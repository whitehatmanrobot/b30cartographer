  ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BasicConstraints2(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->cA)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->cA))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->pathLenConstraint))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BasicConstraints2(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->cA))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->pathLenConstraint))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->cA = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CertificatePolicies(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyInformation(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatePolicies(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (PolicyInformation *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_PolicyInformation(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatePolicies(CertificatePolicies *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyInformation(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyInformation(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyQualifiers(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifiers *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyQualifierInfo(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyQualifiers(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (PolicyQualifierInfo *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_PolicyQualifierInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyQualifiers(PolicyQualifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyQualifierInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyQualifierInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyQualifierInfo(ASN1encoding_t enc, ASN1uint32_t tag, PolicyQualifierInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->policyQualifierId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->qualifier))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyQualifierInfo(ASN1decoding_t dec, ASN1uint32_t tag, PolicyQualifierInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->policyQualifierId))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->qualifier))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyQualifierInfo(PolicyQualifierInfo *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->policyQualifierId);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_NoticeReference(ASN1encoding_t enc, ASN1uint32_t tag, NoticeReference *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->organization);
    if (!ASN1DEREncCharString(enc, 0x16, t, (val)->organization))
	return 0;
    if (!ASN1Enc_NoticeReference_noticeNumbers(enc, 0, &(val)->noticeNumbers))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NoticeReference(ASN1decoding_t dec, ASN1uint32_t tag, NoticeReference *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->organization))
	return 0;
    if (!ASN1Dec_NoticeReference_noticeNumbers(dd, 0, &(val)->noticeNumbers))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NoticeReference(NoticeReference *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->organization);
	ASN1Free_NoticeReference_noticeNumbers(&(val)->noticeNumbers);
    }
}

static int ASN1CALL ASN1Enc_DisplayText(ASN1encoding_t enc, ASN1uint32_t tag, DisplayText *val)
{
    ASN1uint32_t t;
    switch ((val)->choice) {
    case 1:
	t = lstrlenA((val)->u.theVisibleString);
	if (!ASN1DEREncCharString(enc, 0x1a, t, (val)->u.theVisibleString))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->u.theBMPString).length, ((val)->u.theBMPString).value))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisplayText(ASN1decoding_t dec, ASN1uint32_t tag, DisplayText *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x1a:
	(val)->choice = 1;
	if (!ASN1BERDecZeroCharString(dec, 0x1a, &(val)->u.theVisibleString))
	    return 0;
	break;
    case 0x1e:
	(val)->choice = 2;
	if (!ASN1BERDecChar16String(dec, 0x1e, &(val)->u.theBMPString))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisplayText(DisplayText *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1ztcharstring_free((val)->u.theVisibleString);
	    break;
	case 2:
	    ASN1char16string_free(&(val)->u.theBMPString);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CertificatePolicies95(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePolicies95 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyQualifiers(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatePolicies95(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePolicies95 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (PolicyQualifiers *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_PolicyQualifiers(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatePolicies95(CertificatePolicies95 *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyQualifiers(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyQualifiers(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CpsURLs(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_CpsURLs_Seq(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpsURLs(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CpsURLs_Seq *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_CpsURLs_Seq(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpsURLs(CpsURLs *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CpsURLs_Seq(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CpsURLs_Seq(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AuthorityKeyId2(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityKeyId2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_GeneralNames(enc, 0x80000001, &(val)->authorityCertIssuer))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x80000002, &(val)->authorityCertSerialNumber))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityKeyId2(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityKeyId2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x80000000, &(val)->keyIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_GeneralNames(dd, 0x80000001, &(val)->authorityCertIssuer))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x80000002, &(val)->authorityCertSerialNumber))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityKeyId2(AuthorityKeyId2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_GeneralNames(&(val)->authorityCertIssuer);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->authorityCertSerialNumber);
	}
    }
}

static int ASN1CALL ASN1Enc_AuthorityInfoAccess(ASN1encoding_t enc, ASN1uint32_t tag, AuthorityInfoAccess *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_AccessDescription(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthorityInfoAccess(ASN1decoding_t dec, ASN1uint32_t tag, AuthorityInfoAccess *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (AccessDescription *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_AccessDescription(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthorityInfoAccess(AuthorityInfoAccess *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AccessDescription(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AccessDescription(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CRLDistributionPoints(ASN1encoding_t enc, ASN1uint32_t tag, CRLDistributionPoints *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_DistributionPoint(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRLDistributionPoints(ASN1decoding_t dec, ASN1uint32_t tag, CRLDistributionPoints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (DistributionPoint *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_DistributionPoint(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CRLDistributionPoints(CRLDistributionPoints *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_DistributionPoint(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_DistributionPoint(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DistributionPointName(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPointName *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_GeneralNames(enc, 0x80000000, &(val)->u.fullName))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_RelativeDistinguishedName(enc, 0x80000001, &(val)->u.nameRelativeToCRLIssuer))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DistributionPointName(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPointName *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_GeneralNames(dec, 0x80000000, &(val)->u.fullName))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_RelativeDistinguishedName(dec, 0x80000001, &(val)->u.nameRelativeToCRLIssuer))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DistributionPointName(DistributionPointName *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_GeneralNames(&(val)->u.fullName);
	    break;
	case 2:
	    ASN1Free_RelativeDistinguishedName(&(val)->u.nameRelativeToCRLIssuer);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentType);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_SeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SeqOfAny *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncOpenType(enc, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SeqOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (NOCOPYANY *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SeqOfAny(SeqOfAny *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TimeStampRequest(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->timeStampAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->attributesTS))
	    return 0;
    }
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->content))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TimeStampRequest(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->timeStampAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->attributesTS))
	    return 0;
    }
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->content))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TimeStampRequest(TimeStampRequest *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->timeStampAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributesTS);
	}
	ASN1Free_ContentInfo(&(val)->content);
    }
}

static int ASN1CALL ASN1Enc_ContentInfoOTS(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoOTS *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentTypeOTS))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->contentOTS).length, ((val)->contentOTS).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoOTS(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoOTS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentTypeOTS))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString2(dd0, 0x4, &(val)->contentOTS))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoOTS(ContentInfoOTS *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentTypeOTS);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_TimeStampRequestOTS(ASN1encoding_t enc, ASN1uint32_t tag, TimeStampRequestOTS *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->timeStampAlgorithmOTS))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->attributesOTS))
	    return 0;
    }
    if (!ASN1Enc_ContentInfoOTS(enc, 0, &(val)->contentOTS))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TimeStampRequestOTS(ASN1decoding_t dec, ASN1uint32_t tag, TimeStampRequestOTS *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->timeStampAlgorithmOTS))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->attributesOTS))
	    return 0;
    }
    if (!ASN1Dec_ContentInfoOTS(dd, 0, &(val)->contentOTS))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TimeStampRequestOTS(TimeStampRequestOTS *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->timeStampAlgorithmOTS);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributesOTS);
	}
	ASN1Free_ContentInfoOTS(&(val)->contentOTS);
    }
}

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncEoid(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (UsageIdentifier *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecEoid(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1BEREoid_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1BEREoid_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SubjectUsage(ASN1encoding_t enc, ASN1uint32_t tag, SubjectUsage *val)
{
    if (!ASN1Enc_EnhancedKeyUsage(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubjectUsage(ASN1decoding_t dec, ASN1uint32_t tag, SubjectUsage *val)
{
    if (!ASN1Dec_EnhancedKeyUsage(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SubjectUsage(SubjectUsage *val)
{
    if (val) {
	ASN1Free_EnhancedKeyUsage(val);
    }
}

static int ASN1CALL ASN1Enc_TrustedSubjects(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubjects *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TrustedSubject(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TrustedSubjects(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubjects *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (TrustedSubject *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_TrustedSubject(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TrustedSubjects(TrustedSubjects *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TrustedSubject(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TrustedSubject(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TrustedSubject(ASN1encoding_t enc, ASN1uint32_t tag, TrustedSubject *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->subjectIdentifier).length, ((val)->subjectIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->subjectAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TrustedSubject(ASN1decoding_t dec, ASN1uint32_t tag, TrustedSubject *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->subjectIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->subjectAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TrustedSubject(TrustedSubject *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->subjectAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EnrollmentNameValuePair(ASN1encoding_t enc, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->name).length, ((val)->name).value))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->value).length, ((val)->value).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnrollmentNameValuePair(ASN1decoding_t dec, ASN1uint32_t tag, EnrollmentNameValuePair *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->name))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnrollmentNameValuePair(EnrollmentNameValuePair *val)
{
    if (val) {
	ASN1char16string_free(&(val)->name);
	ASN1char16string_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_CSPProvider(ASN1encoding_t enc, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->keySpec))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->cspName).length, ((val)->cspName).value))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->signature).length, ((val)->signature).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CSPProvider(ASN1decoding_t dec, ASN1uint32_t tag, CSPProvider *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->keySpec))
	return 0;
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->cspName))
	return 0;
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->signature))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CSPProvider(CSPProvider *val)
{
    if (val) {
	ASN1char16string_free(&(val)->cspName);
    }
}

static int ASN1CALL ASN1Enc_CertificatePair(ASN1encoding_t enc, ASN1uint32_t tag, CertificatePair *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->forward))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->reverse))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatePair(ASN1decoding_t dec, ASN1uint32_t tag, CertificatePair *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->forward))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000001) {
	    (val)->o[0] |= 0x40;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->reverse))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatePair(CertificatePair *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_GeneralSubtrees(ASN1encoding_t enc, ASN1uint32_t tag, GeneralSubtrees *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_GeneralSubtree(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralSubtrees(ASN1decoding_t dec, ASN1uint32_t tag, GeneralSubtrees *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (GeneralSubtree *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_GeneralSubtree(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GeneralSubtrees(GeneralSubtrees *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_GeneralSubtree(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_GeneralSubtree(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_IssuingDistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, IssuingDistributionPoint *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->onlyContainsUserCerts)
	o[0] &= ~0x40;
    if (!(val)->onlyContainsCACerts)
	o[0] &= ~0x20;
    if (!(val)->indirectCRL)
	o[0] &= ~0x8;
    if (o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_DistributionPointName(enc, 0, &(val)->issuingDistributionPoint))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncBool(enc, 0x80000001, (val)->onlyContainsUserCerts))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1BEREncBool(enc, 0x80000002, (val)->onlyContainsCACerts))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1DEREncBitString(enc, 0x80000003, ((val)->onlySomeReasons).length, ((val)->onlySomeReasons).value))
	    return 0;
    }
    if (o[0] & 0x8) {
	if (!ASN1BEREncBool(enc, 0x80000004, (val)->indirectCRL))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuingDistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, IssuingDistributionPoint *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_DistributionPointName(dd0, 0, &(val)->issuingDistributionPoint))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBool(dd, 0x80000001, &(val)->onlyContainsUserCerts))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecBool(dd, 0x80000002, &(val)->onlyContainsCACerts))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecBitString2(dd, 0x80000003, &(val)->onlySomeReasons))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecBool(dd, 0x80000004, &(val)->indirectCRL))
	    return 0;
    }
    if (!((val)->o[0] & 0x40))
	(val)->onlyContainsUserCerts = 0;
    if (!((val)->o[0] & 0x20))
	(val)->onlyContainsCACerts = 0;
    if (!((val)->o[0] & 0x8))
	(val)->indirectCRL = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuingDistributionPoint(IssuingDistributionPoint *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DistributionPointName(&(val)->issuingDistributionPoint);
	}
	if ((val)->o[0] & 0x10) {
	}
    }
}

static int ASN1CALL ASN1Enc_CrossCertDistPointNames(ASN1encoding_t enc, ASN1uint32_t tag, CrossCertDistPointNames *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_GeneralNames(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CrossCertDistPointNames(ASN1decoding_t dec, ASN1uint32_t tag, CrossCertDistPointNames *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (GeneralNames *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_GeneralNames(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CrossCertDistPointNames(CrossCertDistPointNames *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_GeneralNames(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_GeneralNames(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyMappings(ASN1encoding_t enc, ASN1uint32_t tag, PolicyMappings *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_PolicyMapping(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyMappings(ASN1decoding_t dec, ASN1uint32_t tag, PolicyMappings *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (PolicyMapping *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_PolicyMapping(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyMappings(PolicyMappings *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PolicyMapping(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PolicyMapping(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PolicyMapping(ASN1encoding_t enc, ASN1uint32_t tag, PolicyMapping *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->issuerDomainPolicy))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->subjectDomainPolicy))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyMapping(ASN1decoding_t dec, ASN1uint32_t tag, PolicyMapping *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->issuerDomainPolicy))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->subjectDomainPolicy))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyMapping(PolicyMapping *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->issuerDomainPolicy);
	ASN1BEREoid_free(&(val)->subjectDomainPolicy);
    }
}

static int ASN1CALL ASN1Enc_PolicyConstraints(ASN1encoding_t enc, ASN1uint32_t tag, PolicyConstraints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x80000000, (val)->requireExplicitPolicy))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncU32(enc, 0x80000001, (val)->inhibitPolicyMapping))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyConstraints(ASN1decoding_t dec, ASN1uint32_t tag, PolicyConstraints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecU32Val(dd, 0x80000000, (ASN1uint32_t *) &(val)->requireExplicitPolicy))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecU32Val(dd, 0x80000001, (ASN1uint32_t *) &(val)->inhibitPolicyMapping))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ControlSequence(ASN1encoding_t enc, ASN1uint32_t tag, ControlSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedAttribute(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ControlSequence(ASN1decoding_t dec, ASN1uint32_t tag, ControlSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (TaggedAttribute *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_TaggedAttribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ControlSequence(ControlSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedAttribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedAttribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ReqSequence(ASN1encoding_t enc, ASN1uint32_t tag, ReqSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedRequest(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReqSequence(ASN1decoding_t dec, ASN1uint32_t tag, ReqSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (TaggedRequest *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_TaggedRequest(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReqSequence(ReqSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedRequest(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedRequest(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CmsSequence(ASN1encoding_t enc, ASN1uint32_t tag, CmsSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedContentInfo(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsSequence(ASN1decoding_t dec, ASN1uint32_t tag, CmsSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (TaggedContentInfo *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_TaggedContentInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsSequence(CmsSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedContentInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedContentInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_OtherMsgSequence(ASN1encoding_t enc, ASN1uint32_t tag, OtherMsgSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_TaggedOtherMsg(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherMsgSequence(ASN1decoding_t dec, ASN1uint32_t tag, OtherMsgSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (TaggedOtherMsg *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_TaggedOtherMsg(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherMsgSequence(OtherMsgSequence *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_TaggedOtherMsg(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_TaggedOtherMsg(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BodyPartIDSequence(ASN1encoding_t enc, ASN1uint32_t tag, BodyPartIDSequence *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncU32(enc, 0x2, ((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BodyPartIDSequence(ASN1decoding_t dec, ASN1uint32_t tag, BodyPartIDSequence *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (BodyPartID *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BodyPartIDSequence(BodyPartIDSequence *val)
{
    if (val) {
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_TaggedAttribute(ASN1encoding_t enc, ASN1uint32_t tag, TaggedAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedAttribute(ASN1decoding_t dec, ASN1uint32_t tag, TaggedAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedAttribute(TaggedAttribute *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_TaggedCertificationRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedCertificationRequest *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->certificationRequest))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedCertificationRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedCertificationRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->certificationRequest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedCertificationRequest(TaggedCertificationRequest *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TaggedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, TaggedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->contentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, TaggedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->contentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedContentInfo(TaggedContentInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TaggedOtherMsg(ASN1encoding_t enc, ASN1uint32_t tag, TaggedOtherMsg *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->bodyPartID))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->otherMsgType))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->otherMsgValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedOtherMsg(ASN1decoding_t dec, ASN1uint32_t tag, TaggedOtherMsg *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->bodyPartID))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->otherMsgType))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->otherMsgValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TaggedOtherMsg(TaggedOtherMsg *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->otherMsgType);
    }
}

static int ASN1CALL ASN1Enc_PendInfo(ASN1encoding_t enc, ASN1uint32_t tag, PendInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->pendToken).length, ((val)->pendToken).value))
	return 0;
    if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->pendTime))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PendInfo(ASN1decoding_t dec, ASN1uint32_t tag, PendInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->pendToken))
	return 0;
    if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->pendTime))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PendInfo(PendInfo *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CmcAddExtensions(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddExtensions *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pkiDataReference))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Enc_Extensions(enc, 0, &(val)->extensions))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcAddExtensions(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddExtensions *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pkiDataReference))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Dec_Extensions(dd, 0, &(val)->extensions))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcAddExtensions(CmcAddExtensions *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->certReferences);
	ASN1Free_Extensions(&(val)->extensions);
    }
}

static int ASN1CALL ASN1Enc_CmcAddAttributes(ASN1encoding_t enc, ASN1uint32_t tag, CmcAddAttributes *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->pkiDataReference))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Enc_Attributes(enc, 0, &(val)->attributes))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcAddAttributes(ASN1decoding_t dec, ASN1uint32_t tag, CmcAddAttributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->pkiDataReference))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->certReferences))
	return 0;
    if (!ASN1Dec_Attributes(dd, 0, &(val)->attributes))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcAddAttributes(CmcAddAttributes *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->certReferences);
	ASN1Free_Attributes(&(val)->attributes);
    }
}

static int ASN1CALL ASN1Enc_CertificateTemplate(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTemplate *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->templateID))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->templateMajorVersion))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x2, (val)->templateMinorVersion))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateTemplate(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTemplate *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->templateID))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->templateMajorVersion))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->templateMinorVersion))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateTemplate(CertificateTemplate *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->templateID);
    }
}

static int ASN1CALL ASN1Enc_CmcStatusInfo_otherInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncU32(enc, 0x2, (val)->u.failInfo))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_PendInfo(enc, 0, &(val)->u.pendInfo))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CmcStatusInfo_otherInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo_otherInfo *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x2:
	(val)->choice = 1;
	if (!ASN1BERDecU32Val(dec, 0x2, (ASN1uint32_t *) &(val)->u.failInfo))
	    return 0;
	break;
    case 0x10:
	(val)->choice = 2;
	if (!ASN1Dec_PendInfo(dec, 0, &(val)->u.pendInfo))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CmcStatusInfo_otherInfo(CmcStatusInfo_otherInfo *val)
{
    if (val) {
	switch ((val)->choice) {
	case 2:
	    ASN1Free_PendInfo(&(val)->u.pendInfo);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CpsURLs_Seq(ASN1encoding_t enc, ASN1uint32_t tag, CpsURLs_Seq *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->url);
    if (!ASN1DEREncCharString(enc, 0x16, t, (val)->url))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->digestAlgorithmId))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpsURLs_Seq(ASN1decoding_t dec, ASN1uint32_t tag, CpsURLs_Seq *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->url))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->digestAlgorithmId))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->digest))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpsURLs_Seq(CpsURLs_Seq *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->url);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AlgorithmIdentifier(&(val)->digestAlgorithmId);
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->type);
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}

static int ASN1CALL ASN1Enc_X942DhParameters(ASN1encoding_t enc, ASN1uint32_t tag, X942DhParameters *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->p))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->g))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->q))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->j))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_X942DhValidationParams(enc, 0, &(val)->validationParams))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhParameters(ASN1decoding_t dec, ASN1uint32_t tag, X942DhParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->p))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->g))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->q))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->j))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_X942DhValidationParams(dd, 0, &(val)->validationParams))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhParameters(X942DhParameters *val)
{
    if (val) {
	ASN1intx_free(&(val)->p);
	ASN1intx_free(&(val)->g);
	ASN1intx_free(&(val)->q);
	if ((val)->o[0] & 0x80) {
	    ASN1intx_free(&(val)->j);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_X942DhValidationParams(&(val)->validationParams);
	}
    }
}

static int ASN1CALL ASN1Enc_X942DhOtherInfo(ASN1encoding_t enc, ASN1uint32_t tag, X942DhOtherInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_X942DhKeySpecificInfo(enc, 0, &(val)->keyInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->pubInfo).length, ((val)->pubInfo).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyLength).length, ((val)->keyLength).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X942DhOtherInfo(ASN1decoding_t dec, ASN1uint32_t tag, X942DhOtherInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_X942DhKeySpecificInfo(dd, 0, &(val)->keyInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString2(dd0, 0x4, &(val)->pubInfo))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOctetString2(dd0, 0x4, &(val)->keyLength))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X942DhOtherInfo(X942DhOtherInfo *val)
{
    if (val) {
	ASN1Free_X942DhKeySpecificInfo(&(val)->keyInfo);
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateToBeSigned *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->version == 0)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->signature))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1Enc_Validity(enc, 0, &(val)->validity))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->subject))
	return 0;
    if (!ASN1Enc_SubjectPublicKeyInfo(enc, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x80000001, ((val)->issuerUniqueIdentifier).length, ((val)->issuerUniqueIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1DEREncBitString(enc, 0x80000002, ((val)->subjectUniqueIdentifier).length, ((val)->subjectUniqueIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->extensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateToBeSigned *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecS32Val(dd0, 0x2, &(val)->version))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->signature))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->issuer))
	return 0;
    if (!ASN1Dec_Validity(dd, 0, &(val)->validity))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->subject))
	return 0;
    if (!ASN1Dec_SubjectPublicKeyInfo(dd, 0, &(val)->subjectPublicKeyInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x80000001, &(val)->issuerUniqueIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecBitString2(dd, 0x80000002, &(val)->subjectUniqueIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->extensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->version = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateToBeSigned(CertificateToBeSigned *val)
{
    if (val) {
	ASN1intx_free(&(val)->serialNumber);
	ASN1Free_AlgorithmIdentifier(&(val)->signature);
	ASN1Free_Validity(&(val)->validity);
	ASN1Free_SubjectPublicKeyInfo(&(val)->subjectPublicKeyInfo);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Extensions(&(val)->extensions);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateRevocationListToBeSigned(ASN1encoding_t enc, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
    }
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->signature))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->thisUpdate))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->nextUpdate))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_RevokedCertificates(enc, 0, &(val)->revokedCertificates))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->crlExtensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateRevocationListToBeSigned(ASN1decoding_t dec, ASN1uint32_t tag, CertificateRevocationListToBeSigned *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	    return 0;
    }
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->signature))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->issuer))
	return 0;
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->thisUpdate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x17 || t == 0x18) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->nextUpdate))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_RevokedCertificates(dd, 0, &(val)->revokedCertificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->crlExtensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateRevocationListToBeSigned(CertificateRevocationListToBeSigned *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->signature);
	ASN1Free_ChoiceOfTime(&(val)->thisUpdate);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ChoiceOfTime(&(val)->nextUpdate);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_RevokedCertificates(&(val)->revokedCertificates);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Extensions(&(val)->crlExtensions);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyAttributes(ASN1encoding_t enc, ASN1uint32_t tag, KeyAttributes *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->keyIdentifier).length, ((val)->keyIdentifier).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->intendedKeyUsage).length, ((val)->intendedKeyUsage).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_PrivateKeyValidity(enc, 0, &(val)->privateKeyUsagePeriod))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyAttributes(ASN1decoding_t dec, ASN1uint32_t tag, KeyAttributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->keyIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x3, &(val)->intendedKeyUsage))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_PrivateKeyValidity(dd, 0, &(val)->privateKeyUsagePeriod))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyAttributes(KeyAttributes *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_PrivateKeyValidity(&(val)->privateKeyUsagePeriod);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyUsageRestriction(ASN1encoding_t enc, ASN1uint32_t tag, KeyUsageRestriction *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertPolicySet(enc, 0, &(val)->certPolicySet))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->restrictedKeyUsage).length, ((val)->restrictedKeyUsage).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyUsageRestriction(ASN1decoding_t dec, ASN1uint32_t tag, KeyUsageRestriction *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertPolicySet(dd, 0, &(val)->certPolicySet))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x3, &(val)->restrictedKeyUsage))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyUsageRestriction(KeyUsageRestriction *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertPolicySet(&(val)->certPolicySet);
	}
	if ((val)->o[0] & 0x40) {
	}
    }
}

static int ASN1CALL ASN1Enc_GeneralName(ASN1encoding_t enc, ASN1uint32_t tag, GeneralName *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_OtherName(enc, 0x80000000, &(val)->u.otherName))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncCharString(enc, 0x80000001, ((val)->u.rfc822Name).length, ((val)->u.rfc822Name).value))
	    return 0;
	break;
    case 3:
	if (!ASN1DEREncCharString(enc, 0x80000002, ((val)->u.dNSName).length, ((val)->u.dNSName).value))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_SeqOfAny(enc, 0x80000003, &(val)->u.x400Address))
	    return 0;
	break;
    case 5:
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->u.directoryName))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 6:
	if (!ASN1Enc_SeqOfAny(enc, 0x80000005, &(val)->u.ediPartyName))
	    return 0;
	break;
    case 7:
	if (!ASN1DEREncCharString(enc, 0x80000006, ((val)->u.uniformResourceLocator).length, ((val)->u.uniformResourceLocator).value))
	    return 0;
	break;
    case 8:
	if (!ASN1DEREncOctetString(enc, 0x80000007, ((val)->u.iPAddress).length, ((val)->u.iPAddress).value))
	    return 0;
	break;
    case 9:
	if (!ASN1BEREncEoid(enc, 0x80000008, &(val)->u.registeredID))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralName(ASN1decoding_t dec, ASN1uint32_t tag, GeneralName *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_OtherName(dec, 0x80000000, &(val)->u.otherName))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecCharString(dec, 0x80000001, &(val)->u.rfc822Name))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecCharString(dec, 0x80000002, &(val)->u.dNSName))
	    return 0;
	break;
    case 0x80000003:
	(val)->choice = 4;
	if (!ASN1Dec_SeqOfAny(dec, 0x80000003, &(val)->u.x400Address))
	    return 0;
	break;
    case 0x80000004:
	(val)->choice = 5;
	if (!ASN1BERDecExplicitTag(dec, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOpenType2(dd0, &(val)->u.directoryName))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000005:
	(val)->choice = 6;
	if (!ASN1Dec_SeqOfAny(dec, 0x80000005, &(val)->u.ediPartyName))
	    return 0;
	break;
    case 0x80000006:
	(val)->choice = 7;
	if (!ASN1BERDecCharString(dec, 0x80000006, &(val)->u.uniformResourceLocator))
	    return 0;
	break;
    case 0x80000007:
	(val)->choice = 8;
	if (!ASN1BERDecOctetString2(dec, 0x80000007, &(val)->u.iPAddress))
	    return 0;
	break;
    case 0x80000008:
	(val)->choice = 9;
	if (!ASN1BERDecEoid(dec, 0x80000008, &(val)->u.registeredID))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GeneralName(GeneralName *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_OtherName(&(val)->u.otherName);
	    break;
	case 2:
	    ASN1charstring_free(&(val)->u.rfc822Name);
	    break;
	case 3:
	    ASN1charstring_free(&(val)->u.dNSName);
	    break;
	case 4:
	    ASN1Free_SeqOfAny(&(val)->u.x400Address);
	    break;
	case 5:
	    break;
	case 6:
	    ASN1Free_SeqOfAny(&(val)->u.ediPartyName);
	    break;
	case 7:
	    ASN1charstring_free(&(val)->u.uniformResourceLocator);
	    break;
	case 8:
	    break;
	case 9:
	    ASN1BEREoid_free(&(val)->u.registeredID);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_BasicConstraints(ASN1encoding_t enc, ASN1uint32_t tag, BasicConstraints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->subjectType).length, ((val)->subjectType).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->pathLenConstraint))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_SubtreesConstraint(enc, 0, &(val)->subtreesConstraint))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BasicConstraints(ASN1decoding_t dec, ASN1uint32_t tag, BasicConstraints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecBitString2(dd, 0x3, &(val)->subjectType))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->pathLenConstraint))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_SubtreesConstraint(dd, 0, &(val)->subtreesConstraint))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BasicConstraints(BasicConstraints *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1Free_SubtreesConstraint(&(val)->subtreesConstraint);
	}
    }
}

static int ASN1CALL ASN1Enc_PolicyInformation(ASN1encoding_t enc, ASN1uint32_t tag, PolicyInformation *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->policyIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PolicyQualifiers(enc, 0, &(val)->policyQualifiers))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PolicyInformation(ASN1decoding_t dec, ASN1uint32_t tag, PolicyInformation *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->policyIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_PolicyQualifiers(dd, 0, &(val)->policyQualifiers))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PolicyInformation(PolicyInformation *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->policyIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PolicyQualifiers(&(val)->policyQualifiers);
	}
    }
}

static int ASN1CALL ASN1Enc_UserNotice(ASN1encoding_t enc, ASN1uint32_t tag, UserNotice *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_NoticeReference(enc, 0, &(val)->noticeRef))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_DisplayText(enc, 0, &(val)->explicitText))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserNotice(ASN1decoding_t dec, ASN1uint32_t tag, UserNotice *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_NoticeReference(dd, 0, &(val)->noticeRef))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1a || t == 0x1e) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_DisplayText(dd, 0, &(val)->explicitText))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UserNotice(UserNotice *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_NoticeReference(&(val)->noticeRef);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_DisplayText(&(val)->explicitText);
	}
    }
}

static int ASN1CALL ASN1Enc_VerisignQualifier1(ASN1encoding_t enc, ASN1uint32_t tag, VerisignQualifier1 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->practicesReference);
	if (!ASN1DEREncCharString(enc, 0x16, t, (val)->practicesReference))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncEoid(enc, 0x6, &(val)->noticeId))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncEoid(enc, 0x6, &(val)->nsiNoticeId))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_CpsURLs(enc, 0, &(val)->cpsURLs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VerisignQualifier1(ASN1decoding_t dec, ASN1uint32_t tag, VerisignQualifier1 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x16) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->practicesReference))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecEoid(dd0, 0x6, &(val)->noticeId))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecEoid(dd0, 0x6, &(val)->nsiNoticeId))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x10;
	if (!ASN1Dec_CpsURLs(dd, 0, &(val)->cpsURLs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_VerisignQualifier1(VerisignQualifier1 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->practicesReference);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1BEREoid_free(&(val)->noticeId);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1BEREoid_free(&(val)->nsiNoticeId);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_CpsURLs(&(val)->cpsURLs);
	}
    }
}

static int ASN1CALL ASN1Enc_AccessDescription(ASN1encoding_t enc, ASN1uint32_t tag, AccessDescription *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->accessMethod))
	return 0;
    if (!ASN1Enc_GeneralName(enc, 0, &(val)->accessLocation))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AccessDescription(ASN1decoding_t dec, ASN1uint32_t tag, AccessDescription *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->accessMethod))
	return 0;
    if (!ASN1Dec_GeneralName(dd, 0, &(val)->accessLocation))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AccessDescription(AccessDescription *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->accessMethod);
	ASN1Free_GeneralName(&(val)->accessLocation);
    }
}

static int ASN1CALL ASN1Enc_DistributionPoint(ASN1encoding_t enc, ASN1uint32_t tag, DistributionPoint *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_DistributionPointName(enc, 0, &(val)->distributionPoint))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1DEREncBitString(enc, 0x80000001, ((val)->reasons).length, ((val)->reasons).value))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_GeneralNames(enc, 0x80000002, &(val)->cRLIssuer))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DistributionPoint(ASN1decoding_t dec, ASN1uint32_t tag, DistributionPoint *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_DistributionPointName(dd0, 0, &(val)->distributionPoint))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecBitString2(dd, 0x80000001, &(val)->reasons))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1Dec_GeneralNames(dd, 0x80000002, &(val)->cRLIssuer))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DistributionPoint(DistributionPoint *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_DistributionPointName(&(val)->distributionPoint);
	}
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_GeneralNames(&(val)->cRLIssuer);
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfoSeqOfAny(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoSeqOfAny *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncEoid(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_SeqOfAny(enc, 0, &(val)->contentSeqOfAny))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoSeqOfAny(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoSeqOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecEoid(dd, 0x6, &(val)->contentType))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_SeqOfAny(dd0, 0, &(val)->contentSeqOfAny))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoSeqOfAny(ContentInfoSeqOfAny *val)
{
    if (val) {
	ASN1BEREoid_free(&(val)->contentType);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SeqOfAny(&(val)->contentSeqOfAny);
	}
    }
}

static int ASN1CALL ASN1Enc_CertificateTrustList(ASN1encoding_t enc, ASN1uint32_t tag, CertificateTrustList *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->version == 0)
	o[0] &= ~0x80;
    if (o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
    }
    if (!ASN1Enc_SubjectUsage(enc, 0, &(val)->subjectUsage))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->listIdentifier).length, ((val)->listIdentifier).value))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1BEREncSX(enc, 0x2, &(val)->sequenceNumber))
	    return 0;
    }
    if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->ctlThisUpdate))
	return 0;
    if (o[0] & 0x10) {
	if (!ASN1Enc_ChoiceOfTime(enc, 0, &(val)->ctlNextUpdate))
	    return 0;
    }
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->subjectAlgorithm))
	return 0;
    if (o[0] & 0x8) {
	if (!ASN1Enc_TrustedSubjects(enc, 0, &(val)->trustedSubjects))
	    return 0;
    }
    if (o[0] & 0x4) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_Extensions(enc, 0, &(val)->ctlExtensions))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificateTrustList(ASN1decoding_t dec, ASN1uint32_t tag, CertificateTrustList *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	    return 0;
    }
    if (!ASN1Dec_SubjectUsage(dd, 0, &(val)->subjectUsage))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x4) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->listIdentifier))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecSXVal(dd, 0x2, &(val)->sequenceNumber))
	    return 0;
    }
    if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->ctlThisUpdate))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x17 || t == 0x18) {
	(val)->o[0] |= 0x10;
	if (!ASN1Dec_ChoiceOfTime(dd, 0, &(val)->ctlNextUpdate))
	    return 0;
    }
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->subjectAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x8;
	if (!ASN1Dec_TrustedSubjects(dd, 0, &(val)->trustedSubjects))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x4;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_Extensions(dd0, 0, &(val)->ctlExtensions))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->version = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificateTrustList(CertificateTrustList *val)
{
    if (val) {
	ASN1Free_SubjectUsage(&(val)->subjectUsage);
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1intx_free(&(val)->sequenceNumber);
	}
	ASN1Free_ChoiceOfTime(&(val)->ctlThisUpdate);
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ChoiceOfTime(&(val)->ctlNextUpdate);
	}
	ASN1Free_AlgorithmIdentifier(&(val)->subjectAlgorithm);
	if ((val)->o[0] & 0x8) {
	    ASN1Free_TrustedSubjects(&(val)->trustedSubjects);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_Extensions(&(val)->ctlExtensions);
	}
    }
}

static int ASN1CALL ASN1Enc_NameConstraints(ASN1encoding_t enc, ASN1uint32_t tag, NameConstraints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_GeneralSubtrees(enc, 0x80000000, &(val)->permittedSubtrees))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_GeneralSubtrees(enc, 0x80000001, &(val)->excludedSubtrees))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NameConstraints(ASN1decoding_t dec, ASN1uint32_t tag, NameConstraints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_GeneralSubtrees(dd, 0x80000000, &(val)->permittedSubtrees))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_GeneralSubtrees(dd, 0x80000001, &(val)->excludedSubtrees))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NameConstraints(NameConstraints *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_GeneralSubtrees(&(val)->permittedSubtrees);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_GeneralSubtrees(&(val)->excludedSubtrees);
	}
    }
}

static int ASN1CALL ASN1Enc_GeneralSubtree(ASN1encoding_t enc, ASN1uint32_t tag, GeneralSubtree *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->minimum == 0)
	o[0] &= ~0x80;
    if (!ASN1Enc_GeneralName(enc, 0, &(val)->base))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x80000000, (val)->minimum))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncU32(enc, 0x80000001, (val)->maximum))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GeneralSubtree(ASN1decoding_t dec, ASN1uint32_t tag, GeneralSubtree *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_GeneralName(dd, 0, &(val)->base))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecU32Val(dd, 0x80000000, (ASN1uint32_t *) &(val)->minimum))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecU32Val(dd, 0x80000001, (ASN1uint32_t *) &(val)->maximum))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->minimum = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_GeneralSubtree(GeneralSubtree *val)
{
    if (val) {
	ASN1Free_GeneralName(&(val)->base);
    }
}

static int ASN1CALL ASN1Enc_CrossCertDistPoints(ASN1encoding_t enc, ASN1uint32_t tag, CrossCertDistPoints *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncU32(enc, 0x2, (val)->syncDeltaTime))
	    return 0;
    }
    if (!ASN1Enc_CrossCertDistPointNames(enc, 0, &(val)->crossCertDistPointNames))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CrossCertDistPoints(ASN1decoding_t dec, ASN1uint32_t tag, CrossCertDistPoints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->syncDeltaTime))
	    return 0;
    }
    if (!ASN1Dec_CrossCertDistPointNames(dd, 0, &(val)->crossCertDistPointNames))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CrossCertDistPoints(CrossCertDistPoints *val)
{
    if (val) {
	ASN1Free_CrossCertDistPointNames(&(val)->crossCertDistPointNames);
    }
}

static int ASN1CALL ASN1Enc_CmcData(ASN1encoding_t enc, ASN1uint32_t tag, CmcData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ControlSequence(enc, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Enc_ReqSequence(enc, 0, &(val)->reqSequence))
	return 0;
    if (!ASN1Enc_CmsSequence(enc, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Enc_OtherMsgSequence(enc, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcData(ASN1decoding_t dec, ASN1uint32_t tag, CmcData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ControlSequence(dd, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Dec_ReqSequence(dd, 0, &(val)->reqSequence))
	return 0;
    if (!ASN1Dec_CmsSequence(dd, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Dec_OtherMsgSequence(dd, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcData(CmcData *val)
{
    if (val) {
	ASN1Free_ControlSequence(&(val)->controlSequence);
	ASN1Free_ReqSequence(&(val)->reqSequence);
	ASN1Free_CmsSequence(&(val)->cmsSequence);
	ASN1Free_OtherMsgSequence(&(val)->otherMsgSequence);
    }
}

static int ASN1CALL ASN1Enc_CmcResponseBody(ASN1encoding_t enc, ASN1uint32_t tag, CmcResponseBody *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ControlSequence(enc, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Enc_CmsSequence(enc, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Enc_OtherMsgSequence(enc, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcResponseBody(ASN1decoding_t dec, ASN1uint32_t tag, CmcResponseBody *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ControlSequence(dd, 0, &(val)->controlSequence))
	return 0;
    if (!ASN1Dec_CmsSequence(dd, 0, &(val)->cmsSequence))
	return 0;
    if (!ASN1Dec_OtherMsgSequence(dd, 0, &(val)->otherMsgSequence))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcResponseBody(CmcResponseBody *val)
{
    if (val) {
	ASN1Free_ControlSequence(&(val)->controlSequence);
	ASN1Free_CmsSequence(&(val)->cmsSequence);
	ASN1Free_OtherMsgSequence(&(val)->otherMsgSequence);
    }
}

static int ASN1CALL ASN1Enc_TaggedRequest(ASN1encoding_t enc, ASN1uint32_t tag, TaggedRequest *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_TaggedCertificationRequest(enc, 0x80000000, &(val)->u.tcr))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TaggedRequest(ASN1decoding_t dec, ASN1uint32_t tag, TaggedRequest *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1Dec_TaggedCertificationRequest(dec, 0x80000000, &(val)->u.tcr))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TaggedRequest(TaggedRequest *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_TaggedCertificationRequest(&(val)->u.tcr);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CmcStatusInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmcStatusInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->cmcStatus))
	return 0;
    if (!ASN1Enc_BodyPartIDSequence(enc, 0, &(val)->bodyList))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncUTF8String(enc, 0xc, ((val)->statusString).length, ((val)->statusString).value))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CmcStatusInfo_otherInfo(enc, 0, &(val)->otherInfo))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmcStatusInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmcStatusInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->cmcStatus))
	return 0;
    if (!ASN1Dec_BodyPartIDSequence(dd, 0, &(val)->bodyList))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0xc) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecUTF8String(dd, 0xc, &(val)->statusString))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2 || t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CmcStatusInfo_otherInfo(dd, 0, &(val)->otherInfo))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmcStatusInfo(CmcStatusInfo *val)
{
    if (val) {
	ASN1Free_BodyPartIDSequence(&(val)->bodyList);
	if ((val)->o[0] & 0x80) {
	    ASN1utf8string_free(&(val)->statusString);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CmcStatusInfo_otherInfo(&(val)->otherInfo);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\callctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       callctx.h
//
//  Contents:   Certificate Chaining Infrastructure Call Context
//
//  History:    02-Mar-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CALLCTX_H__)
#define __CALLCTX_H__

#include <chain.h>

#define DEFAULT_CREATION_CACHE_BUCKETS 13

// The first revocation URL retrieval uses half of this timeout
#define DEFAULT_REV_ACCUMULATIVE_URL_RETRIEVAL_TIMEOUT 20000

//
// The call context object provides a mechanism for packaging and passing
// around per-call data in the certificate chaining infrastructure.
//

class CChainCallContext
{
public:

    //
    // Construction
    //

    CChainCallContext (
          IN PCCERTCHAINENGINE pChainEngine,
          IN OPTIONAL LPFILETIME pRequestedTime,
          IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
          IN DWORD dwFlags,
          OUT BOOL& rfResult
          );

    ~CChainCallContext ();

    inline PCCERTCHAINENGINE ChainEngine();

    inline VOID CurrentTime (
                    OUT LPFILETIME pCurrentTime
                    );
    inline VOID RequestedTime (
                    OUT LPFILETIME pCurrentTime
                    );

    inline PCERT_CHAIN_PARA ChainPara();
    inline BOOL HasDefaultUrlRetrievalTimeout ();

    DWORD RevocationUrlRetrievalTimeout();
    DWORD AIAUrlRetrievalTimeout();

    inline DWORD AIAUrlRetrievalCount();
    inline VOID IncrementAIAUrlRetrievalCount();

    inline DWORD CallFlags();
    inline DWORD EngineFlags();
    inline DWORD CallOrEngineFlags();

    //
    // Cert Object Creation Cache
    //
    // This caches all certificate objects created in the context of this
    // call.
    //

    BOOL AddPathObjectToCreationCache (
            IN PCCHAINPATHOBJECT pPathObject
            );

    VOID RemovePathObjectFromCreationCache (
            IN PCCHAINPATHOBJECT pPathObject
            );

    PCCHAINPATHOBJECT FindPathObjectInCreationCache (
                     IN BYTE rgbCertHash[ CHAINHASHLEN ]
                     );

    inline VOID FlushObjectsInCreationCache( );

    BOOL IsOnline ();


    //
    // Engine Touching
    //

    inline VOID TouchEngine ();
    BOOL IsTouchedEngine ();
    inline VOID ResetTouchEngine ();


private:

    //
    // Cert Object Creation cache
    //
    // NOTE: LRU is turned off
    //

    HLRUCACHE m_hObjectCreationCache;

    PCCERTCHAINENGINE m_pChainEngine;
    FILETIME m_CurrentTime;
    FILETIME m_RequestedTime;
    CERT_CHAIN_PARA m_ChainPara;
    BOOL m_fDefaultUrlRetrievalTimeout;
    DWORD m_dwCallFlags;

    DWORD m_dwStatus;

    DWORD m_dwTouchEngineCount;

    FILETIME m_RevEndTime;

    DWORD m_dwAIAUrlRetrievalCount;
    FILETIME m_AIAEndTime;
};

#define CHAINCALLCONTEXT_CHECKED_ONLINE_FLAG    0x00000001
#define CHAINCALLCONTEXT_ONLINE_FLAG            0x00010000

#define CHAINCALLCONTEXT_REV_END_TIME_FLAG      0x00000010
#define CHAINCALLCONTEXT_AIA_END_TIME_FLAG      0x00000020


//
// Call Context Utility Functions
//

BOOL WINAPI
CallContextCreateCallObject (
    IN PCCERTCHAINENGINE pChainEngine,
    IN OPTIONAL LPFILETIME pRequestedTime,
    IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
    IN DWORD dwFlags,
    OUT PCCHAINCALLCONTEXT* ppCallContext
    );

VOID WINAPI
CallContextFreeCallObject (
    IN PCCHAINCALLCONTEXT pCallContext
    );

VOID WINAPI
CallContextOnCreationCacheObjectRemoval (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    );

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CChainCallContext::FlushObjectsInCreationCache, public
//
//  Synopsis:   flush the cache of objects
//
//----------------------------------------------------------------------------
inline VOID
CChainCallContext::FlushObjectsInCreationCache( )
{
    I_CryptFlushLruCache( m_hObjectCreationCache, 0, this );
    m_dwAIAUrlRetrievalCount = 0;
}

inline PCCERTCHAINENGINE
CChainCallContext::ChainEngine ()
{
    return( m_pChainEngine);
}

inline VOID
CChainCallContext::RequestedTime (
                    OUT LPFILETIME pRequestedTime
                    )
{
    *pRequestedTime = m_RequestedTime;
}

inline VOID
CChainCallContext::CurrentTime (
                    OUT LPFILETIME pCurrentTime
                    )
{
    *pCurrentTime = m_CurrentTime;
}

inline PCERT_CHAIN_PARA
CChainCallContext::ChainPara()
{
    return( &m_ChainPara );
}

inline BOOL
CChainCallContext::HasDefaultUrlRetrievalTimeout()
{
    return( m_fDefaultUrlRetrievalTimeout );
}

inline DWORD
CChainCallContext::CallFlags ()
{
    return( m_dwCallFlags );
}

inline DWORD
CChainCallContext::EngineFlags ()
{
    return( m_pChainEngine->Flags() );
}

inline DWORD
CChainCallContext::CallOrEngineFlags ()
{
    return( m_dwCallFlags | m_pChainEngine->Flags() );
}


inline VOID
CChainCallContext::TouchEngine ()
{
    m_dwTouchEngineCount = m_pChainEngine->IncrementTouchEngineCount();
}


inline VOID
CChainCallContext::ResetTouchEngine ()
{
    m_dwTouchEngineCount = m_pChainEngine->TouchEngineCount();
}

inline DWORD
CChainCallContext::AIAUrlRetrievalCount ()
{
    return( m_dwAIAUrlRetrievalCount );
}

inline VOID
CChainCallContext::IncrementAIAUrlRetrievalCount ()
{
    m_dwAIAUrlRetrievalCount++;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\chain.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chain.h
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    13-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CHAIN_H__)
#define __CHAIN_H__

#include <windows.h>
#include <wincrypt.h>
#include <winchain.h>
#include <lrucache.h>
#include <md5.h>


// All internal chain hashes are MD5 (16 bytes)
#define CHAINHASHLEN    MD5DIGESTLEN

// Limitation: no support for AES hash algorithm
#define CHAIN_MAX_SIG_HASH_LEN  20
#define CHAIN_MIN_SIG_HASH_LEN  16

//
// Certificate and Path Object Forward class declarations
//

class CCertObject;
class CCertIssuerList;
class CCertObjectCache;
class CCertChainEngine;
class CChainPathObject;

//
// Certificate and Path Object Class pointer typedefs
//

typedef CCertObject*       PCCERTOBJECT;
typedef CCertIssuerList*   PCCERTISSUERLIST;
typedef CCertObjectCache*  PCCERTOBJECTCACHE;
typedef CCertChainEngine*  PCCERTCHAINENGINE;
typedef CChainPathObject*  PCCHAINPATHOBJECT;

//
// SSCTL Forward class declarations
//

class CSSCtlObject;
class CSSCtlObjectCache;

//
// SSCTL Class pointer typedefs
//

typedef class CSSCtlObject*      PCSSCTLOBJECT;
typedef class CSSCtlObjectCache* PCSSCTLOBJECTCACHE;

//
// Call Context Forward class declarations
//

class CChainCallContext;

//
// Call Context class pointer typedefs
//

typedef CChainCallContext* PCCHAINCALLCONTEXT;

//
// Certificate Object Identifier.  This is a unique identifier for a certificate
// object and is the MD5 hash of the issuer and serial no.
//

typedef BYTE CERT_OBJECT_IDENTIFIER[ CHAINHASHLEN ];

//
// CCertObject types
//

#define CERT_END_OBJECT_TYPE                1
#define CERT_CACHED_END_OBJECT_TYPE         2
#define CERT_CACHED_ISSUER_OBJECT_TYPE      3
#define CERT_EXTERNAL_ISSUER_OBJECT_TYPE    4

//
// Issuer match types
//

#define CERT_EXACT_ISSUER_MATCH_TYPE        1
#define CERT_KEYID_ISSUER_MATCH_TYPE        2
#define CERT_NAME_ISSUER_MATCH_TYPE         3
#define CERT_PUBKEY_ISSUER_MATCH_TYPE       4

//
// Issuer match flags
//

#define CERT_MATCH_TYPE_TO_FLAG(MatchType)  (1 << (MatchType - 1))

#define CERT_EXACT_ISSUER_MATCH_FLAG    \
                CERT_MATCH_TYPE_TO_FLAG(CERT_EXACT_ISSUER_MATCH_TYPE)
#define CERT_KEYID_ISSUER_MATCH_FLAG    \
                CERT_MATCH_TYPE_TO_FLAG(CERT_KEYID_ISSUER_MATCH_TYPE)
#define CERT_NAME_ISSUER_MATCH_FLAG     \
                CERT_MATCH_TYPE_TO_FLAG(CERT_NAME_ISSUER_MATCH_TYPE)
#define CERT_PUBKEY_ISSUER_MATCH_FLAG   \
                CERT_MATCH_TYPE_TO_FLAG(CERT_PUBKEY_ISSUER_MATCH_TYPE)


//
// Issuer status flags
//

#define CERT_ISSUER_PUBKEY_FLAG             0x00000001
#define CERT_ISSUER_VALID_SIGNATURE_FLAG    0x00000002
#define CERT_ISSUER_URL_FLAG                0x00000004
#define CERT_ISSUER_PUBKEY_PARA_FLAG        0x00000008
#define CERT_ISSUER_SELF_SIGNED_FLAG        0x00000010
#define CERT_ISSUER_TRUSTED_ROOT_FLAG       0x00000020
#define CERT_ISSUER_EXACT_MATCH_HASH_FLAG   0x00000100
#define CERT_ISSUER_NAME_MATCH_HASH_FLAG    0x00000200

//
// Misc info flags
//

#define CHAIN_INVALID_BASIC_CONSTRAINTS_INFO_FLAG           0x00000001
#define CHAIN_INVALID_ISSUER_NAME_CONSTRAINTS_INFO_FLAG     0x00000002
#define CHAIN_INVALID_KEY_USAGE_FLAG                        0x00000004


//
// CTL cache entry used for a self signed, untrusted root CCertObject
//

typedef struct _CERT_OBJECT_CTL_CACHE_ENTRY CERT_OBJECT_CTL_CACHE_ENTRY,
    *PCERT_OBJECT_CTL_CACHE_ENTRY;
struct _CERT_OBJECT_CTL_CACHE_ENTRY {
    PCSSCTLOBJECT                   pSSCtlObject;   // AddRef'ed
    PCERT_TRUST_LIST_INFO           pTrustListInfo;
    PCERT_OBJECT_CTL_CACHE_ENTRY    pNext;
};


//
// Chain policies and usage info
//

// Issuance and application policy and usage info
typedef struct _CHAIN_ISS_OR_APP_INFO {
    PCERT_POLICIES_INFO             pPolicy;
    PCERT_POLICY_MAPPINGS_INFO      pMappings;
    PCERT_POLICY_CONSTRAINTS_INFO   pConstraints;
    PCERT_ENHKEY_USAGE              pUsage;                 // If NULL, any
    DWORD                           dwFlags;
} CHAIN_ISS_OR_APP_INFO, *PCHAIN_ISS_OR_APP_INFO;

#define CHAIN_INVALID_POLICY_FLAG       0x00000001
#define CHAIN_ANY_POLICY_FLAG           0x00000002

#define CHAIN_ISS_INDEX                 0
#define CHAIN_APP_INDEX                 1
#define CHAIN_ISS_OR_APP_COUNT          2

typedef struct _CHAIN_POLICIES_INFO {
    CHAIN_ISS_OR_APP_INFO           rgIssOrAppInfo[CHAIN_ISS_OR_APP_COUNT];

    PCERT_ENHKEY_USAGE              pPropertyUsage;         // If NULL, any
} CHAIN_POLICIES_INFO, *PCHAIN_POLICIES_INFO;

//
// Subject name constraint info
//

typedef struct _CHAIN_SUBJECT_NAME_CONSTRAINTS_INFO {
    BOOL                            fInvalid;

    // NULL pointer implies not present in the subject certificate
    PCERT_ALT_NAME_INFO             pAltNameInfo;
    PCERT_NAME_INFO                 pUnicodeNameInfo;

    // If the AltNameInfo doesn't have a RFC822 (email) choice, tries to find
    // email attribute (szOID_RSA_emailAddr) in the above pUnicodeNameInfo.
    // Note, not re-allocated.
    PCERT_RDN_ATTR                  pEmailAttr;

    // Set to TRUE if the pAltNameInfo has a DNS choice.
    BOOL                            fHasDnsAltNameEntry;
} CHAIN_SUBJECT_NAME_CONSTRAINTS_INFO, *PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO;

//
// CSSCtlObjectCache::EnumObjects callback data structure used to
// create the linked list of CTL cache entries.
//

typedef struct _CERT_OBJECT_CTL_CACHE_ENUM_DATA {
    BOOL                fResult; 
    DWORD               dwLastError;
    PCCERTOBJECT        pCertObject;
} CERT_OBJECT_CTL_CACHE_ENUM_DATA, *PCERT_OBJECT_CTL_CACHE_ENUM_DATA;


//
// CCertObject.  This is the main object used for caching information
// about a certificate
//

class CCertObject
{
public:

    //
    // Construction
    //

    CCertObject (
        IN DWORD dwObjectType,
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCERT_CONTEXT pCertContext,
        IN BYTE rgbCertHash[CHAINHASHLEN],
        OUT BOOL& rfResult
        );

    ~CCertObject ();

    //
    // Object type
    //

    inline DWORD ObjectType();

    //
    // Convert a CERT_END_OBJECT_TYPE to a CERT_CACHED_END_OBJECT_TYPE.
    //

    BOOL CacheEndObject(
        IN PCCHAINCALLCONTEXT pCallContext
        );

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Chain engine access
    //

    inline PCCERTCHAINENGINE ChainEngine ();

    //
    // Issuer's match and status flags
    //

    inline DWORD IssuerMatchFlags();
    inline DWORD CachedMatchFlags();
    inline DWORD IssuerStatusFlags();
    inline VOID OrIssuerStatusFlags(IN DWORD dwFlags);
    inline VOID OrCachedMatchFlags(IN DWORD dwFlags);

    //
    // Misc Info status flags
    //

    inline DWORD InfoFlags();

    //
    // For CERT_ISSUER_SELF_SIGNED_FLAG && !CERT_ISSUER_TRUSTED_ROOT_FLAG.
    //
    // List of cached CTLs
    //

    inline PCERT_OBJECT_CTL_CACHE_ENTRY NextCtlCacheEntry(
        IN PCERT_OBJECT_CTL_CACHE_ENTRY pEntry
        );
    inline VOID InsertCtlCacheEntry(
        IN PCERT_OBJECT_CTL_CACHE_ENTRY pEntry
        );

    //
    // Object's certificate context
    //

    inline PCCERT_CONTEXT CertContext ();


    //
    // Policies and enhanced key usage obtained from certificate context's
    // extensions and property
    //

    inline PCHAIN_POLICIES_INFO PoliciesInfo ();

    //
    // Basic constraints obtained from the certificate context's
    // extensions (NULL if this extension is omitted)
    //
    inline PCERT_BASIC_CONSTRAINTS2_INFO BasicConstraintsInfo ();

    //
    // Key usage obtained from the certificate context's
    // extensions (NULL if this extension is omitted)
    //
    inline PCRYPT_BIT_BLOB KeyUsage ();

    //
    // Issuer name constraints obtained from the certificate context's
    // extensions (NULL if this extension is omitted)
    //
    inline PCERT_NAME_CONSTRAINTS_INFO IssuerNameConstraintsInfo ();

    //
    // Subject name constraint info
    //

    PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO SubjectNameConstraintsInfo ();

    //
    // Issuer access
    //

    inline PCERT_AUTHORITY_KEY_ID_INFO AuthorityKeyIdentifier ();



    //
    // Hash access
    //

    inline LPBYTE CertHash ();

    //
    // Key identifier access
    //

    inline DWORD KeyIdentifierSize ();
    inline LPBYTE KeyIdentifier ();

    //
    // Public key hash access
    //

    inline LPBYTE PublicKeyHash ();

    // Only valid when CERT_ISSUER_PUBKEY_FLAG is set in m_dwIssuerStatusFlags
    inline LPBYTE IssuerPublicKeyHash ();


    //
    // The index entry handles for cached issuer certificates.
    // The primary index entry is the hash index entry. The index entries
    // aren't LRU'ed.
    //

    inline HLRUENTRY HashIndexEntry ();
    inline HLRUENTRY IdentifierIndexEntry ();
    inline HLRUENTRY SubjectNameIndexEntry ();
    inline HLRUENTRY KeyIdIndexEntry ();
    inline HLRUENTRY PublicKeyHashIndexEntry ();


    //
    // The index entry handle for cached end certificates. This is an LRU
    // list.
    //

    inline HLRUENTRY EndHashIndexEntry ();

    //
    // Issuer match hashes. If match hash doesn't exist,
    // returns pMatchHash->cbData = 0
    //
    VOID GetIssuerExactMatchHash(
        OUT PCRYPT_DATA_BLOB pMatchHash
        );
    VOID GetIssuerKeyMatchHash(
        OUT PCRYPT_DATA_BLOB pMatchHash
        );
    VOID GetIssuerNameMatchHash(
        OUT PCRYPT_DATA_BLOB pMatchHash
        );
    

private:
    //
    // Object's type
    //

    DWORD                       m_dwObjectType;

    //
    // Reference count
    //

    LONG                        m_cRefs;

    //
    // Certificate Chain Engine which owns this certificate object (not
    // AddRef'ed)
    //

    PCCERTCHAINENGINE           m_pChainEngine;

    //
    // Issuer's match and status flags
    //
    
    DWORD                       m_dwIssuerMatchFlags;
    DWORD                       m_dwCachedMatchFlags;
    DWORD                       m_dwIssuerStatusFlags;

    //
    // Misc Info flags
    //

    DWORD                       m_dwInfoFlags;

    //
    // For CERT_ISSUER_SELF_SIGNED_FLAG && !CERT_ISSUER_TRUSTED_ROOT_FLAG.
    // Only set for CERT_CACHED_ISSUER_OBJECT_TYPE.
    //
    // List of cached CTLs
    //

    PCERT_OBJECT_CTL_CACHE_ENTRY m_pCtlCacheHead;

    //
    // Certificate context (duplicated)
    //

    PCCERT_CONTEXT              m_pCertContext;

    //
    // Policies and usage info
    //

    CHAIN_POLICIES_INFO         m_PoliciesInfo;

    //
    // Basic constraints info (NULL if this extension is omitted)
    //
    PCERT_BASIC_CONSTRAINTS2_INFO m_pBasicConstraintsInfo;

    //
    // Key usage (NULL if this extension is omitted)
    //
    PCRYPT_BIT_BLOB             m_pKeyUsage;

    //
    // Name constraints obtained from the certificate context's
    // extensions (NULL if this extension is omitted)
    //
    PCERT_NAME_CONSTRAINTS_INFO m_pIssuerNameConstraintsInfo;

    //
    // Subject name constraint info (deferred get of)
    //

    BOOL                                m_fAvailableSubjectNameConstraintsInfo;
    CHAIN_SUBJECT_NAME_CONSTRAINTS_INFO m_SubjectNameConstraintsInfo;

    //
    // Authority Key Identifier.  This contains the issuer and serial number
    // and/or key identifier of the issuing certificate for this certificate
    // object if the m_dwIssuerMatchFlags includes
    // CERT_EXACT_ISSUER_MATCH_FLAG and/or CERT_KEYID_ISSUER_MATCH_FLAG
    //

    PCERT_AUTHORITY_KEY_ID_INFO m_pAuthKeyIdentifier;


    //
    // Certificate Object Identifier (MD5 hash of issuer and serial number)
    //

    CERT_OBJECT_IDENTIFIER      m_ObjectIdentifier;

    //
    // MD5 Hash of the certificate
    //

    BYTE                        m_rgbCertHash[ CHAINHASHLEN ];

    //
    // Key Identifier of the certificate
    //

    DWORD                       m_cbKeyIdentifier;
    LPBYTE                      m_pbKeyIdentifier;

    //
    // MD5 Hash of the subject and issuer public keys
    //

    BYTE                        m_rgbPublicKeyHash[ CHAINHASHLEN ];

    // Only valid when CERT_ISSUER_PUBKEY_FLAG is set in m_dwIssuerStatusFlags
    BYTE                        m_rgbIssuerPublicKeyHash[ CHAINHASHLEN ];

    // Only valid when CERT_ISSUER_EXACT_MATCH_HASH_FLAG is set in
    // m_dwIssuerStatusFlags
    BYTE                        m_rgbIssuerExactMatchHash[ CHAINHASHLEN ];
    // Only valid when CERT_ISSUER_NAME_MATCH_HASH_FLAG is set in
    // m_dwIssuerStatusFlags
    BYTE                        m_rgbIssuerNameMatchHash[ CHAINHASHLEN ];

    //
    // Certificate Object Cache Index entries applicable to
    // CERT_CACHED_ISSUER_OBJECT_TYPE.
    //

    HLRUENTRY                   m_hHashEntry;
    HLRUENTRY                   m_hIdentifierEntry;
    HLRUENTRY                   m_hSubjectNameEntry;
    HLRUENTRY                   m_hKeyIdEntry;
    HLRUENTRY                   m_hPublicKeyHashEntry;

    //
    // Certificate Object Cache Index entries applicable to
    // CERT_CACHED_END_OBJECT_TYPE.
    //

    HLRUENTRY                   m_hEndHashEntry;
};

//
//  Chain quality values (ascending order)
//

#define CERT_QUALITY_SIMPLE_CHAIN                   0x00000001
#define CERT_QUALITY_CHECK_REVOCATION               0x00000010
#define CERT_QUALITY_ONLINE_REVOCATION              0x00000020
#define CERT_QUALITY_PREFERRED_ISSUER               0x00000040

#define CERT_QUALITY_HAS_APPLICATION_USAGE          0x00000080

#define CERT_QUALITY_HAS_ISSUANCE_CHAIN_POLICY      0x00000100
#define CERT_QUALITY_POLICY_CONSTRAINTS_VALID       0x00000200
#define CERT_QUALITY_BASIC_CONSTRAINTS_VALID        0x00000400
#define CERT_QUALITY_HAS_NAME_CONSTRAINTS           0x00000800
#define CERT_QUALITY_NAME_CONSTRAINTS_VALID         0x00001000
#define CERT_QUALITY_NAME_CONSTRAINTS_MET           0x00002000


#define CERT_QUALITY_NOT_REVOKED                    0x00010000
#define CERT_QUALITY_TIME_VALID                     0x00020000
#define CERT_QUALITY_MEETS_USAGE_CRITERIA           0x00040000
#define CERT_QUALITY_NO_DUPLICATE_KEY               0x00400000
#define CERT_QUALITY_NOT_CYCLIC                     0x00800000
#define CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT    0x01000000
#define CERT_QUALITY_HAS_TRUSTED_ROOT               0x02000000
#define CERT_QUALITY_COMPLETE_CHAIN                 0x04000000
#define CERT_QUALITY_SIGNATURE_VALID                0x08000000


#define CERT_QUALITY_FOR_REVOCATION_CHECK ( \
                CERT_QUALITY_HAS_TRUSTED_ROOT       | \
                CERT_QUALITY_COMPLETE_CHAIN         | \
                CERT_QUALITY_SIGNATURE_VALID )

__inline
BOOL
IsValidCertQualityForRevocationCheck(
    IN DWORD dwQuality
    )
{
    if (CERT_QUALITY_FOR_REVOCATION_CHECK ==
            (dwQuality & CERT_QUALITY_FOR_REVOCATION_CHECK))
        return TRUE;
    else
        return FALSE;
}



#define CERT_TRUST_CERTIFICATE_ONLY_INFO_STATUS ( CERT_TRUST_IS_SELF_SIGNED |\
                                                  CERT_TRUST_HAS_EXACT_MATCH_ISSUER |\
                                                  CERT_TRUST_HAS_NAME_MATCH_ISSUER |\
                                                  CERT_TRUST_HAS_KEY_MATCH_ISSUER )


#define CERT_CHAIN_REVOCATION_CHECK_ALL ( CERT_CHAIN_REVOCATION_CHECK_END_CERT | \
                                          CERT_CHAIN_REVOCATION_CHECK_CHAIN | \
                                          CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT )

#define CERT_TRUST_ANY_NAME_CONSTRAINT_ERROR_STATUS ( \
                    CERT_TRUST_INVALID_NAME_CONSTRAINTS             | \
                    CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT    | \
                    CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT      | \
                    CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT    | \
                    CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT )


//
// Internal chain context. Wraps the exposed CERT_CHAIN_CONTEXT.
//

typedef struct _INTERNAL_CERT_CHAIN_CONTEXT INTERNAL_CERT_CHAIN_CONTEXT,
                                                *PINTERNAL_CERT_CHAIN_CONTEXT;
struct _INTERNAL_CERT_CHAIN_CONTEXT {
    CERT_CHAIN_CONTEXT              ChainContext;
    LONG                            cRefs;
    DWORD                           dwQuality;
    PINTERNAL_CERT_CHAIN_CONTEXT    pNext;
};

//
// Restricted issuance, application and property usage as we move from the
// top down to the end certificate
//

// Note, NULL PCERT_ENHKEY_USAGE implies any
typedef struct _CHAIN_RESTRICTED_USAGE_INFO {
    PCERT_ENHKEY_USAGE              pIssuanceRestrictedUsage;
    PCERT_ENHKEY_USAGE              pIssuanceMappedUsage;
    LPDWORD                         rgdwIssuanceMappedIndex;
    BOOL                            fRequireIssuancePolicy;

    PCERT_ENHKEY_USAGE              pApplicationRestrictedUsage;
    PCERT_ENHKEY_USAGE              pApplicationMappedUsage;
    LPDWORD                         rgdwApplicationMappedIndex;

    PCERT_ENHKEY_USAGE              pPropertyRestrictedUsage;
} CHAIN_RESTRICTED_USAGE_INFO, *PCHAIN_RESTRICTED_USAGE_INFO;

//
// Forward reference to the issuer element
//

typedef struct _CERT_ISSUER_ELEMENT CERT_ISSUER_ELEMENT, *PCERT_ISSUER_ELEMENT;

//
// CChainPathObject.  This is the main object used for building the
// chain graph.
//
// Note, since this object isn't persisted across calls, NO REF COUNTING is
// done.
//
class CChainPathObject
{
public:
    //
    // Construction
    //

    CChainPathObject (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN BOOL fCyclic,
        IN LPVOID pvObject,             // fCyclic : pPathObject ? pCertObject
        IN OPTIONAL HCERTSTORE hAdditionalStore,
        OUT BOOL& rfResult,
        OUT BOOL& rfAddedToCreationCache
        );

    ~CChainPathObject ();


    //
    // Certificate Object (AddRef'ed)
    //

    inline PCCERTOBJECT CertObject ();

    //
    // Pass 1 quality
    //

    inline DWORD Pass1Quality ();
    inline VOID SetPass1Quality (IN DWORD dwQuality);

    //
    // Pass 1 duplicate key depth
    //

    inline DWORD Pass1DuplicateKeyDepth ();
    inline VOID SetPass1DuplicateKeyDepth (IN DWORD dwDepth);

    //
    // Returns TRUE if we have completed the initialization and addition
    // of issuers to this object. FALSE would normally indicate a cyclic
    // issuer.
    //

    inline BOOL IsCompleted ();

    //
    // AdditionalStatus flag, down path object and up issuer element
    //

    inline BOOL HasAdditionalStatus ();
    inline PCCHAINPATHOBJECT DownPathObject ();
    inline PCERT_ISSUER_ELEMENT UpIssuerElement ();

    //
    // Find and add issuers
    //
    
    BOOL FindAndAddIssuers (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL HCERTSTORE hAdditionalStore,
        IN OPTIONAL HCERTSTORE hIssuerUrlStore
        );
    BOOL FindAndAddIssuersByMatchType(
        IN DWORD dwMatchType,
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL HCERTSTORE hAdditionalStore,
        IN OPTIONAL HCERTSTORE hIssuerUrlStore
        );
    BOOL FindAndAddIssuersFromCacheByMatchType(
        IN DWORD dwMatchType,
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL HCERTSTORE hAdditionalStore
        );
    BOOL FindAndAddIssuersFromStoreByMatchType(
        IN DWORD dwMatchType,
        IN PCCHAINCALLCONTEXT pCallContext,
        IN BOOL fExternalStore,
        IN OPTIONAL HCERTSTORE hAdditionalStore,
        IN OPTIONAL HCERTSTORE hIssuerUrlStore
        );

    BOOL FindAndAddCtlIssuersFromCache (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL HCERTSTORE hAdditionalStore
        );
    BOOL FindAndAddCtlIssuersFromAdditionalStore (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN HCERTSTORE hAdditionalStore
        );

    //
    // Builds the top down chain graph for the next top object
    //

    PCCHAINPATHOBJECT NextPath (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL PCCHAINPATHOBJECT pPrevTopPathObject
        );

    PCCHAINPATHOBJECT NextPathWithoutDuplicateKeyCheck (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL PCCHAINPATHOBJECT pPrevTopPathObject
        );

    VOID ResetNextPath(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OPTIONAL PCCHAINPATHOBJECT pTopPathObject
        );

    VOID CalculateAdditionalStatus (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN HCERTSTORE hAllStore
        );
    VOID CalculatePolicyConstraintsStatus ();
    VOID CalculateBasicConstraintsStatus ();
    VOID CalculateKeyUsageStatus ();
    VOID CalculateNameConstraintsStatus (
        IN PCERT_USAGE_MATCH pUsageToUse
        );
    VOID CalculateRevocationStatus (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN HCERTSTORE hCrlStore,
        IN LPFILETIME pTime
        );

    PINTERNAL_CERT_CHAIN_CONTEXT CreateChainContextFromPath (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCHAINPATHOBJECT pTopPathObject
        );

    BOOL UpdateChainContextUsageForPathObject (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OUT PCERT_SIMPLE_CHAIN pChain,
        IN OUT PCERT_CHAIN_ELEMENT pElement,
        IN OUT PCHAIN_RESTRICTED_USAGE_INFO pRestrictedUsageInfo
        );

    BOOL UpdateChainContextFromPathObject (
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OUT PCERT_SIMPLE_CHAIN pChain,
        IN OUT PCERT_CHAIN_ELEMENT pElement
        );

    //
    // AuthRoot Auto Update CTL Methods
    //
    BOOL GetAuthRootAutoUpdateUrlStore(
        IN PCCHAINCALLCONTEXT pCallContext,
        OUT HCERTSTORE *phIssuerUrlStore
        );

private:
    //
    // Certificate Object (AddRef'ed)
    //

    PCCERTOBJECT            m_pCertObject;

    //
    // Trust Status.  This does not represent the full trust status
    // for the object.  Some of the bits are calculated on demand and placed
    // into the ending chain context.  The following are the trust status
    // bits which can appear here
    //
    // CERT_TRUST_IS_SELF_SIGNED
    // CERT_TRUST_HAS_EXACT_MATCH_ISSUER
    // CERT_TRUST_HAS_NAME_MATCH_ISSUER
    // CERT_TRUST_HAS_KEY_MATCH_ISSUER
    //
    // CERT_TRUST_IS_NOT_SIGNATURE_VALID (if the certificate is self-signed)
    // CERT_TRUST_IS_UNTRUSTED_ROOT (if the certificate is self-signed)
    // CERT_TRUST_HAS_PREFERRED_ISSUER (if the certificate is self-signed)
    //
    // CERT_TRUST_IS_CYCLIC (for cyclic cert)
    //

    CERT_TRUST_STATUS       m_TrustStatus;

    // Pass1 Quality is limited to the following:
    //  CERT_QUALITY_NO_DUPLICATE_KEY
    //  CERT_QUALITY_NOT_CYCLIC
    //  CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT
    //  CERT_QUALITY_HAS_TRUSTED_ROOT
    //  CERT_QUALITY_SIGNATURE_VALID
    //  CERT_QUALITY_COMPLETE_CHAIN

    DWORD                   m_dwPass1Quality;
    DWORD                   m_dwPass1DuplicateKeyDepth;

    //
    //  The chain context's chain and element indices
    //

    DWORD                   m_dwChainIndex;
    DWORD                   m_dwElementIndex;

    //
    // Down and up path pointers for a chain context
    //

    PCERT_ISSUER_ELEMENT    m_pDownIssuerElement;
    PCCHAINPATHOBJECT       m_pDownPathObject;
    PCERT_ISSUER_ELEMENT    m_pUpIssuerElement;

    //
    // Additional status and revocation info (only applicable to self signed
    // certificates or top certificates without any issuers)
    //

    BOOL                    m_fHasAdditionalStatus;
    CERT_TRUST_STATUS       m_AdditionalStatus;
    BOOL                    m_fHasRevocationInfo;
    CERT_REVOCATION_INFO    m_RevocationInfo;
    CERT_REVOCATION_CRL_INFO m_RevocationCrlInfo;


    //
    // Issuer Chain Path Objects.  The list of issuers of this
    // certificate object along with information about those issuers
    // relevant to this subject.
    //

    PCCERTISSUERLIST        m_pIssuerList;

    //
    // Supplemental error information is localization formatted and appended.
    // Each error line should be terminated with a L'\n'.
    //
    LPWSTR                  m_pwszExtendedErrorInfo;

    //
    // Following flag is set when we have completed the initialization and
    // addition of all issuers to this object.
    //
    BOOL                    m_fCompleted;
};


//
// CCertIssuerList.  List of issuer certificate objects along with related
// issuer information.  This is used by the certificate object to cache
// its possible set of issuers
//

// Currently in a self signed certificate object, the issuer elements will
// have CTL issuer data set and pIssuer may be NULL if unable to find 
// the CTL signer

typedef struct _CTL_ISSUER_DATA {
    PCSSCTLOBJECT         pSSCtlObject;     // AddRef'ed
    PCERT_TRUST_LIST_INFO pTrustListInfo;
} CTL_ISSUER_DATA, *PCTL_ISSUER_DATA;

struct _CERT_ISSUER_ELEMENT {
    DWORD                        dwPass1Quality;
    DWORD                        dwPass1DuplicateKeyDepth;
    CERT_TRUST_STATUS            SubjectStatus;
    BOOL                         fCtlIssuer;
    PCCHAINPATHOBJECT            pIssuer;

    // For a cyclic issuer, the above pIssuer is saved into the following
    // before it is updated with the cyclic issuer path object
    PCCHAINPATHOBJECT            pCyclicSaveIssuer;

    PCTL_ISSUER_DATA             pCtlIssuerData;
    struct _CERT_ISSUER_ELEMENT* pPrevElement;
    struct _CERT_ISSUER_ELEMENT* pNextElement;
    BOOL                         fHasRevocationInfo;
    CERT_REVOCATION_INFO         RevocationInfo;
    CERT_REVOCATION_CRL_INFO     RevocationCrlInfo;
};

class CCertIssuerList
{
public:

    //
    // Construction
    //

    CCertIssuerList (
         IN PCCHAINPATHOBJECT pSubject
         );

    ~CCertIssuerList ();

    //
    // Issuer management
    //

    inline BOOL IsEmpty ();

    BOOL AddIssuer(
            IN PCCHAINCALLCONTEXT pCallContext,
            IN OPTIONAL HCERTSTORE hAdditionalStore,
            IN PCCERTOBJECT pIssuer
            );

    BOOL AddCtlIssuer(
            IN PCCHAINCALLCONTEXT pCallContext,
            IN OPTIONAL HCERTSTORE hAdditionalStore,
            IN PCSSCTLOBJECT pSSCtlObject,
            IN PCERT_TRUST_LIST_INFO pTrustListInfo
            );

    //
    // Element management
    //

    BOOL CreateElement(
            IN PCCHAINCALLCONTEXT pCallContext,
            IN BOOL fCtlIssuer,
            IN OPTIONAL PCCHAINPATHOBJECT pIssuer,
            IN OPTIONAL HCERTSTORE hAdditionalStore,
            IN OPTIONAL PCSSCTLOBJECT pSSCtlObject,
            IN OPTIONAL PCERT_TRUST_LIST_INFO pTrustListInfo,
            OUT PCERT_ISSUER_ELEMENT* ppElement
            );


    VOID DeleteElement (
               IN PCERT_ISSUER_ELEMENT pElement
               );

    inline VOID AddElement (
                   IN PCERT_ISSUER_ELEMENT pElement
                   );

    inline VOID RemoveElement (
                      IN PCERT_ISSUER_ELEMENT pElement
                      );

    BOOL CheckForDuplicateElement (
              IN BYTE rgbHash [ CHAINHASHLEN ],
              IN BOOL fCtlIssuer
              );

    //
    // Enumerate the issuers
    //

    inline PCERT_ISSUER_ELEMENT NextElement (
                                    IN PCERT_ISSUER_ELEMENT pElement
                                    );

private:

    //
    // Subject chain path object
    //

    PCCHAINPATHOBJECT     m_pSubject;

    //
    // Issuer List
    //

    PCERT_ISSUER_ELEMENT  m_pHead;

};


//
// CCertObjectCache.
//
// Cache of issuer certificate object references indexed by the following keys:
//      Certificate Hash
//      Certificate Object Identifier
//      Subject Name
//      Key Identifier
//      Public Key Hash
//
// Cache of end certificate object references indexed by the following keys:
//      End Certificate Hash
//
// Only the end certificate is LRU maintained.
//

#define DEFAULT_CERT_OBJECT_CACHE_BUCKETS 127
#define DEFAULT_MAX_INDEX_ENTRIES         256

class CCertObjectCache
{
public:

    //
    // Construction
    //

    CCertObjectCache (
         IN DWORD MaxIndexEntries,
         OUT BOOL& rfResult
         );

    ~CCertObjectCache ();

    //
    // Certificate Object Management
    //

    // Increments engine's touch count
    VOID AddIssuerObject (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERTOBJECT pCertObject
            );

    VOID AddEndObject (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERTOBJECT pCertObject
            );

    //
    // Access the indexes
    //

    inline HLRUCACHE HashIndex ();

    inline HLRUCACHE IdentifierIndex ();

    inline HLRUCACHE SubjectNameIndex ();

    inline HLRUCACHE KeyIdIndex ();

    inline HLRUCACHE PublicKeyHashIndex ();

    inline HLRUCACHE EndHashIndex ();

    //
    // Certificate Object Searching
    //

    PCCERTOBJECT FindIssuerObject (
                     IN HLRUCACHE hIndex,
                     IN PCRYPT_DATA_BLOB pIdentifier
                     );

    PCCERTOBJECT FindIssuerObjectByHash (
                     IN BYTE rgbCertHash[ CHAINHASHLEN ]
                     );

    PCCERTOBJECT FindEndObjectByHash (
                     IN BYTE rgbCertHash[ CHAINHASHLEN ]
                     );

    //
    // Certificate Object Enumeration
    //

    PCCERTOBJECT NextMatchingIssuerObject (
                     IN HLRUENTRY hObjectEntry,
                     IN PCCERTOBJECT pCertObject
                     );

    //
    // Cache flushing
    //

    inline VOID FlushObjects (IN PCCHAINCALLCONTEXT pCallContext);

private:

    //
    // Certificate Hash Index
    //

    HLRUCACHE m_hHashIndex;

    //
    // Certificate Object Identifier Index
    //

    HLRUCACHE m_hIdentifierIndex;

    //
    // Subject Name Index
    //

    HLRUCACHE m_hSubjectNameIndex;

    //
    // Key Identifier Index
    //

    HLRUCACHE m_hKeyIdIndex;

    //
    // Public Key Hash Index
    //

    HLRUCACHE m_hPublicKeyHashIndex;

    //
    // End Certificate Hash Index
    //

    HLRUCACHE m_hEndHashIndex;

    //
    // Private methods
    //
};



typedef struct _XCERT_DP_ENTRY XCERT_DP_ENTRY, *PXCERT_DP_ENTRY;
typedef struct _XCERT_DP_LINK XCERT_DP_LINK, *PXCERT_DP_LINK;

//
// Cross Certificate Distribution Point Entry
//

struct _XCERT_DP_ENTRY {
    // Seconds between syncs
    DWORD               dwSyncDeltaTime;

    // List of NULL terminated Urls. A successfully retrieved Url
    // pointer is moved to the beginning of the list.
    DWORD               cUrl;
    LPWSTR              *rgpwszUrl;

    // Time of last sync
    FILETIME            LastSyncTime;

    // If dwOfflineCnt == 0, NextSyncTime = LastSyncTime + dwSyncDeltaTime.
    // Otherwise, NextSyncTime = CurrentTime +
    //                rgdwChainOfflineUrlDeltaSeconds[dwOfflineCnt - 1]
    FILETIME            NextSyncTime;

    // Following is incremented when unable to do an online Url retrieval.
    // A successful Url retrieval resets.
    DWORD               dwOfflineCnt;

    // Following is incremented for each new scan through the DP entries
    DWORD               dwResyncIndex;

    // Following is set when this entry has already been checked
    BOOL                fChecked;
    
    PXCERT_DP_LINK      pChildCrossCertDPLink;
    LONG                lRefCnt;
    HCERTSTORE          hUrlStore;
    PXCERT_DP_ENTRY     pNext;
    PXCERT_DP_ENTRY     pPrev;
};


//
// Cross Certificate Distribution Point Link
//

struct _XCERT_DP_LINK {
    PXCERT_DP_ENTRY     pCrossCertDPEntry;
    PXCERT_DP_LINK      pNext;
    PXCERT_DP_LINK      pPrev;
};


//
// AuthRoot Auto Update Info
//

#define AUTH_ROOT_KEY_MATCH_IDX         0
#define AUTH_ROOT_NAME_MATCH_IDX        1
#define AUTH_ROOT_MATCH_CNT             2

#define AUTH_ROOT_MATCH_CACHE_BUCKETS   61

typedef struct _AUTH_ROOT_AUTO_UPDATE_INFO {
    // Seconds between syncs
    DWORD               dwSyncDeltaTime;

    // Registry Flags value
    DWORD               dwFlags;

    // URL to the directory containing the AuthRoots
    LPWSTR              pwszRootDirUrl;

    // URL to the CAB containing the CTL containing the complete list of roots
    // in the AuthRoot store
    LPWSTR              pwszCabUrl;

    // URL to the SequenceNumber file corresponding to the latest list of
    // roots in the AuthRoot store
    LPWSTR              pwszSeqUrl;

    // Time of last sync
    FILETIME            LastSyncTime;

    // NextSyncTime = LastSyncTime + dwSyncDeltaTime.
    FILETIME            NextSyncTime;

    // If nonNull, a validated AuthRoot CTL.
    PCCTL_CONTEXT       pCtl;

    // Cache of CTL entries via their key and name match hashes. The
    // Cache entry value is the PCTL_ENTRY pointer.
    HLRUCACHE           rghMatchCache[AUTH_ROOT_MATCH_CNT];

} AUTH_ROOT_AUTO_UPDATE_INFO, *PAUTH_ROOT_AUTO_UPDATE_INFO;

// 7 days
#define AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME   (60 * 60 * 24 * 7)

#define AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL      L"http://www.download.windowsupdate.com/msdownload/update/v3/static/trustedr/en"

typedef struct _CHAIN_CONFIG {
    BOOL        fDisableMandatoryBasicConstraints;

    BOOL        fDisableAIAUrlRetrieval;
    DWORD       dwMaxAIAUrlCountInCert;
    DWORD       dwMaxAIAUrlRetrievalCountPerChain;
    DWORD       dwMaxAIAUrlRetrievalByteCount;
    DWORD       dwMaxAIAUrlRetrievalCertCount;
} CHAIN_CONFIG;

//
// CCertChainEngine.  The chaining engine satisfies requests for chain contexts
// given some set of parameters.  In order to make the building of these
// contexts efficient, the chain engine caches trust and chain information
// for certificates
//

class CCertChainEngine
{
public:

    //
    // Construction
    //

    CCertChainEngine (
         IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
         IN BOOL fDefaultEngine,
         OUT BOOL& rfResult
         );

    ~CCertChainEngine ();

    //
    // Chain Engine Locking
    //

    inline VOID LockEngine ();
    inline VOID UnlockEngine ();

    //
    // Chain Engine reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Cache access
    //

    inline PCCERTOBJECTCACHE CertObjectCache ();
    inline PCSSCTLOBJECTCACHE SSCtlObjectCache ();

    //
    // Store access
    //

    inline HCERTSTORE RootStore ();
    inline HCERTSTORE RealRootStore ();
    inline HCERTSTORE TrustStore ();
    inline HCERTSTORE OtherStore ();
    inline HCERTSTORE CAStore ();
    inline HCERTSTORE DisallowedStore ();

    //
    // Open the HKLM or HKCU "trust" store. Caller must close.
    //

    inline HCERTSTORE OpenTrustStore ();

    //
    // Engine's Url retrieval timeout
    //

    inline DWORD UrlRetrievalTimeout ();
    inline BOOL HasDefaultUrlRetrievalTimeout ();

    //
    // Engine's Flags
    //

    inline DWORD Flags ();


    //
    // DisableMandatoryBasicConstraints flag
    //

    inline BOOL DisableMandatoryBasicConstraints ();

    //
    // Engine Touching
    //

    inline DWORD TouchEngineCount ();
    inline DWORD IncrementTouchEngineCount ();

    //
    // Chain Context Retrieval
    //

    BOOL GetChainContext (
            IN PCCERT_CONTEXT pCertContext,
            IN LPFILETIME pTime,
            IN HCERTSTORE hAdditionalStore,
            IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
            IN DWORD dwFlags,
            IN LPVOID pvReserved,
            OUT PCCERT_CHAIN_CONTEXT* ppChainContext
            );

    BOOL CreateChainContextFromPathGraph (
            IN PCCHAINCALLCONTEXT pCallContext,
            IN PCCERT_CONTEXT pCertContext,
            IN HCERTSTORE hAdditionalStore,
            OUT PCCERT_CHAIN_CONTEXT* ppChainContext
            );

    BOOL IsPotentialKeyRolloverRoot (
            IN PCCERT_CONTEXT pRootCertContext
            );

    // Leaves Engine's lock to do URL fetching
    BOOL GetIssuerUrlStore(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCERT_CONTEXT pSubjectCertContext,
        IN DWORD dwRetrievalFlags,
        OUT HCERTSTORE *phIssuerUrlStore
        );

    // Engine isn't locked on entry. Only called if online.
    HCERTSTORE GetNewerIssuerUrlStore(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCERT_CONTEXT pSubjectCertContext,
        IN PCCERT_CONTEXT pIssuerCertContext
        );


    //
    // Resync the engine
    //

    BOOL Resync (IN PCCHAINCALLCONTEXT pCallContext, BOOL fForce);


    //
    // Cross Certificate Methods implemented in xcert.cpp
    //

    void
    InsertCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry
        );
    void
    RemoveCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry
        );

    void
    RepositionOnlineCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry,
        IN LPFILETIME pLastSyncTime
        );
    void
    RepositionOfflineCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry,
        IN LPFILETIME pCurrentTime
        );
    void
    RepositionNewSyncDeltaTimeCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry,
        IN DWORD dwSyncDeltaTime
        );

    PXCERT_DP_ENTRY
    CreateCrossCertDistPointEntry(
        IN DWORD dwSyncDeltaTime,
        IN DWORD cUrl,
        IN LPWSTR *rgpwszUrl
        );
    void
    AddRefCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry
        );
    BOOL
    ReleaseCrossCertDistPointEntry(
        IN OUT PXCERT_DP_ENTRY pEntry
        );

    BOOL
    GetCrossCertDistPointsForStore(
        IN HCERTSTORE hStore,
        IN BOOL fOnlyLMSystemStore,
        IN OUT PXCERT_DP_LINK *ppLinkHead
        );

    void
    RemoveCrossCertDistPointOrphanEntry(
        IN PXCERT_DP_ENTRY pOrphanEntry
        );
    void
    FreeCrossCertDistPoints(
        IN OUT PXCERT_DP_LINK *ppLinkHead
        );

    BOOL
    RetrieveCrossCertUrl(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN OUT PXCERT_DP_ENTRY pEntry,
        IN DWORD dwRetrievalFlags,
        IN OUT BOOL *pfTimeValid
        );
    BOOL
    UpdateCrossCerts(
        IN PCCHAINCALLCONTEXT pCallContext
        );



    //
    // AuthRoot Auto Update CTL Methods
    //

    inline PAUTH_ROOT_AUTO_UPDATE_INFO AuthRootAutoUpdateInfo();

    BOOL
    RetrieveAuthRootAutoUpdateObjectByUrlW(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN DWORD dwSuccessEventID,
        IN DWORD dwFailEventID,
        IN LPCWSTR pwszUrl,
        IN LPCSTR pszObjectOid,
        IN DWORD dwRetrievalFlags,
        IN DWORD dwTimeout,         // 0 => use default
        OUT LPVOID* ppvObject,
        IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
        );

    BOOL
    GetAuthRootAutoUpdateCtl(
        IN PCCHAINCALLCONTEXT pCallContext,
        OUT PCCTL_CONTEXT *ppCtl
        );

    VOID
    FindAuthRootAutoUpdateMatchingCtlEntries(
        IN CRYPT_DATA_BLOB rgMatchHash[AUTH_ROOT_MATCH_CNT],
        IN OUT PCCTL_CONTEXT *ppCtl,
        OUT DWORD *pcCtlEntry,
        OUT PCTL_ENTRY **prgpCtlEntry
        );

    BOOL
    GetAuthRootAutoUpdateCert(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCTL_ENTRY pCtlEntry,
        IN OUT HCERTSTORE hStore
        );

private:

    //
    // Reference count
    //

    LONG                     m_cRefs;

    //
    // Engine Lock
    //

    CRITICAL_SECTION         m_Lock;
    BOOL                     m_fInitializedLock;

    //
    // Root store ( Certs )
    //

    HCERTSTORE               m_hRealRootStore;
    HCERTSTORE               m_hRootStore;

    //
    // Trust Store Collection ( CTLs )
    //

    HCERTSTORE               m_hTrustStore;

    //
    // Other store collection ( Certs and CRLs )
    //

    HCERTSTORE               m_hOtherStore;
    HCERTSTORE               m_hCAStore;

    //
    // Disallowed Store (disallowed, untrusted end certificates)
    //

    HCERTSTORE               m_hDisallowedStore;

    //
    // Engine Store ( Collection of Root, Trust and Other )
    //

    HCERTSTORE               m_hEngineStore;

    //
    // Engine Store Change Notification Event
    //

    HANDLE                   m_hEngineStoreChangeEvent;

    //
    // Engine flags
    //

    DWORD                    m_dwFlags;

    //
    // Retrieval timeout
    //

    DWORD                    m_dwUrlRetrievalTimeout;
    BOOL                     m_fDefaultUrlRetrievalTimeout;

    //
    // Certificate Object Cache
    //

    PCCERTOBJECTCACHE        m_pCertObjectCache;

    //
    // Self Signed Certificate Trust List Object Cache
    //

    PCSSCTLOBJECTCACHE       m_pSSCtlObjectCache;


    //
    // Engine Touching
    //

    DWORD                    m_dwTouchEngineCount;

    //
    // Cross Certificate
    //

    // List of all distribution point entries. Ordered according to
    // the entrys' NextSyncTime.
    PXCERT_DP_ENTRY          m_pCrossCertDPEntry;

    // List of engine's distribution point links
    PXCERT_DP_LINK           m_pCrossCertDPLink;

    // Collection of cross cert stores
    HCERTSTORE               m_hCrossCertStore;

    // Following index is advanced for each new scan to find cross cert
    // distribution points to resync
    DWORD                    m_dwCrossCertDPResyncIndex;

    //
    // AuthRoot Auto Update Info. Created first time we have a partial chain
    // or a untrusted root and auto update has been enabled.
    //
    PAUTH_ROOT_AUTO_UPDATE_INFO m_pAuthRootAutoUpdateInfo;

    //
    // Chain configuration parameters updatable via HKLM registry
    //
    CHAIN_CONFIG             m_Config;
};


//+===========================================================================
//  CCertObject inline methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::ObjectType, public
//
//  Synopsis:   return the object type
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::ObjectType ()
{
    return( m_dwObjectType );
}
 
//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::AddRef, public
//
//  Synopsis:   add a reference to the certificate object
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::AddRef ()
{
    InterlockedIncrement( &m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::Release, public
//
//  Synopsis:   remove a reference from the certificate object
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::Release ()
{
    if ( InterlockedDecrement( &m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::ChainEngine, public
//
//  Synopsis:   return the chain engine object
//
//----------------------------------------------------------------------------
inline PCCERTCHAINENGINE
CCertObject::ChainEngine ()
{
    return( m_pChainEngine );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerMatchFlags, public
//
//  Synopsis:   return the issuer match flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::IssuerMatchFlags ()
{
    return( m_dwIssuerMatchFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CachedMatchFlags, public
//
//  Synopsis:   return the cached match flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::CachedMatchFlags ()
{
    return( m_dwCachedMatchFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerStatusFlags, public
//
//  Synopsis:   return the issuer status flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::IssuerStatusFlags ()
{
    return( m_dwIssuerStatusFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::OrIssuerStatusFlags, public
//
//  Synopsis:   'or' bits into the issuer status flags.
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::OrIssuerStatusFlags(
        IN DWORD dwFlags
        )
{
    m_dwIssuerStatusFlags |= dwFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::OrCachedMatchFlags, public
//
//  Synopsis:   'or' bits into the cached match flags
//
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::OrCachedMatchFlags(
        IN DWORD dwFlags
        )
{
    m_dwCachedMatchFlags |= dwFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::InfoFlags, public
//
//  Synopsis:   return the misc info flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::InfoFlags ()
{
    return( m_dwInfoFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::NextCtlCacheEntry, public
//
//  Synopsis:   return the next entry, if pEntry == NULL the first entry
//              is returned
//
//----------------------------------------------------------------------------
inline PCERT_OBJECT_CTL_CACHE_ENTRY
CCertObject::NextCtlCacheEntry(
    IN PCERT_OBJECT_CTL_CACHE_ENTRY pEntry
    )
{
    if (NULL == pEntry)
        return m_pCtlCacheHead;
    else
        return pEntry->pNext;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::InsertCtlCacheEntry, public
//
//  Synopsis:   insert an entry into the Ctl cache
//
//----------------------------------------------------------------------------
inline VOID
CCertObject::InsertCtlCacheEntry(
    IN PCERT_OBJECT_CTL_CACHE_ENTRY pEntry
    )
{
    pEntry->pNext = m_pCtlCacheHead;
    m_pCtlCacheHead = pEntry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CertContext, public
//
//  Synopsis:   return the certificate context
//
//----------------------------------------------------------------------------
inline PCCERT_CONTEXT
CCertObject::CertContext ()
{
    return( m_pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::PoliciesInfo, public
//
//  Synopsis:   return pointer to the policies and usage info
//
//----------------------------------------------------------------------------
inline PCHAIN_POLICIES_INFO
CCertObject::PoliciesInfo ()
{
    return( &m_PoliciesInfo );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::BasicConstraintsInfo, public
//
//  Synopsis:   return the basic constraints info pointer
//
//----------------------------------------------------------------------------
inline PCERT_BASIC_CONSTRAINTS2_INFO
CCertObject::BasicConstraintsInfo ()
{
    return( m_pBasicConstraintsInfo );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyUsage, public
//
//  Synopsis:   return the key usage pointer
//
//----------------------------------------------------------------------------
inline PCRYPT_BIT_BLOB
CCertObject::KeyUsage ()
{
    return( m_pKeyUsage );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerNameConstraintsInfo, public
//
//  Synopsis:   return the issuer name constraints info pointer
//
//----------------------------------------------------------------------------
inline PCERT_NAME_CONSTRAINTS_INFO
CCertObject::IssuerNameConstraintsInfo ()
{
    return( m_pIssuerNameConstraintsInfo );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::AuthorityKeyIdentifier, public
//
//  Synopsis:   return the issuer authority key identifier information
//
//----------------------------------------------------------------------------
inline PCERT_AUTHORITY_KEY_ID_INFO
CCertObject::AuthorityKeyIdentifier ()
{
    return( m_pAuthKeyIdentifier );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CertHash, public
//
//  Synopsis:   return the certificate hash
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::CertHash ()
{
    return( m_rgbCertHash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdentifierSize, public
//
//  Synopsis:   return the key identifier blob size
//
//----------------------------------------------------------------------------
inline DWORD
CCertObject::KeyIdentifierSize ()
{
    return( m_cbKeyIdentifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdentifier, public
//
//  Synopsis:   return the key identifier
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::KeyIdentifier ()
{
    return( m_pbKeyIdentifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::PublicKeyHash, public
//
//  Synopsis:   return the cert's public key hash
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::PublicKeyHash ()
{
    return( m_rgbPublicKeyHash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IssuerPublicKeyHash, public
//
//  Synopsis:   return the public key hash of the cert's issuer
//
//----------------------------------------------------------------------------
inline LPBYTE
CCertObject::IssuerPublicKeyHash ()
{
    return( m_rgbIssuerPublicKeyHash );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::HashIndexEntry, public
//
//  Synopsis:   return the hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::HashIndexEntry ()
{
    return( m_hHashEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::IdentifierIndexEntry, public
//
//  Synopsis:   return the identifier index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::IdentifierIndexEntry ()
{
    return( m_hIdentifierEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::SubjectNameIndexEntry, public
//
//  Synopsis:   return the subject name index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::SubjectNameIndexEntry ()
{
    return( m_hSubjectNameEntry );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::KeyIdIndexEntry, public
//
//  Synopsis:   return the key identifier index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::KeyIdIndexEntry ()
{
    return( m_hKeyIdEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::PublicKeyHashIndexEntry, public
//
//  Synopsis:   return the public key hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::PublicKeyHashIndexEntry ()
{
    return( m_hPublicKeyHashEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::EndHashIndexEntry, public
//
//  Synopsis:   return the hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CCertObject::EndHashIndexEntry ()
{
    return( m_hEndHashEntry );
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CertObject, public
//
//  Synopsis:   returns the cert object
//
//----------------------------------------------------------------------------
inline PCCERTOBJECT
CChainPathObject::CertObject ()
{
    return( m_pCertObject );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::Pass1Quality, public
//
//  Synopsis:   return the quality value determined during the first pass
//
//----------------------------------------------------------------------------
inline DWORD
CChainPathObject::Pass1Quality ()
{
    return( m_dwPass1Quality );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::SetPass1Quality, public
//
//  Synopsis:   set the first pass quality value
//
//----------------------------------------------------------------------------
inline VOID
CChainPathObject::SetPass1Quality (IN DWORD dwQuality)
{
    m_dwPass1Quality  = dwQuality;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::Pass1DuplicateKeyDepth, public
//
//  Synopsis:   return the duplicate key depth determined during the first pass
//
//----------------------------------------------------------------------------
inline DWORD
CChainPathObject::Pass1DuplicateKeyDepth ()
{
    return( m_dwPass1DuplicateKeyDepth );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::SetPass1DuplicateKeyDepth, public
//
//  Synopsis:   set the first pass duplicate key depth
//
//----------------------------------------------------------------------------
inline VOID
CChainPathObject::SetPass1DuplicateKeyDepth (IN DWORD dwDepth)
{
    m_dwPass1DuplicateKeyDepth  = dwDepth;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::IsCompleted, public
//
//  Synopsis:   returns TRUE if we have completed object initialization and
//              the addition of all issuers. FALSE normally indicates a
//              cyclic issuer.
//
//----------------------------------------------------------------------------
inline BOOL
CChainPathObject::IsCompleted ()
{
    return m_fCompleted;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::HasAdditionalStatus, public
//
//  Synopsis:   returns HasAdditionalStatus flag value 
//
//----------------------------------------------------------------------------
inline BOOL
CChainPathObject::HasAdditionalStatus ()
{
    return( m_fHasAdditionalStatus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::DownPathObject, public
//
//  Synopsis:   returns this object's down path object
//
//----------------------------------------------------------------------------
inline PCCHAINPATHOBJECT
CChainPathObject::DownPathObject ()
{
    return( m_pDownPathObject );
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::UpIssuerElement, public
//
//  Synopsis:   returns this object's up issuer element.
//
//----------------------------------------------------------------------------
inline PCERT_ISSUER_ELEMENT
CChainPathObject::UpIssuerElement ()
{
    return( m_pUpIssuerElement );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::IsEmpty, public
//
//  Synopsis:   is the issuer list empty
//
//----------------------------------------------------------------------------
inline BOOL
CCertIssuerList::IsEmpty ()
{
    return( m_pHead == NULL );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddElement, public
//
//  Synopsis:   add an element to the list
//
//----------------------------------------------------------------------------
inline VOID
CCertIssuerList::AddElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    pElement->pNextElement = m_pHead;
    pElement->pPrevElement = NULL;

    if ( m_pHead != NULL )
    {
        m_pHead->pPrevElement = pElement;
    }

    m_pHead = pElement;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::RemoveElement, public
//
//  Synopsis:   remove an element from the list
//
//----------------------------------------------------------------------------
inline VOID
CCertIssuerList::RemoveElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    if ( pElement->pPrevElement != NULL )
    {
        pElement->pPrevElement->pNextElement = pElement->pNextElement;
    }

    if ( pElement->pNextElement != NULL )
    {
        pElement->pNextElement->pPrevElement = pElement->pPrevElement;
    }

    if ( pElement == m_pHead )
    {
        m_pHead = pElement->pNextElement;
    }

#if DBG
    pElement->pPrevElement = NULL;
    pElement->pNextElement = NULL;
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::NextElement, public
//
//  Synopsis:   return the next element, if pElement == NULL the first element
//              is returned
//
//----------------------------------------------------------------------------
inline PCERT_ISSUER_ELEMENT
CCertIssuerList::NextElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    if ( pElement == NULL )
    {
        return( m_pHead );
    }

    return( pElement->pNextElement );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::HashIndex, public
//
//  Synopsis:   return the hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::HashIndex ()
{
    return( m_hHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::IdentifierIndex, public
//
//  Synopsis:   return the identifier index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::IdentifierIndex ()
{
    return( m_hIdentifierIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::SubjectNameIndex, public
//
//  Synopsis:   return the subject name index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::SubjectNameIndex ()
{
    return( m_hSubjectNameIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::KeyIdIndex, public
//
//  Synopsis:   return the key identifier index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::KeyIdIndex ()
{
    return( m_hKeyIdIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::PublicKeyHashIndex, public
//
//  Synopsis:   return the hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::PublicKeyHashIndex ()
{
    return( m_hPublicKeyHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::EndHashIndex, public
//
//  Synopsis:   return the end hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CCertObjectCache::EndHashIndex ()
{
    return( m_hEndHashIndex );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FlushObjects, public
//
//  Synopsis:   flush the cache of issuer and end objects
//
//----------------------------------------------------------------------------
inline VOID
CCertObjectCache::FlushObjects (IN PCCHAINCALLCONTEXT pCallContext)
{
    I_CryptFlushLruCache( m_hHashIndex, 0, pCallContext );
    I_CryptFlushLruCache( m_hEndHashIndex, 0, pCallContext );

}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::LockEngine, public
//
//  Synopsis:   acquire the engine lock
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::LockEngine ()
{
    EnterCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::UnlockEngine, public
//
//  Synopsis:   release the engine lock
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::UnlockEngine ()
{
    LeaveCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::AddRef, public
//
//  Synopsis:   increment the reference count
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::AddRef ()
{
    InterlockedIncrement( &m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::Release, public
//
//  Synopsis:   decrement the reference count
//
//----------------------------------------------------------------------------
inline VOID
CCertChainEngine::Release ()
{
    if ( InterlockedDecrement( &m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CertObjectCache, public
//
//  Synopsis:   return the certificate object cache
//
//----------------------------------------------------------------------------
inline PCCERTOBJECTCACHE
CCertChainEngine::CertObjectCache ()
{
    return( m_pCertObjectCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::SSCtlObjectCache, public
//
//  Synopsis:   return the self signed certificate trust list object cache
//
//----------------------------------------------------------------------------
inline PCSSCTLOBJECTCACHE
CCertChainEngine::SSCtlObjectCache ()
{
    return( m_pSSCtlObjectCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RootStore, public
//
//  Synopsis:   return the configured root store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::RootStore ()
{
    return( m_hRootStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RealRootStore, public
//
//  Synopsis:   return the real root store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::RealRootStore ()
{
    return( m_hRealRootStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::TrustStore, public
//
//  Synopsis:   return the configured trust store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::TrustStore ()
{
    return( m_hTrustStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::OtherStore, public
//
//  Synopsis:   return the configured other store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::OtherStore ()
{
    return( m_hOtherStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CAStore, public
//
//  Synopsis:   return the opened CA store, NOTE: this could be NULL!
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::CAStore ()
{
    return( m_hCAStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::DisallowedStore, public
//
//  Synopsis:   return the opened Disallowed store, NOTE: this could be NULL!
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::DisallowedStore ()
{
    return( m_hDisallowedStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::OpenTrustStore, public
//
//  Synopsis:   open's the engine's HKLM or HKCU "trust" store.
//              Caller must close.
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CCertChainEngine::OpenTrustStore ()
{
    DWORD dwStoreFlags;

    if ( m_dwFlags & CERT_CHAIN_USE_LOCAL_MACHINE_STORE )
    {
        dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }
    else
    {
        dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    }

    return CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags |
                         CERT_STORE_SHARE_CONTEXT_FLAG |
                         CERT_STORE_SHARE_STORE_FLAG |
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                     L"trust"
                     );
    
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::UrlRetrievalTimeout, public
//
//  Synopsis:   return the engine's UrlRetrievalTimeout
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::UrlRetrievalTimeout ()
{
    return( m_dwUrlRetrievalTimeout );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::HasDefaultUrlRetrievalTimeout, public
//
//  Synopsis:   returns TRUE if the engine is using the default timeout
//
//----------------------------------------------------------------------------
inline BOOL
CCertChainEngine::HasDefaultUrlRetrievalTimeout ()
{
    return( m_fDefaultUrlRetrievalTimeout );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::Flags, public
//
//  Synopsis:   return the engine's flags
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::Flags ()
{
    return( m_dwFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::DisableMandatoryBasicConstraints, public
//
//  Synopsis:   return the engine's flags
//
//----------------------------------------------------------------------------
inline BOOL
CCertChainEngine::DisableMandatoryBasicConstraints ()
{
    return( m_Config.fDisableMandatoryBasicConstraints );
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::TouchEngineCount, public
//
//  Synopsis:   return the engine's touch count
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::TouchEngineCount ()
{
    return( m_dwTouchEngineCount );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::IncrementTouchEngineCount, public
//
//  Synopsis:   increment and return the engine's touch count
//
//----------------------------------------------------------------------------
inline DWORD
CCertChainEngine::IncrementTouchEngineCount ()
{
    return( ++m_dwTouchEngineCount );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::AuthRootAutoUpdateInfo, public
//
//  Synopsis:   returns pointer to the engine's AuthRoot Auto Update Info
//
//----------------------------------------------------------------------------
inline PAUTH_ROOT_AUTO_UPDATE_INFO
CCertChainEngine::AuthRootAutoUpdateInfo()
{
    return m_pAuthRootAutoUpdateInfo;
}


//+===========================================================================
//  CCertObject helper functions
//============================================================================

BOOL WINAPI
ChainCreateCertObject (
    IN DWORD dwObjectType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPBYTE pbCertHash,
    OUT PCCERTOBJECT *ppCertObject
    );

BOOL WINAPI
ChainFillCertObjectCtlCacheEnumFn(
     IN LPVOID pvParameter,
     IN PCSSCTLOBJECT pSSCtlObject
     );
VOID WINAPI
ChainFreeCertObjectCtlCache(
     IN PCERT_OBJECT_CTL_CACHE_ENTRY pCtlCacheHead
     );

LPVOID WINAPI
ChainAllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

VOID WINAPI
ChainGetIssuerMatchInfo (
     IN PCCERT_CONTEXT pCertContext,
     OUT DWORD *pdwIssuerMatchFlags,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     );

BOOL WINAPI
ChainConvertAuthKeyIdentifierFromV2ToV1 (
     IN PCERT_AUTHORITY_KEY_ID2_INFO pAuthKeyIdentifier2,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     );
VOID WINAPI
ChainFreeAuthorityKeyIdentifier (
     IN PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdInfo
     );

VOID WINAPI
ChainProcessSpecialOrDuplicateOIDsInUsage (
    IN OUT PCERT_ENHKEY_USAGE *ppUsage,
    IN OUT DWORD *pdwFlags
    );

VOID WINAPI
ChainConvertPoliciesToUsage (
    IN PCERT_POLICIES_INFO pPolicy,
    IN OUT DWORD *pdwFlags,
    OUT PCERT_ENHKEY_USAGE *ppUsage
    );

VOID WINAPI
ChainRemoveDuplicatePolicyMappings (
    IN OUT PCERT_POLICY_MAPPINGS_INFO pInfo
    );

VOID WINAPI
ChainGetPoliciesInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCHAIN_POLICIES_INFO pPoliciesInfo
    );
VOID WINAPI
ChainFreePoliciesInfo (
    IN OUT PCHAIN_POLICIES_INFO pPoliciesInfo
    );

BOOL WINAPI
ChainGetBasicConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    OUT PCERT_BASIC_CONSTRAINTS2_INFO *ppInfo
    );

VOID WINAPI
ChainFreeBasicConstraintsInfo (
    IN OUT PCERT_BASIC_CONSTRAINTS2_INFO pInfo
    );

BOOL WINAPI
ChainGetKeyUsage (
    IN PCCERT_CONTEXT pCertContext,
    OUT PCRYPT_BIT_BLOB *ppKeyUsage
    );

VOID WINAPI
ChainFreeKeyUsage (
    IN OUT PCRYPT_BIT_BLOB pKeyUsage
    );

VOID WINAPI
ChainGetSelfSignedStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERTOBJECT pCertObject,
    IN OUT DWORD *pdwIssuerStatusFlags
    );
VOID WINAPI
ChainGetRootStoreStatus (
    IN HCERTSTORE hRoot,
    IN HCERTSTORE hRealRoot,
    IN BYTE rgbCertHash[ CHAINHASHLEN ],
    IN OUT DWORD *pdwIssuerStatusFlags
    );

//+===========================================================================
//  CCertObjectCache helper functions
//============================================================================

BOOL WINAPI
ChainCreateCertificateObjectCache (
     IN DWORD MaxIndexEntries,
     OUT PCCERTOBJECTCACHE* ppCertObjectCache
     );

VOID WINAPI
ChainFreeCertificateObjectCache (
     IN PCCERTOBJECTCACHE pCertObjectCache
     );


//
// Issuer Certificate Object Cache Primary Index Entry Removal Notification
//
// This should remove the relevant entries
// from the other indexes and release the reference on the certificate object
// maintained by the primary index.
//

VOID WINAPI
CertObjectCacheOnRemovalFromPrimaryIndex (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    );

//
// End Certificate Object Cache Entry Removal Notification
//

VOID WINAPI
CertObjectCacheOnRemovalFromEndHashIndex (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    );

//
// Certificate Object Cache Identifier Hashing Functions
//

DWORD WINAPI
CertObjectCacheHashMd5Identifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    );

DWORD WINAPI
CertObjectCacheHashNameIdentifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    );

VOID WINAPI
ChainCreateCertificateObjectIdentifier (
     IN PCERT_NAME_BLOB pIssuer,
     IN PCRYPT_INTEGER_BLOB pSerialNumber,
     OUT CERT_OBJECT_IDENTIFIER ObjectIdentifier
     );

//+===========================================================================
//  CChainPathObject helper functions
//============================================================================
BOOL WINAPI
ChainCreatePathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERTOBJECT pCertObject,
     IN OPTIONAL HCERTSTORE hAdditionalStore,
     OUT PCCHAINPATHOBJECT *ppPathObject
     );
BOOL WINAPI
ChainCreateCyclicPathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCHAINPATHOBJECT pPathObject,
     OUT PCCHAINPATHOBJECT *ppCyclicPathObject
     );
VOID WINAPI
ChainDeleteCyclicPathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN OUT PCCHAINPATHOBJECT pCyclicPathObject
     );

LPSTR WINAPI
ChainAllocAndCopyOID (
     IN LPSTR pszSrcOID
     );
VOID WINAPI
ChainFreeOID (
     IN OUT LPSTR pszOID
     );

BOOL WINAPI
ChainAllocAndCopyUsage (
     IN PCERT_ENHKEY_USAGE pSrcUsage,
     OUT PCERT_ENHKEY_USAGE *ppDstUsage
     );
VOID WINAPI
ChainFreeUsage (
     IN OUT PCERT_ENHKEY_USAGE pUsage
     );

BOOL WINAPI
ChainIsOIDInUsage (
    IN LPSTR pszOID,
    IN PCERT_ENHKEY_USAGE pUsage
    );

VOID WINAPI
ChainIntersectUsages (
    IN PCERT_ENHKEY_USAGE pCertUsage,
    IN OUT PCERT_ENHKEY_USAGE pRestrictedUsage
    );

VOID WINAPI
ChainFreeAndClearRestrictedUsageInfo(
    IN OUT PCHAIN_RESTRICTED_USAGE_INFO pInfo
    );

BOOL WINAPI
ChainCalculateRestrictedUsage (
    IN PCERT_ENHKEY_USAGE pCertUsage,
    IN OPTIONAL PCERT_POLICY_MAPPINGS_INFO pMappings,
    IN OUT PCERT_ENHKEY_USAGE *ppRestrictedUsage,
    IN OUT PCERT_ENHKEY_USAGE *ppMappedUsage,
    IN OUT LPDWORD *ppdwMappedIndex
    );

VOID WINAPI
ChainGetUsageStatus (
     IN PCERT_ENHKEY_USAGE pRequestedUsage,
     IN PCERT_ENHKEY_USAGE pAvailableUsage,
     IN DWORD dwMatchType,
     IN OUT PCERT_TRUST_STATUS pStatus
     );

VOID WINAPI
ChainOrInStatusBits (
     IN PCERT_TRUST_STATUS pDestStatus,
     IN PCERT_TRUST_STATUS pSourceStatus
     );

BOOL WINAPI
ChainGetMatchInfoStatus (
    IN PCCERTOBJECT pIssuerObject,
    IN PCCERTOBJECT pSubjectObject,
    IN OUT DWORD *pdwInfoStatus
    );
DWORD WINAPI
ChainGetMatchInfoStatusForNoIssuer (
    IN DWORD dwIssuerMatchFlags
    );

BOOL WINAPI
ChainIsValidPubKeyMatchForIssuer (
    IN PCCERTOBJECT pIssuer,
    IN PCCERTOBJECT pSubject
    );

// Leaves Engine's lock to do signature verification
BOOL WINAPI
ChainGetSubjectStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCHAINPATHOBJECT pIssuerPathObject,
    IN PCCHAINPATHOBJECT pSubjectPathObject,
    IN OUT PCERT_TRUST_STATUS pStatus
    );

VOID WINAPI
ChainUpdateSummaryStatusByTrustStatus(
     IN OUT PCERT_TRUST_STATUS pSummaryStatus,
     IN PCERT_TRUST_STATUS pTrustStatus
     );

BOOL WINAPI
ChainIsKeyRolloverSubject(
    IN PCCHAINPATHOBJECT pIssuerPathObject,
    IN PCCHAINPATHOBJECT pSubjectPathObject
    );

//+===========================================================================
//  Format and append extended error information helper functions
//============================================================================

BOOL WINAPI
ChainAllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

VOID WINAPI
ChainAppendExtendedErrorInfo(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN LPWSTR pwszAppend,
    IN DWORD cchAppend                  // Includes NULL terminator
    );

VOID WINAPI
ChainFormatAndAppendExtendedErrorInfo(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN UINT nFormatID,
    ...
    );

//+===========================================================================
//  Name Constraint helper functions
//============================================================================
VOID WINAPI
ChainRemoveLeadingAndTrailingWhiteSpace(
    IN LPWSTR pwszIn,
    OUT LPWSTR *ppwszOut,
    OUT DWORD *pcchOut
    );

BOOL WINAPI
ChainIsRightStringInString(
    IN LPCWSTR pwszRight,
    IN DWORD cchRight,
    IN LPCWSTR pwszString,
    IN DWORD cchString
    );

BOOL WINAPI
ChainIsSpecialAtCharacterMatch(
    IN LPCWSTR pwszRight,
    IN DWORD cchRight,
    IN LPCWSTR pwszString,
    IN DWORD cchString
    );

// pAltNameEntry->pOtherName->Value.cbData is set to the following when
// Value.pbData is updated to point to a CERT_NAME_VALUE fixup
#define CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH    0xFFFFFFFF

// pAltNameEntry->pOtherName->Value.cbData less than or equal to the
// following length indicates an empty value. In a NameConstraint, it
// matches any Value.
#define CHAIN_OTHER_NAME_MAX_EMPTY_LENGTH       2

// Returns one of the following values:
//  +1 - The encoded value is a string
//   0 - The encoded value is empty (takes precedence over being a string)
//  -1 - The encoded value isn't a string
int WINAPI
ChainIsEmptyOrStringEncodedValue(
    IN PCRYPT_OBJID_BLOB pEncodedValue
    );

BOOL WINAPI
ChainFixupNameConstraintsOtherNameValue(
    IN OUT PCRYPT_OBJID_BLOB pOtherValue
    );
BOOL WINAPI
ChainAllocDecodeAndFixupNameConstraintsDirectoryName(
    IN PCERT_NAME_BLOB pDirName,
    OUT PCERT_NAME_INFO *ppNameInfo
    );
BOOL WINAPI
ChainFixupNameConstraintsAltNameEntry(
    IN BOOL fSubjectConstraint,
    IN OUT PCERT_ALT_NAME_ENTRY pEntry
    );
VOID WINAPI
ChainFreeNameConstraintsAltNameEntryFixup(
    IN BOOL fSubjectConstraint,
    IN OUT PCERT_ALT_NAME_ENTRY pEntry
    );

LPWSTR WINAPI
ChainFormatNameConstraintsAltNameEntryFixup(
    IN PCERT_ALT_NAME_ENTRY pEntry
    );

VOID WINAPI
ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN PCERT_ALT_NAME_ENTRY pEntry,
    IN UINT nFormatID,
    IN OPTIONAL DWORD dwSubtreeIndex = 0    // 0 => no subtree parameter
    );

BOOL WINAPI
ChainGetIssuerNameConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCERT_NAME_CONSTRAINTS_INFO *ppInfo
    );
VOID WINAPI
ChainFreeIssuerNameConstraintsInfo (
    IN OUT PCERT_NAME_CONSTRAINTS_INFO pInfo
    );

VOID WINAPI
ChainGetSubjectNameConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo
    );
VOID WINAPI
ChainFreeSubjectNameConstraintsInfo (
    IN OUT PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo
    );

BOOL WINAPI
ChainCompareNameConstraintsDirectoryName(
    IN PCERT_NAME_INFO pSubjectInfo,
    IN PCERT_NAME_INFO pSubtreeInfo
    );
BOOL WINAPI
ChainCompareNameConstraintsIPAddress(
    IN PCRYPT_DATA_BLOB pSubjectIPAddress,
    IN PCRYPT_DATA_BLOB pSubtreeIPAddress
    );
BOOL WINAPI
ChainCompareNameConstraintsOtherNameValue(
    IN LPCSTR pszOtherNameOID,
    IN PCRYPT_OBJID_BLOB pSubjectValue,
    IN PCRYPT_OBJID_BLOB pSubtreeValue
    );
DWORD WINAPI
ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pSubjectEntry,
    IN BOOL fExcludedSubtree,
    IN DWORD cSubtree,
    IN PCERT_GENERAL_SUBTREE pSubtree,
    IN OUT LPWSTR *ppwszExtErrorInfo
    );
DWORD WINAPI
ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pSubjectEntry,
    IN PCERT_NAME_CONSTRAINTS_INFO pNameConstraintsInfo,
    IN OUT LPWSTR *ppwszExtErrorInfo
    );

//+===========================================================================
//  CCertIssuerList helper functions
//============================================================================
BOOL WINAPI
ChainCreateIssuerList (
     IN PCCHAINPATHOBJECT pSubject,
     OUT PCCERTISSUERLIST* ppIssuerList
     );
VOID WINAPI
ChainFreeIssuerList (
     IN PCCERTISSUERLIST pIssuerList
     );

VOID WINAPI
ChainFreeCtlIssuerData (
     IN PCTL_ISSUER_DATA pCtlIssuerData
     );

//+===========================================================================
//  INTERNAL_CERT_CHAIN_CONTEXT helper functions
//============================================================================
VOID WINAPI
ChainAddRefInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     );
VOID WINAPI
ChainReleaseInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     );
VOID WINAPI
ChainFreeInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pContext
     );

VOID
ChainUpdateEndEntityCertContext(
    IN OUT PINTERNAL_CERT_CHAIN_CONTEXT pChainContext,
    IN OUT PCCERT_CONTEXT pEndCertContext
    );

//+===========================================================================
//  CERT_REVOCATION_INFO helper functions
//============================================================================

VOID WINAPI
ChainUpdateRevocationInfo (
     IN PCERT_REVOCATION_STATUS pRevStatus,
     IN OUT PCERT_REVOCATION_INFO pRevocationInfo,
     IN OUT PCERT_TRUST_STATUS pTrustStatus
     );

//+===========================================================================
//  CCertChainEngine helper functions
//============================================================================

BOOL WINAPI
ChainCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN HCERTSTORE hCA,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     IN DWORD dwStoreFlags,
     OUT HCERTSTORE* phWorld
     );
BOOL WINAPI
ChainCreateEngineStore (
     IN HCERTSTORE hRootStore,
     IN HCERTSTORE hTrustStore,
     IN HCERTSTORE hOtherStore,
     IN BOOL fDefaultEngine,
     IN DWORD dwFlags,
     OUT HCERTSTORE* phEngineStore,
     OUT HANDLE* phEngineStoreChangeEvent
     );

BOOL WINAPI
ChainIsProperRestrictedRoot (
     IN HCERTSTORE hRealRoot,
     IN HCERTSTORE hRestrictedRoot
     );

BOOL WINAPI
ChainCreateCollectionIncludingCtlCertificates (
     IN HCERTSTORE hStore,
     OUT HCERTSTORE* phCollection
     );


//+===========================================================================
//  URL helper functions
//============================================================================

//
// Cryptnet Thunk Helper API
//

typedef BOOL (WINAPI *PFN_GETOBJECTURL) (
                          IN LPCSTR pszUrlOid,
                          IN LPVOID pvPara,
                          IN DWORD dwFlags,
                          OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
                          IN OUT DWORD* pcbUrlArray,
                          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
                          IN OUT OPTIONAL DWORD* pcbUrlInfo,
                          IN OPTIONAL LPVOID pvReserved
                          );

BOOL WINAPI
ChainGetObjectUrl (
     IN LPCSTR pszUrlOid,
     IN LPVOID pvPara,
     IN DWORD dwFlags,
     OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
     IN OUT DWORD* pcbUrlArray,
     OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
     IN OUT OPTIONAL DWORD* pcbUrlInfo,
     IN OPTIONAL LPVOID pvReserved
     );

typedef BOOL (WINAPI *PFN_RETRIEVEOBJECTBYURLW) (
                          IN LPCWSTR pszUrl,
                          IN LPCSTR pszObjectOid,
                          IN DWORD dwRetrievalFlags,
                          IN DWORD dwTimeout,
                          OUT LPVOID* ppvObject,
                          IN HCRYPTASYNC hAsyncRetrieve,
                          IN PCRYPT_CREDENTIALS pCredentials,
                          IN LPVOID pvVerify,
                          IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                          );

BOOL WINAPI
ChainRetrieveObjectByUrlW (
     IN LPCWSTR pszUrl,
     IN LPCSTR pszObjectOid,
     IN DWORD dwRetrievalFlags,
     IN DWORD dwTimeout,
     OUT LPVOID* ppvObject,
     IN HCRYPTASYNC hAsyncRetrieve,
     IN PCRYPT_CREDENTIALS pCredentials,
     IN LPVOID pvVerify,
     IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
     );

BOOL WINAPI
ChainIsConnected();

BOOL
WINAPI
ChainGetHostNameFromUrl (
    IN LPWSTR pwszUrl,
    IN DWORD cchHostName,
    OUT LPWSTR pwszHostName
    );

HMODULE WINAPI
ChainGetCryptnetModule ();

//
// URL helper
//

//
// Given the number of unsuccessful attempts to retrieve the Url, returns
// the number of seconds to wait before the next attempt.
//
DWORD
WINAPI
ChainGetOfflineUrlDeltaSeconds (
    IN DWORD dwOfflineCnt
    );

//+===========================================================================
//  Debug helper functions
//============================================================================
DWORD
WINAPI
ChainGetDebugFlags();

VOID
WINAPI
ChainOutputDebugStringA(
    LPCSTR lpOutputString
    );


//+===========================================================================
//  AuthRoot Auto Update helper functions (chain.cpp)
//============================================================================

PAUTH_ROOT_AUTO_UPDATE_INFO WINAPI
CreateAuthRootAutoUpdateInfo();

VOID WINAPI
FreeAuthRootAutoUpdateInfo(
    IN OUT PAUTH_ROOT_AUTO_UPDATE_INFO pInfo
    );

BOOL WINAPI
CreateAuthRootAutoUpdateMatchCaches(
    IN PCCTL_CONTEXT pCtl,
    IN OUT HLRUCACHE  rghMatchCache[AUTH_ROOT_MATCH_CNT]
    );

VOID WINAPI
FreeAuthRootAutoUpdateMatchCaches(
    IN OUT HLRUCACHE  rghMatchCache[AUTH_ROOT_MATCH_CNT]
    );

#define SHA1_HASH_LEN               20
#define SHA1_HASH_NAME_LEN          (2 * SHA1_HASH_LEN)

LPWSTR WINAPI
FormatAuthRootAutoUpdateCertUrl(
    IN BYTE rgbSha1Hash[SHA1_HASH_LEN],
    IN PAUTH_ROOT_AUTO_UPDATE_INFO pInfo
    );

BOOL WINAPI
ChainGetAuthRootAutoUpdateStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERTOBJECT pCertObject,
    IN OUT DWORD *pdwIssuerStatusFlags
    );

//+===========================================================================
//  AuthRoot Auto Update helper functions (extract.cpp)
//============================================================================

PCCTL_CONTEXT WINAPI
ExtractAuthRootAutoUpdateCtlFromCab (
    IN PCRYPT_BLOB_ARRAY pcbaCab
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\chain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chain.cpp
//
//  Contents:   Certificate Chaining Infrastructure
//
//  History:    15-Jan-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>


//+===========================================================================
//  CCertObject methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CCertObject, public
//
//  Synopsis:   Constructor
//
//              Leaves the engine's critical section to create an object of
//              dwObjectType = CERT_END_OBJECT_TYPE. For a self-signed root
//              may also leave the critical section to retrieve and validate
//              the AuthRoot Auto Update CTL and add such a root to the
//              AuthRoot store.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
CCertObject::CCertObject (
    IN DWORD dwObjectType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERT_CONTEXT pCertContext,
    IN BYTE rgbCertHash[CHAINHASHLEN],
    OUT BOOL& rfResult
    )
{
    BOOL fLocked = TRUE;
    CRYPT_DATA_BLOB   DataBlob;
    DWORD cbData;

    if (CERT_END_OBJECT_TYPE == dwObjectType) {
        pCallContext->ChainEngine()->UnlockEngine();
        fLocked = FALSE;
    }

    m_dwObjectType = dwObjectType;
    m_cRefs = 1;

    // NOTE: The chain engine is NOT addref'd
    m_pChainEngine = pCallContext->ChainEngine();

    m_dwIssuerMatchFlags = 0;
    m_dwCachedMatchFlags = 0;
    m_dwIssuerStatusFlags = 0;
    m_dwInfoFlags = 0;
    m_pCtlCacheHead = NULL;
    m_pCertContext = CertDuplicateCertificateContext( pCertContext );
    memset(&m_PoliciesInfo, 0, sizeof(m_PoliciesInfo));
    m_pBasicConstraintsInfo = NULL;
    m_pKeyUsage = NULL;
    m_pIssuerNameConstraintsInfo = NULL;
    m_fAvailableSubjectNameConstraintsInfo = FALSE;
    memset(&m_SubjectNameConstraintsInfo, 0,
        sizeof(m_SubjectNameConstraintsInfo));
    m_pAuthKeyIdentifier = NULL;
    // m_ObjectIdentifier;
    memcpy(m_rgbCertHash, rgbCertHash, CHAINHASHLEN);
    m_cbKeyIdentifier = 0;
    m_pbKeyIdentifier = NULL;
    // m_rgbPublicKeyHash[ CHAINHASHLEN ];
    // m_rgbIssuerPublicKeyHash[ CHAINHASHLEN ];
    // m_rgbIssuerExactMatchHash[ CHAINHASHLEN ];
    // m_rgbIssuerNameMatchHash[ CHAINHASHLEN ];


    m_hHashEntry = NULL;
    m_hIdentifierEntry = NULL;
    m_hSubjectNameEntry = NULL;
    m_hKeyIdEntry = NULL;
    m_hPublicKeyHashEntry = NULL;

    m_hEndHashEntry = NULL;

    if (!CertGetCertificateContextProperty(
               pCertContext,
               CERT_KEY_IDENTIFIER_PROP_ID,
               NULL,
               &m_cbKeyIdentifier
               ))
        goto GetKeyIdentifierPropertyError;
    m_pbKeyIdentifier = new BYTE [ m_cbKeyIdentifier ];
    if (NULL == m_pbKeyIdentifier)
        goto OutOfMemory;
    if (!CertGetCertificateContextProperty(
               pCertContext,
               CERT_KEY_IDENTIFIER_PROP_ID,
               m_pbKeyIdentifier,
               &m_cbKeyIdentifier
               ))
        goto GetKeyIdentifierPropertyError;

    cbData = CHAINHASHLEN;
    if (!CertGetCertificateContextProperty(
              pCertContext,
              CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID,
              m_rgbPublicKeyHash,
              &cbData
              ) || CHAINHASHLEN != cbData)
        goto GetSubjectPublicKeyHashPropertyError;

    cbData = CHAINHASHLEN;
    if (CertGetCertificateContextProperty(
            pCertContext,
            CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID,
            m_rgbIssuerPublicKeyHash,
            &cbData
            ) && CHAINHASHLEN == cbData)
        m_dwIssuerStatusFlags |= CERT_ISSUER_PUBKEY_FLAG;

    ChainGetPoliciesInfo(pCertContext, &m_PoliciesInfo);

    if (!ChainGetBasicConstraintsInfo(pCertContext, &m_pBasicConstraintsInfo))
        m_dwInfoFlags |= CHAIN_INVALID_BASIC_CONSTRAINTS_INFO_FLAG;

    if (!ChainGetKeyUsage(pCertContext, &m_pKeyUsage))
        m_dwInfoFlags |= CHAIN_INVALID_KEY_USAGE_FLAG;

    if (!ChainGetIssuerNameConstraintsInfo(pCertContext,
            &m_pIssuerNameConstraintsInfo))
        m_dwInfoFlags |= CHAIN_INVALID_ISSUER_NAME_CONSTRAINTS_INFO_FLAG;

    if (CERT_CACHED_ISSUER_OBJECT_TYPE == dwObjectType) {
        DataBlob.cbData = CHAINHASHLEN;
        DataBlob.pbData = m_rgbCertHash;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->HashIndex(),
                          &DataBlob,
                          this,
                          &m_hHashEntry
                          ))
            goto CreateHashLruEntryError;

        // Need to double check this, only needed for issuer caching ???
        ChainCreateCertificateObjectIdentifier(
             &pCertContext->pCertInfo->Issuer,
             &pCertContext->pCertInfo->SerialNumber,
             m_ObjectIdentifier
             );

        DataBlob.cbData = sizeof( CERT_OBJECT_IDENTIFIER );
        DataBlob.pbData = m_ObjectIdentifier;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->IdentifierIndex(),
                          &DataBlob,
                          this,
                          &m_hIdentifierEntry
                          ))
            goto CreateIdentifierLruEntryError;

        DataBlob.cbData = pCertContext->pCertInfo->Subject.cbData;
        DataBlob.pbData = pCertContext->pCertInfo->Subject.pbData;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->SubjectNameIndex(),
                          &DataBlob,
                          this,
                          &m_hSubjectNameEntry
                          ))
            goto CreateSubjectNameLruEntryError;

        DataBlob.cbData = m_cbKeyIdentifier;
        DataBlob.pbData = m_pbKeyIdentifier;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->KeyIdIndex(),
                          &DataBlob,
                          this,
                          &m_hKeyIdEntry
                          ))
            goto CreateKeyIdLruEntryError;

        DataBlob.cbData = CHAINHASHLEN;
        DataBlob.pbData = m_rgbPublicKeyHash;
        if (!I_CryptCreateLruEntry(
                          m_pChainEngine->CertObjectCache()->PublicKeyHashIndex(),
                          &DataBlob,
                          this,
                          &m_hPublicKeyHashEntry
                          ))
            goto CreatePublicKeyHashLruEntryError;
    }


    ChainGetIssuerMatchInfo(
            pCertContext,
            &m_dwIssuerMatchFlags,
            &m_pAuthKeyIdentifier
            );

    ChainGetSelfSignedStatus(pCallContext, this, &m_dwIssuerStatusFlags);

    if (m_dwIssuerStatusFlags & CERT_ISSUER_SELF_SIGNED_FLAG) {
        //
        // NOTE: This means that only self-signed roots are supported
        //

        if (!fLocked) {
            pCallContext->ChainEngine()->LockEngine();
            fLocked = TRUE;
        }

        ChainGetRootStoreStatus(
             m_pChainEngine->RootStore(),
             m_pChainEngine->RealRootStore(),
             rgbCertHash,
             &m_dwIssuerStatusFlags
             );

        if (!(m_dwIssuerStatusFlags & CERT_ISSUER_TRUSTED_ROOT_FLAG)) {
            if (!ChainGetAuthRootAutoUpdateStatus(
                    pCallContext,
                    this,
                    &m_dwIssuerStatusFlags
                    ))
                goto AuthRootAutoUpdateError;
        }

        if (!(m_dwIssuerStatusFlags & CERT_ISSUER_TRUSTED_ROOT_FLAG)) {
            // Get all cached CTLs we are a member of

            CERT_OBJECT_CTL_CACHE_ENUM_DATA EnumData;

            memset(&EnumData, 0, sizeof(EnumData));
            EnumData.fResult = TRUE;
            EnumData.pCertObject = this;

            m_pChainEngine->SSCtlObjectCache()->EnumObjects(
                ChainFillCertObjectCtlCacheEnumFn,
                &EnumData
                );

            if (!EnumData.fResult) {
                SetLastError(EnumData.dwLastError);
                goto FillCertObjectCtlCacheError;
            }
        }
    }

    rfResult = TRUE;

CommonReturn:
    if (!fLocked)
        pCallContext->ChainEngine()->LockEngine();
    return;

ErrorReturn:
    rfResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetKeyIdentifierPropertyError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(GetSubjectPublicKeyHashPropertyError)
TRACE_ERROR(CreateHashLruEntryError)
TRACE_ERROR(CreateIdentifierLruEntryError)
TRACE_ERROR(CreateSubjectNameLruEntryError)
TRACE_ERROR(CreateKeyIdLruEntryError)
TRACE_ERROR(CreatePublicKeyHashLruEntryError)
TRACE_ERROR(AuthRootAutoUpdateError)
TRACE_ERROR(FillCertObjectCtlCacheError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::~CCertObject, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertObject::~CCertObject ()
{
    if ( m_hKeyIdEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hKeyIdEntry );
    }

    if ( m_hSubjectNameEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hSubjectNameEntry );
    }

    if ( m_hIdentifierEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hIdentifierEntry );
    }

    if ( m_hPublicKeyHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hPublicKeyHashEntry );
    }

    if ( m_hHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hHashEntry );
    }

    if ( m_hEndHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hEndHashEntry );
    }

    ChainFreeCertObjectCtlCache(m_pCtlCacheHead);

    delete m_pbKeyIdentifier;
    ChainFreeAuthorityKeyIdentifier( m_pAuthKeyIdentifier );
    ChainFreePoliciesInfo( &m_PoliciesInfo );
    ChainFreeBasicConstraintsInfo( m_pBasicConstraintsInfo );
    ChainFreeKeyUsage( m_pKeyUsage );
    ChainFreeIssuerNameConstraintsInfo( m_pIssuerNameConstraintsInfo );
    ChainFreeSubjectNameConstraintsInfo( &m_SubjectNameConstraintsInfo );
    CertFreeCertificateContext( m_pCertContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::CacheEndObject, public
//
//  Synopsis:   Convert a CERT_END_OBJECT_TYPE to a CERT_CACHED_END_OBJECT_TYPE.
//
//----------------------------------------------------------------------------
BOOL 
CCertObject::CacheEndObject(
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
    BOOL fResult;
    CRYPT_DATA_BLOB   DataBlob;

    assert(CERT_END_OBJECT_TYPE == m_dwObjectType);

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = m_rgbCertHash;
    fResult = I_CryptCreateLruEntry(
                      m_pChainEngine->CertObjectCache()->EndHashIndex(),
                      &DataBlob,
                      this,
                      &m_hEndHashEntry
                      );

    if (fResult)
        m_dwObjectType = CERT_CACHED_END_OBJECT_TYPE;

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::SubjectNameConstraintsInfo, public
//
//  Synopsis:   return the subject name constraints info
//
//              allocation and getting of info is deferred until the
//              first name constraint check is done.
//
//  Assumption: chain engine isn't locked upon entry.
//
//----------------------------------------------------------------------------
PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO
CCertObject::SubjectNameConstraintsInfo ()
{
    if (!m_fAvailableSubjectNameConstraintsInfo) {
        CHAIN_SUBJECT_NAME_CONSTRAINTS_INFO Info;

        memset(&Info, 0, sizeof(Info));

        ChainGetSubjectNameConstraintsInfo(m_pCertContext, &Info);

        // Must do the update while holding the engine's critical section
        m_pChainEngine->LockEngine();

        if (m_fAvailableSubjectNameConstraintsInfo)
            // Another thread already did the update
            ChainFreeSubjectNameConstraintsInfo(&Info);
        else {
            memcpy(&m_SubjectNameConstraintsInfo, &Info,
                sizeof(m_SubjectNameConstraintsInfo));


            // Must be set last!!!
            m_fAvailableSubjectNameConstraintsInfo = TRUE;
        }
    
        m_pChainEngine->UnlockEngine();
        
    }

    return &m_SubjectNameConstraintsInfo;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::GetIssuerExactMatchHash, public
//
//  Synopsis:   if the cert has an Authority Key Info extension with
//              the optional issuer and serial number, returns the count and
//              pointer to the MD5 hash of the issuer name and serial number.
//              Otherwise, pMatchHash->cbData is set to 0.
//
//              MD5 hash calculation is deferred until the first call.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
VOID
CCertObject::GetIssuerExactMatchHash(
    OUT PCRYPT_DATA_BLOB pMatchHash
    )
{
    if (!(m_dwIssuerStatusFlags & CERT_ISSUER_EXACT_MATCH_HASH_FLAG)) {
        PCERT_AUTHORITY_KEY_ID_INFO pAKI = m_pAuthKeyIdentifier;

        if (pAKI && 0 != pAKI->CertIssuer.cbData &&
                0 != pAKI->CertSerialNumber.cbData) {
            ChainCreateCertificateObjectIdentifier(
                &pAKI->CertIssuer,
                &pAKI->CertSerialNumber,
                m_rgbIssuerExactMatchHash
                );
            m_dwIssuerStatusFlags |= CERT_ISSUER_EXACT_MATCH_HASH_FLAG;
        } else {
            pMatchHash->cbData = 0;
            pMatchHash->pbData = NULL;
            return;
        }
    }
    // else
    //  We have already calculated the MD5 hash

    pMatchHash->cbData = CHAINHASHLEN;
    pMatchHash->pbData = m_rgbIssuerExactMatchHash;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::GetIssuerKeyMatchHash, public
//
//  Synopsis:   if the cert has an Authority Key Info extension with
//              the optional key id, returns the key id.
//              Otherwise, pMatchHash->cbData is set to 0.
//
//----------------------------------------------------------------------------
VOID
CCertObject::GetIssuerKeyMatchHash(
    OUT PCRYPT_DATA_BLOB pMatchHash
    )
{
    PCERT_AUTHORITY_KEY_ID_INFO pAKI = m_pAuthKeyIdentifier;

    if (pAKI)
        *pMatchHash = pAKI->KeyId;
    else {
        pMatchHash->cbData = 0;
        pMatchHash->pbData = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObject::GetIssuerNameMatchHash, public
//
//  Synopsis:   if the cert has an issuer name, returns the count and
//              pointer to the MD5 hash of the issuer name.
//              Otherwise, pMatchHash->cbData is set to 0.
//
//              MD5 hash calculation is deferred until the first call.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
VOID
CCertObject::GetIssuerNameMatchHash(
    OUT PCRYPT_DATA_BLOB pMatchHash
    )
{
    if (!(m_dwIssuerStatusFlags & CERT_ISSUER_NAME_MATCH_HASH_FLAG)) {
        PCERT_INFO pCertInfo = m_pCertContext->pCertInfo;

        if (0 != pCertInfo->Issuer.cbData) {
            MD5_CTX md5ctx;

            MD5Init( &md5ctx );
            MD5Update( &md5ctx, pCertInfo->Issuer.pbData,
                pCertInfo->Issuer.cbData );
            MD5Final( &md5ctx );

            assert(CHAINHASHLEN == MD5DIGESTLEN);
            memcpy(m_rgbIssuerNameMatchHash, md5ctx.digest, CHAINHASHLEN);

            m_dwIssuerStatusFlags |= CERT_ISSUER_NAME_MATCH_HASH_FLAG;
        } else {
            pMatchHash->cbData = 0;
            pMatchHash->pbData = NULL;
            return;
        }
    }

    pMatchHash->cbData = CHAINHASHLEN;
    pMatchHash->pbData = m_rgbIssuerNameMatchHash;
}


//+===========================================================================
//  CChainPathObject methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CChainPathObject, public
//
//  Synopsis:   Constructor
//
//  Once successfully added to the call context cache, rfAddedToCreationCache
//  is set. This object will be deleted when CChainCallContext gets destroyed.
//
//  Since this object is per call, no AddRef'ing is required.
//
//----------------------------------------------------------------------------
CChainPathObject::CChainPathObject (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN BOOL fCyclic,
    IN LPVOID pvObject,             // fCyclic : pPathObject ? pCertObject
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    OUT BOOL& rfResult,
    OUT BOOL& rfAddedToCreationCache
    )
{
    PCCERTOBJECT pCertObject;
    PCCHAINPATHOBJECT pPathObject;
    DWORD dwIssuerStatusFlags;

    rfAddedToCreationCache = FALSE;

    if (fCyclic) {
        pPathObject = (PCCHAINPATHOBJECT) pvObject;
        pCertObject = pPathObject->CertObject();
    } else {
        pPathObject = NULL;
        pCertObject = (PCCERTOBJECT) pvObject;
    }

    m_pCertObject = pCertObject;
    pCertObject->AddRef();
    memset( &m_TrustStatus, 0, sizeof( m_TrustStatus ) );
    m_dwPass1Quality = 0;
    m_dwPass1DuplicateKeyDepth = 0;
    m_dwChainIndex = 0;
    m_dwElementIndex = 0;
    m_pDownIssuerElement = NULL;
    m_pDownPathObject = NULL;
    m_pUpIssuerElement = NULL;
    m_fHasAdditionalStatus = FALSE;
    memset( &m_AdditionalStatus, 0, sizeof( m_AdditionalStatus ) );
    m_fHasRevocationInfo = FALSE;
    memset( &m_RevocationInfo, 0, sizeof( m_RevocationInfo ) );
    memset( &m_RevocationCrlInfo, 0, sizeof( m_RevocationCrlInfo ) );
    m_pIssuerList = NULL;
    m_pwszExtendedErrorInfo = NULL;
    m_fCompleted = FALSE;

    if (!ChainCreateIssuerList( this, &m_pIssuerList ))
        goto CreateIssuerListError;

    if (!pCallContext->AddPathObjectToCreationCache( this ))
        goto AddPathObjectToCreationCacheError;
    rfAddedToCreationCache = TRUE;

    if (fCyclic) {
        m_TrustStatus = pPathObject->m_TrustStatus;
        m_TrustStatus.dwInfoStatus |= ChainGetMatchInfoStatusForNoIssuer(
            pCertObject->IssuerMatchFlags());
        m_TrustStatus.dwErrorStatus |= CERT_TRUST_IS_CYCLIC;
        goto SuccessReturn;
    }

    dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
    if (dwIssuerStatusFlags & CERT_ISSUER_SELF_SIGNED_FLAG) {
        m_TrustStatus.dwInfoStatus |= CERT_TRUST_IS_SELF_SIGNED;
        ChainGetMatchInfoStatus(pCertObject, pCertObject,
            &m_TrustStatus.dwInfoStatus);
        m_dwPass1Quality |= CERT_QUALITY_COMPLETE_CHAIN |
            CERT_QUALITY_NOT_CYCLIC;

        if (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG) {
            m_dwPass1Quality |= CERT_QUALITY_SIGNATURE_VALID;
        } else {
            m_TrustStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
            m_TrustStatus.dwInfoStatus &= ~CERT_TRUST_HAS_PREFERRED_ISSUER;
        }

        if (dwIssuerStatusFlags & CERT_ISSUER_TRUSTED_ROOT_FLAG) {
            m_dwPass1Quality |= CERT_QUALITY_HAS_TRUSTED_ROOT;

            if (0 == (pCallContext->CallFlags() &
                    CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING))
                m_dwPass1Quality |= CERT_QUALITY_NO_DUPLICATE_KEY;

            // Check if we have a time valid root. This is an extra
            // check necessary to determine if we will need to do
            // AuthRoot Auto Update.

            FILETIME RequestedTime;
            PCERT_INFO pCertInfo = pCertObject->CertContext()->pCertInfo;

            pCallContext->RequestedTime(&RequestedTime);
            if ((0 == (pCallContext->CallFlags() &
                                CERT_CHAIN_TIMESTAMP_TIME)) &&
                    0 == CertVerifyTimeValidity(&RequestedTime, pCertInfo)) {
                m_dwPass1Quality |= CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT;
            } else {
                // Use current time for timestamping or try again using the
                // current time. This is necessary for cross certificate
                // chains.

                FILETIME CurrentTime;

                pCallContext->CurrentTime(&CurrentTime);
                if (0 == CertVerifyTimeValidity(&CurrentTime, pCertInfo)) {
                    m_dwPass1Quality |=
                        CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT;
                }
            }
        } else {
            m_TrustStatus.dwErrorStatus |= CERT_TRUST_IS_UNTRUSTED_ROOT;

            if (!FindAndAddCtlIssuersFromCache(pCallContext, hAdditionalStore))
                goto FindAndCtlIssuersFromCacheError;

            if (hAdditionalStore) {
                if (!FindAndAddCtlIssuersFromAdditionalStore(
                        pCallContext,
                        hAdditionalStore
                        ))
                    goto FindAndCtlIssuersFromAdditionalStoreError;
            }

            if (!(dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG))
                m_dwPass1Quality &= ~CERT_QUALITY_SIGNATURE_VALID;

            if (0 == (pCallContext->CallFlags() &
                        CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING) &&
                    m_pIssuerList->IsEmpty())
                m_dwPass1Quality |= CERT_QUALITY_NO_DUPLICATE_KEY;
        }
    } else {
        DWORD iLast;
        BOOL fGetIssuerUrlStore;

        if (!FindAndAddIssuers (
                pCallContext,
                hAdditionalStore,
                NULL                // hIssuerUrlStore
                ))
            goto FindAndAddIssuersError;

        dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
        iLast = 1;  // Default to allow AIA wire
        fGetIssuerUrlStore = FALSE;

        if (m_pIssuerList->IsEmpty())
            fGetIssuerUrlStore = TRUE;
        else if (!(dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG) ||
                !(m_dwPass1Quality & CERT_QUALITY_SIGNATURE_VALID)) {
            fGetIssuerUrlStore = TRUE;

            if (dwIssuerStatusFlags & CERT_ISSUER_URL_FLAG)
                iLast = 0; // Only do AIA cache
        }

        if (fGetIssuerUrlStore) {
            DWORD i;

            // Try the following 2 URL cases:
            //  0 - AIA cache
            //  1 - AIA wire
            // Continue through the cases until finding a "good" issuer.
            for (i = 0; i <= iLast; i++) {
                HCERTSTORE hIssuerUrlStore = NULL;
                DWORD dwRetrievalFlags;

                if (0 == i)
                    dwRetrievalFlags = CRYPT_CACHE_ONLY_RETRIEVAL;
                else {
                    if (!pCallContext->IsOnline())
                        break;
                    dwRetrievalFlags = CRYPT_WIRE_ONLY_RETRIEVAL;
                }

                // The following leaves the engine's critical section to do
                // URL fetching.  If the engine was touched by another
                // thread, it fails with LastError set to
                // ERROR_CAN_NOT_COMPLETE.
                if (!pCallContext->ChainEngine()->GetIssuerUrlStore(
                        pCallContext,
                        pCertObject->CertContext(),
                        dwRetrievalFlags,
                        &hIssuerUrlStore
                        ))
                    goto GetIssuerUrlStoreError;

                if (hIssuerUrlStore) {
                    BOOL fResult;

                    fResult = FindAndAddIssuers (
                        pCallContext,
                        hAdditionalStore,
                        hIssuerUrlStore
                        );
                    CertCloseStore(hIssuerUrlStore, 0);

                    if (!fResult)
                        goto FindAndAddIssuersFromUrlStoreError;

                    dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
                    if (!m_pIssuerList->IsEmpty() &&
                            (dwIssuerStatusFlags &
                                CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
                        assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

                        // Try to find all issuers having the same public key.
                        if (!FindAndAddIssuersByMatchType(
                                CERT_PUBKEY_ISSUER_MATCH_TYPE,
                                pCallContext,
                                hAdditionalStore,
                                NULL                    // hIssuerUrlStore
                                ))
                            goto FindIssuersByPubKeyError;

                        if (m_dwPass1Quality & CERT_QUALITY_SIGNATURE_VALID)
                            break;
                    }

                }
            }

            pCertObject->OrIssuerStatusFlags(CERT_ISSUER_URL_FLAG);
        }

        // Check if we have a time valid, signature valid, trusted root
        if ((CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT |
                CERT_QUALITY_SIGNATURE_VALID) !=
                    (m_dwPass1Quality &
                        (CERT_QUALITY_HAS_TIME_VALID_TRUSTED_ROOT |
                            CERT_QUALITY_SIGNATURE_VALID))
                            &&
                pCallContext->IsOnline()) {
            HCERTSTORE hIssuerUrlStore = NULL;

            // The following leaves the engine's critical section to do
            // URL fetching.  If the engine was touched by another
            // thread, it fails with LastError set to
            // ERROR_CAN_NOT_COMPLETE.

            // Note, we only hit the wire to fetch AuthRoots stored
            // on Microsoft's web server

            if (!GetAuthRootAutoUpdateUrlStore(
                    pCallContext,
                    &hIssuerUrlStore
                    ))
                goto GetAuthRootAutoUpdateUrlStoreError;

            if (hIssuerUrlStore) {
                BOOL fResult;

                fResult = FindAndAddIssuers (
                    pCallContext,
                    hAdditionalStore,
                    hIssuerUrlStore
                    );
                CertCloseStore(hIssuerUrlStore, 0);

                if (!fResult)
                    goto FindAndAddIssuersFromUrlStoreError;
            }
        }

        if (m_pIssuerList->IsEmpty()) {
            m_TrustStatus.dwInfoStatus |= ChainGetMatchInfoStatusForNoIssuer(
                pCertObject->IssuerMatchFlags());

            assert(0 == (m_dwPass1Quality &
                (CERT_QUALITY_HAS_TRUSTED_ROOT |
                    CERT_QUALITY_COMPLETE_CHAIN)));

            // Unable to verify our signature, default to being valid.
            // Also, we can't be cyclic.
            m_dwPass1Quality |= CERT_QUALITY_SIGNATURE_VALID |
                CERT_QUALITY_NOT_CYCLIC;

            if (0 == (pCallContext->CallFlags() &
                    CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING))
                m_dwPass1Quality |= CERT_QUALITY_NO_DUPLICATE_KEY;
        }
    }

SuccessReturn:
    rfResult = TRUE;
CommonReturn:
    m_fCompleted = TRUE;
    return;
ErrorReturn:
    rfResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateIssuerListError)
TRACE_ERROR(AddPathObjectToCreationCacheError)
TRACE_ERROR(FindAndCtlIssuersFromCacheError)
TRACE_ERROR(FindAndCtlIssuersFromAdditionalStoreError)
TRACE_ERROR(FindAndAddIssuersError)
TRACE_ERROR(GetIssuerUrlStoreError)
TRACE_ERROR(GetAuthRootAutoUpdateUrlStoreError)
TRACE_ERROR(FindAndAddIssuersFromUrlStoreError)
TRACE_ERROR(FindIssuersByPubKeyError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::~CChainPathObject, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CChainPathObject::~CChainPathObject ()
{
    if (m_pCertObject)
        m_pCertObject->Release();

    if (m_fHasRevocationInfo) {
        if (m_RevocationCrlInfo.pBaseCrlContext)
            CertFreeCRLContext(m_RevocationCrlInfo.pBaseCrlContext);
        if (m_RevocationCrlInfo.pDeltaCrlContext)
            CertFreeCRLContext(m_RevocationCrlInfo.pDeltaCrlContext);
    }

    if (m_pIssuerList)
        ChainFreeIssuerList( m_pIssuerList );
    if (m_pwszExtendedErrorInfo)
        PkiFree(m_pwszExtendedErrorInfo);
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddIssuers, public
//
//  Synopsis:   find and add issuers for all matching types
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddIssuers (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL HCERTSTORE hIssuerUrlStore
    )
{
    BOOL fResult;
    PCCERTOBJECT pCertObject = m_pCertObject;
    DWORD dwIssuerMatchFlags;
    DWORD i;

    static const rgdwMatchType[] = {
        CERT_EXACT_ISSUER_MATCH_TYPE,
        CERT_KEYID_ISSUER_MATCH_TYPE,
        CERT_NAME_ISSUER_MATCH_TYPE
    };
#define FIND_MATCH_TYPE_CNT (sizeof(rgdwMatchType) / sizeof(rgdwMatchType[0]))

    if (pCertObject->IssuerStatusFlags() & CERT_ISSUER_PUBKEY_FLAG) {
        // We know the issuer's public key. First, attempt to find all issuers
        // having that public key.
        if (!FindAndAddIssuersByMatchType(
                CERT_PUBKEY_ISSUER_MATCH_TYPE,
                pCallContext,
                hAdditionalStore,
                hIssuerUrlStore
                ))
            goto FindIssuersByPubKeyError;

        if (!m_pIssuerList->IsEmpty() &&
                (pCertObject->IssuerStatusFlags() &
                    CERT_ISSUER_VALID_SIGNATURE_FLAG))
            goto SuccessReturn;
    }

    dwIssuerMatchFlags = pCertObject->IssuerMatchFlags();

    for (i = 0; i < FIND_MATCH_TYPE_CNT; i++) {
        if (dwIssuerMatchFlags & CERT_MATCH_TYPE_TO_FLAG(rgdwMatchType[i])) {
            DWORD dwIssuerStatusFlags;

            if (!FindAndAddIssuersByMatchType(
                    rgdwMatchType[i],
                    pCallContext,
                    hAdditionalStore,
                    hIssuerUrlStore
                    ))
                goto FindIssuersByMatchTypeError;

            dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
            if (!m_pIssuerList->IsEmpty() &&
                    (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
                assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

                // We can now find all issuers having the same public key.
                if (!FindAndAddIssuersByMatchType(
                        CERT_PUBKEY_ISSUER_MATCH_TYPE,
                        pCallContext,
                        hAdditionalStore,
                        hIssuerUrlStore
                        ))
                    goto FindIssuersByPubKeyError;

                break;
            }
        }
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
    
TRACE_ERROR(FindIssuersByPubKeyError)
TRACE_ERROR(FindIssuersByMatchTypeError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddIssuersByMatchType, public
//
//  Synopsis:   find and add issuers for the specified match type
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddIssuersByMatchType(
    IN DWORD dwMatchType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL HCERTSTORE hIssuerUrlStore
    )
{
    BOOL fResult;
    PCCERTOBJECT pCertObject = m_pCertObject;

    if (NULL == hIssuerUrlStore) {
        DWORD dwIssuerStatusFlags;
        DWORD dwCachedMatchFlags;

        // Note, we need to get the cached match flags before finding
        // in the cache. Due to recursive, doing a find further up the
        // chain may result in another issuer being inserted at the beginning
        // of the cache bucket list. Pretty remote, but possible.
        dwCachedMatchFlags = pCertObject->CachedMatchFlags();

        if (!FindAndAddIssuersFromCacheByMatchType(
                dwMatchType,
                pCallContext,
                hAdditionalStore
                ))
            goto FindIssuersFromCacheError;

        dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
        if (CERT_PUBKEY_ISSUER_MATCH_TYPE != dwMatchType &&
                !m_pIssuerList->IsEmpty() &&
                    (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
            assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

            // We will be called again using the PUBKEY match
            goto SuccessReturn;
        }

        if (!(dwCachedMatchFlags & CERT_MATCH_TYPE_TO_FLAG(dwMatchType))) {
            if (!FindAndAddIssuersFromStoreByMatchType(
                    dwMatchType,
                    pCallContext,
                    FALSE,                  // fExternalStore
                    hAdditionalStore,
                    NULL                    // hIssuerUrlStore
                    ))
                goto FindIssuersFromEngineStoreError;

            dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
            if (CERT_PUBKEY_ISSUER_MATCH_TYPE != dwMatchType &&
                    !m_pIssuerList->IsEmpty() &&
                        (dwIssuerStatusFlags &
                            CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
                assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

                // We will be called again using the PUBKEY match
                goto SuccessReturn;
            }
        }
    }


    if (NULL != hAdditionalStore || NULL != hIssuerUrlStore) {
        if (!FindAndAddIssuersFromStoreByMatchType(
                dwMatchType,
                pCallContext,
                TRUE,                   // fExternalStore
                hAdditionalStore,
                hIssuerUrlStore
                ))
            goto FindIssuersFromAdditionalOrUrlStoreError;
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(FindIssuersFromCacheError)
TRACE_ERROR(FindIssuersFromEngineStoreError)
TRACE_ERROR(FindIssuersFromAdditionalOrUrlStoreError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddIssuersFromCacheByMatchType, public
//
//  Synopsis:   find and add cached issuers for the specified match type
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddIssuersFromCacheByMatchType(
    IN DWORD dwMatchType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore
    )
{
    BOOL fResult;
    PCCERTOBJECT pCertObject = m_pCertObject;
    PCCERTCHAINENGINE pChainEngine = pCertObject->ChainEngine();
    PCCERTOBJECTCACHE pCertObjectCache = pChainEngine->CertObjectCache();
    PCCERTOBJECT pIssuer = NULL;

    HLRUCACHE hCache;
    HLRUENTRY hEntry;
    PCRYPT_DATA_BLOB pIdentifier;
    CRYPT_DATA_BLOB DataBlob;

    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;

    switch (dwMatchType) {
        case CERT_EXACT_ISSUER_MATCH_TYPE:
            hCache = pCertObjectCache->IdentifierIndex();
            pCertObject->GetIssuerExactMatchHash(&DataBlob);
            pIdentifier = &DataBlob;
            break;
        case CERT_KEYID_ISSUER_MATCH_TYPE:
            hCache = pCertObjectCache->KeyIdIndex();
            pAuthKeyIdentifier = pCertObject->AuthorityKeyIdentifier();
            pIdentifier = &pAuthKeyIdentifier->KeyId;
            break;
        case CERT_NAME_ISSUER_MATCH_TYPE:
            hCache = pCertObjectCache->SubjectNameIndex();
            pIdentifier = &pCertObject->CertContext()->pCertInfo->Issuer;
            break;
        case CERT_PUBKEY_ISSUER_MATCH_TYPE:
            hCache = pCertObjectCache->PublicKeyHashIndex();
            DataBlob.cbData = CHAINHASHLEN;
            DataBlob.pbData = pCertObject->IssuerPublicKeyHash();
            pIdentifier = &DataBlob;
            break;
        default:
            goto InvalidMatchType;
    }

    pIssuer = pCertObjectCache->FindIssuerObject(hCache, pIdentifier);
    while (pIssuer) {
        DWORD dwIssuerStatusFlags;

        if (!m_pIssuerList->AddIssuer(
                pCallContext,
                hAdditionalStore,
                pIssuer
                ))
            goto AddIssuerError;

        dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
        if (CERT_PUBKEY_ISSUER_MATCH_TYPE != dwMatchType &&
                (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
            assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

            // We will be called again using the PUBKEY match
            goto SuccessReturn;
        }

        switch (dwMatchType) {
            case CERT_EXACT_ISSUER_MATCH_TYPE:
                hEntry = pIssuer->IdentifierIndexEntry();
                break;
            case CERT_KEYID_ISSUER_MATCH_TYPE:
                hEntry = pIssuer->KeyIdIndexEntry();
                break;
            case CERT_NAME_ISSUER_MATCH_TYPE:
                hEntry = pIssuer->SubjectNameIndexEntry();
                break;
            case CERT_PUBKEY_ISSUER_MATCH_TYPE:
                hEntry = pIssuer->PublicKeyHashIndexEntry();
                break;
            default:
                goto InvalidMatchType;
        }

        pIssuer = pCertObjectCache->NextMatchingIssuerObject(hEntry, pIssuer);
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (pIssuer) {
        DWORD dwErr = GetLastError();

        pIssuer->Release();

        SetLastError(dwErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidMatchType, E_UNEXPECTED)
TRACE_ERROR(AddIssuerError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddIssuersFromStoreByMatchType, public
//
//  Synopsis:   find and add issuers from either the engine's or an
//              external store for the specified match type
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddIssuersFromStoreByMatchType(
    IN DWORD dwMatchType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN BOOL fExternalStore,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL HCERTSTORE hIssuerUrlStore
    )
{
    BOOL fResult;
    PCCERTOBJECT pCertObject = m_pCertObject;
    PCCERTCHAINENGINE pChainEngine = pCertObject->ChainEngine();

    HCERTSTORE hAdditionalStoreToUse = NULL;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD dwFindType;
    const void *pvFindPara;
    CRYPT_DATA_BLOB DataBlob;
    CERT_INFO CertInfo;
    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;

    if (fExternalStore) {
        if (hIssuerUrlStore) {
            hStore = CertDuplicateStore(hIssuerUrlStore);
            if (hAdditionalStore) {
                hAdditionalStoreToUse = CertOpenStore(
                      CERT_STORE_PROV_COLLECTION,
                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                      NULL,
                      CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                      NULL
                      );
                if (NULL == hAdditionalStoreToUse)
                    goto OpenCollectionStoreError;

                if (!CertAddStoreToCollection(hAdditionalStoreToUse,
                        hIssuerUrlStore, 0, 0))
                    goto AddToCollectionStoreError;
                if (!CertAddStoreToCollection(hAdditionalStoreToUse,
                        hAdditionalStore, 0, 0))
                    goto AddToCollectionStoreError;
            } else
                hAdditionalStoreToUse = CertDuplicateStore(hIssuerUrlStore);

        } else {
            assert(hAdditionalStore);
            hStore = CertDuplicateStore(hAdditionalStore);
            hAdditionalStoreToUse = CertDuplicateStore(hAdditionalStore);
        }
    } else {
        hStore = CertDuplicateStore(pChainEngine->OtherStore());
        if (hAdditionalStore)
            hAdditionalStoreToUse = CertDuplicateStore(hAdditionalStore);
    }

    switch (dwMatchType) {
        case CERT_EXACT_ISSUER_MATCH_TYPE:
            dwFindType = CERT_FIND_SUBJECT_CERT;
            pAuthKeyIdentifier = pCertObject->AuthorityKeyIdentifier();
            CertInfo.Issuer = pAuthKeyIdentifier->CertIssuer;
            CertInfo.SerialNumber = pAuthKeyIdentifier->CertSerialNumber;
            pvFindPara = (const void *) &CertInfo;
            break;
        case CERT_KEYID_ISSUER_MATCH_TYPE:
            dwFindType = CERT_FIND_KEY_IDENTIFIER;
            pAuthKeyIdentifier = pCertObject->AuthorityKeyIdentifier();
            pvFindPara = (const void *) &pAuthKeyIdentifier->KeyId;
            break;
        case CERT_NAME_ISSUER_MATCH_TYPE:
            dwFindType = CERT_FIND_SUBJECT_NAME;
            pvFindPara =
                (const void *) &pCertObject->CertContext()->pCertInfo->Issuer;
            break;
        case CERT_PUBKEY_ISSUER_MATCH_TYPE:
            dwFindType = CERT_FIND_PUBKEY_MD5_HASH;
            DataBlob.cbData = CHAINHASHLEN;
            DataBlob.pbData = pCertObject->IssuerPublicKeyHash();
            pvFindPara = (const void *) &DataBlob;
            break;
        default:
            goto InvalidMatchType;
    }

    while (pCertContext = CertFindCertificateInStore(
            hStore,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                              // dwFindFlags
            dwFindType,
            pvFindPara,
            pCertContext
            )) {
        DWORD dwIssuerStatusFlags;
        PCCERTOBJECT pIssuer = NULL;

        if (!ChainCreateCertObject (
                fExternalStore ? CERT_EXTERNAL_ISSUER_OBJECT_TYPE :
                                 CERT_CACHED_ISSUER_OBJECT_TYPE,
                pCallContext,
                pCertContext,
                NULL,           // rgbCertHash
                &pIssuer
                ))
            goto CreateIssuerObjectError;

        fResult = m_pIssuerList->AddIssuer(
                pCallContext,
                hAdditionalStoreToUse,
                pIssuer
                );
        pIssuer->Release();
        if (!fResult)
            goto AddIssuerError;

        dwIssuerStatusFlags = pCertObject->IssuerStatusFlags();
        if (CERT_PUBKEY_ISSUER_MATCH_TYPE != dwMatchType &&
                (dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
            assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);

            // We will be called again using the PUBKEY match
            goto SuccessReturn;
        }
    }

    if (CRYPT_E_NOT_FOUND != GetLastError())
        goto FindCertificateInStoreError;

    if (!fExternalStore)
        // All matching issuers from the engine's store should be in
        // the cache now.
        pCertObject->OrCachedMatchFlags(CERT_MATCH_TYPE_TO_FLAG(dwMatchType));

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    if (hAdditionalStoreToUse)
        CertCloseStore(hAdditionalStoreToUse, 0);
    if (hStore)
        CertCloseStore(hStore, 0);

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
    
TRACE_ERROR(OpenCollectionStoreError)
TRACE_ERROR(AddToCollectionStoreError)
SET_ERROR(InvalidMatchType, E_UNEXPECTED)
TRACE_ERROR(CreateIssuerObjectError)
TRACE_ERROR(AddIssuerError)
TRACE_ERROR(FindCertificateInStoreError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddCtlIssuersFromCache, public
//
//  Synopsis:   find and add matching CTL issuers from the cache
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddCtlIssuersFromCache (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore
    )
{
    PCERT_OBJECT_CTL_CACHE_ENTRY pEntry;

    assert(m_pCertObject->IssuerStatusFlags() &
        CERT_ISSUER_SELF_SIGNED_FLAG);
    assert(!(m_pCertObject->IssuerStatusFlags() &
        CERT_ISSUER_TRUSTED_ROOT_FLAG));

    pEntry = NULL;
    while (pEntry = m_pCertObject->NextCtlCacheEntry(pEntry)) {
        PCERT_TRUST_LIST_INFO pTrustListInfo = NULL;

        if (!SSCtlAllocAndCopyTrustListInfo(
                pEntry->pTrustListInfo,
                &pTrustListInfo
                ))
            return FALSE;

        if (!m_pIssuerList->AddCtlIssuer(
                pCallContext,
                hAdditionalStore,
                pEntry->pSSCtlObject,
                pTrustListInfo
                ))
        {
            SSCtlFreeTrustListInfo(pTrustListInfo);
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::FindAndAddCtlIssuersFromAdditionalStore, public
//
//  Synopsis:   find and add matching Ctl issuers from an additional store
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::FindAndAddCtlIssuersFromAdditionalStore (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN HCERTSTORE hAdditionalStore
    )
{
    BOOL fResult;
    PCCTL_CONTEXT pCtlContext = NULL;
    PCSSCTLOBJECT pSSCtlObject = NULL;

    assert(hAdditionalStore);

    while (pCtlContext = CertEnumCTLsInStore(hAdditionalStore, pCtlContext))
    {
        PCERT_TRUST_LIST_INFO pTrustListInfo = NULL;

        pSSCtlObject = NULL;

        if (!SSCtlCreateCtlObject(
                m_pCertObject->ChainEngine(),
                pCtlContext,
                TRUE,                       // fAdditionalStore
                &pSSCtlObject
                ))
            // Should look at the different errors
            continue;
        if (!pSSCtlObject->GetTrustListInfo(
                m_pCertObject->CertContext(),
                &pTrustListInfo
                )) {
            DWORD dwErr = GetLastError();
            if (CRYPT_E_NOT_FOUND != dwErr)
                goto GetTrustListInfoError;
            else {
                pSSCtlObject->Release();
                continue;
            }
        }

        if (!m_pIssuerList->AddCtlIssuer(
                pCallContext,
                hAdditionalStore,
                pSSCtlObject,
                pTrustListInfo
                )) {
            SSCtlFreeTrustListInfo(pTrustListInfo);
            goto AddCtlIssuerError;
        }

        pSSCtlObject->Release();
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    if (pCtlContext)
        CertFreeCTLContext(pCtlContext);
    if (pSSCtlObject)
        pSSCtlObject->Release();

    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetTrustListInfoError)
TRACE_ERROR(AddCtlIssuerError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::NextPath, public
//
//  Synopsis:   Get the next top path object for this end path object.
//              If CERT_QUALITY_NO_DUPLICATE_KEY is set in the
//              Pass1Quality, advances past paths containing duplicate keys.
//
//----------------------------------------------------------------------------
PCCHAINPATHOBJECT
CChainPathObject::NextPath (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL PCCHAINPATHOBJECT pPrevTopPathObject
    )
{
    PCCHAINPATHOBJECT pTopPathObject = pPrevTopPathObject;

    while (pTopPathObject = NextPathWithoutDuplicateKeyCheck(
            pCallContext,
            pTopPathObject
            )) {
        BOOL fDuplicateKey = FALSE;
        PCCHAINPATHOBJECT pSubjectObject;

        for (pSubjectObject = pTopPathObject->m_pDownPathObject;
                NULL != pSubjectObject;
                    pSubjectObject = pSubjectObject->m_pDownPathObject) {
            if (0 == (pSubjectObject->m_dwPass1Quality &
                    CERT_QUALITY_NO_DUPLICATE_KEY))
                break;

            LPBYTE pbSubjectPublicKeyHash =
                pSubjectObject->m_pCertObject->PublicKeyHash();
            PCERT_ISSUER_ELEMENT pIssuerElement;
            PCCHAINPATHOBJECT pIssuerObject;

            for (pIssuerElement = pSubjectObject->m_pUpIssuerElement;
                NULL != pIssuerElement &&
                    NULL != (pIssuerObject = pIssuerElement->pIssuer);
                        pIssuerElement = pIssuerObject->m_pUpIssuerElement) {
                if (0 == memcmp(pbSubjectPublicKeyHash,
                        pIssuerObject->m_pCertObject->PublicKeyHash(),
                        CHAINHASHLEN)) {
                    fDuplicateKey = TRUE;
                    break;
                }
            }

            if (fDuplicateKey)
                break;
            
        }

        if (!fDuplicateKey)
            break;
    }

    return pTopPathObject;
}

VOID
CChainPathObject::ResetNextPath (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL PCCHAINPATHOBJECT pTopPathObject
    )
{
    while (pTopPathObject) {
        PCERT_ISSUER_ELEMENT pSubjectIssuerElement =
            pTopPathObject->m_pDownIssuerElement;
        PCCHAINPATHOBJECT pSubjectPathObject =
            pTopPathObject->m_pDownPathObject;

        pTopPathObject->m_pDownPathObject = NULL;
        pTopPathObject->m_fHasAdditionalStatus = FALSE;
        pTopPathObject->m_pDownIssuerElement = NULL;

        if (pSubjectIssuerElement &&
                pSubjectIssuerElement->pCyclicSaveIssuer) {

            // Remove and delete the cyclic path object
            ChainDeleteCyclicPathObject(
                pCallContext,
                pSubjectIssuerElement->pIssuer
                );

            // Restore the issuer replaced by the cyclic issuer
            pSubjectIssuerElement->pIssuer =
                pSubjectIssuerElement->pCyclicSaveIssuer;
            pSubjectIssuerElement->pCyclicSaveIssuer = NULL;
        }


        pTopPathObject = pSubjectPathObject;
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::NextPathWithoutDuplicateKeyCheck, public
//
//  Synopsis:   Get the next top path object for this end path object
//              without checking for duplicate keys.
//
//----------------------------------------------------------------------------
PCCHAINPATHOBJECT
CChainPathObject::NextPathWithoutDuplicateKeyCheck (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL PCCHAINPATHOBJECT pPrevTopPathObject
    )
{
    PCCHAINPATHOBJECT pTopPathObject;
    PCERT_ISSUER_ELEMENT pSubjectIssuerElement;
    PCCHAINPATHOBJECT pSubjectPathObject;
    DWORD dwFlags = pCallContext->CallFlags();

    if (NULL == pPrevTopPathObject) {
        pSubjectIssuerElement = NULL;
        pSubjectPathObject = NULL;
    } else {
        // Find the next issuer for the issuer's subject certificate.
        // We iterate downward toward the end certificate
        while (TRUE) {
            pSubjectIssuerElement = pPrevTopPathObject->m_pDownIssuerElement;
            pSubjectPathObject = pPrevTopPathObject->m_pDownPathObject;

            // Set to NULL so it can be reused. Used to determine if
            // cyclic.
            pPrevTopPathObject->m_pDownPathObject = NULL;
            pPrevTopPathObject->m_fHasAdditionalStatus = FALSE;


            if (NULL == pSubjectPathObject) {
                // We have reached the end certificate without having a
                // next path
                SetLastError((DWORD) CRYPT_E_NOT_FOUND);
                goto NoPath;
            }

            assert(pSubjectIssuerElement);
            if (pSubjectIssuerElement->pCyclicSaveIssuer) {

                // Remove and delete the cyclic path object
                ChainDeleteCyclicPathObject(
                    pCallContext,
                    pSubjectIssuerElement->pIssuer
                    );

                // Restore the issuer replaced by the cyclic issuer
                pSubjectIssuerElement->pIssuer =
                    pSubjectIssuerElement->pCyclicSaveIssuer;
                pSubjectIssuerElement->pCyclicSaveIssuer = NULL;
            }

            // Move on to the next issuer for the subject. Skip low
            // quality issuers
            while (pSubjectIssuerElement =
                    pSubjectPathObject->m_pIssuerList->NextElement(
                                                    pSubjectIssuerElement)) {
                if ((dwFlags & CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING)
                                    ||
                        ((pSubjectIssuerElement->dwPass1Quality >=
                            pSubjectPathObject->m_dwPass1Quality) &&
                         (pSubjectIssuerElement->dwPass1DuplicateKeyDepth <=
                            pSubjectPathObject->m_dwPass1DuplicateKeyDepth))) {
                    // For a CTL, check that we have an issuer
                    if (NULL != pSubjectIssuerElement->pIssuer)
                        break;
                    else {
                        assert(pSubjectIssuerElement->fCtlIssuer);
                    }
                }
            }

            if (pSubjectIssuerElement)
                // The subject has another issuer
                break;

            // Note, a untrusted self signed root without CTLs is equal and
            // possibly higher quality than having untrusted CTLs
            if ((pSubjectPathObject->m_TrustStatus.dwInfoStatus &
                    CERT_TRUST_IS_SELF_SIGNED) && 
                    (dwFlags & CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING) &&
                    !(pSubjectPathObject->m_dwPass1Quality &
                        CERT_QUALITY_HAS_TRUSTED_ROOT)) {
                pTopPathObject = pSubjectPathObject;
                pTopPathObject->m_pUpIssuerElement = NULL;
                goto SelfSignedRootInsteadOfCtlPathReturn;
            }

            // Find the next issuer for my subject
            pPrevTopPathObject = pSubjectPathObject;
        }
    }

    // Iterate upward until the TopPathObject's issuer list is empty or
    // we have detected a cyclic PathObject
    while (TRUE) {
        if (NULL == pSubjectIssuerElement) {
            // End (bottom) certificate
            pTopPathObject = this;
            pTopPathObject->m_dwChainIndex = 0;
            pTopPathObject->m_dwElementIndex = 0;
        } else {
            pTopPathObject = pSubjectIssuerElement->pIssuer;
            // Determine if cyclic.
            if (pTopPathObject->m_pDownPathObject ||
                    pTopPathObject == this) {
                // The returned Cyclic path won't have any issuers
                if (!ChainCreateCyclicPathObject(
                        pCallContext,
                        pTopPathObject,
                        &pTopPathObject
                        ))
                    goto CreateCyclicPathObjectError;
                pSubjectIssuerElement->pCyclicSaveIssuer = 
                    pSubjectIssuerElement->pIssuer;
                pSubjectIssuerElement->pIssuer = pTopPathObject;
            }

            if (pSubjectPathObject->m_TrustStatus.dwInfoStatus &
                    CERT_TRUST_IS_SELF_SIGNED) {
                pTopPathObject->m_dwChainIndex =
                    pSubjectPathObject->m_dwChainIndex + 1;
                pTopPathObject->m_dwElementIndex = 0;
            } else {
                pTopPathObject->m_dwChainIndex =
                    pSubjectPathObject->m_dwChainIndex;
                pTopPathObject->m_dwElementIndex =
                    pSubjectPathObject->m_dwElementIndex + 1;
            }

            pSubjectPathObject->m_pUpIssuerElement = pSubjectIssuerElement;

        }

        pTopPathObject->m_pDownIssuerElement = pSubjectIssuerElement;
        pTopPathObject->m_pDownPathObject = pSubjectPathObject;

        pSubjectPathObject = pTopPathObject;

        // Find the first issuer having sufficient quality
        pSubjectIssuerElement = NULL;
        while (pSubjectIssuerElement =
                pSubjectPathObject->m_pIssuerList->NextElement(
                                                pSubjectIssuerElement)) {
            if ((dwFlags & CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING)
                            ||
                    ((pSubjectIssuerElement->dwPass1Quality >=
                        pSubjectPathObject->m_dwPass1Quality) &&
                     (pSubjectIssuerElement->dwPass1DuplicateKeyDepth <=
                        pSubjectPathObject->m_dwPass1DuplicateKeyDepth))) {
                // For a CTL, check that we have an issuer
                if (NULL != pSubjectIssuerElement->pIssuer)
                    break;
                else {
                    assert(pSubjectIssuerElement->fCtlIssuer);
                }
            }
        }

        if (NULL == pSubjectIssuerElement) {
            pTopPathObject->m_pUpIssuerElement = NULL;
            break;
        }

    }

SelfSignedRootInsteadOfCtlPathReturn:
CommonReturn:
    return pTopPathObject;

NoPath:
ErrorReturn:
    pTopPathObject = NULL;
    goto CommonReturn;
TRACE_ERROR(CreateCyclicPathObjectError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateAdditionalStatus, public
//
//  Synopsis:   calculate additional status bits based on time, usage,
//              revocation, ...
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateAdditionalStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN HCERTSTORE hAllStore
    )
{
    PCERT_INFO pCertInfo = m_pCertObject->CertContext()->pCertInfo;
    FILETIME RequestedTime;
    FILETIME CurrentTime;

    assert(!m_fHasAdditionalStatus);
    memset(&m_AdditionalStatus, 0, sizeof(m_AdditionalStatus));
    if (m_pwszExtendedErrorInfo) {
        PkiFree(m_pwszExtendedErrorInfo);
        m_pwszExtendedErrorInfo = NULL;
    }

    pCallContext->RequestedTime(&RequestedTime);
    pCallContext->CurrentTime(&CurrentTime);

    if (0 == m_dwChainIndex) {
        // First simple chain

        if (0 == m_dwElementIndex) {
            // End cert
            if (pCallContext->CallFlags() & CERT_CHAIN_TIMESTAMP_TIME) {
                // For time stamping, the end certificate needs to be valid
                // for both the time stamped and current times.
                if (0 != CertVerifyTimeValidity(&RequestedTime, pCertInfo) ||
                        0 != CertVerifyTimeValidity(&CurrentTime, pCertInfo))
                    m_AdditionalStatus.dwErrorStatus |=
                        CERT_TRUST_IS_NOT_TIME_VALID;
            } else {
                // End certificate needs to be valid for the requested time
                if (0 != CertVerifyTimeValidity(&RequestedTime, pCertInfo))
                    m_AdditionalStatus.dwErrorStatus |=
                        CERT_TRUST_IS_NOT_TIME_VALID;
            }
        } else {
            // CA or root
            if (pCallContext->CallFlags() & CERT_CHAIN_TIMESTAMP_TIME) {
                // For time stamping, the CA or root needs to be valid using
                // current time
                if (0 != CertVerifyTimeValidity(&CurrentTime, pCertInfo))
                    m_AdditionalStatus.dwErrorStatus |=
                        CERT_TRUST_IS_NOT_TIME_VALID;
            } else {
                // The CA or root needs to be valid using either the requested
                // or current time. Allowing current time is necessary for
                // cross certificate chains.
                if (!(0 == CertVerifyTimeValidity(&RequestedTime, pCertInfo) ||
                        0 == CertVerifyTimeValidity(&CurrentTime, pCertInfo)))
                    m_AdditionalStatus.dwErrorStatus |=
                        CERT_TRUST_IS_NOT_TIME_VALID;
            }
        }
    } else {
        // CTL signer chains. Must be valid using current time.
        if (0 != CertVerifyTimeValidity(&CurrentTime, pCertInfo))
            m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_TIME_VALID;
    }
        
    if (m_pDownIssuerElement) {
        PCERT_USAGE_MATCH pUsageToUse;
        CERT_USAGE_MATCH CtlUsage;
        LPSTR pszUsage = szOID_KP_CTL_USAGE_SIGNING;

        // Update subject's issuer status
        assert (m_pDownIssuerElement->pIssuer = this);


        if (0 != m_pDownPathObject->m_dwChainIndex) {
            // CTL path object
            memset(&CtlUsage, 0, sizeof(CtlUsage));

            CtlUsage.dwType = USAGE_MATCH_TYPE_AND;
            CtlUsage.Usage.cUsageIdentifier = 1;
            CtlUsage.Usage.rgpszUsageIdentifier = &pszUsage;

            pUsageToUse = &CtlUsage;
        } else
            pUsageToUse = &pCallContext->ChainPara()->RequestedUsage;

        if (m_pDownIssuerElement->fCtlIssuer) {
            FILETIME CurrentTime;

            memset(&m_pDownIssuerElement->SubjectStatus, 0,
                sizeof(m_pDownIssuerElement->SubjectStatus));
            pCallContext->CurrentTime(&CurrentTime);
            m_pDownIssuerElement->pCtlIssuerData->pSSCtlObject->
                CalculateStatus(
                    &CurrentTime,
                    pUsageToUse,
                    &m_pDownIssuerElement->SubjectStatus
                    );
        } else {
            CalculatePolicyConstraintsStatus();
            CalculateBasicConstraintsStatus();
            CalculateKeyUsageStatus();
            CalculateNameConstraintsStatus(pUsageToUse);
        }
    }

    if (pCallContext->CallFlags() & CERT_CHAIN_REVOCATION_CHECK_ALL) {
        // For CTL signer chains, always use current time
        CalculateRevocationStatus(
            pCallContext,
            hAllStore,
            0 == m_dwChainIndex ? &RequestedTime : &CurrentTime
            );
    }

    m_fHasAdditionalStatus = TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculatePolicyConstraintsStatus, public
//
//  Synopsis:   calculate policy constraints additional status for this
//              issuer
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculatePolicyConstraintsStatus ()
{
    PCHAIN_POLICIES_INFO pPoliciesInfo;
    DWORD i;

    assert (0 != m_dwElementIndex);

    pPoliciesInfo = m_pCertObject->PoliciesInfo();
    for (i = 0; i < CHAIN_ISS_OR_APP_COUNT; i++ ) {
        PCERT_POLICY_CONSTRAINTS_INFO pConstraints =
            pPoliciesInfo->rgIssOrAppInfo[i].pConstraints;

        DWORD dwRequireSkipCerts;
        DWORD dwInhibitSkipCerts;
        PCCHAINPATHOBJECT pPathObject;
        PCCHAINPATHOBJECT pIssuerObject;

        if (NULL == pConstraints)
            continue;

        dwRequireSkipCerts = pConstraints->dwRequireExplicitPolicySkipCerts;
        dwInhibitSkipCerts = pConstraints->dwInhibitPolicyMappingSkipCerts;
        for (pIssuerObject = this, pPathObject = m_pDownPathObject;
                NULL != pPathObject &&
                    pPathObject->m_dwChainIndex == m_dwChainIndex;
                                pIssuerObject = pPathObject,
                                pPathObject = pPathObject->m_pDownPathObject) {
                PCHAIN_POLICIES_INFO pSubjectPoliciesInfo;

            if (ChainIsKeyRolloverSubject(pIssuerObject, pPathObject))
                continue;

            pSubjectPoliciesInfo = pPathObject->m_pCertObject->PoliciesInfo();

            if (pConstraints->fRequireExplicitPolicy) {
                if (0 < dwRequireSkipCerts)
                    dwRequireSkipCerts--;
                else {
                    if (NULL == pSubjectPoliciesInfo->rgIssOrAppInfo[i].pPolicy)
                    {
                        m_AdditionalStatus.dwErrorStatus |=
                            CERT_TRUST_INVALID_POLICY_CONSTRAINTS;
                        goto RequireExplicitPolicyError;
                    }
                }
            }

            if (pConstraints->fInhibitPolicyMapping) {
                if (0 < dwInhibitSkipCerts)
                    dwInhibitSkipCerts--;
                else {
                    if (pSubjectPoliciesInfo->rgIssOrAppInfo[i].pMappings)
                    {
                        m_AdditionalStatus.dwErrorStatus |=
                            CERT_TRUST_INVALID_POLICY_CONSTRAINTS;
                        goto InhibitPolicyMappingError;
                    }
                }
            }
        }
    }

CommonReturn:
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(RequireExplicitPolicyError)
TRACE_ERROR(InhibitPolicyMappingError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateBasicConstraintsStatus, public
//
//  Synopsis:   calculate basic constraints additional status for this
//              issuer
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateBasicConstraintsStatus ()
{
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo;

    assert (0 != m_dwElementIndex);

    if (m_pCertObject->InfoFlags() &
            CHAIN_INVALID_BASIC_CONSTRAINTS_INFO_FLAG) {
        m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
    }

    pInfo = m_pCertObject->BasicConstraintsInfo();
    if (NULL == pInfo) {
        if (0 != (m_TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED) ||
               CertObject()->ChainEngine()->DisableMandatoryBasicConstraints())
            return;

        m_AdditionalStatus.dwErrorStatus |=
            CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
        goto BasicConstraintsError;
    }

    if (!pInfo->fCA) {
        m_AdditionalStatus.dwErrorStatus |=
            CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
        goto BasicConstraintsError;
    }

    if (pInfo->fPathLenConstraint &&
            m_dwElementIndex > pInfo->dwPathLenConstraint + 1) {

        DWORD dwElementIndex;
        PCCHAINPATHOBJECT pIssuer;
        PCCHAINPATHOBJECT pSubject;

        // Remove any key rollover entries
        for (pIssuer = this,
             pSubject = m_pDownPathObject,
             dwElementIndex = m_dwElementIndex;
                    NULL != pSubject &&
                        pSubject->m_dwChainIndex == m_dwChainIndex;
                                    pIssuer = pSubject,
                                    pSubject = pSubject->m_pDownPathObject) {
            if (ChainIsKeyRolloverSubject(pIssuer, pSubject))
                dwElementIndex--;
        }

        if (dwElementIndex > pInfo->dwPathLenConstraint + 1) {
            m_AdditionalStatus.dwErrorStatus |=
                CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
            goto BasicConstraintsError;
        }
    }

CommonReturn:
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(BasicConstraintsError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateKeyUsageStatus, public
//
//  Synopsis:   calculate key usage additional status for this
//              issuer
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateKeyUsageStatus ()
{
    PCRYPT_BIT_BLOB pKeyUsage;

    assert (0 != m_dwElementIndex);

    if (m_pCertObject->InfoFlags() & CHAIN_INVALID_KEY_USAGE_FLAG) {
        m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    }

    pKeyUsage = m_pCertObject->KeyUsage();
    if (NULL == pKeyUsage)
        return;

    if (1 > pKeyUsage->cbData ||
            0 == (pKeyUsage->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE)) {
        m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
        goto KeyUsageError;
    }

CommonReturn:
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(KeyUsageError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateNameConstraintsStatus, public
//
//  Synopsis:   calculate name constraints additional status for this
//              issuer
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateNameConstraintsStatus (
    IN PCERT_USAGE_MATCH pUsageToUse
    )
{
    PCERT_NAME_CONSTRAINTS_INFO pIssuerInfo;
    PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo;
    PCERT_BASIC_CONSTRAINTS2_INFO pSubjectBasicInfo;
    PCCHAINPATHOBJECT pSubjectObject;
    DWORD dwErrorStatus = 0;

    assert (0 != m_dwElementIndex);

    if (m_pCertObject->InfoFlags() &
            CHAIN_INVALID_ISSUER_NAME_CONSTRAINTS_INFO_FLAG) {
        m_AdditionalStatus.dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_INVALID_NAME_CONSTRAINTS;

        ChainFormatAndAppendExtendedErrorInfo(
            &m_pwszExtendedErrorInfo,
            IDS_INVALID_ISSUER_NAME_CONSTRAINT_EXT
            );
    }
    
    pIssuerInfo = m_pCertObject->IssuerNameConstraintsInfo();
    if (NULL == pIssuerInfo)
        // No NameConstraint check
        return;

    // We only verify the name constraints on the end cert
    for (pSubjectObject = m_pDownPathObject;
            NULL != pSubjectObject && 0 != pSubjectObject->m_dwElementIndex;
                        pSubjectObject = pSubjectObject->m_pDownPathObject)
        ;

    assert(pSubjectObject);
    assert(pSubjectObject->m_dwChainIndex == m_dwChainIndex);
    if (NULL == pSubjectObject)
        return;

    pSubjectBasicInfo = pSubjectObject->m_pCertObject->BasicConstraintsInfo();
    if (pSubjectBasicInfo && pSubjectBasicInfo->fCA)
        // End cert is a CA.
        return;

    pSubjectInfo = pSubjectObject->m_pCertObject->SubjectNameConstraintsInfo();

    if (pSubjectInfo->fInvalid) {
        dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_INVALID_NAME_CONSTRAINTS;

        ChainFormatAndAppendExtendedErrorInfo(
            &m_pwszExtendedErrorInfo,
            IDS_INVALID_SUBJECT_NAME_CONSTRAINT_INFO
            );

        goto InvalidNameConstraints;
    }

    if (pSubjectInfo->pAltNameInfo) {
        // Loop through all the AltName entries. There needs to be a
        // name constraint for each entry.
        DWORD cEntry;
        PCERT_ALT_NAME_ENTRY pEntry;
            
        cEntry = pSubjectInfo->pAltNameInfo->cAltEntry;
        pEntry = pSubjectInfo->pAltNameInfo->rgAltEntry;
        for ( ; 0 < cEntry; cEntry--, pEntry++) {
            BOOL fSupported;

            // Check if a NameConstraint for this entry choice is supported
            fSupported = FALSE;
            switch (pEntry->dwAltNameChoice) {
                case CERT_ALT_NAME_OTHER_NAME:
                case CERT_ALT_NAME_RFC822_NAME:
                case CERT_ALT_NAME_DNS_NAME:
                case CERT_ALT_NAME_URL:
                case CERT_ALT_NAME_DIRECTORY_NAME:
                    fSupported = TRUE;
                    break;
                case CERT_ALT_NAME_IP_ADDRESS:
                    // Only support 4 or 16 byte IP addresses
                    if (4 == pEntry->IPAddress.cbData ||
                            16 == pEntry->IPAddress.cbData)
                        fSupported = TRUE;
                    break;
                case CERT_ALT_NAME_X400_ADDRESS:
                case CERT_ALT_NAME_EDI_PARTY_NAME:
                case CERT_ALT_NAME_REGISTERED_ID:
                default:
                    // Not supported
                    break;
            }

            if (!fSupported) {
                dwErrorStatus |= CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;

                ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
                    &m_pwszExtendedErrorInfo,
                    pEntry,
                    IDS_NOT_SUPPORTED_ENTRY_NAME_CONSTRAINT
                    );
            } else
                dwErrorStatus |=
                    ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
                        pEntry, pIssuerInfo, &m_pwszExtendedErrorInfo);
        }
    }

    if (pSubjectInfo->pUnicodeNameInfo) {
        // Check as a DIRECTORY_NAME AltNameEntry choice. The DIRECTORY_NAME
        // fixup expects the DirectoryName.pbData to be the decoded and
        // fixup'ed UnicodeNameInfo.

        CERT_ALT_NAME_ENTRY Entry;

        Entry.dwAltNameChoice = CERT_ALT_NAME_DIRECTORY_NAME;
        Entry.DirectoryName.pbData = (BYTE *) pSubjectInfo->pUnicodeNameInfo;
        dwErrorStatus |=
            ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
               &Entry, pIssuerInfo, &m_pwszExtendedErrorInfo);
    }

    if (pSubjectInfo->pEmailAttr) {
        // The SubjectAltName doesn't have an email choice. However, there is an
        // email attribute in the Subject UnicodeNameInfo.
        //
        // Check as a CERT_ALT_NAME_RFC822_NAME AltNameEntry choice. The
        // RFC822 fixup uses the DirectoryName.pbData and DirectoryName.cbData
        // to contain the pointer to and length of the unicode string.

        CERT_ALT_NAME_ENTRY Entry;
        Entry.dwAltNameChoice = CERT_ALT_NAME_RFC822_NAME;
        Entry.DirectoryName = pSubjectInfo->pEmailAttr->Value;
        dwErrorStatus |=
            ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
               &Entry, pIssuerInfo, &m_pwszExtendedErrorInfo);
    }


    if (!pSubjectInfo->fHasDnsAltNameEntry &&
            NULL != pSubjectInfo->pUnicodeNameInfo &&
            ChainIsOIDInUsage(szOID_PKIX_KP_SERVER_AUTH, &pUsageToUse->Usage)) {
        // The SubjectAltName doesn't have a DNS choice and we are building
        // a ServerAuth chain.

        // Need to check all the CN components in the UnicodeNameInfo.

        DWORD cRDN;
        PCERT_RDN pRDN;

        cRDN = pSubjectInfo->pUnicodeNameInfo->cRDN;
        pRDN = pSubjectInfo->pUnicodeNameInfo->rgRDN;
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                    continue;
                if (0 == strcmp(pAttr->pszObjId, szOID_COMMON_NAME)) {
                    //
                    // Check as a CERT_ALT_NAME_DNS_NAME AltNameEntry choice.
                    // The DNS fixup uses the DirectoryName.pbData and
                    // DirectoryName.cbData to contain the pointer to and
                    // length of the unicode string.

                    CERT_ALT_NAME_ENTRY Entry;
                    Entry.dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
                    Entry.DirectoryName = pAttr->Value;
                    dwErrorStatus |=
                        ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
                           &Entry, pIssuerInfo, &m_pwszExtendedErrorInfo);
                }
            }
        }
    }

CommonReturn:
    if (0 == dwErrorStatus)
        m_AdditionalStatus.dwInfoStatus |= CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS;
    else
        m_AdditionalStatus.dwErrorStatus |= dwErrorStatus;
    return;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(InvalidNameConstraints)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CalculateRevocationStatus, public
//
//  Synopsis:   calculate additional status bits based on revocation
//
//----------------------------------------------------------------------------
VOID
CChainPathObject::CalculateRevocationStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN HCERTSTORE hCrlStore,
    IN LPFILETIME pTime
    )
{
    CERT_REVOCATION_PARA   RevPara;
    CERT_REVOCATION_STATUS RevStatus;
    DWORD                  dwRevFlags;
    DWORD                  dwFlags = pCallContext->CallFlags();
    PCERT_CHAIN_PARA       pChainPara  = pCallContext->ChainPara();
    FILETIME               CurrentTime;

    assert(dwFlags & CERT_CHAIN_REVOCATION_CHECK_ALL);

    memset( &RevPara, 0, sizeof( RevPara ) );
    RevPara.cbSize = sizeof( RevPara );
    RevPara.hCrlStore = hCrlStore;
    RevPara.pftTimeToUse = pTime;
    RevPara.dwUrlRetrievalTimeout =
        pCallContext->RevocationUrlRetrievalTimeout();
    RevPara.fCheckFreshnessTime = pChainPara->fCheckRevocationFreshnessTime;
    RevPara.dwFreshnessTime = pChainPara->dwRevocationFreshnessTime;
    pCallContext->CurrentTime(&CurrentTime);
    RevPara.pftCurrentTime = &CurrentTime;

    memset( &RevStatus, 0, sizeof( RevStatus ) );
    RevStatus.cbSize = sizeof( RevStatus );

    dwRevFlags = 0;
    if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY)
        dwRevFlags |= CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION;
    if (dwFlags & CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT)
        dwRevFlags |= CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG;

    if (!m_fHasRevocationInfo) {
        BOOL fHasRevocationInfo = FALSE;

        if (m_TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED) {
            BOOL fDoRevocation = FALSE;

            if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT) {
                ;
            } else if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_END_CERT) {
                if (0 == m_dwChainIndex && 0 == m_dwElementIndex)
                    fDoRevocation = TRUE;
            } else {
                assert(dwFlags & CERT_CHAIN_REVOCATION_CHECK_CHAIN);
                fDoRevocation = TRUE;
            }

            if (fDoRevocation) {
                PCCERT_CONTEXT pSubjectCert = m_pCertObject->CertContext();
                RevPara.pIssuerCert = m_pCertObject->CertContext();
                RevPara.pCrlInfo = &m_RevocationCrlInfo;
                m_RevocationCrlInfo.cbSize = sizeof(m_RevocationCrlInfo);

                RevStatus.dwError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
                if (IsValidCertQualityForRevocationCheck(m_dwPass1Quality))
                    CertVerifyRevocation(
                        X509_ASN_ENCODING,
                        CERT_CONTEXT_REVOCATION_TYPE,
                        1,
                        (LPVOID *) &pSubjectCert,
                        dwRevFlags,
                        &RevPara,
                        &RevStatus
                        );
                fHasRevocationInfo = TRUE;
            }
        } else if (NULL == m_pUpIssuerElement) {
            if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_END_CERT) {
                if (0 == m_dwChainIndex && 0 == m_dwElementIndex)
                    fHasRevocationInfo = TRUE;
            } else {
                fHasRevocationInfo = TRUE;
            }

            if (fHasRevocationInfo) {
                RevStatus.dwError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
            }
        }


        if (fHasRevocationInfo) {
            ChainUpdateRevocationInfo(&RevStatus, &m_RevocationInfo,
                &m_TrustStatus);
            m_fHasRevocationInfo = TRUE;

            memset( &RevStatus, 0, sizeof( RevStatus ) );
            RevStatus.cbSize = sizeof( RevStatus );
        }
    }

    if (m_pDownIssuerElement && !m_pDownIssuerElement->fCtlIssuer &&
            !m_pDownIssuerElement->fHasRevocationInfo) {
        BOOL fDoRevocation = FALSE;

        if (dwFlags & CERT_CHAIN_REVOCATION_CHECK_END_CERT) {
            if (0 == m_dwChainIndex && 1 == m_dwElementIndex)
                fDoRevocation = TRUE;
        } else {
            fDoRevocation = TRUE;
        }

        if (fDoRevocation) {
            PCCERT_CONTEXT pSubjectCert =
                m_pDownPathObject->m_pCertObject->CertContext();
            RevPara.pIssuerCert = m_pCertObject->CertContext();
            RevPara.pCrlInfo = &m_pDownIssuerElement->RevocationCrlInfo;
            m_pDownIssuerElement->RevocationCrlInfo.cbSize =
                sizeof(m_pDownIssuerElement->RevocationCrlInfo);

            RevStatus.dwError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;

            if (IsValidCertQualityForRevocationCheck(
                    m_pDownIssuerElement->dwPass1Quality)) {
                BOOL fRevokedIssuer = FALSE;
                PCCHAINPATHOBJECT pIssuerObject = this;

                while (TRUE) {
                    PCERT_ISSUER_ELEMENT pIssuerElement =
                        pIssuerObject->m_pUpIssuerElement;

                    if (NULL == pIssuerElement) {
                        if (pIssuerObject->m_TrustStatus.dwErrorStatus &
                                CERT_TRUST_IS_REVOKED)
                            fRevokedIssuer = TRUE;
                        break;
                    } else {
                        if (pIssuerElement->SubjectStatus.dwErrorStatus &
                                CERT_TRUST_IS_REVOKED) {
                            fRevokedIssuer = TRUE;
                            break;
                        }
                        pIssuerObject = pIssuerElement->pIssuer;
                    }
                }
                        
                if (!fRevokedIssuer)
                    CertVerifyRevocation(
                        X509_ASN_ENCODING,
                        CERT_CONTEXT_REVOCATION_TYPE,
                        1,
                        (LPVOID *) &pSubjectCert,
                        dwRevFlags,
                        &RevPara,
                        &RevStatus
                        );
            }

            ChainUpdateRevocationInfo(&RevStatus,
                &m_pDownIssuerElement->RevocationInfo,
                &m_pDownIssuerElement->SubjectStatus);
            m_pDownIssuerElement->fHasRevocationInfo = TRUE;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::CreateChainContextFromPath, public
//
//  Synopsis:   Create the chain context for chain path ending in the
//              specified top path object. Also calculates the chain's
//              quality value.
//
//----------------------------------------------------------------------------
PINTERNAL_CERT_CHAIN_CONTEXT
CChainPathObject::CreateChainContextFromPath (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCHAINPATHOBJECT pTopPathObject
    )
{
    // Single PkiZeroAlloc for all of the following:
    PINTERNAL_CERT_CHAIN_CONTEXT pContext = NULL;
    PCERT_SIMPLE_CHAIN *ppChain;
    PCERT_SIMPLE_CHAIN pChain;
    PCERT_CHAIN_ELEMENT *ppElement;
    PCERT_CHAIN_ELEMENT pElement;
    DWORD cChain;
    DWORD cTotalElement;
    DWORD cbTotal;
    PCCHAINPATHOBJECT pPathObject;
    DWORD dwQuality;
    DWORD dwChainErrorStatus;
    DWORD dwChainInfoStatus;
    PCERT_ENHKEY_USAGE pAppUsage;

    BOOL fHasContextRevocationFreshnessTime;

    // Restricted usage info that gets propogated downward
    CHAIN_RESTRICTED_USAGE_INFO RestrictedUsageInfo;

    memset(&RestrictedUsageInfo, 0, sizeof(RestrictedUsageInfo));

    cChain = pTopPathObject->m_dwChainIndex + 1;

    if (1 == cChain) {
        cTotalElement = pTopPathObject->m_dwElementIndex + 1;
    } else {
        cTotalElement = 0;
        for (pPathObject = pTopPathObject; NULL != pPathObject;
                                pPathObject = pPathObject->m_pDownPathObject)
            cTotalElement++;
    }

    cbTotal = sizeof(INTERNAL_CERT_CHAIN_CONTEXT) +
        sizeof(PCERT_SIMPLE_CHAIN) * cChain +
        sizeof(CERT_SIMPLE_CHAIN) * cChain +
        sizeof(PCERT_CHAIN_ELEMENT) * cTotalElement +
        sizeof(CERT_CHAIN_ELEMENT) * cTotalElement;
    

    pContext = (PINTERNAL_CERT_CHAIN_CONTEXT) PkiZeroAlloc(cbTotal);
    if (NULL == pContext)
        goto OutOfMemory;
    ppChain = (PCERT_SIMPLE_CHAIN *) &pContext[1];
    pChain = (PCERT_SIMPLE_CHAIN) &ppChain[cChain];
    ppElement = (PCERT_CHAIN_ELEMENT *) &pChain[cChain];
    pElement = (PCERT_CHAIN_ELEMENT) &ppElement[cTotalElement];

    pContext->cRefs = 1;
    pContext->ChainContext.cbSize = sizeof(CERT_CHAIN_CONTEXT);
    pContext->ChainContext.cChain = cChain;
    pContext->ChainContext.rgpChain = ppChain;

    if (1 < cChain )
        pContext->ChainContext.TrustStatus.dwInfoStatus |=
            CERT_TRUST_IS_COMPLEX_CHAIN;

    // Default to having preferred issuers
    pContext->ChainContext.TrustStatus.dwInfoStatus |=
        CERT_TRUST_HAS_PREFERRED_ISSUER;

    // Default to having revocation freshness time
    fHasContextRevocationFreshnessTime = TRUE;

    // Work our way from the top downward
    pPathObject = pTopPathObject;
    ppChain += cChain - 1;
    pChain += cChain - 1;
    ppElement += cTotalElement - 1;
    pElement += cTotalElement - 1;

    if (!(pTopPathObject->m_TrustStatus.dwInfoStatus &
            CERT_TRUST_IS_SELF_SIGNED))
        pChain->TrustStatus.dwErrorStatus |= CERT_TRUST_IS_PARTIAL_CHAIN;

    for ( ; 0 < cChain; cChain--, ppChain--, pChain--) {
        BOOL fHasChainRevocationFreshnessTime;
        DWORD cElement;

        *ppChain = pChain;
        pChain->cbSize = sizeof(CERT_SIMPLE_CHAIN);

        // Default to having preferred issuers
        pChain->TrustStatus.dwInfoStatus |= CERT_TRUST_HAS_PREFERRED_ISSUER;

        // Default to having revocation freshness time
        fHasChainRevocationFreshnessTime = TRUE;


        cElement = pPathObject->m_dwElementIndex + 1;
        pChain->cElement = cElement;
        pChain->rgpElement = ppElement - (cElement - 1);
        for ( ; 0 < cElement; cElement--, cTotalElement--,
                              ppElement--, pElement--,
                              pPathObject = pPathObject->m_pDownPathObject) {
            assert(pPathObject);
            *ppElement = pElement;
            pElement->cbSize = sizeof(CERT_CHAIN_ELEMENT);

            if (!pPathObject->UpdateChainContextUsageForPathObject (
                    pCallContext,
                    pChain,
                    pElement,
                    &RestrictedUsageInfo
                    ))
                goto UpdateChainContextUsageForPathObjectError;


            // This must be last. It updates the chain's TrustStatus
            // from the element's TrustStatus.
            if (!pPathObject->UpdateChainContextFromPathObject (
                    pCallContext,
                    pChain,
                    pElement
                    ))
                goto UpdateChainContextFromPathObjectError;

            // Remember the largest revocation freshness time for the
            // simple chain and the chain context.
            if (pElement->pRevocationInfo && fHasChainRevocationFreshnessTime) {
                PCERT_REVOCATION_INFO pRevInfo = pElement->pRevocationInfo;

                if (pRevInfo->fHasFreshnessTime) {
                    if (pRevInfo->dwFreshnessTime >
                            pChain->dwRevocationFreshnessTime)
                        pChain->dwRevocationFreshnessTime =
                            pRevInfo->dwFreshnessTime;
                    pChain->fHasRevocationFreshnessTime = TRUE;

                    if (fHasContextRevocationFreshnessTime) {
                        if (pRevInfo->dwFreshnessTime >
                                pContext->ChainContext.dwRevocationFreshnessTime)
                            pContext->ChainContext.dwRevocationFreshnessTime =
                                pRevInfo->dwFreshnessTime;
                        pContext->ChainContext.fHasRevocationFreshnessTime =
                            TRUE;
                    }
                } else if (CRYPT_E_NO_REVOCATION_CHECK !=
                        pRevInfo->dwRevocationResult) {
                    fHasChainRevocationFreshnessTime = FALSE;
                    pChain->fHasRevocationFreshnessTime = FALSE;

                    fHasContextRevocationFreshnessTime = FALSE;
                    pContext->ChainContext.fHasRevocationFreshnessTime = FALSE;
                }
                
            }

            CertPerfIncrementChainElementCount();

        }

        ChainUpdateSummaryStatusByTrustStatus(
            &pContext->ChainContext.TrustStatus,
            &pChain->TrustStatus);

        ChainFreeAndClearRestrictedUsageInfo(&RestrictedUsageInfo);
    }

    assert(0 == cTotalElement);

    // Calculate chain quality value
    dwQuality = 0;
    dwChainErrorStatus = pContext->ChainContext.TrustStatus.dwErrorStatus;
    dwChainInfoStatus = pContext->ChainContext.TrustStatus.dwInfoStatus;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_NOT_TIME_VALID) &&
         !(dwChainErrorStatus & CERT_TRUST_CTL_IS_NOT_TIME_VALID))
        dwQuality |= CERT_QUALITY_TIME_VALID;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE) &&
         !(dwChainErrorStatus & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE))
        dwQuality |= CERT_QUALITY_MEETS_USAGE_CRITERIA;

    pAppUsage =
        pContext->ChainContext.rgpChain[0]->rgpElement[0]->pApplicationUsage;
    if (NULL == pAppUsage || 0 != pAppUsage->cUsageIdentifier)
        dwQuality |= CERT_QUALITY_HAS_APPLICATION_USAGE;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_UNTRUSTED_ROOT))
        dwQuality |= CERT_QUALITY_HAS_TRUSTED_ROOT;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID) &&
         !(dwChainErrorStatus & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID))
        dwQuality |= CERT_QUALITY_SIGNATURE_VALID;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_PARTIAL_CHAIN))
        dwQuality |= CERT_QUALITY_COMPLETE_CHAIN;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_REVOKED))
        dwQuality |= CERT_QUALITY_NOT_REVOKED;

    if (!(dwChainErrorStatus & CERT_TRUST_IS_OFFLINE_REVOCATION) &&
            !(dwChainErrorStatus & CERT_TRUST_IS_REVOKED))
        dwQuality |= CERT_QUALITY_ONLINE_REVOCATION;

    if (!(dwChainErrorStatus & CERT_TRUST_REVOCATION_STATUS_UNKNOWN) &&
            !(dwChainErrorStatus & CERT_TRUST_IS_REVOKED))
        dwQuality |= CERT_QUALITY_CHECK_REVOCATION;

    if (!(dwChainInfoStatus & CERT_TRUST_IS_COMPLEX_CHAIN))
        dwQuality |= CERT_QUALITY_SIMPLE_CHAIN;

    if (dwChainInfoStatus & CERT_TRUST_HAS_PREFERRED_ISSUER)
        dwQuality |= CERT_QUALITY_PREFERRED_ISSUER;

    if (dwChainInfoStatus & CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY)
        dwQuality |= CERT_QUALITY_HAS_ISSUANCE_CHAIN_POLICY;
    if (!(dwChainErrorStatus &
            (CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY |
                CERT_TRUST_INVALID_POLICY_CONSTRAINTS)))
        dwQuality |= CERT_QUALITY_POLICY_CONSTRAINTS_VALID;
    if (!(dwChainErrorStatus & CERT_TRUST_INVALID_BASIC_CONSTRAINTS))
        dwQuality |= CERT_QUALITY_BASIC_CONSTRAINTS_VALID;

    if (dwChainInfoStatus & CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS)
        dwQuality |= CERT_QUALITY_HAS_NAME_CONSTRAINTS;
    if (!(dwChainErrorStatus & (CERT_TRUST_INVALID_NAME_CONSTRAINTS |
            CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT |
            CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT)))
        dwQuality |= CERT_QUALITY_NAME_CONSTRAINTS_VALID;
    if (!(dwChainErrorStatus & (CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT |
            CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT)))
        dwQuality |= CERT_QUALITY_NAME_CONSTRAINTS_MET;


    pContext->dwQuality = dwQuality;

    CertPerfIncrementChainCount();

CommonReturn:
    return pContext;

ErrorReturn:
    if (pContext) {
        ChainReleaseInternalChainContext(pContext);
        pContext = NULL;
    }

    ChainFreeAndClearRestrictedUsageInfo(&RestrictedUsageInfo);
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(UpdateChainContextUsageForPathObjectError)
TRACE_ERROR(UpdateChainContextFromPathObjectError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::UpdateChainContextUsageForPathObject, public
//
//  Synopsis:   update the chain context usage information for this
//              path object.
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::UpdateChainContextUsageForPathObject (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PCERT_SIMPLE_CHAIN pChain,
    IN OUT PCERT_CHAIN_ELEMENT pElement,
    IN OUT PCHAIN_RESTRICTED_USAGE_INFO pRestrictedUsageInfo
    )
{
    BOOL fResult;
    PCHAIN_POLICIES_INFO pPoliciesInfo = m_pCertObject->PoliciesInfo();
    CERT_USAGE_MATCH CtlUsage;
    PCERT_USAGE_MATCH pUsageToUse;
    LPSTR pszUsage = szOID_KP_CTL_USAGE_SIGNING;
    PCERT_ENHKEY_USAGE pIssUsage;
    PCERT_ENHKEY_USAGE pAppUsage;
    PCERT_ENHKEY_USAGE pPropUsage;
    DWORD dwIssFlags;
    DWORD dwAppFlags;

    static const CERT_ENHKEY_USAGE NoUsage = { 0, NULL };

    // Update the usage to use for the second and subsequent chains
    if (0 != m_dwChainIndex) {
        // CTL path object
        memset(&CtlUsage, 0, sizeof(CtlUsage));


        CtlUsage.dwType = USAGE_MATCH_TYPE_AND;
        CtlUsage.Usage.cUsageIdentifier = 1;
        CtlUsage.Usage.rgpszUsageIdentifier = &pszUsage;

        pUsageToUse = &CtlUsage;
    } else {
        pUsageToUse = &pCallContext->ChainPara()->RequestedUsage;
    }

    dwIssFlags = pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].dwFlags;
    dwAppFlags = pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].dwFlags;

    // Update TrustStatus to reflect any policy decoding errors
    if ((dwIssFlags & CHAIN_INVALID_POLICY_FLAG) ||
            (dwAppFlags & CHAIN_INVALID_POLICY_FLAG))
        pElement->TrustStatus.dwErrorStatus |= CERT_TRUST_INVALID_EXTENSION |
            CERT_TRUST_INVALID_POLICY_CONSTRAINTS;

    // Issuance :: restricted and mapped usage

    pIssUsage = pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pUsage;
    if (NULL == pIssUsage) {
        // NULL => Any Usage

        // Only allow any usage for self signed roots or certs having
        // the CertPolicies extension. Otherwise, treat as having no usage.
        if (!(m_TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED) &&
                NULL == pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pPolicy)
            pIssUsage = (PCERT_ENHKEY_USAGE) &NoUsage;
    }

    if (!ChainCalculateRestrictedUsage (
            pIssUsage,
            pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pMappings,
            &pRestrictedUsageInfo->pIssuanceRestrictedUsage,
            &pRestrictedUsageInfo->pIssuanceMappedUsage,
            &pRestrictedUsageInfo->rgdwIssuanceMappedIndex
            ))
        goto CalculateIssuanceRestrictedUsageError;

    if (!ChainAllocAndCopyUsage(
            pRestrictedUsageInfo->pIssuanceRestrictedUsage,
            &pElement->pIssuanceUsage
            ))
        goto AllocAndCopyUsageError;

    if (0 != m_dwElementIndex) {
        PCERT_POLICY_CONSTRAINTS_INFO pConstraints =
            pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pConstraints;

        if (pConstraints && pConstraints->fRequireExplicitPolicy &&
                m_dwElementIndex >
                    pConstraints->dwRequireExplicitPolicySkipCerts &&
                !pRestrictedUsageInfo->fRequireIssuancePolicy) {
            DWORD dwElementIndex;
            PCCHAINPATHOBJECT pIssuer;
            PCCHAINPATHOBJECT pSubject;

            // Remove any key rollover entries
            for (pIssuer = this,
                 pSubject = m_pDownPathObject,
                 dwElementIndex = m_dwElementIndex;
                        NULL != pSubject &&
                            pSubject->m_dwChainIndex == m_dwChainIndex;
                                    pIssuer = pSubject,
                                    pSubject = pSubject->m_pDownPathObject) {
                if (ChainIsKeyRolloverSubject(pIssuer, pSubject))
                    dwElementIndex--;
            }
            if (dwElementIndex >
                    pConstraints->dwRequireExplicitPolicySkipCerts)
                pRestrictedUsageInfo->fRequireIssuancePolicy = TRUE;
        }
        
    } else {
        // For the end cert, update the require issuance chain policy
        // TrustStatus.  Also, check the requested issuance policy.

        if (pRestrictedUsageInfo->fRequireIssuancePolicy) {
            if (pRestrictedUsageInfo->pIssuanceRestrictedUsage &&
                    0 == pRestrictedUsageInfo->pIssuanceRestrictedUsage->cUsageIdentifier) {
                // Must have either ANY_POLICY or some policy OIDs
                pChain->TrustStatus.dwErrorStatus |=
                    CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY;
            } else if (pPoliciesInfo->rgIssOrAppInfo[CHAIN_ISS_INDEX].pPolicy) {
                pChain->TrustStatus.dwInfoStatus |=
                    CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY;
            }
        }

        pIssUsage = pElement->pIssuanceUsage;
        if (pIssUsage) {
            PCERT_USAGE_MATCH pRequestedIssuancePolicy =
                &pCallContext->ChainPara()->RequestedIssuancePolicy;

            ChainGetUsageStatus(
                &pRequestedIssuancePolicy->Usage,
                pIssUsage,
                pRequestedIssuancePolicy->dwType,
                &pElement->TrustStatus
                );
        }
    }


    if (USAGE_MATCH_TYPE_OR == pUsageToUse->dwType &&
            1 < pUsageToUse->Usage.cUsageIdentifier) {
        // For "OR" match type request, we can't use restricted property usage
        pPropUsage = pPoliciesInfo->pPropertyUsage;

        // For "OR" match type request, we only use restricted application
        // usage upon seeing policy mappings.
        if (pRestrictedUsageInfo->pApplicationMappedUsage ||
                pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pMappings) {
            if (!ChainCalculateRestrictedUsage (
                    pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pUsage,
                    pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pMappings,
                    &pRestrictedUsageInfo->pApplicationRestrictedUsage,
                    &pRestrictedUsageInfo->pApplicationMappedUsage,
                    &pRestrictedUsageInfo->rgdwApplicationMappedIndex
                    ))
                goto CalculateApplicationRestrictedUsageError;
            pAppUsage = pRestrictedUsageInfo->pApplicationRestrictedUsage;
        } else
            pAppUsage = pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pUsage;
    } else {
        // Restricted property and application usage

        PCERT_ENHKEY_USAGE pPropMappedUsage = NULL;
        LPDWORD pdwPropMappedIndex = NULL;

        fResult = ChainCalculateRestrictedUsage (
            pPoliciesInfo->pPropertyUsage,
            NULL,                               // pMappings
            &pRestrictedUsageInfo->pPropertyRestrictedUsage,
            &pPropMappedUsage,
            &pdwPropMappedIndex
            );
        assert(NULL == pPropMappedUsage && NULL == pdwPropMappedIndex);
        if (!fResult)
            goto CalculatePropertyRestrictedUsageError;
        pPropUsage = pRestrictedUsageInfo->pPropertyRestrictedUsage;

        if (!ChainCalculateRestrictedUsage (
                pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pUsage,
                pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].pMappings,
                &pRestrictedUsageInfo->pApplicationRestrictedUsage,
                &pRestrictedUsageInfo->pApplicationMappedUsage,
                &pRestrictedUsageInfo->rgdwApplicationMappedIndex
                ))
            goto CalculateApplicationRestrictedUsageError;
        pAppUsage = pRestrictedUsageInfo->pApplicationRestrictedUsage;
    }


    // The element's application usage includes the intersection with
    // the property usage
    if (NULL == pAppUsage) {
        if (!ChainAllocAndCopyUsage(
                pPropUsage,
                &pElement->pApplicationUsage
                ))
            goto AllocAndCopyUsageError;
    } else {
        if (!ChainAllocAndCopyUsage(
                pAppUsage,
                &pElement->pApplicationUsage
                ))
            goto AllocAndCopyUsageError;
        if (pPropUsage)
            // Remove OIDs not also in the property usage
            ChainIntersectUsages(pPropUsage, pElement->pApplicationUsage);
    }

    // Check the requested usage
    pAppUsage = pElement->pApplicationUsage;
    if (pAppUsage)
        ChainGetUsageStatus(
            &pUsageToUse->Usage,
            pAppUsage,
            pUsageToUse->dwType,
            &pElement->TrustStatus
            );

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CalculateIssuanceRestrictedUsageError)
TRACE_ERROR(AllocAndCopyUsageError)
TRACE_ERROR(CalculateApplicationRestrictedUsageError)
TRACE_ERROR(CalculatePropertyRestrictedUsageError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::UpdateChainContextFromPathObject, public
//
//  Synopsis:   update the chain context using information from this
//              path object.
//
//----------------------------------------------------------------------------
BOOL
CChainPathObject::UpdateChainContextFromPathObject (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PCERT_SIMPLE_CHAIN pChain,
    IN OUT PCERT_CHAIN_ELEMENT pElement
    )
{
    BOOL fResult;
    PCERT_REVOCATION_INFO pRevocationInfo = NULL;
    PCERT_REVOCATION_CRL_INFO pRevocationCrlInfo = NULL;
    CERT_REVOCATION_INFO DisallowedRevocationInfo;

    ChainOrInStatusBits(&pElement->TrustStatus, &m_TrustStatus);
    assert(m_fHasAdditionalStatus);
    ChainOrInStatusBits(&pElement->TrustStatus, &m_AdditionalStatus);

    if ((pElement->TrustStatus.dwErrorStatus &
            CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT)
                            &&
        (pChain->TrustStatus.dwInfoStatus &
            CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS)) {
        // If one of our parents has a valid name constraint, then,
        // it isn't mandatory that we have a constraint for all name spaces.
        pElement->TrustStatus.dwErrorStatus &=
            ~CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT;
    }

    if (m_pUpIssuerElement) {
        if (m_pUpIssuerElement->fCtlIssuer) {
            ChainOrInStatusBits(&pChain->TrustStatus,
                &m_pUpIssuerElement->SubjectStatus);

            assert(pElement->TrustStatus.dwErrorStatus &
                CERT_TRUST_IS_UNTRUSTED_ROOT);

            pElement->TrustStatus.dwErrorStatus &=
                ~CERT_TRUST_IS_UNTRUSTED_ROOT;

            if (!SSCtlAllocAndCopyTrustListInfo(
                    m_pUpIssuerElement->pCtlIssuerData->pTrustListInfo,
                    &pChain->pTrustListInfo
                    ))
                goto AllocAndCopyTrustListInfoError;
        } else {
            ChainOrInStatusBits(&pElement->TrustStatus,
                &m_pUpIssuerElement->SubjectStatus);
        }
    }

    pRevocationInfo = NULL;
    if (m_fHasRevocationInfo) {
        pRevocationInfo = &m_RevocationInfo;
        pRevocationCrlInfo = &m_RevocationCrlInfo;
    } else if (m_pUpIssuerElement && m_pUpIssuerElement->fHasRevocationInfo) {
        pRevocationInfo = &m_pUpIssuerElement->RevocationInfo;
        pRevocationCrlInfo = &m_pUpIssuerElement->RevocationCrlInfo;
    }

    if (0 == m_dwElementIndex && 0 == m_dwChainIndex &&
            !(pElement->TrustStatus.dwErrorStatus & CERT_TRUST_IS_REVOKED) &&
            NULL != m_pCertObject->ChainEngine()->DisallowedStore()) {
        // Check if the end certificate has been explicitly disallowed.
        // Since the signature component can be altered, must use the signature
        // hash

        BYTE rgbSigHash[CHAIN_MAX_SIG_HASH_LEN];
        CRYPT_DATA_BLOB SigHashBlob;
        SigHashBlob.pbData = rgbSigHash;
        SigHashBlob.cbData = CHAIN_MAX_SIG_HASH_LEN;

        if (CertGetCertificateContextProperty(
                m_pCertObject->CertContext(),
                CERT_SIGNATURE_HASH_PROP_ID,
                rgbSigHash,
                &SigHashBlob.cbData
                ) && CHAIN_MIN_SIG_HASH_LEN <= SigHashBlob.cbData) {
            PCCERT_CONTEXT pDisallowedCert;

            pDisallowedCert = CertFindCertificateInStore(
                m_pCertObject->ChainEngine()->DisallowedStore(),
                0,                  // dwCertEncodingType
                0,                  // dwFindFlags
                CERT_FIND_SIGNATURE_HASH,
                (const void *) &SigHashBlob,
                NULL                //pPrevCertContext
                );

            if (pDisallowedCert) {
                CertFreeCertificateContext(pDisallowedCert);

                memset(&DisallowedRevocationInfo, 0,
                    sizeof(DisallowedRevocationInfo));
                DisallowedRevocationInfo.cbSize =
                    sizeof(DisallowedRevocationInfo);
                DisallowedRevocationInfo.dwRevocationResult =
                    (DWORD) CRYPT_E_REVOKED;
                DisallowedRevocationInfo.fHasFreshnessTime = TRUE;
                // DisallowedRevocationInfo.dwFreshnessTime = 0;

                pRevocationInfo = &DisallowedRevocationInfo;
                pRevocationCrlInfo = NULL;

                pElement->TrustStatus.dwErrorStatus |= CERT_TRUST_IS_REVOKED;
                pElement->TrustStatus.dwErrorStatus &=
                    ~(CERT_TRUST_REVOCATION_STATUS_UNKNOWN |
                        CERT_TRUST_IS_OFFLINE_REVOCATION);
                
            }
        }
    }


    if (pRevocationInfo) {
        pElement->pRevocationInfo = new CERT_REVOCATION_INFO;
        if (NULL == pElement->pRevocationInfo)
            goto OutOfMemory;

        memset(pElement->pRevocationInfo, 0, sizeof(CERT_REVOCATION_INFO));
        pElement->pRevocationInfo->cbSize = sizeof(CERT_REVOCATION_INFO);
        pElement->pRevocationInfo->dwRevocationResult = 
            pRevocationInfo->dwRevocationResult;
        pElement->pRevocationInfo->fHasFreshnessTime = 
            pRevocationInfo->fHasFreshnessTime;
        pElement->pRevocationInfo->dwFreshnessTime = 
            pRevocationInfo->dwFreshnessTime;

        if (NULL != pRevocationCrlInfo &&
                NULL != pRevocationCrlInfo->pBaseCrlContext) {
            PCERT_REVOCATION_CRL_INFO pCrlInfo;

            pCrlInfo = new CERT_REVOCATION_CRL_INFO;
            if (NULL == pCrlInfo)
                goto OutOfMemory;

            pElement->pRevocationInfo->pCrlInfo = pCrlInfo;
            memcpy(pCrlInfo, pRevocationCrlInfo, sizeof(*pCrlInfo));
            assert(pCrlInfo->cbSize = sizeof(*pCrlInfo));

            pCrlInfo->pBaseCrlContext = CertDuplicateCRLContext(
                pRevocationCrlInfo->pBaseCrlContext);
            if (NULL != pRevocationCrlInfo->pDeltaCrlContext)
                pCrlInfo->pDeltaCrlContext = CertDuplicateCRLContext(
                    pRevocationCrlInfo->pDeltaCrlContext);
        }
    }

    if (m_pwszExtendedErrorInfo) {
        DWORD cbExtendedErrorInfo;
        LPWSTR pwszExtendedErrorInfo;

        cbExtendedErrorInfo =
            (wcslen(m_pwszExtendedErrorInfo) + 1) * sizeof(WCHAR);
        if (NULL == (pwszExtendedErrorInfo = (LPWSTR) PkiNonzeroAlloc(
                cbExtendedErrorInfo)))
            goto OutOfMemory;
        memcpy(pwszExtendedErrorInfo, m_pwszExtendedErrorInfo,
            cbExtendedErrorInfo);
        pElement->pwszExtendedErrorInfo = pwszExtendedErrorInfo;
    }

    pElement->pCertContext = CertDuplicateCertificateContext(
        m_pCertObject->CertContext());

    ChainUpdateSummaryStatusByTrustStatus(&pChain->TrustStatus,
        &pElement->TrustStatus);

    fResult = TRUE;
CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AllocAndCopyTrustListInfoError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


//+===========================================================================
//  CCertIssuerList methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CCertIssuerList, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertIssuerList::CCertIssuerList (IN PCCHAINPATHOBJECT pSubject)
{
    m_pSubject = pSubject;
    m_pHead = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::~CCertIssuerList, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertIssuerList::~CCertIssuerList ()
{
    PCERT_ISSUER_ELEMENT pElement;

    while ( ( pElement = NextElement( NULL ) ) != NULL  )
    {
        RemoveElement( pElement );
        DeleteElement( pElement );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddIssuer, public
//
//  Synopsis:   add an issuer to the list
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::AddIssuer(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCCERTOBJECT pIssuer
    )
{
    BOOL fResult;
    PCCHAINPATHOBJECT pIssuerPathObject = NULL;
    PCERT_ISSUER_ELEMENT pElement = NULL;

    if (CheckForDuplicateElement(pIssuer->CertHash(), FALSE))
        return TRUE;

    // Don't add ourself as an issuer.
    if (0 == memcmp(m_pSubject->CertObject()->CertHash(),
            pIssuer->CertHash(), CHAINHASHLEN))
        return TRUE;

    // Mainly for certs generated by tstore2.exe that mostly contain
    // the same public key, need to add an additional filter to
    // discard certs that only match via the public key, ie no
    // AKI, name or basic constraints match.
    if (!ChainIsValidPubKeyMatchForIssuer(pIssuer, m_pSubject->CertObject()))
        return TRUE;

    if (!ChainCreatePathObject(
            pCallContext,
            pIssuer,
            hAdditionalStore,
            &pIssuerPathObject
            ))
        return FALSE;

    fResult = CreateElement(
               pCallContext,
               FALSE,               // fCtlIssuer
               pIssuerPathObject,
               hAdditionalStore,
               NULL,                // pSSCtlObject
               NULL,                // pTrustListInfo
               &pElement
               );

    if (!fResult)
    {
        return( FALSE );
    }

    AddElement( pElement );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::AddCtlIssuer, public
//
//  Synopsis:   add an issuer to the list
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::AddCtlIssuer(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN PCSSCTLOBJECT pSSCtlObject,
    IN PCERT_TRUST_LIST_INFO pTrustListInfo
    )
{
    PCERT_ISSUER_ELEMENT pElement = NULL;

    if (CheckForDuplicateElement(pSSCtlObject->CtlHash(), TRUE))
        return TRUE;

    if (!CreateElement(
               pCallContext,
               TRUE,                // fCtlIssuer
               NULL,                // pIssuerPathObject
               hAdditionalStore,
               pSSCtlObject,
               pTrustListInfo,
               &pElement
               ))
        return FALSE;


    AddElement( pElement );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CreateElement, public
//
//  Synopsis:   create an element
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::CreateElement(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN BOOL fCtlIssuer,
    IN OPTIONAL PCCHAINPATHOBJECT pIssuer,
    IN OPTIONAL HCERTSTORE hAdditionalStore,
    IN OPTIONAL PCSSCTLOBJECT pSSCtlObject,
    IN OPTIONAL PCERT_TRUST_LIST_INFO pTrustListInfo,   // allocated by caller
    OUT PCERT_ISSUER_ELEMENT* ppElement
    )
{
    BOOL fResult;
    BOOL fCtlSignatureValid = FALSE;
    PCERT_ISSUER_ELEMENT pElement;

    pElement = new CERT_ISSUER_ELEMENT;
    if (NULL == pElement)
        goto OutOfMemory;

    memset( pElement, 0, sizeof( CERT_ISSUER_ELEMENT ) );

    pElement->fCtlIssuer = fCtlIssuer;

    if (!fCtlIssuer) {
        pElement->pIssuer = pIssuer;

        // The following may leave the engine's critical section to verify the
        // signature. If the engine was touched by another thread, it fails with
        // LastError set to ERROR_CAN_NOT_COMPLETE.
        if (!ChainGetSubjectStatus(
                 pCallContext,
                 pIssuer,
                 m_pSubject,
                 &pElement->SubjectStatus
                 ))
            goto GetSubjectStatusError;
    } else {
        pElement->pCtlIssuerData = new CTL_ISSUER_DATA;
        if (NULL == pElement->pCtlIssuerData)
            goto OutOfMemory;

        memset( pElement->pCtlIssuerData, 0, sizeof( CTL_ISSUER_DATA ) );

        pSSCtlObject->AddRef();
        pElement->pCtlIssuerData->pSSCtlObject = pSSCtlObject;
        pElement->pCtlIssuerData->pTrustListInfo = pTrustListInfo;

        // The following may leave the engine's critical section to verify a
        // signature or do URL retrieval. If the engine was touched by
        // another thread, it fails with LastError set to
        // ERROR_CAN_NOT_COMPLETE.
        if (!pSSCtlObject->GetSigner(
                m_pSubject,
                pCallContext,
                hAdditionalStore,
                &pElement->pIssuer,
                &fCtlSignatureValid
                )) {
            if (GetLastError() != CRYPT_E_NOT_FOUND)
                goto GetSignerError;
        }
    }

    if (pElement->pIssuer) {
        // If the Issuer hasn't completed yet, then, we are cyclic.
        if (!pElement->pIssuer->IsCompleted())
            pElement->dwPass1Quality = 0;
        else {
            pElement->dwPass1Quality = pElement->pIssuer->Pass1Quality();

            if (!fCtlIssuer) {
                if (pElement->SubjectStatus.dwErrorStatus &
                        CERT_TRUST_IS_NOT_SIGNATURE_VALID) {
                    pElement->dwPass1Quality &= ~CERT_QUALITY_SIGNATURE_VALID;
                }
            } else if (!fCtlSignatureValid) {
                pElement->dwPass1Quality &= ~CERT_QUALITY_SIGNATURE_VALID;
            }

            if (0 == (pElement->dwPass1Quality &
                    CERT_QUALITY_NO_DUPLICATE_KEY)) {
                // Add to the duplicate key depth
                pElement->dwPass1DuplicateKeyDepth =
                    pElement->pIssuer->Pass1DuplicateKeyDepth() + 1;
            } else {
                // Check that we have a no duplicate key path to the top

                PCCHAINPATHOBJECT pTopPathObject = NULL;
                LPBYTE pbPathPublicKeyHash =
                    m_pSubject->CertObject()->PublicKeyHash();

                while (pTopPathObject = pElement->pIssuer->NextPath(
                        pCallContext,
                        pTopPathObject
                        )) {
                    BOOL fDuplicateKey = FALSE;

                    PCERT_ISSUER_ELEMENT pIssuerElement;
                    PCCHAINPATHOBJECT pIssuerObject;

                    for (pIssuerElement = pElement;
                        NULL != pIssuerElement &&
                            NULL != (pIssuerObject = pIssuerElement->pIssuer);
                                pIssuerElement =
                                    pIssuerObject->UpIssuerElement()) {

                        assert(0 != (pIssuerElement->dwPass1Quality &
                            CERT_QUALITY_NO_DUPLICATE_KEY));

                        if (0 == memcmp(pbPathPublicKeyHash,
                                pIssuerObject->CertObject()->PublicKeyHash(),
                                CHAINHASHLEN)) {
                            fDuplicateKey = TRUE;
                            break;
                        }
                    }

                    if (!fDuplicateKey)
                        break;
                }
                
                if (pTopPathObject)
                    pElement->pIssuer->ResetNextPath(
                        pCallContext,
                        pTopPathObject
                        );
                else {
                    pElement->dwPass1Quality &= ~CERT_QUALITY_NO_DUPLICATE_KEY;
                    // Start the duplicate key depth count
                    pElement->dwPass1DuplicateKeyDepth = 1;
                }
            }
        }
    } else {
        assert(fCtlIssuer);
        pElement->dwPass1Quality = 0;
    }

    // Remember highest quality issuer and lowest duplicate key depth
    if (pElement->dwPass1Quality > m_pSubject->Pass1Quality()) {
        m_pSubject->SetPass1Quality(pElement->dwPass1Quality);
        m_pSubject->SetPass1DuplicateKeyDepth(
            pElement->dwPass1DuplicateKeyDepth);
    } else if (pElement->dwPass1Quality == m_pSubject->Pass1Quality()) {
        if (IsEmpty() || pElement->dwPass1DuplicateKeyDepth <
                m_pSubject->Pass1DuplicateKeyDepth()) {
            m_pSubject->SetPass1DuplicateKeyDepth(
                pElement->dwPass1DuplicateKeyDepth);
        }
    }
   
    fResult = TRUE;

CommonReturn:
    *ppElement = pElement;
    return fResult;

ErrorReturn:
    if (pElement) {
        DeleteElement(pElement);
        pElement = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(GetSubjectStatusError)
TRACE_ERROR(GetSignerError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::DeleteElement, public
//
//  Synopsis:   delete an element
//
//----------------------------------------------------------------------------
VOID
CCertIssuerList::DeleteElement (IN PCERT_ISSUER_ELEMENT pElement)
{
    if ( pElement->pCtlIssuerData )
    {
        ChainFreeCtlIssuerData( pElement->pCtlIssuerData );
    }

    if (pElement->fHasRevocationInfo) {
        if (pElement->RevocationCrlInfo.pBaseCrlContext)
            CertFreeCRLContext(pElement->RevocationCrlInfo.pBaseCrlContext);
        if (pElement->RevocationCrlInfo.pDeltaCrlContext)
            CertFreeCRLContext(pElement->RevocationCrlInfo.pDeltaCrlContext);
    }

    delete pElement;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertIssuerList::CheckForDuplicateElement, public
//
//  Synopsis:   check for a duplicate element
//
//----------------------------------------------------------------------------
BOOL
CCertIssuerList::CheckForDuplicateElement (
                      IN BYTE rgbHash[ CHAINHASHLEN ],
                      IN BOOL fCtlIssuer
                      )
{
    PCERT_ISSUER_ELEMENT pElement = NULL;

    while ( ( pElement = NextElement( pElement ) ) != NULL )
    {
        if ( pElement->fCtlIssuer == fCtlIssuer )
        {
            if ( fCtlIssuer == FALSE )
            {
                if ( memcmp(
                        rgbHash,
                        pElement->pIssuer->CertObject()->CertHash(),
                        CHAINHASHLEN
                        ) == 0 )
                {
                    return( TRUE );
                }
            }
            else
            {
                if ( memcmp(
                        rgbHash,
                        pElement->pCtlIssuerData->pSSCtlObject->CtlHash(),
                        CHAINHASHLEN
                        ) == 0 )
                {
                    return( TRUE );
                }
            }
        }
    }

    return( FALSE );
}

//+===========================================================================
//  CCertObjectCache methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::CCertObjectCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertObjectCache::CCertObjectCache (
                       IN DWORD MaxIndexEntries,
                       OUT BOOL& rfResult
                       )
{
    LRU_CACHE_CONFIG Config;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.cBuckets = DEFAULT_CERT_OBJECT_CACHE_BUCKETS;

    m_hHashIndex = NULL;
    m_hIdentifierIndex = NULL;
    m_hKeyIdIndex = NULL;
    m_hSubjectNameIndex = NULL;
    m_hPublicKeyHashIndex = NULL;
    m_hEndHashIndex = NULL;

    Config.pfnHash = CertObjectCacheHashNameIdentifier;

    rfResult = I_CryptCreateLruCache( &Config, &m_hSubjectNameIndex );

    Config.pfnHash = CertObjectCacheHashMd5Identifier;

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hIdentifierIndex );
    }

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hKeyIdIndex );
    }

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hPublicKeyHashIndex );
    }

    Config.pfnOnRemoval = CertObjectCacheOnRemovalFromPrimaryIndex;

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hHashIndex );
    }

    Config.MaxEntries = MaxIndexEntries;
    Config.pfnOnRemoval = CertObjectCacheOnRemovalFromEndHashIndex;

    if ( rfResult == TRUE )
    {
        rfResult = I_CryptCreateLruCache( &Config, &m_hEndHashIndex );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::~CCertObjectCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertObjectCache::~CCertObjectCache ()
{
    I_CryptFreeLruCache(
           m_hHashIndex,
           0,
           NULL
           );

    I_CryptFreeLruCache(
           m_hSubjectNameIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hIdentifierIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hKeyIdIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hPublicKeyHashIndex,
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptFreeLruCache(
           m_hEndHashIndex,
           0,
           NULL
           );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::AddIssuerObject, public
//
//  Synopsis:   add an issuer object to the cache

//              Increments engine's touch count
//
//----------------------------------------------------------------------------
VOID
CCertObjectCache::AddIssuerObject (
                     IN PCCHAINCALLCONTEXT pCallContext,
                     IN PCCERTOBJECT pCertObject
                     )
{
    assert(CERT_CACHED_ISSUER_OBJECT_TYPE == pCertObject->ObjectType());
    pCertObject->AddRef();

    I_CryptInsertLruEntry( pCertObject->HashIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->IdentifierIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->SubjectNameIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->KeyIdIndexEntry(), pCallContext );
    I_CryptInsertLruEntry( pCertObject->PublicKeyHashIndexEntry(),
        pCallContext );

    pCallContext->TouchEngine();

    CertPerfIncrementChainCertCacheCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::AddEndObject, public
//
//  Synopsis:   add an end object to the cache
//
//----------------------------------------------------------------------------
VOID
CCertObjectCache::AddEndObject (
                     IN PCCHAINCALLCONTEXT pCallContext,
                     IN PCCERTOBJECT pCertObject
                     )
{
    PCCERTOBJECT pDuplicate;


    if (CERT_END_OBJECT_TYPE != pCertObject->ObjectType())
        return;

    pDuplicate = FindEndObjectByHash(pCertObject->CertHash());
    if (pDuplicate) {
        pDuplicate->Release();
        return;
    }

    if (pCertObject->CacheEndObject(pCallContext)) {
        pCertObject->AddRef();

        I_CryptInsertLruEntry( pCertObject->EndHashIndexEntry(), pCallContext );

        CertPerfIncrementChainCertCacheCount();

        CertPerfIncrementChainCacheEndCertCount();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindIssuerObject, public
//
//  Synopsis:   find object
//
//  Note, also called by FindEndObjectByHash
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindIssuerObject (
                      IN HLRUCACHE hIndex,
                      IN PCRYPT_DATA_BLOB pIdentifier
                      )
{
    HLRUENTRY    hFound;
    PCCERTOBJECT pFound = NULL;

    hFound = I_CryptFindLruEntry( hIndex, pIdentifier );
    if ( hFound != NULL )
    {
        pFound = (PCCERTOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindIssuerObjectByHash, public
//
//  Synopsis:   find object by hash
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindIssuerObjectByHash (
                      IN BYTE rgbCertHash[ CHAINHASHLEN ]
                      )
{
    CRYPT_DATA_BLOB   DataBlob;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = rgbCertHash;
    return( FindIssuerObject( m_hHashIndex, &DataBlob ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::FindEndObjectByHash, public
//
//  Synopsis:   find object by hash
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::FindEndObjectByHash (
                      IN BYTE rgbCertHash[ CHAINHASHLEN ]
                      )
{
    CRYPT_DATA_BLOB   DataBlob;

    DataBlob.cbData = CHAINHASHLEN;
    DataBlob.pbData = rgbCertHash;
    return( FindIssuerObject( m_hEndHashIndex, &DataBlob ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertObjectCache::NextMatchingIssuerObject, public
//
//  Synopsis:   next matching issuer object
//
//----------------------------------------------------------------------------
PCCERTOBJECT
CCertObjectCache::NextMatchingIssuerObject (
                      IN HLRUENTRY hObjectEntry,
                      IN PCCERTOBJECT pCertObject
                      )
{
    HLRUENTRY    hFound;
    PCCERTOBJECT pFound = NULL;

    I_CryptAddRefLruEntry( hObjectEntry );

    hFound = I_CryptEnumMatchingLruEntries( hObjectEntry );
    if ( hFound != NULL )
    {
        pFound = (PCCERTOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    pCertObject->Release();

    return( pFound );
}

//+===========================================================================
//  CCertChainEngine methods
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CCertChainEngine, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCertChainEngine::CCertChainEngine (
                       IN PCERT_CHAIN_ENGINE_CONFIG pConfig,
                       IN BOOL fDefaultEngine,
                       OUT BOOL& rfResult
                       )
{
    HCERTSTORE hWorld = NULL;
    DWORD      dwStoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
    HKEY       hConfigKey = NULL;

    assert( pConfig->cbSize == sizeof( CERT_CHAIN_ENGINE_CONFIG ) );

    rfResult = TRUE;

    m_cRefs = 1;
    m_hRootStore = NULL;
    m_hRealRootStore = NULL;
    m_hTrustStore = NULL;
    m_hOtherStore = NULL;
    m_hCAStore = NULL;
    m_hDisallowedStore = NULL;
    m_hEngineStore = NULL;
    m_hEngineStoreChangeEvent = NULL;
    m_pCertObjectCache = NULL;
    m_pSSCtlObjectCache = NULL;
    m_dwFlags = pConfig->dwFlags;
    if (0 == pConfig->dwUrlRetrievalTimeout)
    {
        m_dwUrlRetrievalTimeout = DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT;
        m_fDefaultUrlRetrievalTimeout = TRUE;
    }
    else
    {
        m_dwUrlRetrievalTimeout = pConfig->dwUrlRetrievalTimeout;
        m_fDefaultUrlRetrievalTimeout = FALSE;
    }
    m_dwTouchEngineCount = 0;

    m_pCrossCertDPEntry = NULL;
    m_pCrossCertDPLink = NULL;
    m_hCrossCertStore = NULL;
    m_dwCrossCertDPResyncIndex = 0;
    m_pAuthRootAutoUpdateInfo = NULL;

    m_Config.fDisableMandatoryBasicConstraints = FALSE;

    m_Config.fDisableAIAUrlRetrieval = FALSE;
    m_Config.dwMaxAIAUrlCountInCert =
        CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT;
    m_Config.dwMaxAIAUrlRetrievalCountPerChain =
        CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT;
    m_Config.dwMaxAIAUrlRetrievalByteCount =
        CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT;
    m_Config.dwMaxAIAUrlRetrievalCertCount =
        CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT;

    if (ERROR_SUCCESS == RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_CHAIN_CONFIG_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hConfigKey
            )) {
        DWORD dwValue;

        ILS_ReadDWORDValueFromRegistry(
            hConfigKey,
            L"DisableMandatoryBasicConstraints",
            &dwValue
            );
        if (0 != dwValue)
            m_Config.fDisableMandatoryBasicConstraints = TRUE;

        ILS_ReadDWORDValueFromRegistry(
            hConfigKey,
            CERT_CHAIN_DISABLE_AIA_URL_RETRIEVAL_VALUE_NAME,
            &dwValue
            );
        if (0 != dwValue)
            m_Config.fDisableAIAUrlRetrieval = TRUE;

        ILS_ReadDWORDValueFromRegistry(
            hConfigKey,
            CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_VALUE_NAME,
            &dwValue
            );
        if (0 != dwValue)
            m_Config.dwMaxAIAUrlCountInCert = dwValue;

        ILS_ReadDWORDValueFromRegistry(
            hConfigKey,
            CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_VALUE_NAME,
            &dwValue
            );
        if (0 != dwValue)
            m_Config.dwMaxAIAUrlRetrievalCountPerChain = dwValue;

        ILS_ReadDWORDValueFromRegistry(
            hConfigKey,
            CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_VALUE_NAME,
            &dwValue
            );
        if (0 != dwValue)
            m_Config.dwMaxAIAUrlRetrievalByteCount = dwValue;

        ILS_ReadDWORDValueFromRegistry(
            hConfigKey,
            CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_VALUE_NAME,
            &dwValue
            );
        if (0 != dwValue)
            m_Config.dwMaxAIAUrlRetrievalCertCount = dwValue;

        ILS_CloseRegistryKey(hConfigKey);
    }


    if ( !Pki_InitializeCriticalSection( &m_Lock ))
    {
        m_fInitializedLock = FALSE;
        rfResult = FALSE;
        return;
    }
    else
    {
        m_fInitializedLock = TRUE;
    }

    if ( pConfig->dwFlags & CERT_CHAIN_USE_LOCAL_MACHINE_STORE )
    {
        dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
    }

    if ( pConfig->dwFlags & CERT_CHAIN_ENABLE_SHARE_STORE )
    {
        dwStoreFlags |= CERT_STORE_SHARE_STORE_FLAG;
    }

    dwStoreFlags |= CERT_STORE_SHARE_CONTEXT_FLAG;

    m_hRealRootStore = CertOpenStore(
                           CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           NULL,
                           dwStoreFlags |
                               CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                           L"root"
                           );

    if ( m_hRealRootStore == NULL )
    {
        rfResult = FALSE;
        return;
    }

    m_hCAStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags |
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                     L"ca"
                     );

    m_hDisallowedStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags |
                         CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                     L"disallowed"
                     );

    if ( m_hDisallowedStore != NULL )
    {
        CertControlStore(
            m_hDisallowedStore,
            0,                  // dwFlags
            CERT_STORE_CTRL_AUTO_RESYNC,
            NULL                // pvCtrlPara
            );
    }

    if ( pConfig->hRestrictedRoot != NULL )
    {
        if ( ChainIsProperRestrictedRoot(
                  m_hRealRootStore,
                  pConfig->hRestrictedRoot
                  ) == TRUE )
        {
            m_hRootStore = CertDuplicateStore( pConfig->hRestrictedRoot );

            // Having restricted roots implicitly disables the auto
            // updating of roots
            m_dwFlags |= CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE;
        }
    }
    else
    {
        m_hRootStore = CertDuplicateStore( m_hRealRootStore );
    }

    if ( m_hRootStore == NULL )
    {
        rfResult = FALSE;
        return;
    }

    if ( ( pConfig->hRestrictedTrust == NULL ) ||
         ( pConfig->hRestrictedOther == NULL ) )
    {
        rfResult = ChainCreateWorldStore(
                        m_hRootStore,
                        m_hCAStore,
                        pConfig->cAdditionalStore,
                        pConfig->rghAdditionalStore,
                        dwStoreFlags,
                        &hWorld
                        );

        if ( rfResult == FALSE )
        {
            return;
        }
    }

    if ( pConfig->hRestrictedTrust != NULL )
    {
        m_hTrustStore = CertDuplicateStore( pConfig->hRestrictedTrust );
    }
    else
    {
        m_hTrustStore = CertDuplicateStore( hWorld );
    }

    m_hOtherStore = CertOpenStore(
                        CERT_STORE_PROV_COLLECTION,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        NULL,
                        CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                        NULL
                        );

    if ( m_hOtherStore != NULL )
    {
        if ( pConfig->hRestrictedOther != NULL )
        {
            rfResult = CertAddStoreToCollection(
                           m_hOtherStore,
                           pConfig->hRestrictedOther,
                           0,
                           0
                           );

            if ( rfResult == TRUE )
            {
                rfResult = CertAddStoreToCollection(
                               m_hOtherStore,
                               m_hRootStore,
                               0,
                               0
                               );
            }
        }
        else
        {
            rfResult = CertAddStoreToCollection(
                           m_hOtherStore,
                           hWorld,
                           0,
                           0
                           );

            if ( ( rfResult == TRUE ) && ( pConfig->hRestrictedTrust != NULL ) )
            {
                rfResult = CertAddStoreToCollection(
                               m_hOtherStore,
                               pConfig->hRestrictedTrust,
                               0,
                               0
                               );
            }
        }
    }
    else
    {
        rfResult = FALSE;
    }

    if ( hWorld != NULL )
    {
        CertCloseStore( hWorld, 0 );
    }

    if ( rfResult == TRUE )
    {
        rfResult = ChainCreateEngineStore(
                        m_hRootStore,
                        m_hTrustStore,
                        m_hOtherStore,
                        fDefaultEngine,
                        pConfig->dwFlags,
                        &m_hEngineStore,
                        &m_hEngineStoreChangeEvent
                        );
    }

    if ( rfResult == TRUE )
    {
        rfResult = ChainCreateCertificateObjectCache(
                        pConfig->MaximumCachedCertificates,
                        &m_pCertObjectCache
                        );
    }

    if ( rfResult == TRUE )
    {
        rfResult = SSCtlCreateObjectCache( &m_pSSCtlObjectCache );
    }

    if ( rfResult == TRUE )
    {
        rfResult = m_pSSCtlObjectCache->PopulateCache( this );
    }

    assert( m_hRootStore != NULL );


    // Beginning of cross certificate stuff

    if ( rfResult == FALSE )
    {
        return;
    }

    m_hCrossCertStore = CertOpenStore(
        CERT_STORE_PROV_COLLECTION,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        NULL,
        CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
        NULL
        );

    if ( m_hCrossCertStore == NULL )
    {
        rfResult = FALSE;
        return;
    }

    rfResult = GetCrossCertDistPointsForStore(
         m_hEngineStore,
         TRUE,                      // fOnlyLMSystemStore
         &m_pCrossCertDPLink
         );
    if ( rfResult == FALSE )
    {
        return;
    }

    rfResult = CertAddStoreToCollection(
         m_hOtherStore,
         m_hCrossCertStore,
         0,
         0
         );

    // End of cross certificate stuff

    CertPerfIncrementChainEngineCurrentCount();
    CertPerfIncrementChainEngineTotalCount();
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::~CCertChainEngine, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CCertChainEngine::~CCertChainEngine ()
{
    CertPerfDecrementChainEngineCurrentCount();

    // Beginning of cross certificate stuff

    FreeCrossCertDistPoints(
        &m_pCrossCertDPLink
        );

    assert( NULL == m_pCrossCertDPLink );
    assert( NULL == m_pCrossCertDPEntry );

    if ( m_hCrossCertStore != NULL )
    {
        CertCloseStore( m_hCrossCertStore, 0 );
    }

    // End of cross certificate stuff

    FreeAuthRootAutoUpdateInfo(m_pAuthRootAutoUpdateInfo);


    ChainFreeCertificateObjectCache( m_pCertObjectCache );
    SSCtlFreeObjectCache( m_pSSCtlObjectCache );

    if ( m_hRootStore != NULL )
    {
        CertCloseStore( m_hRootStore, 0 );
    }

    if ( m_hRealRootStore != NULL )
    {
        CertCloseStore( m_hRealRootStore, 0 );
    }

    if ( m_hTrustStore != NULL )
    {
        CertCloseStore( m_hTrustStore, 0 );
    }

    if ( m_hOtherStore != NULL )
    {
        CertCloseStore( m_hOtherStore, 0 );
    }

    if ( m_hCAStore != NULL )
    {
        CertCloseStore( m_hCAStore, 0 );
    }

    if ( m_hDisallowedStore != NULL )
    {
        CertCloseStore( m_hDisallowedStore, 0 );
    }

    if ( m_hEngineStore != NULL )
    {
        if ( m_hEngineStoreChangeEvent != NULL )
        {
            CertControlStore(
                m_hEngineStore,
                0,                              // dwFlags
                CERT_STORE_CTRL_CANCEL_NOTIFY,
                &m_hEngineStoreChangeEvent
                );
        }

        CertCloseStore( m_hEngineStore, 0 );
    }

    if ( m_hEngineStoreChangeEvent != NULL )
    {
        CloseHandle( m_hEngineStoreChangeEvent );
    }

    if ( m_fInitializedLock )
    {
        DeleteCriticalSection( &m_Lock );
    }
}


// "CrossCA"
const BYTE rgbEncodedCrossCAUnicodeString[] = {
    0x1E, 0x0E,
        0x00, 0x43, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x73,
        0x00, 0x73, 0x00, 0x43, 0x00, 0x41
};

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetChainContext, public
//
//  Synopsis:   get a certificate chain context
//
//              NOTE: This method acquires the engine lock
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetChainContext (
                     IN PCCERT_CONTEXT pCertContext,
                     IN LPFILETIME pTime,
                     IN OPTIONAL HCERTSTORE hAdditionalStore,
                     IN OPTIONAL PCERT_CHAIN_PARA pChainPara,
                     IN DWORD dwFlags,
                     IN LPVOID pvReserved,
                     OUT PCCERT_CHAIN_CONTEXT* ppChainContext
                     )
{
    BOOL fResult;
    DWORD dwLastError = 0;
    PCCHAINCALLCONTEXT pCallContext = NULL;
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    PCERT_SIMPLE_CHAIN pChain;
    DWORD cEle;
    PCERT_CHAIN_ELEMENT *ppEle;

#define RETRY_AIA_ERROR_STATUS  \
            (CERT_TRUST_IS_REVOKED | \
                CERT_TRUST_IS_NOT_TIME_VALID | \
                CERT_TRUST_IS_UNTRUSTED_ROOT)

#define DISABLE_AIA_ADD_CERT_STATUS \
            (CERT_TRUST_IS_NOT_TIME_VALID | \
                CERT_TRUST_IS_REVOKED | \
                CERT_TRUST_IS_NOT_SIGNATURE_VALID | \
                CERT_TRUST_IS_UNTRUSTED_ROOT | \
                CERT_TRUST_IS_CYCLIC | \
                CERT_TRUST_IS_PARTIAL_CHAIN | \
                CERT_TRUST_CTL_IS_NOT_TIME_VALID | \
                CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID)

    if (!CallContextCreateCallObject(
            this,
            pTime,
            pChainPara,
            dwFlags,
            &pCallContext
            ))
        goto CallContextCreateCallObjectError;

    if (!CreateChainContextFromPathGraph(
            pCallContext,
            pCertContext,
            hAdditionalStore,
            &pChainContext
            ))
        goto CreateChainContextFromPathGraphError;

    if (0 == (pChainContext->TrustStatus.dwErrorStatus &
            RETRY_AIA_ERROR_STATUS))
        goto SuccessReturn;


    pChain = pChainContext->rgpChain[0];
    cEle = pChain->cElement;
    ppEle = pChain->rgpElement;

    // If the end certificate is time invalid, revoked or the untrusted root,
    // then, no need to retry via AIA retrieval.
    if (ppEle[0]->TrustStatus.dwErrorStatus & RETRY_AIA_ERROR_STATUS)
        goto SuccessReturn;

    if (!pCallContext->IsOnline())
        goto SuccessReturn;


    {
        HCERTSTORE hNewerIssuerUrlStore = NULL;

        if (CERT_TRUST_IS_UNTRUSTED_ROOT ==
                (pChainContext->TrustStatus.dwErrorStatus &
                    RETRY_AIA_ERROR_STATUS)) {
            // For a potential key rollover root attempt to retrieve
            // the key rollover cross cert using the subject's AIA.

            if (2 <= cEle &&
                    IsPotentialKeyRolloverRoot(ppEle[cEle - 1]->pCertContext)) {
                hNewerIssuerUrlStore = GetNewerIssuerUrlStore(
                    pCallContext,
                    ppEle[cEle - 2]->pCertContext,      // Subject
                    ppEle[cEle - 1]->pCertContext       // Root, Issuer
                    );
            }
        } else {
            // Try to retrieve a newer CA cert via the subject's AIA extension.
            //
            // Note, will only try for the first revoked or time
            // invalid CA cert in the first simple chain.

            DWORD i;

            for (i = 1; i < cEle; i++) {
                PCERT_CHAIN_ELEMENT pIssuerEle = ppEle[i];

                if (pIssuerEle->TrustStatus.dwErrorStatus &
                        RETRY_AIA_ERROR_STATUS) {
                    // First Revoked or Time Invalid CA

                    PCCERT_CONTEXT pIssuerCert = pIssuerEle->pCertContext;
                    PCERT_EXTENSION pExt;

                    // Ignore CrossCA's. If the CA cert has a Certificate
                    // Template Name extension we will check if its set to
                    // "CrossCA". Note, this is only a hint. Its not a
                    // requirement to have this extension for a cross cert.
                    pExt = CertFindExtension(
                        szOID_ENROLL_CERTTYPE_EXTENSION,
                        pIssuerCert->pCertInfo->cExtension,
                        pIssuerCert->pCertInfo->rgExtension
                        );
                    if (pExt && pExt->Value.cbData ==
                                    sizeof(rgbEncodedCrossCAUnicodeString) &&
                            0 == memcmp(pExt->Value.pbData,
                                rgbEncodedCrossCAUnicodeString,
                                sizeof(rgbEncodedCrossCAUnicodeString)))
                        break;
                
                    hNewerIssuerUrlStore = GetNewerIssuerUrlStore(
                        pCallContext,
                        ppEle[i - 1]->pCertContext,      // Subject
                        pIssuerCert
                        );

                    break;
                }
            }
        }

        if (hNewerIssuerUrlStore) {
            // Rebuild the chain using the newer AIA retrieved Issuer cert

            HCERTSTORE hNewerAdditionalStore = NULL;

            if (hAdditionalStore) {
                hNewerAdditionalStore = CertOpenStore(
                    CERT_STORE_PROV_COLLECTION,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    NULL,
                    CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                    NULL
                    );
                if (hNewerAdditionalStore) {
                    if (!CertAddStoreToCollection(hNewerAdditionalStore,
                            hNewerIssuerUrlStore, 0, 0) ||
                        !CertAddStoreToCollection(hNewerAdditionalStore,
                            hAdditionalStore, 0, 0)) {

                        CertCloseStore(hNewerAdditionalStore, 0);
                        hNewerAdditionalStore = NULL;
                    }
                }
            } else 
                hNewerAdditionalStore =
                    CertDuplicateStore(hNewerIssuerUrlStore);

            if (hNewerAdditionalStore) {
                PCCERT_CHAIN_CONTEXT pNewerChainContext = NULL;

                LockEngine();

                pCallContext->FlushObjectsInCreationCache( );

                UnlockEngine();

                if (CreateChainContextFromPathGraph(
                        pCallContext,
                        pCertContext,
                        hNewerAdditionalStore,
                        &pNewerChainContext
                        )) {
                    assert(pNewerChainContext);
                    CertFreeCertificateChain(pChainContext);
                    pChainContext = pNewerChainContext;
                }

                CertCloseStore(hNewerAdditionalStore, 0);
            }

            CertCloseStore(hNewerIssuerUrlStore, 0);
        }
    }


SuccessReturn:
    if (0 < pCallContext->AIAUrlRetrievalCount() &&
            0 == (pChainContext->TrustStatus.dwErrorStatus &
                    DISABLE_AIA_ADD_CERT_STATUS) &&
            NULL != CAStore()) {

        DWORD i;

        // Add any AIA retrieved CA certificates to the CA store
        pChain = pChainContext->rgpChain[0];
        cEle = pChain->cElement;
        ppEle = pChain->rgpElement;

        // Ignore end entity and self signed root certificates
        for (i = 1; i < cEle - 1; i++) {
            PCCERT_CONTEXT pAIACert = ppEle[i]->pCertContext;
            DWORD cbData;

            if (CertGetCertificateContextProperty(
                    pAIACert,
                    CERT_AIA_URL_RETRIEVED_PROP_ID,
                    NULL,
                    &cbData
                    )) {

                // Delete the property
                CertSetCertificateContextProperty(
                    pAIACert,
                    CERT_AIA_URL_RETRIEVED_PROP_ID,
                    CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                    NULL
                    );

                CertAddCertificateContextToStore(
                    CAStore(),
                    pAIACert,
                    CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
                    NULL
                    );
            }
        }
    }


    fResult = TRUE;

CommonReturn:
    if (pCallContext) {
        LockEngine();

        CallContextFreeCallObject(pCallContext);

        UnlockEngine();
    }

    if (0 != dwLastError)
        SetLastError(dwLastError);

    *ppChainContext = pChainContext;
    return fResult;

ErrorReturn:
    dwLastError = GetLastError();

    assert(NULL == pChainContext);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CallContextCreateCallObjectError)
TRACE_ERROR(CreateChainContextFromPathGraphError)
}


//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::CreateChainContextFromPathGraph, public
//
//  Synopsis:   builds a chain path graph and returns quality ordered
//              chain contexts
//
//              NOTE: This method acquires the engine lock
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::CreateChainContextFromPathGraph (
                     IN PCCHAINCALLCONTEXT pCallContext,
                     IN PCCERT_CONTEXT pCertContext,
                     IN OPTIONAL HCERTSTORE hAdditionalStore,
                     OUT PCCERT_CHAIN_CONTEXT* ppChainContext
                     )
{
    BOOL fResult;
    DWORD dwLastError = 0;
    BOOL fLocked = FALSE;
    BYTE rgbCertHash[CHAINHASHLEN];
    DWORD cbCertHash;
    PCCERTOBJECT pEndCertObject = NULL;
    PCCHAINPATHOBJECT pEndPathObject = NULL;
    PCCHAINPATHOBJECT pTopPathObject = NULL;
    HCERTSTORE hAdditionalStoreToUse = NULL;
    HCERTSTORE hAllStore = NULL;
    PINTERNAL_CERT_CHAIN_CONTEXT pNewChainContext = NULL;   // don't release
    PINTERNAL_CERT_CHAIN_CONTEXT pChainContext = NULL;
    DWORD cChainContext = 0;
    DWORD dwFlags = pCallContext->CallFlags();

    cbCertHash = CHAINHASHLEN;
    if (!CertGetCertificateContextProperty(
            pCertContext,
            CERT_MD5_HASH_PROP_ID,
            rgbCertHash,
            &cbCertHash
            ) || CHAINHASHLEN != cbCertHash)
        goto GetCertHashError;

    if (hAdditionalStore) {
        if (!ChainCreateCollectionIncludingCtlCertificates(
                hAdditionalStore,
                &hAdditionalStoreToUse
                ))
            goto CreateAdditionalStoreCollectionError;

        hAllStore = CertOpenStore(
            CERT_STORE_PROV_COLLECTION,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            NULL,
            CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
            NULL
            );
        if (NULL == hAllStore)
            goto OpenAllCollectionError;
        if (!CertAddStoreToCollection(hAllStore, OtherStore(), 0, 0 ))
            goto AddToAllCollectionError;
        if (!CertAddStoreToCollection(hAllStore, hAdditionalStoreToUse, 0, 0 ))
            goto AddToAllCollectionError;
    } else 
        hAllStore = CertDuplicateStore(OtherStore());

    LockEngine();
    fLocked = TRUE;

    // We're in this loop to handle the case where we leave the engine's
    // critical section and another thread has entered the engine's
    // critical section and done a resync or added a cached issuer cert object.
    while (TRUE) {
        if (!Resync(pCallContext, FALSE))
            goto ResyncError;

        pCallContext->ResetTouchEngine();

        assert(NULL == pEndCertObject);
        pEndCertObject = m_pCertObjectCache->FindIssuerObjectByHash(
            rgbCertHash);

        fResult = TRUE;
        if (NULL == pEndCertObject) {
            pEndCertObject = m_pCertObjectCache->FindEndObjectByHash(
                rgbCertHash);

            if (NULL == pEndCertObject) {
                fResult = ChainCreateCertObject(
                        CERT_END_OBJECT_TYPE,
                        pCallContext,
                        pCertContext,
                        rgbCertHash,
                        &pEndCertObject
                        );
            } else {
                CertPerfIncrementChainEndCertInCacheCount();
            }
        }

        if (pCallContext->IsTouchedEngine()) {
            // The chain engine was touched at some point when we left
            // the engine's lock to create the end cert object
            if (pEndCertObject) {
                pEndCertObject->Release();
                pEndCertObject = NULL;
            }

            continue;
        }

        if (!fResult)
            goto CreateCertObjectError;
        assert(pEndCertObject);

        // This will create the entire path graph
        fResult = ChainCreatePathObject(
                       pCallContext,
                       pEndCertObject,
                       hAdditionalStoreToUse,
                       &pEndPathObject
                       );

        if (pCallContext->IsTouchedEngine()) {
            // The chain engine was touched at some point when we left
            // the engine's lock to verify a signature or do URL fetching.

            pEndCertObject->Release();
            pEndCertObject = NULL;
            pEndPathObject = NULL;
            pCallContext->FlushObjectsInCreationCache( );
        } else
            break;
    }

    if (!fResult)
        goto CreatePathObjectError;

    if (pCallContext->CallOrEngineFlags() & CERT_CHAIN_CACHE_END_CERT)
        m_pCertObjectCache->AddEndObject(pCallContext, pEndCertObject);


    // Create the ChainContext without holding the engine lock
    UnlockEngine();
    fLocked = FALSE;

    // Loop through all the certificate paths:
    //  - Calculate additional status
    //  - Create chain context and its quality value
    //  - Determine highest quality chain
    //  - Optionally, maintain a linked list of the lower quality chains

    while (pTopPathObject = pEndPathObject->NextPath(
            pCallContext,
            pTopPathObject
            )) {
        PCCHAINPATHOBJECT pPathObject;

        // Loop downward to calculate additional status
        for (pPathObject = pTopPathObject;
                pPathObject && !pPathObject->HasAdditionalStatus();
                            pPathObject = pPathObject->DownPathObject()) {
            pPathObject->CalculateAdditionalStatus(
                pCallContext,
                hAllStore
                );
        }

        // Also calculates the chain's quality value
        pNewChainContext = pEndPathObject->CreateChainContextFromPath(
            pCallContext,
            pTopPathObject
            );
        if (NULL == pNewChainContext)
            goto CreateChainContextFromPathError;

        // Fixup end cert
        ChainUpdateEndEntityCertContext(pNewChainContext, pCertContext);

        // Add logic to call either the chain engine's or the caller's
        // callback function here to provide additional chain context
        // quality

        if (NULL == pChainContext) {
            pChainContext = pNewChainContext;
            cChainContext = 1;
        } else {
            BOOL fNewHigherQuality = FALSE;

            if (pNewChainContext->dwQuality > pChainContext->dwQuality)
                fNewHigherQuality = TRUE;
            else if (pNewChainContext->dwQuality == pChainContext->dwQuality) {
                BOOL fDupPublicKeyOrName = FALSE;

                PCERT_SIMPLE_CHAIN pChain =
                    pChainContext->ChainContext.rgpChain[0];
                PCERT_SIMPLE_CHAIN pNewChain =
                    pNewChainContext->ChainContext.rgpChain[0];
                DWORD cElement = pChain->cElement;
                DWORD cNewElement = pNewChain->cElement;

                if (cElement != cNewElement) {
                    // Check if the longer chain has any duplicate public
                    // keys or names. This could happen if we have 2 sets of
                    // cross certificates or root rollever certs

                    PCERT_SIMPLE_CHAIN pLongChain;
                    DWORD cLongElement;
                    DWORD i;

                    if (cElement > cNewElement) {
                        pLongChain = pChain;
                        cLongElement = cElement;
                    } else {
                        pLongChain = pNewChain;
                        cLongElement = cNewElement;
                    }

                    // Start with the CA and compare all keys and names up to 
                    // and including the root
                    for (i = 1; i + 1 < cLongElement; i++) {
                        DWORD j;
                        DWORD cbHash;
                        BYTE rgbHash0[ CHAINHASHLEN ];
                        PCCERT_CONTEXT pCert0 =
                            pLongChain->rgpElement[i]->pCertContext;

                        cbHash = CHAINHASHLEN;
                        if (!CertGetCertificateContextProperty(
                                pCert0,
                                CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID,
                                rgbHash0,
                                &cbHash
                                ) || CHAINHASHLEN != cbHash)
                            break;

                        for (j = i + 1; j < cLongElement; j++) {
                            BYTE rgbHash1[ CHAINHASHLEN ];
                            PCCERT_CONTEXT pCert1 =
                                pLongChain->rgpElement[j]->pCertContext;

                            cbHash = CHAINHASHLEN;
                            if (!CertGetCertificateContextProperty(
                                    pCert1,
                                    CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID,
                                    rgbHash1,
                                    &cbHash
                                    ) || CHAINHASHLEN != cbHash)
                                break;

                            if (0 == memcmp(rgbHash0, rgbHash1, CHAINHASHLEN)
                                                ||
                                    CertCompareCertificateName(
                                        pCert0->dwCertEncodingType,
                                        &pCert0->pCertInfo->Subject,
                                        &pCert1->pCertInfo->Subject)) {
                                fDupPublicKeyOrName = TRUE;
                                break;
                            }
                        }

                        if (fDupPublicKeyOrName)
                            break;
                    }
                }

                if (fDupPublicKeyOrName) {
                    if (cElement > cNewElement)
                        fNewHigherQuality = TRUE;
                } else {
                    DWORD i;
                    DWORD cMinElement;

                    // Chains having certs with later NotAfter/NotBefore dates
                    // starting with the first CA cert are considered higher
                    // quality when dwQuality is the same. Will only compare
                    // the first simple chain.
                    cMinElement = min(cElement, cNewElement);

                    for (i = 1; i < cMinElement; i++) {
                        LONG lCmp;

                        PCERT_INFO pCertInfo =
                            pChain->rgpElement[i]->pCertContext->pCertInfo;
                        PCERT_INFO pNewCertInfo =
                            pNewChain->rgpElement[i]->pCertContext->pCertInfo;
                        
                        lCmp = CompareFileTime(&pNewCertInfo->NotAfter,
                            &pCertInfo->NotAfter);
                        if (0 < lCmp) {
                            fNewHigherQuality = TRUE;
                            break;
                        } else if (0 > lCmp) {
                            break;
                        } else {
                            // Same NotAfter. Check NotBefore.
                            lCmp = CompareFileTime(&pNewCertInfo->NotBefore,
                                &pCertInfo->NotBefore);
                            if (0 < lCmp) {
                                fNewHigherQuality = TRUE;
                                break;
                            } else if (0 > lCmp)
                                break;
                            // else
                            //  Same
                        }
                    }
                }
            }
            // else
            //  fNewHigherQuality = FALSE;

            if (fNewHigherQuality) {
                if (dwFlags & CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS) {
                    pNewChainContext->pNext = pChainContext;
                    pChainContext = pNewChainContext;
                    cChainContext++;
                } else {
                    ChainReleaseInternalChainContext(pChainContext);
                    pChainContext = pNewChainContext;
                }
            } else {
                if (dwFlags & CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS) {
                    PINTERNAL_CERT_CHAIN_CONTEXT p;

                    // Insert according to quality
                    for (p = pChainContext;
                             p->pNext && p->pNext->dwQuality >=
                                 pNewChainContext->dwQuality;
                                                                p = p->pNext) {
                        ;
                    }

                    pNewChainContext->pNext = p->pNext;
                    p->pNext = pNewChainContext;

                    cChainContext++;
                } else {
                    ChainReleaseInternalChainContext(pNewChainContext);
                }
            }
        }
    }

    if (GetLastError() != CRYPT_E_NOT_FOUND)
        goto NextPathError;

    assert(pChainContext && cChainContext);


    if (cChainContext > 1) {
        PINTERNAL_CERT_CHAIN_CONTEXT p;
        PCCERT_CHAIN_CONTEXT *ppLower;

        // Create array of lower quality chain contexts
        ppLower = new PCCERT_CHAIN_CONTEXT [ cChainContext - 1];
        if (NULL == ppLower)
            goto OutOfMemory;

        pChainContext->ChainContext.cLowerQualityChainContext =
            cChainContext - 1;
        pChainContext->ChainContext.rgpLowerQualityChainContext = ppLower;

        for (p = pChainContext->pNext; p; p = p->pNext, ppLower++) {
            assert(cChainContext > 1);
            cChainContext--;

            *ppLower = (PCCERT_CHAIN_CONTEXT) p;
        }

    }

    assert(1 == cChainContext);

    fResult = TRUE;

CommonReturn:
    if (!fLocked)
        LockEngine();

    if (pEndCertObject)
        pEndCertObject->Release();

    if (hAllStore)
        CertCloseStore(hAllStore, 0);
    if (hAdditionalStoreToUse)
        CertCloseStore(hAdditionalStoreToUse, 0);


    *ppChainContext = (PCCERT_CHAIN_CONTEXT) pChainContext;

    UnlockEngine();

    if (0 != dwLastError)
        SetLastError(dwLastError);
    return fResult;

ErrorReturn:
    dwLastError = GetLastError();

    if (pChainContext) {
        PINTERNAL_CERT_CHAIN_CONTEXT p;

        while (p = pChainContext->pNext) {
            pChainContext->pNext = p->pNext;
            ChainReleaseInternalChainContext(p);
        }

        ChainReleaseInternalChainContext(pChainContext);
        pChainContext = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetCertHashError)
TRACE_ERROR(CreateAdditionalStoreCollectionError)
TRACE_ERROR(OpenAllCollectionError)
TRACE_ERROR(AddToAllCollectionError)
TRACE_ERROR(ResyncError)
TRACE_ERROR(CreateCertObjectError)
TRACE_ERROR(CreatePathObjectError)
TRACE_ERROR(CreateChainContextFromPathError)
TRACE_ERROR(NextPathError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::IsPotentialKeyRolloverRoot, public
//
//  Synopsis:   checks if the root certificate is a potential key rollover
//              candidate by trying to find a matching cross certificate
//              having the same subject name with a different key. Returns TRUE
//              if such a matching cross certificate is found in the engine's
//              OtherStore (really WorldStore).
//
//              NOTE: This method acquires the engine lock
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::IsPotentialKeyRolloverRoot (
                     IN PCCERT_CONTEXT pRootCertContext
                     )
{
    BOOL fPotentialRollover = FALSE;
    PCCERT_CONTEXT pCert = NULL;

    LockEngine();

    while (pCert = CertFindCertificateInStore(
            m_hOtherStore,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                              // dwFindFlags
            CERT_FIND_SUBJECT_NAME,
            (const void *) &pRootCertContext->pCertInfo->Subject,
            pCert
            )) {
        PCRYPT_BIT_BLOB pRootKey =
            &pRootCertContext->pCertInfo->SubjectPublicKeyInfo.PublicKey;
        PCRYPT_BIT_BLOB pCertKey =
            &pCert->pCertInfo->SubjectPublicKeyInfo.PublicKey;

        if (pRootKey->cbData != pCertKey->cbData ||
                0 != memcmp(pRootKey->pbData, pCertKey->pbData,
                        pRootKey->cbData)) {
            fPotentialRollover = TRUE;
            CertFreeCertificateContext(pCert);
            break;
        }
    }

    UnlockEngine();
    return fPotentialRollover;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetIssuerUrlStore, public
//
//  Synopsis:   if the certificate has an Authority Info Access extension,
//              return a store containing the issuing certificates
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetIssuerUrlStore(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERT_CONTEXT pSubjectCertContext,
    IN DWORD dwRetrievalFlags,
    OUT HCERTSTORE *phIssuerUrlStore
    )
{
    BOOL             fTouchedResult = TRUE;
    BOOL             fResult;
    DWORD            cbUrlArray;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD            cCount;
    DWORD            dwCacheResultFlag;


    *phIssuerUrlStore = NULL;

    if (m_Config.fDisableAIAUrlRetrieval ||
            pCallContext->AIAUrlRetrievalCount() >=
                m_Config.dwMaxAIAUrlRetrievalCountPerChain)
    {
        return TRUE;
    }

    dwRetrievalFlags |= CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
                            CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL |
                            CRYPT_OFFLINE_CHECK_RETRIEVAL |
                            CRYPT_AIA_RETRIEVAL;

    fResult = ChainGetObjectUrl(
                   URL_OID_CERTIFICATE_ISSUER,
                   (LPVOID) pSubjectCertContext,
                   CRYPT_GET_URL_FROM_EXTENSION,
                   NULL,
                   &cbUrlArray,
                   NULL,
                   NULL,
                   NULL
                   );

    if ( fResult )
    {
        pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
        if ( pUrlArray == NULL )
        {
            return TRUE;
        }

        fResult = ChainGetObjectUrl(
                       URL_OID_CERTIFICATE_ISSUER,
                       (LPVOID) pSubjectCertContext,
                       CRYPT_GET_URL_FROM_EXTENSION,
                       pUrlArray,
                       &cbUrlArray,
                       NULL,
                       NULL,
                       NULL
                       );

        if ( fResult )
        {
            if (pUrlArray->cUrl > m_Config.dwMaxAIAUrlCountInCert)
            {
                ChainOutputDebugStringA("CRYPT32.DLL --> Exceeded MaxAIAUrlCountInCert\n");
                fResult = FALSE;
            }

        }
    }

    if ( fResult )
    {
        BOOL fLocked = FALSE;
        CRYPT_RETRIEVE_AUX_INFO RetrieveAuxInfo;

        memset(&RetrieveAuxInfo, 0, sizeof(RetrieveAuxInfo));
        RetrieveAuxInfo.cbSize = sizeof(RetrieveAuxInfo);
        RetrieveAuxInfo.dwMaxUrlRetrievalByteCount =
            m_Config.dwMaxAIAUrlRetrievalByteCount;

        //
        // We are about to go on the wire to retrieve the issuer certificate.
        // At this time we will release the chain engine lock so others can
        // go about there business while we wait for the protocols to do the
        // fetching.
        //

        UnlockEngine();

        for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
        {
            dwCacheResultFlag = 0;

            if (!(dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL)) {
                if (pCallContext->AIAUrlRetrievalCount() >=
                        m_Config.dwMaxAIAUrlRetrievalCountPerChain)
                {
                    ChainOutputDebugStringA("CRYPT32.DLL --> Exceeded MaxAIAUrlRetrievalCountPerChain\n");
                    break;
                }
                pCallContext->IncrementAIAUrlRetrievalCount();

                if (0 != _wcsnicmp(pUrlArray->rgwszUrl[ cCount ], L"http:", 5))
                {
                    dwCacheResultFlag = CRYPT_DONT_CACHE_RESULT;
                }
            } else if (0 == pCallContext->AIAUrlRetrievalCount()) {
                // Need a nonzero retrieval count so we can add to the CA
                // store
                pCallContext->IncrementAIAUrlRetrievalCount();
            }


            fResult = ChainRetrieveObjectByUrlW(
                           pUrlArray->rgwszUrl[ cCount ],
                           CONTEXT_OID_CERTIFICATE,
                           dwRetrievalFlags | dwCacheResultFlag,
                           (dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL) ?
                                0 : pCallContext->AIAUrlRetrievalTimeout(),
                           (LPVOID *)phIssuerUrlStore,
                           NULL,
                           NULL,
                           NULL,
                           &RetrieveAuxInfo
                           );

            if ( fResult )
            {
                CertPerfIncrementChainUrlIssuerCount();
                if (dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL)
                    CertPerfIncrementChainCacheOnlyUrlIssuerCount();

                //
                // Retake the engine lock. Also check if the engine was
                // touched during our absence.
                //

                LockEngine();
                if (pCallContext->IsTouchedEngine()) {
                    fTouchedResult = FALSE;
                    SetLastError( (DWORD) ERROR_CAN_NOT_COMPLETE );
                }

                fLocked = TRUE;


                if (!fTouchedResult) {
                    CertCloseStore(*phIssuerUrlStore, 0);
                    *phIssuerUrlStore = NULL;
                } else {
                    // Check that we don't exceed the maximum allowed number
                    // of certificates per AIA retrieval. Also, set
                    // the AIA property on each certificate. If these
                    // certificates are used in the returned chain context,
                    // then, they will be added to the CA store.

                    CRYPT_DATA_BLOB DataBlob = {0, NULL};
                    PCCERT_CONTEXT pAIACert = NULL;
                    DWORD cAIACert = 0;

                    while (pAIACert = CertEnumCertificatesInStore(
                            *phIssuerUrlStore, pAIACert)) {
                        cAIACert++;

                        CertSetCertificateContextProperty(
                            pAIACert,
                            CERT_AIA_URL_RETRIEVED_PROP_ID,
                            CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG,
                            &DataBlob
                            );
                    }

                    if (cAIACert > m_Config.dwMaxAIAUrlRetrievalCertCount) {
                        ChainOutputDebugStringA("CRYPT32.DLL --> Exceeded MaxAIAUrlRetrievalCertCount\n");
                        CertCloseStore(*phIssuerUrlStore, 0);
                        *phIssuerUrlStore = NULL;
                    }
                }

                break;
            }
        }

        //
        // Retake the engine lock if necessary
        //

        if ( !fLocked )
        {
            LockEngine();
            if (pCallContext->IsTouchedEngine()) {
                fTouchedResult = FALSE;
                SetLastError( (DWORD) ERROR_CAN_NOT_COMPLETE );
            }
        }
    }

    delete (LPBYTE)pUrlArray;

    // NOTE: Need to somehow log that we tried to retrieve the issuer but
    //       it was inaccessible

    return( fTouchedResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetNewerIssuerUrlStore, public
//
//  Synopsis:   if the subject certificate has an Authority Info Access
//              extension, attempts an online URL retrieval of the
//              issuer certificate(s). If any of the URL retrieved
//              certs are different from the input Issuer cert,
//              returns a store containing the issuing certificates.
//              Otherwise, returns NULL store.
//
//  Assumption: Chain engine isn't locked in the calling thread. Also,
//              only called if online.
//
//----------------------------------------------------------------------------
HCERTSTORE
CCertChainEngine::GetNewerIssuerUrlStore(
        IN PCCHAINCALLCONTEXT pCallContext,
        IN PCCERT_CONTEXT pSubjectCertContext,
        IN PCCERT_CONTEXT pIssuerCertContext
        )
{
    HCERTSTORE hNewIssuerUrlStore = NULL;

    LockEngine();

    while (TRUE) {
        pCallContext->ResetTouchEngine();

        GetIssuerUrlStore(
            pCallContext,
            pSubjectCertContext,
            CRYPT_WIRE_ONLY_RETRIEVAL,
            &hNewIssuerUrlStore
            );
        if (!pCallContext->IsTouchedEngine())
            break;

        assert(NULL == hNewIssuerUrlStore);
    }

    UnlockEngine();

    if (hNewIssuerUrlStore) {
        // Discard if it doesn't contain more than just the input
        // pIssuerCertContext

        PCCERT_CONTEXT pCert;

        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hNewIssuerUrlStore, pCert)) {
            if (!CertCompareCertificate(
                    pCert->dwCertEncodingType,
                    pCert->pCertInfo,
                    pIssuerCertContext->pCertInfo
                    )) {
                CertFreeCertificateContext(pCert);
                return hNewIssuerUrlStore;
            }
        }

        CertCloseStore(hNewIssuerUrlStore, 0);
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::Resync, public
//
//  Synopsis:   resync the store if necessary
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//              A resync increments the engine's touch count.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::Resync (IN PCCHAINCALLCONTEXT pCallContext, BOOL fForce)
{
    BOOL fResync = FALSE;
    BOOL fResult = TRUE;

    if ( fForce == FALSE )
    {
        if ( WaitForSingleObject(
                 m_hEngineStoreChangeEvent,
                 0
                 ) == WAIT_OBJECT_0 )
        {
            fResync = TRUE;
        }
    }
    else
    {
        fResync = TRUE;
    }


    if ( fResync )
    {
        CertControlStore(
            m_hEngineStore,
            CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG,
            CERT_STORE_CTRL_RESYNC,
            &m_hEngineStoreChangeEvent
            );

        m_pCertObjectCache->FlushObjects( pCallContext );

        fResult = m_pSSCtlObjectCache->Resync( this );

        assert( fResult == TRUE );

        assert( m_hCrossCertStore );

        // Remove CrossCert collection from engine's list. Don't want to
        // also search it for cross cert distribution points
        CertRemoveStoreFromCollection(
            m_hOtherStore,
            m_hCrossCertStore
            );

        fResult = GetCrossCertDistPointsForStore(
             m_hEngineStore,
             TRUE,                  // fOnlyLMSystemStore
             &m_pCrossCertDPLink
             );

        CertAddStoreToCollection(
            m_hOtherStore,
            m_hCrossCertStore,
            0,
            0
            );

        pCallContext->TouchEngine();

        CertPerfIncrementChainEngineResyncCount();
    }

    if ( fResult )
    {
        while (TRUE ) {
            pCallContext->ResetTouchEngine();

            // The following 2 updates leave the engine's critical
            // section to do the URL fetching. If the engine was touched by
            // another thread, it fails with LastError set to
            // ERROR_CAN_NOT_COMPLETE and IsTouchedEngine() is TRUE.

            UpdateCrossCerts(pCallContext);
            if (pCallContext->IsTouchedEngine())
                continue;

            m_pSSCtlObjectCache->UpdateCache(this, pCallContext);
            if (!pCallContext->IsTouchedEngine())
                break;
        }
    }

    return( TRUE );
}


//+===========================================================================
//  CCertObject helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertObject
//
//  Synopsis:   create a cert object, note since it is a ref-counted
//              object, freeing occurs by doing a pCertObject->Release
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCertObject (
    IN DWORD dwObjectType,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERT_CONTEXT pCertContext,
    IN OPTIONAL LPBYTE pbCertHash,
    OUT PCCERTOBJECT *ppCertObject
    )
{
    BOOL fResult = TRUE;
    PCCERTOBJECT pCertObject;
    BYTE rgbHash[CHAINHASHLEN];

    if (NULL == pbCertHash) {
        DWORD cbHash = CHAINHASHLEN;

        if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_MD5_HASH_PROP_ID,
                rgbHash,
                &cbHash
                ) || CHAINHASHLEN != cbHash) {
            *ppCertObject = NULL;
            return FALSE;
        }
        pbCertHash = rgbHash;
    }

    if (CERT_CACHED_ISSUER_OBJECT_TYPE == dwObjectType) {
        pCertObject =
            pCallContext->ChainEngine()->CertObjectCache()->FindIssuerObjectByHash(
                pbCertHash);

        if (NULL != pCertObject) {
            *ppCertObject = pCertObject;
            return TRUE;
        }
    } else {
        PCCHAINPATHOBJECT pPathObject;

        pPathObject = pCallContext->FindPathObjectInCreationCache(
            pbCertHash);
        if (NULL != pPathObject) {
            pCertObject = pPathObject->CertObject();
            pCertObject->AddRef();
            *ppCertObject = pCertObject;

            return TRUE;
        }
    }


    pCertObject = new CCertObject(
                        dwObjectType,
                        pCallContext,
                        pCertContext,
                        pbCertHash,
                        fResult
                        );

    if (NULL != pCertObject) {
        if (!fResult) {
            pCertObject->Release();
            pCertObject = NULL;
        } else if (CERT_CACHED_ISSUER_OBJECT_TYPE == dwObjectType) {
            // Following add increments the engine's touch count
            pCallContext->ChainEngine()->CertObjectCache()->AddIssuerObject(
                pCallContext,
                pCertObject
                );
        }
    } else {
        fResult = FALSE;

    }

    *ppCertObject = pCertObject;
    return fResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainFillCertObjectCtlCacheEnumFn
//
//  Synopsis:   CSSCtlObjectCache::EnumObjects callback used to create
//              the linked list of CTL cache entries.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFillCertObjectCtlCacheEnumFn(
     IN LPVOID pvParameter,
     IN PCSSCTLOBJECT pSSCtlObject
     )
{
    PCERT_OBJECT_CTL_CACHE_ENUM_DATA pEnumData =
        (PCERT_OBJECT_CTL_CACHE_ENUM_DATA) pvParameter;
    PCERT_TRUST_LIST_INFO pTrustListInfo = NULL;
    PCERT_OBJECT_CTL_CACHE_ENTRY pEntry = NULL;

    if (!pEnumData->fResult)
        return FALSE;

    if (!pSSCtlObject->GetTrustListInfo(
            pEnumData->pCertObject->CertContext(),
            &pTrustListInfo
            )) {
        DWORD dwErr = GetLastError();
        if (CRYPT_E_NOT_FOUND == dwErr)
            return TRUE;
        else {
            pEnumData->fResult = FALSE;
            pEnumData->dwLastError = dwErr;
            return FALSE;
        }
    }

    pEntry = new CERT_OBJECT_CTL_CACHE_ENTRY;
    if (NULL == pEntry) {
        SSCtlFreeTrustListInfo(pTrustListInfo);

        pEnumData->fResult = FALSE;
        pEnumData->dwLastError = (DWORD) E_OUTOFMEMORY;
        return FALSE;
    }

    pSSCtlObject->AddRef();
    pEntry->pSSCtlObject = pSSCtlObject;
    pEntry->pTrustListInfo = pTrustListInfo;
    pEnumData->pCertObject->InsertCtlCacheEntry(pEntry);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCertObjectCtlCache
//
//  Synopsis:   free the linked list of CTL cache entries.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCertObjectCtlCache(
     IN PCERT_OBJECT_CTL_CACHE_ENTRY pCtlCacheHead
     )
{
    PCERT_OBJECT_CTL_CACHE_ENTRY pCtlCache;

    while (pCtlCache = pCtlCacheHead) {
        pCtlCacheHead = pCtlCacheHead->pNext;

        if (pCtlCache->pTrustListInfo)
            SSCtlFreeTrustListInfo(pCtlCache->pTrustListInfo);

        if (pCtlCache->pSSCtlObject)
            pCtlCache->pSSCtlObject->Release();

        delete pCtlCache;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocAndDecodeObject
//
//  Synopsis:   allocate and decodes the ASN.1 encoded data structure.
//
//              NULL is returned for a decoding or allocation error.
//              PkiFree must be called to free the allocated data structure.
//
//----------------------------------------------------------------------------
LPVOID WINAPI
ChainAllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    DWORD cbStructInfo;
    void *pvStructInfo;

    if (!CryptDecodeObjectEx(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_SHARE_OID_STRING_FLAG |
                CRYPT_DECODE_NOCOPY_FLAG |
                CRYPT_DECODE_ALLOC_FLAG,
            &PkiDecodePara,
            (void *) &pvStructInfo,
            &cbStructInfo
            ))
        goto DecodeError;

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetIssuerMatchInfo
//
//  Synopsis:   return match bits specifying the types of issuer matching
//              that can be done for this certificate and if available return
//              the decoded authority key identifier extension
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetIssuerMatchInfo (
     IN PCCERT_CONTEXT pCertContext,
     OUT DWORD *pdwIssuerMatchFlags,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     )
{
    PCERT_EXTENSION              pExt;
    LPVOID                       pv = NULL;
    BOOL                         fV1AuthKeyIdInfo = TRUE;
    PCERT_AUTHORITY_KEY_ID_INFO  pAuthKeyIdentifier = NULL;
    DWORD                        dwIssuerMatchFlags = 0;

    pExt = CertFindExtension(
               szOID_AUTHORITY_KEY_IDENTIFIER,
               pCertContext->pCertInfo->cExtension,
               pCertContext->pCertInfo->rgExtension
               );

    if ( pExt == NULL )
    {
        fV1AuthKeyIdInfo = FALSE;

        pExt = CertFindExtension(
                   szOID_AUTHORITY_KEY_IDENTIFIER2,
                   pCertContext->pCertInfo->cExtension,
                   pCertContext->pCertInfo->rgExtension
                   );
    }

    if ( pExt != NULL )
    {

        pv = ChainAllocAndDecodeObject(
            pExt->pszObjId,
            pExt->Value.pbData,
            pExt->Value.cbData
            );
    }

    if ( pv )
    {
        if ( fV1AuthKeyIdInfo == FALSE )
        {
            // NOTENOTE: Yes, this is a bit backwards but, right now but the
            //           V1 structure is a bit easier to deal with and we
            //           only support the V1 version of the V2 structure
            //           anyway
            ChainConvertAuthKeyIdentifierFromV2ToV1(
                (PCERT_AUTHORITY_KEY_ID2_INFO)pv,
                &pAuthKeyIdentifier
                );

        }
        else
        {
            pAuthKeyIdentifier = (PCERT_AUTHORITY_KEY_ID_INFO)pv;
            pv = NULL;
        }

        if ( pAuthKeyIdentifier != NULL )
        {
            if ( ( pAuthKeyIdentifier->CertIssuer.cbData != 0 ) &&
                 ( pAuthKeyIdentifier->CertSerialNumber.cbData != 0 ) )
            {
                dwIssuerMatchFlags |= CERT_EXACT_ISSUER_MATCH_FLAG;
            }

            if ( pAuthKeyIdentifier->KeyId.cbData != 0 )
            {
                dwIssuerMatchFlags |= CERT_KEYID_ISSUER_MATCH_FLAG;
            }

            if (0 == dwIssuerMatchFlags) {
                delete (LPBYTE) pAuthKeyIdentifier;
                pAuthKeyIdentifier = NULL;
            }

        }
    }

    dwIssuerMatchFlags |= CERT_NAME_ISSUER_MATCH_FLAG;

    if (pv)
        PkiFree(pv);

    *pdwIssuerMatchFlags = dwIssuerMatchFlags;
    *ppAuthKeyIdentifier = pAuthKeyIdentifier;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainConvertAuthKeyIdentifierFromV2ToV1
//
//  Synopsis:   convert authority key identifier from V2 to V1
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainConvertAuthKeyIdentifierFromV2ToV1 (
     IN PCERT_AUTHORITY_KEY_ID2_INFO pAuthKeyIdentifier2,
     OUT PCERT_AUTHORITY_KEY_ID_INFO* ppAuthKeyIdentifier
     )
{
    DWORD                       cb;
    PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdentifier;
    BOOL                        fExactMatchAvailable = FALSE;

    if ( ( pAuthKeyIdentifier2->AuthorityCertIssuer.cAltEntry == 1 ) &&
         ( pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].dwAltNameChoice ==
           CERT_ALT_NAME_DIRECTORY_NAME ) )
    {
        fExactMatchAvailable = TRUE;
    }

    cb = sizeof( CERT_AUTHORITY_KEY_ID_INFO );
    cb += pAuthKeyIdentifier2->KeyId.cbData;

    if ( fExactMatchAvailable == TRUE )
    {
        cb += pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.cbData;
        cb += pAuthKeyIdentifier2->AuthorityCertSerialNumber.cbData;
    }

    pAuthKeyIdentifier = (PCERT_AUTHORITY_KEY_ID_INFO)PkiZeroAlloc(cb);
    if ( pAuthKeyIdentifier == NULL )
    {
        return( FALSE );
    }

    pAuthKeyIdentifier->KeyId.cbData = pAuthKeyIdentifier2->KeyId.cbData;
    pAuthKeyIdentifier->KeyId.pbData = (LPBYTE)pAuthKeyIdentifier + sizeof( CERT_AUTHORITY_KEY_ID_INFO );

    memcpy(
       pAuthKeyIdentifier->KeyId.pbData,
       pAuthKeyIdentifier2->KeyId.pbData,
       pAuthKeyIdentifier->KeyId.cbData
       );

    if ( fExactMatchAvailable == TRUE )
    {
        pAuthKeyIdentifier->CertIssuer.cbData = pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.cbData;
        pAuthKeyIdentifier->CertIssuer.pbData = pAuthKeyIdentifier->KeyId.pbData + pAuthKeyIdentifier->KeyId.cbData;

        memcpy(
           pAuthKeyIdentifier->CertIssuer.pbData,
           pAuthKeyIdentifier2->AuthorityCertIssuer.rgAltEntry[0].DirectoryName.pbData,
           pAuthKeyIdentifier->CertIssuer.cbData
           );

        pAuthKeyIdentifier->CertSerialNumber.cbData = pAuthKeyIdentifier2->AuthorityCertSerialNumber.cbData;
        pAuthKeyIdentifier->CertSerialNumber.pbData = pAuthKeyIdentifier->CertIssuer.pbData + pAuthKeyIdentifier->CertIssuer.cbData;

        memcpy(
           pAuthKeyIdentifier->CertSerialNumber.pbData,
           pAuthKeyIdentifier2->AuthorityCertSerialNumber.pbData,
           pAuthKeyIdentifier->CertSerialNumber.cbData
           );
    }

    *ppAuthKeyIdentifier = pAuthKeyIdentifier;

    return( TRUE );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeAuthorityKeyIdentifier
//
//  Synopsis:   free the authority key identifier
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeAuthorityKeyIdentifier (
     IN PCERT_AUTHORITY_KEY_ID_INFO pAuthKeyIdInfo
     )
{
    PkiFree(pAuthKeyIdInfo);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainProcessSpecialOrDuplicateOIDsInUsage
//
//  Synopsis:   process and removes special or duplicate OIDs from the usage
//
//              For szOID_ANY_CERT_POLICY, frees the usage
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainProcessSpecialOrDuplicateOIDsInUsage (
    IN OUT PCERT_ENHKEY_USAGE *ppUsage,
    IN OUT DWORD *pdwFlags
    )
{
    PCERT_ENHKEY_USAGE pUsage = *ppUsage;
    DWORD dwFlags = *pdwFlags;
    LPSTR *ppszOID;
    DWORD cOID;
    DWORD i;

    cOID = pUsage->cUsageIdentifier;
    ppszOID = pUsage->rgpszUsageIdentifier;

    i = 0;
    while (i < cOID) {
        BOOL fSpecialOrDuplicate = TRUE;
        LPSTR pszOID = ppszOID[i];

        if (0 == strcmp(pszOID, szOID_ANY_CERT_POLICY))
            dwFlags |= CHAIN_ANY_POLICY_FLAG;
        else {
            // Check for duplicate OID

            DWORD j;

            fSpecialOrDuplicate = FALSE;
            for (j = 0; j < i; j++) {
                if (0 == strcmp(ppszOID[j], ppszOID[i])) {
                    fSpecialOrDuplicate = TRUE;
                    break;
                }
            }
        }

        if (fSpecialOrDuplicate) {
            // Remove the special or duplicate OID string and move the remaining
            // strings up one.
            DWORD j;

            for (j = i; j + 1 < cOID; j++)
                ppszOID[j] = ppszOID[j + 1];

            cOID--;
            pUsage->cUsageIdentifier = cOID;
        } else
            i++;
    }

    if (dwFlags & CHAIN_ANY_POLICY_FLAG) {
        PkiFree(pUsage);
        *ppUsage = NULL;
    }
        
    *pdwFlags = dwFlags;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainConvertPoliciesToUsage
//
//  Synopsis:   extract the usage OIDs from the cert policies
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainConvertPoliciesToUsage (
    IN PCERT_POLICIES_INFO pPolicy,
    IN OUT DWORD *pdwFlags,
    OUT PCERT_ENHKEY_USAGE *ppUsage
    )
{
    PCERT_ENHKEY_USAGE pUsage;
    LPSTR *ppszOID;
    DWORD cOID;
    DWORD i;

    cOID = pPolicy->cPolicyInfo;

    pUsage = (PCERT_ENHKEY_USAGE) PkiNonzeroAlloc(
        sizeof(CERT_ENHKEY_USAGE) + sizeof(LPSTR) * cOID);

    if (NULL == pUsage) {
        *pdwFlags |= CHAIN_INVALID_POLICY_FLAG;
        *ppUsage = NULL;
        return;
    }

    ppszOID = (LPSTR *) &pUsage[1];

    pUsage->cUsageIdentifier = cOID;
    pUsage->rgpszUsageIdentifier = ppszOID;

    for (i = 0; i < cOID; i++)
        ppszOID[i] = pPolicy->rgPolicyInfo[i].pszPolicyIdentifier;

    *ppUsage = pUsage;

    ChainProcessSpecialOrDuplicateOIDsInUsage(ppUsage, pdwFlags);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveDuplicatePolicyMappings
//
//  Synopsis:   remove any duplicate mappings
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveDuplicatePolicyMappings (
    IN OUT PCERT_POLICY_MAPPINGS_INFO pInfo
    )
{
    DWORD cMap = pInfo->cPolicyMapping;
    PCERT_POLICY_MAPPING pMap = pInfo->rgPolicyMapping;
    DWORD i;

    i = 0;
    while (i < cMap) {
        DWORD j;

        for (j = 0; j < i; j++) {
            if (0 == strcmp(pMap[i].pszSubjectDomainPolicy,
                    pMap[j].pszSubjectDomainPolicy))
                break;
        }

        if (j < i) {
            // Duplicate
            //
            // Remove the duplicate mapping and move the remaining
            // mappings up one.
            for (j = i; j + 1 < cMap; j++)
                pMap[j] = pMap[j + 1];

            cMap--;
            pInfo->cPolicyMapping = cMap;
        } else
            i++;
    }

}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetPoliciesInfo
//
//  Synopsis:   allocate and return the policies and usage info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetPoliciesInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCHAIN_POLICIES_INFO pPoliciesInfo
    )
{
    DWORD cExt = pCertContext->pCertInfo->cExtension;
    PCERT_EXTENSION rgExt = pCertContext->pCertInfo->rgExtension;
    DWORD i;
    DWORD cbData;

    for (i = 0; i < CHAIN_ISS_OR_APP_COUNT; i++ ) {
        PCHAIN_ISS_OR_APP_INFO pInfo = &pPoliciesInfo->rgIssOrAppInfo[i];
        PCERT_EXTENSION pExt;

        pExt = CertFindExtension(
            CHAIN_ISS_INDEX == i ?
                szOID_CERT_POLICIES : szOID_APPLICATION_CERT_POLICIES,
            cExt, rgExt);
        if (pExt) {
            pInfo->pPolicy =
                (PCERT_POLICIES_INFO) ChainAllocAndDecodeObject(
                    X509_CERT_POLICIES,
                    pExt->Value.pbData,
                    pExt->Value.cbData
                    );

            if (NULL == pInfo->pPolicy)
                pInfo->dwFlags |= CHAIN_INVALID_POLICY_FLAG;
            else
                ChainConvertPoliciesToUsage(pInfo->pPolicy,
                    &pInfo->dwFlags, &pInfo->pUsage);
        } else if (CHAIN_APP_INDEX == i) {
            pExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                cExt, rgExt);
            if (pExt) {
                pInfo->pUsage =
                    (PCERT_ENHKEY_USAGE) ChainAllocAndDecodeObject(
                        X509_ENHANCED_KEY_USAGE,
                        pExt->Value.pbData,
                        pExt->Value.cbData
                        );

                if (NULL == pInfo->pUsage)
                    pInfo->dwFlags |= CHAIN_INVALID_POLICY_FLAG;
                else
                    ChainProcessSpecialOrDuplicateOIDsInUsage(
                        &pInfo->pUsage, &pInfo->dwFlags);
            }
        }

        pExt = CertFindExtension(
            CHAIN_ISS_INDEX == i ?
                szOID_POLICY_MAPPINGS : szOID_APPLICATION_POLICY_MAPPINGS,
            cExt, rgExt);
        if (pExt) {
            pInfo->pMappings =
                (PCERT_POLICY_MAPPINGS_INFO) ChainAllocAndDecodeObject(
                    X509_POLICY_MAPPINGS,
                    pExt->Value.pbData,
                    pExt->Value.cbData
                    );

            if (NULL == pInfo->pMappings)
                pInfo->dwFlags |= CHAIN_INVALID_POLICY_FLAG;
            else
                ChainRemoveDuplicatePolicyMappings(pInfo->pMappings);
        }

        pExt = CertFindExtension(
            CHAIN_ISS_INDEX == i ?
                szOID_POLICY_CONSTRAINTS : szOID_APPLICATION_POLICY_CONSTRAINTS,
            cExt, rgExt);
        if (pExt) {
            pInfo->pConstraints =
                (PCERT_POLICY_CONSTRAINTS_INFO) ChainAllocAndDecodeObject(
                    X509_POLICY_CONSTRAINTS,
                    pExt->Value.pbData,
                    pExt->Value.cbData
                    );

            if (NULL == pInfo->pConstraints)
                pInfo->dwFlags |= CHAIN_INVALID_POLICY_FLAG;
        }
    }

    cbData = 0;
    if (CertGetCertificateContextProperty(
            pCertContext,
            CERT_ENHKEY_USAGE_PROP_ID,
            NULL,   // pbData
            &cbData
            ) && 0 != cbData) {
        BYTE *pbData;

        pbData = (BYTE *) PkiNonzeroAlloc(cbData);
        if (pbData) {
            if (CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_ENHKEY_USAGE_PROP_ID,
                    pbData,
                    &cbData
                    ))
                pPoliciesInfo->pPropertyUsage =
                    (PCERT_ENHKEY_USAGE) ChainAllocAndDecodeObject(
                        X509_ENHANCED_KEY_USAGE,
                        pbData,
                        cbData
                        );

            PkiFree(pbData);
        }

        if (NULL == pPoliciesInfo->pPropertyUsage)
            pPoliciesInfo->rgIssOrAppInfo[CHAIN_APP_INDEX].dwFlags |=
                CHAIN_INVALID_POLICY_FLAG;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreePoliciesInfo
//
//  Synopsis:   free the policies and usage info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreePoliciesInfo (
    IN OUT PCHAIN_POLICIES_INFO pPoliciesInfo
    )
{
    DWORD i;

    for (i = 0; i < CHAIN_ISS_OR_APP_COUNT; i++ ) {
        PCHAIN_ISS_OR_APP_INFO pInfo = &pPoliciesInfo->rgIssOrAppInfo[i];

        PkiFree(pInfo->pPolicy);
        PkiFree(pInfo->pUsage);
        PkiFree(pInfo->pMappings);
        PkiFree(pInfo->pConstraints);
    }

    PkiFree(pPoliciesInfo->pPropertyUsage);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetBasicConstraintsInfo
//
//  Synopsis:   alloc and return the basic constraints info.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetBasicConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCERT_BASIC_CONSTRAINTS2_INFO *ppInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCERT_BASIC_CONSTRAINTS2_INFO pInfo = NULL;
    PCERT_BASIC_CONSTRAINTS_INFO pLegacyInfo = NULL;

    pExt = CertFindExtension(
        szOID_BASIC_CONSTRAINTS2,
        pCertContext->pCertInfo->cExtension,
        pCertContext->pCertInfo->rgExtension
        );

    if (pExt) {
        pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) ChainAllocAndDecodeObject(
            X509_BASIC_CONSTRAINTS2, 
            pExt->Value.pbData,
            pExt->Value.cbData
            );
        if (NULL == pInfo)
            goto DecodeError;
    } else {
        // Try to find the legacy extension

        pExt = CertFindExtension(
            szOID_BASIC_CONSTRAINTS,
            pCertContext->pCertInfo->cExtension,
            pCertContext->pCertInfo->rgExtension
            );

        if (pExt) {
            pLegacyInfo =
                (PCERT_BASIC_CONSTRAINTS_INFO) ChainAllocAndDecodeObject(
                    X509_BASIC_CONSTRAINTS, 
                    pExt->Value.pbData,
                    pExt->Value.cbData
                    );
            if (NULL == pLegacyInfo)
                goto DecodeError;

            // Convert to new format
            pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO) PkiZeroAlloc(
                sizeof(CERT_BASIC_CONSTRAINTS2_INFO));
            if (NULL == pInfo)
                goto OutOfMemory;

            if (pLegacyInfo->SubjectType.cbData > 0 &&
                    (pLegacyInfo->SubjectType.pbData[0] &
                        CERT_CA_SUBJECT_FLAG)) {
                pInfo->fCA = TRUE;
                pInfo->fPathLenConstraint = pLegacyInfo->fPathLenConstraint;
                pInfo->dwPathLenConstraint = pLegacyInfo->dwPathLenConstraint;
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    if (pLegacyInfo)
        PkiFree(pLegacyInfo);
    *ppInfo = pInfo;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
TRACE_ERROR(OutOfMemory)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeBasicConstraintsInfo
//
//  Synopsis:   free the basic constraints info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeBasicConstraintsInfo (
    IN OUT PCERT_BASIC_CONSTRAINTS2_INFO pInfo
    )
{
    PkiFree(pInfo);
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetKeyUsage
//
//  Synopsis:   alloc and return the key usage.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetKeyUsage (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCRYPT_BIT_BLOB *ppKeyUsage
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCRYPT_BIT_BLOB pKeyUsage = NULL;

    pExt = CertFindExtension(
        szOID_KEY_USAGE,
        pCertContext->pCertInfo->cExtension,
        pCertContext->pCertInfo->rgExtension
        );

    if (pExt) {
        pKeyUsage = (PCRYPT_BIT_BLOB) ChainAllocAndDecodeObject(
            X509_KEY_USAGE, 
            pExt->Value.pbData,
            pExt->Value.cbData
            );
        if (NULL == pKeyUsage)
            goto DecodeError;
    }

    fResult = TRUE;
CommonReturn:
    *ppKeyUsage = pKeyUsage;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeKeyUsage
//
//  Synopsis:   free the key usage
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeKeyUsage (
    IN OUT PCRYPT_BIT_BLOB pKeyUsage
    )
{
    PkiFree(pKeyUsage);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetSelfSignedStatus
//
//  Synopsis:   return status bits specifying if the certificate is self signed
//              and if so, if it is signature valid
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetSelfSignedStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERTOBJECT pCertObject,
    IN OUT DWORD *pdwIssuerStatusFlags
    )
{
    DWORD dwInfoStatus = 0;

    // If the certificate has an AKI, then, ignore name matching

    if (ChainGetMatchInfoStatus(pCertObject, pCertObject, &dwInfoStatus) &&
            (CERT_TRUST_HAS_NAME_MATCH_ISSUER != dwInfoStatus)) {

        *pdwIssuerStatusFlags |= CERT_ISSUER_SELF_SIGNED_FLAG;

        if (CryptVerifyCertificateSignatureEx(
                NULL,                   // hCryptProv
                X509_ASN_ENCODING,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pCertObject->CertContext(),
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pCertObject->CertContext(),
                0,                      // dwFlags
                NULL                    // pvReserved
                ))
            *pdwIssuerStatusFlags |= CERT_ISSUER_VALID_SIGNATURE_FLAG;

        CertPerfIncrementChainVerifyCertSignatureCount();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetRootStoreStatus
//
//  Synopsis:   determine if the certificate with the given hash is in the
//              root store
//
//  Assumption: Chain engine is locked once in the calling thread.
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetRootStoreStatus (
    IN HCERTSTORE hRoot,
    IN HCERTSTORE hRealRoot,
    IN BYTE rgbCertHash[ CHAINHASHLEN ],
    IN OUT DWORD *pdwIssuerStatusFlags
    )
{
    CRYPT_HASH_BLOB HashBlob;
    PCCERT_CONTEXT pCertContext;

    HashBlob.cbData = CHAINHASHLEN;
    HashBlob.pbData = rgbCertHash;
    pCertContext = CertFindCertificateInStore(
                       hRoot,
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       0,
                       CERT_FIND_MD5_HASH,
                       (LPVOID) &HashBlob,
                       NULL
                       );

    if ( pCertContext )
    {
        CertFreeCertificateContext( pCertContext );

        if ( hRoot == hRealRoot )
        {
            *pdwIssuerStatusFlags |= CERT_ISSUER_TRUSTED_ROOT_FLAG;
            return;
        }

        pCertContext = CertFindCertificateInStore(
                           hRealRoot,
                           X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           0,
                           CERT_FIND_MD5_HASH,
                           (LPVOID) &HashBlob,
                           NULL
                           );

        if ( pCertContext )
        {
            CertFreeCertificateContext( pCertContext );
            *pdwIssuerStatusFlags |= CERT_ISSUER_TRUSTED_ROOT_FLAG;
        }
    }
}


//+===========================================================================
//  CCertObjectCache helper functions
//============================================================================


//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertificateObjectCache
//
//  Synopsis:   create certificate object cache object
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCertificateObjectCache (
     IN DWORD MaxIndexEntries,
     OUT PCCERTOBJECTCACHE* ppCertObjectCache
     )
{
    BOOL              fResult = FALSE;
    PCCERTOBJECTCACHE pCertObjectCache = NULL;

    pCertObjectCache = new CCertObjectCache( MaxIndexEntries, fResult );
    if ( pCertObjectCache != NULL )
    {
        if ( fResult == TRUE )
        {
            *ppCertObjectCache = pCertObjectCache;
        }
        else
        {
            delete pCertObjectCache;
        }
    }
    else
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCertificateObjectCache
//
//  Synopsis:   free the certificate object cache object
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCertificateObjectCache (
     IN PCCERTOBJECTCACHE pCertObjectCache
     )
{
    delete pCertObjectCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheOnRemovalFromPrimaryIndex
//
//  Synopsis:   removes the cert object from all other indexes and also
//              removes the reference on the cert object.
//
//----------------------------------------------------------------------------
VOID WINAPI
CertObjectCacheOnRemovalFromPrimaryIndex (
    IN LPVOID pv,
    IN OPTIONAL LPVOID pvRemovalContext
    )
{
    PCCERTOBJECT pCertObject = (PCCERTOBJECT) pv;

    I_CryptRemoveLruEntry(
           pCertObject->IdentifierIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->SubjectNameIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->KeyIdIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    I_CryptRemoveLruEntry(
           pCertObject->PublicKeyHashIndexEntry(),
           LRU_SUPPRESS_REMOVAL_NOTIFICATION,
           NULL
           );

    pCertObject->Release();

    CertPerfDecrementChainCertCacheCount();
}


//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheOnRemovalFromEndHashIndex
//
//  Synopsis:   removes the reference on the end cert object.
//
//----------------------------------------------------------------------------
VOID WINAPI
CertObjectCacheOnRemovalFromEndHashIndex (
    IN LPVOID pv,
    IN LPVOID pvRemovalContext
    )
{
    PCCERTOBJECT pCertObject = (PCCERTOBJECT) pv;

    pCertObject->Release();

    CertPerfDecrementChainCertCacheCount();
}


//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheHashMd5Identifier
//
//  Synopsis:   DWORD hash an MD5 identifier.  This is done by taking the
//              first four bytes of the MD5 hash since there is enough
//              randomness already
//
//----------------------------------------------------------------------------
DWORD WINAPI
CertObjectCacheHashMd5Identifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    )
{
    if ( sizeof(DWORD) > pIdentifier->cbData )
    {
        return 0;
    }
    else
    {
        return( *( (DWORD UNALIGNED *)pIdentifier->pbData ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CertObjectCacheHashNameIdentifier
//
//  Synopsis:   DWORD hash a subject or issuer name.
//
//----------------------------------------------------------------------------
DWORD WINAPI
CertObjectCacheHashNameIdentifier (
    IN PCRYPT_DATA_BLOB pIdentifier
    )
{
    DWORD  dwHash = 0;
    DWORD  cb = pIdentifier->cbData;
    LPBYTE pb = pIdentifier->pbData;

    while ( cb-- )
    {
        if ( dwHash & 0x80000000 )
        {
            dwHash = ( dwHash << 1 ) | 1;
        }
        else
        {
            dwHash = dwHash << 1;
        }

        dwHash += *pb++;
    }

    return( dwHash );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCertificateObjectIdentifier
//
//  Synopsis:   create an object identifier given the issuer name and serial
//              number.  This is done using an MD5 hash over the content
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainCreateCertificateObjectIdentifier (
     IN PCERT_NAME_BLOB pIssuer,
     IN PCRYPT_INTEGER_BLOB pSerialNumber,
     OUT CERT_OBJECT_IDENTIFIER ObjectIdentifier
     )
{
    MD5_CTX md5ctx;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pIssuer->pbData, pIssuer->cbData );
    MD5Update( &md5ctx, pSerialNumber->pbData, pSerialNumber->cbData );

    MD5Final( &md5ctx );

    assert(CHAINHASHLEN == MD5DIGESTLEN);

    memcpy( ObjectIdentifier, md5ctx.digest, CHAINHASHLEN );
}


//+===========================================================================
//  CChainPathObject helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreatePathObject
//
//  Synopsis:   create a path object, note since it is a ref-counted
//              object, freeing occurs by doing a pCertObject->Release
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreatePathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCERTOBJECT pCertObject,
     IN OPTIONAL HCERTSTORE hAdditionalStore,
     OUT PCCHAINPATHOBJECT *ppPathObject
     )
{
    BOOL fResult = TRUE;
    BOOL fAddedToCreationCache = TRUE;
    PCCHAINPATHOBJECT pPathObject = NULL;

    pPathObject = pCallContext->FindPathObjectInCreationCache(
        pCertObject->CertHash() );
    if ( pPathObject != NULL )
    {
        *ppPathObject = pPathObject;
        return( TRUE );
    }

    pPathObject = new CChainPathObject(
                           pCallContext,
                           FALSE,                   // fCyclic
                           (LPVOID) pCertObject,
                           hAdditionalStore,
                           fResult,
                           fAddedToCreationCache
                           );

    if ( pPathObject != NULL )
    {
        if (!fResult) {
            if (!fAddedToCreationCache)
            {
                delete pPathObject;
            }
            pPathObject = NULL;
        }
    }
    else
    {
        fResult = FALSE;
    }

    *ppPathObject = pPathObject;
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCyclicPathObject
//
//  Synopsis:   create a path object, note since it is a ref-counted
//              object, freeing occurs by doing a pCertObject->Release
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCyclicPathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PCCHAINPATHOBJECT pPathObject,
     OUT PCCHAINPATHOBJECT *ppCyclicPathObject
     )
{
    BOOL fResult = TRUE;
    BOOL fAddedToCreationCache = TRUE;
    PCCHAINPATHOBJECT pCyclicPathObject = NULL;

    pCyclicPathObject = new CChainPathObject(
                           pCallContext,
                           TRUE,                    // fCyclic
                           (LPVOID) pPathObject,
                           NULL,                    // hAdditionalStore
                           fResult,
                           fAddedToCreationCache
                           );

    if ( pCyclicPathObject != NULL )
    {
        if (!fResult) {
            if (!fAddedToCreationCache) {
                delete pCyclicPathObject;
            }
            pCyclicPathObject = NULL;
        }
    }
    else
    {
        fResult = FALSE;
    }

    *ppCyclicPathObject = pCyclicPathObject;
    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainDeleteCyclicPathObject
//
//  Synopsis:   delete a previously created cyclic path object.
//              Also, remove the creation cache.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainDeleteCyclicPathObject (
     IN PCCHAINCALLCONTEXT pCallContext,
     IN OUT PCCHAINPATHOBJECT pCyclicPathObject
     )
{
    pCallContext->RemovePathObjectFromCreationCache(pCyclicPathObject);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocAndCopyOID
//
//  Synopsis:   allocate and copy OID
//
//----------------------------------------------------------------------------
LPSTR WINAPI
ChainAllocAndCopyOID (
     IN LPSTR pszSrcOID
     )
{
    DWORD cchOID;
    LPSTR pszDstOID;

    cchOID = strlen(pszSrcOID) + 1;
    pszDstOID = (LPSTR) PkiNonzeroAlloc(cchOID);
    if (NULL == pszDstOID)
        return NULL;

    memcpy(pszDstOID, pszSrcOID, cchOID);
    return pszDstOID;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeOID
//
//  Synopsis:   free allocated OID
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeOID (
     IN OUT LPSTR pszOID
     )
{
    PkiFree(pszOID);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocAndCopyUsage
//
//  Synopsis:   allocates and copies usage OIDs.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainAllocAndCopyUsage (
     IN PCERT_ENHKEY_USAGE pSrcUsage,
     OUT PCERT_ENHKEY_USAGE *ppDstUsage
     )
{
    BOOL fResult;
    PCERT_ENHKEY_USAGE pDstUsage = NULL;
    DWORD cOID;
    LPSTR *ppszDstOID;
    DWORD i;

    if (NULL == pSrcUsage)
        goto SuccessReturn;

    cOID = pSrcUsage->cUsageIdentifier;

    pDstUsage = (PCERT_ENHKEY_USAGE) PkiZeroAlloc(
        sizeof(CERT_ENHKEY_USAGE) + sizeof(LPSTR) * cOID);
    if (NULL == pDstUsage)
        goto OutOfMemory;

    ppszDstOID = (LPSTR *) &pDstUsage[1];

    pDstUsage->cUsageIdentifier = cOID;
    pDstUsage->rgpszUsageIdentifier = ppszDstOID;

    for (i = 0; i < cOID; i++) {
        ppszDstOID[i] =
            ChainAllocAndCopyOID(pSrcUsage->rgpszUsageIdentifier[i]);
        if (NULL == ppszDstOID[i])
            goto OutOfMemory;
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *ppDstUsage = pDstUsage;
    return fResult;

ErrorReturn:
    if (pDstUsage) {
        ChainFreeUsage(pDstUsage);
        pDstUsage = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeUsage
//
//  Synopsis:   frees usage OIDs allocated by ChainAllocAndCopyUsage
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeUsage (
     IN OUT PCERT_ENHKEY_USAGE pUsage
     )
{
    if (pUsage) {
        DWORD cOID = pUsage->cUsageIdentifier;
        LPSTR *ppszOID = pUsage->rgpszUsageIdentifier;
        DWORD i;

        for (i = 0; i < cOID; i++)
            ChainFreeOID(ppszOID[i]);

        PkiFree(pUsage);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsOIDInUsage
//
//  Synopsis:   returns TRUE if the OID is in the usage
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsOIDInUsage (
    IN LPSTR pszOID,
    IN PCERT_ENHKEY_USAGE pUsage
    )
{
    DWORD cOID;
    DWORD i;

    assert(pUsage);

    cOID = pUsage->cUsageIdentifier;
    for (i = 0; i < cOID; i++){
        if (0 == strcmp(pszOID, pUsage->rgpszUsageIdentifier[i]))
            return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIntersectUsages
//
//  Synopsis:   returns the intersection of the two usages
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainIntersectUsages (
    IN PCERT_ENHKEY_USAGE pCertUsage,
    IN OUT PCERT_ENHKEY_USAGE pRestrictedUsage
    )
{
    LPSTR *ppszOID;
    DWORD cOID;
    DWORD i;
    
    cOID = pRestrictedUsage->cUsageIdentifier;
    ppszOID = pRestrictedUsage->rgpszUsageIdentifier;
    i = 0;
    while (i < cOID) {
        if (ChainIsOIDInUsage(ppszOID[i], pCertUsage))
            i++;
        else {
            // Remove the OID string and move the remaining
            // strings up one.
            DWORD j;

            ChainFreeOID(ppszOID[i]);

            for (j = i; j + 1 < cOID; j++)
                ppszOID[j] = ppszOID[j + 1];

            cOID--;
            pRestrictedUsage->cUsageIdentifier = cOID;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeAndClearRestrictedUsageInfo
//
//  Synopsis:   frees allocated restricted usage info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeAndClearRestrictedUsageInfo(
    IN OUT PCHAIN_RESTRICTED_USAGE_INFO pInfo
    )
{
    ChainFreeUsage(pInfo->pIssuanceRestrictedUsage);
    ChainFreeUsage(pInfo->pIssuanceMappedUsage);
    PkiFree(pInfo->rgdwIssuanceMappedIndex);
    // fRequireIssuancePolicy

    ChainFreeUsage(pInfo->pApplicationRestrictedUsage);
    ChainFreeUsage(pInfo->pApplicationMappedUsage);
    PkiFree(pInfo->rgdwApplicationMappedIndex);

    ChainFreeUsage(pInfo->pPropertyRestrictedUsage);

    memset(pInfo, 0, sizeof(*pInfo));
}
    
//+---------------------------------------------------------------------------
//
//  Function:   ChainCalculateRestrictedUsage
//
//  Synopsis:   update the restricted and mapped usage using the cert's
//              usage and optional policy mappings
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCalculateRestrictedUsage (
    IN PCERT_ENHKEY_USAGE pCertUsage,
    IN OPTIONAL PCERT_POLICY_MAPPINGS_INFO pMappings,
    IN OUT PCERT_ENHKEY_USAGE *ppRestrictedUsage,
    IN OUT PCERT_ENHKEY_USAGE *ppMappedUsage,
    IN OUT LPDWORD *ppdwMappedIndex
    )
{
    BOOL fResult;
    PCERT_ENHKEY_USAGE pNewMappedUsage = NULL;
    LPDWORD pdwNewMappedIndex = NULL;

    if (pCertUsage) {
        if (NULL == *ppRestrictedUsage) {
            // Top most, first certificate with a usage restriction

            assert(NULL == *ppMappedUsage);
            assert(NULL == *ppdwMappedIndex);

            if (!ChainAllocAndCopyUsage(pCertUsage, ppRestrictedUsage))
                goto AllocAndCopyUsageError;
        } else {
            PCERT_ENHKEY_USAGE pRestrictedUsage = *ppRestrictedUsage;
            PCERT_ENHKEY_USAGE pMappedUsage = *ppMappedUsage;
            
            if (NULL == pMappedUsage) {
                // Take the intersection of the restricted and cert's
                // usage

                ChainIntersectUsages(pCertUsage, pRestrictedUsage);

            } else {
                // Take the intersection of the mapped and cert's
                // usage. If removed from the mapped usage,
                // we might also need to remove from the restricted usage.

                LPDWORD pdwMappedIndex = *ppdwMappedIndex;
                LPSTR *ppszOID;
                DWORD cOID;
                DWORD i;

                assert(pdwMappedIndex);

                cOID = pMappedUsage->cUsageIdentifier;
                ppszOID = pMappedUsage->rgpszUsageIdentifier;
                i = 0;
                while (i < cOID) {
                    if (ChainIsOIDInUsage(ppszOID[i], pCertUsage))
                        i++;
                    else {
                        // If no other mappings to the restricted OID, then,
                        // remove the restricted OID.

                        DWORD j;
                        BOOL fRemoveRestricted;

                        if ((0 == i ||
                                pdwMappedIndex[i - 1] != pdwMappedIndex[i])
                                            &&
                            (i + 1 == cOID ||
                                pdwMappedIndex[i] != pdwMappedIndex[i + 1])) {
                            // Remove the restricted OID we are mapped to.

                            LPSTR *ppszRestrictedOID =
                                pRestrictedUsage->rgpszUsageIdentifier;
                            DWORD cRestrictedOID = 
                                pRestrictedUsage->cUsageIdentifier;

                            fRemoveRestricted = TRUE;

                            j = pdwMappedIndex[i];
                            assert(j < cRestrictedOID);

                            if (j < cRestrictedOID)
                                ChainFreeOID(ppszRestrictedOID[j]);

                            for ( ; j + 1 < cRestrictedOID; j++)
                                ppszRestrictedOID[j] = ppszRestrictedOID[j + 1];

                            cRestrictedOID--;
                            pRestrictedUsage->cUsageIdentifier =
                                cRestrictedOID;
                        } else
                            fRemoveRestricted = FALSE;

                        // Remove the OID string and mapped index. Move the
                        // remaining strings and indices up one.
                        ChainFreeOID(ppszOID[i]);

                        for (j = i; j + 1 < cOID; j++) {
                            ppszOID[j] = ppszOID[j + 1];
                            pdwMappedIndex[j] = pdwMappedIndex[j + 1];
                            if (fRemoveRestricted) {
                                assert(0 < pdwMappedIndex[j]);
                                pdwMappedIndex[j] -= 1;
                                
                            }
                        }

                        cOID--;
                        pMappedUsage->cUsageIdentifier = cOID;
                    }
                }
            }
        }
    }
    // else
    //  No restrictions added by certificate


    if (pMappings) {
        PCERT_ENHKEY_USAGE pRestrictedUsage = *ppRestrictedUsage;
        PCERT_ENHKEY_USAGE pMappedUsage = *ppMappedUsage;

        if (NULL == pRestrictedUsage ||
                0 == pRestrictedUsage->cUsageIdentifier) {
            // Nothing to be mapped.
            assert(NULL == pMappedUsage ||
                0 == pMappedUsage->cUsageIdentifier);
        } else {
            LPDWORD pdwMappedIndex;
            PCERT_ENHKEY_USAGE pSrcUsage;
            LPSTR *ppszSrcOID;
            DWORD cSrcOID;
            DWORD iSrc;

            DWORD cMap;
            PCERT_POLICY_MAPPING pMap;

            DWORD cNewOID;
            LPSTR *ppszNewOID;

            if (pMappedUsage) {
                // Subsequent mapping
                assert(0 < pMappedUsage->cUsageIdentifier);
                pSrcUsage = pMappedUsage;
                pdwMappedIndex = *ppdwMappedIndex;
                assert(pdwMappedIndex);
            } else {
                // First mapping
                pSrcUsage = pRestrictedUsage;
                pdwMappedIndex = NULL;
            }

            cSrcOID = pSrcUsage->cUsageIdentifier;
            ppszSrcOID = pSrcUsage->rgpszUsageIdentifier;

            cMap = pMappings->cPolicyMapping;
            pMap = pMappings->rgPolicyMapping;

            // Note, all duplicates have been remove from usage and
            // mappings
            cNewOID = cSrcOID + cMap;

            pNewMappedUsage = (PCERT_ENHKEY_USAGE) PkiZeroAlloc(
                sizeof(CERT_ENHKEY_USAGE) + sizeof(LPSTR) * cNewOID);
            if (NULL == pNewMappedUsage)
                goto OutOfMemory;

            ppszNewOID = (LPSTR *) &pNewMappedUsage[1];
            pNewMappedUsage->cUsageIdentifier = cNewOID;
            pNewMappedUsage->rgpszUsageIdentifier = ppszNewOID;

            pdwNewMappedIndex = (LPDWORD) PkiZeroAlloc(
                sizeof(DWORD) * cNewOID);
            if (NULL == pdwNewMappedIndex)
                goto OutOfMemory;

            cNewOID = 0;
            for (iSrc = 0; iSrc < cSrcOID; iSrc++) {
                DWORD iMap;
                BOOL fMapped = FALSE;

                for (iMap = 0; iMap < cMap; iMap++) {
                    if (0 == strcmp(ppszSrcOID[iSrc],
                            pMap[iMap].pszIssuerDomainPolicy)) {
                        assert(cNewOID < pNewMappedUsage->cUsageIdentifier);

                        ppszNewOID[cNewOID] = ChainAllocAndCopyOID(
                            pMap[iMap].pszSubjectDomainPolicy);
                        if (NULL == ppszNewOID[cNewOID])
                            goto OutOfMemory;

                        if (pdwMappedIndex)
                            pdwNewMappedIndex[cNewOID] = pdwMappedIndex[iSrc];
                        else
                            pdwNewMappedIndex[cNewOID] = iSrc;
                        cNewOID++;
                        fMapped = TRUE;
                    }
                }

                if (!fMapped) {
                    assert(cNewOID < pNewMappedUsage->cUsageIdentifier);

                    ppszNewOID[cNewOID] =
                        ChainAllocAndCopyOID(ppszSrcOID[iSrc]);
                    if (NULL == ppszNewOID[cNewOID])
                        goto OutOfMemory;
                    if (pdwMappedIndex)
                        pdwNewMappedIndex[cNewOID] = pdwMappedIndex[iSrc];
                    else
                        pdwNewMappedIndex[cNewOID] = iSrc;

                    cNewOID++;

                }
            }

            assert(cNewOID >= cSrcOID);
            pNewMappedUsage->cUsageIdentifier = cNewOID;

            if (pMappedUsage) {
                ChainFreeUsage(pMappedUsage);
                PkiFree(pdwMappedIndex);
            }

            *ppMappedUsage = pNewMappedUsage;
            *ppdwMappedIndex = pdwNewMappedIndex;

        }
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    ChainFreeUsage(pNewMappedUsage);
    PkiFree(pdwNewMappedIndex);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AllocAndCopyUsageError)
TRACE_ERROR(OutOfMemory)
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetUsageStatus
//
//  Synopsis:   get the usage status
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetUsageStatus (
     IN PCERT_ENHKEY_USAGE pRequestedUsage,
     IN PCERT_ENHKEY_USAGE pAvailableUsage,
     IN DWORD dwMatchType,
     IN OUT PCERT_TRUST_STATUS pStatus
     )
{
    DWORD cRequested;
    DWORD cAvailable;
    DWORD cFound;
    BOOL  fFound;

    if ( pAvailableUsage == NULL )
    {
        return;
    }

    if ( ( pRequestedUsage->cUsageIdentifier >
           pAvailableUsage->cUsageIdentifier ) &&
         ( dwMatchType == USAGE_MATCH_TYPE_AND ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
        return;
    }

    for ( cRequested = 0, cFound = 0;
          cRequested < pRequestedUsage->cUsageIdentifier;
          cRequested++ )
    {
        for ( cAvailable = 0, fFound = FALSE;
              ( cAvailable < pAvailableUsage->cUsageIdentifier ) &&
              ( fFound == FALSE );
              cAvailable++ )
        {
            // NOTE: Optimize compares of OIDs.  Perhaps with a different
            //       encoding
            if ( strcmp(
                    pRequestedUsage->rgpszUsageIdentifier[ cRequested ],
                    pAvailableUsage->rgpszUsageIdentifier[ cAvailable ]
                    ) == 0 )
            {
                fFound = TRUE;
            }
        }

        if ( fFound == TRUE )
        {
            cFound += 1;
        }
    }

    if ( ( dwMatchType == USAGE_MATCH_TYPE_AND ) &&
         ( cFound != pRequestedUsage->cUsageIdentifier ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    }
    else if ( ( dwMatchType == USAGE_MATCH_TYPE_OR ) &&
              ( cFound == 0 ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainOrInStatusBits
//
//  Synopsis:   bit or in the status bits from the source into the destination
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainOrInStatusBits (
     IN PCERT_TRUST_STATUS pDestStatus,
     IN PCERT_TRUST_STATUS pSourceStatus
     )
{
    pDestStatus->dwErrorStatus |= pSourceStatus->dwErrorStatus;
    pDestStatus->dwInfoStatus |= pSourceStatus->dwInfoStatus;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetMatchInfoStatus
//
//  Synopsis:   return the info status used to match the issuer
//
//              For a match returns TRUE, where dwInfoStatus can be
//              one of the following:
//               - CERT_TRUST_HAS_EXACT_MATCH_ISSUER |
//                      CERT_TRUST_HAS_PREFERRED_ISSUER
//               - CERT_TRUST_HAS_KEY_MATCH_ISSUER |
//                      CERT_TRUST_HAS_PREFERRED_ISSUER
//               - CERT_TRUST_HAS_KEY_MATCH_ISSUER (nonmatching AKI exact match)
//               - CERT_TRUST_HAS_NAME_MATCH_ISSUER |
//                      CERT_TRUST_HAS_PREFERRED_ISSUER
//               - CERT_TRUST_HAS_NAME_MATCH_ISSUER (nonmatching AKI)
//
//              For no match returns FALSE with dwInfoStatus set to the
//              following:
//               - CERT_TRUST_HAS_KEY_MATCH_ISSUER
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetMatchInfoStatus (
    IN PCCERTOBJECT pIssuerObject,
    IN PCCERTOBJECT pSubjectObject,
    IN OUT DWORD *pdwInfoStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwInfoStatus = 0;
    DWORD dwPreferredStatus = CERT_TRUST_HAS_PREFERRED_ISSUER;

    PCERT_INFO pSubjectInfo = pSubjectObject->CertContext()->pCertInfo;
    PCERT_AUTHORITY_KEY_ID_INFO pAKI = pSubjectObject->AuthorityKeyIdentifier();
    PCERT_INFO pIssuerInfo = pIssuerObject->CertContext()->pCertInfo;

    if (pAKI) {
        if ( ( pAKI->CertIssuer.cbData != 0 ) &&
             ( pAKI->CertSerialNumber.cbData != 0 ) )
        {
            DWORD cbAuthIssuerName;
            LPBYTE pbAuthIssuerName;
            DWORD cbAuthSerialNumber;
            LPBYTE pbAuthSerialNumber;

            cbAuthIssuerName = pAKI->CertIssuer.cbData;
            pbAuthIssuerName = pAKI->CertIssuer.pbData;
            cbAuthSerialNumber = pAKI->CertSerialNumber.cbData;
            pbAuthSerialNumber = pAKI->CertSerialNumber.pbData;

            if ( ( cbAuthIssuerName == pIssuerInfo->Issuer.cbData ) &&
                 ( memcmp(
                      pbAuthIssuerName,
                      pIssuerInfo->Issuer.pbData,
                      cbAuthIssuerName
                      ) == 0 ) &&
                 ( cbAuthSerialNumber == pIssuerInfo->SerialNumber.cbData ) &&
                 ( memcmp(
                      pbAuthSerialNumber,
                      pIssuerInfo->SerialNumber.pbData,
                      cbAuthSerialNumber
                      ) == 0 ) )
            {
                dwInfoStatus = CERT_TRUST_HAS_EXACT_MATCH_ISSUER |
                    CERT_TRUST_HAS_PREFERRED_ISSUER;
                goto SuccessReturn;
            } else {
                // Doesn't have preferred match
                dwPreferredStatus = 0;
            }
        }

        if ( pAKI->KeyId.cbData != 0 )
        {
            DWORD cbAuthKeyIdentifier;
            LPBYTE pbAuthKeyIdentifier;
            DWORD cbIssuerKeyIdentifier;
            LPBYTE pbIssuerKeyIdentifier;

            cbAuthKeyIdentifier = pAKI->KeyId.cbData;
            pbAuthKeyIdentifier = pAKI->KeyId.pbData;
            cbIssuerKeyIdentifier = pIssuerObject->KeyIdentifierSize();
            pbIssuerKeyIdentifier = pIssuerObject->KeyIdentifier();

            if ( ( cbAuthKeyIdentifier == cbIssuerKeyIdentifier ) &&
                 ( memcmp(
                      pbAuthKeyIdentifier,
                      pbIssuerKeyIdentifier,
                      cbAuthKeyIdentifier
                      ) == 0 ) )
            {
                dwInfoStatus = dwPreferredStatus |
                    CERT_TRUST_HAS_KEY_MATCH_ISSUER;
                goto SuccessReturn;
            } else {
                // Doesn't have preferred match
                dwPreferredStatus = 0;
            }
        }
    }

    if ( ( pSubjectInfo->Issuer.cbData == pIssuerInfo->Subject.cbData ) &&
         ( pSubjectInfo->Issuer.cbData != 0) &&
         ( memcmp(
              pSubjectInfo->Issuer.pbData,
              pIssuerInfo->Subject.pbData,
              pIssuerInfo->Subject.cbData
              ) == 0 ) )
    {
        dwInfoStatus = dwPreferredStatus | CERT_TRUST_HAS_NAME_MATCH_ISSUER;
        goto SuccessReturn;
    }


    // Default to nonPreferred public key match
    dwInfoStatus = CERT_TRUST_HAS_KEY_MATCH_ISSUER;
    goto ErrorReturn;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *pdwInfoStatus |= dwInfoStatus;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetMatchInfoStatusForNoIssuer
//
//  Synopsis:   return the info status when unable to find our issuer
//
//----------------------------------------------------------------------------
DWORD WINAPI
ChainGetMatchInfoStatusForNoIssuer (
    IN DWORD dwIssuerMatchFlags
    )
{
    if (dwIssuerMatchFlags & CERT_EXACT_ISSUER_MATCH_FLAG)
        return CERT_TRUST_HAS_EXACT_MATCH_ISSUER;
    else if (dwIssuerMatchFlags & CERT_KEYID_ISSUER_MATCH_TYPE)
        return CERT_TRUST_HAS_KEY_MATCH_ISSUER;
    else
        return CERT_TRUST_HAS_NAME_MATCH_ISSUER;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsValidPubKeyMatchForIssuer
//
//  Synopsis:   returns TRUE if the issuer matches more than just the
//              public key match criteria
//
//              This logic is mainly here to handle tstore2.exe and regress.bat
//              which has end, CA and root certificates using the same
//              public key.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsValidPubKeyMatchForIssuer (
    IN PCCERTOBJECT pIssuer,
    IN PCCERTOBJECT pSubject
    )
{
    BOOL fResult = TRUE;
    BOOL fCheckMatchInfo;
    PCERT_BASIC_CONSTRAINTS2_INFO pIssuerBasicConstraints;

    fCheckMatchInfo = FALSE;

    // Check if the issuer has a basic constraints extension. If it does
    // and it isn't a CA, then, we will need to do an additional issuer match.

    pIssuerBasicConstraints = pIssuer->BasicConstraintsInfo();
    if (pIssuerBasicConstraints && !pIssuerBasicConstraints->fCA)
        fCheckMatchInfo = TRUE;
    else {
        // Check if the issuer has the same public key as the subject. If it
        // does, then, will need to do an additional issuer match.

        BYTE *pbIssuerPublicKeyHash;
        BYTE *pbSubjectPublicKeyHash;

        pbIssuerPublicKeyHash = pIssuer->PublicKeyHash();
        pbSubjectPublicKeyHash = pSubject->PublicKeyHash();
        if (0 == memcmp(pbIssuerPublicKeyHash, pbSubjectPublicKeyHash,
                CHAINHASHLEN))
            fCheckMatchInfo = TRUE;
    }

    if (fCheckMatchInfo) {
        // Check that the issuer matches the subject's AKI or subject's
        // issuer name.

        DWORD dwInfoStatus = 0;

        // Following returns FALSE if only has the public key match
        fResult = ChainGetMatchInfoStatus(pIssuer, pSubject, &dwInfoStatus);
    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetSubjectStatus
//
//  Synopsis:   get the subject status bits by checking the time nesting and
//              signature validity
//
//              For CERT_END_OBJECT_TYPE or CERT_EXTERNAL_ISSUER_OBJECT_TYPE
//              CCertObject types, leaves the engine's critical section to
//              verify the signature. If the engine was touched by another
//              thread, it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetSubjectStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCHAINPATHOBJECT pIssuerPathObject,
    IN PCCHAINPATHOBJECT pSubjectPathObject,
    IN OUT PCERT_TRUST_STATUS pStatus
    )
{
    BOOL fResult;

    PCCERTOBJECT pIssuerObject = pIssuerPathObject->CertObject();
    PCCERTOBJECT pSubjectObject = pSubjectPathObject->CertObject();
    PCCERT_CONTEXT pIssuerContext = pIssuerObject->CertContext();
    PCCERT_CONTEXT pSubjectContext = pSubjectObject->CertContext();

    DWORD dwIssuerStatusFlags;

    ChainGetMatchInfoStatus(
        pIssuerObject,
        pSubjectObject,
        &pStatus->dwInfoStatus
        );

    dwIssuerStatusFlags = pSubjectObject->IssuerStatusFlags();
    if (!(dwIssuerStatusFlags & CERT_ISSUER_VALID_SIGNATURE_FLAG)) {
        DWORD dwObjectType;

        dwObjectType = pSubjectObject->ObjectType();
        if (CERT_END_OBJECT_TYPE == dwObjectType ||
                CERT_EXTERNAL_ISSUER_OBJECT_TYPE == dwObjectType)
            pCallContext->ChainEngine()->UnlockEngine();

        fResult = CryptVerifyCertificateSignatureEx(
                NULL,                   // hCryptProv
                X509_ASN_ENCODING,
                CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT,
                (void *) pSubjectContext,
                CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                (void *) pIssuerContext,
                0,                      // dwFlags
                NULL                    // pvReserved
                );

        if (CERT_END_OBJECT_TYPE == dwObjectType ||
                CERT_EXTERNAL_ISSUER_OBJECT_TYPE == dwObjectType) {
            pCallContext->ChainEngine()->LockEngine();
            if (pCallContext->IsTouchedEngine())
                goto TouchedDuringSignatureVerification;
        }

        if (!fResult) {
            pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
            pStatus->dwInfoStatus &= ~CERT_TRUST_HAS_PREFERRED_ISSUER;
        } else {
            if (dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG) {
                // Verify the issuer's public key hash
                if (0 != memcmp(pSubjectObject->IssuerPublicKeyHash(),
                        pIssuerObject->PublicKeyHash(), CHAINHASHLEN))
                    dwIssuerStatusFlags &= ~CERT_ISSUER_PUBKEY_FLAG;
            }

            if (!(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG)) {
                CRYPT_DATA_BLOB DataBlob;

                memcpy(pSubjectObject->IssuerPublicKeyHash(),
                    pIssuerObject->PublicKeyHash(), CHAINHASHLEN);
                DataBlob.pbData = pSubjectObject->IssuerPublicKeyHash(),
                DataBlob.cbData = CHAINHASHLEN;
                CertSetCertificateContextProperty(
                    pSubjectContext,
                    CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID,
                    CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                    &DataBlob
                    );
            }

            pSubjectObject->OrIssuerStatusFlags(
                CERT_ISSUER_PUBKEY_FLAG |
                    CERT_ISSUER_VALID_SIGNATURE_FLAG
                );
        }

        CertPerfIncrementChainVerifyCertSignatureCount();
    } else {

        // also need to check public key parameters

        assert(dwIssuerStatusFlags & CERT_ISSUER_PUBKEY_FLAG);
        if (0 != memcmp(pSubjectObject->IssuerPublicKeyHash(),
                    pIssuerObject->PublicKeyHash(), CHAINHASHLEN)) {
            pStatus->dwErrorStatus |= CERT_TRUST_IS_NOT_SIGNATURE_VALID;
            pStatus->dwInfoStatus &= ~CERT_TRUST_HAS_PREFERRED_ISSUER;
        }

        CertPerfIncrementChainCompareIssuerPublicKeyCount();
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(TouchedDuringSignatureVerification, ERROR_CAN_NOT_COMPLETE)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainUpdateSummaryStatusByTrustStatus
//
//  Synopsis:   update the summary status bits given new trust status bits
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainUpdateSummaryStatusByTrustStatus(
     IN OUT PCERT_TRUST_STATUS pSummaryStatus,
     IN PCERT_TRUST_STATUS pTrustStatus
     )
{
    pSummaryStatus->dwErrorStatus |= pTrustStatus->dwErrorStatus;
    pSummaryStatus->dwInfoStatus |=
        pTrustStatus->dwInfoStatus &
            ~(CERT_TRUST_CERTIFICATE_ONLY_INFO_STATUS |
                CERT_TRUST_HAS_PREFERRED_ISSUER);
    if (!(pTrustStatus->dwInfoStatus & CERT_TRUST_HAS_PREFERRED_ISSUER))
        pSummaryStatus->dwInfoStatus &= ~CERT_TRUST_HAS_PREFERRED_ISSUER;

    if (pSummaryStatus->dwErrorStatus &
            CERT_TRUST_ANY_NAME_CONSTRAINT_ERROR_STATUS)
        pSummaryStatus->dwInfoStatus &= ~CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsKeyRolloverSubject
//
//  Synopsis:   a subject is considered to be a key rollover cert if its
//              subject name == issuer name == issuer cert's subject name
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsKeyRolloverSubject(
    IN PCCHAINPATHOBJECT pIssuerPathObject,
    IN PCCHAINPATHOBJECT pSubjectPathObject
    )
{
    PCERT_INFO pIssuerInfo =
        pIssuerPathObject->CertObject()->CertContext()->pCertInfo;
    PCERT_INFO pSubjectInfo =
        pSubjectPathObject->CertObject()->CertContext()->pCertInfo;
    DWORD cbData = pSubjectInfo->Subject.cbData;

    if (0 != cbData &&
            cbData == pSubjectInfo->Issuer.cbData &&
            cbData == pIssuerInfo->Subject.cbData
                        &&
            0 == memcmp(pSubjectInfo->Subject.pbData,
                    pSubjectInfo->Issuer.pbData, cbData)
                        &&
            0 == memcmp(pSubjectInfo->Subject.pbData,
                    pIssuerInfo->Subject.pbData, cbData))
        return TRUE;
    else
        return FALSE;
}


//+===========================================================================
//  Format and append extended error information helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocAndEncodeObject
//
//  Synopsis:   allocate and ASN.1 encodes the data structure.
//
//              PkiFree must be called to free the encoded bytes
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainAllocAndEncodeObject(
    IN LPCSTR lpszStructType,
    IN const void *pvStructInfo,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    return CryptEncodeObjectEx(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        lpszStructType,
        pvStructInfo,
        CRYPT_ENCODE_ALLOC_FLAG,
        &PkiEncodePara,
        (void *) ppbEncoded,
        pcbEncoded
        );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainAppendExtendedErrorInfo
//
//  Synopsis:   PkiReallocate and append an already localization formatted
//              line of extended error information
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainAppendExtendedErrorInfo(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN LPWSTR pwszAppend,
    IN DWORD cchAppend                  // Includes NULL terminator
    )
{
    LPWSTR pwszExtErrorInfo = *ppwszExtErrorInfo;
    DWORD cchExtErrorInfo;

    if (pwszExtErrorInfo)
        cchExtErrorInfo = wcslen(pwszExtErrorInfo);
    else
        cchExtErrorInfo = 0;

    assert(0 < cchAppend);

    if (pwszExtErrorInfo = (LPWSTR) PkiRealloc(pwszExtErrorInfo,
            (cchExtErrorInfo + cchAppend) * sizeof(WCHAR))) {
        memcpy(&pwszExtErrorInfo[cchExtErrorInfo], pwszAppend,
            cchAppend * sizeof(WCHAR));
        *ppwszExtErrorInfo = pwszExtErrorInfo;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainFormatAndAppendExtendedErrorInfo
//
//  Synopsis:   localization format a line of extended error information
//              and append via the above ChainAppendExtendedErrorInfo
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFormatAndAppendExtendedErrorInfo(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN UINT nFormatID,
    ...
    )
{
    DWORD cchMsg = 0;
    LPWSTR pwszMsg = NULL;
    WCHAR wszFormat[256];
    wszFormat[0] = '\0';
    va_list argList;

    // get format string from resources
    if(0 == LoadStringU(g_hChainInst, nFormatID, wszFormat,
            sizeof(wszFormat)/sizeof(wszFormat[0])))
        return;

    __try {

        // format message into requested buffer
        va_start(argList, nFormatID);
        cchMsg = FormatMessageU(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
            wszFormat,
            0,                  // dwMessageId
            0,                  // dwLanguageId
            (LPWSTR) &pwszMsg,
            0,                  // minimum size to allocate
            &argList);

        va_end(argList);

        // Must at least have the L'\n' terminator
        if (1 < cchMsg && pwszMsg)
            ChainAppendExtendedErrorInfo(
                ppwszExtErrorInfo,
                pwszMsg,
                cchMsg + 1
                );

    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if (pwszMsg)
        LocalFree(pwszMsg);
}

//+===========================================================================
//  Name Constraint helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsWhiteSpace
//
//  Synopsis:   returns TRUE for a white space character
//
//----------------------------------------------------------------------------
static inline BOOL ChainIsWhiteSpace(WCHAR wc)
{
    return wc == L' ' || (wc >= 0x09 && wc <= 0x0d);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRemoveLeadingAndTrailingWhiteSpace
//
//  Synopsis:   advances the pointer past any leading white space. Removes
//              any trailing white space by inserting the L'\0' and updating
//              the character count.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainRemoveLeadingAndTrailingWhiteSpace(
    IN LPWSTR pwszIn,
    OUT LPWSTR *ppwszOut,
    OUT DWORD *pcchOut
    )
{
    LPWSTR pwszOut;
    DWORD cchOut;
    WCHAR wc;

    // Remove leading white space
    for (pwszOut = pwszIn ; L'\0' != (wc = *pwszOut); pwszOut++) {
        if (!ChainIsWhiteSpace(wc))
            break;
    }

    for (cchOut = wcslen(pwszOut); 0 < cchOut; cchOut--) {
        if (!ChainIsWhiteSpace(pwszOut[cchOut - 1]))
            break;
    }

    pwszOut[cchOut] = L'\0';
    *ppwszOut = pwszOut;
    *pcchOut = cchOut;
}

#define NO_LOCALE MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsRightStringInString
//
//  Synopsis:   returns TRUE for a case insensitive match of the
//              "Right" string with the right most characters of the
//              string.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsRightStringInString(
    IN LPCWSTR pwszRight,
    IN DWORD cchRight,
    IN LPCWSTR pwszString,
    IN DWORD cchString
    )
{
    if (0 == cchRight)
        return TRUE;
    if (cchRight > cchString)
        return FALSE;

    if (CSTR_EQUAL == CompareStringU(
            NO_LOCALE,
            NORM_IGNORECASE,
            pwszRight,
            cchRight,
            pwszString + (cchString - cchRight),
            cchRight
            ))
        return TRUE;
    else
        return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainIsSpecialAtCharacterMatch
//
//  Synopsis:   returns TRUE if the "Right" string satisfies one of the
//              following conditions:
//               - doesn't contain an "@" (at character)
//               - "@" is the left-most character
//               - "Right" string has the same number of characters as the
//                 string (indicates an exact case insensitive match)
//
//              alternatively, returns FALSE if the "Right" string contains
//              a non-leading "@" and isn't an exact case insensitive match
//              of the string.
//
//              Assumes that ChainIsRightStringInString() was previously
//              called and returned TRUE.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsSpecialAtCharacterMatch(
    IN LPCWSTR pwszRight,
    IN DWORD cchRight,
    IN DWORD cchString
    )
{
    BOOL fMatch = TRUE;

    if (cchString > cchRight) {
        DWORD i;

        for (i = 0; i < cchRight; i++) {
            if (L'@' == pwszRight[i]) {
                if (0 != i)
                    fMatch = FALSE;

                break;
            }
        }
    }

    return fMatch;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsEmptyOrStringEncodedValue
//
//  Synopsis:   Checks if the encoded value is empty (only contains
//              the tag and length octets) or is a string (has string tag).
//
//              Returns one of the following values:
//               +1 - The encoded value is a string
//                0 - The encoded value is empty (takes precedence over being
//                    a string)
//               -1 - The encoded value isn't a string
//
//----------------------------------------------------------------------------

const BYTE rgbChainStringTag[] = {
    0x0C, // UTF8STRING ::= UTF8String               -- tag 0x0C (12)
    0x1E, // BMPSTRING ::= BMPString                 -- tag 0x1E (30)
    0x16, // IA5STRING ::= IA5String                 -- tag 0x16 (22)
    0x13, // PRINTABLESTRING ::= PrintableString     -- tag 0x13 (19)
    0x1C, // UNIVERSALSTRING ::= UniversalString     -- tag 0x1C (28)
    0x14, // TELETEXSTRING ::= TeletexString         -- tag 0x14 (20)
//  0x14, // T61STRING ::= T61String                 -- tag 0x14 (20)
    0x12, // NUMERICSTRING ::= NumericString         -- tag 0x12 (18)
    0x1B, // GENERALSTRING ::= GeneralString         -- tag 0x1B (27)
    0x15, // VIDEOTEXSTRING ::= VideotexString       -- tag 0x15 (21)
    0x19, // GRAPHICSTRING ::= GraphicString         -- tag 0x19 (25)
    0x1A, // VISIBLESTRING ::= VisibleString         -- tag 0x1A (26)
//  0x1A, // ISO646STRING ::= ISO646String           -- tag 0x1A (26)
};

#define CHAIN_STRING_TAB_CNT    \
    (sizeof(rgbChainStringTag) / sizeof(rgbChainStringTag[0]))

int WINAPI
ChainIsEmptyOrStringEncodedValue(
    IN PCRYPT_OBJID_BLOB pEncodedValue
    )
{
    DWORD i;
    BYTE bTag;

    if (CHAIN_OTHER_NAME_MAX_EMPTY_LENGTH >= pEncodedValue->cbData)
        return 0;

    bTag = pEncodedValue->pbData[0];

    for (i = 0; i < CHAIN_STRING_TAB_CNT; i++) {
        if (bTag == rgbChainStringTag[i])
            return 1;
    }

    return -1;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFixupNameConstraintsOtherNameValue
//
//  Synopsis:   fixup the CERT_ALT_NAME_OTHER_NAME AltName entry choice
//              for values encoded as strings by allocating and converting
//              to a PCERT_NAME_VALUE containing the unicode string
//              with leading and trailing white space removed.
//
//              The pOtherName->Value.pbData is updated to point to the
//              PCERT_NAME_VALUE instead of the original ASN.1 encoded
//              bytes.
//
//              pOtherName->Value.cbData is set to
//              CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH for a successful
//              fixup.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFixupNameConstraintsOtherNameValue(
    IN OUT PCRYPT_OBJID_BLOB pOtherValue
    )
{
    BOOL fResult;
    PCERT_NAME_VALUE pNameValue;
    LPWSTR pwsz;
    DWORD cch;

    if (0 >= ChainIsEmptyOrStringEncodedValue(pOtherValue))
        // Empty or not a string. No Fixup.
        goto SuccessReturn;

    pNameValue = (PCERT_NAME_VALUE) ChainAllocAndDecodeObject(
        X509_UNICODE_ANY_STRING, 
        pOtherValue->pbData,
        pOtherValue->cbData
        );
    if (NULL == pNameValue)
        goto DecodeError;

    if (!IS_CERT_RDN_CHAR_STRING(pNameValue->dwValueType)) {
        PkiFree(pNameValue);
        goto InvalidStringType;
    }

    ChainRemoveLeadingAndTrailingWhiteSpace(
        (LPWSTR) pNameValue->Value.pbData,
        &pwsz,
        &cch
        );

    pNameValue->Value.pbData = (BYTE *) pwsz;
    pNameValue->Value.cbData = cch * sizeof(WCHAR);

    pOtherValue->pbData = (BYTE *) pNameValue;
    pOtherValue->cbData = CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
SET_ERROR(InvalidStringType, CRYPT_E_BAD_ENCODE)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainAllocDecodeAndFixupNameConstraintsDirectoryName
//
//  Synopsis:   fixup the CERT_ALT_NAME_DIRECTORY_NAME AltName entry choice
//              or the encoded certificate Subject name by allocating and
//              converting to a unicode PCERT_NAME_INFO where
//              leading and trailing white space has been removed from
//              all the attributes.
//
//              The DirectoryName.pbData is updated to point to the
//              PCERT_NAME_INFO instead of the original ASN.1 encoded
//              bytes.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainAllocDecodeAndFixupNameConstraintsDirectoryName(
    IN PCERT_NAME_BLOB pDirName,
    OUT PCERT_NAME_INFO *ppNameInfo
    )
{
    BOOL fResult;
    PCERT_NAME_INFO pNameInfo = NULL;
    DWORD cRDN;
    PCERT_RDN pRDN;

    if (0 == pDirName->cbData)
        goto SuccessReturn;

    pNameInfo = (PCERT_NAME_INFO) ChainAllocAndDecodeObject(
        X509_UNICODE_NAME, 
        pDirName->pbData,
        pDirName->cbData
        );
    if (NULL == pNameInfo)
        goto DecodeError;

    if (0 == pNameInfo->cRDN) {
        PkiFree(pNameInfo);
        pNameInfo = NULL;
        goto SuccessReturn;
    }

    // Iterate through all the attributes and remove leading and trailing
    // white space.
    cRDN = pNameInfo->cRDN;
    pRDN = pNameInfo->rgRDN;
    for ( ; cRDN > 0; cRDN--, pRDN++) {
        DWORD cAttr = pRDN->cRDNAttr;
        PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
        for ( ; cAttr > 0; cAttr--, pAttr++) {
            LPWSTR pwsz;
            DWORD cch;

            if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                continue;

            ChainRemoveLeadingAndTrailingWhiteSpace(
                (LPWSTR) pAttr->Value.pbData,
                &pwsz,
                &cch
                );

            pAttr->Value.pbData = (BYTE *) pwsz;
            pAttr->Value.cbData = cch * sizeof(WCHAR);
        }
    }

SuccessReturn:
    fResult = TRUE;

CommonReturn:
    *ppNameInfo = pNameInfo;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFixupNameConstraintsAltNameEntry
//
//  Synopsis:   fixup the AltName entry choices as follows:
//                  CERT_ALT_NAME_OTHER_NAME
//                      For values encoded as strings, pOtherName->Value.pbData
//                      is updated to point to the allocated
//                      PCERT_NAME_VALUE containing the decoded unicode string.
//                      For a fixup, pOtherName->Value.cbData is set to
//                      CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH.
//
//                  CERT_ALT_NAME_RFC822_NAME
//                  CERT_ALT_NAME_DNS_NAME
//                  CERT_ALT_NAME_URL
//                      Uses DirectoryName.pbData and DirectoryName.cbData
//                      to contain the pointer to and length of the unicode
//                      string.
//
//                      For the subject URL, the DirectoryName.pbData's
//                      unicode string is the allocated host name.
//
//                  CERT_ALT_NAME_DIRECTORY_NAME:
//                      DirectoryName.pbData is updated to point to the
//                      allocated and decoded unicode PCERT_NAME_INFO.
//
//              For the above choices, leading and trailing white space
//              has been removed. cbData is number of bytes and not number
//              of characters, ie, cbData = cch * sizeof(WCHAR)
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainFixupNameConstraintsAltNameEntry(
    IN BOOL fSubjectConstraint,
    IN OUT PCERT_ALT_NAME_ENTRY pEntry
    )
{
    BOOL fResult = TRUE;

    LPWSTR pwsz = NULL;
    DWORD cch = 0;

    switch (pEntry->dwAltNameChoice) {
        case CERT_ALT_NAME_OTHER_NAME:
            fResult = ChainFixupNameConstraintsOtherNameValue(
                &pEntry->pOtherName->Value);
            break;
        case CERT_ALT_NAME_RFC822_NAME:
        case CERT_ALT_NAME_DNS_NAME:
            ChainRemoveLeadingAndTrailingWhiteSpace(
                pEntry->pwszRfc822Name,
                &pwsz,
                &cch
                );
            // Use the directory name's BLOB choice to contain both
            // the pointer to and length of the string
            pEntry->DirectoryName.pbData  = (BYTE *) pwsz;
            pEntry->DirectoryName.cbData  = cch * sizeof(WCHAR);
            break;
        case CERT_ALT_NAME_URL:
            if (fSubjectConstraint) {
                WCHAR rgwszHostName[MAX_PATH + 1];
                LPWSTR pwszHostName;

                rgwszHostName[0] = L'\0';
                fResult = ChainGetHostNameFromUrl(
                    pEntry->pwszURL, MAX_PATH, rgwszHostName);
                if (fResult) {
                    ChainRemoveLeadingAndTrailingWhiteSpace(
                        rgwszHostName,
                        &pwszHostName,
                        &cch
                        );
                    pwsz = (LPWSTR) PkiNonzeroAlloc((cch + 1) * sizeof(WCHAR));
                    if (NULL == pwsz)
                        fResult = FALSE;
                    else
                        memcpy(pwsz, pwszHostName, (cch + 1) * sizeof(WCHAR));
                }

                if (!fResult) {
                    pwsz = NULL;
                    cch = 0;
                }
            } else {
                ChainRemoveLeadingAndTrailingWhiteSpace(
                    pEntry->pwszURL,
                    &pwsz,
                    &cch
                    );
            }

            // Use the directory name's BLOB choice to contain both
            // the pointer to and length of the string
            pEntry->DirectoryName.pbData  = (BYTE *) pwsz;
            pEntry->DirectoryName.cbData  = cch * sizeof(WCHAR);
            break;
        case CERT_ALT_NAME_DIRECTORY_NAME:
            {
                PCERT_NAME_INFO pNameInfo = NULL;
                fResult = ChainAllocDecodeAndFixupNameConstraintsDirectoryName(
                    &pEntry->DirectoryName, &pNameInfo);

                // Update the directory name's BLOB to contain the pointer
                // to the decoded name info
                pEntry->DirectoryName.pbData = (BYTE *) pNameInfo;
            }
            break;
        case CERT_ALT_NAME_X400_ADDRESS:
        case CERT_ALT_NAME_EDI_PARTY_NAME:
        case CERT_ALT_NAME_IP_ADDRESS:
        case CERT_ALT_NAME_REGISTERED_ID:
        default:
            break;
    }

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeNameConstraintsAltNameEntryFixup
//
//  Synopsis:   free memory allocated by the above
//              ChainFixupNameConstraintsAltNameEntry
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeNameConstraintsAltNameEntryFixup(
    IN BOOL fSubjectConstraint,
    IN OUT PCERT_ALT_NAME_ENTRY pEntry
    )
{
    switch (pEntry->dwAltNameChoice) {
        case CERT_ALT_NAME_OTHER_NAME:
            if (CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH ==
                    pEntry->pOtherName->Value.cbData)
                // pbData :: PCERT_NAME_VALUE
                PkiFree(pEntry->pOtherName->Value.pbData);
            break;
        case CERT_ALT_NAME_RFC822_NAME:
        case CERT_ALT_NAME_DNS_NAME:
            break;
        case CERT_ALT_NAME_URL:
            if (fSubjectConstraint)
                // pbData :: LPWSTR
                PkiFree(pEntry->DirectoryName.pbData);
            break;
        case CERT_ALT_NAME_DIRECTORY_NAME:
            // pbData :: PCERT_NAME_INFO
            PkiFree(pEntry->DirectoryName.pbData);
            break;
        case CERT_ALT_NAME_X400_ADDRESS:
        case CERT_ALT_NAME_EDI_PARTY_NAME:
        case CERT_ALT_NAME_IP_ADDRESS:
        case CERT_ALT_NAME_REGISTERED_ID:
        default:
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFormatNameConstraintsAltNameEntryFixup
//
//  Synopsis:   localization format and allocate a previously fixed up
//              AltName entry.
//
//              The returned string must be freed via PkiFree().
//
//----------------------------------------------------------------------------
LPWSTR WINAPI
ChainFormatNameConstraintsAltNameEntryFixup(
    IN PCERT_ALT_NAME_ENTRY pEntry
    )
{
    DWORD dwExceptionCode;
    LPWSTR pwszFormat = NULL;
    DWORD cbFormat = 0;
    CERT_ALT_NAME_ENTRY AltEntry;
    const CERT_ALT_NAME_INFO AltNameInfo = { 1, &AltEntry };
    CERT_OTHER_NAME OtherName;

    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    BYTE *pbEncoded2 = NULL;
    DWORD cbEncoded2;

    __try {

        AltEntry = *pEntry;

        // Restore fixed up entries so we can re-encode
        switch (AltEntry.dwAltNameChoice) {
            case CERT_ALT_NAME_OTHER_NAME:
                if (CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH ==
                        pEntry->pOtherName->Value.cbData) {
                    // Restore from the following fixup:
                    //  pEntry->pOtherName->Value.pbData :: PCERT_NAME_VALUE
                    if (NULL == pEntry->pOtherName->Value.pbData)
                        goto InvalidOtherName;
                    if (!ChainAllocAndEncodeObject(
                            X509_UNICODE_ANY_STRING, 
                            (PCERT_NAME_VALUE) pEntry->pOtherName->Value.pbData,
                            &pbEncoded2,
                            &cbEncoded2
                            ))
                        goto EncodedOtherNameError;
                    OtherName.pszObjId = pEntry->pOtherName->pszObjId;
                    OtherName.Value.pbData = pbEncoded2;
                    OtherName.Value.cbData = cbEncoded2;

                    AltEntry.pOtherName = &OtherName;
                }
                break;
            case CERT_ALT_NAME_RFC822_NAME:
            case CERT_ALT_NAME_DNS_NAME:
            case CERT_ALT_NAME_URL:
                // Restore from the following fixup:
                //  pEntry->DirectoryName.pbData  = (BYTE *) pwsz;
                //  pEntry->DirectoryName.cbData  = cch * sizeof(WCHAR);
                if (NULL == pEntry->DirectoryName.pbData ||
                        0 == pEntry->DirectoryName.cbData)
                    AltEntry.pwszRfc822Name = L"???";
                else
                    AltEntry.pwszRfc822Name =
                        (LPWSTR) pEntry->DirectoryName.pbData;
                break;
            case CERT_ALT_NAME_DIRECTORY_NAME:
                // Restore from the following fixup:
                //  pEntry->DirectoryName.pbData :: PCERT_NAME_INFO
                if (NULL == pEntry->DirectoryName.pbData)
                    goto InvalidDirName;
                if (!ChainAllocAndEncodeObject(
                        X509_UNICODE_NAME,
                        (PCERT_NAME_INFO) pEntry->DirectoryName.pbData,
                        &pbEncoded2,
                        &cbEncoded2
                        ))
                    goto EncodeDirNameError;

                AltEntry.DirectoryName.pbData = pbEncoded2;
                AltEntry.DirectoryName.cbData = cbEncoded2;
                break;
            case CERT_ALT_NAME_X400_ADDRESS:
            case CERT_ALT_NAME_EDI_PARTY_NAME:
            case CERT_ALT_NAME_IP_ADDRESS:
            case CERT_ALT_NAME_REGISTERED_ID:
            default:
                break;
        }

        if (!ChainAllocAndEncodeObject(
                X509_ALTERNATE_NAME,
                &AltNameInfo,
                &pbEncoded,
                &cbEncoded
                ))
            goto EncodeAltNameError;

        if (!CryptFormatObject(
                X509_ASN_ENCODING,
                0,                          // dwFormatType
                0,                          // dwFormatStrType
                NULL,                       // pFormatStruct
                X509_ALTERNATE_NAME,
                pbEncoded,
                cbEncoded,
                NULL,                       // pwszFormat
                &cbFormat
                ))
            goto FormatAltNameError;

        if (NULL == (pwszFormat = (LPWSTR) PkiZeroAlloc(
                cbFormat + sizeof(WCHAR))))
            goto OutOfMemory;

        if (!CryptFormatObject(
                X509_ASN_ENCODING,
                0,                          // dwFormatType
                0,                          // dwFormatStrType
                NULL,                       // pFormatStruct
                X509_ALTERNATE_NAME,
                pbEncoded,
                cbEncoded,
                pwszFormat,
                &cbFormat
                ))
            goto FormatAltNameError;

    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwExceptionCode = GetExceptionCode();
        goto ExceptionError;
    }

CommonReturn:
    PkiFree(pbEncoded);
    PkiFree(pbEncoded2);

    return pwszFormat;

ErrorReturn:
    if (pwszFormat) {
        PkiFree(pwszFormat);
        pwszFormat = NULL;
    }
    goto CommonReturn;

SET_ERROR(InvalidOtherName, ERROR_INVALID_DATA)
TRACE_ERROR(EncodedOtherNameError)
TRACE_ERROR(InvalidDirName)
TRACE_ERROR(EncodeDirNameError)
TRACE_ERROR(EncodeAltNameError)
TRACE_ERROR(FormatAltNameError)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainFormatAndAppendNameConstraintsAltNameEntryFixup
//
//  Synopsis:   localization format a previously fixed up
//              AltName entry and append to the extended error information.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
    IN OUT LPWSTR *ppwszExtErrorInfo,
    IN PCERT_ALT_NAME_ENTRY pEntry,
    IN UINT nFormatID,
    IN OPTIONAL DWORD dwSubtreeIndex        // 0 => no subtree parameter
    )
{
    LPWSTR pwszAllocFormatEntry = NULL;
    LPWSTR pwszFormatEntry;

    pwszAllocFormatEntry = ChainFormatNameConstraintsAltNameEntryFixup(pEntry);
    if (pwszAllocFormatEntry)
        pwszFormatEntry = pwszAllocFormatEntry;
    else
        pwszFormatEntry = L"???";

    if (0 == dwSubtreeIndex)
        ChainFormatAndAppendExtendedErrorInfo(
            ppwszExtErrorInfo,
            nFormatID,
            pwszFormatEntry
            );
    else
        ChainFormatAndAppendExtendedErrorInfo(
            ppwszExtErrorInfo,
            nFormatID,
            dwSubtreeIndex,
            pwszFormatEntry
            );

    PkiFree(pwszAllocFormatEntry);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetIssuerNameConstraintsInfo
//
//  Synopsis:   alloc and return the issuer name constraints info.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetIssuerNameConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCERT_NAME_CONSTRAINTS_INFO *ppInfo
    )
{
    BOOL fResult;
    PCERT_EXTENSION pExt;
    PCERT_NAME_CONSTRAINTS_INFO pInfo = NULL;
    PCERT_GENERAL_SUBTREE pSubtree;
    DWORD cSubtree;

    pExt = CertFindExtension(
        szOID_NAME_CONSTRAINTS,
        pCertContext->pCertInfo->cExtension,
        pCertContext->pCertInfo->rgExtension
        );
    if (NULL == pExt)
        goto SuccessReturn;

    pInfo = (PCERT_NAME_CONSTRAINTS_INFO) ChainAllocAndDecodeObject(
        X509_NAME_CONSTRAINTS, 
        pExt->Value.pbData,
        pExt->Value.cbData
        );
    if (NULL == pInfo)
        goto DecodeError;


    // Fixup all the AltName entries

    // Note, even for an error we need to fixup all the entries.
    // ChainFreeIssuerNameConstraintsInfo iterates through all the entries.
    fResult = TRUE;

    cSubtree = pInfo->cPermittedSubtree;
    pSubtree = pInfo->rgPermittedSubtree;
    for ( ; 0 < cSubtree; cSubtree--, pSubtree++) {
        if (!ChainFixupNameConstraintsAltNameEntry(FALSE, &pSubtree->Base))
            fResult = FALSE;
    }

    cSubtree = pInfo->cExcludedSubtree;
    pSubtree = pInfo->rgExcludedSubtree;
    for ( ; 0 < cSubtree; cSubtree--, pSubtree++) {
        if (!ChainFixupNameConstraintsAltNameEntry(FALSE, &pSubtree->Base))
            fResult = FALSE;
    }

    if (!fResult)
        goto FixupAltNameEntryError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    *ppInfo = pInfo;
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(DecodeError)
TRACE_ERROR(FixupAltNameEntryError)
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeIssuerNameConstraintsInfo
//
//  Synopsis:   free the issuer name constraints info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeIssuerNameConstraintsInfo (
    IN OUT PCERT_NAME_CONSTRAINTS_INFO pInfo
    )
{
    PCERT_GENERAL_SUBTREE pSubtree;
    DWORD cSubtree;

    if (NULL == pInfo)
        return;

    cSubtree = pInfo->cPermittedSubtree;
    pSubtree = pInfo->rgPermittedSubtree;
    for ( ; 0 < cSubtree; cSubtree--, pSubtree++)
        ChainFreeNameConstraintsAltNameEntryFixup(FALSE, &pSubtree->Base);

    cSubtree = pInfo->cExcludedSubtree;
    pSubtree = pInfo->rgExcludedSubtree;
    for ( ; 0 < cSubtree; cSubtree--, pSubtree++)
        ChainFreeNameConstraintsAltNameEntryFixup(FALSE, &pSubtree->Base);

    PkiFree(pInfo);
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetSubjectNameConstraintsInfo
//
//  Synopsis:   alloc and return the subject name constraints info.
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainGetSubjectNameConstraintsInfo (
    IN PCCERT_CONTEXT pCertContext,
    IN OUT PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo
    )
{
    PCERT_EXTENSION pExt;
    BOOL fHasEmailAltNameEntry = FALSE;

    pExt = CertFindExtension(
        szOID_SUBJECT_ALT_NAME2,
        pCertContext->pCertInfo->cExtension,
        pCertContext->pCertInfo->rgExtension
        );

    if (NULL == pExt) {
        pExt = CertFindExtension(
            szOID_SUBJECT_ALT_NAME,
            pCertContext->pCertInfo->cExtension,
            pCertContext->pCertInfo->rgExtension
            );
    }

    if (pExt) {
        PCERT_ALT_NAME_INFO pAltNameInfo;

        pAltNameInfo = (PCERT_ALT_NAME_INFO) ChainAllocAndDecodeObject(
            X509_ALTERNATE_NAME, 
            pExt->Value.pbData,
            pExt->Value.cbData
            );
        if (NULL == pAltNameInfo)
            pSubjectInfo->fInvalid = TRUE;
        else {
            DWORD cEntry;
            PCERT_ALT_NAME_ENTRY pEntry;
            
            pSubjectInfo->pAltNameInfo = pAltNameInfo;

            // Fixup all the AltName entries

            // Note, even for an error we need to fixup all the entries.
            // ChainFreeSubjectNameConstraintsInfo iterates through all
            // the entries.

            cEntry = pAltNameInfo->cAltEntry;
            pEntry = pAltNameInfo->rgAltEntry;
            for ( ; 0 < cEntry; cEntry--, pEntry++) {
                if (CERT_ALT_NAME_RFC822_NAME == pEntry->dwAltNameChoice)
                    fHasEmailAltNameEntry = TRUE;
                else if (CERT_ALT_NAME_DNS_NAME == pEntry->dwAltNameChoice)
                    pSubjectInfo->fHasDnsAltNameEntry = TRUE;

                if (!ChainFixupNameConstraintsAltNameEntry(TRUE, pEntry))
                    pSubjectInfo->fInvalid = TRUE;
            }
        }
    }

    if (!ChainAllocDecodeAndFixupNameConstraintsDirectoryName(
            &pCertContext->pCertInfo->Subject,
            &pSubjectInfo->pUnicodeNameInfo 
            ))
        pSubjectInfo->fInvalid = TRUE;

    if (!fHasEmailAltNameEntry && pSubjectInfo->pUnicodeNameInfo) {
        DWORD cRDN;
        PCERT_RDN pRDN;

        cRDN = pSubjectInfo->pUnicodeNameInfo->cRDN;
        pRDN = pSubjectInfo->pUnicodeNameInfo->rgRDN;
        for ( ; cRDN > 0; cRDN--, pRDN++) {
            DWORD cAttr = pRDN->cRDNAttr;
            PCERT_RDN_ATTR pAttr = pRDN->rgRDNAttr;
            for ( ; cAttr > 0; cAttr--, pAttr++) {
                if (!IS_CERT_RDN_CHAR_STRING(pAttr->dwValueType))
                    continue;

                if (0 == strcmp(pAttr->pszObjId, szOID_RSA_emailAddr)) {
                    pSubjectInfo->pEmailAttr = pAttr;
                    break;
                }

            }
            if (cAttr > 0)
                break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeSubjectNameConstraintsInfo
//
//  Synopsis:   free the subject name constraints info
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeSubjectNameConstraintsInfo (
    IN OUT PCHAIN_SUBJECT_NAME_CONSTRAINTS_INFO pSubjectInfo
    )
{
    PCERT_ALT_NAME_INFO pAltNameInfo;

    pAltNameInfo = pSubjectInfo->pAltNameInfo;
    if (pAltNameInfo) {
        DWORD cEntry;
        PCERT_ALT_NAME_ENTRY pEntry;
            
        cEntry = pAltNameInfo->cAltEntry;
        pEntry = pAltNameInfo->rgAltEntry;
        for ( ; 0 < cEntry; cEntry--, pEntry++)
            ChainFreeNameConstraintsAltNameEntryFixup(TRUE, pEntry);

        PkiFree(pAltNameInfo);
    }

    PkiFree(pSubjectInfo->pUnicodeNameInfo);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCompareNameConstraintsDirectoryName
//
//  Synopsis:   returns TRUE if all the subtree RDN attributes match
//              the RDN attributes at the beginning of the subject
//              directory name. A case insensitive match
//              is performed on each RDN attribute that is a string type.
//              A binary compare is performed on nonstring attribute types.
//
//              The OIDs of the RDN attributes must match.
//
//              Note, a NULL subtree or a subtree with no RDNs matches
//              any subject directory name. Also, an empty subtree
//              RDN attribute matches any subject attribute. 
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCompareNameConstraintsDirectoryName(
    IN PCERT_NAME_INFO pSubjectInfo,
    IN PCERT_NAME_INFO pSubtreeInfo
    )
{
    DWORD cSubjectRDN;
    PCERT_RDN pSubjectRDN;
    DWORD cSubtreeRDN;
    PCERT_RDN pSubtreeRDN;

    if (NULL == pSubtreeInfo || 0 == pSubtreeInfo->cRDN)
        // Match any subject
        return TRUE;
    if (NULL == pSubjectInfo)
        return FALSE;

    cSubjectRDN = pSubjectInfo->cRDN;
    cSubtreeRDN = pSubtreeInfo->cRDN;
    if (cSubtreeRDN > cSubjectRDN)
        return FALSE;

    pSubjectRDN = pSubjectInfo->rgRDN;
    pSubtreeRDN = pSubtreeInfo->rgRDN;
    for ( ; cSubtreeRDN > 0; cSubtreeRDN--, pSubtreeRDN++, pSubjectRDN++) {
        DWORD cSubjectAttr = pSubjectRDN->cRDNAttr;
        PCERT_RDN_ATTR pSubjectAttr = pSubjectRDN->rgRDNAttr;
        DWORD cSubtreeAttr = pSubtreeRDN->cRDNAttr;
        PCERT_RDN_ATTR pSubtreeAttr = pSubtreeRDN->rgRDNAttr;

        if (1 < cSubtreeRDN) {
            if (cSubtreeAttr != cSubjectAttr)
                return FALSE;
        } else {
            if (cSubtreeAttr > cSubjectAttr)
                return FALSE;
        }

        for ( ; cSubtreeAttr > 0; cSubtreeAttr--, pSubtreeAttr++, pSubjectAttr++) {
            if (0 != strcmp(pSubtreeAttr->pszObjId, pSubjectAttr->pszObjId))
                return FALSE;

            if (IS_CERT_RDN_CHAR_STRING(pSubtreeAttr->dwValueType) !=
                    IS_CERT_RDN_CHAR_STRING(pSubjectAttr->dwValueType))
                return FALSE;

            if (IS_CERT_RDN_CHAR_STRING(pSubtreeAttr->dwValueType)) {
                DWORD cchSubtree = pSubtreeAttr->Value.cbData / sizeof(WCHAR);

                if (0 == cchSubtree) {
                    // Match any attribute
                    ;
                } else if (cchSubtree !=
                        pSubjectAttr->Value.cbData / sizeof(WCHAR)) {
                    // For X.509, must match entire attribute
                    return FALSE;
                } else if (!ChainIsRightStringInString(
                        (LPCWSTR) pSubtreeAttr->Value.pbData,
                        cchSubtree,
                        (LPCWSTR) pSubjectAttr->Value.pbData,
                        cchSubtree
                        )) {
                    return FALSE;
                }
            } else {
                if (pSubtreeAttr->Value.cbData != pSubjectAttr->Value.cbData)
                    return FALSE;
                if (0 != memcmp(pSubtreeAttr->Value.pbData,
                        pSubjectAttr->Value.pbData,
                        pSubtreeAttr->Value.cbData
                        ))
                    return FALSE;
            }
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCompareNameConstraintsIPAddress
//
//  Synopsis:   returns TRUE if the subject IP address is within the IP
//              range specified by subtree IP address and mask.
//
//              The subtree IP contains the octet bytes for both the
//              IP address and its mask.
//
//              For IPv4, there are 4 address bytes followed by 4 mask bytes.
//              See RFC 2459 for more details.
//
//              Here's my interpretation:
//
//              For a match: SubtreeIPAddr == (SubjectIPAddr & SubtreeIPMask)
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCompareNameConstraintsIPAddress(
    IN PCRYPT_DATA_BLOB pSubjectIPAddress,
    IN PCRYPT_DATA_BLOB pSubtreeIPAddress
    )
{
    BYTE *pbSubject = pSubjectIPAddress->pbData;
    DWORD cbSubject = pSubjectIPAddress->cbData;
    BYTE *pbSubtree = pSubtreeIPAddress->pbData;
    DWORD cbSubtree = pSubtreeIPAddress->cbData;
    BYTE *pbSubtreeMask = pbSubtree + cbSubject;

    DWORD i;

    if (0 == cbSubtree)
        // Match any IP address
        return TRUE;

    // Only compare if the number of subtree bytes is twice the length of
    // the subject. Second half contains the mask.
    if (cbSubtree != 2 * cbSubject)
        return FALSE;

    for (i = 0; i < cbSubject; i++) {
        if (pbSubtree[i] != (pbSubject[i] & pbSubtreeMask[i]))
            return FALSE;
    }

    return TRUE;

}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCompareNameConstraintsOtherNameValue
//
//  Synopsis:   returns TRUE if the subtree OtherName value is empty.
//              If both the subtree and subject OtherName values are strings,
//              returns TRUE if the subtree OtherName string matches the
//              right most characters of the subject's OtherName
//              doing a case insensitive match.
//
//              For the szOID_NT_PRINCIPAL_NAME (UPN) OtherName also
//              does a special "@" (At character) match.
//
//              For CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH == Value.cbData,
//              the Value.pbData points to the decoded PCERT_NAME_VALUE.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCompareNameConstraintsOtherNameValue(
    IN LPCSTR pszOtherNameOID,
    IN PCRYPT_OBJID_BLOB pSubjectValue,
    IN PCRYPT_OBJID_BLOB pSubtreeValue
    )
{
    BOOL fCompare;
    PCERT_NAME_VALUE pSubjectNameValue;
    PCERT_NAME_VALUE pSubtreeNameValue;

    if (CHAIN_OTHER_NAME_MAX_EMPTY_LENGTH >= pSubtreeValue->cbData)
        // Subtree has an empty value. Match any subject.
        return TRUE;

    if (CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH != pSubjectValue->cbData ||
            CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH != pSubtreeValue->cbData)
        // Only support string matching
        return FALSE;

    // The OtherName's Value.pbData is used to point to the decoded
    // PCERT_NAME_VALUE

    pSubjectNameValue =
        (PCERT_NAME_VALUE) pSubjectValue->pbData;
    pSubtreeNameValue =
        (PCERT_NAME_VALUE) pSubtreeValue->pbData;

    if (pSubjectNameValue && pSubtreeNameValue) {
        fCompare = ChainIsRightStringInString(
            (LPCWSTR) pSubtreeNameValue->Value.pbData,
            pSubtreeNameValue->Value.cbData / sizeof(WCHAR),
            (LPCWSTR) pSubjectNameValue->Value.pbData,
            pSubjectNameValue->Value.cbData / sizeof(WCHAR)
            );

        if (fCompare && 0 == strcmp(pszOtherNameOID, szOID_NT_PRINCIPAL_NAME))
            fCompare = ChainIsSpecialAtCharacterMatch(
                (LPCWSTR) pSubtreeNameValue->Value.pbData,
                pSubtreeNameValue->Value.cbData / sizeof(WCHAR),
                pSubjectNameValue->Value.cbData / sizeof(WCHAR)
                );
    } else
        fCompare = FALSE;

    return fCompare;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry
//
//  Synopsis:   calculates the name constraints error status by seeing if
//              the subject AltName entry matches any subtree AltName entry.
//
//----------------------------------------------------------------------------
DWORD WINAPI
ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pSubjectEntry,
    IN BOOL fExcludedSubtree,
    IN DWORD cSubtree,
    IN PCERT_GENERAL_SUBTREE pSubtree,
    IN OUT LPWSTR *ppwszExtErrorInfo
    )
{
    DWORD dwErrorStatus = 0;
    BOOL fHasSubtreeEntry = FALSE;
    DWORD dwAltNameChoice = pSubjectEntry->dwAltNameChoice;
    DWORD i;

    for (i = 0; i < cSubtree; i++, pSubtree++) {
        PCERT_ALT_NAME_ENTRY pSubtreeEntry;
        BOOL fCompare;

        if (0 != pSubtree->dwMinimum || pSubtree->fMaximum) {
            dwErrorStatus |= CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;

            ChainFormatAndAppendExtendedErrorInfo(
                ppwszExtErrorInfo,
                fExcludedSubtree ?
                    IDS_NOT_SUPPORTED_EXCLUDED_NAME_CONSTRAINT :
                    IDS_NOT_SUPPORTED_PERMITTED_NAME_CONSTRAINT,
                i + 1
                );
            continue;
        }

        pSubtreeEntry = &pSubtree->Base;
        if (dwAltNameChoice != pSubtreeEntry->dwAltNameChoice)
            continue;

        fCompare = FALSE;
        switch (dwAltNameChoice) {
            case CERT_ALT_NAME_OTHER_NAME:
                // Only support empty or string OtherName Values.
                if (CHAIN_OTHER_NAME_MAX_EMPTY_LENGTH <
                            pSubtreeEntry->pOtherName->Value.cbData
                                    &&
                        CHAIN_OTHER_NAME_FIXUP_STRING_LENGTH !=
                            pSubtreeEntry->pOtherName->Value.cbData) {
                    dwErrorStatus |=
                        CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;

                    ChainFormatAndAppendExtendedErrorInfo(
                        ppwszExtErrorInfo,
                        fExcludedSubtree ?
                            IDS_NOT_SUPPORTED_EXCLUDED_NAME_CONSTRAINT :
                            IDS_NOT_SUPPORTED_PERMITTED_NAME_CONSTRAINT,
                        i + 1
                        );
                } else if (0 == strcmp(pSubtreeEntry->pOtherName->pszObjId,
                        pSubjectEntry->pOtherName->pszObjId)) {
                    fHasSubtreeEntry = TRUE;

                    fCompare = ChainCompareNameConstraintsOtherNameValue(
                        pSubtreeEntry->pOtherName->pszObjId,
                        &pSubjectEntry->pOtherName->Value,
                        &pSubtreeEntry->pOtherName->Value
                        );
                }
                break;
            case CERT_ALT_NAME_RFC822_NAME:
            case CERT_ALT_NAME_DNS_NAME:
            case CERT_ALT_NAME_URL:
                fHasSubtreeEntry = TRUE;
                // The directory name's BLOB choice is used to contain both
                // the pointer to and length of the string
                fCompare = ChainIsRightStringInString(
                    (LPCWSTR) pSubtreeEntry->DirectoryName.pbData,
                    pSubtreeEntry->DirectoryName.cbData / sizeof(WCHAR),
                    (LPCWSTR) pSubjectEntry->DirectoryName.pbData,
                    pSubjectEntry->DirectoryName.cbData / sizeof(WCHAR)
                    );
                if (fCompare && CERT_ALT_NAME_RFC822_NAME == dwAltNameChoice)
                    fCompare = ChainIsSpecialAtCharacterMatch(
                        (LPCWSTR) pSubtreeEntry->DirectoryName.pbData,
                        pSubtreeEntry->DirectoryName.cbData / sizeof(WCHAR),
                        pSubjectEntry->DirectoryName.cbData / sizeof(WCHAR)
                        );
                break;
            case CERT_ALT_NAME_DIRECTORY_NAME:
                fHasSubtreeEntry = TRUE;
                fCompare = ChainCompareNameConstraintsDirectoryName(
                    (PCERT_NAME_INFO) pSubjectEntry->DirectoryName.pbData,
                    (PCERT_NAME_INFO) pSubtreeEntry->DirectoryName.pbData
                    );
                break;
            case CERT_ALT_NAME_IP_ADDRESS:
                fHasSubtreeEntry = TRUE;
                fCompare = ChainCompareNameConstraintsIPAddress(
                    &pSubjectEntry->IPAddress, &pSubtreeEntry->IPAddress);
                break;
            case CERT_ALT_NAME_X400_ADDRESS:
            case CERT_ALT_NAME_EDI_PARTY_NAME:
            case CERT_ALT_NAME_REGISTERED_ID:
            default:
                assert(0);
                break;
        }

        if (fCompare) {
            if (fExcludedSubtree) {
                dwErrorStatus |= CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT;

                ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
                    ppwszExtErrorInfo,
                    pSubjectEntry,
                    IDS_EXCLUDED_ENTRY_NAME_CONSTRAINT,
                    i + 1
                    );
            }
            return dwErrorStatus;
        }
    }

    if (!fExcludedSubtree) {
        if (fHasSubtreeEntry) {
            dwErrorStatus |= CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT;

            ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
                ppwszExtErrorInfo,
                pSubjectEntry,
                IDS_NOT_PERMITTED_ENTRY_NAME_CONSTRAINT
                );
        } else if (!IPR_IsNotDefinedNameConstraintDisabled()) {
            dwErrorStatus |= CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT;

            ChainFormatAndAppendNameConstraintsAltNameEntryFixup(
                ppwszExtErrorInfo,
                pSubjectEntry,
                IDS_NOT_DEFINED_ENTRY_NAME_CONSTRAINT
                );
        }
    }

    return dwErrorStatus;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCalculateNameConstraintsErrorStatusForAltNameEntry
//
//  Synopsis:   calculates the name constraints error status by seeing if
//              the subject AltName entry matches either an excluded
//              or permitted subtree AltName entry.
//
//----------------------------------------------------------------------------
DWORD WINAPI
ChainCalculateNameConstraintsErrorStatusForAltNameEntry(
    IN PCERT_ALT_NAME_ENTRY pSubjectEntry,
    IN PCERT_NAME_CONSTRAINTS_INFO pNameConstraintsInfo,
    IN OUT LPWSTR *ppwszExtErrorInfo
    )
{
    DWORD dwErrorStatus;

    dwErrorStatus =
        ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry(
            pSubjectEntry,
            TRUE,                                   // fExcludedSubtree
            pNameConstraintsInfo->cExcludedSubtree,
            pNameConstraintsInfo->rgExcludedSubtree,
            ppwszExtErrorInfo
            );

    if (!(dwErrorStatus & CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT))
        dwErrorStatus =
            ChainCalculateNameConstraintsSubtreeErrorStatusForAltNameEntry(
                pSubjectEntry,
                FALSE,                                  // fExcludedSubtree
                pNameConstraintsInfo->cPermittedSubtree,
                pNameConstraintsInfo->rgPermittedSubtree,
                ppwszExtErrorInfo
                );

    return dwErrorStatus;
}



//+===========================================================================
//  CCertIssuerList helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateIssuerList
//
//  Synopsis:   create the issuer list object for the given subject
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateIssuerList (
     IN PCCHAINPATHOBJECT pSubject,
     OUT PCCERTISSUERLIST* ppIssuerList
     )
{
    PCCERTISSUERLIST pIssuerList;

    pIssuerList = new CCertIssuerList( pSubject );
    if ( pIssuerList == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    *ppIssuerList = pIssuerList;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeIssuerList
//
//  Synopsis:   free the issuer list object
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeIssuerList (
     IN PCCERTISSUERLIST pIssuerList
     )
{
    delete pIssuerList;
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeCtlIssuerData
//
//  Synopsis:   free CTL issuer data
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeCtlIssuerData (
     IN PCTL_ISSUER_DATA pCtlIssuerData
     )
{
    if ( pCtlIssuerData->pTrustListInfo != NULL )
    {
        SSCtlFreeTrustListInfo( pCtlIssuerData->pTrustListInfo );
    }

    if ( pCtlIssuerData->pSSCtlObject != NULL )
    {
        pCtlIssuerData->pSSCtlObject->Release();
    }

    delete pCtlIssuerData;
}

//+===========================================================================
//  INTERNAL_CERT_CHAIN_CONTEXT helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainAddRefInternalChainContext
//
//  Synopsis:   addref the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainAddRefInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     )
{
    InterlockedIncrement( &pChainContext->cRefs );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainReleaseInternalChainContext
//
//  Synopsis:   release the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainReleaseInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pChainContext
     )
{
    if ( InterlockedDecrement( &pChainContext->cRefs ) == 0 )
    {
        ChainFreeInternalChainContext( pChainContext );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainFreeInternalChainContext
//
//  Synopsis:   free the internal chain context
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainFreeInternalChainContext (
     IN PINTERNAL_CERT_CHAIN_CONTEXT pContext
     )
{

    PCERT_SIMPLE_CHAIN *ppChain;
    DWORD cChain;

    PINTERNAL_CERT_CHAIN_CONTEXT *ppLowerContext;

    if (NULL == pContext)
        return;

    cChain = pContext->ChainContext.cChain;
    ppChain = pContext->ChainContext.rgpChain;
    for ( ; 0 < cChain; cChain--, ppChain++) {
        PCERT_SIMPLE_CHAIN pChain;
        DWORD cElement;
        PCERT_CHAIN_ELEMENT *ppElement;

        pChain = *ppChain;
        if (NULL == pChain)
            continue;

        if (pChain->pTrustListInfo)
            SSCtlFreeTrustListInfo(pChain->pTrustListInfo);

        cElement = pChain->cElement;
        ppElement = pChain->rgpElement;
        for ( ; 0 < cElement; cElement--, ppElement++) {
            PCERT_CHAIN_ELEMENT pElement;

            pElement = *ppElement;
            if (NULL == pElement)
                continue;

            if (pElement->pRevocationInfo) {
                PCERT_REVOCATION_CRL_INFO pCrlInfo =
                    pElement->pRevocationInfo->pCrlInfo;

                if (pCrlInfo) {
                    if (pCrlInfo->pBaseCrlContext)
                        CertFreeCRLContext(pCrlInfo->pBaseCrlContext);
                    if (pCrlInfo->pDeltaCrlContext)
                        CertFreeCRLContext(pCrlInfo->pDeltaCrlContext);

                    delete pCrlInfo;
                }

                delete pElement->pRevocationInfo;
            }

            if (pElement->pCertContext)
                CertFreeCertificateContext(pElement->pCertContext);

            ChainFreeUsage(pElement->pIssuanceUsage);
            ChainFreeUsage(pElement->pApplicationUsage);

            if (pElement->pwszExtendedErrorInfo)
                PkiFree((LPWSTR) pElement->pwszExtendedErrorInfo);
        }

        
    }

    ppLowerContext = (PINTERNAL_CERT_CHAIN_CONTEXT*)
                            pContext->ChainContext.rgpLowerQualityChainContext;
    if (ppLowerContext) {
        DWORD cLowerContext;
        DWORD i;

        cLowerContext = pContext->ChainContext.cLowerQualityChainContext;
        for (i = 0; i < cLowerContext; i++)
            ChainReleaseInternalChainContext(ppLowerContext[i]);

        delete ppLowerContext;
    }

    PkiFree(pContext);
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainUpdateEndEntityCertContext
//
//  Synopsis:   update the end entity cert context in the chain context
//
//----------------------------------------------------------------------------
VOID
ChainUpdateEndEntityCertContext(
    IN OUT PINTERNAL_CERT_CHAIN_CONTEXT pChainContext,
    IN OUT PCCERT_CONTEXT pEndCertContext
    )
{
    PCCERT_CONTEXT pCertContext =
        pChainContext->ChainContext.rgpChain[0]->rgpElement[0]->pCertContext;
    if (pCertContext == pEndCertContext)
        return;
    pChainContext->ChainContext.rgpChain[0]->rgpElement[0]->pCertContext =
        pEndCertContext;

    {
        DWORD cbData;
        DWORD cbEndData;

        // If the chain context's end context has the public key parameter
        // property and the end context passed in to CertGetCertificateChain
        // doesn't, then copy the public key parameter property.
        if (CertGetCertificateContextProperty(
                pCertContext,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbData) && 0 < cbData &&
            !CertGetCertificateContextProperty(
                pEndCertContext,
                CERT_PUBKEY_ALG_PARA_PROP_ID,
                NULL,                       // pvData
                &cbEndData))
        {
            BYTE *pbData;

            __try {
                pbData = (BYTE *) _alloca(cbData);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                pbData = NULL;
            }
            if (pbData)
            {
                if (CertGetCertificateContextProperty(
                        pCertContext,
                        CERT_PUBKEY_ALG_PARA_PROP_ID,
                        pbData,
                        &cbData))
                {
                    CRYPT_DATA_BLOB Para;
                    Para.pbData = pbData;
                    Para.cbData = cbData;
                    CertSetCertificateContextProperty(
                        pEndCertContext,
                        CERT_PUBKEY_ALG_PARA_PROP_ID,
                        CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG,
                        &Para
                        );
                }
            }
        }
    }

    CertDuplicateCertificateContext(pEndCertContext);
    CertFreeCertificateContext(pCertContext);
}


//+===========================================================================
//  CERT_REVOCATION_INFO helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainUpdateRevocationInfo
//
//  Synopsis:   update the revocation information on the element
//
//----------------------------------------------------------------------------
VOID WINAPI
ChainUpdateRevocationInfo (
     IN PCERT_REVOCATION_STATUS pRevStatus,
     IN OUT PCERT_REVOCATION_INFO pRevocationInfo,
     IN OUT PCERT_TRUST_STATUS pTrustStatus
     )
{
    CertPerfIncrementChainRevocationCount();

    if (ERROR_SUCCESS == pRevStatus->dwError) {
        ;
    } else if (CRYPT_E_REVOKED == pRevStatus->dwError) {
        pTrustStatus->dwErrorStatus |= CERT_TRUST_IS_REVOKED;
        CertPerfIncrementChainRevokedCount();
    } else {
        pTrustStatus->dwErrorStatus |= CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
        if (CRYPT_E_NO_REVOCATION_CHECK == pRevStatus->dwError) {
            CertPerfIncrementChainNoRevocationCheckCount();
        } else {
            pTrustStatus->dwErrorStatus |= CERT_TRUST_IS_OFFLINE_REVOCATION;
            CertPerfIncrementChainRevocationOfflineCount();
        }
    }

    pRevocationInfo->cbSize = sizeof(CERT_REVOCATION_INFO);
    pRevocationInfo->dwRevocationResult = pRevStatus->dwError;
    pRevocationInfo->fHasFreshnessTime = pRevStatus->fHasFreshnessTime;
    pRevocationInfo->dwFreshnessTime = pRevStatus->dwFreshnessTime;
}


//+===========================================================================
//  CCertChainEngine helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateWorldStore
//
//  Synopsis:   create the world store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN HCERTSTORE hCA,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     IN DWORD dwStoreFlags,
     OUT HCERTSTORE* phWorld
     )
{
    BOOL       fResult;
    HCERTSTORE hWorld;
    HCERTSTORE hStore;
    DWORD      cCount;

    hWorld = CertOpenStore(
                 CERT_STORE_PROV_COLLECTION,
                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                 NULL,
                 CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                 NULL
                 );

    if ( hWorld == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hWorld, hRoot, 0, 0 );

    for ( cCount = 0;
          ( cCount < cAdditionalStore ) && ( fResult == TRUE );
          cCount++ )
    {
        fResult = CertAddStoreToCollection(
                      hWorld,
                      rghAdditionalStore[ cCount ],
                      0,
                      0
                      );
    }

    dwStoreFlags |=
        CERT_STORE_MAXIMUM_ALLOWED_FLAG | CERT_STORE_SHARE_CONTEXT_FLAG;

    if ( fResult == TRUE )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags,
                     L"trust"
                     );

        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        if ( hCA != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hCA, 0, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenStore(
                     CERT_STORE_PROV_SYSTEM_W,
                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                     NULL,
                     dwStoreFlags,
                     L"my"
                     );

        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        *phWorld = hWorld;
    }
    else
    {
        CertCloseStore( hWorld, 0 );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateEngineStore
//
//  Synopsis:   create the engine store and the change event handle
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateEngineStore (
     IN HCERTSTORE hRootStore,
     IN HCERTSTORE hTrustStore,
     IN HCERTSTORE hOtherStore,
     IN BOOL fDefaultEngine,
     IN DWORD dwFlags,
     OUT HCERTSTORE* phEngineStore,
     OUT HANDLE* phEngineStoreChangeEvent
     )
{
    BOOL       fResult = TRUE;
    HCERTSTORE hEngineStore;
    HANDLE     hEvent;

    hEngineStore = CertOpenStore(
                       CERT_STORE_PROV_COLLECTION,
                       X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                       NULL,
                       CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                       NULL
                       );

    hEvent = CreateEventA( NULL, FALSE, FALSE, NULL );

    if ( ( hEngineStore == NULL ) || ( hEvent == NULL ) )
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hRootStore, 0, 0 );
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hTrustStore, 0, 0 );
    }

    if ( fResult == TRUE )
    {
        fResult = CertAddStoreToCollection( hEngineStore, hOtherStore, 0, 0 );
    }

    if ( ( fResult == TRUE ) &&
         ( dwFlags & CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE ) )
    {
        // Someday support a let me know about errors flag
        CertControlStore(
            hEngineStore,
            CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG,
            CERT_STORE_CTRL_NOTIFY_CHANGE,
            &hEvent
            );
    }

    if ( fResult == TRUE )
    {
        *phEngineStore = hEngineStore;
        *phEngineStoreChangeEvent = hEvent;
    }
    else
    {
        if ( hEngineStore != NULL )
        {
            CertCloseStore( hEngineStore, 0 );
        }

        if ( hEvent != NULL )
        {
            CloseHandle( hEvent );
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsProperRestrictedRoot
//
//  Synopsis:   check to see if this restricted root store is a proper subset
//              of the real root store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsProperRestrictedRoot (
     IN HCERTSTORE hRealRoot,
     IN HCERTSTORE hRestrictedRoot
     )
{
    PCCERT_CONTEXT  pCertContext = NULL;
    PCCERT_CONTEXT  pFound = NULL;
    DWORD           cbData = CHAINHASHLEN;
    BYTE            CertificateHash[ CHAINHASHLEN ];
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = cbData;
    HashBlob.pbData = CertificateHash;

    while ( ( pCertContext = CertEnumCertificatesInStore(
                                 hRestrictedRoot,
                                 pCertContext
                                 ) ) != NULL )
    {
        if ( CertGetCertificateContextProperty(
                 pCertContext,
                 CERT_MD5_HASH_PROP_ID,
                 CertificateHash,
                 &cbData
                 ) == TRUE )
        {
            pFound = CertFindCertificateInStore(
                         hRealRoot,
                         X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                         0,
                         CERT_FIND_MD5_HASH,
                         &HashBlob,
                         NULL
                         );

            if ( pFound == NULL )
            {
                CertFreeCertificateContext( pCertContext );
                return( FALSE );
            }
            else
            {
                CertFreeCertificateContext( pFound );
            }
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCollectionIncludingCtlCertificates
//
//  Synopsis:   create a collection which includes the source store hStore and
//              any CTL certificates from it
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCollectionIncludingCtlCertificates (
     IN HCERTSTORE hStore,
     OUT HCERTSTORE* phCollection
     )
{
    BOOL          fResult = FALSE;
    HCERTSTORE    hCollection;
    PCCTL_CONTEXT pCtlContext = NULL;
    HCERTSTORE    hCtlStore;

    hCollection = CertOpenStore(
                      CERT_STORE_PROV_COLLECTION,
                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                      NULL,
                      CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                      NULL
                      );

    if ( hCollection == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hCollection, hStore, 0, 0 );

    while ( ( fResult == TRUE ) &&
            ( ( pCtlContext = CertEnumCTLsInStore(
                                  hStore,
                                  pCtlContext
                                  ) ) != NULL ) )
    {
        hCtlStore = CertOpenStore(
                        CERT_STORE_PROV_MSG,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        NULL,
                        0,
                        pCtlContext->hCryptMsg
                        );

        if ( hCtlStore != NULL )
        {
            fResult = CertAddStoreToCollection(
                          hCollection,
                          hCtlStore,
                          0,
                          0
                          );

            CertCloseStore( hCtlStore, 0 );
        }
    }

    if ( fResult == TRUE )
    {
        *phCollection = hCollection;
    }
    else
    {
        CertCloseStore( hCollection, 0 );
    }

    return( fResult );
}


//+===========================================================================
//  URL helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetObjectUrl
//
//  Synopsis:   thunk to CryptGetObjectUrl in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetObjectUrl (
     IN LPCSTR pszUrlOid,
     IN LPVOID pvPara,
     IN DWORD dwFlags,
     OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
     IN OUT DWORD* pcbUrlArray,
     OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
     IN OUT OPTIONAL DWORD* pcbUrlInfo,
     IN OPTIONAL LPVOID pvReserved
     )
{
    BOOL             fResult = FALSE;
    HMODULE          hModule;
    PFN_GETOBJECTURL pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_GETOBJECTURL)GetProcAddress( hModule, "CryptGetObjectUrl" );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )(
                      pszUrlOid,
                      pvPara,
                      dwFlags,
                      pUrlArray,
                      pcbUrlArray,
                      pUrlInfo,
                      pcbUrlInfo,
                      pvReserved
                      );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainRetrieveObjectByUrlW
//
//  Synopsis:   thunk to CryptRetrieveObjectByUrlW in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainRetrieveObjectByUrlW (
     IN LPCWSTR pszUrl,
     IN LPCSTR pszObjectOid,
     IN DWORD dwRetrievalFlags,
     IN DWORD dwTimeout,
     OUT LPVOID* ppvObject,
     IN HCRYPTASYNC hAsyncRetrieve,
     IN PCRYPT_CREDENTIALS pCredentials,
     IN LPVOID pvVerify,
     IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
     )
{
    BOOL                     fResult = FALSE;
    HMODULE                  hModule;
    PFN_RETRIEVEOBJECTBYURLW pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_RETRIEVEOBJECTBYURLW)GetProcAddress(
                                          hModule,
                                          "CryptRetrieveObjectByUrlW"
                                          );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )(
                      pszUrl,
                      pszObjectOid,
                      dwRetrievalFlags,
                      dwTimeout,
                      ppvObject,
                      hAsyncRetrieve,
                      pCredentials,
                      pvVerify,
                      pAuxInfo
                      );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ChainIsConnected
//
//  Synopsis:   thunk to I_CryptNetIsConnected in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainIsConnected()
{
    BOOL                     fResult = FALSE;
    HMODULE                  hModule;
    PFN_I_CRYPTNET_IS_CONNECTED pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_I_CRYPTNET_IS_CONNECTED)GetProcAddress(
                                          hModule,
                                          "I_CryptNetIsConnected"
                                          );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )();
    }

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetHostNameFromUrl
//
//  Synopsis:   thunk to I_CryptNetGetHostNameFromUrl in cryptnet.dll
//
//----------------------------------------------------------------------------
BOOL
WINAPI
ChainGetHostNameFromUrl (
        IN LPWSTR pwszUrl,
        IN DWORD cchHostName,
        OUT LPWSTR pwszHostName
        )
{
    BOOL                     fResult = FALSE;
    HMODULE                  hModule;
    PFN_I_CRYPTNET_GET_HOST_NAME_FROM_URL pfn = NULL;

    hModule = ChainGetCryptnetModule();

    if ( hModule != NULL )
    {
        pfn = (PFN_I_CRYPTNET_GET_HOST_NAME_FROM_URL)GetProcAddress(
                                          hModule,
                                          "I_CryptNetGetHostNameFromUrl"
                                          );
    }

    if ( pfn != NULL )
    {
        fResult = ( *pfn )(
            pwszUrl,
            cchHostName,
            pwszHostName
            );
    }

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainGetOfflineUrlDeltaSeconds
//
//  Synopsis:   given the number of unsuccessful attempts to retrieve the
//              Url, returns the number of seconds to wait before the
//              next attempt.
//
//----------------------------------------------------------------------------

const DWORD rgdwChainOfflineUrlDeltaSeconds[] = {
    15,                 // 15 seconds
    15,                 // 15 seconds
    60,                 // 1 minute
    60 * 5,             // 5 minutes
    60 * 10,            // 10 minutes
    60 * 30,            // 30 minutes
};

#define CHAIN_OFFLINE_URL_DELTA_SECONDS_CNT \
    (sizeof(rgdwChainOfflineUrlDeltaSeconds) / \
        sizeof(rgdwChainOfflineUrlDeltaSeconds[0]))

DWORD
WINAPI
ChainGetOfflineUrlDeltaSeconds (
    IN DWORD dwOfflineCnt
    )
{
    if (0 == dwOfflineCnt)
        return 0;

    if (CHAIN_OFFLINE_URL_DELTA_SECONDS_CNT < dwOfflineCnt)
        dwOfflineCnt = CHAIN_OFFLINE_URL_DELTA_SECONDS_CNT;

    return rgdwChainOfflineUrlDeltaSeconds[dwOfflineCnt - 1];
}

//+===========================================================================
//  Debug helper functions
//============================================================================
DWORD
WINAPI
ChainGetDebugFlags()
{
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);

    DWORD dwLastErr = GetLastError();

    if (ERROR_SUCCESS != RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\crypt32",
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))
        goto ErrorReturn;

    if (ERROR_SUCCESS != RegQueryValueExA(
            hKey,
            "DebugFlags",
            NULL,               // pdwReserved
            &dwType,
            (BYTE *) &dwValue,
            &cbValue
            ))
        goto ErrorReturn;

    if (dwType != REG_DWORD || cbValue != sizeof(dwValue))
        goto ErrorReturn;

CommonReturn:
    if (hKey)
        RegCloseKey(hKey);

    SetLastError(dwLastErr);

    return dwValue;

ErrorReturn:
    dwValue = 0;
    goto CommonReturn;
}

VOID
WINAPI
ChainOutputDebugStringA(
    LPCSTR lpOutputString
    )
{
    if (ChainGetDebugFlags() & 0x1) {
        DWORD dwLastErr = GetLastError();
        
        OutputDebugStringA(lpOutputString);

        SetLastError(dwLastErr);
    }
}

//+===========================================================================
//  AuthRoot Auto Update methods and helper functions
//============================================================================

//+---------------------------------------------------------------------------
//
//  Member:     CChainPathObject::GetAuthRootAutoUpdateUrlStore, public
//
//  Synopsis:   attempts to get a time valid AuthRoot Auto Update CTL.
//              Checks if there is CTL entry matching the subject
//              certificate's AKI exact match, key identifier or name
//              match. For a match URL retrieves the certificate and
//              returns a store containing the retrieved certificates
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section.
//
//              The caller has already checked that we are online.
//
//----------------------------------------------------------------------------


// CN=Root Agency
const BYTE rgbRootAgencyIssuerName[] = {
    0x30, 0x16,                         // SEQUENCE
    0x31, 0x14,                         //  SET
    0x30, 0x12,                         //   SEQUENCE
    0x06, 0x03, 0x55, 0x04, 0x03,       //    OID
                                        //    PRINTABLE STRING
    0x13, 0x0b, 0x52, 0x6f, 0x6f, 0x74, 0x20,
    0x41, 0x67, 0x65, 0x6e, 0x63, 0x79
};

// CN=Root SGC Authority
const BYTE rgbRootSGCAuthorityIssuerName[] = {
    0x30, 0x1d,                         // SEQUENCE
    0x31, 0x1b,                         //  SET
    0x30, 0x19,                         //   SEQUENCE
    0x06, 0x03, 0x55, 0x04, 0x03,       //    OID
                                        //    PRINTABLE STRING
    0x13, 0x12, 0x52, 0x6f, 0x6f, 0x74, 0x20,
                0x53, 0x47, 0x43, 0x20, 0x41,
                0x75, 0x74, 0x68, 0x6f, 0x72,
                0x69, 0x74, 0x79
};

const CRYPT_DATA_BLOB rgSkipPartialIssuer[] = {
    sizeof(rgbRootAgencyIssuerName), (BYTE *) rgbRootAgencyIssuerName,
    sizeof(rgbRootSGCAuthorityIssuerName), (BYTE *) rgbRootSGCAuthorityIssuerName
};
#define SKIP_PARTIAL_ISSUER_CNT     (sizeof(rgSkipPartialIssuer)/ \
                                        sizeof(rgSkipPartialIssuer[0]))



BOOL
CChainPathObject::GetAuthRootAutoUpdateUrlStore(
    IN PCCHAINCALLCONTEXT pCallContext,
    OUT HCERTSTORE *phIssuerUrlStore
    )
{
    BOOL fTouchedResult = TRUE;
    PCCERTCHAINENGINE pChainEngine = pCallContext->ChainEngine();
    PCERT_INFO pCertInfo = m_pCertObject->CertContext()->pCertInfo;
    PCCTL_CONTEXT pCtl = NULL;
    HCERTSTORE hIssuerUrlStore = NULL;

    CRYPT_DATA_BLOB rgAuthRootMatchHash[AUTH_ROOT_MATCH_CNT];
    DWORD cEntry = 0;
    PCTL_ENTRY *rgpEntry = NULL;
    PCCERT_CONTEXT pCert;
    DWORD cCert;
    DWORD i;

    *phIssuerUrlStore = NULL;

    // Loop and skip known issuers such as, "Root Agency". Don't want all
    // clients in the world hiting the wire when building these chains
    for (i = 0; i < SKIP_PARTIAL_ISSUER_CNT; i++) {
        if (pCertInfo->Issuer.cbData == rgSkipPartialIssuer[i].cbData &&
            0 == memcmp(pCertInfo->Issuer.pbData, 
                    rgSkipPartialIssuer[i].pbData,
                    rgSkipPartialIssuer[i].cbData))
            return TRUE;
    }
    
    fTouchedResult = pChainEngine->GetAuthRootAutoUpdateCtl(
        pCallContext,
        &pCtl
        );

    if (!fTouchedResult || NULL == pCtl) {

#if 0
// This logs too many test failures

        if (fTouchedResult) {
            PAUTH_ROOT_AUTO_UPDATE_INFO pInfo =
                pChainEngine->AuthRootAutoUpdateInfo();

            if (NULL == pInfo || !(pInfo->dwFlags &
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG))
                IPR_LogCertInformation(
                    MSG_PARTIAL_CHAIN_INFORMATIONAL,
                    m_pCertObject->CertContext(),
                    TRUE        // fFormatIssuerName
                    );
        }
#endif

        return fTouchedResult;
    }

    // We have a valid AuthRoot Auto Update CTL.
    // See if we can find any matching AuthRoots

    memset(rgAuthRootMatchHash, 0, sizeof(rgAuthRootMatchHash));

    m_pCertObject->GetIssuerKeyMatchHash(
        &rgAuthRootMatchHash[AUTH_ROOT_KEY_MATCH_IDX]);
    m_pCertObject->GetIssuerNameMatchHash(
        &rgAuthRootMatchHash[AUTH_ROOT_NAME_MATCH_IDX]);

    pChainEngine->FindAuthRootAutoUpdateMatchingCtlEntries(
        rgAuthRootMatchHash,
        &pCtl,
        &cEntry,
        &rgpEntry
        );

    if (0 == cEntry) {

#if 0
// This logs too many test failures

        PAUTH_ROOT_AUTO_UPDATE_INFO pInfo =
            pChainEngine->AuthRootAutoUpdateInfo();

        if (NULL == pInfo || !(pInfo->dwFlags &
                CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG))
            IPR_LogCertInformation(
                MSG_PARTIAL_CHAIN_INFORMATIONAL,
                m_pCertObject->CertContext(),
                TRUE        // fFormatIssuerName
                );
#endif

        goto NoAutoUpdateCtlEntry;
    }

    hIssuerUrlStore = CertOpenStore(
        CERT_STORE_PROV_MEMORY,
        0,                          // dwEncodingType
        NULL,                       // hCryptProv
        0,                          // dwFlags
        NULL                        // pvPara
        );
    if (NULL == hIssuerUrlStore)
        goto OpenMemoryStoreError;

    for (i = 0; i < cEntry; i++) {
        PCTL_ENTRY pEntry = rgpEntry[i];

        // If already in our store, no need to hit the wire and retrieve.
        if (pCert = CertFindCertificateInStore(
                pChainEngine->OtherStore(),
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                0,
                CERT_FIND_SHA1_HASH,
                (LPVOID) &pEntry->SubjectIdentifier,
                NULL
                )) {
            CertFreeCertificateContext(pCert);
            continue;
        }

        fTouchedResult = pChainEngine->GetAuthRootAutoUpdateCert(
            pCallContext,
            pEntry,
            hIssuerUrlStore
            );

        if (!fTouchedResult)
            goto TouchedDuringUrlRetrievalOfAuthRoots;
    }

    pCert = NULL;
    cCert = 0;
    while (pCert = CertEnumCertificatesInStore(hIssuerUrlStore, pCert))
        cCert++;

    if (0 == cCert)
        goto NoAuthRootAutoUpdateCerts;

    if (1 < cCert) {
        // If more than one root in the list, explicitly add them all here. 
        // While building the chain using the returned AuthRoots we might
        // leave the critical section and restart. After restarting may
        // have a trusted root and won't redo this URL retrieval.

        pChainEngine->UnlockEngine();

        pCert = NULL;
        while (pCert = CertEnumCertificatesInStore(hIssuerUrlStore, pCert))
            IPR_AddCertInAuthRootAutoUpdateCtl(pCert, pCtl);

        pChainEngine->LockEngine();
        if (pCallContext->IsTouchedEngine()) {
            fTouchedResult = FALSE;
            goto TouchedDuringAddOfAuthRoots;
        }
    }

    *phIssuerUrlStore = hIssuerUrlStore;
    
CommonReturn:
    if (rgpEntry)
        PkiFree(rgpEntry);
    if (pCtl)
        CertFreeCTLContext(pCtl);

    return fTouchedResult;
ErrorReturn:
    if (hIssuerUrlStore)
        CertCloseStore(hIssuerUrlStore, 0);
    goto CommonReturn;

TRACE_ERROR(NoAutoUpdateCtlEntry)
TRACE_ERROR(OpenMemoryStoreError)
TRACE_ERROR(TouchedDuringUrlRetrievalOfAuthRoots)
TRACE_ERROR(NoAuthRootAutoUpdateCerts)
TRACE_ERROR(TouchedDuringAddOfAuthRoots)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::RetrieveAuthRootAutoUpdateObjectByUrlW, public
//
//  Synopsis:   URL retrieves an AuthRoot Auto Update object. For wire
//              retrieval, logs the event.
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              If the object was successfully retrieved,
//              *ppvObject != NULL. Otherwise, *ppvObject = NULL.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section. *ppvObject may be != NULL
//              when touched.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::RetrieveAuthRootAutoUpdateObjectByUrlW(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN DWORD dwSuccessEventID,
    IN DWORD dwFailEventID,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszObjectOid,
    IN DWORD dwRetrievalFlags,
    IN DWORD dwTimeout,         // 0 => use default
    OUT LPVOID* ppvObject,
    IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    )
{
    BOOL fTouchedResult = TRUE;
    BOOL fResult;

    *ppvObject = NULL;
    if (0 == dwTimeout)
        dwTimeout = pCallContext->ChainPara()->dwUrlRetrievalTimeout;

    //
    // We are about to go on the wire to retrieve the object.
    // At this time we will release the chain engine lock so others can
    // go about there business while we wait for the protocols to do the
    // fetching.
    //

    UnlockEngine();

    // Note, the windows update server doesn't require authentication.
    // wininet sometimes calls us within a critical section. NO_AUTH
    // normally will fix this deadlock.
    //
    // On 09-May-01 the above was fixed by wininet.
    // Removed setting CRYPT_NO_AUTH_RETRIEVAL.
    //
    // Authentication may be required by a proxy.
    fResult = ChainRetrieveObjectByUrlW(
        pwszUrl,
        pszObjectOid,
        dwRetrievalFlags,
        dwTimeout,
        ppvObject,
        NULL,                               // hAsyncRetrieve
        NULL,                               // pCredentials
        NULL,                               // pvVerify
        pAuxInfo
        );

    if (dwRetrievalFlags & CRYPT_WIRE_ONLY_RETRIEVAL) {
        // Only log wire retrievals

        if (fResult) {
            LPCWSTR rgpwszStrings[1] = { pwszUrl };

            IPR_LogCrypt32Event(
                EVENTLOG_INFORMATION_TYPE,
                dwSuccessEventID,
                1,          // wNumStrings
                rgpwszStrings
                );
        } else
            IPR_LogCrypt32Error(
                dwFailEventID,
                pwszUrl,
                GetLastError()
                );
    }

    LockEngine();

    if (pCallContext->IsTouchedEngine()) {
        fTouchedResult = FALSE;
        goto TouchedDuringAuthRootObjectUrlRetrieval;
    }

    if (fResult)
        assert(*ppvObject);
    else
        assert(NULL == *ppvObject);

CommonReturn:
    return fTouchedResult;
ErrorReturn:
    goto CommonReturn;

SET_ERROR(TouchedDuringAuthRootObjectUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetAuthRootAutoUpdateCtl, public
//
//  Synopsis:   if auto update hasn't been disabled,
//              returns the AuthRoot Auto Update CTL. Hits the wire
//              if necessary to get a "fresh" CTL.
//
//              Note, 2 URL fetches. One for the SequenceNumber file. The
//              other for the CTL cab file. The SequenceNumber file
//              is small and bounded in size. If it matches the SequenceNumber
//              in an already retrieved CTL, then, no need to hit the
//              wire to retrive the larger CTL file. This optimization will
//              reduce the number of bytes needing to be fetched across the
//              wire. The CTL won't be updated that often.
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              If auto update has been disabled, returns TRUE and
//              *ppCtl = NULL.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section.
//
//              The returned pCtl is AddRef'ed.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetAuthRootAutoUpdateCtl(
    IN PCCHAINCALLCONTEXT pCallContext,
    OUT PCCTL_CONTEXT *ppCtl
    )
{
    BOOL fTouchedResult = TRUE;
    FILETIME CurrentTime;
    PAUTH_ROOT_AUTO_UPDATE_INFO pInfo;
    PCRYPT_BLOB_ARRAY pcbaSeq = NULL;
    PCRYPT_BLOB_ARRAY pcbaCab = NULL;
    PCCTL_CONTEXT pNewCtl = NULL;
    CRYPT_RETRIEVE_AUX_INFO RetrieveAuxInfo;
    DWORD i;

    *ppCtl = NULL;

    if ((pCallContext->CallOrEngineFlags() &
                CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE) ||
            IPR_IsAuthRootAutoUpdateDisabled())
        return TRUE;

    if (NULL == (pInfo = m_pAuthRootAutoUpdateInfo)) {
        if (NULL == (pInfo = CreateAuthRootAutoUpdateInfo()))
            return TRUE;
        m_pAuthRootAutoUpdateInfo = pInfo;
    }

    pCallContext->CurrentTime(&CurrentTime);

    memset(&RetrieveAuxInfo, 0, sizeof(RetrieveAuxInfo));
    RetrieveAuxInfo.cbSize = sizeof(RetrieveAuxInfo);

    // First try the cache. If unable to retrieve the seq file or
    // find a time valid CTL cab in the cache, hit the wire.
    for (i = 0; i <= 1; i++) {
        BOOL fResult;
        DWORD dwRetrievalFlags;
        DWORD dwCtlTimeout = 0;
        PCRYPT_INTEGER_BLOB pSequenceNumber;
        FILETIME NewLastSyncTime;
        FILETIME CtlLastSyncTime;
        PCTL_INFO pNewCtlInfo;

        if (pInfo->pCtl &&
                0 < CompareFileTime(&pInfo->NextSyncTime, &CurrentTime))
            // We already have a time valid CTL
            break;

        if (0 == i)
            dwRetrievalFlags = CRYPT_CACHE_ONLY_RETRIEVAL;
        else {
            if (!pCallContext->IsOnline())
                break;
            dwRetrievalFlags = CRYPT_WIRE_ONLY_RETRIEVAL;
        }

        // First try to fetch the CTL's sequence number file
        RetrieveAuxInfo.pLastSyncTime = &NewLastSyncTime;
        fTouchedResult = RetrieveAuthRootAutoUpdateObjectByUrlW(
            pCallContext,
            MSG_ROOT_SEQUENCE_NUMBER_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL,
            MSG_ROOT_SEQUENCE_NUMBER_AUTO_UPDATE_URL_RETRIEVAL_ERROR,
            pInfo->pwszSeqUrl,
            NULL,                   // pszObjectOid,
            dwRetrievalFlags |
                CRYPT_OFFLINE_CHECK_RETRIEVAL |
                CRYPT_STICKY_CACHE_RETRIEVAL,
            0,                      // dwTimeout (use default)
            (LPVOID*) &pcbaSeq,
            &RetrieveAuxInfo
            );
        if (!fTouchedResult)
            goto TouchedDuringAuthRootSeqUrlRetrieval;

        pSequenceNumber = NULL;
        if (NULL == pcbaSeq) {
            // SequenceNumber retrieval failed

            if (0 != i)
                // For wire retrieval failure, don't try to fetch the CTL
                continue;
        } else if (0 > CompareFileTime(&NewLastSyncTime,
                &pInfo->LastSyncTime)) {
            // An older sync time
            CryptMemFree(pcbaSeq);
            pcbaSeq = NULL;
        } else {
            // Extract the Sequence Number from the retrieved blob.
            // Convert the ascii hex characters to binary. Overwrite
            // the ascii hex with the converted bytes.
            // Convert binary to little endian.
            DWORD cchSeq;
            BOOL fUpperNibble = TRUE;
            DWORD cb = 0;
            DWORD j;

            pSequenceNumber = pcbaSeq->rgBlob;
            if (0 == pcbaSeq->cBlob)
                cchSeq = 0;
            else
                cchSeq = pSequenceNumber->cbData;

            for (j = 0; j < cchSeq; j++) {
                char ch = (char) pSequenceNumber->pbData[j];
                BYTE b;

                // only convert ascii hex characters 0..9, a..f, A..F
                // silently ignore all others
                if (ch >= '0' && ch <= '9')
                    b = (BYTE) (ch - '0');
                else if (ch >= 'a' && ch <= 'f')
                    b = (BYTE) (10 + ch - 'a');
                else if (ch >= 'A' && ch <= 'F')
                    b = (BYTE) (10 + ch - 'A');
                else
                    continue;
        
                if (fUpperNibble) {
                    pSequenceNumber->pbData[cb] = b << 4;
                    fUpperNibble = FALSE;
                } else {
                    pSequenceNumber->pbData[cb] |= b;
                    cb++;
                    fUpperNibble = TRUE;
                }
            }

            if (0 == cb) {
                // Empty sequence number.
                CryptMemFree(pcbaSeq);
                pcbaSeq = NULL;
            } else {
                pSequenceNumber->cbData = cb;

                PkiAsn1ReverseBytes(pSequenceNumber->pbData,
                    pSequenceNumber->cbData);

                // Check if we already have a CTL corresponding to this
                // fetched SequenceNumber
                if (pInfo->pCtl) {
                    PCTL_INFO pCtlInfo = pInfo->pCtl->pCtlInfo;

                    if (pCtlInfo->SequenceNumber.cbData ==
                            pSequenceNumber->cbData &&
                        0 == memcmp(pCtlInfo->SequenceNumber.pbData,
                                pSequenceNumber->pbData,
                                pSequenceNumber->cbData)) {
                        // Same CTL
                        pInfo->LastSyncTime = NewLastSyncTime;
                        I_CryptIncrementFileTimeBySeconds(
                            &pInfo->LastSyncTime,
                            pInfo->dwSyncDeltaTime,
                            &pInfo->NextSyncTime
                            );

                        CryptMemFree(pcbaSeq);
                        pcbaSeq = NULL;
                        continue;
                    }
                }

                // The SequenceNumber consists of the FILETIME followed by
                // an optional byte containing a hint for the CTL URL
                // retrieval timeout (in seconds). If we are using the
                // default retrieval timeout, use the hint if it exceeds
                // the default timeout.
                if (sizeof(FILETIME) < cb &&
                        pCallContext->HasDefaultUrlRetrievalTimeout()) {
                    dwCtlTimeout =
                        ((DWORD) pSequenceNumber->pbData[sizeof(FILETIME)]) *
                            1000;
                    if (dwCtlTimeout <
                            pCallContext->ChainPara()->dwUrlRetrievalTimeout)
                        dwCtlTimeout =
                            pCallContext->ChainPara()->dwUrlRetrievalTimeout;
                }
            }
        }

        // After retrieving the sequence number file, now
        // try to fetch the cab containing the CTL
        RetrieveAuxInfo.pLastSyncTime = &CtlLastSyncTime;
        fTouchedResult = RetrieveAuthRootAutoUpdateObjectByUrlW(
            pCallContext,
            MSG_ROOT_LIST_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL,
            MSG_ROOT_LIST_AUTO_UPDATE_URL_RETRIEVAL_ERROR,
            pInfo->pwszCabUrl,
            NULL,                   // pszObjectOid,
            dwRetrievalFlags |
                CRYPT_OFFLINE_CHECK_RETRIEVAL |
                CRYPT_STICKY_CACHE_RETRIEVAL,
            dwCtlTimeout,
            (LPVOID*) &pcbaCab,
            &RetrieveAuxInfo
            );
        if (!fTouchedResult)
            goto TouchedDuringAuthRootCabUrlRetrieval;

        if (NULL == pcbaCab) {
            // Cab Retrieval failed
            if (pcbaSeq) {
                CryptMemFree(pcbaSeq);
                pcbaSeq = NULL;
            }
            continue;
        }

        // Leave the engine to extract the CTL from the cab
        UnlockEngine();

        pNewCtl = ExtractAuthRootAutoUpdateCtlFromCab(pcbaCab);
        if (NULL == pNewCtl)
            IPR_LogCrypt32Error(
                MSG_ROOT_LIST_AUTO_UPDATE_EXTRACT_ERROR,
                pInfo->pwszCabUrl,
                GetLastError()
                );

        CryptMemFree(pcbaCab);
        pcbaCab = NULL;

        LockEngine();

        if (pCallContext->IsTouchedEngine()) {
            fTouchedResult = FALSE;
            goto TouchedDuringExtractAuthRootCtl;
        }

        if (NULL == pNewCtl) {
            // Ctl Extraction failed
            if (pcbaSeq) {
                CryptMemFree(pcbaSeq);
                pcbaSeq = NULL;
            }
            continue;
        }

        // If the SequenceNumber is the same as the one in the retrieved
        // Ctl, then, use the lastest sync of the 2 URL fetches. Otherwise,
        // use the Ctl sync time
        pNewCtlInfo = pNewCtl->pCtlInfo;
        if (NULL == pcbaSeq ||
                pNewCtlInfo->SequenceNumber.cbData != pSequenceNumber->cbData ||
                0 != memcmp(pNewCtlInfo->SequenceNumber.pbData,
                    pSequenceNumber->pbData, pSequenceNumber->cbData)
                            ||
                0 < CompareFileTime(&CtlLastSyncTime, &NewLastSyncTime))
            NewLastSyncTime = CtlLastSyncTime;

        // We are done with the SequenceNumber info
        if (pcbaSeq) {
            CryptMemFree(pcbaSeq);
            pcbaSeq = NULL;
        }

        if (0 >= CompareFileTime(&NewLastSyncTime, &pInfo->LastSyncTime)) {
            // Not a newer sync
            CertFreeCTLContext(pNewCtl);
            pNewCtl = NULL;
            continue;
        }
            
        if (pInfo->pCtl &&
                pInfo->pCtl->cbCtlEncoded == pNewCtl->cbCtlEncoded &&
                0 == memcmp(pInfo->pCtl->pbCtlEncoded,
                    pNewCtl->pbCtlEncoded, pNewCtl->cbCtlEncoded)) {
            // Same CTL
            pInfo->LastSyncTime = NewLastSyncTime;
            I_CryptIncrementFileTimeBySeconds(
                &pInfo->LastSyncTime,
                pInfo->dwSyncDeltaTime,
                &pInfo->NextSyncTime
            );

            CertFreeCTLContext(pNewCtl);
            pNewCtl = NULL;
            continue;
        }

        // Leave the engine to verify the CTL
        UnlockEngine();
        fResult = IRL_VerifyAuthRootAutoUpdateCtl(pNewCtl);
        if (!fResult)
            IPR_LogCrypt32Error(
                MSG_ROOT_LIST_AUTO_UPDATE_EXTRACT_ERROR,
                pInfo->pwszCabUrl,
                GetLastError()
                );
        LockEngine();

        if (fResult &&
                0 < CompareFileTime(&NewLastSyncTime, &pInfo->LastSyncTime)) {
            // Valid CTL that is newer

            pInfo->LastSyncTime = NewLastSyncTime;
            I_CryptIncrementFileTimeBySeconds(
                &pInfo->LastSyncTime,
                pInfo->dwSyncDeltaTime,
                &pInfo->NextSyncTime
            );

            FreeAuthRootAutoUpdateMatchCaches(pInfo->rghMatchCache);
            if (pInfo->pCtl)
                CertFreeCTLContext(pInfo->pCtl);
            pInfo->pCtl = pNewCtl;
            pNewCtl = NULL;
        }

        if (pCallContext->IsTouchedEngine()) {
            fTouchedResult = FALSE;
            goto TouchedDuringVerifyAuthRootCtl;
        }
    }

    if (pInfo->pCtl)
        *ppCtl = CertDuplicateCTLContext(pInfo->pCtl);

CommonReturn:
    if (pcbaSeq)
        CryptMemFree(pcbaSeq);
    if (pcbaCab)
        CryptMemFree(pcbaCab);
    if (pNewCtl)
        CertFreeCTLContext(pNewCtl);
    return fTouchedResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(TouchedDuringAuthRootSeqUrlRetrieval)
TRACE_ERROR(TouchedDuringAuthRootCabUrlRetrieval)
SET_ERROR(TouchedDuringExtractAuthRootCtl, ERROR_CAN_NOT_COMPLETE)
SET_ERROR(TouchedDuringVerifyAuthRootCtl, ERROR_CAN_NOT_COMPLETE)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::FindAuthRootAutoUpdateMatchingCtlEntries, public
//
//  Synopsis:   If the CTL hash match cache doesn't exist its created.
//              Iterates through the key and name hash cache entries.
//              Returns matching entries. Removes duplicates.
//              
//  Assumption: Chain engine is locked once in the calling thread.
//
//              The returned prgpCtlEntry must be PkiFree()'ed.
//
//              Note, if the engine's pCtl is different then the passed in
//              pCtl, the passed in pCtl is free'ed and updated with the
//              engine's.
//
//----------------------------------------------------------------------------
VOID
CCertChainEngine::FindAuthRootAutoUpdateMatchingCtlEntries(
    IN CRYPT_DATA_BLOB rgMatchHash[AUTH_ROOT_MATCH_CNT],
    IN OUT PCCTL_CONTEXT *ppCtl,
    OUT DWORD *pcCtlEntry,
    OUT PCTL_ENTRY **prgpCtlEntry
    )
{
    PAUTH_ROOT_AUTO_UPDATE_INFO pInfo;
    PCCTL_CONTEXT pCtl;
    DWORD cCtlEntry = 0;
    PCTL_ENTRY *rgpCtlEntry = NULL;
    DWORD i;

    pInfo = m_pAuthRootAutoUpdateInfo;
    if (NULL == pInfo || NULL == pInfo->pCtl)
        goto InvalidCtl;

    pCtl = *ppCtl;
    if (pCtl != pInfo->pCtl) {
        assert(pCtl);
        CertFreeCTLContext(pCtl);
        *ppCtl = pCtl = pInfo->pCtl;
        CertDuplicateCTLContext(pCtl);
    }

    if (!CreateAuthRootAutoUpdateMatchCaches(
            pCtl,
            pInfo->rghMatchCache
            ))
        goto CreateMatchCachesError;

    assert(pInfo->rghMatchCache[0]);
    assert(pInfo->rghMatchCache[AUTH_ROOT_MATCH_CNT - 1]);

    // Loop through the exact, key and name match hashes and try to find an
    // entry in the corresponding CTL match cache
    for (i = 0; i < AUTH_ROOT_MATCH_CNT; i++) {
        HLRUENTRY hEntry;

        if (0 == rgMatchHash[i].cbData)
            continue;

        hEntry = I_CryptFindLruEntry(pInfo->rghMatchCache[i], &rgMatchHash[i]);
        while (NULL != hEntry) {
            PCTL_ENTRY pCtlEntry;
            PCTL_ENTRY *rgpNewCtlEntry;
            DWORD j;

            pCtlEntry = (PCTL_ENTRY) I_CryptGetLruEntryData(hEntry);
            hEntry = I_CryptEnumMatchingLruEntries(hEntry);

            assert(pCtlEntry);
            if (NULL == pCtlEntry)
                continue;

            // Check if we already have this Ctl Entry
            for (j = 0; j < cCtlEntry; j++) {
                if (pCtlEntry == rgpCtlEntry[j])
                    break;
            }

            if (j < cCtlEntry)
                continue;
            
            if (NULL == (rgpNewCtlEntry = (PCTL_ENTRY *) PkiRealloc(
                    rgpCtlEntry, (cCtlEntry + 1) * sizeof(PCTL_ENTRY))))
                continue;

            rgpCtlEntry = rgpNewCtlEntry;
            rgpCtlEntry[cCtlEntry++] = pCtlEntry;
        }
    }

CommonReturn:
    *pcCtlEntry = cCtlEntry;
    *prgpCtlEntry = rgpCtlEntry;
    return;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(InvalidCtl)
TRACE_ERROR(CreateMatchCachesError)
}

//+---------------------------------------------------------------------------
//
//  Member:     CCertChainEngine::GetAuthRootAutoUpdateCert, public
//
//  Synopsis:   URL retrieval of the AuthRoot from the Microsoft web
//              server.
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section.
//
//----------------------------------------------------------------------------
BOOL
CCertChainEngine::GetAuthRootAutoUpdateCert(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCTL_ENTRY pCtlEntry,
    IN OUT HCERTSTORE hStore
    )
{
    BOOL fTouchedResult = TRUE;
    LPWSTR pwszCertUrl = NULL;
    HCERTSTORE hUrlStore = NULL;

    assert(m_pAuthRootAutoUpdateInfo);

    if (SHA1_HASH_LEN != pCtlEntry->SubjectIdentifier.cbData)
        goto InvalidCtlEntryError;

    if (NULL == (pwszCertUrl = FormatAuthRootAutoUpdateCertUrl(
            pCtlEntry->SubjectIdentifier.pbData,
            m_pAuthRootAutoUpdateInfo
            )))
        goto FormatCertUrlError;

    fTouchedResult = RetrieveAuthRootAutoUpdateObjectByUrlW(
        pCallContext,
        MSG_ROOT_CERT_AUTO_UPDATE_URL_RETRIEVAL_INFORMATIONAL,
        MSG_ROOT_CERT_AUTO_UPDATE_URL_RETRIEVAL_ERROR,
        pwszCertUrl,
        CONTEXT_OID_CERTIFICATE,
        CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
            CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL |
            CRYPT_OFFLINE_CHECK_RETRIEVAL |
            CRYPT_WIRE_ONLY_RETRIEVAL |
            CRYPT_DONT_CACHE_RESULT,
        0,              // dwTimeout (use default)
        (LPVOID *) &hUrlStore,
        NULL                                // pAuxInfo
        );
    if (!fTouchedResult)
        goto TouchedDuringAuthRootCertUrlRetrieval;

    if (hUrlStore)
        I_CertUpdateStore(hStore, hUrlStore, 0, NULL);

CommonReturn:
    PkiFree(pwszCertUrl);
    if (hUrlStore)
        CertCloseStore(hUrlStore, 0);
    return fTouchedResult;
ErrorReturn:
    goto CommonReturn;
SET_ERROR(InvalidCtlEntryError, ERROR_INVALID_DATA)
TRACE_ERROR(FormatCertUrlError)
TRACE_ERROR(TouchedDuringAuthRootCertUrlRetrieval)
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateAuthRootAutoUpdateInfo
//
//  Synopsis:   creates and initializes the AuthRoot Auto Update info
//
//----------------------------------------------------------------------------
PAUTH_ROOT_AUTO_UPDATE_INFO WINAPI
CreateAuthRootAutoUpdateInfo()
{
    HKEY hKey = NULL;
    PAUTH_ROOT_AUTO_UPDATE_INFO pInfo = NULL;
    DWORD cchDir;
    DWORD cchUrl;

    if (NULL == (pInfo = (PAUTH_ROOT_AUTO_UPDATE_INFO) PkiZeroAlloc(
            sizeof(AUTH_ROOT_AUTO_UPDATE_INFO))))
        goto OutOfMemory;

    if (ERROR_SUCCESS != RegOpenKeyExU(
            HKEY_LOCAL_MACHINE,
            CERT_AUTH_ROOT_AUTO_UPDATE_LOCAL_MACHINE_REGPATH,
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))
        hKey = NULL;

    if (hKey) {
        // Attempt to get values from registry

        ILS_ReadDWORDValueFromRegistry(
            hKey,
            CERT_AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME_VALUE_NAME,
            &pInfo->dwSyncDeltaTime
            );

        ILS_ReadDWORDValueFromRegistry(
            hKey,
            CERT_AUTH_ROOT_AUTO_UPDATE_FLAGS_VALUE_NAME,
            &pInfo->dwFlags
            );

        pInfo->pwszRootDirUrl = ILS_ReadSZValueFromRegistry(
            hKey,
            CERT_AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL_VALUE_NAME
            );
        if (pInfo->pwszRootDirUrl && L'\0' == *pInfo->pwszRootDirUrl) {
            PkiFree(pInfo->pwszRootDirUrl);
            pInfo->pwszRootDirUrl = NULL;
        }
    }

    // If not defined in registry, use our defaults

    if (0 == pInfo->dwSyncDeltaTime)
        pInfo->dwSyncDeltaTime = AUTH_ROOT_AUTO_UPDATE_SYNC_DELTA_TIME;

    if (NULL == pInfo->pwszRootDirUrl) {
        if (NULL == (pInfo->pwszRootDirUrl = ILS_AllocAndCopyString(
                AUTH_ROOT_AUTO_UPDATE_ROOT_DIR_URL)))
            goto OutOfMemory;
    }

    // Construct the CTL and Seq Urls
    cchDir = wcslen(pInfo->pwszRootDirUrl);

    cchUrl = cchDir + 1 + wcslen(CERT_AUTH_ROOT_CAB_FILENAME) + 1;
    if (NULL == (pInfo->pwszCabUrl = (LPWSTR) PkiNonzeroAlloc(
            sizeof(WCHAR) * cchUrl)))
        goto OutOfMemory;
    wcscpy(pInfo->pwszCabUrl, pInfo->pwszRootDirUrl);
    pInfo->pwszCabUrl[cchDir] = L'/';
    wcscpy(pInfo->pwszCabUrl + cchDir + 1, CERT_AUTH_ROOT_CAB_FILENAME);

    cchUrl = cchDir + 1 + wcslen(CERT_AUTH_ROOT_SEQ_FILENAME) + 1;
    if (NULL == (pInfo->pwszSeqUrl = (LPWSTR) PkiNonzeroAlloc(
            sizeof(WCHAR) * cchUrl)))
        goto OutOfMemory;
    wcscpy(pInfo->pwszSeqUrl, pInfo->pwszRootDirUrl);
    pInfo->pwszSeqUrl[cchDir] = L'/';
    wcscpy(pInfo->pwszSeqUrl + cchDir + 1, CERT_AUTH_ROOT_SEQ_FILENAME);

CommonReturn:
    ILS_CloseRegistryKey(hKey);
    return pInfo;

ErrorReturn:
    FreeAuthRootAutoUpdateInfo(pInfo);
    pInfo = NULL;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeAuthRootAutoUpdateInfo
//
//  Synopsis:   frees the AuthRoot Auto Update info
//
//----------------------------------------------------------------------------
VOID WINAPI
FreeAuthRootAutoUpdateInfo(
    IN OUT PAUTH_ROOT_AUTO_UPDATE_INFO pInfo
    )
{
    if (NULL == pInfo)
        return;

    PkiFree(pInfo->pwszRootDirUrl);
    PkiFree(pInfo->pwszCabUrl);
    PkiFree(pInfo->pwszSeqUrl);

    FreeAuthRootAutoUpdateMatchCaches(pInfo->rghMatchCache);

    if (pInfo->pCtl)
        CertFreeCTLContext(pInfo->pCtl);

    PkiFree(pInfo);
}

const LPCSTR rgpszAuthRootMatchOID[AUTH_ROOT_MATCH_CNT] = {
    szOID_CERT_KEY_IDENTIFIER_PROP_ID,
    szOID_CERT_SUBJECT_NAME_MD5_HASH_PROP_ID
};

//+---------------------------------------------------------------------------
//
//  Function:   CreateAuthRootAutoUpdateMatchCaches
//
//  Synopsis:   if not already created, iterates through the CTL entries
//              and creates key and name match caches entries from
//              the associated entry hash attribute values.
//
//----------------------------------------------------------------------------
BOOL WINAPI
CreateAuthRootAutoUpdateMatchCaches(
    IN PCCTL_CONTEXT pCtl,
    IN OUT HLRUCACHE  rghMatchCache[AUTH_ROOT_MATCH_CNT]
    )
{
    BOOL fResult;
    LRU_CACHE_CONFIG Config;
    DWORD i;
    DWORD cEntry;
    PCTL_ENTRY pEntry;

    if (NULL != rghMatchCache[0])
        // Already created.
        return TRUE;

    memset( &Config, 0, sizeof( Config ) );
    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.pfnHash = CertObjectCacheHashMd5Identifier;
    Config.cBuckets = AUTH_ROOT_MATCH_CACHE_BUCKETS;

    for (i = 0; i < AUTH_ROOT_MATCH_CNT; i++) {
        if (!I_CryptCreateLruCache(&Config, &rghMatchCache[i]))
            goto CreateLruCacheError;
    }

    // Loop through the CTL entries and add the exact, key and name match
    // hash cache entries
    cEntry = pCtl->pCtlInfo->cCTLEntry;
    pEntry = pCtl->pCtlInfo->rgCTLEntry;
    for ( ; cEntry > 0; cEntry--, pEntry++) {
        DWORD cAttr;
        PCRYPT_ATTRIBUTE pAttr;

        cAttr = pEntry->cAttribute;
        pAttr = pEntry->rgAttribute;

        // Skip a remove entry
        if (CertFindAttribute(
                szOID_REMOVE_CERTIFICATE,
                cAttr,
                pAttr
                ))
            continue;

        for ( ; cAttr > 0; cAttr--, pAttr++) {
            for (i = 0; i < AUTH_ROOT_MATCH_CNT; i++) {
                if (0 == strcmp(rgpszAuthRootMatchOID[i], pAttr->pszObjId))
                    break;
            }

            if (i < AUTH_ROOT_MATCH_CNT) {
                PCRYPT_ATTR_BLOB pValue;
                DWORD cbHash;
                const BYTE *pbHash;
                CRYPT_DATA_BLOB DataBlob;
                HLRUENTRY hEntry = NULL;

                // Check that we have a single valued attribute encoded as an
                // OCTET STRING
                if (1 != pAttr->cValue)
                    continue;

                pValue = pAttr->rgValue;
                if (2 > pValue->cbData ||
                        ASN1UTIL_TAG_OCTETSTRING != pValue->pbData[0])
                    continue;

                // Extract the hash bytes from the encoded OCTET STRING
                if (0 >= Asn1UtilExtractContent(
                        pValue->pbData,
                        pValue->cbData,
                        &cbHash,
                        &pbHash
                        ) || CMSG_INDEFINITE_LENGTH == cbHash || 0 == cbHash)
                    continue;

                DataBlob.cbData = cbHash;
                DataBlob.pbData = (BYTE *) pbHash;
                if (!I_CryptCreateLruEntry(
                        rghMatchCache[i],
                        &DataBlob,
                        pEntry,
                        &hEntry
                        ))
                    goto CreateLruEntryError;
                I_CryptInsertLruEntry(hEntry, NULL);
                I_CryptReleaseLruEntry(hEntry);
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    FreeAuthRootAutoUpdateMatchCaches(rghMatchCache);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateLruCacheError)
TRACE_ERROR(CreateLruEntryError)
}


//+---------------------------------------------------------------------------
//
//  Function:   FreeAuthRootAutoUpdateMatchCaches
//
//  Synopsis:   frees the AuthRoot Auto Match Caches
//
//----------------------------------------------------------------------------
VOID WINAPI
FreeAuthRootAutoUpdateMatchCaches(
    IN OUT HLRUCACHE  rghMatchCache[AUTH_ROOT_MATCH_CNT]
    )
{
    DWORD i;

    for (i = 0; i < AUTH_ROOT_MATCH_CNT; i++) {
        if (NULL != rghMatchCache[i]) {
            I_CryptFreeLruCache(
                rghMatchCache[i],
                LRU_SUPPRESS_REMOVAL_NOTIFICATION,
                NULL
                );
            rghMatchCache[i] = NULL;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   FormatAuthRootAutoUpdateCertUrl
//
//  Synopsis:   allocates and formats the URL to retrieve the auth root cert
//
//              returns "RootDir" "/" "AsciiHexHash" ".cer"
//              for example,
//  "http://www.xyz.com/roots/216B2A29E62A00CE820146D8244141B92511B279.cer"
//
//----------------------------------------------------------------------------
LPWSTR WINAPI
FormatAuthRootAutoUpdateCertUrl(
    IN BYTE rgbSha1Hash[SHA1_HASH_LEN],
    IN PAUTH_ROOT_AUTO_UPDATE_INFO pInfo
    )
{
    LPWSTR pwszUrl;
    DWORD cchDir;
    DWORD cchUrl;

    assert(pInfo->pwszRootDirUrl);

    cchDir = wcslen(pInfo->pwszRootDirUrl);

    cchUrl = cchDir + 1 + SHA1_HASH_NAME_LEN +
        wcslen(CERT_AUTH_ROOT_CERT_EXT) + 1;

    if (NULL == (pwszUrl = (LPWSTR) PkiNonzeroAlloc(sizeof(WCHAR) * cchUrl)))
        return NULL;

    wcscpy(pwszUrl, pInfo->pwszRootDirUrl);
    pwszUrl[cchDir] = L'/';
    ILS_BytesToWStr(SHA1_HASH_LEN, rgbSha1Hash, pwszUrl + cchDir + 1);
    wcscpy(pwszUrl + cchDir + 1 + SHA1_HASH_NAME_LEN, CERT_AUTH_ROOT_CERT_EXT);
    return pwszUrl;
}

// Known invalid roots
BYTE AuthRootInvalidList[][SHA1_HASH_LEN] = {
    // verisign "timestamp" - '97
    { 0xD4, 0x73, 0x5D, 0x8A, 0x9A, 0xE5, 0xBC, 0x4B, 0x0A, 0x0D,
      0xC2, 0x70, 0xD6, 0xA6, 0x25, 0x38, 0xA5, 0x87, 0xD3, 0x2F },

    // Root Agency (test root)
    { 0xFE, 0xE4, 0x49, 0xEE, 0x0E, 0x39, 0x65, 0xA5, 0x24, 0x6F,
      0x00, 0x0E, 0x87, 0xFD, 0xE2, 0xA0, 0x65, 0xFD, 0x89, 0xD4 },
};

#define AUTH_ROOT_INVALID_LIST_CNT  (sizeof(AuthRootInvalidList) / \
                                        sizeof(AuthRootInvalidList[0]))

//+---------------------------------------------------------------------------
//
//  Function:   ChainGetAuthRootAutoUpdateStatus
//
//  Synopsis:   return status bits specifying if the root is 
//              trusted via the AuthRoot Auto Update CTL.
//
//              Leaves the engine's critical section to URL retrieve and
//              validate the CTL. Also leaves critical section to
//              add the cert to the AuthRoot store via crypt32 service.
//              If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//              Only returns FALSE, if the engine was touched when
//              leaving the critical section.
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainGetAuthRootAutoUpdateStatus (
    IN PCCHAINCALLCONTEXT pCallContext,
    IN PCCERTOBJECT pCertObject,
    IN OUT DWORD *pdwIssuerStatusFlags
    )
{
    BOOL fTouchedResult = TRUE;
    BOOL fResult;
    PCCERTCHAINENGINE pChainEngine = pCallContext->ChainEngine();
    PCCERT_CONTEXT pCert = pCertObject->CertContext();
    PCCTL_CONTEXT pCtl = NULL;
    PCTL_ENTRY pCtlEntry;
    PCERT_BASIC_CONSTRAINTS2_INFO pBasicConstraintsInfo;

    DWORD i;
    DWORD cbData;
    BYTE rgbSha1Hash[SHA1_HASH_LEN];

    // Check if the root has an end entity basic constraint. These can't
    // be used for roots.
    pBasicConstraintsInfo = pCertObject->BasicConstraintsInfo();
    if (pBasicConstraintsInfo && !pBasicConstraintsInfo->fCA)
        return TRUE;

    // Check if a known invalid root, such as, expired timestamp
    // root or the "Root Agency" test root. Don't want all clients in the
    // world hiting the wire for these guys.
    cbData = SHA1_HASH_LEN;
    if (!CertGetCertificateContextProperty(
              pCert,
              CERT_SHA1_HASH_PROP_ID,
              rgbSha1Hash,
              &cbData
              ) || SHA1_HASH_LEN != cbData)
        goto GetSha1HashPropertyError;

    for (i = 0; i < AUTH_ROOT_INVALID_LIST_CNT; i++) {
        if (0 == memcmp(AuthRootInvalidList[i], rgbSha1Hash, SHA1_HASH_LEN))
            return TRUE;
    }

    // Check if this certificate has an associated private key. Such
    // certificates are generated by EFS.
    cbData = 0;
    if (CertGetCertificateContextProperty(
              pCert,
              CERT_KEY_PROV_INFO_PROP_ID,
              NULL,                     // pbData
              &cbData) && 0 < cbData)
        return TRUE;


    fTouchedResult = pChainEngine->GetAuthRootAutoUpdateCtl(
        pCallContext,
        &pCtl
        );

    if (!fTouchedResult || NULL == pCtl) {

#if 0
// This logs too many test failures

        if (fTouchedResult) {
            PAUTH_ROOT_AUTO_UPDATE_INFO pInfo =
                pChainEngine->AuthRootAutoUpdateInfo();

            if (NULL == pInfo || !(pInfo->dwFlags &
                    CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG))
                IPR_LogCertInformation(
                    MSG_UNTRUSTED_ROOT_INFORMATIONAL,
                    pCert,
                    FALSE       // fFormatIssuerName
                    );
        }
#endif

        return fTouchedResult;
    }

    if (NULL == (pCtlEntry = CertFindSubjectInCTL(
            pCert->dwCertEncodingType,
            CTL_CERT_SUBJECT_TYPE,
            (void *) pCert,
            pCtl,
            0                           // dwFlags
            ))) {

#if 0
// This logs too many test failures

        PAUTH_ROOT_AUTO_UPDATE_INFO pInfo =
            pChainEngine->AuthRootAutoUpdateInfo();

        if (NULL == pInfo || !(pInfo->dwFlags &
                CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG))
            IPR_LogCertInformation(
                MSG_UNTRUSTED_ROOT_INFORMATIONAL,
                pCert,
                FALSE       // fFormatIssuerName
                );
#endif

        goto CommonReturn;
    }

    // Check if a remove entry
    if (CertFindAttribute(
            szOID_REMOVE_CERTIFICATE,
            pCtlEntry->cAttribute,
            pCtlEntry->rgAttribute
            ))
        goto CommonReturn;

    pChainEngine->UnlockEngine();
    fResult = IPR_AddCertInAuthRootAutoUpdateCtl(pCert, pCtl);
    pChainEngine->LockEngine();
    if (pCallContext->IsTouchedEngine()) {
        fTouchedResult = FALSE;
        goto TouchedDuringAddAuthRootInCtl;
    }

    if (fResult && CertSetCertificateContextPropertiesFromCTLEntry(
            pCert,
            pCtlEntry,
            CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG
            ))
        *pdwIssuerStatusFlags |= CERT_ISSUER_TRUSTED_ROOT_FLAG;

CommonReturn:
    if (pCtl)
        CertFreeCTLContext(pCtl);

    return fTouchedResult;
ErrorReturn:
    goto CommonReturn;

TRACE_ERROR(GetSha1HashPropertyError)
SET_ERROR(TouchedDuringAddAuthRootInCtl, ERROR_CAN_NOT_COMPLETE)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\defce.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       defce.h
//
//  Contents:   Default Chain Engine Manager
//
//  History:    21-Apr-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__DEFCE_H__)
#define __DEFCE_H__

//
// Forward class declarations
//

class CDefaultChainEngineMgr;
class CImpersonationEngine;

//
// Class pointer definitions
//

typedef CDefaultChainEngineMgr* PCDEFAULTCHAINENGINEMGR;
typedef CImpersonationEngine*   PCIMPERSONATIONENGINE;

//
// Some default definitions
//

#define DEFAULT_ENGINE_URL_RETRIEVAL_TIMEOUT 15000

//
// CDefaultChainEngineMgr.  Manage the default chain engines
//

class CDefaultChainEngineMgr
{
public:

    //
    // Constructor
    //

    CDefaultChainEngineMgr ();
    ~CDefaultChainEngineMgr ();

    //
    // Initialization
    //

    BOOL Initialize ();
    VOID Uninitialize ();

    //
    // Get default chain engines
    //

    BOOL GetDefaultEngine (
            IN HCERTCHAINENGINE hDefaultHandle,
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL GetDefaultLocalMachineEngine (
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL GetDefaultCurrentUserEngine (
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    //
    // Flush default engines
    //

    VOID FlushDefaultEngine (IN HCERTCHAINENGINE hDefaultHandle);

private:

    //
    // Lock
    //

    CRITICAL_SECTION m_Lock;

    //
    // Local Machine Default Engine
    //

    HCERTCHAINENGINE m_hLocalMachineEngine;

    //
    // Process User Default Engine
    //

    HCERTCHAINENGINE m_hProcessUserEngine;

    //
    // Impersonated Users Default Engine Cache
    //

    HLRUCACHE        m_hImpersonationCache;

    //
    // Private methods
    //

    BOOL GetDefaultCurrentImpersonatedUserEngine (
            IN HANDLE hUserToken,
            OUT HCERTCHAINENGINE* phDefaultEngine
            );

    BOOL IsImpersonatingUser (
           OUT HANDLE* phUserToken
           );

    BOOL GetTokenId (
            IN HANDLE hUserToken,
            OUT PCRYPT_DATA_BLOB pTokenId
            );

    VOID FreeTokenId (
             IN PCRYPT_DATA_BLOB pTokenId
             );

    BOOL FindImpersonationEngine (
             IN PCRYPT_DATA_BLOB pTokenId,
             OUT PCIMPERSONATIONENGINE* ppEngine
             );

    // NOTE: The impersonation engine accepts ownership of the chain engine
    //       upon success
    BOOL CreateImpersonationEngine (
               IN PCRYPT_DATA_BLOB pTokenId,
               IN HCERTCHAINENGINE hChainEngine,
               OUT PCIMPERSONATIONENGINE* ppEngine
               );

    VOID AddToImpersonationCache (
            IN PCIMPERSONATIONENGINE pEngine
            );
};

VOID WINAPI
DefaultChainEngineMgrOnImpersonationEngineRemoval (
       IN LPVOID pv,
       IN LPVOID pvRemovalContext
       );

DWORD WINAPI
DefaultChainEngineMgrHashTokenIdentifier (
       IN PCRYPT_DATA_BLOB pIdentifier
       );

#define DEFAULT_IMPERSONATION_CACHE_BUCKETS 3
#define MAX_IMPERSONATION_CACHE_ENTRIES     3

//
// CImpersonationEngine, simply a ref-counted chain engine handle which
// can be added to the LRU cache
//

class CImpersonationEngine
{
public:

    //
    // Constructor
    //

    CImpersonationEngine (
                  IN HLRUCACHE hCache,
                  IN HCERTCHAINENGINE hChainEngine,
                  IN PCRYPT_DATA_BLOB pTokenId,
                  OUT BOOL& rfResult
                  );

    ~CImpersonationEngine ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Access to the chain engine
    //

    inline HCERTCHAINENGINE ChainEngine ();

    //
    // Access to the LRU entry handle
    //

    inline HLRUENTRY LruEntry ();

private:

    //
    // Reference count
    //

    ULONG            m_cRefs;

    //
    // Chain Engine
    //

    HCERTCHAINENGINE m_hChainEngine;

    //
    // LRU entry handle
    //

    HLRUENTRY        m_hLruEntry;
};

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::AddRef, public
//
//  Synopsis:   add a reference to the object
//
//----------------------------------------------------------------------------
inline VOID
CImpersonationEngine::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::Release, public
//
//  Synopsis:   release a reference on the object
//
//----------------------------------------------------------------------------
inline VOID
CImpersonationEngine::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::ChainEngine, public
//
//  Synopsis:   return the cert chain engine
//
//----------------------------------------------------------------------------
inline HCERTCHAINENGINE
CImpersonationEngine::ChainEngine ()
{
    return( m_hChainEngine );
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::LruEntry, public
//
//  Synopsis:   return the LRU entry handle
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CImpersonationEngine::LruEntry ()
{
    return( m_hLruEntry );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\defce.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       defce.cpp
//
//  Contents:   Default Chain Engine Manager
//
//  History:    21-Apr-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::CDefaultChainEngineMgr, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CDefaultChainEngineMgr::CDefaultChainEngineMgr ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::~CDefaultChainEngineMgr, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CDefaultChainEngineMgr::~CDefaultChainEngineMgr ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::Initialize, public
//
//  Synopsis:   initialization routine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::Initialize ()
{
    LRU_CACHE_CONFIG Config;

    if (!Pki_InitializeCriticalSection( &m_Lock ))
    {
        return FALSE;
    }

    m_hLocalMachineEngine = NULL;
    m_hProcessUserEngine = NULL;
    m_hImpersonationCache = NULL;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
    Config.cBuckets = DEFAULT_IMPERSONATION_CACHE_BUCKETS;
    Config.MaxEntries = MAX_IMPERSONATION_CACHE_ENTRIES;
    Config.pfnHash = DefaultChainEngineMgrHashTokenIdentifier;
    Config.pfnOnRemoval = DefaultChainEngineMgrOnImpersonationEngineRemoval;

    if (!I_CryptCreateLruCache( &Config, &m_hImpersonationCache ) )
    {
        DeleteCriticalSection( &m_Lock );
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::Uninitialize, public
//
//  Synopsis:   uninitialization routine
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::Uninitialize ()
{
    if ( m_hLocalMachineEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hLocalMachineEngine );
    }

    if ( m_hProcessUserEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hProcessUserEngine );
    }

    if ( m_hImpersonationCache != NULL )
    {
        I_CryptFreeLruCache( m_hImpersonationCache, 0, NULL );
    }

    DeleteCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultEngine, public
//
//  Synopsis:   get the default engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultEngine (
                           IN HCERTCHAINENGINE hDefaultHandle,
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    assert( ( hDefaultHandle == HCCE_LOCAL_MACHINE ) ||
            ( hDefaultHandle == HCCE_CURRENT_USER ) );

    if ( hDefaultHandle == HCCE_LOCAL_MACHINE )
    {
        return( GetDefaultLocalMachineEngine( phDefaultEngine ) );
    }
    else if ( hDefaultHandle == HCCE_CURRENT_USER )
    {
        return( GetDefaultCurrentUserEngine( phDefaultEngine ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultLocalMachineEngine, public
//
//  Synopsis:   get the default local machine chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultLocalMachineEngine (
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL fResult = TRUE;

    EnterCriticalSection( &m_Lock );

    if ( m_hLocalMachineEngine == NULL )
    {
        HCERTCHAINENGINE         hEngine = NULL;
        CERT_CHAIN_ENGINE_CONFIG Config;

        LeaveCriticalSection( &m_Lock );

        memset( &Config, 0, sizeof( Config ) );

        Config.cbSize = sizeof( Config );
        Config.dwFlags = CERT_CHAIN_USE_LOCAL_MACHINE_STORE;
        Config.dwFlags |= CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE |
            CERT_CHAIN_ENABLE_SHARE_STORE;

        fResult = CertCreateCertificateChainEngine(
                      &Config,
                      &hEngine
                      );

        EnterCriticalSection( &m_Lock );

        if ( ( fResult == TRUE ) && ( m_hLocalMachineEngine == NULL ) )
        {
            m_hLocalMachineEngine = hEngine;
            hEngine = NULL;
        }

        if ( hEngine != NULL )
        {
            ( (PCCERTCHAINENGINE)hEngine )->Release();
        }
    }

    if ( fResult == TRUE )
    {
        ( (PCCERTCHAINENGINE)m_hLocalMachineEngine )->AddRef();
        *phDefaultEngine = m_hLocalMachineEngine;
    }

    LeaveCriticalSection( &m_Lock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultCurrentUserEngine, public
//
//  Synopsis:   get the default current user chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultCurrentUserEngine (
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL   fResult = TRUE;
    HANDLE hUserToken;

    EnterCriticalSection( &m_Lock );

    if ( IsImpersonatingUser( &hUserToken ) == FALSE )
    {
        if ( GetLastError() != ERROR_NO_TOKEN )
        {
            LeaveCriticalSection( &m_Lock );
            return( FALSE );
        }

        if ( m_hProcessUserEngine == NULL )
        {
            HCERTCHAINENGINE         hEngine = NULL;
            CERT_CHAIN_ENGINE_CONFIG Config;

            LeaveCriticalSection( &m_Lock );

            memset( &Config, 0, sizeof( Config ) );

            Config.cbSize = sizeof( Config );
            Config.dwFlags |= CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE |
                CERT_CHAIN_ENABLE_SHARE_STORE;

            fResult = CertCreateCertificateChainEngine(
                          &Config,
                          &hEngine
                          );

            EnterCriticalSection( &m_Lock );

            if ( ( fResult == TRUE ) && ( m_hProcessUserEngine == NULL ) )
            {
                m_hProcessUserEngine = hEngine;
                hEngine = NULL;
            }

            if ( hEngine != NULL )
            {
                ( (PCCERTCHAINENGINE)hEngine )->Release();
            }
        }

        if ( fResult == TRUE )
        {
            ( (PCCERTCHAINENGINE)m_hProcessUserEngine )->AddRef();
            *phDefaultEngine = m_hProcessUserEngine;
        }
    }
    else
    {
        fResult = GetDefaultCurrentImpersonatedUserEngine(
                     hUserToken,
                     phDefaultEngine
                     );

        CloseHandle( hUserToken );
    }

    LeaveCriticalSection( &m_Lock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FlushDefaultEngine, public
//
//  Synopsis:   flush default engine
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::FlushDefaultEngine (IN HCERTCHAINENGINE hDefaultHandle)
{
    HCERTCHAINENGINE hEngine = NULL;
    HLRUCACHE        hCacheToFree = NULL;
    HLRUCACHE        hCache = NULL;
    LRU_CACHE_CONFIG Config;

    EnterCriticalSection( &m_Lock );

    if ( hDefaultHandle == HCCE_CURRENT_USER )
    {
        hEngine = m_hProcessUserEngine;
        m_hProcessUserEngine = NULL;

        assert( m_hImpersonationCache != NULL );

        memset( &Config, 0, sizeof( Config ) );

        Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
        Config.cBuckets = DEFAULT_IMPERSONATION_CACHE_BUCKETS;
        Config.MaxEntries = MAX_IMPERSONATION_CACHE_ENTRIES;
        Config.pfnHash = DefaultChainEngineMgrHashTokenIdentifier;
        Config.pfnOnRemoval = DefaultChainEngineMgrOnImpersonationEngineRemoval;

        if ( I_CryptCreateLruCache( &Config, &hCache ) == TRUE )
        {
            hCacheToFree = m_hImpersonationCache;
            m_hImpersonationCache = hCache;
        }
        else
        {
            I_CryptFlushLruCache( m_hImpersonationCache, 0, NULL );
        }

        assert( m_hImpersonationCache != NULL );
    }
    else if ( hDefaultHandle == HCCE_LOCAL_MACHINE )
    {
        hEngine = m_hLocalMachineEngine;
        m_hLocalMachineEngine = NULL;
    }

    LeaveCriticalSection( &m_Lock );

    if ( hEngine != NULL )
    {
        CertFreeCertificateChainEngine( hEngine );
    }

    if ( hCacheToFree != NULL )
    {
        I_CryptFreeLruCache( hCacheToFree, 0, NULL );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetDefaultCurrentImpersonatedUserEngine
//
//  Synopsis:   get current impersonated user chain engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetDefaultCurrentImpersonatedUserEngine (
                           IN HANDLE hUserToken,
                           OUT HCERTCHAINENGINE* phDefaultEngine
                           )
{
    BOOL                  fResult;
    CRYPT_DATA_BLOB       TokenId;
    PCIMPERSONATIONENGINE pEngine = NULL;
    HCERTCHAINENGINE      hChainEngine = NULL;

    fResult = GetTokenId( hUserToken, &TokenId );

    if ( fResult == TRUE )
    {
        if ( FindImpersonationEngine( &TokenId, &pEngine ) == FALSE )
        {
            CERT_CHAIN_ENGINE_CONFIG Config;

            LeaveCriticalSection( &m_Lock );

            memset( &Config, 0, sizeof( Config ) );

            Config.cbSize = sizeof( Config );
            Config.dwFlags |= CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE |
                CERT_CHAIN_ENABLE_SHARE_STORE;

            fResult = CertCreateCertificateChainEngine(
                          &Config,
                          &hChainEngine
                          );

            EnterCriticalSection( &m_Lock );

            if ( fResult == TRUE )
            {
                fResult = FindImpersonationEngine( &TokenId, &pEngine );

                if ( fResult == FALSE )
                {
                    fResult = CreateImpersonationEngine(
                                    &TokenId,
                                    hChainEngine,
                                    &pEngine
                                    );

                    if ( fResult == TRUE )
                    {
                        hChainEngine = NULL;
                        AddToImpersonationCache( pEngine );
                    }
                }
            }
        }

        FreeTokenId( &TokenId );
    }

    if ( fResult == TRUE )
    {
        *phDefaultEngine = pEngine->ChainEngine();
        ( (PCCERTCHAINENGINE)*phDefaultEngine )->AddRef();
    }

    if ( pEngine != NULL )
    {
        pEngine->Release();
    }

    // NOTE: This release of the lock to free the unneeded chain engine handle
    //       must happen AFTER we're done with the impersonation engine and
    //       have addref'd the appropriate chain engine handle

    if ( hChainEngine != NULL )
    {
        LeaveCriticalSection( &m_Lock );

        CertFreeCertificateChainEngine( hChainEngine );

        EnterCriticalSection( &m_Lock );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::IsImpersonatingUser, public
//
//  Synopsis:   is impersonating user?
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::IsImpersonatingUser (
                          OUT HANDLE* phUserToken
                          )
{
    if ( FIsWinNT() == FALSE )
    {
        SetLastError( ERROR_NO_TOKEN );
        return( FALSE );
    }

    return( OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY,
                TRUE,
                phUserToken
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::GetTokenId, public
//
//  Synopsis:   get the token id which is the ModifiedId LUID inside of
//              the TOKEN_STATISTICS information
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::GetTokenId (
                           IN HANDLE hUserToken,
                           OUT PCRYPT_DATA_BLOB pTokenId
                           )
{
    BOOL             fResult;
    TOKEN_STATISTICS ts;
    DWORD            Length = 0;

    fResult = GetTokenInformation(
                 hUserToken,
                 TokenStatistics,
                 &ts,
                 sizeof( ts ),
                 &Length
                 );

    if ( fResult == TRUE )
    {
        pTokenId->cbData = sizeof( ts.ModifiedId );
        pTokenId->pbData = new BYTE [ sizeof( ts.ModifiedId ) ];
        if ( pTokenId->pbData != NULL )
        {
            memcpy(
               pTokenId->pbData,
               &ts.ModifiedId,
               sizeof( ts.ModifiedId )
               );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FreeTokenId, public
//
//  Synopsis:   free token id
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::FreeTokenId (
                            IN PCRYPT_DATA_BLOB pTokenId
                            )
{
    delete pTokenId->pbData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::FindImpersonationEngine, public
//
//  Synopsis:   find the impersonation engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::FindImpersonationEngine (
                            IN PCRYPT_DATA_BLOB pTokenId,
                            OUT PCIMPERSONATIONENGINE* ppEngine
                            )
{
    HLRUENTRY             hFound;
    PCIMPERSONATIONENGINE pEngine = NULL;

    hFound = I_CryptFindLruEntry( m_hImpersonationCache, pTokenId );

    if ( hFound != NULL )
    {
        pEngine = (PCIMPERSONATIONENGINE)I_CryptGetLruEntryData( hFound );
        pEngine->AddRef();

        *ppEngine = pEngine;

        I_CryptReleaseLruEntry( hFound );

        return( TRUE );
    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::CreateImpersonationEngine, public
//
//  Synopsis:   create an impersonation engine
//
//----------------------------------------------------------------------------
BOOL
CDefaultChainEngineMgr::CreateImpersonationEngine (
                              IN PCRYPT_DATA_BLOB pTokenId,
                              IN HCERTCHAINENGINE hChainEngine,
                              OUT PCIMPERSONATIONENGINE* ppEngine
                              )
{
    BOOL                  fResult = FALSE;
    PCIMPERSONATIONENGINE pEngine;

    pEngine = new CImpersonationEngine(
                                m_hImpersonationCache,
                                hChainEngine,
                                pTokenId,
                                fResult
                                );

    if ( pEngine == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }
    else if ( fResult == FALSE )
    {
        delete pEngine;
        return( FALSE );
    }

    *ppEngine = pEngine;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDefaultChainEngineMgr::AddToImpersonationCache, public
//
//  Synopsis:   add to the cache
//
//----------------------------------------------------------------------------
VOID
CDefaultChainEngineMgr::AddToImpersonationCache(
                           IN PCIMPERSONATIONENGINE pEngine
                           )
{
    pEngine->AddRef();
    I_CryptInsertLruEntry( pEngine->LruEntry(), NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   DefaultChainEngineMgrOnImpersonationEngineRemoval
//
//  Synopsis:   removal notification
//
//----------------------------------------------------------------------------
VOID WINAPI
DefaultChainEngineMgrOnImpersonationEngineRemoval (
       IN LPVOID pv,
       IN LPVOID pvRemovalContext
       )
{
    ( (PCIMPERSONATIONENGINE)pv )->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   DefaultChainEngineMgrHashTokenIdentifier
//
//  Synopsis:   hash the token identifier
//
//----------------------------------------------------------------------------
DWORD WINAPI
DefaultChainEngineMgrHashTokenIdentifier (
       IN PCRYPT_DATA_BLOB pIdentifier
       )
{
    DWORD  dwHash = 0;
    DWORD  cb = pIdentifier->cbData;
    LPBYTE pb = pIdentifier->pbData;

    while ( cb-- )
    {
        if ( dwHash & 0x80000000 )
        {
            dwHash = ( dwHash << 1 ) | 1;
        }
        else
        {
            dwHash = dwHash << 1;
        }

        dwHash += *pb++;
    }

    return( dwHash );
}
//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::CImpersonationEngine, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CImpersonationEngine::CImpersonationEngine (
                                    IN HLRUCACHE hCache,
                                    IN HCERTCHAINENGINE hChainEngine,
                                    IN PCRYPT_DATA_BLOB pTokenId,
                                    OUT BOOL& rfResult
                                    )
{

    m_cRefs = 1;
    m_hChainEngine = NULL;
    m_hLruEntry = NULL;

    rfResult = I_CryptCreateLruEntry(
                      hCache,
                      pTokenId,
                      this,
                      &m_hLruEntry
                      );

    if ( rfResult == TRUE )
    {
        m_hChainEngine = hChainEngine;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CImpersonationEngine::~CImpersonationEngine, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CImpersonationEngine::~CImpersonationEngine ()
{
    if ( m_hLruEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hLruEntry );
    }

    if ( m_hChainEngine != NULL )
    {
        CertFreeCertificateChainEngine( m_hChainEngine );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\lru.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lru.cpp
//
//  Contents:   LRU cache implementation
//
//  History:    24-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::CLruEntry, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLruEntry::CLruEntry (
               IN PCLRUCACHE pCache,
               IN PCRYPT_DATA_BLOB pIdentifier,
               IN LPVOID pvData,
               OUT BOOL& rfResult
               )
{
    rfResult = TRUE;

    m_cRefs = 1;
    m_pPrevEntry = NULL;
    m_pNextEntry = NULL;
    m_Usage = 0;

    m_pCache = pCache;
    m_pvData = pvData;
    m_pBucket = pCache->BucketFromIdentifier( pIdentifier );

    if ( pCache->Flags() & LRU_CACHE_NO_COPY_IDENTIFIER )
    {
        m_Identifier = *pIdentifier;
    }
    else
    {
        m_Identifier.cbData = pIdentifier->cbData;
        m_Identifier.pbData = new BYTE [ pIdentifier->cbData ];
        if ( m_Identifier.pbData != NULL )
        {
            memcpy(
               m_Identifier.pbData,
               pIdentifier->pbData,
               pIdentifier->cbData
               );
        }
        else
        {
            rfResult = FALSE;
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return;
        }
    }

    assert( m_pBucket != NULL );
    assert( m_Identifier.pbData != NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::~CLruEntry, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLruEntry::~CLruEntry ()
{
    m_pCache->FreeEntryData( m_pvData );

    if ( !( m_pCache->Flags() & LRU_CACHE_NO_COPY_IDENTIFIER ) )
    {
        delete m_Identifier.pbData;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::CLruCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLruCache::CLruCache (
               IN PLRU_CACHE_CONFIG pConfig,
               OUT BOOL& rfResult
               )
{
    rfResult = TRUE;

    m_Config.dwFlags = LRU_CACHE_NO_SERIALIZE;
    m_cEntries = 0;
    m_aBucket = new LRU_CACHE_BUCKET [ pConfig->cBuckets ];
    if ( m_aBucket == NULL )
    {
        rfResult = FALSE;
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return;
    }

    memset( m_aBucket, 0, sizeof( LRU_CACHE_BUCKET ) * pConfig->cBuckets );

    if ( !( pConfig->dwFlags & LRU_CACHE_NO_SERIALIZE ) )
    {
        if (! Pki_InitializeCriticalSection( &m_Lock ))
        {
            rfResult = FALSE;
            return;
        }
    }

    m_Config = *pConfig;
    m_UsageClock = 0;
    m_cLruDisabled = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::~CLruCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLruCache::~CLruCache ()
{
    if ( m_cEntries > 0 )
    {
        PurgeAllEntries( 0, NULL );
    }

    if ( !( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE ) )
    {
        DeleteCriticalSection( &m_Lock );
    }

    delete m_aBucket;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::EnableLruOfEntries, public
//
//  Synopsis:   enable LRU of entries and purge anything over the watermark
//
//----------------------------------------------------------------------------
VOID
CLruCache::EnableLruOfEntries (IN OPTIONAL LPVOID pvLruRemovalContext)
{
    LockCache();

    assert( m_cLruDisabled > 0 );

    if ( m_cLruDisabled == 0 )
    {
        return;
    }

    m_cLruDisabled -= 1;

    if ( m_cLruDisabled == 0 )
    {
        while ( m_cEntries > m_Config.MaxEntries )
        {
            PurgeLeastRecentlyUsed( pvLruRemovalContext );
        }
    }

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::DisableLruOfEntries, public
//
//  Synopsis:   disable LRU of entries
//
//----------------------------------------------------------------------------
VOID
CLruCache::DisableLruOfEntries ()
{
    LockCache();

    m_cLruDisabled += 1;

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::InsertEntry, public
//
//  Synopsis:   insert an entry into the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::InsertEntry (
                 IN PCLRUENTRY pEntry,
                 IN OPTIONAL LPVOID pvLruRemovalContext
                 )
{
    assert( pEntry->PrevPointer() == NULL );
    assert( pEntry->NextPointer() == NULL );

    pEntry->AddRef();

    LockCache();

    if ( ( m_cEntries == m_Config.MaxEntries ) &&
         ( m_Config.MaxEntries != 0 ) &&
         ( m_cLruDisabled == 0 ) )
    {
        PurgeLeastRecentlyUsed( pvLruRemovalContext );
    }

    assert( ( m_cEntries < m_Config.MaxEntries ) ||
            ( m_Config.MaxEntries == 0 ) ||
            ( m_cLruDisabled > 0 ) );

    pEntry->SetNextPointer( pEntry->Bucket()->pList );

    if ( pEntry->Bucket()->pList != NULL )
    {
        pEntry->Bucket()->pList->SetPrevPointer( pEntry );
    }

    pEntry->Bucket()->pList = pEntry;

    m_cEntries += 1;

    TouchEntryNoLock( pEntry, 0 );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::RemoveEntry, public
//
//  Synopsis:   remove an entry from the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::RemoveEntry (
                 IN PCLRUENTRY pEntry,
                 IN DWORD dwFlags,
                 IN OPTIONAL LPVOID pvRemovalContext
                 )
{
    LockCache();

    RemoveEntryFromBucket(
          pEntry->Bucket(),
          pEntry,
          dwFlags,
          pvRemovalContext
          );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::TouchEntry, public
//
//  Synopsis:   touch the entry
//
//----------------------------------------------------------------------------
VOID
CLruCache::TouchEntry (IN PCLRUENTRY pEntry, IN DWORD dwFlags)
{
    LockCache();

    TouchEntryNoLock( pEntry, dwFlags );

    UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FindEntry, public
//
//  Synopsis:   find the entry matching the given identifier
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::FindEntry (IN PCRYPT_DATA_BLOB pIdentifier, IN BOOL fTouchEntry)
{
    PLRU_CACHE_BUCKET pBucket;

    pBucket = BucketFromIdentifier( pIdentifier );

    assert( pBucket != NULL );

    return( FindNextMatchingEntryInBucket(
                pBucket,
                NULL,
                pIdentifier,
                fTouchEntry
                ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::NextMatchingEntry, public
//
//  Synopsis:   find the next matching entry to pPrevEntry
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::NextMatchingEntry (IN PCLRUENTRY pPrevEntry, IN BOOL fTouchEntry)
{
    PCLRUENTRY pNextEntry;

    pNextEntry = FindNextMatchingEntryInBucket(
                     NULL,
                     pPrevEntry,
                     NULL,
                     fTouchEntry
                     );

    pPrevEntry->Release();

    return( pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::WalkEntries, public
//
//  Synopsis:   walk the entries
//
//----------------------------------------------------------------------------
VOID
CLruCache::WalkEntries (IN PFN_WALK_ENTRIES pfnWalk, IN LPVOID pvParameter)
{
    DWORD      cCount;
    PCLRUENTRY pEntry;
    PCLRUENTRY pNextEntry;

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        pEntry = m_aBucket[ cCount ].pList;

        while ( pEntry != NULL )
        {
            pNextEntry = pEntry->NextPointer();

            if ( ( *pfnWalk )( pvParameter, pEntry ) == FALSE )
            {
                return;
            }

            pEntry = pNextEntry;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::RemoveEntryFromBucket, public
//
//  Synopsis:   remove entry from bucket
//
//----------------------------------------------------------------------------
VOID
CLruCache::RemoveEntryFromBucket (
                 IN PLRU_CACHE_BUCKET pBucket,
                 IN PCLRUENTRY pEntry,
                 IN DWORD dwFlags,
                 IN OPTIONAL LPVOID pvRemovalContext
                 )
{
    if ( pEntry->PrevPointer() != NULL )
    {
        pEntry->PrevPointer()->SetNextPointer( pEntry->NextPointer() );
    }
    else
    {
        assert( pBucket->pList == pEntry );

        pBucket->pList = pEntry->NextPointer();
    }

    if ( pEntry->NextPointer() != NULL )
    {
        pEntry->NextPointer()->SetPrevPointer( pEntry->PrevPointer() );
    }

    pEntry->SetPrevPointer( NULL );
    pEntry->SetNextPointer( NULL );

    m_cEntries -= 1;

    if (  ( m_Config.pfnOnRemoval != NULL ) &&
         !( dwFlags & LRU_SUPPRESS_REMOVAL_NOTIFICATION ) )
    {
        ( *m_Config.pfnOnRemoval )( pEntry->Data(), pvRemovalContext );
    }

    pEntry->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FindNextMatchingEntryInBucket, public
//
//  Synopsis:   find the next matching entry in the given bucket.  If pCurrent
//              is non NULL then start from there, the bucket is not needed and
//              pIdentifier is ignored. If pCurrent is NULL then pIdentifier
//              and the bucket must both be non NULL
//
//----------------------------------------------------------------------------
PCLRUENTRY
CLruCache::FindNextMatchingEntryInBucket (
               IN PLRU_CACHE_BUCKET pBucket,
               IN PCLRUENTRY pCurrent,
               IN PCRYPT_DATA_BLOB pIdentifier,
               IN BOOL fTouchEntry
               )
{
    LockCache();

    if ( pCurrent == NULL )
    {
        pCurrent = pBucket->pList;
    }
    else
    {
        pIdentifier = pCurrent->Identifier();
        pCurrent = pCurrent->NextPointer();
    }

    while ( pCurrent != NULL )
    {
        if ( ( pIdentifier->cbData == pCurrent->Identifier()->cbData ) &&
             ( memcmp(
                  pIdentifier->pbData,
                  pCurrent->Identifier()->pbData,
                  pIdentifier->cbData
                  ) == 0 ) )
        {
            break;
        }

        pCurrent = pCurrent->NextPointer();
    }

    if ( pCurrent != NULL )
    {
        pCurrent->AddRef();

        if ( fTouchEntry == TRUE )
        {
            TouchEntryNoLock( pCurrent, 0 );
        }
    }

    UnlockCache();

    return( pCurrent );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::PurgeLeastRecentlyUsed, public
//
//  Synopsis:   find and remove the least recently used entry
//
//----------------------------------------------------------------------------
VOID
CLruCache::PurgeLeastRecentlyUsed (IN OPTIONAL LPVOID pvLruRemovalContext)
{
    DWORD             cCount;
    PLRU_CACHE_BUCKET pBucket;
    PCLRUENTRY        pEntry;
    PCLRUENTRY        pLRU;

    assert( m_cEntries > 0 );

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        if ( m_aBucket[cCount].pList != NULL )
        {
            break;
        }
    }

    pBucket = &m_aBucket[cCount];
    cCount += 1;
    for ( ; cCount < m_Config.cBuckets; cCount++ )
    {
        if ( ( m_aBucket[cCount].pList != NULL ) &&
             ( m_aBucket[cCount].Usage < pBucket->Usage ) )
        {
            pBucket = &m_aBucket[cCount];
        }
    }

    assert( pBucket != NULL );
    assert( pBucket->pList != NULL );

    pLRU = pBucket->pList;
    pEntry = pLRU->NextPointer();

    while ( pEntry != NULL )
    {
        if ( pEntry->Usage() < pLRU->Usage() )
        {
            pLRU = pEntry;
        }

        pEntry = pEntry->NextPointer();
    }

    RemoveEntryFromBucket( pBucket, pLRU, 0, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::PurgeAllEntries, public
//
//  Synopsis:   remove all entries from the cache
//
//----------------------------------------------------------------------------
VOID
CLruCache::PurgeAllEntries (
                IN DWORD dwFlags,
                IN OPTIONAL LPVOID pvRemovalContext
                )
{
    DWORD cCount;

    for ( cCount = 0; cCount < m_Config.cBuckets; cCount++ )
    {
        while ( m_aBucket[cCount].pList != NULL )
        {
            RemoveEntryFromBucket(
                  &m_aBucket[cCount],
                  m_aBucket[cCount].pList,
                  dwFlags,
                  pvRemovalContext
                  );
        }
    }

    assert( m_cEntries == 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptCreateLruCache
//
//  Synopsis:   create an LRU cache area
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptCreateLruCache (
       IN PLRU_CACHE_CONFIG pConfig,
       OUT HLRUCACHE* phCache
       )
{
    BOOL       fResult = FALSE;
    PCLRUCACHE pCache;

    pCache = new CLruCache( pConfig, fResult );
    if ( pCache == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == FALSE )
    {
        delete pCache;
        return( FALSE );
    }

    *phCache = (HLRUCACHE)pCache;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFlushLruCache
//
//  Synopsis:   flush the cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptFlushLruCache (
       IN HLRUCACHE hCache,
       IN OPTIONAL DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       )
{
    ( (PCLRUCACHE)hCache )->LockCache();

    ( (PCLRUCACHE)hCache )->PurgeAllEntries( dwFlags, pvRemovalContext );

    ( (PCLRUCACHE)hCache )->UnlockCache();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFreeLruCache
//
//  Synopsis:   free the LRU cache area
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptFreeLruCache (
       IN HLRUCACHE hCache,
       IN DWORD dwFlags,
       IN OPTIONAL LPVOID pvRemovalContext
       )
{
    if ( hCache == NULL )
    {
        return;
    }

    if ( dwFlags != 0 )
    {
        ( (PCLRUCACHE)hCache )->PurgeAllEntries( dwFlags, pvRemovalContext );
    }

    delete (PCLRUCACHE)hCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptCreateLruEntry
//
//  Synopsis:   create an LRU entry
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptCreateLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       IN LPVOID pvData,
       OUT HLRUENTRY* phEntry
       )
{
    BOOL       fResult = FALSE;
    PCLRUENTRY pEntry;

    pEntry = new CLruEntry(
                     (PCLRUCACHE)hCache,
                     pIdentifier,
                     pvData,
                     fResult
                     );

    if ( pEntry == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == FALSE )
    {
        delete pEntry;
        return( FALSE );
    }

    *phEntry = (HLRUENTRY)pEntry;
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptGetLruEntryIdentifier
//
//  Synopsis:   return the identifier for the entry
//
//----------------------------------------------------------------------------
PCRYPT_DATA_BLOB WINAPI
I_CryptGetLruEntryIdentifier (
       IN HLRUENTRY hEntry
       )
{
    return( ( (PCLRUENTRY)hEntry )->Identifier() );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptGetLruEntryData
//
//  Synopsis:   get the data associated with the entry
//
//----------------------------------------------------------------------------
LPVOID WINAPI
I_CryptGetLruEntryData (
       IN HLRUENTRY hEntry
       )
{
    return( ( (PCLRUENTRY)hEntry )->Data() );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptAddRefLruEntry
//
//  Synopsis:   add a reference to the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptAddRefLruEntry (
       IN HLRUENTRY hEntry
       )
{
    ( (PCLRUENTRY)hEntry )->AddRef();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptReleaseLruEntry
//
//  Synopsis:   remove a reference from the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptReleaseLruEntry (
       IN HLRUENTRY hEntry
       )
{
    ( (PCLRUENTRY)hEntry )->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptInsertLruEntry
//
//  Synopsis:   insert the entry into its associated cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptInsertLruEntry (
       IN HLRUENTRY hEntry,
       IN OPTIONAL LPVOID pvLruRemovalContext
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->InsertEntry( pEntry, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptRemoveLruEntry
//
//  Synopsis:   remove the entry from its associated cache
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptRemoveLruEntry (
       IN HLRUENTRY hEntry,
       IN DWORD dwFlags,
       IN LPVOID pvLruRemovalContext
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->RemoveEntry( pEntry, dwFlags, pvLruRemovalContext );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptTouchLruEntry
//
//  Synopsis:   touch the entry
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptTouchLruEntry (
       IN HLRUENTRY hEntry,
       IN DWORD dwFlags
       )
{
    PCLRUENTRY pEntry = (PCLRUENTRY)hEntry;

    pEntry->Cache()->TouchEntry( pEntry, dwFlags );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindLruEntry
//
//  Synopsis:   find the entry with the given identifier
//
//----------------------------------------------------------------------------
HLRUENTRY WINAPI
I_CryptFindLruEntry (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier
       )
{
    PCLRUCACHE pCache = (PCLRUCACHE)hCache;

    return( pCache->FindEntry( pIdentifier, FALSE ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptFindLruEntryData
//
//  Synopsis:   find the entry with the given identifier
//
//----------------------------------------------------------------------------
LPVOID WINAPI
I_CryptFindLruEntryData (
       IN HLRUCACHE hCache,
       IN PCRYPT_DATA_BLOB pIdentifier,
       OUT HLRUENTRY* phEntry
       )
{
    PCLRUCACHE pCache = (PCLRUCACHE)hCache;
    PCLRUENTRY pEntry;

    pEntry = pCache->FindEntry( pIdentifier, TRUE );
    *phEntry = (HLRUENTRY)pEntry;

    if ( pEntry != NULL )
    {
        return( pEntry->Data() );
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptEnumMatchingLruEntries
//
//  Synopsis:   get the next matching entry
//
//----------------------------------------------------------------------------
HLRUENTRY WINAPI
I_CryptEnumMatchingLruEntries (
       IN HLRUENTRY hPrevEntry
       )
{
    PCLRUCACHE pCache = ( (PCLRUENTRY)hPrevEntry )->Cache();
    PCLRUENTRY pNextEntry;

    pNextEntry = pCache->NextMatchingEntry( (PCLRUENTRY)hPrevEntry, FALSE );

    return( (HLRUENTRY)pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptEnableLruOfEntries
//
//  Synopsis:   enable LRU of entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptEnableLruOfEntries (
       IN HLRUCACHE hCache,
       IN OPTIONAL LPVOID pvLruRemovalContext
       )
{
    ( (PCLRUCACHE)hCache )->EnableLruOfEntries( pvLruRemovalContext);
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptDisableLruOfEntries
//
//  Synopsis:   disable LRU of entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptDisableLruOfEntries (
       IN HLRUCACHE hCache
       )
{
    ( (PCLRUCACHE)hCache )->DisableLruOfEntries();
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptWalkAllLruCacheEntries
//
//  Synopsis:   walk the LRU cache entries
//
//----------------------------------------------------------------------------
VOID WINAPI
I_CryptWalkAllLruCacheEntries (
       IN HLRUCACHE hCache,
       IN PFN_WALK_ENTRIES pfnWalk,
       IN LPVOID pvParameter
       )
{
    ( (PCLRUCACHE)hCache )->WalkEntries( pfnWalk, pvParameter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\extract.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       extract.cpp
//
//  Contents:   Chain Cabinet Extraction
//
//  Functions:  ExtractAuthRootAutoUpdateCtlFromCab
//
//  History:    11-Nov-00    philh    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <setupapi.h>
#include <dbgdef.h>
#include <userenv.h>

#define CHAIN_CHAR_LEN(sz)    (sizeof(sz) / sizeof(sz[0]))

//+===========================================================================
//  Extract helper functions
//============================================================================

//+-------------------------------------------------------------------------
//  Allocate and read a blob from a file.
//
//  The allocated bytes must be freed by calling PkiFree().
//--------------------------------------------------------------------------
BOOL WINAPI
ReadBlobFromFileA(
    IN LPCSTR pszFileName,
    OUT BYTE **ppb,
    OUT DWORD *pcb
    )
{
    BOOL fResult;
    HANDLE hFile;
    BYTE *pb = NULL;
    DWORD cb = 0;
    DWORD cbRead = 0;

    hFile = CreateFileA(
        pszFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,                               // lpsa
        OPEN_EXISTING,
        0,                                  // fdwAttrsAndFlags
        NULL                                // TemplateFile
        );
    if (INVALID_HANDLE_VALUE == hFile)
        goto CreateFileError;

    cb = GetFileSize(hFile, NULL);
    if (0 == cb)
        goto EmptyFile;

    if (NULL == (pb = (BYTE *) PkiNonzeroAlloc(cb)))
        goto OutOfMemory;

    if (!ReadFile(hFile, pb, cb, &cbRead, NULL))
        goto ReadFileError; 
    if (cbRead != cb)
        goto InvalidFileLengthError;

    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile) {
        DWORD dwLastErr = GetLastError();
        CloseHandle(hFile);
        SetLastError(dwLastErr);
    }

    *ppb = pb;
    *pcb = cb;

    return fResult;

ErrorReturn:
    if (pb) {
        PkiFree(pb);
        pb = NULL;
    }
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateFileError)
SET_ERROR(EmptyFile, ERROR_INVALID_DATA)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ReadFileError)
SET_ERROR(InvalidFileLengthError, ERROR_INVALID_DATA)
}

//+-------------------------------------------------------------------------
//  Write the blob to the specified file
//--------------------------------------------------------------------------
BOOL WINAPI
WriteBlobToFileA(
    IN LPCSTR pszFileName,
    IN const BYTE *pb,
    IN DWORD cb
    )
{
    BOOL fResult;
    HANDLE hFile;
    DWORD cbWritten;

    hFile = CreateFileA(
        pszFileName,
        GENERIC_WRITE,
        0,                  // fdwShareMode
        NULL,               // lpsa
        CREATE_ALWAYS,
        0,                  // fdwAttrsAndFlags
        0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
        goto CreateFileError;

    if (!WriteFile(hFile, pb, cb, &cbWritten, NULL))
        goto WriteFileError;

    fResult = TRUE;
CommonReturn:
    if (INVALID_HANDLE_VALUE != hFile) {
        DWORD dwLastErr = GetLastError();
        CloseHandle(hFile);
        SetLastError(dwLastErr);
    }

    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateFileError)
TRACE_ERROR(WriteFileError)
}


typedef struct _EXTRACT_CAB_FILE_CONTEXT_A {
    LPCSTR      pszFileInCab;
    LPCSTR      pszTempTargetFileName;  // MAX_PATH array
    BOOL        fDidExtract;
} EXTRACT_CAB_FILE_CONTEXT_A, *PEXTRACT_CAB_FILE_CONTEXT_A;

//+-------------------------------------------------------------------------
//  Callback called by SetupIterateCabinetA to extract the file.
//--------------------------------------------------------------------------
UINT CALLBACK
ExtractCabFileCallbackA(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT uRet;
    PEXTRACT_CAB_FILE_CONTEXT_A pCabFileContext =
        (PEXTRACT_CAB_FILE_CONTEXT_A) Context;

    switch (Notification) {
        case SPFILENOTIFY_FILEINCABINET:
            {
                PFILE_IN_CABINET_INFO_A pInfo =
                    (PFILE_IN_CABINET_INFO_A) Param1;

                if (0 == _stricmp(pCabFileContext->pszFileInCab,
                        pInfo->NameInCabinet)) {
                    strncpy(pInfo->FullTargetName,
                        pCabFileContext->pszTempTargetFileName,
                        CHAIN_CHAR_LEN(pInfo->FullTargetName));
                    pInfo->FullTargetName[
                        CHAIN_CHAR_LEN(pInfo->FullTargetName) - 1] = '\0';

                    uRet = FILEOP_DOIT;
                } else
                    uRet = FILEOP_SKIP;
            }
            break;

        case SPFILENOTIFY_FILEEXTRACTED:
            {
                PFILEPATHS_A pInfo = (PFILEPATHS_A) Param1;

                uRet = pInfo->Win32Error;

                if (NO_ERROR == uRet &&
                        0 == _stricmp(pCabFileContext->pszTempTargetFileName,
                                    pInfo->Target))
                    pCabFileContext->fDidExtract = TRUE;
            }
            break;

        default:
            uRet = NO_ERROR;
    }

    return uRet;
}

typedef BOOL (WINAPI *PFN_SETUP_ITERATE_CABINET_A)(
    IN  PCSTR               CabinetFile,
    IN  DWORD               Reserved,
    IN  PSP_FILE_CALLBACK_A MsgHandler,
    IN  PVOID               Context
    );

//+-------------------------------------------------------------------------
//  Load setupapi.dll and call SetupIterateCabinetA to extract and
//  expand the specified file in the cab.
//--------------------------------------------------------------------------
BOOL WINAPI
ExtractFileFromCabFileA(
    IN LPCSTR pszFileInCab,
    IN const CHAR szTempCabFileName[MAX_PATH],
    IN const CHAR szTempTargetFileName[MAX_PATH]
    )
{
    BOOL fResult;
    HMODULE hDll = NULL;
    PFN_SETUP_ITERATE_CABINET_A pfnSetupIterateCabinetA;
    EXTRACT_CAB_FILE_CONTEXT_A CabFileContext;

    if (NULL == (hDll = LoadLibraryA("setupapi.dll")))
        goto LoadSetupApiDllError;

    if (NULL == (pfnSetupIterateCabinetA =
            (PFN_SETUP_ITERATE_CABINET_A) GetProcAddress(
                hDll, "SetupIterateCabinetA")))
        goto SetupIterateCabinetAProcAddressError;

    memset(&CabFileContext, 0, sizeof(CabFileContext));
    CabFileContext.pszFileInCab = pszFileInCab;
    CabFileContext.pszTempTargetFileName = szTempTargetFileName;

    if (!pfnSetupIterateCabinetA(
            szTempCabFileName,
            0,                      // Reserved
            ExtractCabFileCallbackA,
            &CabFileContext
            ))
        goto SetupIterateCabinetError;

    if (!CabFileContext.fDidExtract)
        goto NoCabFileExtracted;

    fResult = TRUE;

CommonReturn:
    if (hDll) {
        DWORD dwLastErr = GetLastError();
        FreeLibrary(hDll);
        SetLastError(dwLastErr);
    }
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(LoadSetupApiDllError)
TRACE_ERROR(SetupIterateCabinetAProcAddressError)
TRACE_ERROR(SetupIterateCabinetError)
SET_ERROR(NoCabFileExtracted, ERROR_FILE_NOT_FOUND)
}

typedef BOOL (WINAPI *PFN_EXPAND_ENVIRONMENT_STRINGS_FOR_USER_A)(
    IN HANDLE hToken,
    IN LPCSTR lpSrc,
    OUT LPSTR lpDest,
    IN DWORD dwSize
    );

//+-------------------------------------------------------------------------
//  Get the thread's temp directory. We may be doing thread impersonation.
//
//  Returns 0 if unable to get a thread temp path
//--------------------------------------------------------------------------
DWORD WINAPI
I_GetThreadTempPathA(
    OUT CHAR szTempPath[MAX_PATH]
    )
{
    DWORD cch;
    HANDLE hToken = NULL;
    HMODULE hDll = NULL;
    PFN_EXPAND_ENVIRONMENT_STRINGS_FOR_USER_A
        pfnExpandEnvironmentStringsForUserA;

    if (!FIsWinNT5())
        return 0;

    if (!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY | TOKEN_IMPERSONATE,
            TRUE,
            &hToken
            ))
        // We aren't impersonating. Default to the system environment
        // variables.
        hToken = NULL;

    if (NULL == (hDll = LoadLibraryA("userenv.dll")))
        goto LoadUserenvDllError;

    if (NULL == (pfnExpandEnvironmentStringsForUserA =
            (PFN_EXPAND_ENVIRONMENT_STRINGS_FOR_USER_A) GetProcAddress(hDll,
                "ExpandEnvironmentStringsForUserA")))
        goto ExpandEnvironmentStringsForUserAProcAddressError;

    szTempPath[0] = L'\0';
    if (!pfnExpandEnvironmentStringsForUserA(
            hToken,
            "%Temp%\\",
            szTempPath,
            MAX_PATH - 1
            ) || '\0' == szTempPath[0])
        goto ExpandTempError;

    szTempPath[MAX_PATH - 1] = '\0';
    cch = strlen(szTempPath);

CommonReturn:
    if (hToken)
        CloseHandle(hToken);
    if (hDll)
        FreeLibrary(hDll);

    return cch;
ErrorReturn:
    cch = 0;
    goto CommonReturn;

TRACE_ERROR(LoadUserenvDllError)
TRACE_ERROR(ExpandEnvironmentStringsForUserAProcAddressError)
TRACE_ERROR(ExpandTempError)
}

//+-------------------------------------------------------------------------
//  Extract, expand and allocate an in-memory blob for the specified
//  file from the in-memory cab.
//  
//  The allocated bytes must be freed by calling PkiFree().
//--------------------------------------------------------------------------
BOOL WINAPI
ExtractBlobFromCabA(
    IN const BYTE *pbCab,
    IN DWORD cbCab,
    IN LPCSTR pszFileInCab,
    OUT BYTE **ppb,
    OUT DWORD *pcb
    )
{
    BOOL fResult;
    DWORD dwLastErr = 0;
    BYTE *pb = NULL;
    DWORD cb;

    CHAR szTempPath[MAX_PATH];
    CHAR szTempCabFileName[MAX_PATH]; szTempCabFileName[0] = '\0';
    CHAR szTempTargetFileName[MAX_PATH]; szTempTargetFileName[0] = '\0';
    DWORD cch;

    // Get temp filenames for the cabinet and extracted target
    cch = GetTempPathA(CHAIN_CHAR_LEN(szTempPath), szTempPath);
    if (0 == cch || (CHAIN_CHAR_LEN(szTempPath) - 1) < cch)
        goto GetTempPathError;

    if (0 == GetTempFileNameA(szTempPath, "Cab", 0, szTempCabFileName)) {
        dwLastErr = GetLastError();

        // If we are doing thread impersonation, we may not have access to the
        // process's temp directory. Try to get the impersonated thread's
        // temp directory.
        cch = I_GetThreadTempPathA(szTempPath);
        if (0 != cch)
            cch = GetTempFileNameA(szTempPath, "Cab", 0, szTempCabFileName);

        if (0 == cch) {
            SetLastError(dwLastErr);
            szTempCabFileName[0] = '\0';
            goto GetTempCabFileNameError;
        }
    }

    szTempCabFileName[CHAIN_CHAR_LEN(szTempCabFileName) - 1] = '\0';

    if (0 == GetTempFileNameA(szTempPath, "Tar", 0, szTempTargetFileName)) {
        szTempTargetFileName[0] = '\0';
        goto GetTempTargetFileNameError;
    }
    szTempTargetFileName[CHAIN_CHAR_LEN(szTempTargetFileName) - 1] = '\0';

    // Write the cab bytes to the temporary cab file
    if (!WriteBlobToFileA(szTempCabFileName, pbCab, cbCab))
        goto WriteCabFileError;

    // Extract the specified file from the temporary cab file
    if (!ExtractFileFromCabFileA(
            pszFileInCab, szTempCabFileName, szTempTargetFileName))
        goto ExtractFileFromCabFileError;

    // Read and allocate the bytes from the temporary target file
    if (!ReadBlobFromFileA(szTempTargetFileName, &pb, &cb))
        goto ReadTargetFileError;

    fResult = TRUE;

CommonReturn:
    // Delete the temp files
    if ('\0' != szTempCabFileName)
        DeleteFileA(szTempCabFileName);
    if ('\0' != szTempTargetFileName)
        DeleteFileA(szTempTargetFileName);

    *ppb = pb;
    *pcb = cb;

    SetLastError(dwLastErr);
    return fResult;

ErrorReturn:
    dwLastErr = GetLastError();
    if (pb) {
        PkiFree(pb);
        pb = NULL;
    }
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetTempPathError)
TRACE_ERROR(GetTempCabFileNameError)
TRACE_ERROR(GetTempTargetFileNameError)
TRACE_ERROR(WriteCabFileError)
TRACE_ERROR(ExtractFileFromCabFileError)
TRACE_ERROR(ReadTargetFileError)
}


//+---------------------------------------------------------------------------
//
//  Function:   ExtractAuthRootAutoUpdateCtlFromCab
//
//  Synopsis:   Extract the authroot.stl file from the cabinet blob
//              and create the AuthRoot Auto Update CTL.
//
//  Assumption: Chain engine isn't locked in the calling thread.
//
//----------------------------------------------------------------------------
PCCTL_CONTEXT WINAPI
ExtractAuthRootAutoUpdateCtlFromCab (
    IN PCRYPT_BLOB_ARRAY pcbaCab
    )
{
    PCRYPT_DATA_BLOB pCabBlob;
    PCCTL_CONTEXT pCtl = NULL;
    BYTE *pbEncodedCtl = NULL;
    DWORD cbEncodedCtl;
    CERT_CREATE_CONTEXT_PARA CreateContextPara;

    // Get the cab blob
    pCabBlob = pcbaCab->rgBlob;
    if (0 == pcbaCab->cBlob || 0 == pCabBlob->cbData)
        goto InvalidCabBlob;

    // Extract, expand and create an in-memory blob for the stl file in the
    // in-memory cab
    if (!ExtractBlobFromCabA(
            pCabBlob->pbData,
            pCabBlob->cbData,
            CERT_AUTH_ROOT_CTL_FILENAME_A,
            &pbEncodedCtl,
            &cbEncodedCtl
            ))
        goto ExtractStlFromCabError;

    // Create the Ctl from the extracted bytes
    memset(&CreateContextPara, 0, sizeof(CreateContextPara));
    CreateContextPara.cbSize = sizeof(CreateContextPara);
    CreateContextPara.pfnFree = PkiFree;

    pCtl = (PCCTL_CONTEXT) CertCreateContext(
        CERT_STORE_CTL_CONTEXT,
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pbEncodedCtl,
        cbEncodedCtl,
        CERT_CREATE_CONTEXT_NOCOPY_FLAG,
        &CreateContextPara
        );
    // For NO_COPY_FLAG, pbEncodedCtl is always freed, even for an error
    pbEncodedCtl = NULL;
    if (NULL == pCtl)
        goto CreateCtlError;

CommonReturn:
    return pCtl;

ErrorReturn:
    assert(NULL == pCtl);
    if (pbEncodedCtl)
        PkiFree(pbEncodedCtl);

    goto CommonReturn;

SET_ERROR(InvalidCabBlob, ERROR_INVALID_DATA)
TRACE_ERROR(ExtractStlFromCabError)
TRACE_ERROR(CreateCtlError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\lru.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       lru.h
//
//  Contents:   LRU cache class definitions
//
//  History:    22-Dec-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LRU_H__)
#define __LRU_H__

#include <lrucache.h>

//
// Forward declaration of LRU cache classes
//

class CLruCache;
class CLruEntry;

typedef CLruCache* PCLRUCACHE;
typedef CLruEntry* PCLRUENTRY;

//
// LRU cache bucket structure
//

typedef struct _LRU_CACHE_BUCKET {

    DWORD      Usage;
    PCLRUENTRY pList;

} LRU_CACHE_BUCKET, *PLRU_CACHE_BUCKET;

//
// CLruEntry class definition
//

class CLruEntry
{
public:

    //
    // Construction
    //

    CLruEntry (
        IN PCLRUCACHE pCache,
        IN PCRYPT_DATA_BLOB pIdentifier,
        IN LPVOID pvData,
        OUT BOOL& rfResult
        );

    ~CLruEntry ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Cache and Bucket access
    //

    inline PCLRUCACHE Cache ();
    inline PLRU_CACHE_BUCKET Bucket ();

    //
    // Data access
    //

    inline PCRYPT_DATA_BLOB Identifier ();
    inline LPVOID Data ();

    //
    // Link access
    //

    inline VOID SetPrevPointer (IN PCLRUENTRY pPrevEntry);
    inline VOID SetNextPointer (IN PCLRUENTRY pNextEntry);

    inline PCLRUENTRY PrevPointer ();
    inline PCLRUENTRY NextPointer ();

    //
    // LRU usage access
    //

    inline VOID SetUsage (DWORD Usage);
    inline DWORD Usage ();

    //
    // Cache Destruction notification
    //

    inline VOID OnCacheDestruction ();

private:

    //
    // Reference count
    //

    ULONG             m_cRefs;

    //
    // Cache pointer
    //

    PCLRUCACHE        m_pCache;

    //
    // Entry information
    //

    CRYPT_DATA_BLOB   m_Identifier;
    LPVOID            m_pvData;

    //
    // Links
    //

    PCLRUENTRY        m_pPrevEntry;
    PCLRUENTRY        m_pNextEntry;
    PLRU_CACHE_BUCKET m_pBucket;

    //
    // Usage
    //

    DWORD             m_Usage;
};

//
// CLruCache class definition
//

class CLruCache
{
public:

    //
    // Construction
    //

    CLruCache (
        IN PLRU_CACHE_CONFIG pConfig,
        OUT BOOL& rfResult
        );

    ~CLruCache ();

    //
    // Clearing the cache
    //

    VOID PurgeAllEntries (
              IN DWORD dwFlags,
              IN OPTIONAL LPVOID pvRemovalContext
              );

    //
    // Cache locking
    //

    inline VOID LockCache ();
    inline VOID UnlockCache ();

    //
    // LRU enable and disable
    //

    VOID EnableLruOfEntries (IN OPTIONAL LPVOID pvLruRemovalContext);

    VOID DisableLruOfEntries ();

    //
    // Cache entry manipulation
    //

    VOID InsertEntry (
               IN PCLRUENTRY pEntry,
               IN OPTIONAL LPVOID pvLruRemovalContext
               );

    VOID RemoveEntry (
               IN PCLRUENTRY pEntry,
               IN DWORD dwFlags,
               IN OPTIONAL LPVOID pvRemovalContext
               );

    VOID TouchEntry (IN PCLRUENTRY pEntry, IN DWORD dwFlags);

    //
    // Cache entry retrieval
    //

    PCLRUENTRY FindEntry (IN PCRYPT_DATA_BLOB pIdentifier, IN BOOL fTouchEntry);

    PCLRUENTRY NextMatchingEntry (
                   IN PCLRUENTRY pPrevEntry,
                   IN BOOL fTouchEntry
                   );

    //
    // Cache bucket retrieval
    //

    inline PLRU_CACHE_BUCKET BucketFromIdentifier (
                                   IN PCRYPT_DATA_BLOB pIdentifier
                                   );

    //
    // Configuration access
    //

    //
    // Use the configured free function to release the
    // pvData in an entry
    //
    // MOTE: This is called from the CLruEntry destructor
    //

    inline VOID FreeEntryData (IN LPVOID pvData);

    //
    // Access the configuration flags
    //

    inline DWORD Flags ();

    //
    // Usage clock access
    //

    inline VOID IncrementUsageClock ();
    inline DWORD UsageClock ();

    //
    // Walk all cache entries
    //

    VOID WalkEntries (IN PFN_WALK_ENTRIES pfnWalk, IN LPVOID pvParameter);

private:

    //
    // Cache configuration
    //

    LRU_CACHE_CONFIG  m_Config;

    //
    // Cache lock
    //

    CRITICAL_SECTION  m_Lock;

    //
    // Entry count
    //

    DWORD             m_cEntries;

    //
    // Cache Buckets
    //

    PLRU_CACHE_BUCKET m_aBucket;

    //
    // Usage clock
    //

    DWORD             m_UsageClock;

    //
    // LRU disabled count
    //

    DWORD             m_cLruDisabled;

    //
    // Private methods
    //

    VOID RemoveEntryFromBucket (
               IN PLRU_CACHE_BUCKET pBucket,
               IN PCLRUENTRY pEntry,
               IN DWORD dwFlags,
               IN OPTIONAL LPVOID pvRemovalContext
               );

    PCLRUENTRY FindNextMatchingEntryInBucket (
                   IN PLRU_CACHE_BUCKET pBucket,
                   IN PCLRUENTRY pCurrent,
                   IN PCRYPT_DATA_BLOB pIdentifier,
                   IN BOOL fTouchEntry
                   );

    VOID PurgeLeastRecentlyUsed (IN OPTIONAL LPVOID pvLruRemovalContext);

    inline VOID TouchEntryNoLock (IN PCLRUENTRY pEntry, IN DWORD dwFlags);
};

//
// Inline functions
//

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::AddRef, public
//
//  Synopsis:   increment entry reference count
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Release, public
//
//  Synopsis:   decrement entry reference count and if count goes to zero
//              free the entry
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Cache, public
//
//  Synopsis:   return the internal cache pointer
//
//----------------------------------------------------------------------------
inline PCLRUCACHE
CLruEntry::Cache ()
{
    return( m_pCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Bucket, public
//
//  Synopsis:   return the internal cache bucket pointer
//
//----------------------------------------------------------------------------
inline PLRU_CACHE_BUCKET
CLruEntry::Bucket ()
{
    return( m_pBucket );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Identifier, public
//
//  Synopsis:   return the internal entry identifier
//
//----------------------------------------------------------------------------
inline PCRYPT_DATA_BLOB
CLruEntry::Identifier ()
{
    return( &m_Identifier );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Data, public
//
//  Synopsis:   return the internal entry data
//
//----------------------------------------------------------------------------
inline LPVOID
CLruEntry::Data ()
{
    return( m_pvData );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetPrevPointer, public
//
//  Synopsis:   set the previous entry pointer
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetPrevPointer (IN PCLRUENTRY pPrevEntry)
{
    m_pPrevEntry = pPrevEntry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetNextPointer, public
//
//  Synopsis:   set the next entry pointer
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetNextPointer (IN PCLRUENTRY pNextEntry)
{
    m_pNextEntry = pNextEntry;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::PrevPointer, public
//
//  Synopsis:   return the previous entry pointer
//
//----------------------------------------------------------------------------
inline PCLRUENTRY
CLruEntry::PrevPointer ()
{
    return( m_pPrevEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::NextPointer, public
//
//  Synopsis:   return the next entry pointer
//
//----------------------------------------------------------------------------
inline PCLRUENTRY
CLruEntry::NextPointer ()
{
    return( m_pNextEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::SetUsage, public
//
//  Synopsis:   set the usage on the entry object and on
//              the corresponding cache bucket
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::SetUsage (IN DWORD Usage)
{
    m_Usage = Usage;
    m_pBucket->Usage = Usage;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::Usage, public
//
//  Synopsis:   return the internal entry usage
//
//----------------------------------------------------------------------------
inline DWORD
CLruEntry::Usage ()
{
    return( m_Usage );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruEntry::OnCacheDestruction, public
//
//  Synopsis:   cleanup reference to cache that is being destroyed
//
//----------------------------------------------------------------------------
inline VOID
CLruEntry::OnCacheDestruction ()
{
    m_pCache = NULL;
    m_pBucket = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::LockCache, public
//
//  Synopsis:   acquire the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::LockCache ()
{
    if ( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE )
    {
        return;
    }

    EnterCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::UnlockCache, public
//
//  Synopsis:   release the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::UnlockCache ()
{
    if ( m_Config.dwFlags & LRU_CACHE_NO_SERIALIZE )
    {
        return;
    }

    LeaveCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::BucketFromIdentifier, public
//
//  Synopsis:   retrieve the associated cache bucket given the entry identifier
//
//----------------------------------------------------------------------------
inline PLRU_CACHE_BUCKET
CLruCache::BucketFromIdentifier (
                 IN PCRYPT_DATA_BLOB pIdentifier
                 )
{
    DWORD Hash = ( *m_Config.pfnHash )( pIdentifier );

    return( &m_aBucket[ Hash % m_Config.cBuckets ] );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::FreeEntryData, public
//
//  Synopsis:   free the data using the configured free function
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::FreeEntryData (IN LPVOID pvData)
{
    if ( m_Config.pfnFree != NULL )
    {
        ( *m_Config.pfnFree )( pvData );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::Flags, public
//
//  Synopsis:   access the configured flags
//
//----------------------------------------------------------------------------
inline DWORD
CLruCache::Flags ()
{
    return( m_Config.dwFlags );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::IncrementUsageClock, public
//
//  Synopsis:   increment the usage clock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::IncrementUsageClock ()
{
    m_UsageClock += 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::UsageClock, public
//
//  Synopsis:   return the usage clock value
//
//----------------------------------------------------------------------------
inline DWORD
CLruCache::UsageClock ()
{
    return( m_UsageClock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLruCache::TouchEntryNoLock, public
//
//  Synopsis:   touch entry without taking the cache lock
//
//----------------------------------------------------------------------------
inline VOID
CLruCache::TouchEntryNoLock (IN PCLRUENTRY pEntry, IN DWORD dwFlags)
{
    if ( !( dwFlags & LRU_SUPPRESS_CLOCK_UPDATE ) )
    {
        IncrementUsageClock();
    }

    pEntry->SetUsage( UsageClock() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\ssctl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ssctl.cpp
//
//  Contents:   Self Signed Certificate Trust List Subsystem used by the
//              Certificate Chaining Infrastructure for building complex
//              chains
//
//  History:    11-Feb-98    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  Attempt to get and allocate the CTL NextUpdate location Url array.
//--------------------------------------------------------------------------
BOOL
WINAPI
SSCtlGetNextUpdateUrl(
    IN PCCTL_CONTEXT pCtl,
    OUT PCRYPT_URL_ARRAY *ppUrlArray
    )
{
#if 1
    // On 03-May-02 REMOVE_CTL_UPDATE_SUPPORT
    *ppUrlArray = NULL;
    SetLastError((DWORD) CRYPT_E_NOT_FOUND);
    return FALSE;

#else

    BOOL fResult;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD cbUrlArray = 0;
    LPVOID apv[2];

    apv[0] = (LPVOID) pCtl;
    apv[1] = (LPVOID)(UINT_PTR)(0);     // Signer Index

    if (!ChainGetObjectUrl(
            URL_OID_CTL_NEXT_UPDATE,
            apv,
            0,              // dwFlags
            NULL,           // pUrlArray
            &cbUrlArray,
            NULL,           // pUrlInfo
            NULL,           // cbUrlInfo,
            NULL            // pvReserved
            ))
        goto GetObjectUrlError;

    pUrlArray = (PCRYPT_URL_ARRAY) new BYTE [cbUrlArray];
    if (NULL == pUrlArray)
        goto OutOfMemory;

    if (!ChainGetObjectUrl(
            URL_OID_CTL_NEXT_UPDATE,
            apv,
            0,              // dwFlags
            pUrlArray,
            &cbUrlArray,
            NULL,           // pUrlInfo
            NULL,           // cbUrlInfo,
            NULL            // pvReserved
            ))
        goto GetObjectUrlError;

    if (0 == pUrlArray->cUrl)
        goto NoNextUpdateUrls;

    fResult = TRUE;
CommonReturn:
    *ppUrlArray = pUrlArray;
    return fResult;

ErrorReturn:
    if (pUrlArray) {
        delete (LPBYTE) pUrlArray;
        pUrlArray = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetObjectUrlError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(NoNextUpdateUrls, CRYPT_E_NOT_FOUND)

#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CSSCtlObject, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSSCtlObject::CSSCtlObject (
                    IN PCCERTCHAINENGINE pChainEngine,
                    IN PCCTL_CONTEXT pCtlContext,
                    IN BOOL fAdditionalStore,
                    OUT BOOL& rfResult
                    )
{
    DWORD           cbData;
    CRYPT_DATA_BLOB DataBlob;

    rfResult = TRUE;

    m_cRefs = 1;
    m_pCtlContext = CertDuplicateCTLContext( pCtlContext );
    m_fHasSignatureBeenVerified = FALSE;
    m_fSignatureValid = FALSE;
    m_hMessageStore = NULL;
    m_hHashEntry = NULL;
    m_pChainEngine = pChainEngine;

    m_pNextUpdateUrlArray = NULL;
    m_dwOfflineCnt = 0;
    I_CryptZeroFileTime(&m_OfflineUpdateTime);

    memset( &m_SignerInfo, 0, sizeof( m_SignerInfo ) );

    cbData = CHAINHASHLEN;
    rfResult = CertGetCTLContextProperty(
                   pCtlContext,
                   CERT_MD5_HASH_PROP_ID,
                   m_rgbCtlHash,
                   &cbData 
                   );

    if ( rfResult && CHAINHASHLEN != cbData)
    {
        rfResult = FALSE;
        SetLastError( (DWORD) E_UNEXPECTED);
    }

    if (!fAdditionalStore)
    {
        if ( rfResult == TRUE )
        {
            DataBlob.cbData = CHAINHASHLEN;
            DataBlob.pbData = m_rgbCtlHash;

            rfResult = I_CryptCreateLruEntry(
                              pChainEngine->SSCtlObjectCache()->HashIndex(),
                              &DataBlob,
                              this,
                              &m_hHashEntry
                              );
        }

        if ( rfResult == TRUE )
        {
            m_hMessageStore = CertOpenStore(
                                  CERT_STORE_PROV_MSG,
                                  X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                  NULL,
                                  0,
                                  pCtlContext->hCryptMsg
                                  );

            if ( m_hMessageStore == NULL )
            {
                rfResult = FALSE;
            }
        }
    }

    if ( rfResult == TRUE )
    {
        rfResult = SSCtlGetSignerInfo( pCtlContext, &m_SignerInfo );
    }

#if 0
    // On 03-May-02 REMOVE_CTL_UPDATE_SUPPORT

    if (!fAdditionalStore)
    {
        if ( rfResult == TRUE )
        {
            if (!I_CryptIsZeroFileTime(&m_pCtlContext->pCtlInfo->NextUpdate))
            {
                // Ignore any errors
                SSCtlGetNextUpdateUrl(m_pCtlContext, &m_pNextUpdateUrlArray);
            }
        }
    }
#endif

    assert( m_pChainEngine != NULL );
    assert( m_pCtlContext != NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::~CSSCtlObject, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSSCtlObject::~CSSCtlObject ()
{
    SSCtlFreeSignerInfo( &m_SignerInfo );

    if ( m_hMessageStore != NULL )
    {
        CertCloseStore( m_hMessageStore, 0 );
    }

    if ( m_pNextUpdateUrlArray != NULL )
    {
        delete (LPBYTE) m_pNextUpdateUrlArray;
    }

    if ( m_hHashEntry != NULL )
    {
        I_CryptReleaseLruEntry( m_hHashEntry );
    }

    CertFreeCTLContext( m_pCtlContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::GetSigner, public
//
//  Synopsis:   get the certificate object of the signer
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObject::GetSigner (
                 IN PCCHAINPATHOBJECT pSubject,
                 IN PCCHAINCALLCONTEXT pCallContext,
                 IN HCERTSTORE hAdditionalStore,
                 OUT PCCHAINPATHOBJECT* ppSigner,
                 OUT BOOL* pfCtlSignatureValid
                 )
{
    BOOL              fResult;
    PCCHAINPATHOBJECT pSigner = NULL;
    BOOL fNewSigner = TRUE;

    fResult = SSCtlGetSignerChainPathObject(
                   pSubject,
                   pCallContext,
                   &m_SignerInfo,
                   hAdditionalStore,
                   &pSigner,
                   &fNewSigner
                   );

    if (fResult)
    {
        if ( !m_fHasSignatureBeenVerified || fNewSigner )
        {
            CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

            memset(&CtrlPara, 0, sizeof(CtrlPara));
            CtrlPara.cbSize = sizeof(CtrlPara);
            // CtrlPara.hCryptProv =

            // This needs to be updated when chain building
            // supports CTLs with more than one signer.
            CtrlPara.dwSignerIndex = 0;
            CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
            CtrlPara.pvSigner = (void *) pSigner->CertObject()->CertContext();


            m_fSignatureValid = CryptMsgControl(
                                     m_pCtlContext->hCryptMsg,
                                     0,
                                     CMSG_CTRL_VERIFY_SIGNATURE_EX,
                                     &CtrlPara
                                     );

            m_fHasSignatureBeenVerified = TRUE;

            CertPerfIncrementChainVerifyCtlSignatureCount();
        }
        else
        {
            CertPerfIncrementChainBeenVerifiedCtlSignatureCount();
        }

        *ppSigner = pSigner;
    }
    *pfCtlSignatureValid = m_fSignatureValid;


    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::GetTrustListInfo, public
//
//  Synopsis:   get the trust list information relative to a particular cert
//              object
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObject::GetTrustListInfo (
                 IN PCCERT_CONTEXT pCertContext,
                 OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
                 )
{
    PCTL_ENTRY            pCtlEntry;
    PCERT_TRUST_LIST_INFO pTrustListInfo;

    pCtlEntry = CertFindSubjectInCTL(
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    CTL_CERT_SUBJECT_TYPE,
                    (LPVOID)pCertContext,
                    m_pCtlContext,
                    0
                    );

    if ( pCtlEntry == NULL )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        return( FALSE );
    }

    pTrustListInfo = new CERT_TRUST_LIST_INFO;
    if ( pTrustListInfo == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    pTrustListInfo->cbSize = sizeof( CERT_TRUST_LIST_INFO );
    pTrustListInfo->pCtlEntry = pCtlEntry;
    pTrustListInfo->pCtlContext = CertDuplicateCTLContext( m_pCtlContext );

    *ppTrustListInfo = pTrustListInfo;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CalculateStatus, public
//
//  Synopsis:   calculate the status
//
//----------------------------------------------------------------------------
VOID
CSSCtlObject::CalculateStatus (
                       IN LPFILETIME pTime,
                       IN PCERT_USAGE_MATCH pRequestedUsage,
                       IN OUT PCERT_TRUST_STATUS pStatus
                       )
{
    assert( m_fHasSignatureBeenVerified == TRUE );

    SSCtlGetCtlTrustStatus(
         m_pCtlContext,
         m_fSignatureValid,
         pTime,
         pRequestedUsage,
         pStatus
         );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::HasNextUpdateUrl, public
//
//  Synopsis:   returns TRUE if the Ctl has a NextUpdate time and location Url
//
//----------------------------------------------------------------------------
BOOL CSSCtlObject::HasNextUpdateUrl (
                OUT LPFILETIME pUpdateTime
                )
{
#if 1
    // On 03-May-02 REMOVE_CTL_UPDATE_SUPPORT
    return FALSE;

#else

    if ( m_pNextUpdateUrlArray != NULL )
    {
        assert(!I_CryptIsZeroFileTime(&m_pCtlContext->pCtlInfo->NextUpdate));
        if (0 != m_dwOfflineCnt) {
            assert(!I_CryptIsZeroFileTime(&m_OfflineUpdateTime));
            *pUpdateTime = m_OfflineUpdateTime;
        } else
            *pUpdateTime = m_pCtlContext->pCtlInfo->NextUpdate;
        return TRUE;
    }
    else
    {
        return FALSE;
    }

#endif
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::SetOffline, public
//
//  Synopsis:   called when offline
//
//----------------------------------------------------------------------------
void CSSCtlObject::SetOffline (
                IN LPFILETIME pCurrentTime,
                OUT LPFILETIME pUpdateTime
                )
{
    m_dwOfflineCnt++;

    I_CryptIncrementFileTimeBySeconds(
            pCurrentTime,
            ChainGetOfflineUrlDeltaSeconds(m_dwOfflineCnt),
            &m_OfflineUpdateTime
            );

    *pUpdateTime = m_OfflineUpdateTime;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::CSSCtlObjectCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CSSCtlObjectCache::CSSCtlObjectCache (
                         OUT BOOL& rfResult
                         )
{
    LRU_CACHE_CONFIG Config;

    memset( &Config, 0, sizeof( Config ) );

    Config.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    Config.pfnHash = CertObjectCacheHashMd5Identifier;
    Config.cBuckets = DEFAULT_CERT_OBJECT_CACHE_BUCKETS;
    Config.pfnOnRemoval = SSCtlOnRemovalFromCache;

    m_hHashIndex = NULL;

    rfResult = I_CryptCreateLruCache( &Config, &m_hHashIndex );

    I_CryptZeroFileTime(&m_UpdateTime);
    m_fFirstUpdate = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::~CSSCtlObjectCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CSSCtlObjectCache::~CSSCtlObjectCache ()
{
    I_CryptFreeLruCache( m_hHashIndex, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::PopulateCache, public
//
//  Synopsis:   populate the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::PopulateCache (
                           IN PCCERTCHAINENGINE pChainEngine
                           )
{
    assert( pChainEngine->SSCtlObjectCache() == this );

    return( SSCtlPopulateCacheFromCertStore( pChainEngine, NULL ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::AddObject, public
//
//  Synopsis:   add an object to the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::AddObject (
                      IN PCSSCTLOBJECT pSSCtlObject,
                      IN BOOL fCheckForDuplicate
                      )
{
    FILETIME UpdateTime;

    if ( fCheckForDuplicate == TRUE )
    {
        PCSSCTLOBJECT   pDuplicate;

        pDuplicate = FindObjectByHash( pSSCtlObject->CtlHash() );
        if ( pDuplicate != NULL )
        {
            pDuplicate->Release();
            SetLastError( (DWORD) CRYPT_E_EXISTS );
            return( FALSE );
        }
    }

    pSSCtlObject->AddRef();

    if (pSSCtlObject->HasNextUpdateUrl(&UpdateTime))
    {
        // Set earliest update time
        if (I_CryptIsZeroFileTime(&m_UpdateTime) ||
                0 > CompareFileTime(&UpdateTime, &m_UpdateTime))
        {
            m_UpdateTime = UpdateTime;
        }

        m_fFirstUpdate = TRUE;

    }

    I_CryptInsertLruEntry( pSSCtlObject->HashIndexEntry(), NULL );

    if (pSSCtlObject->MessageStore() )
    {
        CertAddStoreToCollection(
            pSSCtlObject->ChainEngine()->OtherStore(),
            pSSCtlObject->MessageStore(),
            0,
            0
            );
    }

    CertPerfIncrementChainCtlCacheCount();

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::RemoveObject, public
//
//  Synopsis:   remove object from cache
//
//----------------------------------------------------------------------------
VOID
CSSCtlObjectCache::RemoveObject (
                         IN PCSSCTLOBJECT pSSCtlObject
                         )
{
    I_CryptRemoveLruEntry( pSSCtlObject->HashIndexEntry(), 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::FindObjectByHash, public
//
//  Synopsis:   find object with given hash
//
//----------------------------------------------------------------------------
PCSSCTLOBJECT
CSSCtlObjectCache::FindObjectByHash (
                       IN BYTE rgbHash [ CHAINHASHLEN ]
                       )
{
    HLRUENTRY       hFound;
    PCSSCTLOBJECT   pFound = NULL;
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = CHAINHASHLEN;
    HashBlob.pbData = rgbHash;

    hFound = I_CryptFindLruEntry( m_hHashIndex, &HashBlob );
    if ( hFound != NULL )
    {
        pFound = (PCSSCTLOBJECT)I_CryptGetLruEntryData( hFound );
        pFound->AddRef();

        I_CryptReleaseLruEntry( hFound );
    }

    return( pFound );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::EnumObjects, public
//
//  Synopsis:   enumerate objects
//
//----------------------------------------------------------------------------
VOID
CSSCtlObjectCache::EnumObjects (
                       IN PFN_ENUM_SSCTLOBJECTS pfnEnum,
                       IN LPVOID pvParameter
                       )
{
    SSCTL_ENUM_OBJECTS_DATA EnumData;

    EnumData.pfnEnumObjects = pfnEnum;
    EnumData.pvEnumParameter = pvParameter;

    I_CryptWalkAllLruCacheEntries(
           m_hHashIndex,
           SSCtlEnumObjectsWalkFn,
           &EnumData
           );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::Resync, public
//
//  Synopsis:   resync the cache
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::Resync (IN PCCERTCHAINENGINE pChainEngine)
{
    I_CryptFlushLruCache( m_hHashIndex, 0, NULL );

    I_CryptZeroFileTime(&m_UpdateTime);
    m_fFirstUpdate = FALSE;

    return( PopulateCache( pChainEngine ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::UpdateCache, public
//
//  Synopsis:   update the cache
//
//              Leaves the engine's critical section to do the URL
//              fetching. If the engine was touched by another thread,
//              it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//              If the CTL is updated, increments the engine's touch count
//              and flushes issuer and end cert object caches.
//
//  Assumption: Chain engine is locked once in the calling thread.
//
//----------------------------------------------------------------------------
BOOL
CSSCtlObjectCache::UpdateCache (
    IN PCCERTCHAINENGINE pChainEngine,
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
#if 1
    // On 03-May-02 REMOVE_CTL_UPDATE_SUPPORT

    return TRUE;
#else

    FILETIME CurrentTime;
    SSCTL_UPDATE_CTL_OBJ_PARA Para;
    
    assert( pChainEngine->SSCtlObjectCache() == this );

    // Check if we have any CTLs needing to be updated
    if (I_CryptIsZeroFileTime(&m_UpdateTime))
        return TRUE;
    pCallContext->CurrentTime(&CurrentTime);
    if (0 < CompareFileTime(&m_UpdateTime, &CurrentTime))
        return TRUE;

    if (!m_fFirstUpdate && !pCallContext->IsOnline())
        return TRUE;

    memset(&Para, 0, sizeof(Para));
    Para.pChainEngine = pChainEngine;
    Para.pCallContext = pCallContext;

    EnumObjects(SSCtlUpdateCtlObjectEnumFn, &Para);
    if (pCallContext->IsTouchedEngine()) {
        PSSCTL_UPDATE_CTL_OBJ_ENTRY pEntry;

        pEntry = Para.pEntry;
        while (pEntry) {
            PSSCTL_UPDATE_CTL_OBJ_ENTRY pDeleteEntry;

            pEntry->pSSCtlObjectAdd->Release();

            pDeleteEntry = pEntry;
            pEntry = pEntry->pNext;
            delete pDeleteEntry;
        }

        return FALSE;
    }


    m_UpdateTime = Para.UpdateTime;
    m_fFirstUpdate = FALSE;

    if (Para.pEntry) {
        HCERTSTORE hTrustStore;
        PSSCTL_UPDATE_CTL_OBJ_ENTRY pEntry;

        hTrustStore = pChainEngine->OpenTrustStore();

        pChainEngine->CertObjectCache()->FlushObjects( pCallContext );
        pCallContext->TouchEngine();

        pEntry = Para.pEntry;
        while (pEntry) {
            PSSCTL_UPDATE_CTL_OBJ_ENTRY pDeleteEntry;

            RemoveObject(pEntry->pSSCtlObjectRemove);
            if (AddObject(pEntry->pSSCtlObjectAdd, TRUE)) {
                if (hTrustStore) {
                    // Persist the newer CTL to the trust store
                    CertAddCTLContextToStore(
                        hTrustStore,
                        pEntry->pSSCtlObjectAdd->CtlContext(),
                        CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES,
                        NULL
                        );
                }
            }

            pEntry->pSSCtlObjectAdd->Release();

            pDeleteEntry = pEntry;
            pEntry = pEntry->pNext;
            delete pDeleteEntry;
        }

        if (hTrustStore)
            CertCloseStore(hTrustStore, 0);
    }


    return TRUE;

#endif

}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlOnRemovalFromCache
//
//  Synopsis:   SS CTL removal notification used when the cache is destroyed
//              or an object is explicitly removed.  Note that this cache
//              does not LRU remove objects
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlOnRemovalFromCache (
     IN LPVOID pv,
     IN OPTIONAL LPVOID pvRemovalContext
     )
{
    PCSSCTLOBJECT pSSCtlObject = (PCSSCTLOBJECT) pv;
    CertPerfDecrementChainCtlCacheCount();

    assert( pvRemovalContext == NULL );

    if (pSSCtlObject->MessageStore() )
    {
        CertRemoveStoreFromCollection(
            pSSCtlObject->ChainEngine()->OtherStore(),
            pSSCtlObject->MessageStore()
            );
    }

    pSSCtlObject->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetSignerInfo
//
//  Synopsis:   get the signer info
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlGetSignerInfo (
     IN PCCTL_CONTEXT pCtlContext,
     OUT PSSCTL_SIGNER_INFO pSignerInfo
     )
{
    BOOL              fResult;
    PCERT_INFO        pMessageSignerCertInfo = NULL;
    DWORD             cbData = 0;

    fResult = CryptMsgGetParam(
                   pCtlContext->hCryptMsg,
                   CMSG_SIGNER_CERT_INFO_PARAM,
                   0,
                   NULL,
                   &cbData
                   );

    if ( fResult == TRUE )
    {
        pMessageSignerCertInfo = (PCERT_INFO)new BYTE [ cbData ];
        if ( pMessageSignerCertInfo != NULL )
        {
            fResult = CryptMsgGetParam(
                           pCtlContext->hCryptMsg,
                           CMSG_SIGNER_CERT_INFO_PARAM,
                           0,
                           pMessageSignerCertInfo,
                           &cbData
                           );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        pSignerInfo->pMessageSignerCertInfo = pMessageSignerCertInfo;
        pSignerInfo->fSignerHashAvailable = FALSE;
    }
    else
    {
        delete pMessageSignerCertInfo;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeSignerInfo
//
//  Synopsis:   free the data in the signer info
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeSignerInfo (
     IN PSSCTL_SIGNER_INFO pSignerInfo
     )
{
    delete (LPBYTE)pSignerInfo->pMessageSignerCertInfo;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetSignerChainPathObject
//
//  Synopsis:   get the signer chain path object
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlGetSignerChainPathObject (
     IN PCCHAINPATHOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PSSCTL_SIGNER_INFO pSignerInfo,
     IN HCERTSTORE hAdditionalStore,
     OUT PCCHAINPATHOBJECT* ppSigner,
     OUT BOOL *pfNewSigner
     )
{
    BOOL              fResult = TRUE;
    PCCERTCHAINENGINE pChainEngine = pSubject->CertObject()->ChainEngine();
    PCCERTOBJECTCACHE pCertObjectCache = pChainEngine->CertObjectCache();
    PCCERTOBJECT      pCertObject = NULL;
    PCCERT_CONTEXT    pCertContext = NULL;
    PCCHAINPATHOBJECT pSigner = NULL;
    BOOL              fAdditionalStoreUsed = FALSE;
    BYTE              rgbCertHash[ CHAINHASHLEN ];


    *pfNewSigner = FALSE;

    if ( pSignerInfo->fSignerHashAvailable == TRUE )
    {
        pCertObject = pCertObjectCache->FindIssuerObjectByHash(
            pSignerInfo->rgbSignerCertHash );
    }

    if ( pCertObject == NULL )
    {
        if ( pSignerInfo->fSignerHashAvailable == TRUE )
        {
            pCertContext = SSCtlFindCertificateInStoreByHash(
                                pChainEngine->OtherStore(),
                                pSignerInfo->rgbSignerCertHash
                                );

            if ( ( pCertContext == NULL ) && ( hAdditionalStore != NULL ) )
            {
                fAdditionalStoreUsed = TRUE;

                pCertContext = SSCtlFindCertificateInStoreByHash(
                                    hAdditionalStore,
                                    pSignerInfo->rgbSignerCertHash
                                    );
            }
        }

        if ( pCertContext == NULL )
        {
            *pfNewSigner = TRUE;
            fAdditionalStoreUsed = FALSE;

            pCertContext = CertGetSubjectCertificateFromStore(
                                pChainEngine->OtherStore(),
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                pSignerInfo->pMessageSignerCertInfo
                                );
        }

        if ( ( pCertContext == NULL ) && ( hAdditionalStore != NULL ) )
        {
            fAdditionalStoreUsed = TRUE;

            pCertContext = CertGetSubjectCertificateFromStore(
                                hAdditionalStore,
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                pSignerInfo->pMessageSignerCertInfo
                                );
        }

        if ( pCertContext != NULL )
        {
            DWORD cbData = CHAINHASHLEN;
            fResult = CertGetCertificateContextProperty(
                          pCertContext,
                          CERT_MD5_HASH_PROP_ID,
                          rgbCertHash,
                          &cbData
                          );

            if ( fResult && CHAINHASHLEN != cbData)
            {
                fResult = FALSE;
                SetLastError( (DWORD) E_UNEXPECTED);
            }

            if ( fResult == TRUE )
            {
                fResult = ChainCreateCertObject (
                    fAdditionalStoreUsed ?
                        CERT_EXTERNAL_ISSUER_OBJECT_TYPE :
                        CERT_CACHED_ISSUER_OBJECT_TYPE,
                    pCallContext,
                    pCertContext,
                    rgbCertHash,
                    &pCertObject
                    );
            }

            CertFreeCertificateContext( pCertContext );
        }
        else
        {
            fResult = FALSE;
            SetLastError((DWORD) CRYPT_E_NOT_FOUND);
        }
    }

    if ( fResult )
    {
        assert(pCertObject);
        fResult = ChainCreatePathObject(
            pCallContext,
            pCertObject,
            hAdditionalStore,
            &pSigner
            );
    }

    if ( fResult )
    {
        assert(pSigner);

        if ( !pSignerInfo->fSignerHashAvailable || *pfNewSigner )
        {
            memcpy(
               pSignerInfo->rgbSignerCertHash,
               rgbCertHash,
               CHAINHASHLEN
               );

            pSignerInfo->fSignerHashAvailable = TRUE;
        }

    }

    if ( pCertObject != NULL )
    {
        pCertObject->Release();
    }

    *ppSigner = pSigner;

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFindCertificateInStoreByHash
//
//  Synopsis:   find certificate in store by hash
//
//----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI
SSCtlFindCertificateInStoreByHash (
     IN HCERTSTORE hStore,
     IN BYTE rgbHash [ CHAINHASHLEN]
     )
{
    CRYPT_HASH_BLOB HashBlob;

    HashBlob.cbData = CHAINHASHLEN;
    HashBlob.pbData = rgbHash;

    return( CertFindCertificateInStore(
                hStore,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                0,
                CERT_FIND_MD5_HASH,
                &HashBlob,
                NULL
                ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlGetCtlTrustStatus
//
//  Synopsis:   get the trust status for the CTL
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlGetCtlTrustStatus (
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fSignatureValid,
     IN LPFILETIME pTime,
     IN PCERT_USAGE_MATCH pRequestedUsage,
     IN OUT PCERT_TRUST_STATUS pStatus
     )
{
    FILETIME          NoTime;
    CERT_TRUST_STATUS UsageStatus;

    memset( &NoTime, 0, sizeof( NoTime ) );

    if ( fSignatureValid == FALSE )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
    }

    if ( ( CompareFileTime(
                  pTime,
                  &pCtlContext->pCtlInfo->ThisUpdate
                  ) < 0 ) ||
         ( ( ( CompareFileTime(
                      &NoTime,
                      &pCtlContext->pCtlInfo->NextUpdate
                      ) != 0 ) &&
             ( CompareFileTime(
                      pTime,
                      &pCtlContext->pCtlInfo->NextUpdate
                      ) > 0 ) ) ) )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_TIME_VALID;
    }

    memset( &UsageStatus, 0, sizeof( UsageStatus ) );
    ChainGetUsageStatus(
         (PCERT_ENHKEY_USAGE)&pRequestedUsage->Usage,
         (PCERT_ENHKEY_USAGE)&pCtlContext->pCtlInfo->SubjectUsage,
         pRequestedUsage->dwType,
         &UsageStatus
         );

    if ( UsageStatus.dwErrorStatus & CERT_TRUST_IS_NOT_VALID_FOR_USAGE )
    {
        pStatus->dwErrorStatus |= CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlPopulateCacheFromCertStore
//
//  Synopsis:   populate the SS CTL object cache from certificate store CTLs
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlPopulateCacheFromCertStore (
     IN PCCERTCHAINENGINE pChainEngine,
     IN OPTIONAL HCERTSTORE hStore
     )
{
    BOOL               fResult;
    BOOL               fAdditionalStore = TRUE;
    PCCTL_CONTEXT      pCtlContext = NULL;
    BYTE               rgbCtlHash[ CHAINHASHLEN ];
    PCSSCTLOBJECT      pSSCtlObject;
    PCSSCTLOBJECTCACHE pSSCtlObjectCache;

    pSSCtlObjectCache = pChainEngine->SSCtlObjectCache();

    if ( hStore == NULL )
    {
        hStore = pChainEngine->TrustStore();
        fAdditionalStore = FALSE;
    }

    while ( ( pCtlContext = CertEnumCTLsInStore(
                                hStore,
                                pCtlContext
                                ) ) != NULL )
    {
        DWORD cbData = CHAINHASHLEN;
        fResult = CertGetCTLContextProperty(
                      pCtlContext,
                      CERT_MD5_HASH_PROP_ID,
                      rgbCtlHash,
                      &cbData
                      );
        if ( fResult && CHAINHASHLEN != cbData)
        {
            fResult = FALSE;
            SetLastError( (DWORD) E_UNEXPECTED);
        }

        if ( fResult == TRUE )
        {
            pSSCtlObject = pSSCtlObjectCache->FindObjectByHash( rgbCtlHash );
            if ( pSSCtlObject == NULL )
            {
                fResult = SSCtlCreateCtlObject(
                               pChainEngine,
                               pCtlContext,
                               FALSE,               // fAdditionalStore
                               &pSSCtlObject
                               );
            }
            else
            {
                pSSCtlObject->Release();
                fResult = FALSE;
            }

            if ( fResult == TRUE )
            {
                fResult = pSSCtlObjectCache->AddObject( pSSCtlObject, FALSE );

                // NOTE: Since fDuplicate == FALSE this should never fail
                assert( fResult == TRUE );

                pSSCtlObject->Release();
            }
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlCreateCtlObject
//
//  Synopsis:   create an SS CTL Object
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlCreateCtlObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fAdditionalStore,
     OUT PCSSCTLOBJECT* ppSSCtlObject
     )
{
    BOOL          fResult = TRUE;
    PCSSCTLOBJECT pSSCtlObject;

    pSSCtlObject = new CSSCtlObject( 
        pChainEngine, pCtlContext, fAdditionalStore, fResult );
    if ( pSSCtlObject == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        fResult = FALSE;
    }
    else if ( fResult == TRUE )
    {
        *ppSSCtlObject = pSSCtlObject;
    }
    else
    {
        delete pSSCtlObject;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlEnumObjectsWalkFn
//
//  Synopsis:   object enumerator walk function
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlEnumObjectsWalkFn (
     IN LPVOID pvParameter,
     IN HLRUENTRY hEntry
     )
{
    PSSCTL_ENUM_OBJECTS_DATA pEnumData = (PSSCTL_ENUM_OBJECTS_DATA)pvParameter;

    return( ( *pEnumData->pfnEnumObjects )(
                             pEnumData->pvEnumParameter,
                             (PCSSCTLOBJECT)I_CryptGetLruEntryData( hEntry )
                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlCreateObjectCache
//
//  Synopsis:   create the SS CTL object cache
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlCreateObjectCache (
     OUT PCSSCTLOBJECTCACHE* ppSSCtlObjectCache
     )
{
    BOOL               fResult = TRUE;
    PCSSCTLOBJECTCACHE pSSCtlObjectCache;

    pSSCtlObjectCache = new CSSCtlObjectCache( fResult );

    if ( pSSCtlObjectCache == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        fResult = FALSE;
    }
    else if ( fResult == TRUE )
    {
        *ppSSCtlObjectCache = pSSCtlObjectCache;
    }
    else
    {
        delete pSSCtlObjectCache;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeObjectCache
//
//  Synopsis:   free the object cache
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeObjectCache (
     IN PCSSCTLOBJECTCACHE pSSCtlObjectCache
     )
{
    delete pSSCtlObjectCache;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlFreeTrustListInfo
//
//  Synopsis:   free the trust list info
//
//----------------------------------------------------------------------------
VOID WINAPI
SSCtlFreeTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo
     )
{
    CertFreeCTLContext( pTrustListInfo->pCtlContext );

    delete pTrustListInfo;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCtlAllocAndCopyTrustListInfo
//
//  Synopsis:   allocate and copy the trust list info
//
//----------------------------------------------------------------------------
BOOL WINAPI
SSCtlAllocAndCopyTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo,
     OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
     )
{
    PCERT_TRUST_LIST_INFO pCopyTrustListInfo;

    pCopyTrustListInfo = new CERT_TRUST_LIST_INFO;
    if ( pCopyTrustListInfo == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    pCopyTrustListInfo->cbSize = sizeof( CERT_TRUST_LIST_INFO );

    pCopyTrustListInfo->pCtlContext = CertDuplicateCTLContext(
                                          pTrustListInfo->pCtlContext
                                          );

    pCopyTrustListInfo->pCtlEntry = pTrustListInfo->pCtlEntry;

    *ppTrustListInfo = pCopyTrustListInfo;

    return( TRUE );
}

//+-------------------------------------------------------------------------
//  Retrieve a newer and time valid CTL at one of the NextUpdate Urls
//
//  Leaves the engine's critical section to do the URL
//  fetching. If the engine was touched by another thread,
//  it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//--------------------------------------------------------------------------
BOOL
WINAPI
SSCtlRetrieveCtlUrl(
    IN PCCERTCHAINENGINE pChainEngine,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PCRYPT_URL_ARRAY pNextUpdateUrlArray,
    IN DWORD dwRetrievalFlags,
    IN OUT PCCTL_CONTEXT *ppCtl,
    IN OUT BOOL *pfNewerCtl,
    IN OUT BOOL *pfTimeValid
    )
{
#if 1
    // On 03-May-02 REMOVE_CTL_UPDATE_SUPPORT

    return TRUE;

#else

    BOOL fResult;
    DWORD i;

    // Loop through Urls and try to retrieve a newer and time valid CTL
    for (i = 0; i < pNextUpdateUrlArray->cUrl; i++) {
        PCCTL_CONTEXT pNewCtl = NULL;
        LPWSTR pwszUrl = NULL;
        DWORD cbUrl;


        // Do URL fetching outside of the engine's critical section

        // Need to make a copy of the Url string. pNextUpdateUrlArray
        // can be modified by another thread outside of the critical section.
        cbUrl = (wcslen(pNextUpdateUrlArray->rgwszUrl[i]) + 1) * sizeof(WCHAR);
        pwszUrl = (LPWSTR) PkiNonzeroAlloc(cbUrl);
        if (NULL == pwszUrl)
            goto OutOfMemory;
        memcpy(pwszUrl, pNextUpdateUrlArray->rgwszUrl[i], cbUrl);

        pCallContext->ChainEngine()->UnlockEngine();
        fResult = ChainRetrieveObjectByUrlW(
                pwszUrl,
                CONTEXT_OID_CTL,
                dwRetrievalFlags |
                    CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL |
                    CRYPT_STICKY_CACHE_RETRIEVAL,
                pCallContext->ChainPara()->dwUrlRetrievalTimeout,
                (LPVOID *) &pNewCtl,
                NULL,                               // hAsyncRetrieve
                NULL,                               // pCredentials
                NULL,                               // pvVerify
                NULL                                // pAuxInfo
                );
        pCallContext->ChainEngine()->LockEngine();

        PkiFree(pwszUrl);

        if (pCallContext->IsTouchedEngine()) {
            if (pNewCtl)
                CertFreeCTLContext(pNewCtl);
            goto TouchedDuringUrlRetrieval;
        }

        if (fResult) {
            PCCTL_CONTEXT pOldCtl;

            assert(pNewCtl);

            pOldCtl = *ppCtl;
            if (0 < CompareFileTime(&pNewCtl->pCtlInfo->ThisUpdate,
                        &pOldCtl->pCtlInfo->ThisUpdate)) {
                FILETIME CurrentTime;

                // Move us to the head of the Url list
                DWORD j;
                LPWSTR pwszUrl = pNextUpdateUrlArray->rgwszUrl[i];

                for (j = i; 0 < j; j--) {
                    pNextUpdateUrlArray->rgwszUrl[j] =
                        pNextUpdateUrlArray->rgwszUrl[j - 1];
                }
                pNextUpdateUrlArray->rgwszUrl[0] = pwszUrl;

                *pfNewerCtl = TRUE;
                CertFreeCTLContext(pOldCtl);
                *ppCtl = pNewCtl;

                pCallContext->CurrentTime(&CurrentTime);
                if (I_CryptIsZeroFileTime(&pNewCtl->pCtlInfo->NextUpdate) ||
                        0 < CompareFileTime(&pNewCtl->pCtlInfo->NextUpdate,
                                &CurrentTime)) {
                    *pfTimeValid = TRUE;
                    break;
                }
            } else
                CertFreeCTLContext(pNewCtl);
        }
    }


    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(TouchedDuringUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
TRACE_ERROR(OutOfMemory)

#endif

}


//+-------------------------------------------------------------------------
//  Update Ctl Object Enum Function
//
//  Leaves the engine's critical section to do the URL
//  fetching. If the engine was touched by another thread,
//  it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  Assumption: Chain engine is locked once in the calling thread.
//--------------------------------------------------------------------------
BOOL
WINAPI
SSCtlUpdateCtlObjectEnumFn(
    IN LPVOID pvPara,
    IN PCSSCTLOBJECT pSSCtlObject
    )
{
#if 1
    // On 03-May-02 REMOVE_CTL_UPDATE_SUPPORT

    return TRUE;

#else

    BOOL fTouchResult = TRUE;

    PSSCTL_UPDATE_CTL_OBJ_PARA pPara = (PSSCTL_UPDATE_CTL_OBJ_PARA) pvPara;
    FILETIME CurrentTime;
    FILETIME UpdateTime;
    PCCTL_CONTEXT pRetrieveCtl = NULL;
    BOOL fTimeValid = FALSE;
    BOOL fNewerCtl = FALSE;
    PCRYPT_URL_ARRAY pNextUpdateUrlArray;

    if (!pSSCtlObject->HasNextUpdateUrl(&UpdateTime))
        return TRUE;

    pPara->pCallContext->CurrentTime(&CurrentTime);

    if (0 < CompareFileTime(&UpdateTime, &CurrentTime))
        goto CommonReturn;

    pRetrieveCtl = CertDuplicateCTLContext(pSSCtlObject->CtlContext());
    pNextUpdateUrlArray = pSSCtlObject->NextUpdateUrlArray();

    SSCtlRetrieveCtlUrl(
        pPara->pChainEngine,
        pPara->pCallContext,
        pNextUpdateUrlArray,
        CRYPT_CACHE_ONLY_RETRIEVAL,
        &pRetrieveCtl,
        &fNewerCtl,
        &fTimeValid
        );
    if (pPara->pCallContext->IsTouchedEngine()) {
        fTouchResult = FALSE;
        goto TouchedDuringUrlRetrieval;
    }

    if (!fTimeValid && pPara->pCallContext->IsOnline()) {
        SSCtlRetrieveCtlUrl(
            pPara->pChainEngine,
            pPara->pCallContext,
            pNextUpdateUrlArray,
            CRYPT_WIRE_ONLY_RETRIEVAL,
            &pRetrieveCtl,
            &fNewerCtl,
            &fTimeValid
            );
        if (pPara->pCallContext->IsTouchedEngine()) {
            fTouchResult = FALSE;
            goto TouchedDuringUrlRetrieval;
        }

        if (!fNewerCtl)
            pSSCtlObject->SetOffline(&CurrentTime, &UpdateTime);
    }

    if (fNewerCtl) {
        PSSCTL_UPDATE_CTL_OBJ_ENTRY pEntry;

        pSSCtlObject->SetOnline();

        pEntry = new SSCTL_UPDATE_CTL_OBJ_ENTRY;
        if (NULL == pEntry)
            goto OutOfMemory;

        if (!SSCtlCreateCtlObject(
                pPara->pChainEngine,
                pRetrieveCtl,
                FALSE,                      // fAdditionalStore
                &pEntry->pSSCtlObjectAdd
                )) {
            delete pEntry;
            goto CreateCtlObjectError;
        }

        pEntry->pSSCtlObjectRemove = pSSCtlObject;
        pEntry->pNext = pPara->pEntry;
        pPara->pEntry = pEntry;

    }

CommonReturn:
    if (!fNewerCtl) {
        if (I_CryptIsZeroFileTime(&pPara->UpdateTime) ||
                0 > CompareFileTime(&UpdateTime, &pPara->UpdateTime))
            pPara->UpdateTime = UpdateTime;
    }

    if (pRetrieveCtl)
        CertFreeCTLContext(pRetrieveCtl);

    return fTouchResult;

ErrorReturn:
    fNewerCtl = FALSE;
    goto CommonReturn;

SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(CreateCtlObjectError)
SET_ERROR(TouchedDuringUrlRetrieval, ERROR_CAN_NOT_COMPLETE)

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\ssctl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ssctl.h
//
//  Contents:   Self Signed Certificate Trust List Subsystem used by the
//              Certificate Chaining Infrastructure for building complex
//              chains
//
//  History:    02-Feb-98    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SSCTL_H__)
#define __SSCTL_H__

#include <chain.h>

//
// CSSCtlObject.  This is the main object for caching trust information about
// a self signed certificate trust list
//

typedef struct _SSCTL_SIGNER_INFO {
    PCERT_INFO             pMessageSignerCertInfo;
    BOOL                   fSignerHashAvailable;
    BYTE                   rgbSignerCertHash[ CHAINHASHLEN ];
} SSCTL_SIGNER_INFO, *PSSCTL_SIGNER_INFO;

class CSSCtlObject
{
public:

    //
    // Construction
    //

    CSSCtlObject (
          IN PCCERTCHAINENGINE pChainEngine,
          IN PCCTL_CONTEXT pCtlContext,
          IN BOOL fAdditionalStore,
          OUT BOOL& rfResult
          );

    ~CSSCtlObject ();

    //
    // Reference counting
    //

    inline VOID AddRef ();
    inline VOID Release ();

    //
    // Trust information access
    //

    inline PCCTL_CONTEXT CtlContext ();

    BOOL GetSigner (
            IN PCCHAINPATHOBJECT pSubject,
            IN PCCHAINCALLCONTEXT pCallContext,
            IN HCERTSTORE hAdditionalStore,
            OUT PCCHAINPATHOBJECT* ppSigner,
            OUT BOOL* pfCtlSignatureValid
            );

    BOOL GetTrustListInfo (
            IN PCCERT_CONTEXT pCertContext,
            OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
            );

    VOID CalculateStatus (
                  IN LPFILETIME pTime,
                  IN PCERT_USAGE_MATCH pRequestedUsage,
                  IN OUT PCERT_TRUST_STATUS pStatus
                  );

    //
    // Hash access
    //

    inline LPBYTE CtlHash ();

    //
    // Index entry handles
    //

    inline HLRUENTRY HashIndexEntry ();

    //
    // Returns pointer to the Ctl's NextUpdate location url array
    //

    inline PCRYPT_URL_ARRAY NextUpdateUrlArray ();

    //
    // Returns TRUE if the Ctl has a NextUpdate time and location Url
    //

    BOOL HasNextUpdateUrl (
                    OUT LPFILETIME pUpdateTime
                    );

    //
    // Called for successful online Url retrieval
    //

    inline void SetOnline ();


    //
    // Called for unsuccessful online Url retrieval
    //

    void SetOffline (
                    IN LPFILETIME pCurrentTime,
                    OUT LPFILETIME pUpdateTime
                    );


    //
    // Chain engine access
    //

    inline PCCERTCHAINENGINE ChainEngine ();

    //
    // Message store access
    //

    inline HCERTSTORE MessageStore ();


private:

    //
    // Reference count
    //

    LONG                   m_cRefs;

    //
    // Self Signed Certificate Trust List Context
    //

    PCCTL_CONTEXT          m_pCtlContext;

    //
    // MD5 Hash of CTL
    //

    BYTE                   m_rgbCtlHash[ CHAINHASHLEN ];

    //
    // Signer information
    //

    SSCTL_SIGNER_INFO      m_SignerInfo;
    BOOL                   m_fHasSignatureBeenVerified;
    BOOL                   m_fSignatureValid;

    //
    // Message Store
    //

    HCERTSTORE             m_hMessageStore;

    //
    // Hash Index Entry
    //

    HLRUENTRY              m_hHashEntry;

    //
    // Chain engine
    //

    PCCERTCHAINENGINE      m_pChainEngine;

    //
    // The following is only set if the CTL has a NextUpdate time and location
    //

    PCRYPT_URL_ARRAY       m_pNextUpdateUrlArray;

    //
    // The following is incremented for each SetOffline() call
    //
    DWORD                  m_dwOfflineCnt;

    //
    // The next update time when offline
    //
    FILETIME               m_OfflineUpdateTime;

};

//
// CSSCtlObjectCache.  Cache of self signed certificate trust list objects
// indexed by hash. Note that this cache is NOT LRU maintained.  We expect
// the number of these objects to be small
//

typedef BOOL (WINAPI *PFN_ENUM_SSCTLOBJECTS) (
                          IN LPVOID pvParameter,
                          IN PCSSCTLOBJECT pSSCtlObject
                          );

class CSSCtlObjectCache
{
public:

    //
    // Construction
    //

    CSSCtlObjectCache (
          OUT BOOL& rfResult
          );

    ~CSSCtlObjectCache ();

    //
    // Object Management
    //

    BOOL PopulateCache (
                 IN PCCERTCHAINENGINE pChainEngine
                 );

    BOOL AddObject (
            IN PCSSCTLOBJECT pSSCtlObject,
            IN BOOL fCheckForDuplicate
            );

    VOID RemoveObject (
               IN PCSSCTLOBJECT pSSCtlObject
               );

    //
    // Access the indexes
    //

    inline HLRUCACHE HashIndex ();

    //
    // Searching and Enumeration
    //

    PCSSCTLOBJECT FindObjectByHash (
                      IN BYTE rgbHash [ CHAINHASHLEN ]
                      );

    VOID EnumObjects (
             IN PFN_ENUM_SSCTLOBJECTS pfnEnum,
             IN LPVOID pvParameter
             );

    //
    // Resync
    //

    BOOL Resync (IN PCCERTCHAINENGINE pChainEngine);

    //
    // Update the cache by retrieving any expired CTLs having a
    // NextUpdate time and location.
    //

    BOOL UpdateCache (
        IN PCCERTCHAINENGINE pChainEngine,
        IN PCCHAINCALLCONTEXT pCallContext
        );

private:

    //
    // Hash Index
    //

    HLRUCACHE m_hHashIndex;

    //
    // The following is nonzero, if any CTL has a NextUpdate time and location
    //

    FILETIME m_UpdateTime;

    //
    // The following is TRUE, for the first update of any CTL with a
    // NextUpdate time and location
    //
    BOOL m_fFirstUpdate;
};

//
// Object removal notification function
//

VOID WINAPI
SSCtlOnRemovalFromCache (
     IN LPVOID pv,
     IN OPTIONAL LPVOID pvRemovalContext
     );

//
// SSCtl Subsystem Utility Function Prototypes
//

BOOL WINAPI
SSCtlGetSignerInfo (
     IN PCCTL_CONTEXT pCtlContext,
     OUT PSSCTL_SIGNER_INFO pSignerInfo
     );

VOID WINAPI
SSCtlFreeSignerInfo (
     IN PSSCTL_SIGNER_INFO pSignerInfo
     );

BOOL WINAPI
SSCtlGetSignerChainPathObject (
     IN PCCHAINPATHOBJECT pSubject,
     IN PCCHAINCALLCONTEXT pCallContext,
     IN PSSCTL_SIGNER_INFO pSignerInfo,
     IN HCERTSTORE hAdditionalStore,
     OUT PCCHAINPATHOBJECT* ppSigner,
     OUT BOOL *pfNewSigner
     );

PCCERT_CONTEXT WINAPI
SSCtlFindCertificateInStoreByHash (
     IN HCERTSTORE hStore,
     IN BYTE rgbHash [ CHAINHASHLEN]
     );

VOID WINAPI
SSCtlGetCtlTrustStatus (
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fSignatureValid,
     IN LPFILETIME pTime,
     IN PCERT_USAGE_MATCH pRequestedUsage,
     IN OUT PCERT_TRUST_STATUS pStatus
     );

BOOL WINAPI
SSCtlPopulateCacheFromCertStore (
     IN PCCERTCHAINENGINE pChainEngine,
     IN OPTIONAL HCERTSTORE hStore
     );

BOOL WINAPI
SSCtlCreateCtlObject (
     IN PCCERTCHAINENGINE pChainEngine,
     IN PCCTL_CONTEXT pCtlContext,
     IN BOOL fAdditionalStore,
     OUT PCSSCTLOBJECT* ppSSCtlObject
     );

typedef struct _SSCTL_ENUM_OBJECTS_DATA {
    PFN_ENUM_SSCTLOBJECTS pfnEnumObjects;
    LPVOID                pvEnumParameter;
} SSCTL_ENUM_OBJECTS_DATA, *PSSCTL_ENUM_OBJECTS_DATA;

BOOL WINAPI
SSCtlEnumObjectsWalkFn (
     IN LPVOID pvParameter,
     IN HLRUENTRY hEntry
     );

BOOL WINAPI
SSCtlCreateObjectCache (
     OUT PCSSCTLOBJECTCACHE* ppSSCtlObjectCache
     );

VOID WINAPI
SSCtlFreeObjectCache (
     IN PCSSCTLOBJECTCACHE pSSCtlObjectCache
     );

VOID WINAPI
SSCtlFreeTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo
     );

BOOL WINAPI
SSCtlAllocAndCopyTrustListInfo (
     IN PCERT_TRUST_LIST_INFO pTrustListInfo,
     OUT PCERT_TRUST_LIST_INFO* ppTrustListInfo
     );

//
//  Retrieve a newer and time valid CTL at one of the NextUpdate Urls
//

BOOL
WINAPI
SSCtlRetrieveCtlUrl(
    IN PCCERTCHAINENGINE pChainEngine,
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PCRYPT_URL_ARRAY pNextUpdateUrlArray,
    IN DWORD dwRetrievalFlags,
    IN OUT PCCTL_CONTEXT *ppCtl,
    IN OUT BOOL *pfNewerCtl,
    IN OUT BOOL *pfTimeValid
    );

//
//  Update Ctl Object Enum Function
//

typedef struct _SSCTL_UPDATE_CTL_OBJ_ENTRY SSCTL_UPDATE_CTL_OBJ_ENTRY,
                                            *PSSCTL_UPDATE_CTL_OBJ_ENTRY;

struct _SSCTL_UPDATE_CTL_OBJ_ENTRY {
    PCSSCTLOBJECT               pSSCtlObjectAdd;
    PCSSCTLOBJECT               pSSCtlObjectRemove;
    PSSCTL_UPDATE_CTL_OBJ_ENTRY pNext;
};

typedef struct _SSCTL_UPDATE_CTL_OBJ_PARA {
    PCCERTCHAINENGINE           pChainEngine;
    PCCHAINCALLCONTEXT          pCallContext;

    FILETIME                    UpdateTime;
    PSSCTL_UPDATE_CTL_OBJ_ENTRY pEntry;
} SSCTL_UPDATE_CTL_OBJ_PARA, *PSSCTL_UPDATE_CTL_OBJ_PARA;

BOOL
WINAPI
SSCtlUpdateCtlObjectEnumFn(
    IN LPVOID pvPara,
    IN PCSSCTLOBJECT pSSCtlObject
    );

//
// Inline methods
//

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::AddRef, public
//
//  Synopsis:   add a reference
//
//----------------------------------------------------------------------------
inline VOID
CSSCtlObject::AddRef ()
{
    InterlockedIncrement( &m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::Release, public
//
//  Synopsis:   release a reference
//
//----------------------------------------------------------------------------
inline VOID
CSSCtlObject::Release ()
{
    if ( InterlockedDecrement( &m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CtlContext, public
//
//  Synopsis:   return the CTL context
//
//----------------------------------------------------------------------------
inline PCCTL_CONTEXT
CSSCtlObject::CtlContext ()
{
    return( m_pCtlContext );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::CtlHash, public
//
//  Synopsis:   return the hash
//
//----------------------------------------------------------------------------
inline LPBYTE
CSSCtlObject::CtlHash ()
{
    return( m_rgbCtlHash );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::HashIndexEntry, public
//
//  Synopsis:   return the hash index entry
//
//----------------------------------------------------------------------------
inline HLRUENTRY
CSSCtlObject::HashIndexEntry ()
{
    return( m_hHashEntry );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::NextUpdateUrlArray, public
//
//  Synopsis:   return pointer to the Ctl's NextUpdate location url array
//
//----------------------------------------------------------------------------
inline PCRYPT_URL_ARRAY CSSCtlObject::NextUpdateUrlArray ()
{
    return m_pNextUpdateUrlArray;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::SetOnlineUpdate, public
//
//  Synopsis:   called for successful online Url retrieval
//
//----------------------------------------------------------------------------
inline void CSSCtlObject::SetOnline ()
{
    m_dwOfflineCnt = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::ChainEngine, public
//
//  Synopsis:   return the chain engine object
//
//----------------------------------------------------------------------------
inline PCCERTCHAINENGINE
CSSCtlObject::ChainEngine ()
{
    return( m_pChainEngine );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObject::MessageStore, public
//
//  Synopsis:   return the object's message store
//
//----------------------------------------------------------------------------
inline HCERTSTORE
CSSCtlObject::MessageStore ()
{
    return( m_hMessageStore );
}

//+---------------------------------------------------------------------------
//
//  Member:     CSSCtlObjectCache::HashIndex, public
//
//  Synopsis:   return the hash index
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CSSCtlObjectCache::HashIndex ()
{
    return( m_hHashIndex );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\chain\xcert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       xcert.cpp
//
//  Contents:   CCertChainEngine's Cross Certificate Methods
//
//  History:    22-Dec-99    philh    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>




//+=========================================================================
// Cross Certificate Distribution Point Support Functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Get and allocate the cross certificate distribution points Url array
//  and info for the specified certificate.
//--------------------------------------------------------------------------
BOOL
WINAPI
XCertGetDistPointsUrl(
    IN PCCERT_CONTEXT pCert,
    OUT PCRYPT_URL_ARRAY *ppUrlArray,
    OUT PCRYPT_URL_INFO *ppUrlInfo
    )
{
    BOOL fResult;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD cbUrlArray = 0;
    PCRYPT_URL_INFO pUrlInfo = NULL;
    DWORD cbUrlInfo = 0;

    if (!ChainGetObjectUrl(
            URL_OID_CROSS_CERT_DIST_POINT,
            (LPVOID) pCert,
            CRYPT_GET_URL_FROM_PROPERTY | CRYPT_GET_URL_FROM_EXTENSION,
            NULL,           // pUrlArray
            &cbUrlArray,
            NULL,           // pUrlInfo
            &cbUrlInfo,
            NULL            // pvReserved
            ))
        goto GetObjectUrlError;

    pUrlArray = (PCRYPT_URL_ARRAY) new BYTE [cbUrlArray];
    if (NULL == pUrlArray)
        goto OutOfMemory;

    pUrlInfo = (PCRYPT_URL_INFO) new BYTE [cbUrlInfo];
    if (NULL == pUrlInfo)
        goto OutOfMemory;

    if (!ChainGetObjectUrl(
            URL_OID_CROSS_CERT_DIST_POINT,
            (LPVOID) pCert,
            CRYPT_GET_URL_FROM_PROPERTY | CRYPT_GET_URL_FROM_EXTENSION,
            pUrlArray,
            &cbUrlArray,
            pUrlInfo,
            &cbUrlInfo,
            NULL            // pvReserved
            ))
        goto GetObjectUrlError;

    if (0 == pUrlArray->cUrl || 0 == pUrlInfo->cGroup)
        goto NoDistPointUrls;

    fResult = TRUE;
CommonReturn:
    *ppUrlArray = pUrlArray;
    *ppUrlInfo = pUrlInfo;
    return fResult;

ErrorReturn:
    if (pUrlArray) {
        delete (LPBYTE) pUrlArray;
        pUrlArray = NULL;
    }
    if (pUrlInfo) {
        delete (LPBYTE) pUrlInfo;
        pUrlInfo = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetObjectUrlError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
SET_ERROR(NoDistPointUrls, CRYPT_E_NOT_FOUND)
}



//+-------------------------------------------------------------------------
//  Checks and returns TRUE if all the Urls are contained in the
//  distribution point.
//--------------------------------------------------------------------------
BOOL
WINAPI
XCertIsUrlInDistPoint(
    IN DWORD cUrl,
    IN LPWSTR *ppwszUrl,
    IN PXCERT_DP_ENTRY pEntry
    )
{
    for ( ; 0 < cUrl; cUrl--, ppwszUrl++) {
        DWORD cDPUrl = pEntry->cUrl;
        LPWSTR *ppwszDPUrl = pEntry->rgpwszUrl;

        for ( ; 0 < cDPUrl; cDPUrl--, ppwszDPUrl++) {
            if (0 == wcscmp(*ppwszUrl, *ppwszDPUrl))
                break;
        }

        if (0 == cDPUrl)
            return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Finds a distribution point link containing all the Urls.
//--------------------------------------------------------------------------
PXCERT_DP_LINK
WINAPI
XCertFindUrlInDistPointLinks(
    IN DWORD cUrl,
    IN LPWSTR *rgpwszUrl,
    IN PXCERT_DP_LINK pLink
    )
{
    for ( ; pLink; pLink = pLink->pNext) {
        if (XCertIsUrlInDistPoint(cUrl, rgpwszUrl, pLink->pCrossCertDPEntry))
            return pLink;
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Finds a distribution point entry containing all the Urls.
//--------------------------------------------------------------------------
PXCERT_DP_ENTRY
WINAPI
XCertFindUrlInDistPointEntries(
    IN DWORD cUrl,
    IN LPWSTR *rgpwszUrl,
    PXCERT_DP_ENTRY pEntry
    )
{
    for ( ; pEntry; pEntry = pEntry->pNext) {
        if (XCertIsUrlInDistPoint(cUrl, rgpwszUrl, pEntry))
            return pEntry;
    }

    return NULL;
}


//+-------------------------------------------------------------------------
//  Inserts the cross certificate distribution entry into the engine's
//  list. The list is ordered according to ascending NextSyncTimes.
//--------------------------------------------------------------------------
void
CCertChainEngine::InsertCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry
    )
{
    if (NULL == m_pCrossCertDPEntry) {
        // First entry to be added to engine's list
        pEntry->pNext = NULL;
        pEntry->pPrev = NULL;
        m_pCrossCertDPEntry = pEntry;
    } else {
        PXCERT_DP_ENTRY pListEntry = m_pCrossCertDPEntry;
        BOOL fLast = FALSE;

        // Loop while Entry's NextSyncTime > list's NextSyncTime
        while (0 < CompareFileTime(&pEntry->NextSyncTime,
                &pListEntry->NextSyncTime)) {
            if (NULL == pListEntry->pNext) {
                fLast = TRUE;
                break;
            } else
                pListEntry = pListEntry->pNext;
        }

        if (fLast) {
            assert(NULL == pListEntry->pNext);
            pEntry->pNext = NULL;
            pEntry->pPrev = pListEntry;
            pListEntry->pNext = pEntry;
        } else {
            pEntry->pNext = pListEntry;
            pEntry->pPrev = pListEntry->pPrev;
            if (pListEntry->pPrev) {
                assert(pListEntry->pPrev->pNext == pListEntry);
                pListEntry->pPrev->pNext = pEntry;
            } else {
                assert(m_pCrossCertDPEntry == pListEntry);
                m_pCrossCertDPEntry = pEntry;
            }
            pListEntry->pPrev = pEntry;
        }
    }
}

//+-------------------------------------------------------------------------
//  Removes the cross certificate distribution point from the engine's list.
//--------------------------------------------------------------------------
void
CCertChainEngine::RemoveCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry
    )
{
    if (pEntry->pNext)
        pEntry->pNext->pPrev = pEntry->pPrev;
    if (pEntry->pPrev)
        pEntry->pPrev->pNext = pEntry->pNext;
    else
        m_pCrossCertDPEntry = pEntry->pNext;
}

//+-------------------------------------------------------------------------
//  For an online certificate distribution point updates the NextSyncTime
//  and repositions accordingly in the engine's list.
//
//  NextSyncTime = LastSyncTime + dwSyncDeltaTime.
//--------------------------------------------------------------------------
void
CCertChainEngine::RepositionOnlineCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry,
    IN LPFILETIME pLastSyncTime
    )
{
    assert(!I_CryptIsZeroFileTime(pLastSyncTime));
    pEntry->LastSyncTime = *pLastSyncTime;
    pEntry->dwOfflineCnt = 0;

    I_CryptIncrementFileTimeBySeconds(
        pLastSyncTime,
        pEntry->dwSyncDeltaTime,
        &pEntry->NextSyncTime
        );

    RemoveCrossCertDistPointEntry(pEntry);
    InsertCrossCertDistPointEntry(pEntry);
}

//+-------------------------------------------------------------------------
//  For an offline certificate distribution point, increments the offline
//  count, updates the NextSyncTime to be some delta from the current time
//  and repositions accordingly in the engine's list.
//
//  NextSyncTime = CurrentTime +
//                      rgChainOfflineUrlDeltaSeconds[dwOfflineCnt - 1]
//--------------------------------------------------------------------------
void
CCertChainEngine::RepositionOfflineCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry,
    IN LPFILETIME pCurrentTime
    )
{
    pEntry->dwOfflineCnt++;

    I_CryptIncrementFileTimeBySeconds(
        pCurrentTime,
        ChainGetOfflineUrlDeltaSeconds(pEntry->dwOfflineCnt),
        &pEntry->NextSyncTime
        );

    RemoveCrossCertDistPointEntry(pEntry);
    InsertCrossCertDistPointEntry(pEntry);
}

//+-------------------------------------------------------------------------
//  For a smaller SyncDeltaTime in a certificate distribution point,
//  updates the NextSyncTime and repositions accordingly in the engine's list.
//
//  Note, if the distribution point is offline, the NextSyncTime isn't
//  updated.
//
//  NextSyncTime = LastSyncTime + dwSyncDeltaTime.
//--------------------------------------------------------------------------
void
CCertChainEngine::RepositionNewSyncDeltaTimeCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry,
    IN DWORD dwSyncDeltaTime
    )
{
    if (dwSyncDeltaTime >= pEntry->dwSyncDeltaTime)
        return;

    pEntry->dwSyncDeltaTime = dwSyncDeltaTime;

    if (I_CryptIsZeroFileTime(&pEntry->LastSyncTime) ||
            0 != pEntry->dwOfflineCnt)
        return;

    RepositionOnlineCrossCertDistPointEntry(pEntry, &pEntry->LastSyncTime);
}

//+-------------------------------------------------------------------------
//  Creates the cross certificate distribution point and insert's in the
//  engine's list.
//
//  The returned entry has a refCnt of 1.
//--------------------------------------------------------------------------
PXCERT_DP_ENTRY
CCertChainEngine::CreateCrossCertDistPointEntry(
    IN DWORD dwSyncDeltaTime,
    IN DWORD cUrl,
    IN LPWSTR *rgpwszUrl
    )
{
    PXCERT_DP_ENTRY pEntry;
    DWORD cbEntry;
    LPWSTR *ppwszEntryUrl;
    LPWSTR pwszEntryUrl;
    DWORD i;

    cbEntry = sizeof(XCERT_DP_ENTRY) + cUrl * sizeof(LPWSTR);
    for (i = 0; i < cUrl; i++)
        cbEntry += (wcslen(rgpwszUrl[i]) + 1) * sizeof(WCHAR);

    pEntry = (PXCERT_DP_ENTRY) new BYTE [cbEntry];
    if (NULL == pEntry) {
        SetLastError((DWORD) E_OUTOFMEMORY);
        return NULL;
    }

    memset(pEntry, 0, sizeof(XCERT_DP_ENTRY));
    pEntry->lRefCnt = 1;
    pEntry->dwSyncDeltaTime = dwSyncDeltaTime;

    pEntry->cUrl = cUrl;
    pEntry->rgpwszUrl = ppwszEntryUrl = (LPWSTR *) &pEntry[1];
    pwszEntryUrl = (LPWSTR) &ppwszEntryUrl[cUrl];

    for (i = 0; i < cUrl; i++) {
        ppwszEntryUrl[i] = pwszEntryUrl;
        wcscpy(pwszEntryUrl, rgpwszUrl[i]);
        pwszEntryUrl += wcslen(rgpwszUrl[i]) + 1;
    }

    InsertCrossCertDistPointEntry(pEntry);

    return pEntry;
}

//+-------------------------------------------------------------------------
//  Increments the cross certificate distribution point's reference count.
//--------------------------------------------------------------------------
void
CCertChainEngine::AddRefCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry
    )
{
    pEntry->lRefCnt++;
}

//+-------------------------------------------------------------------------
//  Decrements the cross certificate distribution point's reference count.
//
//  When decremented to 0, removed from the engine's list and freed.
//
//  Returns TRUE if decremented to 0 and freed.
//--------------------------------------------------------------------------
BOOL
CCertChainEngine::ReleaseCrossCertDistPointEntry(
    IN OUT PXCERT_DP_ENTRY pEntry
    )
{
    if (0 != --pEntry->lRefCnt)
        return FALSE;

    RemoveCrossCertDistPointEntry(pEntry);
    FreeCrossCertDistPoints(&pEntry->pChildCrossCertDPLink);

    if (pEntry->hUrlStore) {
        CertRemoveStoreFromCollection(
            m_hCrossCertStore,
            pEntry->hUrlStore
            );
        CertCloseStore(pEntry->hUrlStore, 0);
    }

    delete (LPBYTE) pEntry;

    return TRUE;
}

//+-------------------------------------------------------------------------
//  Finds and gets the Cross Certificate Distribution Points for the
//  specified certificate store.
//
//  *ppLinkHead is updated to contain the store's distribution point links.
//--------------------------------------------------------------------------
BOOL
CCertChainEngine::GetCrossCertDistPointsForStore(
    IN HCERTSTORE hStore,
    IN BOOL fOnlyLMSystemStore,
    IN OUT PXCERT_DP_LINK *ppLinkHead
    )
{
    BOOL fResult;
    PXCERT_DP_LINK pOldLinkHead = *ppLinkHead;
    PXCERT_DP_LINK pNewLinkHead = NULL;
    PCCERT_CONTEXT pCert = NULL;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    PCRYPT_URL_INFO pUrlInfo = NULL;

    while (pCert = CertFindCertificateInStore(
            hStore,
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            0,                                          // dwFindFlags
            CERT_FIND_CROSS_CERT_DIST_POINTS,
            NULL,                                       // pvFindPara,
            pCert
            )) {

        DWORD dwSyncDeltaTime;
        DWORD cDP;
        DWORD *pcUrl;
        LPWSTR *ppwszUrl;

        if (fOnlyLMSystemStore) {
            DWORD dwAccessStateFlags = 0;
            DWORD cbData = sizeof(dwAccessStateFlags);

            if (!CertGetCertificateContextProperty(
                        pCert,
                        CERT_ACCESS_STATE_PROP_ID,
                        &dwAccessStateFlags,
                        &cbData
                        ) ||
                    (0 == (dwAccessStateFlags &
                                CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG)))
                continue;
        }

        if (!XCertGetDistPointsUrl(
                pCert,
                &pUrlArray,
                &pUrlInfo
                ))
            continue;

        dwSyncDeltaTime = pUrlInfo->dwSyncDeltaTime;
        if (0 == dwSyncDeltaTime)
            dwSyncDeltaTime = XCERT_DEFAULT_SYNC_DELTA_TIME;
        else if (XCERT_MIN_SYNC_DELTA_TIME > dwSyncDeltaTime)
            dwSyncDeltaTime = XCERT_MIN_SYNC_DELTA_TIME;

        cDP = pUrlInfo->cGroup;
        pcUrl = pUrlInfo->rgcGroupEntry;
        ppwszUrl = pUrlArray->rgwszUrl;

        for ( ; 0 < cDP; cDP--, ppwszUrl += *pcUrl++) {
            PXCERT_DP_LINK pLink;
            PXCERT_DP_ENTRY pEntry;
            DWORD cUrl = *pcUrl;

            if (0 == cUrl)
                continue;

            // Do we already have an entry in the new list
            if (XCertFindUrlInDistPointLinks(cUrl, ppwszUrl, pNewLinkHead))
                continue;

            // If the entry existed in the old list, move to the new list
            if (pLink = XCertFindUrlInDistPointLinks(
                    cUrl, ppwszUrl, pOldLinkHead)) {
                if (pLink->pNext)
                    pLink->pNext->pPrev = pLink->pPrev;
                if (pLink->pPrev)
                    pLink->pPrev->pNext = pLink->pNext;
                else
                    pOldLinkHead = pLink->pNext;

                RepositionNewSyncDeltaTimeCrossCertDistPointEntry(
                    pLink->pCrossCertDPEntry, dwSyncDeltaTime);
            } else {
                // Check if the entry already exists for the engine
                if (pEntry = XCertFindUrlInDistPointEntries(
                        cUrl, ppwszUrl, m_pCrossCertDPEntry)) {
                    AddRefCrossCertDistPointEntry(pEntry);
                    RepositionNewSyncDeltaTimeCrossCertDistPointEntry(
                        pEntry, dwSyncDeltaTime);
                } else {
                    // Create entry and insert at beginning of
                    // entries list.
                    if (NULL == (pEntry = CreateCrossCertDistPointEntry(
                            dwSyncDeltaTime,
                            cUrl,
                            ppwszUrl
                            )))
                        goto CreateDistPointEntryError;
                }

                pLink = new XCERT_DP_LINK;
                if (NULL == pLink) {
                    ReleaseCrossCertDistPointEntry(pEntry);
                    goto CreateDistPointLinkError;
                }

                pLink->pCrossCertDPEntry = pEntry;

            }

            if (pNewLinkHead) {
                assert(NULL == pNewLinkHead->pPrev);
                pNewLinkHead->pPrev = pLink;
            }
            pLink->pNext = pNewLinkHead;
            pLink->pPrev = NULL;
            pNewLinkHead = pLink;
        }

        delete (LPBYTE) pUrlArray;
        pUrlArray = NULL;
        delete (LPBYTE) pUrlInfo;
        pUrlInfo = NULL;
    }

    assert(NULL == pUrlArray);
    assert(NULL == pUrlInfo);
    assert(NULL == pCert);

    *ppLinkHead = pNewLinkHead;
    fResult = TRUE;
CommonReturn:
    if (pOldLinkHead) {
        DWORD dwErr = GetLastError();

        FreeCrossCertDistPoints(&pOldLinkHead);

        SetLastError(dwErr);
    }

    return fResult;

ErrorReturn:
    *ppLinkHead = NULL;
    if (pUrlArray)
        delete (LPBYTE) pUrlArray;
    if (pUrlInfo)
        delete (LPBYTE) pUrlInfo;
    if (pCert)
        CertFreeCertificateContext(pCert);

    if (pNewLinkHead) {
        FreeCrossCertDistPoints(&pNewLinkHead);
        assert(NULL == pNewLinkHead);
    }
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateDistPointEntryError)
TRACE_ERROR(CreateDistPointLinkError)
}


//+-------------------------------------------------------------------------
//  Removes an orphan'ed entry not in any list of links.
//--------------------------------------------------------------------------
void
CCertChainEngine::RemoveCrossCertDistPointOrphanEntry(
    IN PXCERT_DP_ENTRY pOrphanEntry
    )
{
    PXCERT_DP_ENTRY pEntry;

    for (pEntry = m_pCrossCertDPEntry; pEntry; pEntry = pEntry->pNext) {
        PXCERT_DP_LINK pLink = pEntry->pChildCrossCertDPLink;

        while (pLink) {
            if (pLink->pCrossCertDPEntry == pOrphanEntry) {
                if (pLink->pNext)
                    pLink->pNext->pPrev = pLink->pPrev;
                if (pLink->pPrev)
                    pLink->pPrev->pNext = pLink->pNext;
                else
                    pEntry->pChildCrossCertDPLink = pLink->pNext;

                delete pLink;

                if (ReleaseCrossCertDistPointEntry(pOrphanEntry))
                    return;
                else
                    break;
            }

            pLink = pLink->pNext;
        }
            
    }
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the entry is in this or any child link list
//--------------------------------------------------------------------------
BOOL
WINAPI
XCertIsDistPointInLinkList(
    IN PXCERT_DP_ENTRY pOrphanEntry,
    IN PXCERT_DP_LINK pLink
    )
{
    for (; pLink; pLink = pLink->pNext) {
        PXCERT_DP_ENTRY pEntry = pLink->pCrossCertDPEntry;
        if (pOrphanEntry == pEntry)
            return TRUE;

        // Note, inhibit recursion by checking an entry's list of links
        // only once.
        if (!pEntry->fChecked) {
            pEntry->fChecked = TRUE;

            if (XCertIsDistPointInLinkList(pOrphanEntry,
                    pEntry->pChildCrossCertDPLink))
                return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//  Frees the cross certificate distribution point links.
//--------------------------------------------------------------------------
void
CCertChainEngine::FreeCrossCertDistPoints(
    IN OUT PXCERT_DP_LINK *ppLinkHead
    )
{
    PXCERT_DP_LINK pLink = *ppLinkHead;
    *ppLinkHead = NULL;

    while (pLink) {
        PXCERT_DP_LINK pDelete;
        PXCERT_DP_ENTRY pEntry;

        pEntry = pLink->pCrossCertDPEntry;
        if (ReleaseCrossCertDistPointEntry(pEntry))
            ;
        else {
            // Clear the fChecked flag for all entries
            PXCERT_DP_ENTRY pCheckEntry;
            for (pCheckEntry = m_pCrossCertDPEntry; pCheckEntry;
                                            pCheckEntry = pCheckEntry->pNext)
                pCheckEntry->fChecked = FALSE;

            if (!XCertIsDistPointInLinkList(pEntry, m_pCrossCertDPLink))
                // An orphaned entry. Not in anyone else's list
                RemoveCrossCertDistPointOrphanEntry(pEntry);
        }
        
        pDelete = pLink;
        pLink = pLink->pNext;
        delete pDelete;
    }
}
            


//+-------------------------------------------------------------------------
//  Retrieve the cross certificates
//
//  Leaves the engine's critical section to do the URL
//  fetching. If the engine was touched by another thread,
//  it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  If the URL store is changed, increments engine's touch count and flushes
//  issuer and end cert object caches.
//
//  Assumption: Chain engine is locked once in the calling thread.
//--------------------------------------------------------------------------
BOOL
CCertChainEngine::RetrieveCrossCertUrl(
    IN PCCHAINCALLCONTEXT pCallContext,
    IN OUT PXCERT_DP_ENTRY pEntry,
    IN DWORD dwRetrievalFlags,
    IN OUT BOOL *pfTimeValid
    )
{
    BOOL fResult;
    FILETIME CurrentTime;
    HCERTSTORE hNewUrlStore = NULL;
    FILETIME NewLastSyncTime;
    CRYPT_RETRIEVE_AUX_INFO RetrieveAuxInfo;
    DWORD i;

    memset(&RetrieveAuxInfo, 0, sizeof(RetrieveAuxInfo));
    RetrieveAuxInfo.cbSize = sizeof(RetrieveAuxInfo);
    RetrieveAuxInfo.pLastSyncTime = &NewLastSyncTime;

    pCallContext->CurrentTime(&CurrentTime);

    // Loop through Urls and try to retrieve a time valid cross cert URL
    for (i = 0; i < pEntry->cUrl; i++) {
        NewLastSyncTime = CurrentTime;
        LPWSTR pwszUrl = NULL;
        DWORD cbUrl;

        // Do URL fetching outside of the engine's critical section

        // Need to make a copy of the Url string. pEntry
        // can be modified by another thread outside of the critical section.
        cbUrl = (wcslen(pEntry->rgpwszUrl[i]) + 1) * sizeof(WCHAR);
        pwszUrl = (LPWSTR) PkiNonzeroAlloc(cbUrl);
        if (NULL == pwszUrl)
            goto OutOfMemory;
        memcpy(pwszUrl, pEntry->rgpwszUrl[i], cbUrl);

        pCallContext->ChainEngine()->UnlockEngine();
        fResult = ChainRetrieveObjectByUrlW(
                pwszUrl,
                CONTEXT_OID_CAPI2_ANY,
                dwRetrievalFlags |
                    CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
                    CRYPT_STICKY_CACHE_RETRIEVAL,
                pCallContext->ChainPara()->dwUrlRetrievalTimeout,
                (LPVOID *) &hNewUrlStore,
                NULL,                               // hAsyncRetrieve
                NULL,                               // pCredentials
                NULL,                               // pvVerify
                &RetrieveAuxInfo
                );
        pCallContext->ChainEngine()->LockEngine();

        PkiFree(pwszUrl);

        if (pCallContext->IsTouchedEngine())
            goto TouchedDuringUrlRetrieval;

        if (fResult) {
            assert(hNewUrlStore);

            if (0 > CompareFileTime(&pEntry->LastSyncTime, &NewLastSyncTime)) {
                BOOL fStoreChanged = FALSE;

                // Move us to the head of the Url list
                DWORD j;
                LPWSTR pwszUrl = pEntry->rgpwszUrl[i];

                for (j = i; 0 < j; j--)
                    pEntry->rgpwszUrl[j] = pEntry->rgpwszUrl[j - 1];
                pEntry->rgpwszUrl[0] = pwszUrl;

                if (NULL == pEntry->hUrlStore) {
                    if (!CertAddStoreToCollection(
                            m_hCrossCertStore,
                            hNewUrlStore,
                            0,
                            0
                            ))
                        goto AddStoreToCollectionError;
                    pEntry->hUrlStore = hNewUrlStore;
                    hNewUrlStore = NULL;
                    fStoreChanged = TRUE;
                } else {
                    DWORD dwOutFlags = 0;
                    if (!I_CertSyncStoreEx(
                            pEntry->hUrlStore,
                            hNewUrlStore,
                            ICERT_SYNC_STORE_INHIBIT_SYNC_PROPERTY_IN_FLAG,
                            &dwOutFlags,
                            NULL                    // pvReserved
                            ))
                        goto SyncStoreError;
                    if (dwOutFlags & ICERT_SYNC_STORE_CHANGED_OUT_FLAG)
                        fStoreChanged = TRUE;
                }

                if (fStoreChanged) {
                    m_pCertObjectCache->FlushObjects( pCallContext );
                    pCallContext->TouchEngine();

                    if (!GetCrossCertDistPointsForStore(
                            pEntry->hUrlStore,
                            FALSE,                  // fOnlyLMSystemStore
                            &pEntry->pChildCrossCertDPLink
                            ))
                        goto UpdateDistPointError;
                }

                RepositionOnlineCrossCertDistPointEntry(pEntry,
                    &NewLastSyncTime);

                if (0 < CompareFileTime(&pEntry->NextSyncTime, &CurrentTime)) {
                    *pfTimeValid = TRUE;
                    break;
                }
            }

            if (hNewUrlStore) {
                CertCloseStore(hNewUrlStore, 0);
                hNewUrlStore = NULL;
            }
        }
    }

    fResult = TRUE;
CommonReturn:
    if (hNewUrlStore)
        CertCloseStore(hNewUrlStore, 0);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(AddStoreToCollectionError)
TRACE_ERROR(SyncStoreError)
TRACE_ERROR(UpdateDistPointError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(TouchedDuringUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
}

//+-------------------------------------------------------------------------
//  Update cross certificate distribution points whose NextSyncTime has
//  expired.
//
//  Leaves the engine's critical section to do the URL
//  fetching. If the engine was touched by another thread,
//  it fails with LastError set to ERROR_CAN_NOT_COMPLETE.
//
//  If the URL store is changed, increments engine's touch count and flushes
//  issuer and end cert object caches.
//
//  Assumption: Chain engine is locked once in the calling thread.
//--------------------------------------------------------------------------
BOOL
CCertChainEngine::UpdateCrossCerts(
    IN PCCHAINCALLCONTEXT pCallContext
    )
{
    BOOL fResult;
    PXCERT_DP_ENTRY pEntry;
    FILETIME CurrentTime;

    pEntry = m_pCrossCertDPEntry;
    if (NULL == pEntry)
        goto SuccessReturn;
    
    m_dwCrossCertDPResyncIndex++;

    pCallContext->CurrentTime(&CurrentTime);
    while (pEntry &&
            0 >= CompareFileTime(&pEntry->NextSyncTime, &CurrentTime)) {
        PXCERT_DP_ENTRY pNextEntry = pEntry->pNext;

        if (pEntry->dwResyncIndex < m_dwCrossCertDPResyncIndex) {
            BOOL fTimeValid = FALSE;

            if (0 == pEntry->dwResyncIndex || pCallContext->IsOnline()) {
                RetrieveCrossCertUrl(
                    pCallContext,
                    pEntry,
                    CRYPT_CACHE_ONLY_RETRIEVAL,
                    &fTimeValid
                    );
                if (pCallContext->IsTouchedEngine())
                    goto TouchedDuringUrlRetrieval;

                if (!fTimeValid && pCallContext->IsOnline()) {
                    RetrieveCrossCertUrl(
                        pCallContext,
                        pEntry,
                        CRYPT_WIRE_ONLY_RETRIEVAL,
                        &fTimeValid
                        );
                    if (pCallContext->IsTouchedEngine())
                        goto TouchedDuringUrlRetrieval;

                    if (!fTimeValid)
                        RepositionOfflineCrossCertDistPointEntry(pEntry,
                            &CurrentTime);
                }

                // Start over at the beginning. May have added some entries.
                pNextEntry = m_pCrossCertDPEntry;
            }

            pEntry->dwResyncIndex = m_dwCrossCertDPResyncIndex;

        }
        // else
        //  Skip entries we have already processed.

        pEntry = pNextEntry;
    }

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(TouchedDuringUrlRetrieval, ERROR_CAN_NOT_COMPLETE)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\crypt32\makefile.inc ===
#
# Build private crypt32p.lib.  It contains all the private and public api's
#


$(O)\crypt32p.def: .\crypt32.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DALL_WIN32_EXPORTS /DPRIVATE_VERSION $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\crypt32p.lib: $(O)\crypt32p.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\crypt32p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(PROJECT_LIB_PATH)\crypt32p.lib : $(O)\crypt32p.lib
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\cryptnet\cryptnet.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cryptnet.cpp
//
//  Contents:   DllMain for CRYPTNET.DLL
//
//  History:    24-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include "windows.h"
#include "crtem.h"
#include "unicode.h"

//
// DllMain stuff
//

extern BOOL WINAPI RPORDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI DpsDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI DemandLoadDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);

typedef BOOL (WINAPI *PFN_DLL_MAIN_FUNC) (
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                );

HMODULE g_hModule;

// The following is set for a successful DLL_PROCESS_DETACH.
static BOOL g_fEnableProcessDetach = FALSE;

// For process/thread attach, called in the following order. For process/thread
// detach, called in reverse order.
static const PFN_DLL_MAIN_FUNC rgpfnDllMain[] = {
    DemandLoadDllMain,
    RPORDllMain
};
#define DLL_MAIN_FUNC_COUNT (sizeof(rgpfnDllMain) / sizeof(rgpfnDllMain[0]))

//
// DllRegisterServer and DllUnregisterServer stuff
//

extern HRESULT WINAPI DpsDllRegUnregServer (HMODULE hInstDLL, BOOL fRegUnreg);
extern HRESULT WINAPI RPORDllRegUnregServer (HMODULE hInstDLL, BOOL fRegUnreg);

typedef HRESULT (WINAPI *PFN_DLL_REGUNREGSERVER_FUNC) (
                              HMODULE hInstDLL,
                              BOOL fRegUnreg
                              );

static const PFN_DLL_REGUNREGSERVER_FUNC rgpfnDllRegUnregServer[] = {
    RPORDllRegUnregServer
};

#define DLL_REGUNREGSERVER_FUNC_COUNT (sizeof(rgpfnDllRegUnregServer) / \
                                       sizeof(rgpfnDllRegUnregServer[0]))

#define ENV_LEN 32

#if DBG
#include <crtdbg.h>

#ifndef _CRTDBG_LEAK_CHECK_DF
#define _CRTDBG_LEAK_CHECK_DF 0x20
#endif

#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */

static int WINAPI DbgGetDebugFlags()
{
    int     iDebugFlags = 0;
    char rgch[ENV_LEN + 1];
    DWORD cch;

    cch = GetEnvironmentVariableA(
        "DEBUG_MASK",
        rgch,
        ENV_LEN
        );
    if (cch && cch <= ENV_LEN) {
        rgch[cch] = '\0';
        iDebugFlags = atoi(rgch);
    }

    return iDebugFlags;
}
#endif


//+-------------------------------------------------------------------------
//  Return TRUE if DLL_PROCESS_DETACH is called for FreeLibrary instead
//  of ProcessExit. The third parameter, lpvReserved, passed to DllMain
//  is NULL for FreeLibrary and non-NULL for ProcessExit.
//
//  Also for debugging purposes, check the following environment variables:
//      CRYPT_DEBUG_FORCE_FREE_LIBRARY != 0     (retail and checked)
//      DEBUG_MASK & 0x20                       (only checked)
//
//  If either of the above environment variables is present and satisfies
//  the expression, TRUE is returned.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptnetIsProcessDetachFreeLibrary(
    LPVOID lpvReserved      // Third parameter passed to DllMain
    )
{
    char rgch[ENV_LEN + 1];
    DWORD cch;

    if (NULL == lpvReserved)
        return TRUE;

    cch = GetEnvironmentVariableA(
        "CRYPT_DEBUG_FORCE_FREE_LIBRARY",
        rgch,
        ENV_LEN
        );
    if (cch && cch <= ENV_LEN) {
        long lValue;

        rgch[cch] = '\0';
        lValue = atol(rgch);
        if (lValue)
            return TRUE;
    }

#if DBG
    if (DbgGetDebugFlags() & DEBUG_MASK_LEAK_CHECK)
        return TRUE;
#endif
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
    BOOL    fReturn = TRUE;
    int     i;

    switch (fdwReason) {
        case DLL_PROCESS_DETACH:
            if (!g_fEnableProcessDetach)
                return TRUE;
            else
                g_fEnableProcessDetach = FALSE;

            //
            // This is to prevent unloading the dlls at process exit
            //
            if (!I_CryptnetIsProcessDetachFreeLibrary(lpvReserved))
            {
                return TRUE;
            }

        case DLL_THREAD_DETACH:
            for (i = DLL_MAIN_FUNC_COUNT - 1; i >= 0; i--)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;

        case DLL_PROCESS_ATTACH:
            g_hModule = hInstDLL;
        case DLL_THREAD_ATTACH:
        default:
            for (i = 0; i < DLL_MAIN_FUNC_COUNT; i++)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);

            if ((DLL_PROCESS_ATTACH == fdwReason) && fReturn)
                g_fEnableProcessDetach = TRUE;
            break;
    }

    return(fReturn);
}

STDAPI DllRegisterServer ()
{
    HRESULT hr = 0;
    ULONG   cCount;

    for ( cCount = 0; cCount < DLL_REGUNREGSERVER_FUNC_COUNT; cCount++ )
    {
        hr = rgpfnDllRegUnregServer[cCount]( g_hModule, TRUE );
        if ( hr != S_OK )
        {
            break;
        }
    }

    return( hr );
}

STDAPI DllUnregisterServer ()
{
    HRESULT hr = 0;
    ULONG   cCount;

    for ( cCount = 0; cCount < DLL_REGUNREGSERVER_FUNC_COUNT; cCount++ )
    {
        hr = rgpfnDllRegUnregServer[cCount]( g_hModule, FALSE );
        if ( hr != S_OK )
        {
            break;
        }
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\cryptnet\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cryptnet.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\cryptnet\makefile.inc ===
#
# Build private cryptnet.lib.  It contains all the private and public api's
#

cryptnet_all: $O\cryptntp.lib

$O\cryptntp.def: .\cryptnet.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DALL_WIN32_EXPORTS /DPRIVATE_VERSION $(C_PREPROCESSOR_FLAGS) $** > $@

$O\cryptntp.lib: $O\cryptntp.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$O\cryptntp.def
$(LIBRARY_OBJS)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\crypt32\crypt32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       cryp32.cpp
//
//  Contents:   Crypto API, version 2.
//
//  Functions:  DllMain
//
//  History:    13-Aug-96    kevinr   created
//
//--------------------------------------------------------------------------

#include "windows.h"
#include "unicode.h"

// assignment within conditional expression
#pragma warning (disable: 4706)

#if DBG
extern BOOL WINAPI DebugDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif
extern BOOL WINAPI I_CryptTlsDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI I_CryptOIDFuncDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI I_CryptOIDInfoDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI I_CertRevFuncDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI I_CertCTLUsageFuncDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CertStoreDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CertASNDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CertHelperDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CryptMsgDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI UnicodeDllMain(HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CryptFrmtFuncDllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved);
extern BOOL WINAPI CryptSIPDllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved);
extern BOOL WINAPI CryptPFXDllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved);
extern BOOL WINAPI CertChainPolicyDllMain(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved);

extern BOOL WINAPI ChainDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);
extern BOOL WINAPI CertPerfDllMain (HMODULE hInstDLL, DWORD fdwReason, LPVOID lpvReserved);

typedef BOOL (WINAPI *PFN_DLL_MAIN_FUNC) (
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                );


// For process/thread attach, called in the following order. For process/thread
// detach, called in reverse order.
static const PFN_DLL_MAIN_FUNC rgpfnDllMain[] = {
#if DBG
    DebugDllMain,
#endif
    // For process/thread attach the following two functions must be called
    // first. For process/thread detach the following two functions must
    // be called last.
    I_CryptTlsDllMain,
    I_CryptOIDFuncDllMain,
    CertPerfDllMain,
    CryptSIPDllMain,
    I_CryptOIDInfoDllMain,
    CertHelperDllMain,
    UnicodeDllMain,
    I_CertRevFuncDllMain,
    I_CertCTLUsageFuncDllMain,
	CryptFrmtFuncDllMain,
    CertStoreDllMain,
    CryptPFXDllMain,
    CertASNDllMain,
    ChainDllMain,
    CertChainPolicyDllMain,
    CryptMsgDllMain
};
#define DLL_MAIN_FUNC_COUNT (sizeof(rgpfnDllMain) / sizeof(rgpfnDllMain[0]))

#if DBG
#include <crtdbg.h>

#ifndef _CRTDBG_LEAK_CHECK_DF
#define _CRTDBG_LEAK_CHECK_DF 0x20
#endif

#define DEBUG_MASK_LEAK_CHECK       _CRTDBG_LEAK_CHECK_DF     /* 0x20 */

static int WINAPI DbgGetDebugFlags()
{
    char    *pszEnvVar;
    char    *p;
    int     iDebugFlags = 0;

    if (pszEnvVar = getenv("DEBUG_MASK"))
        iDebugFlags = strtol(pszEnvVar, &p, 16);

    return iDebugFlags;
}
#endif

//
// I_CryptUIProtect loads cryptui.dll.  we need to free it on DLL_PROCESS_DETACH
// if it was loaded.
//

static HINSTANCE g_hCryptUI;


// The following is set for a successful DLL_PROCESS_DETACH.
static BOOL g_fEnableProcessDetach = FALSE;


//+-------------------------------------------------------------------------
//  Return TRUE if DLL_PROCESS_DETACH is called for FreeLibrary instead
//  of ProcessExit. The third parameter, lpvReserved, passed to DllMain
//  is NULL for FreeLibrary and non-NULL for ProcessExit.
//
//  Also for debugging purposes, check the following environment variables:
//      CRYPT_DEBUG_FORCE_FREE_LIBRARY != 0     (retail and checked)
//      DEBUG_MASK & 0x20                       (only checked)
//
//  If either of the above environment variables is present and satisfies
//  the expression, TRUE is returned.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptIsProcessDetachFreeLibrary(
    LPVOID lpvReserved      // Third parameter passed to DllMain
    )
{
#define ENV_LEN 32
    char rgch[ENV_LEN + 1];
    DWORD cch;

    if (NULL == lpvReserved)
        return TRUE;

    cch = GetEnvironmentVariableA(
        "CRYPT_DEBUG_FORCE_FREE_LIBRARY",
        rgch,
        ENV_LEN
        );
    if (cch && cch <= ENV_LEN) {
        long lValue;

        rgch[cch] = '\0';
        lValue = atol(rgch);
        if (lValue)
            return TRUE;
    }

#if DBG
    if (DbgGetDebugFlags() & DEBUG_MASK_LEAK_CHECK)
        return TRUE;
#endif
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved
                )
{
    BOOL    fReturn = TRUE;
    int     i;

#if DBG
    // NB- Due to an apparent bug in the Win95 loader, the CRT gets unloaded
    // too early in some circumstances. In particular, it can get unloaded
    // before this routine executes at process detach time. This can cause
    // faults when executing this routine, and also when executing the rest
    // of CRYPT32:CRT_INIT, after this initroutine returns. Ergo, we do an
    // extra load of the CRT, to be sure it stays around long enough.
    if ((fdwReason == DLL_PROCESS_ATTACH) && (!FIsWinNT()))
        LoadLibrary( "MSVCRTD.DLL");
#endif

    switch (fdwReason) {
        case DLL_PROCESS_DETACH:
            if( g_hCryptUI ) {
                FreeLibrary( g_hCryptUI );
                g_hCryptUI = NULL;
            }

            if (!g_fEnableProcessDetach)
                return TRUE;
            else
                g_fEnableProcessDetach = FALSE;

            if (!I_CryptIsProcessDetachFreeLibrary(lpvReserved)) {
                // Process Exit. I have seen cases where other Dlls, like
                // wininet.dll, depend on crypt32.dll. However, crypt32.dll
                // gets called first at ProcessDetach. Since all the memory
                // and kernel handles will get freed anyway by the kernel,
                // we can skip the following detach freeing.

                // Always need to free shared memory used for certificate
                // performance counters
                CertPerfDllMain(hInstDLL, fdwReason, lpvReserved);
                return TRUE;
            }

            // Fall through for FreeLibrary
        case DLL_THREAD_DETACH:
            for (i = DLL_MAIN_FUNC_COUNT - 1; i >= 0; i--)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;

        case DLL_PROCESS_ATTACH:
            for (i = 0; i < DLL_MAIN_FUNC_COUNT; i++) {
                fReturn = rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
                if (!fReturn)
                    break;
            }

            if (!fReturn) {
                for (i--; i >= 0; i--)
                    rgpfnDllMain[i](hInstDLL, DLL_PROCESS_DETACH, NULL);
            } else
                g_fEnableProcessDetach = TRUE;
            break;

        case DLL_THREAD_ATTACH:
        default:
            for (i = 0; i < DLL_MAIN_FUNC_COUNT; i++)
                fReturn &= rgpfnDllMain[i](hInstDLL, fdwReason, lpvReserved);
            break;
    }

    return(fReturn);
}

#if 1
typedef
DWORD
(WINAPI *PFN_I_CryptUIProtect)(
    IN      PVOID               pvReserved1,
    IN      PVOID               pvReserved2,
    IN      DWORD               dwReserved3,
    IN      PVOID               *pvReserved4,
    IN      BOOL                fReserved5,
    IN      PVOID               pvReserved6
    );
extern "C"
DWORD
WINAPI
I_CryptUIProtect(
    IN      PVOID               pvReserved1,
    IN      PVOID               pvReserved2,
    IN      DWORD               dwReserved3,
    IN      PVOID               *pvReserved4,
    IN      BOOL                fReserved5,
    IN      PVOID               pvReserved6
    )
{
    static PFN_I_CryptUIProtect pfn;
    DWORD rc;


    if ( g_hCryptUI == NULL ) {

        g_hCryptUI = LoadLibrary(TEXT("cryptui.dll"));

        if( g_hCryptUI == NULL )
            return GetLastError();
    }

    if ( pfn == NULL ) {
        pfn = (PFN_I_CryptUIProtect)GetProcAddress(g_hCryptUI, "I_CryptUIProtect");
    }

    if ( pfn != NULL ) {
        rc = (*pfn)(pvReserved1, pvReserved2, dwReserved3, pvReserved4, fReserved5, pvReserved6);
    } else {
        rc = GetLastError();

        if( rc == ERROR_SUCCESS )
            rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}

typedef
DWORD
(WINAPI *PFN_I_CryptUIProtectFailure)(
    IN      PVOID               pvReserved1,
    IN      DWORD               dwReserved2,
    IN      PVOID               *pvReserved3
    );
extern "C"
DWORD
WINAPI
I_CryptUIProtectFailure(
    IN      PVOID               pvReserved1,
    IN      DWORD               dwReserved2,
    IN      PVOID               *pvReserved3
    )
{
    static PFN_I_CryptUIProtectFailure pfn;
    DWORD rc;


    if ( g_hCryptUI == NULL ) {

        g_hCryptUI = LoadLibrary(TEXT("cryptui.dll"));

        if( g_hCryptUI == NULL )
            return GetLastError();
    }

    if ( pfn == NULL ) {
        pfn = (PFN_I_CryptUIProtectFailure)GetProcAddress(g_hCryptUI, "I_CryptUIProtectFailure");
    }

    if ( pfn != NULL ) {
        rc = (*pfn)(pvReserved1, dwReserved2, pvReserved3);
    } else {
        rc = GetLastError();

        if( rc == ERROR_SUCCESS )
            rc = ERROR_INVALID_PARAMETER;
    }

    return rc;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\encdecpk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       encdecpk.h
//
//--------------------------------------------------------------------------

#ifndef _ENCDECPK_H
#define _ENCDECPK_H

BOOL   
WINAPI   
EncodeDecodeDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\impexppk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       impexppk.h
//
//--------------------------------------------------------------------------

#ifndef _IMPEXPPK_H
#define _IMPEXPPK_H

BOOL   
WINAPI   
ImportExportDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved);






#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\encdecpk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhlpr.cpp
//
//  Contents:   import and export of private keys
//
//  Functions:  ImportExoprtDllMain
//              CryptImportPKCS8
//              CryptExportPKCS8
//
//  History:
//--------------------------------------------------------------------------

#include "global.hxx"

#ifdef __cplusplus
extern "C" {
#endif
#include "prvtkey.h"
#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)
static const BYTE NullDer[2] = {0x05, 0x00};
static const CRYPT_OBJID_BLOB NullDerBlob = {2, (BYTE *)&NullDer[0]};

static HCRYPTASN1MODULE hPrivateKeyAsn1Module;
static HCRYPTOIDFUNCSET hEncodePrivKeyFuncSet;
static HCRYPTOIDFUNCSET hDecodePrivKeyFuncSet;

//+-------------------------------------------------------------------------
//  OSS ASN.1 PKCS#8 PrivateKey Encode / Decode functions
//--------------------------------------------------------------------------
static BOOL WINAPI OssRSAPrivateKeyStrucEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BLOBHEADER *pBlobHeader,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
static BOOL WINAPI OssRSAPrivateKeyStrucDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BLOBHEADER *pBlobHeader,
        IN OUT DWORD *pcbBlobHeader
        );

static BOOL WINAPI OssPrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_PRIVATE_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
static BOOL WINAPI OssPrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_PRIVATE_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

static BOOL WINAPI OssEncryptedPrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
static BOOL WINAPI OssEncryptedPrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

static const CRYPT_OID_FUNC_ENTRY PrivateKeyEncodeFuncTable[] = {
    PKCS_RSA_PRIVATE_KEY, OssRSAPrivateKeyStrucEncode,
    PKCS_PRIVATE_KEY_INFO, OssPrivateKeyInfoEncode,
    PKCS_ENCRYPTED_PRIVATE_KEY_INFO, OssEncryptedPrivateKeyInfoEncode
};
#define PRIVATEKEY_ENCODE_FUNC_COUNT (sizeof(PrivateKeyEncodeFuncTable) / \
                                    sizeof(PrivateKeyEncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY PrivateKeyDecodeFuncTable[] = {
    PKCS_RSA_PRIVATE_KEY, OssRSAPrivateKeyStrucDecode,
    PKCS_PRIVATE_KEY_INFO, OssPrivateKeyInfoDecode,
    PKCS_ENCRYPTED_PRIVATE_KEY_INFO, OssEncryptedPrivateKeyInfoDecode,
};

#define PRIVATEKEY_DECODE_FUNC_COUNT (sizeof(PrivateKeyDecodeFuncTable) / \
                                    sizeof(PrivateKeyDecodeFuncTable[0]))



BOOL
WINAPI
EncodeDecodeDllMain(
        HMODULE hInst,
        ULONG ul_reason_for_call,
        LPVOID lpReserved)
{
    switch( ul_reason_for_call )
    {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hEncodePrivKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                0)))
            goto ErrorReturn;
        if (NULL == (hDecodePrivKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_DECODE_OBJECT_FUNC,
                0)))
            goto ErrorReturn;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                PRIVATEKEY_ENCODE_FUNC_COUNT,
                PrivateKeyEncodeFuncTable,
                0))                         // dwFlags
            goto ErrorReturn;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                PRIVATEKEY_DECODE_FUNC_COUNT,
                PrivateKeyDecodeFuncTable,
                0))                         // dwFlags
            goto ErrorReturn;

#ifdef OSS_CRYPT_ASN1
        if (0 == (hPrivateKeyAsn1Module =
                I_CryptInstallAsn1Module(prvtkey, 0, NULL)) )
            goto ErrorReturn;
#else
        PRVTKEY_Module_Startup();
        if (0 == (hPrivateKeyAsn1Module = I_CryptInstallAsn1Module(
                PRVTKEY_Module, 0, NULL))) {
            PRVTKEY_Module_Cleanup();
            goto ErrorReturn;
        }
#endif  // OSS_CRYPT_ASN1
        break;

    case DLL_PROCESS_DETACH:
        I_CryptUninstallAsn1Module(hPrivateKeyAsn1Module);
#ifndef OSS_CRYPT_ASN1
        PRVTKEY_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
        break;

    default:
        break;
    }

    return TRUE;
ErrorReturn:
    return FALSE;
}


static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hPrivateKeyAsn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hPrivateKeyAsn1Module);
}


//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the OssX509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoEncode(
        IN int pdunum,
        IN void *pOssInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfo(
        GetEncoder(),
        pdunum,
        pOssInfo,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL OssInfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppOssInfo
        )
{
    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppOssInfo);
}


//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------
static void OssInfoFree(
        IN int pdunum,
        IN void *pOssInfo
        )
{
    if (pOssInfo) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pOssInfo);

        SetLastError(dwErr);
    }
}


//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
static inline void OssX509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pOss
        )
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
static inline void OssX509GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get Object Identifier string
//--------------------------------------------------------------------------
static BOOL OssX509SetObjId(
        IN LPSTR pszObjId,
        OUT ObjectID *pOss
        )
{
    pOss->count = sizeof(pOss->value) / sizeof(pOss->value[0]);
    if (PkiAsn1ToObjectIdentifier(pszObjId, &pOss->count, pOss->value))
        return TRUE;
    else {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        return FALSE;
    }
}

static void OssX509GetObjId(
        IN ObjectID *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    PkiAsn1FromObjectIdentifier(
        pOss->count,
        pOss->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
static inline void OssX509SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT NOCOPYANY *pOss
        )
{
#ifdef OSS_CRYPT_ASN1
    PkiAsn1SetAny(pInfo, (OpenType *) pOss);
#else
    PkiAsn1SetAny(pInfo, pOss);
#endif  // OSS_CRYPT_ASN1
}
static inline void OssX509GetAny(
        IN NOCOPYANY *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
#ifdef OSS_CRYPT_ASN1
    PkiAsn1GetAny((OpenType *) pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
#else
    PkiAsn1GetAny(pOss, dwFlags, pInfo, ppbExtra, plRemainExtra);
#endif  // OSS_CRYPT_ASN1
}

//+-------------------------------------------------------------------------
//  Set/Free/Get SeqOfAny
//--------------------------------------------------------------------------
static BOOL WINAPI OssX509SetSeqOfAny(
        IN DWORD cValue,
        IN PCRYPT_DER_BLOB pValue,
#ifdef OSS_CRYPT_ASN1
        OUT unsigned int *pOssCount,
#else
        OUT ASN1uint32_t *pOssCount,
#endif  // OSS_CRYPT_ASN1
        OUT NOCOPYANY **ppOssValue
        )
{

    *pOssCount = 0;
    *ppOssValue = NULL;
    if (cValue > 0) {
        NOCOPYANY *pOssValue;

        pOssValue = (NOCOPYANY *) SSAlloc(cValue * sizeof(NOCOPYANY));
        if (pOssValue == NULL)
            return FALSE;
        memset(pOssValue, 0, cValue * sizeof(NOCOPYANY));
        *pOssCount = cValue;
        *ppOssValue = pOssValue;
        for ( ; cValue > 0; cValue--, pValue++, pOssValue++)
            OssX509SetAny(pValue, pOssValue);
    }
    return TRUE;
}

static void OssX509FreeSeqOfAny(
        IN NOCOPYANY *pOssValue
        )
{
    if (pOssValue)
        SSFree(pOssValue);
}

static void OssX509GetSeqOfAny(
        IN unsigned int OssCount,
        IN NOCOPYANY *pOssValue,
        IN DWORD dwFlags,
        OUT DWORD *pcValue,
        OUT PCRYPT_DER_BLOB *ppValue,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lAlignExtra;
    PCRYPT_ATTR_BLOB pValue;

    lAlignExtra = INFO_LEN_ALIGN(OssCount * sizeof(CRYPT_DER_BLOB));
    *plRemainExtra -= lAlignExtra;
    if (*plRemainExtra >= 0) {
        *pcValue = OssCount;
        pValue = (PCRYPT_DER_BLOB) *ppbExtra;
        *ppValue = pValue;
        *ppbExtra += lAlignExtra;
    } else
        pValue = NULL;

    for (; OssCount > 0; OssCount--, pOssValue++, pValue++)
        OssX509GetAny(pOssValue, dwFlags, pValue, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Free/Get CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
static BOOL WINAPI OssX509SetAttribute(
        IN PCRYPT_ATTRIBUTE pInfo,
        OUT Attribute *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    if (!OssX509SetObjId(pInfo->pszObjId, &pOss->type))
        return FALSE;

    return OssX509SetSeqOfAny(
            pInfo->cValue,
            pInfo->rgValue,
            &pOss->values.count,
            &pOss->values.value);
}

static void OssX509FreeAttribute(
        IN OUT Attribute *pOss
        )
{
    OssX509FreeSeqOfAny(pOss->values.value);
}

static void OssX509GetAttribute(
        IN Attribute *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_ATTRIBUTE pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    OssX509GetObjId(&pOss->type, dwFlags,
        &pInfo->pszObjId, ppbExtra, plRemainExtra);
    OssX509GetSeqOfAny(pOss->values.count, pOss->values.value, dwFlags,
        &pInfo->cValue, &pInfo->rgValue, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
static BOOL OssX509SetAlgorithm(
        IN PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        OUT AlgorithmIdentifier *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    if (pInfo->pszObjId) {
        if (!OssX509SetObjId(pInfo->pszObjId, &pOss->algorithm))
            return FALSE;
        if (pInfo->Parameters.cbData)
            OssX509SetAny(&pInfo->Parameters, &pOss->parameters);
        else
            // Per PKCS #1: default to the ASN.1 type NULL.
            OssX509SetAny((PCRYPT_OBJID_BLOB) &NullDerBlob, &pOss->parameters);
        pOss->bit_mask |= parameters_present;
    }
    return TRUE;
}

static void OssX509GetAlgorithm(
        IN AlgorithmIdentifier *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    if (*plRemainExtra >= 0)
        memset(pInfo, 0, sizeof(*pInfo));
    OssX509GetObjId(&pOss->algorithm, dwFlags, &pInfo->pszObjId,
            ppbExtra, plRemainExtra);
    if (pOss->bit_mask & parameters_present)
        OssX509GetAny(&pOss->parameters, dwFlags, &pInfo->Parameters,
            ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Helper function for Encode RSA Private Key
//--------------------------------------------------------------------------
static BOOL WINAPI AllocAndCopyHugeInteger(
        IN BYTE *pbHugeInteger,
        IN DWORD cbHugeInteger,
        OUT HUGEINTEGER *pHugeInteger
        )
{
    BYTE *pbAllocBuffer = NULL;

    if (NULL == (pbAllocBuffer = (BYTE *) SSAlloc(cbHugeInteger + 1)))
        return FALSE;
    *pbAllocBuffer = 0;
    memcpy(pbAllocBuffer + 1, pbHugeInteger, cbHugeInteger);
    PkiAsn1ReverseBytes(pbAllocBuffer + 1, cbHugeInteger);
    pHugeInteger->length = cbHugeInteger + 1;
    pHugeInteger->value = pbAllocBuffer;
    return TRUE;
}

#ifndef RSA2
#define RSA2 ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24))
#endif

//+-------------------------------------------------------------------------
//  Encode RSA Private Key
//--------------------------------------------------------------------------
static BOOL WINAPI OssRSAPrivateKeyStrucEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BLOBHEADER *pBlobHeader,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;

    BYTE *pbKeyBlob;
    RSAPUBKEY *pRsaPubKey;

    BYTE *pbCurrentHugeInteger;
    DWORD cbHugeInteger;
    BYTE *pbAllocBuffer = NULL;

    RSAPrivateKey OssRSAPrivateKey;

    memset(&OssRSAPrivateKey, 0, (size_t) sizeof(RSAPrivateKey));

    // The CAPI RSA private key representation consists of the following sequence:
    // - BLOBHEADER blobheader;
    // - RSAPUBKEY rsapubkey;
    // - BYTE modulus[rsapubkey.bitlen/8];
    // - BYTE prime1[rsapubkey.bitlen/16];
    // - BYTE prime2[rsapubkey.bitlen/16];
    // - BYTE exponent1[rsapubkey.bitlen/16];
    // - BYTE exponent2[rsapubkey.bitlen/16];
    // - BYTE coefficient[rsapubkey.bitlen/16];
    // - BYTE privateExponent[rsapubkey.bitlen/8];

    pbKeyBlob = (BYTE *) pBlobHeader;
    pRsaPubKey = (RSAPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));

    assert(pRsaPubKey->bitlen / 8 > 0);
    assert(pBlobHeader->bType == PRIVATEKEYBLOB);
    assert(pBlobHeader->bVersion == CUR_BLOB_VERSION);
    assert(pBlobHeader->aiKeyAlg == CALG_RSA_SIGN ||
           pBlobHeader->aiKeyAlg == CALG_RSA_KEYX);
    assert(pRsaPubKey->magic == RSA2);
    assert(pRsaPubKey->bitlen % 8 == 0);

    if (pBlobHeader->bType != PRIVATEKEYBLOB)
        goto InvalidArg;

    // PKCS #1 ASN.1 encode
    //
    // ASN.1 isn't reversing HUGE_INTEGERs. Also, after doing the
    // reversal insert a leading 0 byte to force it to always be treated
    // as an unsigned integer

    OssRSAPrivateKey.version = 0; // currently on version 0

    // MODULUS
    pbCurrentHugeInteger = pbKeyBlob + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);
    cbHugeInteger = pRsaPubKey->bitlen / 8;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger,
                                cbHugeInteger,
                                &(OssRSAPrivateKey.modulus)))
        goto ErrorReturn;

    // PUBLIC EXPONENT
    OssRSAPrivateKey.publicExponent = pRsaPubKey->pubexp;

    // PRIME1
    pbCurrentHugeInteger += cbHugeInteger;
    cbHugeInteger = (pRsaPubKey->bitlen + 15) / 16;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger,
                                cbHugeInteger,
                                &(OssRSAPrivateKey.prime1)))
        goto ErrorReturn;

    // PRIME2
    pbCurrentHugeInteger += cbHugeInteger;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger,
                                cbHugeInteger,
                                &(OssRSAPrivateKey.prime2)))
        goto ErrorReturn;

    // EXPONENT1
    pbCurrentHugeInteger += cbHugeInteger;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger,
                                cbHugeInteger,
                                &(OssRSAPrivateKey.exponent1)))
        goto ErrorReturn;

    // EXPONENT2
    pbCurrentHugeInteger += cbHugeInteger;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger,
                                cbHugeInteger,
                                &(OssRSAPrivateKey.exponent2)))
        goto ErrorReturn;

    // COEFFICIENT
    pbCurrentHugeInteger += cbHugeInteger;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger,
                                cbHugeInteger,
                                &(OssRSAPrivateKey.coefficient)))
        goto ErrorReturn;

    // PRIVATE EXPONENT
    pbCurrentHugeInteger += cbHugeInteger;
    cbHugeInteger = pRsaPubKey->bitlen / 8;
    if (!AllocAndCopyHugeInteger(pbCurrentHugeInteger,
                                cbHugeInteger,
                                &(OssRSAPrivateKey.privateExponent)))
        goto ErrorReturn;

    fResult = OssInfoEncode(
        RSAPrivateKey_PDU,
        &OssRSAPrivateKey,
        pbEncoded,
        pcbEncoded
        );
    goto CommonReturn;

InvalidArg:
    SetLastError((DWORD) E_INVALIDARG);
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (OssRSAPrivateKey.modulus.value)
        SSFree(OssRSAPrivateKey.modulus.value);
    if (OssRSAPrivateKey.prime1.value)
        SSFree(OssRSAPrivateKey.prime1.value);
    if (OssRSAPrivateKey.prime2.value)
        SSFree(OssRSAPrivateKey.prime2.value);
    if (OssRSAPrivateKey.exponent1.value)
        SSFree(OssRSAPrivateKey.exponent1.value);
    if (OssRSAPrivateKey.exponent2.value)
        SSFree(OssRSAPrivateKey.exponent2.value);
    if (OssRSAPrivateKey.coefficient.value)
        SSFree(OssRSAPrivateKey.coefficient.value);
    if (OssRSAPrivateKey.privateExponent.value)
        SSFree(OssRSAPrivateKey.privateExponent.value);
    return fResult;
}


//+-------------------------------------------------------------------------
//  Helper function for Decode RSA Private Key
//--------------------------------------------------------------------------
static BOOL WINAPI CopyHugeIntegerToByteArray(
        HUGEINTEGER *pHugeInteger,
        BYTE *pbBuffer,
        DWORD cbBuffer,
        BOOL  fGetRidOfLeading0)
{
    memset(pbBuffer, 0, (size_t) cbBuffer);

    DWORD cbHugeInteger = pHugeInteger->length;
    BYTE *pbHugeInteger = pHugeInteger->value;

    // get rid of leading zero on the huge integer
    if ((cbHugeInteger > 1)     &&
        (*pbHugeInteger == 0)   &&
        (fGetRidOfLeading0))
    {
            pbHugeInteger++;
            cbHugeInteger--;
    }
    else if ((cbHugeInteger > cbBuffer) &&
             (*pbHugeInteger != 0)      &&
             (fGetRidOfLeading0))
    {
        //
        // THIS IS A UNSUPPORTED KEY FORMAT PROBLEM!!
        //
        SetLastError((DWORD) ERROR_UNSUPPORTED_TYPE);
        assert(0);
        return FALSE;
    }

    // verify there is enough space in pbBuffer to receive
    // the huge integer
    if (cbHugeInteger > cbBuffer)
    {
        SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
        assert(0);
        return FALSE;
    }
    // advance pbBuffer to the correct place within itself,
    // this will leave leading zeros at the beginning of the buffer
    /*else
        pbBuffer += (cbBuffer - cbHugeInteger);*/


    if (cbHugeInteger > 0) {
        memcpy(pbBuffer, pbHugeInteger, cbHugeInteger);
        // ASN.1 isn't reversing HUGEINTEGERs
        PkiAsn1ReverseBytes(pbBuffer, cbHugeInteger);
    }

    return TRUE;
}



//+-------------------------------------------------------------------------
//  Decode RSA Private Key
//--------------------------------------------------------------------------
static BOOL WINAPI OssRSAPrivateKeyStrucDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BLOBHEADER *pBlobHeader,
        IN OUT DWORD *pcbBlobHeader
        )
{
    BOOL fResult;
    RSAPrivateKey *pOssPrivateKey = NULL;

    if (pBlobHeader == NULL)
        *pcbBlobHeader = 0;

    if ((fResult = OssInfoDecodeAndAlloc(
            RSAPrivateKey_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pOssPrivateKey))) {
        DWORD cbPrivateKeyStruc;
        BYTE *pbOssModulus;
        DWORD cbModulus;
        DWORD cbNonModulus;
        // Now convert the OSS RSA private key into CAPI's representation which
        // consists of the following sequence:
        // - BLOBHEADER blobheader;
        // - RSAPUBKEY rsapubkey;
        // - BYTE modulus[rsapubkey.bitlen/8];
        // - BYTE prime1[rsapubkey.bitlen/16];
        // - BYTE prime2[rsapubkey.bitlen/16];
        // - BYTE exponent1[rsapubkey.bitlen/16];
        // - BYTE exponent2[rsapubkey.bitlen/16];
        // - BYTE coefficient[rsapubkey.bitlen/16];
        // - BYTE privateExponent[rsapubkey.bitlen/8];
        cbModulus = pOssPrivateKey->modulus.length;

        pbOssModulus = pOssPrivateKey->modulus.value;
        // Strip off a leading 0 byte. Its there in the decoded ASN
        // integer for an unsigned integer with the leading bit set.
        if (cbModulus > 1 && *pbOssModulus == 0) {
            pbOssModulus++;
            cbModulus--;
        }

        cbNonModulus = (cbModulus / 2) + (cbModulus % 2);

        cbPrivateKeyStruc = sizeof(BLOBHEADER) + // length of BLOBHEADER
                            sizeof(RSAPUBKEY) +  // length of RSAPUBKEY
                            (cbModulus * 2) +    // length of modulus and privateExponent
                            (cbNonModulus * 5);  // length of prime1&2, exponent1&2, and coefficient
        if (*pcbBlobHeader < cbPrivateKeyStruc) {
            if (pBlobHeader) {
                fResult = FALSE;
                SetLastError((DWORD) ERROR_MORE_DATA);
            }
        } else {
            BYTE *pbKeyBlob = (BYTE *) pBlobHeader;
            RSAPUBKEY *pRsaPubKey =
                (RSAPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
            BYTE *pbModulus = pbKeyBlob + sizeof(PUBLICKEYSTRUC) +
                sizeof(RSAPUBKEY);
            BYTE *pbCurrentPosition = NULL;

            pBlobHeader->bType = PRIVATEKEYBLOB;
            pBlobHeader->bVersion = CUR_BLOB_VERSION;
            pBlobHeader->reserved = 0;
            // Note: KEYX can also be used for doing a signature
            pBlobHeader->aiKeyAlg = CALG_RSA_KEYX;

            pRsaPubKey->magic = RSA2;
            pRsaPubKey->bitlen = cbModulus * 8;
            pRsaPubKey->pubexp = pOssPrivateKey->publicExponent;

            // MODULUS
            if (cbModulus > 0) {
                memcpy(pbModulus, pbOssModulus, cbModulus);
                // ASN.1 isn't reversing HUGEINTEGERs
                PkiAsn1ReverseBytes(pbModulus, cbModulus);
            }

            // PRIME1
            pbCurrentPosition = pbModulus + cbModulus;
            if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->prime1,
                                            pbCurrentPosition,
                                            cbNonModulus,
                                            (pOssPrivateKey->prime1.length - 1) == cbNonModulus))
                goto ErrorReturn;

            // PRIME2
            pbCurrentPosition += cbNonModulus;
            if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->prime2,
                                            pbCurrentPosition,
                                            cbNonModulus,
                                            (pOssPrivateKey->prime2.length - 1) == cbNonModulus))
                goto ErrorReturn;

            // EXPONENT1
            pbCurrentPosition += cbNonModulus;
            if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->exponent1,
                                            pbCurrentPosition,
                                            cbNonModulus,
                                            (pOssPrivateKey->exponent1.length - 1) == cbNonModulus))
                goto ErrorReturn;

            // EXPONENT2
            pbCurrentPosition += cbNonModulus;
            if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->exponent2,
                                            pbCurrentPosition,
                                            cbNonModulus,
                                            (pOssPrivateKey->exponent2.length - 1) == cbNonModulus))
                goto ErrorReturn;

            // COEFFICIENT
            pbCurrentPosition += cbNonModulus;
            if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->coefficient,
                                            pbCurrentPosition,
                                            cbNonModulus,
                                            (pOssPrivateKey->coefficient.length - 1) == cbNonModulus))
                goto ErrorReturn;

            // PRIVATE EXPONENT
            pbCurrentPosition += cbNonModulus;
            if (!CopyHugeIntegerToByteArray(&pOssPrivateKey->privateExponent,
                                            pbCurrentPosition,
                                            cbModulus,
                                            (pOssPrivateKey->privateExponent.length - 1) == cbModulus))
                goto ErrorReturn;

        }
        *pcbBlobHeader = cbPrivateKeyStruc;
    } else
        *pcbBlobHeader = 0;

    OssInfoFree(RSAPrivateKey_PDU, pOssPrivateKey);

    goto CommonReturn;

ErrorReturn:
    *pcbBlobHeader = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}


//+-------------------------------------------------------------------------
//  Encode Private Key Info
//--------------------------------------------------------------------------
static BOOL WINAPI OssPrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_PRIVATE_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    PrivateKeyInfo OssPrivateKeyInfo;
    Attribute *pOssAttr = NULL;
    DWORD cAttr;
    PCRYPT_ATTRIBUTE pAttr;

    memset(&OssPrivateKeyInfo, 0, sizeof(PrivateKeyInfo));

    OssPrivateKeyInfo.version = pInfo->Version;

    if (!OssX509SetAlgorithm(&pInfo->Algorithm, &OssPrivateKeyInfo.privateKeyAlgorithm))
        goto ErrorReturn;

    OssX509SetOctetString(&pInfo->PrivateKey, &OssPrivateKeyInfo.privateKey);

    if (pInfo->pAttributes) {
        cAttr = pInfo->pAttributes->cAttr;
        pAttr = pInfo->pAttributes->rgAttr;

        OssPrivateKeyInfo.privateKeyAttributes.count = cAttr;
        OssPrivateKeyInfo.privateKeyAttributes.value = NULL;
        if (cAttr > 0) {
            pOssAttr = (Attribute *) SSAlloc(cAttr * sizeof(Attribute));
            if (pOssAttr == NULL)
                goto ErrorReturn;
            memset(pOssAttr, 0, cAttr * sizeof(Attribute));
            OssPrivateKeyInfo.privateKeyAttributes.value= pOssAttr;
        }

        for ( ; cAttr > 0; cAttr--, pAttr++, pOssAttr++) {
            if (!OssX509SetAttribute(pAttr, pOssAttr))
                goto ErrorReturn;
        }

        OssPrivateKeyInfo.bit_mask |= privateKeyAttributes_present;
    }

    fResult = OssInfoEncode(
        PrivateKeyInfo_PDU,
        &OssPrivateKeyInfo,
        pbEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    if (OssPrivateKeyInfo.privateKeyAttributes.value) {
        pOssAttr = OssPrivateKeyInfo.privateKeyAttributes.value;
        cAttr = OssPrivateKeyInfo.privateKeyAttributes.count;
        for ( ; cAttr > 0; cAttr--, pOssAttr++)
            OssX509FreeAttribute(pOssAttr);

        SSFree(OssPrivateKeyInfo.privateKeyAttributes.value);
    }
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode Private Key Info
//--------------------------------------------------------------------------
static BOOL WINAPI OssPrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_PRIVATE_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    PrivateKeyInfo *pPrivateKeyInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!OssInfoDecodeAndAlloc(
            PrivateKeyInfo_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pPrivateKeyInfo))
        goto EncodeError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CRYPT_PRIVATE_KEY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Default all optional fields to zero
        memset(pInfo, 0, sizeof(CRYPT_PRIVATE_KEY_INFO));

        // Update fields not needing extra memory after the CRYPT_PRIVATE_KEY_INFO
        pInfo->Version = pPrivateKeyInfo->version;

        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_PRIVATE_KEY_INFO);
    }

    OssX509GetAlgorithm(&pPrivateKeyInfo->privateKeyAlgorithm, dwFlags,
            &pInfo->Algorithm, &pbExtra, &lRemainExtra);

    OssX509GetOctetString(&pPrivateKeyInfo->privateKey, dwFlags,
            &pInfo->PrivateKey, &pbExtra, &lRemainExtra);

    if (pPrivateKeyInfo->bit_mask & privateKeyAttributes_present) {
        DWORD cAttr;
        PCRYPT_ATTRIBUTE pAttr;
        Attribute *pOssAttr;
        LONG lAlignExtra;

        // put the CRYPT_ATTRIBUTES structure in the extra buffer space
        // and point pInfo->pAttributes to it
        if ((pbExtra) && (lRemainExtra >= sizeof(CRYPT_ATTRIBUTES))) {
            memset(pbExtra, 0, sizeof(CRYPT_ATTRIBUTES));
            pInfo->pAttributes = (PCRYPT_ATTRIBUTES) pbExtra;
            pbExtra += sizeof(CRYPT_ATTRIBUTES);
        }
        lRemainExtra -= sizeof(CRYPT_ATTRIBUTES);

        cAttr = pPrivateKeyInfo->privateKeyAttributes.count;
        lAlignExtra = INFO_LEN_ALIGN(cAttr * sizeof(CRYPT_ATTRIBUTE));
        lRemainExtra -= lAlignExtra;
        if (lRemainExtra >= 0) {
            pInfo->pAttributes->cAttr = cAttr;
            pAttr = (PCRYPT_ATTRIBUTE) pbExtra;
            pInfo->pAttributes->rgAttr = pAttr;
            pbExtra += lAlignExtra;
        } else
            pAttr = NULL;

        pOssAttr = pPrivateKeyInfo->privateKeyAttributes.value;
        for (; cAttr > 0; cAttr--, pAttr++, pOssAttr++)
            OssX509GetAttribute(pOssAttr, dwFlags,
                pAttr, &pbExtra, &lRemainExtra);
    }

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
// ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    OssInfoFree(PrivateKeyInfo_PDU, pPrivateKeyInfo);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Encode Encrypted Private Key Info
//--------------------------------------------------------------------------
static BOOL WINAPI OssEncryptedPrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    EncryptedPrivateKeyInfo OssEncryptedPrivateKeyInfo;

    memset(&OssEncryptedPrivateKeyInfo, 0, sizeof(EncryptedPrivateKeyInfo));

    if (!OssX509SetAlgorithm(&pInfo->EncryptionAlgorithm, &OssEncryptedPrivateKeyInfo.encryptionAlgorithm))
        goto ErrorReturn;

    OssX509SetOctetString(&pInfo->EncryptedPrivateKey, &OssEncryptedPrivateKeyInfo.encryptedData);

    fResult = OssInfoEncode(
        EncryptedPrivateKeyInfo_PDU,
        &OssEncryptedPrivateKeyInfo,
        pbEncoded,
        pcbEncoded
        );
    goto CommonReturn;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decode Encrypted Private Key Info
//--------------------------------------------------------------------------
static BOOL WINAPI OssEncryptedPrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    EncryptedPrivateKeyInfo *pEncryptedPrivateKeyInfo = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!OssInfoDecodeAndAlloc(
            EncryptedPrivateKeyInfo_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pEncryptedPrivateKeyInfo))
        goto EncodeError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CRYPT_ENCRYPTED_PRIVATE_KEY_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        memset(pInfo, 0, sizeof(CRYPT_ENCRYPTED_PRIVATE_KEY_INFO));
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_ENCRYPTED_PRIVATE_KEY_INFO);
    }

    OssX509GetAlgorithm(&pEncryptedPrivateKeyInfo->encryptionAlgorithm, dwFlags,
            &pInfo->EncryptionAlgorithm, &pbExtra, &lRemainExtra);

    OssX509GetOctetString(&pEncryptedPrivateKeyInfo->encryptedData, dwFlags,
            &pInfo->EncryptedPrivateKey, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
EncodeError:
    SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
//ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    OssInfoFree(EncryptedPrivateKeyInfo_PDU, pEncryptedPrivateKeyInfo);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\impexppk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       certhlpr.cpp
//
//  Contents:   import and export of private keys
//
//  Functions:  ImportExoprtDllMain
//				CryptImportPKCS8
//				CryptExportPKCS8
//
//  History:    
//--------------------------------------------------------------------------

#include "global.hxx"
//#include "prvtkey.h"
#include "impexppk.h"
#include "pfxcrypt.h"


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static BOOL WINAPI ExportRSAPrivateKeyInfo(
    HCRYPTPROV              hCryptProv,         // in
    DWORD                   dwKeySpec,          // in
    LPSTR                   pszPrivateKeyObjId, // in
    DWORD                   dwFlags,            // in
    void                    *pvAuxInfo,         // in
    CRYPT_PRIVATE_KEY_INFO  *pPrivateKeyInfo,   // out
    DWORD                   *pcbPrivateKeyInfo  // in, out	
    );

static BOOL WINAPI ImportRSAPrivateKeyInfo(
    HCRYPTPROV                  hCryptProv,			// in
    CRYPT_PRIVATE_KEY_INFO      *pPrivateKeyInfo,	// in
    DWORD                       dwFlags,			// in, optional
    void                        *pvAuxInfo			// in, optional
    );

static BOOL WINAPI ExportDSSPrivateKeyInfo(
    HCRYPTPROV              hCryptProv,         // in
    DWORD                   dwKeySpec,          // in
    LPSTR                   pszPrivateKeyObjId, // in
    DWORD                   dwFlags,            // in
    void                    *pvAuxInfo,         // in
    CRYPT_PRIVATE_KEY_INFO  *pPrivateKeyInfo,   // out
    DWORD                   *pcbPrivateKeyInfo  // in, out	
    );

static BOOL WINAPI ImportDSSPrivateKeyInfo(
    HCRYPTPROV                  hCryptProv,			// in
    CRYPT_PRIVATE_KEY_INFO      *pPrivateKeyInfo,	// in
    DWORD                       dwFlags,			// in, optional
    void                        *pvAuxInfo			// in, optional
    );


static HCRYPTOIDFUNCSET hExportPrivKeyFuncSet;
static HCRYPTOIDFUNCSET hImportPrivKeyFuncSet;

// Internal default OIDs
#define DEFAULT_CSP_PRIVKEY1     ((LPCSTR) 1)
#define DEFAULT_CSP_PRIVKEY2     ((LPCSTR) 2)

static const CRYPT_OID_FUNC_ENTRY ExportPrivKeyFuncTable[] = {
    DEFAULT_CSP_PRIVKEY1, ExportRSAPrivateKeyInfo,
    szOID_RSA_RSA, ExportRSAPrivateKeyInfo,
    szOID_OIWSEC_dsa, ExportDSSPrivateKeyInfo,
    szOID_X957_DSA, ExportDSSPrivateKeyInfo
};
#define EXPORT_PRIV_KEY_FUNC_COUNT (sizeof(ExportPrivKeyFuncTable) / \
                                    sizeof(ExportPrivKeyFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY ImportPrivKeyFuncTable[] = {
    szOID_RSA_RSA, ImportRSAPrivateKeyInfo,
    szOID_OIWSEC_dsa, ImportDSSPrivateKeyInfo,
    szOID_X957_DSA, ImportDSSPrivateKeyInfo
};
#define IMPORT_PRIV_KEY_FUNC_COUNT (sizeof(ImportPrivKeyFuncTable) / \
                                    sizeof(ImportPrivKeyFuncTable[0]))


BOOL   
WINAPI   
ImportExportDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved)
{
    switch( ul_reason_for_call ) 
    {
    case DLL_PROCESS_ATTACH:
 
        // Private key function setup
		if (NULL == (hExportPrivKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC,
                0)))
            goto ErrorReturn;
        if (NULL == (hImportPrivKeyFuncSet = CryptInitOIDFunctionSet(
                CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC,
                0)))
            goto ErrorReturn;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC,
                EXPORT_PRIV_KEY_FUNC_COUNT,
                ExportPrivKeyFuncTable,
                0))                         // dwFlags
            goto ErrorReturn;
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC,
                IMPORT_PRIV_KEY_FUNC_COUNT,
                ImportPrivKeyFuncTable,
                0))                         // dwFlags
            goto ErrorReturn;
        break;
        
    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }


    return TRUE;

ErrorReturn:
    return FALSE;
}


//+-------------------------------------------------------------------------
// phCryptProv - a pointer to a HCRYPTPROV to put the handle of the provider
//				 that received the imported keyset.  if this is NON_NULL then
//				 the caller is responsible for calling CryptReleaseContext().
// pdwKeySpec - a pointer to a DWORD to receive the KeySpec of imported keyset
// privateKeyAndParams - private key blob and corresponding parameters
// dwFlags - The available flags are:
//				CRYPT_EXPORTABLE 
//				this flag is used when importing private keys, for a full 
//				explanation please see the documentation for CryptImportKey.
// phCryptProv - filled in with the handle of the provider the key was
//				 imported to, the caller is responsible for freeing it
// pvAuxInfo - This parameter is reserved for future use and should be set 
//			   to NULL in the interim.
//+-------------------------------------------------------------------------
BOOL 
WINAPI 
CryptImportPKCS8(
    CRYPT_PKCS8_IMPORT_PARAMS           sPrivateKeyAndParams,    // in
    DWORD                               dwFlags,                // in, optional
    HCRYPTPROV                          *phCryptProv,           // out
    void                                *pvAuxInfo              // in, optional
)
{
    BOOL                        fResult = TRUE;
    void                        *pvFuncAddr;
    HCRYPTOIDFUNCADDR           hFuncAddr;

    CRYPT_PRIVATE_KEY_INFO              *pPrivateKeyInfoStruct = NULL;	
    DWORD                               cbPrivateKeyInfoStruct = 0;
    CRYPT_ENCRYPTED_PRIVATE_KEY_INFO	*pEncryptedPrivateKeyInfoStruct = NULL;	
    DWORD                               cbEncryptedPrivateKeyInfoStruct = 0;
    BYTE                                *pbEncodedPrivateKey = sPrivateKeyAndParams.PrivateKey.pbData;
    DWORD                               cbEncodedPrivateKey = sPrivateKeyAndParams.PrivateKey.cbData;
    BOOL                                bEncodedPrivateKeyAlloced = FALSE;
    HCRYPTPROV                          hCryptProv = NULL;

	// try to decode private key blob as a CRYPT_PRIVATE_KEY_INFO structure
	if (!CryptDecodeObject(X509_ASN_ENCODING,
						PKCS_PRIVATE_KEY_INFO,
						sPrivateKeyAndParams.PrivateKey.pbData,
						sPrivateKeyAndParams.PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						NULL,
						&cbPrivateKeyInfoStruct)) {	
		
		// that decode failed, so try to decode as CRYPT_ENCRYPTED_PRIVATE_KEY_INFO structure
		if (!CryptDecodeObject(X509_ASN_ENCODING,
					PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
					sPrivateKeyAndParams.PrivateKey.pbData,
					sPrivateKeyAndParams.PrivateKey.cbData,
					CRYPT_DECODE_NOCOPY_FLAG,
					NULL,
					&cbEncryptedPrivateKeyInfoStruct))
			goto ErrorReturn;	

		if (NULL == (pEncryptedPrivateKeyInfoStruct = (CRYPT_ENCRYPTED_PRIVATE_KEY_INFO *)
					 SSAlloc(cbEncryptedPrivateKeyInfoStruct)))
			goto ErrorReturn;

		if (!CryptDecodeObject(X509_ASN_ENCODING,
					PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
					sPrivateKeyAndParams.PrivateKey.pbData,
					sPrivateKeyAndParams.PrivateKey.cbData,
					CRYPT_DECODE_NOCOPY_FLAG,
					pEncryptedPrivateKeyInfoStruct,
					&cbEncryptedPrivateKeyInfoStruct))
			goto ErrorReturn;
		
		// call back the callee to decrypt the private key info
		pbEncodedPrivateKey = NULL;
		cbEncodedPrivateKey = 0;
		if (!sPrivateKeyAndParams.pDecryptPrivateKeyFunc(
							pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm,
							pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey,
							NULL,
							&cbEncodedPrivateKey,
							sPrivateKeyAndParams.pVoidDecryptFunc))
			goto ErrorReturn;

		if (NULL == (pbEncodedPrivateKey = (BYTE *) 
					 SSAlloc(cbEncodedPrivateKey)))
			goto ErrorReturn;

		bEncodedPrivateKeyAlloced = TRUE;
		if (!sPrivateKeyAndParams.pDecryptPrivateKeyFunc(
							pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm,
							pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey,
							pbEncodedPrivateKey,
							&cbEncodedPrivateKey,
							sPrivateKeyAndParams.pVoidDecryptFunc))
			goto ErrorReturn;
		
		// we are now back to square one with an encoded CRYPT_PRIVATE_KEY_INFO struct,
		// so get the size of that when it's decoded
		if (!CryptDecodeObject(X509_ASN_ENCODING,
					PKCS_PRIVATE_KEY_INFO,
					pbEncodedPrivateKey,
					cbEncodedPrivateKey,
					CRYPT_DECODE_NOCOPY_FLAG,
					NULL,
					&cbPrivateKeyInfoStruct))
			goto ErrorReturn;
	}

	if (NULL == (pPrivateKeyInfoStruct = (CRYPT_PRIVATE_KEY_INFO *)
				 SSAlloc(cbPrivateKeyInfoStruct)))
		goto ErrorReturn;

	if (!CryptDecodeObject(X509_ASN_ENCODING,
					PKCS_PRIVATE_KEY_INFO,
					pbEncodedPrivateKey,
					cbEncodedPrivateKey,
					CRYPT_DECODE_NOCOPY_FLAG,
					pPrivateKeyInfoStruct,
					&cbPrivateKeyInfoStruct))
		goto ErrorReturn;

	// call the caller back to get the provider to import to, if the
	// call back is null then just use the default provider.
	if (sPrivateKeyAndParams.pResolvehCryptProvFunc != NULL) {
		if (!sPrivateKeyAndParams.pResolvehCryptProvFunc(
				pPrivateKeyInfoStruct,
				&hCryptProv,
				sPrivateKeyAndParams.pVoidResolveFunc)) {
			goto ErrorReturn;
		}
	}
	else {
		if (!CryptAcquireContext(
				&hCryptProv,
				NULL,
				NULL,
				PROV_RSA_FULL,
				CRYPT_NEWKEYSET)) {
			goto ErrorReturn;
		}
	}
	
	// resolve what supporting import function to call based on the algorithm 
	// OID of the private key
	if (CryptGetOIDFunctionAddress(
				hImportPrivKeyFuncSet,
				X509_ASN_ENCODING,
				pPrivateKeyInfoStruct->Algorithm.pszObjId,
				0,                      // dwFlags
				&pvFuncAddr,
				&hFuncAddr)) {
		fResult = ((PFN_IMPORT_PRIV_KEY_FUNC) pvFuncAddr)(
				hCryptProv,
				pPrivateKeyInfoStruct,  
				dwFlags,
				pvAuxInfo
				);
		CryptFreeOIDFunctionAddress(hFuncAddr, 0);
	} 
	else {
		SetLastError(ERROR_UNSUPPORTED_TYPE);
        goto ErrorReturn;
	}

	// check to see if the caller wants the hCryptProv
	if (phCryptProv) {
		*phCryptProv = hCryptProv;
	}
	else {
        HRESULT hr = GetLastError();
		CryptReleaseContext(hCryptProv, 0);	
        SetLastError(hr);
	}

	goto CommonReturn;

		
ErrorReturn:
	fResult = FALSE;
	if (hCryptProv)
    {
		HRESULT hr = GetLastError();
        CryptReleaseContext(hCryptProv, 0);	
        SetLastError(hr);
    }

CommonReturn:
	if (pPrivateKeyInfoStruct)
		SSFree(pPrivateKeyInfoStruct);
	if (pEncryptedPrivateKeyInfoStruct)
		SSFree(pEncryptedPrivateKeyInfoStruct);
	if (bEncodedPrivateKeyAlloced)
		SSFree(pbEncodedPrivateKey);
	return fResult;
	
}



////////
// old crusty API kept around for compat reasons
BOOL 
WINAPI 
CryptExportPKCS8(
    HCRYPTPROV  hCryptProv,         // in
    DWORD       dwKeySpec,          // in
    LPSTR       pszPrivateKeyObjId, // in
    DWORD       dwFlags,            // in
    void        *pvAuxInfo,         // in
    BYTE        *pbPrivateKeyBlob,  // out
    DWORD       *pcbPrivateKeyBlob  // in, out
    )
{
    CRYPT_PKCS8_EXPORT_PARAMS sExportParams;
    ZeroMemory(&sExportParams, sizeof(sExportParams));

    // copy args to pkcs8_export struct
    sExportParams.hCryptProv = hCryptProv;
    sExportParams.dwKeySpec = dwKeySpec;
    sExportParams.pszPrivateKeyObjId = pszPrivateKeyObjId;

    // these are not available to non-Ex function
    sExportParams.pEncryptPrivateKeyFunc = NULL;
    sExportParams.pVoidEncryptFunc = NULL;

    return CryptExportPKCS8Ex(
        &sExportParams,
        dwFlags,
        pvAuxInfo,
        pbPrivateKeyBlob,
        pcbPrivateKeyBlob);
}

//+-------------------------------------------------------------------------
// hCryptProv - specifies the provider to export from
// dwKeySpec - Identifies the public key to use from the provider's container. 
//             For example, AT_KEYEXCHANGE or AT_SIGNATURE.
// pszPrivateKeyObjId - Specifies the private key algorithm. If an installable 
//						function was not found for the pszPrivateKeyObjId, an 
//						attempt is made to export the key as a RSA Public Key 
//						(szOID_RSA_RSA).
// dwFlags - The flag values. Current supported values are:
//				DELETE_KEYSET - (NOT CURRENTLY SUPPORTED!!!!)
//				will delete key after export
// pvAuxInfo - This parameter is reserved for future use and should be set to 
//			   NULL in the interim.
// pbPrivateKeyBlob - A pointer to the private key blob.  It will be encoded
//					  as a PKCS8 PrivateKeyInfo.
// pcbPrivateKeyBlob - A pointer to a DWORD that contains the size, in bytes, 
//					   of the private key blob being exported.
//+-------------------------------------------------------------------------
BOOL 
WINAPI 
CryptExportPKCS8Ex(
    CRYPT_PKCS8_EXPORT_PARAMS* psExportParams, // in
    DWORD       dwFlags,            // in
    void        *pvAuxInfo,         // in
    BYTE        *pbPrivateKeyBlob,  // out
    DWORD       *pcbPrivateKeyBlob  // in, out	
)
{
    BOOL                    fResult = TRUE;
    void                    *pvFuncAddr;
    HCRYPTOIDFUNCADDR       hFuncAddr;
    CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo = NULL;
    DWORD                   cbPrivateKeyInfo = 0;
    DWORD                   cbEncoded = 0;

    // optional; used during encrypted export 
    PBYTE                   pbTmpKeyBlob = NULL;
    CRYPT_ENCRYPTED_PRIVATE_KEY_INFO sEncryptedKeyInfo; ZeroMemory(&sEncryptedKeyInfo, sizeof(sEncryptedKeyInfo));
	
    if (CryptGetOIDFunctionAddress(
            hExportPrivKeyFuncSet,
            X509_ASN_ENCODING,
            psExportParams->pszPrivateKeyObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        
		if (!((PFN_EXPORT_PRIV_KEY_FUNC) pvFuncAddr)(
				psExportParams->hCryptProv,
				psExportParams->dwKeySpec,
				psExportParams->pszPrivateKeyObjId, 

				dwFlags & ~GIVE_ME_DATA,    // sizeit
				pvAuxInfo,
				NULL,
				&cbPrivateKeyInfo
				))
			goto ErrorReturn;

		if (NULL == (pPrivateKeyInfo = (CRYPT_PRIVATE_KEY_INFO *) 
                        SSAlloc(cbPrivateKeyInfo)))
			goto ErrorReturn;

		if (!((PFN_EXPORT_PRIV_KEY_FUNC) pvFuncAddr)(

				psExportParams->hCryptProv,
				psExportParams->dwKeySpec,
				psExportParams->pszPrivateKeyObjId,

				dwFlags,        // maybe real data...
				pvAuxInfo,
				pPrivateKeyInfo,
				&cbPrivateKeyInfo
				))
			goto ErrorReturn;

        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } 
	else {	// if (CryptGetOIDFunctionAddress())
        SetLastError(ERROR_UNSUPPORTED_TYPE);
        return FALSE;
    }
	
	// encode the private key info struct 
	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			PKCS_PRIVATE_KEY_INFO,
			pPrivateKeyInfo,
			NULL,
			&cbEncoded))
		goto ErrorReturn;

    if (NULL == psExportParams->pEncryptPrivateKeyFunc) 
    {
        // no encryption; this is output buffer

        // check to see if the caller specified a buffer and has enough space
	    if ((pbPrivateKeyBlob != NULL) && (*pcbPrivateKeyBlob >= cbEncoded)) {
		    if (!CryptEncodeObject(
				    X509_ASN_ENCODING,
				    PKCS_PRIVATE_KEY_INFO,
				    pPrivateKeyInfo,
				    pbPrivateKeyBlob,
				    pcbPrivateKeyBlob))
			    goto ErrorReturn;
	    }
	    else {
		    *pcbPrivateKeyBlob = cbEncoded;
		    
		    if (pbPrivateKeyBlob != NULL) {
			    SetLastError((DWORD) ERROR_MORE_DATA);
			    goto ErrorReturn;
		    }	
	    }
    }
    else
    {
        // we do want to encrypt!!

        // always encode: use tmp alloc
        pbTmpKeyBlob = (PBYTE)SSAlloc(cbEncoded);
        if (pbTmpKeyBlob == NULL)
            goto ErrorReturn;
        DWORD cbTmpKeyBlob = cbEncoded;

        // NOW add optional encryption and encode as ENCR_PRIV_KEY_INFO
        CRYPT_DATA_BLOB sClearTextKey = { cbTmpKeyBlob, pbTmpKeyBlob};

        // do inner encode
		if (!CryptEncodeObject(
				X509_ASN_ENCODING,
				PKCS_PRIVATE_KEY_INFO,
				pPrivateKeyInfo,
				pbTmpKeyBlob,
				&cbTmpKeyBlob))
			goto ErrorReturn;

        // exported the key; encoded as PRIVATE_KEY_INFO.
        if (!psExportParams->pEncryptPrivateKeyFunc(
                            &sEncryptedKeyInfo.EncryptionAlgorithm,     // out
                            &sClearTextKey,                             // in
                            NULL,                                       // opt
                            &sEncryptedKeyInfo.EncryptedPrivateKey.cbData,  // out
                            psExportParams->pVoidEncryptFunc))          
            goto ErrorReturn;

		if (NULL == (sEncryptedKeyInfo.EncryptedPrivateKey.pbData = (BYTE*) SSAlloc(sEncryptedKeyInfo.EncryptedPrivateKey.cbData)))
			goto ErrorReturn;

        if (dwFlags & GIVE_ME_DATA)
        {
            if (!psExportParams->pEncryptPrivateKeyFunc(
                                &sEncryptedKeyInfo.EncryptionAlgorithm,         // out
                                &sClearTextKey,                                 // in
                                sEncryptedKeyInfo.EncryptedPrivateKey.pbData,   // opt
                                &sEncryptedKeyInfo.EncryptedPrivateKey.cbData,  // out
                                psExportParams->pVoidEncryptFunc))
                goto ErrorReturn;
        }
        else
        {
            // fill in phony encr key
            FillMemory(sEncryptedKeyInfo.EncryptedPrivateKey.pbData, sEncryptedKeyInfo.EncryptedPrivateKey.cbData, 0x69);
        }

        // item is now encrypted; now encode

	    // encode the private key info struct 
	    if (!CryptEncodeObject(
			    X509_ASN_ENCODING,
			    PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
			    &sEncryptedKeyInfo,
			    NULL,
			    &cbEncoded))
		    goto ErrorReturn;


        // check to see if the caller specified a buffer and has enough space
	    if ((pbPrivateKeyBlob != NULL) && (*pcbPrivateKeyBlob >= cbEncoded)) {
		    if (!CryptEncodeObject(
				    X509_ASN_ENCODING,
				    PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
				    &sEncryptedKeyInfo,
				    pbPrivateKeyBlob,
				    pcbPrivateKeyBlob))
			    goto ErrorReturn;
	    }
	    else {
		    *pcbPrivateKeyBlob = cbEncoded;
		    
		    if (pbPrivateKeyBlob != NULL) {
			    SetLastError((DWORD) ERROR_MORE_DATA);
			    goto ErrorReturn;
		    }	
	    }
    }

    goto CommonReturn;

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	if (pPrivateKeyInfo)
		SSFree(pPrivateKeyInfo);

    if (pbTmpKeyBlob)
        SSFree(pbTmpKeyBlob);

    if (sEncryptedKeyInfo.EncryptedPrivateKey.pbData)
        SSFree(sEncryptedKeyInfo.EncryptedPrivateKey.pbData);

    if (sEncryptedKeyInfo.EncryptionAlgorithm.Parameters.pbData)
        SSFree(sEncryptedKeyInfo.EncryptionAlgorithm.Parameters.pbData);

	return fResult;	
}

static LONG counter = 0;

// hack function to create a mock RSA private key blob based only on size
BYTE * AllocFakeRSAPrivateKey(DWORD cb)
{
    BLOBHEADER  *pBlobHeader;
    RSAPUBKEY   *pKey;
    BYTE        *pByte;
    DWORD       dwJumpSize;

    pBlobHeader = (BLOBHEADER *) SSAlloc(cb);
    if (pBlobHeader == NULL)
        return NULL;

    memset(pBlobHeader, 0, cb);

    pBlobHeader->bType = PRIVATEKEYBLOB;
    pBlobHeader->bVersion = CUR_BLOB_VERSION;
    pBlobHeader->reserved = 0;
    pBlobHeader->aiKeyAlg = CALG_RSA_SIGN;

    pKey = (RSAPUBKEY *) (((BYTE*) pBlobHeader) + sizeof(BLOBHEADER));
    pKey->magic = 0x32415352;
    pKey->bitlen = ((cb - sizeof(BLOBHEADER) - sizeof(RSAPUBKEY)) / 9) * 2 * 8;
    pKey->pubexp = 65537;

    dwJumpSize = (cb - sizeof(BLOBHEADER) - sizeof(RSAPUBKEY)) / 9;
    pByte = ((BYTE *) pBlobHeader) + sizeof(BLOBHEADER) + sizeof(RSAPUBKEY);
    
    // put some bogus data at the start of the key so 
	// that we know will be unique for each key so that 
	// they look different durring a comparison
	InterlockedIncrement(&counter);
	*((LONG *) pByte) = counter;

    // most significant byte of modulus
    pByte += (dwJumpSize * 2) - 1;
    *pByte = 0x80;

    // most significant byte of prime1
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of prime2
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of exponent1
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of exponent2
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of coefficient
    pByte += dwJumpSize;
    *pByte = 0x80;

    // most significant byte of privateExponent
    pByte += dwJumpSize * 2;
    *pByte = 0x80;

    return ((BYTE *)pBlobHeader);
}

static BOOL WINAPI ExportRSAPrivateKeyInfo(
	HCRYPTPROV				hCryptProv,			// in
	DWORD					dwKeySpec,			// in
	LPSTR					pszPrivateKeyObjId,	// in
	DWORD					dwFlags,			// in
    void					*pvAuxInfo,			// in
    CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,	// out
    DWORD					*pcbPrivateKeyInfo	// in, out	
	)
{
	BOOL			fResult = TRUE;
	HCRYPTKEY		hCryptKey = NULL;
	BYTE			*pKeyBlob = NULL;
	DWORD			cbKeyBlob = 0;
	BYTE			*pEncodedKeyBlob = NULL;
	DWORD			cbEncodedKeyBlob = 0;
	BYTE			*pKeyUsage = NULL;
	DWORD			cbKeyUsage = 0;
	DWORD			dwSize = 0;
	CRYPT_BIT_BLOB	CryptBitBlob;
	BYTE			KeyUsageByte = 0;
	BYTE			*pbCurrentLocation = NULL;

	// get a handle to the keyset to export
	if (!CryptGetUserKey(
			hCryptProv,
			dwKeySpec,
			&hCryptKey))
		goto ErrorReturn;

	// export the key set to a CAPI blob
	if (!CryptExportKey(
			hCryptKey,
			0,
			PRIVATEKEYBLOB,
			0,
			NULL,
			&cbKeyBlob)) 
		goto ErrorReturn;

	// make sure the caller REALLY wants the key at this point
    if ((dwFlags & PFX_MODE) && !(dwFlags & GIVE_ME_DATA))
    {
        if (NULL == (pKeyBlob = AllocFakeRSAPrivateKey(cbKeyBlob)))
		    goto ErrorReturn;
    }
    // if not in PFX export mode or we really want the key then just do normal processing
    else
    {
        if (NULL == (pKeyBlob = (BYTE *) SSAlloc(cbKeyBlob)))
		    goto ErrorReturn;
	    
	    if (!CryptExportKey(
			    hCryptKey,
			    0,
			    PRIVATEKEYBLOB,
			    0,
			    pKeyBlob,
			    &cbKeyBlob))
		    goto ErrorReturn;
    }

	// encode the key blob to a RSA private key
	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			PKCS_RSA_PRIVATE_KEY,
			pKeyBlob,
			NULL,
			&cbEncodedKeyBlob))
		goto ErrorReturn;

	if (NULL == (pEncodedKeyBlob = (BYTE *) SSAlloc(cbEncodedKeyBlob)))
		goto ErrorReturn;
		
	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			PKCS_RSA_PRIVATE_KEY,
			pKeyBlob,
			pEncodedKeyBlob,
			&cbEncodedKeyBlob))
		goto ErrorReturn;
	
	// encode the KEY_USAGE attribute
	CryptBitBlob.cbData = 1;
	CryptBitBlob.pbData = &KeyUsageByte;
	CryptBitBlob.cUnusedBits = 0;
	if (((BLOBHEADER *) pKeyBlob)->aiKeyAlg == CALG_RSA_SIGN) 
		KeyUsageByte = CERT_DIGITAL_SIGNATURE_KEY_USAGE; 
	else if (((BLOBHEADER *) pKeyBlob)->aiKeyAlg == CALG_RSA_KEYX) 
		KeyUsageByte = CERT_DATA_ENCIPHERMENT_KEY_USAGE;
	else {
		goto ErrorReturn;
	}

	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_BITS,
			(void *) &CryptBitBlob,
			NULL,
			&cbKeyUsage))
		goto ErrorReturn;

	if (NULL == (pKeyUsage = (BYTE *) SSAlloc(cbKeyUsage)))
		goto ErrorReturn;

	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_BITS,
			(void *) &CryptBitBlob,
			pKeyUsage,
			&cbKeyUsage))
		goto ErrorReturn;

	// we can now calculate the size needed
	dwSize =	sizeof(CRYPT_PRIVATE_KEY_INFO) +	// main private key info struct
 INFO_LEN_ALIGN(sizeof(szOID_RSA_RSA)) +	        // size of the RSA algorithm identifier string
 INFO_LEN_ALIGN(cbEncodedKeyBlob) +			        // buffer that holds encoded RSA private key
				sizeof(CRYPT_ATTRIBUTES) +	        // struct for private key attributes
				sizeof(CRYPT_ATTRIBUTE) +	        // struct for the one attribute being set, KEY_USAGE
 INFO_LEN_ALIGN(sizeof(szOID_KEY_USAGE)) +	        // size of attribute OID for key usage
				sizeof(CRYPT_ATTR_BLOB)	+	        // struct for values in attribute
				cbKeyUsage;					        // size of buffer for encoded attribute

	// check to see if the caller passed in a buffer, and enough space
	if (pPrivateKeyInfo == NULL)
		goto CommonReturn;
	else if (*pcbPrivateKeyInfo < dwSize) {
		SetLastError((DWORD) ERROR_MORE_DATA);
		goto ErrorReturn;
	}

	// everything is OK so copy all the information to the caller's buffer
	pbCurrentLocation = ((BYTE *) pPrivateKeyInfo) + sizeof(CRYPT_PRIVATE_KEY_INFO);
	
	pPrivateKeyInfo->Version = 0;
	
	pPrivateKeyInfo->Algorithm.pszObjId = (LPSTR) pbCurrentLocation;
	memcpy(pbCurrentLocation, szOID_RSA_RSA, sizeof(szOID_RSA_RSA));
	pbCurrentLocation += INFO_LEN_ALIGN(sizeof(szOID_RSA_RSA));
	pPrivateKeyInfo->Algorithm.Parameters.cbData = 0;	// no parameters for RSA
	pPrivateKeyInfo->Algorithm.Parameters.pbData = NULL;// no parameters for RSA

	pPrivateKeyInfo->PrivateKey.cbData = cbEncodedKeyBlob;
	pPrivateKeyInfo->PrivateKey.pbData = pbCurrentLocation;
	memcpy(pbCurrentLocation, pEncodedKeyBlob, cbEncodedKeyBlob);
	pbCurrentLocation += INFO_LEN_ALIGN(cbEncodedKeyBlob);

	pPrivateKeyInfo->pAttributes = (PCRYPT_ATTRIBUTES) pbCurrentLocation;
	pbCurrentLocation += sizeof(CRYPT_ATTRIBUTES);
	pPrivateKeyInfo->pAttributes->cAttr = 1;	// the only attribute right now is KEY_USAGE
	pPrivateKeyInfo->pAttributes->rgAttr = (PCRYPT_ATTRIBUTE) pbCurrentLocation;
	pbCurrentLocation += sizeof(CRYPT_ATTRIBUTE);
	pPrivateKeyInfo->pAttributes->rgAttr[0].pszObjId = (LPSTR) pbCurrentLocation;
	memcpy(pbCurrentLocation, szOID_KEY_USAGE, sizeof(szOID_KEY_USAGE));
	pbCurrentLocation += INFO_LEN_ALIGN(sizeof(szOID_KEY_USAGE));
	pPrivateKeyInfo->pAttributes->rgAttr[0].cValue = 1; 
	pPrivateKeyInfo->pAttributes->rgAttr[0].rgValue = (PCRYPT_ATTR_BLOB) pbCurrentLocation;
	pbCurrentLocation += sizeof(CRYPT_ATTR_BLOB);
	pPrivateKeyInfo->pAttributes->rgAttr[0].rgValue[0].cbData = cbKeyUsage;
	pPrivateKeyInfo->pAttributes->rgAttr[0].rgValue[0].pbData = pbCurrentLocation;
	memcpy(pbCurrentLocation, pKeyUsage, cbKeyUsage);
	
	goto CommonReturn;

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	*pcbPrivateKeyInfo = dwSize;

    if (hCryptKey)
    {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(hCryptKey);
        SetLastError(dwErr);
    }
	if (pKeyBlob)
		SSFree(pKeyBlob);
	if (pEncodedKeyBlob)
		SSFree(pEncodedKeyBlob);
	if (pKeyUsage)
		SSFree(pKeyUsage);
	return fResult;
}


static DWORD ResolveKeySpec(
	PCRYPT_ATTRIBUTES   pCryptAttributes)
{
	DWORD			i = 0;
	DWORD			dwKeySpec = 0;
	DWORD			cbAttribute = 0;
	CRYPT_BIT_BLOB	*pAttribute = NULL;

	if (pCryptAttributes != NULL)
		while (i < pCryptAttributes->cAttr) {
			if (lstrcmp(pCryptAttributes->rgAttr[i].pszObjId, szOID_KEY_USAGE) == 0) { 
				
				if (!CryptDecodeObject(
						X509_ASN_ENCODING,
						X509_BITS,
						pCryptAttributes->rgAttr[i].rgValue->pbData,
						pCryptAttributes->rgAttr[i].rgValue->cbData,
						0,
						NULL,
						&cbAttribute
						)) {
					i++;
					continue;
				}
				
				if (NULL == (pAttribute = (CRYPT_BIT_BLOB *) SSAlloc(cbAttribute))) 
                {
					i++;
					continue;
				}
			
				if (!CryptDecodeObject(
						X509_ASN_ENCODING,
						X509_BITS,
						pCryptAttributes->rgAttr[i].rgValue->pbData,
						pCryptAttributes->rgAttr[i].rgValue->cbData,
						0,
						pAttribute,
						&cbAttribute
						)) {
					i++;
					SSFree(pAttribute);
					continue;
				}
									
				if ((pAttribute->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE) ||
					(pAttribute->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE)) {
					dwKeySpec = AT_KEYEXCHANGE;
					goto CommonReturn;
				}
				else if ((pAttribute->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE) ||
						(pAttribute->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE) ||
						(pAttribute->pbData[0] & CERT_CRL_SIGN_KEY_USAGE)) {
					dwKeySpec = AT_SIGNATURE;
					goto CommonReturn;
				}
			} // if (lstrcmp(pCryptAttributes->rgAttr[i].pszObjId, szOID_KEY_USAGE) == 0) 
			
			i++;
		} // while (i < pCryptAttributes->cAttr)

//ErrorReturn:
CommonReturn:
	if (pAttribute)
		SSFree(pAttribute);
	return dwKeySpec;
}


static BOOL WINAPI ImportRSAPrivateKeyInfo(
	HCRYPTPROV					hCryptProv,			// in
	CRYPT_PRIVATE_KEY_INFO		*pPrivateKeyInfo,	// in
	DWORD						dwFlags,			// in, optional
	void						*pvAuxInfo			// in, optional
	)
{
	BOOL		fResult = TRUE;
	DWORD		cbRSAPrivateKey = 0;
	BYTE		*pbRSAPrivateKey = NULL;
	HCRYPTKEY	hCryptKey = NULL;
	DWORD		dwKeySpec = 0;

	// decode the rsa der-encoded keyblob into a CAPI type keyblob
	if (!CryptDecodeObject(X509_ASN_ENCODING,
						PKCS_RSA_PRIVATE_KEY,
						pPrivateKeyInfo->PrivateKey.pbData,
						pPrivateKeyInfo->PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						NULL,
						&cbRSAPrivateKey))
		goto ErrorReturn;

	if (NULL == (pbRSAPrivateKey = (BYTE *) SSAlloc(cbRSAPrivateKey)))
		goto ErrorReturn;

	if (!CryptDecodeObject(X509_ASN_ENCODING,
						PKCS_RSA_PRIVATE_KEY,
						pPrivateKeyInfo->PrivateKey.pbData,
						pPrivateKeyInfo->PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						pbRSAPrivateKey,
						&cbRSAPrivateKey))
		goto ErrorReturn;
	
	// figure out what keyspec to use and manually set the algid in the keyblob accordingly
	dwKeySpec = ResolveKeySpec(pPrivateKeyInfo->pAttributes);
	if ((dwKeySpec == AT_KEYEXCHANGE) || (dwKeySpec == 0)) 
		((BLOBHEADER *) pbRSAPrivateKey)->aiKeyAlg = CALG_RSA_KEYX;
	else
		((BLOBHEADER *) pbRSAPrivateKey)->aiKeyAlg = CALG_RSA_SIGN;

	// import this thing
	if (!CryptImportKey(hCryptProv,
			pbRSAPrivateKey,
			cbRSAPrivateKey,
			0,
			dwFlags & (CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED),    // mask the flags that are used
			&hCryptKey))                                            // during the CryptImportKey
		goto ErrorReturn;

	goto CommonReturn;

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	if (pbRSAPrivateKey)
		SSFree(pbRSAPrivateKey);
	if (hCryptKey)
		CryptDestroyKey(hCryptKey);

	return fResult;

}

#ifndef DSS2
#define DSS2 ((DWORD)'D'+((DWORD)'S'<<8)+((DWORD)'S'<<16)+((DWORD)'2'<<24))
#endif

#ifndef DSS_Q_LEN
#define DSS_Q_LEN   20
#endif


// hack function to create a mock RSA private key blob based only on size
BYTE * AllocFakeDSSPrivateKey(DWORD cb)
{
    BLOBHEADER  *pBlobHeader;
    DSSPUBKEY   *pCspPubKey = NULL;
    BYTE        *pbKeyBlob;
    BYTE        *pbKey;
    DWORD       cbKey;
    DSSSEED     *pCspSeed = NULL;

    pBlobHeader = (BLOBHEADER *) SSAlloc(cb);
    if (pBlobHeader == NULL)
        return NULL;

    memset(pBlobHeader, 0, cb);

    pbKeyBlob = (BYTE *) pBlobHeader;
    pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));
    pbKey = pbKeyBlob + sizeof(BLOBHEADER) + sizeof(DSSPUBKEY);

    // BLOBHEADER
    pBlobHeader->bType = PRIVATEKEYBLOB;
    pBlobHeader->bVersion = CUR_BLOB_VERSION;
    pBlobHeader->reserved = 0;
    pBlobHeader->aiKeyAlg = CALG_DSS_SIGN;

    // DSSPUBKEY
    pCspPubKey->magic = DSS2;
    cbKey = (cb - sizeof(BLOBHEADER) - sizeof(DSSPUBKEY) - (2 * DSS_Q_LEN) - sizeof(DSSSEED)) / 2;
    pCspPubKey->bitlen = cbKey * 8;

    // put some bogus data at the start of the key so 
	// that we know will be unique for each key so that 
	// they look different durring a comparison
	InterlockedIncrement(&counter);
	
    // rgbP[cbKey]
    memset(pbKey, counter, cbKey);
    pbKey += cbKey;
    *(pbKey-1) = 0x80;

    // rgbQ[20]
    memset(pbKey, counter, DSS_Q_LEN);
    pbKey += DSS_Q_LEN;
    *(pbKey-1) = 0x80;
   
    // rgbG[cbKey]
    memset(pbKey, counter, cbKey);
    pbKey += cbKey;
    *(pbKey-1) = 0x80;

    // rgbX[20]
    memset(pbKey, counter, DSS_Q_LEN);
    pbKey += DSS_Q_LEN;
    *(pbKey-1) = 0x80;
    
    // DSSSEED: set counter to 0xFFFFFFFF to indicate not available
    pCspSeed = (DSSSEED *) pbKey;
    memset(&pCspSeed->counter, 0xFF, sizeof(pCspSeed->counter));

    return ((BYTE *)pBlobHeader);
}

static BOOL WINAPI ExportDSSPrivateKeyInfo(
	HCRYPTPROV				hCryptProv,			// in
	DWORD					dwKeySpec,			// in
	LPSTR					pszPrivateKeyObjId,	// in
	DWORD					dwFlags,			// in
    void					*pvAuxInfo,			// in
    CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,	// out
    DWORD					*pcbPrivateKeyInfo	// in, out	
	)
{
    BOOL			    fResult = TRUE;
	HCRYPTKEY		    hCryptKey = NULL;
	BYTE			    *pbKeyBlob = NULL;
	DWORD			    cbKeyBlob = 0;
	BYTE			    *pbEncodedPrivateKeyBlob = NULL;
	DWORD			    cbEncodedPrivateKeyBlob = 0;
    BYTE                *pbEncodedParameters = NULL;
    DWORD               cbEncodedParameters = 0;
    CRYPT_INTEGER_BLOB  PrivateKeyBlob;
    CERT_DSS_PARAMETERS DssParameters;
    DWORD               cbKey;
    DSSPUBKEY           *pCspPubKey = NULL;
    BYTE                *pbBytes;
    DWORD			    dwSize = 0;
    BYTE                *pbCurrentLocation;
	
	// get a handle to the keyset to export
	if (!CryptGetUserKey(
			hCryptProv,
			dwKeySpec,
			&hCryptKey))
		goto ErrorReturn;

	// export the key set to a CAPI blob
	if (!CryptExportKey(
			hCryptKey,
			0,
			PRIVATEKEYBLOB,
			0,
			NULL,
			&cbKeyBlob)) 
		goto ErrorReturn;

	// make sure the caller REALLY wants the key at this point
    if ((dwFlags & PFX_MODE) && !(dwFlags & GIVE_ME_DATA))
    {
        if (NULL == (pbKeyBlob = AllocFakeDSSPrivateKey(cbKeyBlob)))
		    goto ErrorReturn;
    }
    // if not in PFX export mode or we really want the key then just do normal processing
    else
    {
        if (NULL == (pbKeyBlob = (BYTE *) SSAlloc(cbKeyBlob)))
		    goto ErrorReturn;
	    
	    if (!CryptExportKey(
			    hCryptKey,
			    0,
			    PRIVATEKEYBLOB,
			    0,
			    pbKeyBlob,
			    &cbKeyBlob))
		    goto ErrorReturn;
    }

	pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));
    pbBytes = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DSSPUBKEY);
    cbKey = pCspPubKey->bitlen / 8;

    // encode the DSS paramaters
    memset(&DssParameters, 0, sizeof(CERT_DSS_PARAMETERS));
    DssParameters.p.cbData = cbKey;
    DssParameters.p.pbData = pbBytes;
    pbBytes += cbKey;
    DssParameters.q.cbData = DSS_Q_LEN;
    DssParameters.q.pbData = pbBytes;
    pbBytes += DSS_Q_LEN;
    DssParameters.g.cbData = cbKey;
    DssParameters.g.pbData = pbBytes;
    pbBytes += cbKey;

    if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_DSS_PARAMETERS,
			&DssParameters,
			NULL,
			&cbEncodedParameters))
		goto ErrorReturn;

    if (NULL == (pbEncodedParameters = (BYTE *) SSAlloc(cbEncodedParameters)))
		goto ErrorReturn;

    if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_DSS_PARAMETERS,
			&DssParameters,
			pbEncodedParameters,
			&cbEncodedParameters))
		goto ErrorReturn;

	// encode the key DSS private key
    PrivateKeyBlob.cbData = DSS_Q_LEN;
    PrivateKeyBlob.pbData = pbBytes;

	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_MULTI_BYTE_INTEGER,
			&PrivateKeyBlob,
			NULL,
			&cbEncodedPrivateKeyBlob))
		goto ErrorReturn;

	if (NULL == (pbEncodedPrivateKeyBlob = (BYTE *) SSAlloc(cbEncodedPrivateKeyBlob)))
		goto ErrorReturn;
		
	if (!CryptEncodeObject(
			X509_ASN_ENCODING,
			X509_MULTI_BYTE_INTEGER,
			&PrivateKeyBlob,
			pbEncodedPrivateKeyBlob,
			&cbEncodedPrivateKeyBlob))
		goto ErrorReturn;
	
    
    
    
	// we can now calculate the size needed
	dwSize =	sizeof(CRYPT_PRIVATE_KEY_INFO) +	// main private key info struct
				sizeof(szOID_X957_DSA) +		    // size of the DSA algorithm identifier string
                cbEncodedParameters +               // size of the DSA parameters
				cbEncodedPrivateKeyBlob;			// buffer that holds encoded DSS private key
				

	// check to see if the caller passed in a buffer, and enough space
	if (pPrivateKeyInfo == NULL)
		goto CommonReturn;
	else if (*pcbPrivateKeyInfo < dwSize) {
		SetLastError((DWORD) ERROR_MORE_DATA);
		goto ErrorReturn;
	}

	// everything is OK so copy all the information to the caller's buffer
	pbCurrentLocation = ((BYTE *) pPrivateKeyInfo) + sizeof(CRYPT_PRIVATE_KEY_INFO);
	
	pPrivateKeyInfo->Version = 0;
	pPrivateKeyInfo->Algorithm.pszObjId = (LPSTR) pbCurrentLocation;
	memcpy(pbCurrentLocation, szOID_X957_DSA, sizeof(szOID_X957_DSA));
	pbCurrentLocation += sizeof(szOID_X957_DSA);
	pPrivateKeyInfo->Algorithm.Parameters.cbData = cbEncodedParameters;	
	pPrivateKeyInfo->Algorithm.Parameters.pbData = pbCurrentLocation;
    memcpy(pbCurrentLocation, pbEncodedParameters, cbEncodedParameters);
    pbCurrentLocation += cbEncodedParameters;

	pPrivateKeyInfo->PrivateKey.cbData = cbEncodedPrivateKeyBlob;
	pPrivateKeyInfo->PrivateKey.pbData = pbCurrentLocation;
	memcpy(pbCurrentLocation, pbEncodedPrivateKeyBlob, cbEncodedPrivateKeyBlob);
	pbCurrentLocation += cbEncodedPrivateKeyBlob;

	pPrivateKeyInfo->pAttributes = NULL;
	
	goto CommonReturn;

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	*pcbPrivateKeyInfo = dwSize;

    if (hCryptKey)
    {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(hCryptKey);
        SetLastError(dwErr);
    }
	if (pbKeyBlob)
		SSFree(pbKeyBlob);
    if (pbEncodedParameters)
		SSFree(pbEncodedParameters);
	if (pbEncodedPrivateKeyBlob)
		SSFree(pbEncodedPrivateKeyBlob);
	

	return fResult;
}

static BOOL WINAPI ImportDSSPrivateKeyInfo(
	HCRYPTPROV					hCryptProv,			// in
	CRYPT_PRIVATE_KEY_INFO		*pPrivateKeyInfo,	// in
	DWORD						dwFlags,			// in, optional
	void						*pvAuxInfo			// in, optional
	)
{
	BOOL		            fResult = TRUE;
	DWORD		            cbDSSPrivateKey = 0;
	CRYPT_DATA_BLOB		    *pbDSSPrivateKey = NULL;
	HCRYPTKEY	            hCryptKey = NULL;
	DWORD		            dwKeySpec = 0;
    DWORD                   cbParameters = 0;
    PCERT_DSS_PARAMETERS    pDssParameters = NULL;
    BLOBHEADER              *pPrivateKeyBlob = NULL;
    DWORD                   cbPrivateKeyStruc = 0;
    DSSPUBKEY               *pCspPubKey = NULL;
    DSSSEED                 *pCspSeed = NULL;
    BYTE                    *pbKey = NULL;
    BYTE                    *pbKeyBlob = NULL;
    DWORD                   cb;
    DWORD                   cbKey;

	// decode the DSS private key
	if (!CryptDecodeObject(X509_ASN_ENCODING,
						X509_MULTI_BYTE_UINT,
						pPrivateKeyInfo->PrivateKey.pbData,
						pPrivateKeyInfo->PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						NULL,
						&cbDSSPrivateKey))
		goto ErrorReturn;

	if (NULL == (pbDSSPrivateKey = (CRYPT_DATA_BLOB *) SSAlloc(cbDSSPrivateKey)))
    {
		SetLastError(E_OUTOFMEMORY);
        goto ErrorReturn;
    }

	if (!CryptDecodeObject(X509_ASN_ENCODING,
						X509_MULTI_BYTE_UINT,
						pPrivateKeyInfo->PrivateKey.pbData,
						pPrivateKeyInfo->PrivateKey.cbData,
						CRYPT_DECODE_NOCOPY_FLAG,
						pbDSSPrivateKey,
						&cbDSSPrivateKey))
		goto ErrorReturn;

    
    // decode the DSS parameters
    if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_DSS_PARAMETERS,
			pPrivateKeyInfo->Algorithm.Parameters.pbData,
			pPrivateKeyInfo->Algorithm.Parameters.cbData,
			0,
			NULL,
			&cbParameters
			)) 
        goto ErrorReturn;
	
	if (NULL == (pDssParameters = (PCERT_DSS_PARAMETERS) SSAlloc(cbParameters))) 
    {
        SetLastError(E_OUTOFMEMORY);
        goto ErrorReturn;
    }

	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_DSS_PARAMETERS,
			pPrivateKeyInfo->Algorithm.Parameters.pbData,
			pPrivateKeyInfo->Algorithm.Parameters.cbData,
			0,
			pDssParameters,
			&cbParameters
			)) 
        goto ErrorReturn;


    // The CAPI private key representation consists of the following sequence:
    //  - BLOBHEADER
    //  - DSSPUBKEY
    //  - rgbP[cbKey]
    //  - rgbQ[20]
    //  - rgbG[cbKey]
    //  - rgbX[20]
    //  - DSSSEED

    cbKey = pDssParameters->p.cbData;
    if (0 == cbKey)
        goto ErrorInvalidKey;

    cbPrivateKeyStruc = sizeof(BLOBHEADER) + sizeof(DSSPUBKEY) +
        cbKey + DSS_Q_LEN + cbKey + DSS_Q_LEN + sizeof(DSSSEED);

    if (NULL == (pPrivateKeyBlob = (BLOBHEADER *) SSAlloc(cbPrivateKeyStruc))) 
    {
        SetLastError(E_OUTOFMEMORY);
        goto ErrorReturn;
    }
	
    pbKeyBlob = (BYTE *) pPrivateKeyBlob;
    pCspPubKey = (DSSPUBKEY *) (pbKeyBlob + sizeof(BLOBHEADER));
    pbKey = pbKeyBlob + sizeof(BLOBHEADER) + sizeof(DSSPUBKEY);

    // NOTE, the length of G can be less than the length of P.
    // The CSP requires G to be padded out with 0x00 bytes if it
    // is less and in little endian form

    // BLOBHEADER
    pPrivateKeyBlob->bType = PRIVATEKEYBLOB;
    pPrivateKeyBlob->bVersion = CUR_BLOB_VERSION;
    pPrivateKeyBlob->reserved = 0;
   	pPrivateKeyBlob->aiKeyAlg = CALG_DSS_SIGN;

    // DSSPUBKEY
    pCspPubKey->magic = DSS2;
    pCspPubKey->bitlen = cbKey * 8;

    // rgbP[cbKey]
    memcpy(pbKey, pDssParameters->p.pbData, cbKey);
    pbKey += cbKey;

    // rgbQ[20]
    cb = pDssParameters->q.cbData;
    if (0 == cb || cb > DSS_Q_LEN)
        goto ErrorInvalidKey;
    memcpy(pbKey, pDssParameters->q.pbData, cb);
    if (DSS_Q_LEN > cb)
        memset(pbKey + cb, 0, DSS_Q_LEN - cb);
    pbKey += DSS_Q_LEN;

    // rgbG[cbKey]
    cb = pDssParameters->g.cbData;
    if (0 == cb || cb > cbKey)
        goto ErrorInvalidKey;
    memcpy(pbKey, pDssParameters->g.pbData, cb);
    if (cbKey > cb)
        memset(pbKey + cb, 0, cbKey - cb);
    pbKey += cbKey;

    // rgbX[20]
    cb = pbDSSPrivateKey->cbData;
    if (0 == cb || cb > DSS_Q_LEN)
        goto ErrorInvalidKey;
    memcpy(pbKey, pbDSSPrivateKey->pbData, cb);
    if (DSS_Q_LEN > cb)
        memset(pbKey + cb, 0, DSS_Q_LEN - cb);
    pbKey += DSS_Q_LEN;

    // DSSSEED: set counter to 0xFFFFFFFF to indicate not available
    pCspSeed = (DSSSEED *) pbKey;
    memset(&pCspSeed->counter, 0xFF, sizeof(pCspSeed->counter));


	// import this thing
	if (!CryptImportKey(hCryptProv,
			(BYTE *)pPrivateKeyBlob,
			cbPrivateKeyStruc,
			0,
			dwFlags & (CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED),    // mask the flags that are used
			&hCryptKey))                                            // during the CryptImportKey
    {
	    DWORD dw = GetLastError();
        goto ErrorReturn;
    }

	goto CommonReturn;

ErrorInvalidKey:
    SetLastError(E_INVALIDARG);

ErrorReturn:
	fResult = FALSE;

CommonReturn:
	if (pbDSSPrivateKey)
		SSFree(pbDSSPrivateKey);
    if (pDssParameters)
		SSFree(pDssParameters);
    if (pPrivateKeyBlob)
        SSFree(pPrivateKeyBlob);
	if (hCryptKey)
		CryptDestroyKey(hCryptKey);

	return fResult;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\nscpfmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       nscp.cpp
//
//  Contents:   PFX: Personal Information Exchange.
//
//  Functions:
//
//  History:    02-Jun-97    mattt    created
//
//--------------------------------------------------------------------------
#include "global.hxx"

#include <wincrypt.h>
#include <sha.h>
#include "des.h"
#include "tripldes.h"
#include "modes.h"

#define _PFX_SOURCE_
#include "dbgdef.h"

extern "C" {
    #include "pfxnscp.h"    // ASN1 generated
}

#include "pfxhelp.h"
#include "pfxcrypt.h"
#include "pfxcmn.h"

///////////////////////////////////////////////////////////////////////////////////
// OLD PKCS #12 Object Identifiers - these are for supporting the old netscape file format
#define OLD_szOID_PKCS_12_OIDs                          szOID_PKCS_12               ".5"    // 1.2.840.113549.1.12.5
#define OLD_szOID_PKCS_12_PbeIds                        OLD_szOID_PKCS_12_OIDs      ".1"
#define OLD_szOID_PKCS_12_pbeWithSHA1And128BitRC4       OLD_szOID_PKCS_12_PbeIds    ".1"
#define OLD_szOID_PKCS_12_pbeWithSHA1And40BitRC4        OLD_szOID_PKCS_12_PbeIds    ".2"
#define OLD_szOID_PKCS_12_pbeWithSHA1AndTripleDES       OLD_szOID_PKCS_12_PbeIds    ".3"
#define OLD_szOID_PKCS_12_pbeWithSHA1And128BitRC2       OLD_szOID_PKCS_12_PbeIds    ".4"
#define OLD_szOID_PKCS_12_pbeWithSHA1And40BitRC2        OLD_szOID_PKCS_12_PbeIds    ".5"

#define OLD_szOID_PKCS_12_EnvelopingIds                 OLD_szOID_PKCS_12_OIDs          ".2"
#define OLD_szOID_PKCS_12_rsaEncryptionWith128BitRC4    OLD_szOID_PKCS_12_EnvelopingIds ".1"
#define OLD_szOID_PKCS_12_rsaEncryptionWith40BitRC4     OLD_szOID_PKCS_12_EnvelopingIds ".2"
#define OLD_szOID_PKCS_12_rsaEncryptionWithTripleDES    OLD_szOID_PKCS_12_EnvelopingIds ".3"

#define OLD_szOID_PKCS_12_SignatureIds                  OLD_szOID_PKCS_12_OIDs          ".3"
#define OLD_szOID_PKCS_12_rsaSignatureWithSHA1Digest    OLD_szOID_PKCS_12_SignatureIds  ".1"

#define OLD_szOID_PKCS_12_ModeIDs               OLD_szOID_PKCS_12               ".1"    // 1.2.840.113549.1.12.1
#define OLD_szOID_PKCS_12_PubKeyMode            OLD_szOID_PKCS_12_ModeIDs       ".1"    // 1.2.840.113549.1.12.1.1
#define OLD_szOID_PKCS_12_PasswdMode            OLD_szOID_PKCS_12_ModeIDs       ".2"    // 1.2.840.113549.1.12.1.2
#define OLD_szOID_PKCS_12_offlineTransportMode  OLD_szOID_PKCS_12_ModeIds       ".1"    // obsolete
#define OLD_szOID_PKCS_12_onlineTransportMode   OLD_szOID_PKCS_12_ModeIds       ".2"    // obsolete

#define OLD_szOID_PKCS_12_EspvkIDs              OLD_szOID_PKCS_12               ".2"    // 1.2.840.113549.1.12.2
#define OLD_szOID_PKCS_12_KeyShrouding          OLD_szOID_PKCS_12_EspvkIDs      ".1"    // 1.2.840.113549.1.12.2.1

#define OLD_szOID_PKCS_12_BagIDs                OLD_szOID_PKCS_12               ".3"    // obsolete
#define OLD_szOID_PKCS_12_KeyBagIDs             OLD_szOID_PKCS_12_BagIDs        ".1"    // obsolete
#define OLD_szOID_PKCS_12_CertCrlBagIDs         OLD_szOID_PKCS_12_BagIDs        ".2"    // obsolete
#define OLD_szOID_PKCS_12_SecretBagIDs          OLD_szOID_PKCS_12_BagIDs        ".3"    // obsolete
#define OLD_szOID_PKCS_12_SafeCntIDs            OLD_szOID_PKCS_12_BagIDs        ".4"    // obsolete
#define OLD_szOID_PKCS_12_ShrKeyBagIDs          OLD_szOID_PKCS_12_BagIDs        ".5"    // obsolete

#define OLD_szOID_PKCS_12_CertBagIDs            OLD_szOID_PKCS_12               ".4"    // obsolete
#define OLD_szOID_PKCS_12_x509CertCrlBagIDs     OLD_szOID_PKCS_12_CertBagIDs    ".1"    // obsolete
#define OLD_szOID_PKCS_12_sdsiCertBagIDs        OLD_szOID_PKCS_12_CertBagIDs    ".2"    // obsolete


static HCRYPTASN1MODULE hNSCPAsn1Module;

// fwd
//BOOL FNSCPDumpSafeCntsToHPFX(SafeContents* pSafeCnts, HPFX hpfx);


BOOL InitNSCP()
{
#ifdef OSS_CRYPT_ASN1
    if (0 == (hNSCPAsn1Module = I_CryptInstallAsn1Module(pfxnscp, 0, NULL)) )
        return FALSE;
#else
    PFXNSCP_Module_Startup();
    if (0 == (hNSCPAsn1Module = I_CryptInstallAsn1Module(
            PFXNSCP_Module, 0, NULL))) {
        PFXNSCP_Module_Cleanup();
        return FALSE;
    }
#endif  // OSS_CRYPT_ASN1
    
    return TRUE;
}

BOOL TerminateNSCP()
{
    I_CryptUninstallAsn1Module(hNSCPAsn1Module);
#ifndef OSS_CRYPT_ASN1
    PFXNSCP_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    return TRUE;
}

static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hNSCPAsn1Module);
}



//+-------------------------------------------------------------------------
//  Function:   INSCP_Asn1ToObjectID
//
//  Synopsis:   Convert a dotted string oid to an ASN1 ObjectID
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
INSCP_Asn1ToObjectID(
    IN OID          oid,
    OUT ObjectID    *pooid
)
{
    BOOL            fRet;

    pooid->count = 16;
    if (!PkiAsn1ToObjectIdentifier(
	    oid,
	    &pooid->count,
	    pooid->value))
	goto PkiAsn1ToObjectIdentifierError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    SetLastError(CRYPT_E_OID_FORMAT);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(PkiAsn1ToObjectIdentifierError)
}


//+-------------------------------------------------------------------------
//  Function:   INSCP_Asn1FromObjectID
//
//  Synopsis:   Convert an ASN1 ObjectID to a dotted string oid
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
INSCP_Asn1FromObjectID(
    IN ObjectID     *pooid,
    OUT OID         *poid
)
{
    BOOL        fRet;
    OID         oid = NULL;
    DWORD       cb;

    if (!PkiAsn1FromObjectIdentifier(
	    pooid->count,
	    pooid->value,
	    NULL,
	    &cb))
	goto PkiAsn1FromObjectIdentifierSizeError;
    if (NULL == (oid = (OID)SSAlloc( cb)))
	    goto OidAllocError;
    if (!PkiAsn1FromObjectIdentifier(
	    pooid->count,
	    pooid->value,
	    oid,
	    &cb))
	goto PkiAsn1FromObjectIdentifierError;

    fRet = TRUE;
CommonReturn:
    *poid = oid;
    return fRet;

ErrorReturn:
    SSFree(oid);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OidAllocError)
SET_ERROR(PkiAsn1FromObjectIdentifierSizeError , CRYPT_E_OID_FORMAT)
SET_ERROR(PkiAsn1FromObjectIdentifierError     , CRYPT_E_OID_FORMAT)
}

//+-------------------------------------------------------------------------
//  Function:   INSCP_EqualObjectIDs
//
//  Compare 2 OSS object id's.
//
//  Returns:    FALSE iff !equal
//--------------------------------------------------------------------------
BOOL
WINAPI
INSCP_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2)
{
    BOOL        fRet;
    DWORD       i;
    PDWORD      pdw1;
    PDWORD      pdw2;

    if (poid1->count != poid2->count)
        goto Unequal;
    for (i=poid1->count, pdw1=poid1->value, pdw2=poid2->value;
            (i>0) && (*pdw1==*pdw2);
            i--, pdw1++, pdw2++)
        ;
    if (i>0)
        goto Unequal;

    fRet = TRUE;        // equal
CommonReturn:
    return fRet;

Unequal:
    fRet = FALSE;       // !equal
    goto CommonReturn;
}



//+ --------------------------------------------------------------
//  in NSCP's initial implementation of PFX020, this 
//  is the algorithm they used to derive a key from a password.
//  ACTUALLY, they have two slightly different methods of generating
//  a key, this is the one needed to decrypt the baggage.
//  We include it so we can interoperate.
BOOL NCSPDeriveBaggageDecryptionKey(
        LPCWSTR szPassword,
        int     iPKCS5Iterations,
        PBYTE   pbPKCS5Salt, 
        DWORD   cbPKCS5Salt,
        PBYTE   pbDerivedMaterial,
        DWORD   cbDerivedMaterial)
{
    
    BOOL  fRet = TRUE;
    LPSTR szASCIIPassword = NULL;
    DWORD cbASCIIPassword = 0;
    DWORD i;
    BYTE  paddedPKCS5Salt[20];
    BYTE  *pbTempPKCS5Salt = NULL;
    DWORD cbTempPKCS5Salt = 0;

    BYTE    rgbPKCS5Key[A_SHA_DIGEST_LEN];

    // for some reason the password is used as ASCII in this key derivation
    // so change it from unicode to ASCII
    if (0 == (cbASCIIPassword = WideCharToMultiByte(
                                    CP_ACP,
                                    0,
                                    szPassword,
                                    -1,
                                    NULL,
                                    0,
                                    NULL,
                                    NULL))) {
        goto ErrorReturn;
    }

    if (NULL == (szASCIIPassword = (LPSTR) SSAlloc(cbASCIIPassword))) 
        goto ErrorReturn;

    if (0 == (cbASCIIPassword = WideCharToMultiByte(
                                    CP_ACP,
                                    0,
                                    szPassword,
                                    -1,
                                    szASCIIPassword,
                                    cbASCIIPassword,
                                    NULL,
                                    NULL))) {
        goto ErrorReturn;
    }

    // get rid of the NULL character, Netscape doesn't include it
    cbASCIIPassword--; 

    // because of a Netscape bug the minimum length of password + salt is 20,
    // if the password + salt is less than 20 they pad with 0's.
    // so, check to see if the password + salt is less than 20, if so then pad the 
    // salt since it will be appended to the password.  
    if (cbASCIIPassword+cbPKCS5Salt < 20) {
        // reset the pbPKCS5Salt pointer to a local buffer 
        // which is padded with 0's, and adjust cbPKCS5Salt 
        memset(paddedPKCS5Salt, 0, 20);
        memcpy(paddedPKCS5Salt, pbPKCS5Salt, cbPKCS5Salt);
        pbTempPKCS5Salt = paddedPKCS5Salt;
        cbTempPKCS5Salt = 20 - cbASCIIPassword;
    }
    else {
        pbTempPKCS5Salt = pbPKCS5Salt;
        cbTempPKCS5Salt = cbPKCS5Salt;
    }
    
    
    // use PKCS#5 to generate initial bit stream (seed)
    if (!PKCS5_GenKey(
            iPKCS5Iterations,
            (BYTE *)szASCIIPassword, 
            cbASCIIPassword, 
            pbTempPKCS5Salt, 
            cbTempPKCS5Salt, 
            rgbPKCS5Key))
        goto Ret;
    
    // if there isn't engough key material, then use PHash to generate more
    if (cbDerivedMaterial > sizeof(rgbPKCS5Key))
    {
        // P_hash (secret, seed) =  HMAC_hash (secret, A(0) + seed),
        //                          HMAC_hash (secret, A(1) + seed),
        //                          HMAC_hash (secret, A(2) + seed),
        //                          HMAC_hash (secret, A(3) + seed) ...
        // where
        // A(0) = seed
        // A(i) = HMAC_hash(secret, A(i-1))
        // seed = PKCS5 salt for PKCS5 PBE param
        // secret = normal PKCS5 hashed key

        if (!P_Hash (
                rgbPKCS5Key,
                sizeof(rgbPKCS5Key), 

                pbPKCS5Salt, 
                cbPKCS5Salt,  

                pbDerivedMaterial,      // output
                cbDerivedMaterial,      // # of output bytes requested
                TRUE) )                 // NSCP compat mode?
            goto Ret;
    }
    else
    {
        // we already have enough bits to satisfy the request
        CopyMemory(pbDerivedMaterial, rgbPKCS5Key, cbDerivedMaterial);
    }

    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    if (szASCIIPassword)
        SSFree(szASCIIPassword);
 
    return fRet;
}



// this function will create a SAFE_BAG structure contained in a single buffer
// for the given encoded private key, friendly name, and local key ID
static
BOOL
SetupKeyBag (
    SAFE_BAG    **ppKeyBag,
    DWORD       dwLocalKeyID,
    BYTE        *pbFriendlyName,
    DWORD       cbFriendlyName,
    BYTE        *pbEncodedPrivateKey,
    DWORD       cbEncodedPrivateKey
    )
{

    BOOL                fRet = TRUE;
    SAFE_BAG            *pSafeBag;
    DWORD               cbBytesNeeded = sizeof(SAFE_BAG);
    DWORD				dwKeyID = 0;
	CRYPT_ATTR_BLOB		keyID;
    CERT_NAME_VALUE		wideFriendlyName;
    BYTE                *pbEncodedLocalKeyID = NULL;
    DWORD               cbEncodedLocalKeyID = 0;
    BYTE                *pbEncodedFriendlyName = NULL;
    DWORD               cbEncodedFriendlyName = 0;
    BYTE                *pbCurrentBufferLocation = NULL;

    keyID.pbData = (BYTE *) &dwKeyID;
	keyID.cbData = sizeof(DWORD);
    dwKeyID = dwLocalKeyID;   

    // calculate the size needed for a buffer to fit all the SAFE_BAG information
    cbBytesNeeded += strlen(szOID_PKCS_12_KEY_BAG) + 1;
    cbBytesNeeded += cbEncodedPrivateKey;
    cbBytesNeeded += sizeof(CRYPT_ATTRIBUTE) * 2;
    cbBytesNeeded += strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1;
    cbBytesNeeded += sizeof(CRYPT_ATTR_BLOB);
    
    // encode the keyID attribute
   if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &keyID,
		    NULL,
		    &cbEncodedLocalKeyID)) {
	    goto ErrorReturn;
    }

    if (NULL == (pbEncodedLocalKeyID = (BYTE *) SSAlloc(cbEncodedLocalKeyID)))
	    goto ErrorReturn;

    cbBytesNeeded += cbEncodedLocalKeyID;

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &keyID,
		    pbEncodedLocalKeyID,
		    &cbEncodedLocalKeyID)) {
	    goto ErrorReturn;
    }

    cbBytesNeeded += strlen(szOID_PKCS_12_FRIENDLY_NAME_ATTR) + 1;
    cbBytesNeeded += sizeof(CRYPT_ATTR_BLOB);
    
    // encode the friendly name attribute
    wideFriendlyName.dwValueType = CERT_RDN_BMP_STRING;
    wideFriendlyName.Value.pbData = pbFriendlyName;
    wideFriendlyName.Value.cbData = 0;

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    (void *)&wideFriendlyName,
		    NULL,
		    &cbEncodedFriendlyName)) {
	    goto ErrorReturn;
    }

    if (NULL == (pbEncodedFriendlyName = (BYTE *) SSAlloc(cbEncodedFriendlyName))) 
	    goto ErrorReturn;

    cbBytesNeeded += cbEncodedFriendlyName;

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    (void *)&wideFriendlyName,
		    pbEncodedFriendlyName,
		    &cbEncodedFriendlyName)) {
	    goto ErrorReturn;
    }

    // now allocate space for the all the SAFE_BAG data and copy the data into the buffer
    if (NULL == (pSafeBag = (SAFE_BAG *) SSAlloc(cbBytesNeeded))) 
        goto ErrorReturn;

    memset(pSafeBag, 0, cbBytesNeeded);

    // set current buffer location to be at the end of the SAFE_BAG
    // structure which is at the head of the buffer
    pbCurrentBufferLocation = ((BYTE *) pSafeBag) + sizeof(SAFE_BAG);
    
    // copy key bag type OID
    pSafeBag->pszBagTypeOID = (LPSTR) pbCurrentBufferLocation;
    strcpy((LPSTR) pbCurrentBufferLocation, szOID_PKCS_12_KEY_BAG);
    pbCurrentBufferLocation += strlen(szOID_PKCS_12_KEY_BAG) + 1;

    // copy the private key 
    pSafeBag->BagContents.pbData = pbCurrentBufferLocation;
    pSafeBag->BagContents.cbData = cbEncodedPrivateKey; 
    memcpy(pbCurrentBufferLocation, pbEncodedPrivateKey, cbEncodedPrivateKey);
    pbCurrentBufferLocation += cbEncodedPrivateKey;

    // create space for the attributes array
    pSafeBag->Attributes.cAttr = 2;
    pSafeBag->Attributes.rgAttr = (CRYPT_ATTRIBUTE *) pbCurrentBufferLocation;
    pbCurrentBufferLocation += sizeof(CRYPT_ATTRIBUTE) * 2;

    // copy the local key ID attribute and value
    pSafeBag->Attributes.rgAttr[0].pszObjId = (LPSTR) pbCurrentBufferLocation;
    strcpy((LPSTR) pbCurrentBufferLocation, szOID_PKCS_12_LOCAL_KEY_ID);
    pbCurrentBufferLocation += strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1;
    pSafeBag->Attributes.rgAttr[0].cValue = 1;
    pSafeBag->Attributes.rgAttr[0].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
    pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
    pSafeBag->Attributes.rgAttr[0].rgValue->cbData = cbEncodedLocalKeyID;
    pSafeBag->Attributes.rgAttr[0].rgValue->pbData = pbCurrentBufferLocation;
    memcpy(pbCurrentBufferLocation, pbEncodedLocalKeyID, cbEncodedLocalKeyID);
    pbCurrentBufferLocation += cbEncodedLocalKeyID;

     // copy the friendly name attribute and value
    pSafeBag->Attributes.rgAttr[1].pszObjId = (LPSTR) pbCurrentBufferLocation;
    strcpy((LPSTR) pbCurrentBufferLocation, szOID_PKCS_12_FRIENDLY_NAME_ATTR);
    pbCurrentBufferLocation += strlen(szOID_PKCS_12_FRIENDLY_NAME_ATTR) + 1;
    pSafeBag->Attributes.rgAttr[1].cValue = 1;
    pSafeBag->Attributes.rgAttr[1].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
    pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
    pSafeBag->Attributes.rgAttr[1].rgValue->cbData = cbEncodedFriendlyName;
    pSafeBag->Attributes.rgAttr[1].rgValue->pbData = pbCurrentBufferLocation;
    memcpy(pbCurrentBufferLocation, pbEncodedFriendlyName, cbEncodedFriendlyName);

    *ppKeyBag = pSafeBag;
    
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    if (pbEncodedLocalKeyID)
        SSFree(pbEncodedLocalKeyID);
    if (pbEncodedFriendlyName)
        SSFree(pbEncodedFriendlyName);
    return fRet;
}



// this function will extract a private key from the baggage structure handed in
// and put the private key in a SAFE_BAG structure, where all the data of the 
// SAFE_BAG is contained in a single in a single buffer
static
BOOL
ExtractKeyFromBaggage(
    Baggage     baggage, 
    SAFE_BAG    **ppKeyBag,
    LPCWSTR     szPassword,
    DWORD       dwLocalKeyID,
    BYTE        **ppbCertThumbprint
    )
{
    BOOL                                fRet = TRUE;
	DWORD								dwErr;

    DWORD                               cbEncryptedPrivateKeyInfoStruct = 0;
    CRYPT_ENCRYPTED_PRIVATE_KEY_INFO	*pEncryptedPrivateKeyInfoStruct = NULL;	
    BYTE                                rgbDerivedKeyMatl[40]; // 320 bits is enough for 128 bit key, 64 bit IV
    DWORD                               cbEncodedPrivateKeyInfoStruct = 0;
    BYTE                                *pbEncodedPrivateKeyInfoStruct = NULL;
    PBEParameter                        *pPBEParameter = NULL;
    ASN1decoding_t                      pDec = GetDecoder();

        
    // there should only be one baggage item
    if (baggage.count != 1)
        goto SetPFXDecodeError;

    // there should only be one private key 
    if (baggage.value->espvks.count != 1)
        goto SetPFXDecodeError;

    // decode the PKCS8, which is actually stored in the espvkCipherText field
    // of the ESPVK structure.  it's a Netscape thing man!!!!
    if (!CryptDecodeObject(X509_ASN_ENCODING,
				PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
				(BYTE *) baggage.value->espvks.value->espvkCipherText.value,
				baggage.value->espvks.value->espvkCipherText.length,
				CRYPT_DECODE_NOCOPY_FLAG,
				NULL,
				&cbEncryptedPrivateKeyInfoStruct))
		goto SetPFXDecodeError;	

	if (NULL == (pEncryptedPrivateKeyInfoStruct = (CRYPT_ENCRYPTED_PRIVATE_KEY_INFO *)
				 SSAlloc(cbEncryptedPrivateKeyInfoStruct)))
		goto SetPFXDecodeError;

	if (!CryptDecodeObject(X509_ASN_ENCODING,
				PKCS_ENCRYPTED_PRIVATE_KEY_INFO,
				(BYTE *) baggage.value->espvks.value->espvkCipherText.value,
				baggage.value->espvks.value->espvkCipherText.length,
				CRYPT_DECODE_NOCOPY_FLAG,
				pEncryptedPrivateKeyInfoStruct,
				&cbEncryptedPrivateKeyInfoStruct))
		goto SetPFXDecodeError;

    // verify that the algorithm is the one we expect
    if (strcmp("1.2.840.113549.1.12.5.1.3", pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm.pszObjId) != 0)
        goto SetPFXDecodeError;

    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pPBEParameter,
            PBEParameter_PDU,
            pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm.Parameters.pbData,
            pEncryptedPrivateKeyInfoStruct->EncryptionAlgorithm.Parameters.cbData))
    	goto SetPFXDecodeError;

    // derive the key to be used for decrypting,
    if (!NCSPDeriveBaggageDecryptionKey(
            szPassword,
            pPBEParameter->iterationCount,
            pPBEParameter->salt.value,      // pkcs5 salt
            pPBEParameter->salt.length,
            rgbDerivedKeyMatl,
            40)) { // 192 bits for triple des - 3key, and 64 bit IV ---- for some reason netscape asks for 
                   // 40 bytes of key material, then uses the first 192 bits for key and last 64 bits for IV,
                   // skipping 64 bits in between.  who knows why they do these things!!
       goto ErrorReturn;
    }

    // decrypt the private key
    {
        DWORD       dwDataPos;
        DWORD       cbToBeDec = pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey.cbData;
        DES3TABLE   des3Table;
        BYTE        des3Fdbk [DES_BLOCKLEN];


        // key setup
        tripledes3key(&des3Table, rgbDerivedKeyMatl); 
        CopyMemory(des3Fdbk, &rgbDerivedKeyMatl[40 - sizeof(des3Fdbk)], sizeof(des3Fdbk));    // fdbk is last chunk
                               
        cbEncodedPrivateKeyInfoStruct = 
            ((pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey.cbData + 7) / 8) * 8;
                
        if (NULL == (pbEncodedPrivateKeyInfoStruct = (BYTE *) SSAlloc(cbEncodedPrivateKeyInfoStruct))) 
            goto ErrorReturn;

        for (dwDataPos=0; cbToBeDec > 0; dwDataPos += DES_BLOCKLEN, cbToBeDec -= DES_BLOCKLEN)
        {
            BYTE rgbDec[DES_BLOCKLEN];
            
            CBC(
                tripledes,
		        DES_BLOCKLEN,
		        rgbDec,
		        &(pEncryptedPrivateKeyInfoStruct->EncryptedPrivateKey.pbData[dwDataPos]),
		        (void *) &des3Table,
		        DECRYPT,
		        des3Fdbk);

            CopyMemory(&pbEncodedPrivateKeyInfoStruct[dwDataPos], rgbDec, DES_BLOCKLEN);
        }
    }

    // set up the SAFE_BAG to be returned
    if (!SetupKeyBag(
            ppKeyBag, 
            dwLocalKeyID, 
            (BYTE *) baggage.value->espvks.value->espvkData.nickname.value,
            baggage.value->espvks.value->espvkData.nickname.length,
            pbEncodedPrivateKeyInfoStruct, 
            cbEncodedPrivateKeyInfoStruct)) {
        goto ErrorReturn;
    }

    // copy the cert thumbprint
    assert(baggage.value->espvks.value->espvkData.assocCerts.count == 1);
    if (NULL == (*ppbCertThumbprint = (BYTE *) 
                    SSAlloc(baggage.value->espvks.value->espvkData.assocCerts.value->digest.length)))
        goto ErrorReturn;

    memcpy(
        *ppbCertThumbprint, 
        baggage.value->espvks.value->espvkData.assocCerts.value->digest.value,
        baggage.value->espvks.value->espvkData.assocCerts.value->digest.length);

    goto Ret;

SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
ErrorReturn:
    fRet = FALSE;

Ret:
	// save last error from TLS madness
	dwErr = GetLastError();

    if (pEncryptedPrivateKeyInfoStruct)
		SSFree(pEncryptedPrivateKeyInfoStruct);
    if (pbEncodedPrivateKeyInfoStruct)
        SSFree(pbEncodedPrivateKeyInfoStruct);

    PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);

	// save last error from TLS madness
	SetLastError(dwErr);

    return fRet;
}


// this function will take a SafeContents structure and format it as an array
// array of SAFE_BAGs with all the date for the SAGE_BAGs containted in a single
// buffer.  it also adds the local key ID attribute to the cert which has
// the same thumbprint as the thumbprint passed in 
static
BOOL
SetupCertBags(
    SafeContents    *pSafeCnts,
    SAFE_BAG        **ppCertBags,
    DWORD           *pcNumCertBags,
    DWORD           dwLocalKeyID,
    BYTE            *pbCertThumbprint
    )
{
    BOOL            fRet = TRUE;
	DWORD			dwErr;
    
    SAFE_BAG        *pSafeBags = NULL;
    DWORD           cNumSafeBags = 0;
    
    DWORD           cbBytesNeeded = 0;
    BYTE            *pbCurrentBufferLocation = NULL;
    
    X509Bag         *pX509Bag = NULL;
    CertCRLBag      *pCertCRLBag = NULL;
    
    HCERTSTORE      hCertStore = NULL;
    CRYPT_DATA_BLOB cryptDataBlob;
    PCCERT_CONTEXT  pCertContext = NULL;
    DWORD           dwSafeBagIndex = 0;
    
    DWORD			dwKeyID = 0;
	CRYPT_ATTR_BLOB keyID;
    DWORD           cbEncodedLocalKeyID = 0;
    BYTE            *pbEncodedLocalKeyID = NULL;
    ASN1decoding_t  pDec = GetDecoder();
    
    keyID.pbData = (BYTE *) &dwKeyID;
	keyID.cbData = sizeof(DWORD);
    dwKeyID = dwLocalKeyID;   

    // decode the safe bag content, should be a CertCrlBag
    assert(pSafeCnts->count == 1);
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pCertCRLBag,
            CertCRLBag_PDU,
            (BYTE *) pSafeCnts->value->safeBagContent.value,
            pSafeCnts->value->safeBagContent.length))
    	goto SetPFXDecodeError;

    // decode the X509bag
    assert(pCertCRLBag->count == 1);
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pX509Bag,
            X509Bag_PDU,
            (BYTE *) pCertCRLBag->value[0].value.value,
            pCertCRLBag->value[0].value.length))
    	goto SetPFXDecodeError;

    // encode the keyID so it is ready to be added to a SAFE_BAGs attributes
   if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &keyID,
		    NULL,
		    &cbEncodedLocalKeyID)) {
	    goto ErrorReturn;
    }

    if (NULL == (pbEncodedLocalKeyID = (BYTE *) SSAlloc(cbEncodedLocalKeyID)))
	    goto ErrorReturn;

    
    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    &keyID,
		    pbEncodedLocalKeyID,
		    &cbEncodedLocalKeyID)) {
	    goto ErrorReturn;
    }

    // open a cert store with the SignedData buffer we got from the SafeContents passed in,
    // this will allow access to all the certs as X509 encoded blobs, and it
    // will give access to the thumbprints so a cert can be matched with the
    // private key
    cryptDataBlob.pbData = (BYTE *) pX509Bag->certOrCRL.content.value;
    cryptDataBlob.cbData = pX509Bag->certOrCRL.content.length;
    hCertStore = CertOpenStore(
                    CERT_STORE_PROV_PKCS7,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    NULL,
                    0,
                    &cryptDataBlob);
    
    if (NULL == hCertStore) {
        goto ErrorReturn;
    }

    // calculate how much space is needed to fit the array of SAFE_BAGs and
    // all their data into one contiguous buffer
    while (NULL != (pCertContext = CertEnumCertificatesInStore(
                                        hCertStore,
                                        pCertContext))) {
        DWORD cbEncodedCertBag = 0;
        
        cNumSafeBags++;
        cbBytesNeeded += sizeof(SAFE_BAG);
        
        // get the size for wrapping an encoded cert into an encoded cert bag
        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded, 
                pCertContext->cbCertEncoded, 
                NULL, 
                &cbEncodedCertBag)) {
            goto ErrorReturn;
        }

        cbBytesNeeded += cbEncodedCertBag;
        cbBytesNeeded += strlen(szOID_PKCS_12_CERT_BAG) + 1;
    }

    // add bytes to cbBytesNeeded so there is enough space to add the 
    // LocalKeyID attribute to ONE of the certificates
    cbBytesNeeded += sizeof(CRYPT_ATTRIBUTE);
    cbBytesNeeded += sizeof(CRYPT_ATTR_BLOB);
    cbBytesNeeded += strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1;
    cbBytesNeeded += cbEncodedLocalKeyID;

    // allocate the one big buffer
    if (NULL == (pSafeBags = (SAFE_BAG *) SSAlloc(cbBytesNeeded)))
        goto ErrorReturn;

    memset(pSafeBags, 0, cbBytesNeeded);

    // set the current buffer location to the end of the SAFE_BAG array which
    // is at the head of the buffer
    pbCurrentBufferLocation = ((BYTE *) pSafeBags) + (sizeof(SAFE_BAG) * cNumSafeBags);

    // get the X509 blob for each cert and fill in the array of SAFE_BAGs
    pCertContext = NULL;
    dwSafeBagIndex = 0;
    while (NULL != (pCertContext = CertEnumCertificatesInStore(
                                        hCertStore,
                                        pCertContext))) {

        BYTE    *pbLocalThumbprint = NULL;
        DWORD   cbLocalThumbprint = 0;
        BYTE    *pbEncodedCertBag = NULL;
        DWORD   cbEncodedCertBag = 0;
        
        // copy the bag type OID 
        pSafeBags[dwSafeBagIndex].pszBagTypeOID = (LPSTR) pbCurrentBufferLocation;
        strcpy((LPSTR)pbCurrentBufferLocation, szOID_PKCS_12_CERT_BAG);
        pbCurrentBufferLocation += strlen(szOID_PKCS_12_CERT_BAG) + 1;

        // wrap the encoded cert into an encoded certbag
        // get the size for wrapping an encoded cert into an encoded cert bag
        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded, 
                pCertContext->cbCertEncoded, 
                NULL, 
                &cbEncodedCertBag)) {
            goto ErrorReturn;
        }

        if (NULL == (pbEncodedCertBag = (BYTE *) SSAlloc(cbEncodedCertBag)))
            goto ErrorReturn;


        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded, 
                pCertContext->cbCertEncoded, 
                pbEncodedCertBag, 
                &cbEncodedCertBag)) {
            SSFree(pbEncodedCertBag);
            goto ErrorReturn;
        }

        // copy the encoded certbag
        pSafeBags[dwSafeBagIndex].BagContents.cbData = cbEncodedCertBag;
        pSafeBags[dwSafeBagIndex].BagContents.pbData = pbCurrentBufferLocation;
        memcpy(pbCurrentBufferLocation, pbEncodedCertBag, cbEncodedCertBag);
        pbCurrentBufferLocation += cbEncodedCertBag;

        // we don't need the encoded cert bag anymore
        SSFree(pbEncodedCertBag);
        
        // check to see if this cert is the cert that matches the private key by 
        // comparing the thumbprints

        // Get the thumbprint
        if (!CertGetCertificateContextProperty(
                pCertContext, 
                CERT_SHA1_HASH_PROP_ID, 
                NULL,
                &cbLocalThumbprint)) {
            CertFreeCertificateContext(pCertContext);
            goto ErrorReturn;
        }

        if (NULL == (pbLocalThumbprint = (BYTE *) SSAlloc(cbLocalThumbprint))) {
            CertFreeCertificateContext(pCertContext);
            goto ErrorReturn;   
        }

        if (!CertGetCertificateContextProperty(
                pCertContext, 
                CERT_SHA1_HASH_PROP_ID, 
                pbLocalThumbprint,
                &cbLocalThumbprint)) {
            CertFreeCertificateContext(pCertContext);
            SSFree(pbLocalThumbprint);
            goto ErrorReturn;
        }

        // compare thumbprints
        if (memcmp(pbCertThumbprint, pbLocalThumbprint, cbLocalThumbprint) == 0) {

            // the thumbprints match so add a single attribute with a single value which
            pSafeBags[dwSafeBagIndex].Attributes.cAttr = 1;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr = (CRYPT_ATTRIBUTE *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTRIBUTE);
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].pszObjId = (LPSTR) pbCurrentBufferLocation;
            strcpy((LPSTR) pbCurrentBufferLocation, szOID_PKCS_12_LOCAL_KEY_ID);
            pbCurrentBufferLocation += strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].cValue = 1;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].rgValue[0].cbData = cbEncodedLocalKeyID;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr[0].rgValue[0].pbData = pbCurrentBufferLocation;
            memcpy(pbCurrentBufferLocation, pbEncodedLocalKeyID, cbEncodedLocalKeyID);
            pbCurrentBufferLocation += cbEncodedLocalKeyID;
        }
        else {

            // otherwise the certificate bag has no attributes in it
            pSafeBags[dwSafeBagIndex].Attributes.cAttr = 0;
            pSafeBags[dwSafeBagIndex].Attributes.rgAttr = NULL;
        }

        SSFree(pbLocalThumbprint);
        dwSafeBagIndex++;
    }

    // return the safe bag array and the number of safe bags in the array
    *ppCertBags = pSafeBags;
    *pcNumCertBags = cNumSafeBags;

    goto Ret;

SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
ErrorReturn:
    fRet = FALSE;

    if (pSafeBags)
        SSFree(pSafeBags);
    *ppCertBags = NULL;
    *pcNumCertBags = 0;

Ret:
	// save last error from TLS madness
	dwErr = GetLastError();
    
    PkiAsn1FreeDecoded(pDec, pCertCRLBag, CertCRLBag_PDU);
    PkiAsn1FreeDecoded(pDec, pX509Bag, X509Bag_PDU);

    if (pbEncodedLocalKeyID)
        SSFree(pbEncodedLocalKeyID);

    if (hCertStore)
        CertCloseStore(hCertStore, 0);

	// save last error from TLS madness
	SetLastError(dwErr);

    return fRet;
}


// this function will calculate the number of bytes needed for an
// attribute
static
DWORD
CalculateSizeOfAttributes(
    CRYPT_ATTRIBUTES *pAttributes
    )
{
    DWORD cbBytesNeeded = 0;
    DWORD i,j;

    for (i=0; i<pAttributes->cAttr; i++) {
        cbBytesNeeded += sizeof(CRYPT_ATTRIBUTE);
        cbBytesNeeded += strlen(pAttributes->rgAttr[i].pszObjId) + 1;
        for (j=0; j<pAttributes->rgAttr[i].cValue; j++) {
            cbBytesNeeded += sizeof(CRYPT_ATTR_BLOB);
            cbBytesNeeded += pAttributes->rgAttr[i].rgValue[j].cbData; 
        }
    }

    return cbBytesNeeded;
}


// this function will take two SAFE_BAG arrays and concatenate them into 
// a SAFE_CONTENT structure.  also, the SAFE_CONTENT structure and all
// it's supporting data will be in a single contiguous buffer
static
BOOL
ConcatenateSafeBagsIntoSafeContents(
    SAFE_BAG    *pSafeBagArray1,
    DWORD       cSafeBagArray1,
    SAFE_BAG    *pSafeBagArray2,
    DWORD       cSafeBagArray2,
    SAFE_CONTENTS **ppSafeContents
    )
{
    BOOL            fRet = TRUE;
    DWORD           cbBytesNeeded = 0;
    DWORD           i,j;
    SAFE_CONTENTS   *pSafeContents = NULL;
    DWORD           dwSafeBagIndex = 0;
    BYTE            *pbCurrentBufferLocation = NULL;

    cbBytesNeeded += sizeof(SAFE_CONTENTS);
    cbBytesNeeded += sizeof(SAFE_BAG) * (cSafeBagArray1 + cSafeBagArray2);

    for (i=0; i<cSafeBagArray1; i++) {
        cbBytesNeeded += strlen(pSafeBagArray1[i].pszBagTypeOID) + 1;
        cbBytesNeeded += pSafeBagArray1[i].BagContents.cbData;
        cbBytesNeeded += CalculateSizeOfAttributes(&pSafeBagArray1[i].Attributes);
    }

    for (i=0; i<cSafeBagArray2; i++) {
        cbBytesNeeded += strlen(pSafeBagArray2[i].pszBagTypeOID) + 1;
        cbBytesNeeded += pSafeBagArray2[i].BagContents.cbData;
        cbBytesNeeded += CalculateSizeOfAttributes(&pSafeBagArray2[i].Attributes);
    }

    if (NULL == (pSafeContents = (SAFE_CONTENTS *) SSAlloc(cbBytesNeeded)))
        goto ErrorReturn;

    memset(pSafeContents, 0, cbBytesNeeded);

    pbCurrentBufferLocation = ((BYTE *) pSafeContents) + sizeof(SAFE_CONTENTS);
    pSafeContents->cSafeBags = cSafeBagArray1 + cSafeBagArray2;
    pSafeContents->pSafeBags = (SAFE_BAG *) pbCurrentBufferLocation;
    pbCurrentBufferLocation += sizeof(SAFE_BAG) * (cSafeBagArray1 + cSafeBagArray2);

    for (i=0; i<cSafeBagArray1; i++) {
        pSafeContents->pSafeBags[dwSafeBagIndex].pszBagTypeOID = (LPSTR) pbCurrentBufferLocation;
        strcpy((LPSTR) pbCurrentBufferLocation, pSafeBagArray1[i].pszBagTypeOID);
        pbCurrentBufferLocation += strlen(pSafeBagArray1[i].pszBagTypeOID) + 1;
        pSafeContents->pSafeBags[dwSafeBagIndex].BagContents.cbData = pSafeBagArray1[i].BagContents.cbData;
        pSafeContents->pSafeBags[dwSafeBagIndex].BagContents.pbData = pbCurrentBufferLocation;
        memcpy(pbCurrentBufferLocation, pSafeBagArray1[i].BagContents.pbData, pSafeBagArray1[i].BagContents.cbData);
        pbCurrentBufferLocation += pSafeBagArray1[i].BagContents.cbData;
        
        pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr = pSafeBagArray1[i].Attributes.cAttr;
        if (pSafeBagArray1[i].Attributes.cAttr != 0) {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr = (CRYPT_ATTRIBUTE *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTRIBUTE) * pSafeBagArray1[i].Attributes.cAttr;
        }
        else {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr = NULL;
        }

        for (j=0; j<pSafeBagArray1[i].Attributes.cAttr; j++) {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].pszObjId = (LPSTR) pbCurrentBufferLocation;
            strcpy((LPSTR) pbCurrentBufferLocation, pSafeBagArray1[i].Attributes.rgAttr[j].pszObjId);
            pbCurrentBufferLocation += strlen(pSafeBagArray1[i].Attributes.rgAttr[j].pszObjId) + 1;
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].cValue = 1;
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue[0].cbData = 
                pSafeBagArray1[i].Attributes.rgAttr[j].rgValue[0].cbData;  
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue[0].pbData = pbCurrentBufferLocation;
            memcpy(
                pbCurrentBufferLocation, 
                pSafeBagArray1[i].Attributes.rgAttr[j].rgValue[0].pbData, 
                pSafeBagArray1[i].Attributes.rgAttr[j].rgValue[0].cbData);
            pbCurrentBufferLocation += pSafeBagArray1[i].Attributes.rgAttr[j].rgValue[0].cbData;
        }

        dwSafeBagIndex++;
    }

    for (i=0; i<cSafeBagArray2; i++) {
        pSafeContents->pSafeBags[dwSafeBagIndex].pszBagTypeOID = (LPSTR) pbCurrentBufferLocation;
        strcpy((LPSTR) pbCurrentBufferLocation, pSafeBagArray2[i].pszBagTypeOID);
        pbCurrentBufferLocation += strlen(pSafeBagArray2[i].pszBagTypeOID) + 1;
        pSafeContents->pSafeBags[dwSafeBagIndex].BagContents.cbData = pSafeBagArray2[i].BagContents.cbData;
        pSafeContents->pSafeBags[dwSafeBagIndex].BagContents.pbData = pbCurrentBufferLocation;
        memcpy(pbCurrentBufferLocation, pSafeBagArray2[i].BagContents.pbData, pSafeBagArray2[i].BagContents.cbData);
        pbCurrentBufferLocation += pSafeBagArray2[i].BagContents.cbData;
        
        pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr = pSafeBagArray2[i].Attributes.cAttr;
        if (pSafeBagArray2[i].Attributes.cAttr != 0) {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr = (CRYPT_ATTRIBUTE *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTRIBUTE) * pSafeBagArray2[i].Attributes.cAttr;
        }
        else {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr = NULL;
        }

        for (j=0; j<pSafeBagArray2[i].Attributes.cAttr; j++) {
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].pszObjId = (LPSTR) pbCurrentBufferLocation;
            strcpy((LPSTR) pbCurrentBufferLocation, pSafeBagArray2[i].Attributes.rgAttr[j].pszObjId);
            pbCurrentBufferLocation += strlen(pSafeBagArray2[i].Attributes.rgAttr[j].pszObjId) + 1;
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].cValue = 1;
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue = (CRYPT_ATTR_BLOB *) pbCurrentBufferLocation;
            pbCurrentBufferLocation += sizeof(CRYPT_ATTR_BLOB);
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue[0].cbData = 
                pSafeBagArray2[i].Attributes.rgAttr[j].rgValue[0].cbData;  
            pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[j].rgValue[0].pbData = pbCurrentBufferLocation;
            memcpy(
                pbCurrentBufferLocation, 
                pSafeBagArray2[i].Attributes.rgAttr[j].rgValue[0].pbData, 
                pSafeBagArray2[i].Attributes.rgAttr[j].rgValue[0].cbData);
            pbCurrentBufferLocation += pSafeBagArray2[i].Attributes.rgAttr[j].rgValue[0].cbData;
        }

        dwSafeBagIndex++;
    }

    *ppSafeContents = pSafeContents;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    return fRet;
}


BOOL
PFXAPI
NSCPImportBlob
(   
    LPCWSTR  szPassword,
    PBYTE   pbIn,
    DWORD   cbIn,
    SAFE_CONTENTS **ppSafeContents
)
{
    BOOL            fRet = TRUE;
	DWORD			dwErr;
    
    int             iEncrType;
    OID             oid = NULL;

    PFX             *psPfx = NULL;
    EncryptedData   *pEncrData = NULL;
    RSAData         *pRSAData = NULL;
    PBEParameter    *pPBEParameter = NULL;
    SafeContents    *pSafeCnts = NULL;
    AuthenticatedSafe *pAuthSafe = NULL;
	SAFE_BAG		*pKeyBag = NULL;
	SAFE_BAG        *pCertBag = NULL;
    BYTE            *pCertThumbprint = NULL;
    DWORD           cNumCertBags = 0;
    ASN1decoding_t  pDec = GetDecoder();

    // Crack the PFX blob
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&psPfx,
            PFX_PDU,
            pbIn,
            cbIn))
    	goto SetPFXDecodeError;
    
    // info blurted into psPfx(PFX) - ensure content present
    if (0 == (psPfx->authSafe.bit_mask & content_present))
	    goto SetPFXDecodeError;

    
    // UNDONE: tear apart MACData


    // Check authsafe(ContentInfo)

    // could be data/signeddata
    // UNDONE: only support szOID_RSA_data 
    if (!INSCP_Asn1FromObjectID( &psPfx->authSafe.contentType,  &oid))
	    goto ErrorReturn;
    if (0 != strcmp( oid, szOID_RSA_data))
	    goto SetPFXDecodeError;
    SSFree(oid);
    oid = NULL;
    
    // content is data: decode
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pRSAData,
            RSAData_PDU,
            (BYTE *) psPfx->authSafe.content.value,
            psPfx->authSafe.content.length))
    	goto SetPFXDecodeError;

    // now we have octet string: this is an encoded authSafe
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pAuthSafe,
            AuthenticatedSafe_PDU,
            pRSAData->value,
            pRSAData->length))
    	goto SetPFXDecodeError;

    // check version of the safe
    if (pAuthSafe->bit_mask & version_present)
#ifdef OSS_CRYPT_ASN1
        if (pAuthSafe->version != v1)
#else
        if (pAuthSafe->version != Version_v1)
#endif  // OSS_CRYPT_ASN1
	        goto SetPFXDecodeError;

    // require (officially optional) pieces
    
    // NSCP: transport mode is used but count is encoded incorrectly
//   if (0 == (pAuthSafe->bit_mask & transportMode_present))
//	    goto PFXDecodeError;

    if (0 == (pAuthSafe->bit_mask & privacySalt_present))
	    goto SetPFXDecodeError;
    if (0 == (pAuthSafe->bit_mask & baggage_present))
	    goto SetPFXDecodeError;

    // could be encryptedData/envelopedData
    // UNDONE: only support szOID_RSA_encryptedData 
    if (!INSCP_Asn1FromObjectID( &pAuthSafe->safe.contentType,  &oid))
	    goto ErrorReturn;
    if (0 != strcmp( oid, szOID_RSA_encryptedData))
	    goto SetPFXDecodeError;
    SSFree(oid);
    oid = NULL;


    //    
    // we have pAuthSafe->safe data as RSA_encryptedData
    // we have pAuthSafe->privacySalt to help us decrypt it

    // we have pAuthSafe->baggage 

    // decode content to encryptedData
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pEncrData,
            EncryptedData_PDU,
            (BYTE *) pAuthSafe->safe.content.value,
            pAuthSafe->safe.content.length))
    	goto SetPFXDecodeError;
    

    // chk version
    if (pEncrData->version != 0)  
        goto SetPFXDecodeError;

    // chk content present, type
    if (0 == (pEncrData->encryptedContentInfo.bit_mask & encryptedContent_present))
        goto SetPFXDecodeError;
    if (!INSCP_Asn1FromObjectID(&pEncrData->encryptedContentInfo.contentType, &oid))
        goto ErrorReturn;
    if (0 != strcmp( oid, szOID_RSA_data))
        goto SetPFXDecodeError;
    SSFree(oid);
    oid = NULL;


    // chk encr alg present, type
    if (0 == (pEncrData->encryptedContentInfo.contentEncryptionAlg.bit_mask & parameters_present))
        goto SetPFXDecodeError;
    if (!INSCP_Asn1FromObjectID(&pEncrData->encryptedContentInfo.contentEncryptionAlg.algorithm, &oid))
        goto ErrorReturn;

    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pPBEParameter,
            PBEParameter_PDU,
            (BYTE *) pEncrData->encryptedContentInfo.contentEncryptionAlg.parameters.value,
            pEncrData->encryptedContentInfo.contentEncryptionAlg.parameters.length))
    	goto SetPFXDecodeError;


    
    if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1And40BitRC2))
    {
        iEncrType = RC2_40;
    }
    else if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1And40BitRC4))
    {
        iEncrType = RC4_40;
    }
    else if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1And128BitRC2))
    {
        iEncrType = RC2_128;
    }
    else if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1And128BitRC4))
    {
        iEncrType = RC4_128;
    }
    else if (0 == strcmp( oid, OLD_szOID_PKCS_12_pbeWithSHA1AndTripleDES))
    {
        iEncrType = TripleDES;
    }
    else
        goto SetPFXAlgIDError;
    SSFree(oid);
    oid = NULL;


    // DECRYPT encryptedData
    if (!NSCPPasswordDecryptData(
            iEncrType, 

            szPassword,
            pAuthSafe->privacySalt.value,   // privacy salt
            pAuthSafe->privacySalt.length/8,
            pPBEParameter->iterationCount,
            pPBEParameter->salt.value,      // pkcs5 salt
            pPBEParameter->salt.length,

            &pEncrData->encryptedContentInfo.encryptedContent.value,
            (PDWORD)&pEncrData->encryptedContentInfo.encryptedContent.length))
        goto SetPFXDecryptError;

    // decode plaintext encryptedData
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pSafeCnts,
            SafeContents_PDU,
            pEncrData->encryptedContentInfo.encryptedContent.value,
            pEncrData->encryptedContentInfo.encryptedContent.length))
    	goto SetPFXDecodeError;

    // get private keys out of baggage
	if (!ExtractKeyFromBaggage(
            pAuthSafe->baggage, 
            &pKeyBag, 
            szPassword,
            1,              // this parameter is the Local Key ID to add to the key bags attributes
            &pCertThumbprint)) { 
        goto ErrorReturn;
    }
    
    // set up the cert bag
    if (!SetupCertBags(
            pSafeCnts,
            &pCertBag,
            &cNumCertBags,
            1,    // this parameter is the Local Key ID to add to the cert bags attributes
            pCertThumbprint)) { 
        goto ErrorReturn;
    }

    ConcatenateSafeBagsIntoSafeContents(
        pKeyBag,
        1,
        pCertBag,
        cNumCertBags,
        ppSafeContents);
 	
    goto Ret;


SetPFXAlgIDError:
    SetLastError(NTE_BAD_ALGID);
    goto ErrorReturn;

SetPFXDecodeError:
	SetLastError(CRYPT_E_BAD_ENCODE);
    goto ErrorReturn;

SetPFXDecryptError:
	SetLastError(NTE_FAIL);
    goto ErrorReturn;

ErrorReturn:
    fRet = FALSE;
Ret:

	// save last error from TLS madness
	dwErr = GetLastError();

    PkiAsn1FreeDecoded(pDec, psPfx, PFX_PDU);
    PkiAsn1FreeDecoded(pDec, pRSAData, RSAData_PDU);
    PkiAsn1FreeDecoded(pDec, pAuthSafe, AuthenticatedSafe_PDU);
    PkiAsn1FreeDecoded(pDec, pEncrData, EncryptedData_PDU);
    PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);
    PkiAsn1FreeDecoded(pDec, pSafeCnts, SafeContents_PDU);

    if (oid != NULL)
        SSFree(oid);

    if (pKeyBag)
        SSFree(pKeyBag);

    if (pCertBag)
        SSFree(pCertBag);

    if (pCertThumbprint)
        SSFree(pCertThumbprint);
	
	// save last error from TLS madness
	SetLastError(dwErr);

    return fRet;  // return bogus handle
}


BOOL
PFXAPI
IsNetscapePFXBlob(CRYPT_DATA_BLOB* pPFX)
{
    PFX             *psPfx = NULL;
    ASN1decoding_t  pDec = GetDecoder();
    
    // Crack the PFX blob
    if (0 == PkiAsn1Decode(
            pDec,
            (void **)&psPfx,
            PFX_PDU,
            pPFX->pbData,
            pPFX->cbData))
    {
        PkiAsn1FreeDecoded(pDec, psPfx, PFX_PDU);
        return TRUE;
    }
    	
    return FALSE;
}



/*
BOOL FNSCPDumpSafeCntsToHPFX(SafeContents* pSafeCnts, HPFX hpfx)
{
    PPFX_INFO           ppfx = (PPFX_INFO)hpfx;

    // sort and dump bags into correct areas
    ObjectID oKeyBag, oCertBag; 
    DWORD dw;

    ZeroMemory(&oKeyBag, sizeof(ObjectID));
    ZeroMemory(&oCertBag, sizeof(ObjectID));

    if (!INSCP_Asn1ToObjectID( &szOID_PKCS_12_KeyBagIDs, &oKeyBag))
	    return FALSE;

    if (!INSCP_Asn1ToObjectID( &szOID_PKCS_12_CertCrlBagIDs, &oCertBag))
	    return FALSE;

    for (dw=pSafeCnts->count; dw>0; --dw)
    {
        if (INSCP_EqualObjectIDs(&pSafeCnts->value->safeBagType,
                &oKeyBag) )
        {
            // inc size
            ppfx->cKeys++;
            if (ppfx->rgKeys)
                ppfx->rgKeys = (void**)SSReAlloc(ppfx->rgKeys, ppfx->cKeys * sizeof(SafeBag*));
            else
                ppfx->rgKeys = (void**)SSAlloc(ppfx->cKeys * sizeof(SafeBag*));

            // assign to keys
            ppfx->rgKeys[ppfx->cKeys-1] = &pSafeCnts->value[dw];
        }
        else if (INSCP_EqualObjectIDs(&pSafeCnts->value->safeBagType,
                &oCertBag) )
        {
            // inc size
            ppfx->cCertcrls++;
            if (ppfx->rgCertcrls)
                ppfx->rgCertcrls = (void**)SSReAlloc(ppfx->rgCertcrls, ppfx->cCertcrls * sizeof(SafeBag*));
            else
                ppfx->rgCertcrls = (void**)SSAlloc(ppfx->cCertcrls * sizeof(SafeBag*));

            // assign to certs/crls
            ppfx->rgCertcrls[ppfx->cCertcrls-1] = &pSafeCnts->value[dw];
        }
        else
        {
            // inc size
            ppfx->cSecrets++;
            if (ppfx->rgSecrets)
                ppfx->rgSecrets = (void**)SSReAlloc(ppfx->rgSecrets, ppfx->cSecrets * sizeof(SafeBag*));
            else
                ppfx->rgSecrets = (void**)SSAlloc(ppfx->cSecrets * sizeof(SafeBag*));

            // assign to safebag
            ppfx->rgSecrets[ppfx->cSecrets-1] = &pSafeCnts->value[dw];
        }
    }

    return TRUE;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxcmn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pfxcmn.h
//
//--------------------------------------------------------------------------

#ifndef _PFXCMN_H_
#define _PFXCMN_H_

#ifdef __cplusplus
extern "C" {
#endif


typedef DWORD   PFXERR;
typedef HANDLE  HPFXITEM;
typedef HANDLE  HPFX;
typedef LPSTR   OID;

#define PFXAPI __stdcall

// define allocators
#define SSAlloc(__x__)              LocalAlloc(LMEM_FIXED, __x__)
#define SSFree(__x__)               LocalFree(__x__)
#define SSReAlloc(__x__, __y__)     LocalReAlloc(__x__, __y__, LMEM_MOVEABLE)


// PFXExportCertStoreEx -> PFXExportCertStore internal param
#define PKCS12_ENHANCED_STRENGTH_ENCODING  0xffff0008 

#define PKCS12_ENCR_PWD_ITERATIONS      2000
#define PKCS12_MAC_PWD_ITERATIONS		2000


#define MAKEZERO(arg) ZeroMemory( &arg, sizeof(arg))

// count the number of bytes needed to fully store a WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )


typedef struct _PFX_INFO {

    #define     NSCP_BLOB   1
    #define     PFX_BLOB    2
    DWORD                   dwBlobType; // NSCP, PFX?

    LPWSTR                  szPassword;

    DWORD                   dwPrivacyMode;
    DWORD                   dwIntegrityMode;
    DWORD                   dwTransportMode;

    CRYPT_ALGORITHM_IDENTIFIER    aiKeyShroudingEncryptionAlgid;
    CRYPT_ALGORITHM_IDENTIFIER    aiSafePDUEncryptionAlgid;

    
    void**                  rgSecrets;          // SafeBag* []  -- array of safebag*'s
    DWORD                   cSecrets;

    void**                  rgCertcrls;         // SafeBag* []  -- array of safebag*'s
    DWORD                   cCertcrls;

    void**                  rgKeys;             // SafeBag* []  -- array of safebag*'s
    DWORD                   cKeys;

    void**                  rgShroudedKeys;     // SafeBag* []  -- array of safebag*'s
    DWORD                   cShroudedKeys;

} PFX_INFO, *PPFX_INFO;





// -------------------------------------------------------------------------
// begin nscp.cpp entry points
// -------------------------------------------------------------------------
BOOL InitNSCP();
BOOL TerminateNSCP();

////////////////////
// import pb, cb, return HPFX
BOOL
PFXAPI
NSCPImportBlob
(   
    LPCWSTR         szPassword,
    PBYTE           pbIn,
    DWORD           cbIn,
    SAFE_CONTENTS   **ppSafeContents
);

// -------------------------------------------------------------------------
// end nscp.cpp entry points
// -------------------------------------------------------------------------



// -------------------------------------------------------------------------
// begin PFX.cpp entry points
// -------------------------------------------------------------------------
BOOL InitPFX();
BOOL TerminatePFX();

////////////////////
//  returns HPFX, prepares PFX export
HPFX
PFXAPI
PfxExportCreate (
    LPCWSTR szPassword
);


////////////////////
//  Do header wrap of specified HPFX
BOOL
PFXAPI
PfxExportBlob
(   
    HPFX    hpfx,   
    PBYTE   pbOut,
    DWORD*  pcbOut,
    DWORD   dwFlags
);

////////////////////
//  Unwrap pb cb, return handle to new HPFX
HPFX
PFXAPI
PfxImportBlob
(   
    LPCWSTR szPassword,
    PBYTE   pbIn,
    DWORD   cbIn,
    DWORD   dwFlags
);

////////////////////
//  Free all resources associated with the hpfx
BOOL
PFXAPI
PfxCloseHandle(
    IN HPFX hpfx
);


//
// functions for checking if somethings is a pfx blob
//
BOOL
PFXAPI
IsRealPFXBlob
(
    CRYPT_DATA_BLOB* pPFX
);

BOOL
PFXAPI
IsNetscapePFXBlob
(
    CRYPT_DATA_BLOB* pPFX
);

// -------------------------------------------------------------------------
// end PFX.cpp entry points
// -------------------------------------------------------------------------

// new entry points for loading up the HPFX
BOOL PfxGetKeysAndCerts(
    HPFX hPfx, 
    SAFE_CONTENTS* pContents
);

BOOL PfxAddSafeBags(
    HPFX hPfx, 
    SAFE_BAG*   pSafeBags, 
    DWORD       cSafeBags
);

BOOL
MakeEncodedCertBag(
    BYTE *pbEncodedCert,
    DWORD cbEncodedCert,
    BYTE *pbEncodedCertBag,
    DWORD *pcbEncodedCertBag
);

BOOL
GetEncodedCertFromEncodedCertBag(
    BYTE    *pbEncodedCertBag,
    DWORD   cbEncodedCertBag,
    BYTE    *pbEncodedCert,
    DWORD   *pcbEncodedCert
);

BOOL
SetSaltAndIterationCount(
    BYTE    **ppbParameters,
    DWORD   *pcbParameters,
    BYTE    *pbSalt,
    DWORD   cbSalt,
    int     iIterationCount
);

BOOL
GetSaltAndIterationCount(
    BYTE    *pbParameters,
    DWORD   cbParameters,
    BYTE    **ppbSalt,
    DWORD   *pcbSalt,
    int     *piIterationCount
);

///////////////////////////////////////////////////////////////////////////////////
// The real PKCS #12 Object Identifiers
#define szOID_PKCS_12_PbeIds                        szOID_PKCS_12           ".1"
#define szOID_PKCS_12_pbeWithSHA1And128BitRC4       szOID_PKCS_12_PbeIds    ".1"
#define szOID_PKCS_12_pbeWithSHA1And40BitRC4        szOID_PKCS_12_PbeIds    ".2"
#define szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES   szOID_PKCS_12_PbeIds    ".3"
#define szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES   szOID_PKCS_12_PbeIds    ".4"
#define szOID_PKCS_12_pbeWithSHA1And128BitRC2       szOID_PKCS_12_PbeIds    ".5"
#define szOID_PKCS_12_pbeWithSHA1And40BitRC2        szOID_PKCS_12_PbeIds    ".6"

#define szOID_PKCS_12_EnvelopingIds                 OLD_szOID_PKCS_12_OIDs          ".2"
#define szOID_PKCS_12_rsaEncryptionWith128BitRC4    OLD_szOID_PKCS_12_EnvelopingIds ".1"
#define szOID_PKCS_12_rsaEncryptionWith40BitRC4     OLD_szOID_PKCS_12_EnvelopingIds ".2"
#define szOID_PKCS_12_rsaEncryptionWithTripleDES    OLD_szOID_PKCS_12_EnvelopingIds ".3"

#define szOID_PKCS_12_SignatureIds                  OLD_szOID_PKCS_12_OIDs          ".3"
#define szOID_PKCS_12_rsaSignatureWithSHA1Digest    OLD_szOID_PKCS_12_SignatureIds  ".1"



#define szOID_PKCS_12_PkekIDs               szOID_PKCS_12               ".6"    // 1.2.840.113549.1.12.6
#define szOID_PKCS_12_UserCertPkekId        szOID_PKCS_12_PkekIDs       ".1"    // 1.2.840.113549.1.12.6.1
#define szOID_PKCS_12_CACertPkekId          szOID_PKCS_12_PkekIDs       ".2"    // 1.2.840.113549.1.12.6.2
#define szOID_PKCS_12_SelfSignedPkekId      szOID_PKCS_12_PkekIDs       ".3"    // 1.2.840.113549.1.12.6.3

#define szOID_PKCS_12_Version1                  szOID_PKCS_12           ".10"
#define szOID_PKCS_12_BagIDs                    szOID_PKCS_12_Version1  ".1"
#define szOID_PKCS_12_KeyBag                    szOID_PKCS_12_BagIDs    ".1"
#define szOID_PKCS_12_ShroudedKeyBag            szOID_PKCS_12_BagIDs    ".2"
#define szOID_PKCS_12_CertBag                   szOID_PKCS_12_BagIDs    ".3"
#define szOID_PKCS_12_CRLBag                    szOID_PKCS_12_BagIDs    ".4"
#define szOID_PKCS_12_SecretBag                 szOID_PKCS_12_BagIDs    ".5"
#define szOID_PKCS_12_SafeContentsBag           szOID_PKCS_12_BagIDs    ".6"


// new oids 6/30/97
#define szOID_PKCS_12_FriendlyName              szOID_PKCS_9            ".20"
#define szOID_PKCS_12_LocalKeyID                szOID_PKCS_9            ".21"
#define szOID_PKCS_12_CertTypes                 szOID_PKCS_9            ".22"
#define szOID_PKCS_12_CRLTypes                  szOID_PKCS_9            ".23"
#define szOID_PKCS_12_x509Cert                  szOID_PKCS_12_CertTypes ".1"
#define szOID_PKCS_12_SDSICert                  szOID_PKCS_12_CertTypes ".2"
#define szOID_PKCS_12_x509CRL                   szOID_PKCS_12_CRLTypes  ".1"




#ifdef __cplusplus
}   // extern "C"
#endif

#endif // _PFXCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\managed\unity\certificate.cs ===
///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
/// <summary>
/// 
/// Filename: Certificate.cs
/// 
/// Remark  : This class does not inherit from System.Security.Cryptography.
///           X509Certificates.X509Certificate class.
///           
/// History : DSIE 7/16/2002
/// 
/// </summary>
/// ---------------------------------------------------------------------------

using System;
using System.Text;

namespace System.Security.Cryptographic.PKI
{
   ///[DllImport("Crypt32.dll")]
   ///private static extern 

   ///+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	/// <summary>
	/// 
	/// Certificate class to manipulate X509 digital certificate.
	/// 
	/// </summary>
	/// 
	/// ------------------------------------------------------------------------

	public class Certificate
	{
      ///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ///
      /// <summary>
      ///
      /// Function: Certificate.Create.
      /// 
      /// Synopsis: Static method to create a Certificate instance from
      ///           certificate stored in file (CER, SST, P7S, P7B, etc.).
      ///           
      /// Remark  : If the file contains more than one certificate, such as
      ///           SST, the very first one encountered will be used.
      ///           
      /// Notes   : Should we have a constructor that takes a filename instead
      ///           of this static method?
      ///           
      /// </summary>
      /// <param name="filename"></param>
      /// 
      /// <returns>Certificate</returns>
      /// 
      ///----------------------------------------------------------------------
      
      public static Certificate Create (string filename)
      {
         Encoding encodingUTF8 = System.Text.Encoding.UTF8;

         byte[] certBlob = encodingUTF8.GetBytes("CertBlob");

         return new Certificate(certBlob);
      }

      ///++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ///
      /// <summary>
      /// 
      /// Constructor using a byte array containing an ASN encoded X509
      /// certificate.
      /// 
      /// </summary>
      /// 
      /// ---------------------------------------------------------------------
      
      public Certificate(byte[] encodedCertificate)
		{
			//
			// TODO: Add constructor logic here
			//
		}

      public int Version
      {
         get 
         {
            Console.WriteLine("?");

            return 3;
         }
      }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\managed\unity\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxcrypt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pfxcrypt.h
//
//--------------------------------------------------------------------------

#define RC4_128     1
#define RC4_40      2
#define TripleDES   3
#define RC2_128     4
#define RC2_40      5


BOOL _stdcall 
PFXPasswordEncryptData(
        int     iEncrType,
        LPCWSTR szPassword,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt, 

        PBYTE* pbData,
        DWORD* pcbData);

BOOL _stdcall
PFXPasswordDecryptData(
        int     iEncrType,
        LPCWSTR szPassword,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt, 

        PBYTE* pbData,
        DWORD* pcbData);



BOOL NSCPPasswordDecryptData(
        int     iEncrType,

        LPCWSTR szPassword,

        PBYTE   pbPrivacySalt,
        DWORD   cbPrivacySalt,

        int     iPKCS5Iterations,
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt, 

        PBYTE*  ppbData,
        DWORD*  pcbData);

BOOL FGenerateMAC(
        LPCWSTR szPassword,

        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt, 
        DWORD   iterationCount,

        PBYTE   pbData,     // pb data
        DWORD   cbData,     // cb data
        BYTE    rgbMAC[]);  // A_SHA_DIGEST_LEN



//////////////////////////////////////////////////
// begin tls1key.h
BOOL PKCS5_GenKey
(
    int     iIterations,

    PBYTE   pbPW, 
    DWORD   cbPW, 

    PBYTE   pbSalt, 
    DWORD   cbSalt, 

    BYTE    rgbPKCS5Key[]     // A_SHA_DIGEST_LEN
);

BOOL P_Hash
(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut, //# of bytes of key length they want as output.

    BOOL   fNSCPCompatMode
);

BOOL FTestPHASH_and_HMAC();
BOOL F_NSCP_TestPHASH_and_HMAC();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxfmt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pfx.cpp
//
//  Contents:   PFX: Personal Information Exchange.
//
//  Functions:
//
//  History:    02-Aug-96    kevinr   created
//              01-May-97    mattt    modified for pstore provider usage
//              07-Jul-97    mattt    modified for crypt32 inclusion
//
//--------------------------------------------------------------------------
#include "global.hxx"

#define _PFX_SOURCE_

extern "C" {
#include "pfxpkcs.h"    // ASN1-generated
}

#include "pfxhelp.h"
#include "pfxcmn.h"
#include "crypttls.h"

#include "pfxcrypt.h"
#include <sha.h>
#include "dbgdef.h"

#define CURRENT_PFX_VERSION  0x3


// fwd
BOOL FPFXDumpSafeCntsToHPFX(SafeContents* pSafeCnts, HPFX hpfx);

static HCRYPTASN1MODULE hPFXAsn1Module;

BOOL InitPFX()
{
#ifdef OSS_CRYPT_ASN1
    if (0 == (hPFXAsn1Module = I_CryptInstallAsn1Module(pfxpkcs, 0, NULL)) )
        return FALSE;
#else
    PFXPKCS_Module_Startup();
    if (0 == (hPFXAsn1Module = I_CryptInstallAsn1Module(
            PFXPKCS_Module, 0, NULL))) {
        PFXPKCS_Module_Cleanup();
        return FALSE;
    }
#endif  // OSS_CRYPT_ASN1

    return TRUE;
}

BOOL TerminatePFX()
{
    I_CryptUninstallAsn1Module(hPFXAsn1Module);
#ifndef OSS_CRYPT_ASN1
    PFXPKCS_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    return TRUE;
}



static inline ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hPFXAsn1Module);
}
static inline ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hPFXAsn1Module);
}


//+-------------------------------------------------------------------------
//  Function:   IPFX_Asn1ToObjectID
//
//  Synopsis:   Convert a dotted string oid to an ASN1 ObjectID
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
IPFX_Asn1ToObjectID(
    IN OID          oid,
    OUT ObjectID    *pooid
)
{
    BOOL            fRet;

    pooid->count = 16;
    if (!PkiAsn1ToObjectIdentifier(
        oid,
        &pooid->count,
        pooid->value))
    goto PkiAsn1ToObjectIdentifierError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    SetLastError(CRYPT_E_OID_FORMAT);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(PkiAsn1ToObjectIdentifierError)
}


//+-------------------------------------------------------------------------
//  Function:   IPFX_Asn1FromObjectID
//
//  Synopsis:   Convert an ASN1 ObjectID to a dotted string oid
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
IPFX_Asn1FromObjectID(
    IN ObjectID     *pooid,
    OUT OID         *poid
)
{
    BOOL        fRet;
    OID         oid = NULL;
    DWORD       cb;

    if (!PkiAsn1FromObjectIdentifier(
        pooid->count,
        pooid->value,
        NULL,
        &cb))
    goto PkiAsn1FromObjectIdentifierSizeError;
    if (NULL == (oid = (OID)SSAlloc( cb)))
        goto OidAllocError;
    if (!PkiAsn1FromObjectIdentifier(
        pooid->count,
        pooid->value,
        oid,
        &cb))
    goto PkiAsn1FromObjectIdentifierError;

    fRet = TRUE;
CommonReturn:
    *poid = oid;
    return fRet;

ErrorReturn:
    SSFree(oid);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OidAllocError)
SET_ERROR(PkiAsn1FromObjectIdentifierSizeError ,CRYPT_E_OID_FORMAT)
SET_ERROR(PkiAsn1FromObjectIdentifierError     ,CRYPT_E_OID_FORMAT)
}

//+-------------------------------------------------------------------------
//  Function:   IPFX_EqualObjectIDs
//
//  Compare 2 OSS object id's.
//
//  Returns:    FALSE iff !equal
//--------------------------------------------------------------------------
BOOL
WINAPI
IPFX_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2)
{
    BOOL        fRet;
    DWORD       i;
    PDWORD      pdw1;
    PDWORD      pdw2;

    if (poid1->count != poid2->count)
        goto Unequal;
    for (i=poid1->count, pdw1=poid1->value, pdw2=poid2->value;
            (i>0) && (*pdw1==*pdw2);
            i--, pdw1++, pdw2++)
        ;
    if (i>0)
        goto Unequal;

    fRet = TRUE;        // equal
CommonReturn:
    return fRet;

Unequal:
    fRet = FALSE;       // !equal
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  Function:   PfxExportCreate
//
//  Synopsis:   Prepare the PFX for export
//
//  Returns:    NULL iff failed
//--------------------------------------------------------------------------
HPFX
PFXAPI
PfxExportCreate (
    LPCWSTR             szPassword
)
{
    PPFX_INFO       ppfx  = NULL;
    PCCERT_CONTEXT  pcctx = NULL;

    // Create the HPFX
    if (NULL == (ppfx = (PPFX_INFO)SSAlloc(sizeof(PFX_INFO))))
        goto PfxInfoAllocError;
    ZeroMemory(ppfx, sizeof(PFX_INFO));

    if (szPassword)
    {
        if (NULL == (ppfx->szPassword = (LPWSTR)SSAlloc(WSZ_BYTECOUNT(szPassword)) ))
            goto PfxInfoAllocError;

        CopyMemory(ppfx->szPassword, szPassword, WSZ_BYTECOUNT(szPassword));
    }
    else
    {
        ppfx->szPassword = NULL;
    }

CommonReturn:
    // free pcctx
    return (HPFX)ppfx;

ErrorReturn:
    PfxCloseHandle((HPFX)ppfx);
    ppfx = NULL;
    goto CommonReturn;

TRACE_ERROR(PfxInfoAllocError)
}



BOOL ASNFreeSafeBag(SafeBag* pBag)
{
    DWORD iAttr, iAnys;

    if (pBag->safeBagAttribs.value)
    {
        if (pBag->safeBagContent.value)
        {
            SSFree(pBag->safeBagContent.value);
            pBag->safeBagContent.value = NULL;
        }

        for (iAttr=0; iAttr<pBag->safeBagAttribs.count; iAttr++)
        {
            for (iAnys=0; iAnys<pBag->safeBagAttribs.value[iAttr].attributeValue.count; iAnys++)
            {
                if (pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value)
                    SSFree(pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value);

                pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value = NULL;
            }

            SSFree(pBag->safeBagAttribs.value[iAttr].attributeValue.value);
        }

        SSFree(pBag->safeBagAttribs.value);
        pBag->safeBagAttribs.value = NULL;
        pBag->safeBagAttribs.count = 0;
    }

    SSFree(pBag);

    return TRUE;
}



//+-------------------------------------------------------------------------
//  Function:  PfxCloseHandle
//
//  Synopsis:  Free all resources associated with the hpfx
//
//  Returns:   error code
//--------------------------------------------------------------------------
BOOL
PFXAPI
PfxCloseHandle (
    IN HPFX hpfx)
{
    BOOL            fRet = FALSE;
    PPFX_INFO       pPfx = (PPFX_INFO)hpfx;
    DWORD           i;


    if (pPfx)
    {
        if (pPfx->szPassword)
            SSFree(pPfx->szPassword);

        // keys struct
        for (i=0; i<pPfx->cKeys; i++)
        {
            ASNFreeSafeBag((SafeBag*)pPfx->rgKeys[i]);
            pPfx->rgKeys[i] = NULL;
        }

        SSFree(pPfx->rgKeys);
        pPfx->rgKeys = NULL;
        pPfx->cKeys = 0;

        // shrouded keys
        for (i=0; i<pPfx->cShroudedKeys; i++)
        {
            ASNFreeSafeBag((SafeBag*)pPfx->rgShroudedKeys[i]);
            pPfx->rgShroudedKeys[i] = NULL;
        }

        SSFree(pPfx->rgShroudedKeys);
        pPfx->rgShroudedKeys = NULL;
        pPfx->cShroudedKeys = 0;


        // certcrl struct
        for (i=0; i<pPfx->cCertcrls; i++)
        {
            ASNFreeSafeBag((SafeBag*)pPfx->rgCertcrls[i]);
            pPfx->rgCertcrls[i] = NULL;
        }

        SSFree(pPfx->rgCertcrls);
        pPfx->rgCertcrls = NULL;
        pPfx->cCertcrls = 0;



        // secrets struct
        for (i=0; i<pPfx->cSecrets; i++)
        {
            ASNFreeSafeBag((SafeBag*)pPfx->rgSecrets[i]);
            pPfx->rgSecrets[i] = NULL;
        }

        SSFree(pPfx->rgSecrets);
        pPfx->rgSecrets = NULL;
        pPfx->cSecrets = 0;


        SSFree(pPfx);
    }

    fRet = TRUE;

//Ret:
    return fRet;
}



BOOL
MakeEncodedCertBag(
    BYTE *pbEncodedCert,
    DWORD cbEncodedCert,
    BYTE *pbEncodedCertBag,
    DWORD *pcbEncodedCertBag
    )
{

    BOOL            fRet = TRUE;
    DWORD           dwErr;

    OctetStringType encodedCert;
    DWORD           cbCertAsOctetString = 0;
    BYTE            *pbCertAsOctetString = NULL;
    DWORD           dwBytesNeeded = 0;
    CertBag         certBag;
    BYTE            *pbEncoded = NULL;
    DWORD           cbEncoded = 0;
    ASN1encoding_t  pEnc = GetEncoder();

    // wrap the encoded cert in an OCTET_STRING
    encodedCert.length = cbEncodedCert;
    encodedCert.value = pbEncodedCert;

    if (0 != PkiAsn1Encode(
            pEnc,
            &encodedCert,
            OctetStringType_PDU,
            &pbCertAsOctetString,
            &cbCertAsOctetString))
        goto SetPFXEncodeError;

    // setup and encode the CertBag

    // convert the X509Cert oid from a string to an ASN1 ObjectIdentifier
    if (!IPFX_Asn1ToObjectID(szOID_PKCS_12_x509Cert, &certBag.certType)) {
        goto ErrorReturn;
    }

    certBag.value.length = cbCertAsOctetString;
    certBag.value.value = pbCertAsOctetString;

    if (0 != PkiAsn1Encode(
            pEnc,
            &certBag,
            CertBag_PDU,
            &pbEncoded,
            &cbEncoded))
        goto SetPFXEncodeError;

    // check to see if the caller has enough space for the data
    if ((0 != *pcbEncodedCertBag) && (*pcbEncodedCertBag < cbEncoded)) {
        goto ErrorReturn;
    }
    else if (0 != *pcbEncodedCertBag) {
        memcpy(pbEncodedCertBag, pbEncoded, cbEncoded);
    }

    goto CommonReturn;

SetPFXEncodeError:
    SetLastError(CRYPT_E_BAD_ENCODE);
ErrorReturn:
    fRet = FALSE;

CommonReturn:

    // save last error from TLS madness
    dwErr = GetLastError();

    *pcbEncodedCertBag = cbEncoded;

    PkiAsn1FreeEncoded(pEnc, pbCertAsOctetString);

    PkiAsn1FreeEncoded(pEnc, pbEncoded);

    // save last error from TLS madness
    SetLastError(dwErr);

    return fRet;
}



BOOL
GetEncodedCertFromEncodedCertBag(
    BYTE    *pbEncodedCertBag,
    DWORD   cbEncodedCertBag,
    BYTE    *pbEncodedCert,
    DWORD   *pcbEncodedCert)
{
    BOOL            fRet = TRUE;
    DWORD           dwErr;

    CertBag         *pCertBag = NULL;
    OID             oid = NULL;
    OctetStringType *pEncodedCert = NULL;
    ASN1decoding_t  pDec = GetDecoder();


    // decode the cert bag
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pCertBag,
            CertBag_PDU,
            pbEncodedCertBag,
            cbEncodedCertBag))
        goto SetPFXDecodeError;

    // make sure this is a X509 cert since that is all we support
    if (!IPFX_Asn1FromObjectID(&pCertBag->certType,  &oid))
        goto ErrorReturn;

    // only support SHA1
    if (0 != strcmp( oid, szOID_PKCS_12_x509Cert))
        goto SetPFXDecodeError;

    // strip off the octet string wrapper of the encoded cert
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pEncodedCert,
            OctetStringType_PDU,
            (BYTE *) pCertBag->value.value,
            pCertBag->value.length))
        goto SetPFXDecodeError;

    // check to see if the caller has enough space for the data
    if ((0 != *pcbEncodedCert) && (*pcbEncodedCert < (DWORD) pEncodedCert->length)) {
        goto ErrorReturn;
    }
    else if (0 != *pcbEncodedCert) {
        memcpy(pbEncodedCert, pEncodedCert->value, pEncodedCert->length);
    }

    goto CommonReturn;


SetPFXDecodeError:
    SetLastError(CRYPT_E_BAD_ENCODE);
ErrorReturn:
    fRet = FALSE;
CommonReturn:

    // save last error from TLS madness
    dwErr = GetLastError();

    if (pEncodedCert)
        *pcbEncodedCert = pEncodedCert->length;

    PkiAsn1FreeDecoded(pDec, pCertBag, CertBag_PDU);
    PkiAsn1FreeDecoded(pDec, pEncodedCert, OctetStringType_PDU);

    if (oid)
        SSFree(oid);

    // save last error from TLS madness
    SetLastError(dwErr);

    return fRet;
}


BOOL
GetSaltAndIterationCount(
    BYTE    *pbParameters,
    DWORD   cbParameters,
    BYTE    **ppbSalt,
    DWORD   *pcbSalt,
    int     *piIterationCount
    )
{
    BOOL            fRet = TRUE;
    DWORD           dwErr;

    PBEParameter    *pPBEParameter = NULL;
    ASN1decoding_t  pDec = GetDecoder();

    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pPBEParameter,
            PBEParameter_PDU,
            pbParameters,
            cbParameters))
        goto SetPFXDecodeError;

    if (NULL == (*ppbSalt = (BYTE *) SSAlloc(pPBEParameter->salt.length)))
        goto ErrorReturn;

    memcpy(*ppbSalt, pPBEParameter->salt.value, pPBEParameter->salt.length);
    *pcbSalt = pPBEParameter->salt.length;
    *piIterationCount = pPBEParameter->iterationCount;

    goto Ret;

SetPFXDecodeError:
    SetLastError(CRYPT_E_BAD_ENCODE);
    fRet = FALSE;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:

    // save last error from TLS madness
    dwErr = GetLastError();

    PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);

    // save last error from TLS madness
    SetLastError(dwErr);

    return fRet;

}

BOOL
SetSaltAndIterationCount(
    BYTE    **ppbParameters,
    DWORD   *pcbParameters,
    BYTE    *pbSalt,
    DWORD   cbSalt,
    int     iIterationCount
    )
{
    BOOL            fRet = TRUE;
    DWORD           dwErr;

    PBEParameter    sPBEParameter;
    sPBEParameter.salt.length = cbSalt;
    sPBEParameter.salt.value = pbSalt;
    sPBEParameter.iterationCount = iIterationCount;

    BYTE            *pbEncoded = NULL;
    DWORD           cbEncoded;
    ASN1encoding_t  pEnc = GetEncoder();

    if (0 != PkiAsn1Encode(
            pEnc,
            &sPBEParameter,
            PBEParameter_PDU,
            &pbEncoded,
            &cbEncoded))
        goto SetPFXDecodeError;

    if (NULL == (*ppbParameters = (BYTE *) SSAlloc(cbEncoded)))
        goto ErrorReturn;

    memcpy(*ppbParameters, pbEncoded, cbEncoded);
    *pcbParameters = cbEncoded;

    goto Ret;

SetPFXDecodeError:
    SetLastError(CRYPT_E_BAD_ENCODE);
    fRet = FALSE;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:

    // save last error from TLS madness
    dwErr = GetLastError();

    PkiAsn1FreeEncoded(pEnc, pbEncoded);

    // save last error from TLS madness
    SetLastError(dwErr);

    return fRet;

}


///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////

// wrap up data from pfx_info.safeContents area
BOOL
PFXAPI
PfxExportBlob
(
    HPFX    hpfx,
    PBYTE   pbOut,
    DWORD*  pcbOut,
    DWORD   dwFlags
)
{
    BOOL                fRet = FALSE;
    BOOL                fSizeOnly = (pbOut==NULL);

    DWORD               dwErr;
    PPFX_INFO           ppfx = (PPFX_INFO)hpfx;

    BYTE                rgbSafeMac[A_SHA_DIGEST_LEN];
    BYTE                rgbMacSalt[A_SHA_DIGEST_LEN];

    OID                 oid = NULL;
    EncryptedData       EncrData;           MAKEZERO(EncrData);
    OctetStringType     OctetStr;           MAKEZERO(OctetStr);
    AuthenticatedSafes  AuthSafes;          MAKEZERO(AuthSafes);
    PBEParameter        PbeParam;           MAKEZERO(PbeParam);
    ContentInfo         rgCntInfo[2];       memset(&(rgCntInfo[0]), 0, sizeof(rgCntInfo));
    SafeContents        SafeCnts;           MAKEZERO(SafeCnts);
    PFX                 sPfx;               MAKEZERO(sPfx);

    BYTE                *pbEncoded = NULL;
    DWORD               cbEncoded;
    ASN1encoding_t      pEnc = GetEncoder();

    PBYTE               pbEncrData = NULL;
    DWORD               cbEncrData;

    DWORD               i;

    // multi bags with differing security levels
    int                 iLevel, iBagSecurityLevels = 0;
    BOOL                fNoSecurity, fLowSecurity, fHighSecurity;
    DWORD               dwEncrAlg;

    HCRYPTPROV          hVerifyProv = NULL;

    if (!CryptAcquireContext(&hVerifyProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        goto ErrorOut;

    // Encode all SafeBags
    fNoSecurity = (ppfx->cShroudedKeys != 0);                   // no encr on these items
    fLowSecurity = ((ppfx->cSecrets + ppfx->cCertcrls) != 0);   // low level crypto on these items
    fHighSecurity = (ppfx->cKeys != 0);                         // high level crypto on these items

    iBagSecurityLevels = (fNoSecurity ? 1:0) + (fLowSecurity ? 1:0) + (fHighSecurity ? 1:0);
    assert(iBagSecurityLevels <= (sizeof(rgCntInfo)/sizeof(rgCntInfo[0])) );

    for (iLevel=0; iLevel<iBagSecurityLevels; iLevel++)
    {
        // clean up these each time through loop
        if (SafeCnts.value)
        {
            SSFree(SafeCnts.value);
            MAKEZERO(SafeCnts);
        }
        if (PbeParam.salt.value)
        {
            SSFree(PbeParam.salt.value);
            MAKEZERO(PbeParam);
        }
        if (EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value)
        {
            PkiAsn1FreeEncoded( pEnc, EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value);
            MAKEZERO(EncrData);
        }
        if (pbEncrData)
        {
            SSFree(pbEncrData);
            pbEncrData = NULL;
        }


        if (fNoSecurity)
        {
            // no security: bag already shrouded

            SafeCnts.count = ppfx->cShroudedKeys;
            if (NULL == (SafeCnts.value = (SafeBag*) SSAlloc(SafeCnts.count * sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            ZeroMemory(SafeCnts.value, SafeCnts.count * sizeof(SafeBag));

            for (i=0; i<(ppfx->cShroudedKeys); i++)
                CopyMemory(&SafeCnts.value[i], ppfx->rgShroudedKeys[i], sizeof(SafeBag));

            // bag already shrouded!
            dwEncrAlg = 0;

            // done with no security setup
            fNoSecurity = FALSE;
        }
        else if (fLowSecurity)
        {
            DWORD dw = 0;

            // do low security (keys/secrets)
            SafeCnts.count =    ppfx->cSecrets +
                                ppfx->cCertcrls;
            if (NULL == (SafeCnts.value = (SafeBag*) SSAlloc(SafeCnts.count * sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            ZeroMemory(SafeCnts.value, SafeCnts.count * sizeof(SafeBag));

            for (i=0; i<(ppfx->cSecrets); i++, dw++)
                CopyMemory(SafeCnts.value, ppfx->rgSecrets[i], sizeof(SafeBag));
            for (i=0; i<(ppfx->cCertcrls); i++, dw++)
                CopyMemory(&SafeCnts.value[dw], ppfx->rgCertcrls[i], sizeof(SafeBag));

            // encr alg present, type
            EncrData.encryptedContentInfo.contentEncryptionAlg.bit_mask |= parameters_present;
            if (!IPFX_Asn1ToObjectID(szOID_PKCS_12_pbeWithSHA1And40BitRC2, &EncrData.encryptedContentInfo.contentEncryptionAlg.algorithm))
                goto ErrorOut;

            dwEncrAlg = RC2_40;

            // done with low security setup
            fLowSecurity = FALSE;
        }
        else if (fHighSecurity)
        {
            // high security: need strength for unencr keys

            SafeCnts.count = ppfx->cKeys;
            if (NULL == (SafeCnts.value = (SafeBag*) SSAlloc(SafeCnts.count * sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            ZeroMemory(SafeCnts.value, SafeCnts.count * sizeof(SafeBag));

            for (i=0; i<(ppfx->cKeys); i++)
                CopyMemory(&SafeCnts.value[i], ppfx->rgKeys[i], sizeof(SafeBag));


            // encr alg present, type
            EncrData.encryptedContentInfo.contentEncryptionAlg.bit_mask |= parameters_present;
            if (!IPFX_Asn1ToObjectID(szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES, &EncrData.encryptedContentInfo.contentEncryptionAlg.algorithm))
                goto ErrorOut;


            // bag already shrouded!
            dwEncrAlg = TripleDES;

            // done with high security setup
            fHighSecurity = FALSE;
        }
        else
            break;  // no more bags


        // encode safecontents
        if (0 != PkiAsn1Encode(
                pEnc,
                &SafeCnts,
                SafeContents_PDU,
                &pbEncoded,
                &cbEncoded))
            goto SetPFXEncodeError;

        if (dwEncrAlg == 0)
        {
            // no encryption?
            OctetStr.length = cbEncoded;
            OctetStr.value = pbEncoded;

            // jam octet string into contentInfo
            if (0 != PkiAsn1Encode(
                    pEnc,
                    &OctetStr,
                    OctetStringType_PDU,
                    &pbEncoded,
                    &cbEncoded))
                goto SetPFXEncodeError;

            if (OctetStr.value)
            {
                PkiAsn1FreeEncoded(pEnc, OctetStr.value);
                OctetStr.value = NULL;
            }

            // set up content info struct
            if (!IPFX_Asn1ToObjectID(
                    szOID_RSA_data,
                    &rgCntInfo[iLevel].contentType))
                goto ErrorOut;

            rgCntInfo[iLevel].content.length = cbEncoded;
            rgCntInfo[iLevel].content.value = pbEncoded;
            rgCntInfo[iLevel].bit_mask = content_present;
        }
        else
        {
            cbEncrData = cbEncoded;
            if (NULL == (pbEncrData = (PBYTE)SSAlloc(cbEncoded)) )
                goto SetPfxAllocError;

            CopyMemory(pbEncrData, pbEncoded, cbEncrData);
            PkiAsn1FreeEncoded(pEnc, pbEncoded);

            // PBE Param
            PbeParam.iterationCount = PKCS12_ENCR_PWD_ITERATIONS;
            if (NULL == (PbeParam.salt.value = (BYTE *) SSAlloc(PBE_SALT_LENGTH) ))
                goto SetPfxAllocError;

            PbeParam.salt.length = PBE_SALT_LENGTH;

            if (!CryptGenRandom(hVerifyProv, PBE_SALT_LENGTH, PbeParam.salt.value))
                goto ErrorOut;

            if (0 != PkiAsn1Encode(
                    pEnc,
                    &PbeParam,
                    PBEParameter_PDU,
                    &pbEncoded,
                    &cbEncoded))
                goto SetPFXEncodeError;

            EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.length = cbEncoded;
            EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value = pbEncoded;

            // ENCRYPT safeContents into encryptedData
            // using szPassword (in place)
            if (!PFXPasswordEncryptData(
                    dwEncrAlg,

                    ppfx->szPassword,               // pwd itself

                    (fSizeOnly) ? 1 : PbeParam.iterationCount,  // don't do iterations if only returning size
                    PbeParam.salt.value,            // pkcs5 salt
                    PbeParam.salt.length,

                    &pbEncrData,
                    &cbEncrData))
                goto SetPFXEncryptError;

            // encode content to encryptedContentInfo
            EncrData.encryptedContentInfo.bit_mask |= encryptedContent_present;
            if (!IPFX_Asn1ToObjectID(szOID_RSA_data, &EncrData.encryptedContentInfo.contentType))
                goto ErrorOut;
            EncrData.encryptedContentInfo.encryptedContent.length = cbEncrData;
            EncrData.encryptedContentInfo.encryptedContent.value = pbEncrData;

            if (0 != PkiAsn1Encode(
                    pEnc,
                    &EncrData,
                    EncryptedData_PDU,
                    &pbEncoded,
                    &cbEncoded))
                goto SetPFXEncodeError;

            // jam octet string into contentInfo
            // set up content info struct
            if (!IPFX_Asn1ToObjectID(
                    szOID_RSA_encryptedData,
                    &rgCntInfo[iLevel].contentType))
                goto ErrorOut;

            rgCntInfo[iLevel].content.length = cbEncoded;
            rgCntInfo[iLevel].content.value = pbEncoded;
            rgCntInfo[iLevel].bit_mask = content_present;
        }
    }

    AuthSafes.count = iBagSecurityLevels;
    AuthSafes.value = rgCntInfo;

    // set up authenticated safe struct
    if (0 != PkiAsn1Encode(
            pEnc,
            &AuthSafes,
            AuthenticatedSafes_PDU,
            &pbEncoded,
            &cbEncoded))
        goto SetPFXEncodeError;

    {
        sPfx.macData.bit_mask = macIterationCount_present;
        sPfx.macData.safeMac.digest.length = sizeof(rgbSafeMac);
        sPfx.macData.safeMac.digest.value = rgbSafeMac;

        // COMPATIBILITY MODE: export with macIterationCount == 1
        if (dwFlags & PKCS12_ENHANCED_STRENGTH_ENCODING)
            sPfx.macData.macIterationCount = PKCS12_MAC_PWD_ITERATIONS;
        else
            sPfx.macData.macIterationCount = 1;


        if (!IPFX_Asn1ToObjectID( szOID_OIWSEC_sha1, &sPfx.macData.safeMac.digestAlgorithm.algorithm))
            goto ErrorOut;

        sPfx.macData.macSalt.length = sizeof(rgbMacSalt);
        sPfx.macData.macSalt.value = rgbMacSalt;

        if (!CryptGenRandom(hVerifyProv, sPfx.macData.macSalt.length, sPfx.macData.macSalt.value))
            goto ErrorOut;

        // create MAC
        if (!FGenerateMAC(
                ppfx->szPassword,
                sPfx.macData.macSalt.value,         // pb salt
                sPfx.macData.macSalt.length,        // cb salt
                (fSizeOnly) ? 1 : sPfx.macData.macIterationCount,   // don't do iterations if only returning size
                pbEncoded,                          // pb data
                cbEncoded,                          // cb data
                sPfx.macData.safeMac.digest.value))
            goto SetPFXPasswordError;
    }
    sPfx.bit_mask |= macData_present;

    // stream to octet string
    OctetStr.length = cbEncoded;
    OctetStr.value = pbEncoded;
    if (0 != PkiAsn1Encode(
            pEnc,
            &OctetStr,
            OctetStringType_PDU,
            &pbEncoded,
            &cbEncoded))
        goto SetPFXEncodeError;

    // take encoded authsafes octet string, encode in PFX pdu
    if (!IPFX_Asn1ToObjectID(
            szOID_RSA_data,
            &sPfx.authSafes.contentType))
        goto ErrorOut;
    sPfx.authSafes.content.length = cbEncoded;
    sPfx.authSafes.content.value = pbEncoded;
    sPfx.authSafes.bit_mask = content_present;
    sPfx.version = CURRENT_PFX_VERSION;
    if (0 != PkiAsn1Encode(
            pEnc,
            &sPfx,
            PFX_PDU,
            &pbEncoded,
            &cbEncoded))
        goto SetPFXEncodeError;

    fRet = TRUE;
    goto Ret;


SetPFXEncodeError:
    SetLastError(CRYPT_E_BAD_ENCODE);
    goto Ret;

SetPFXPasswordError:
    SetLastError(ERROR_INVALID_PASSWORD);
    goto Ret;

SetPFXEncryptError:
    SetLastError(NTE_FAIL);
    goto Ret;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    goto Ret;

ErrorOut:   // error already set; just return failure
Ret:
    // save last error from TLS madness
    dwErr = GetLastError();

    if (hVerifyProv)
        CryptReleaseContext(hVerifyProv, 0);

    if (EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value)
        PkiAsn1FreeEncoded( pEnc, EncrData.encryptedContentInfo.contentEncryptionAlg.parameters.value);

    for(iLevel=0; iLevel<iBagSecurityLevels; iLevel++)
    {
        if (rgCntInfo[iLevel].content.value)
            PkiAsn1FreeEncoded( pEnc, rgCntInfo[iLevel].content.value);
    }

    PkiAsn1FreeEncoded(pEnc, OctetStr.value);
    PkiAsn1FreeEncoded(pEnc, sPfx.authSafes.content.value);

    if (pbEncrData)
        SSFree(pbEncrData);

    if (SafeCnts.value)
        SSFree(SafeCnts.value);

    if (PbeParam.salt.value)
        SSFree(PbeParam.salt.value);

    if (fRet)
    {
        if (pbOut == NULL)
        {
            // report size only
            *pcbOut = cbEncoded;
        }
        else if (*pcbOut < cbEncoded)
        {
            // report that we need a bigger buffer
            *pcbOut = cbEncoded;
            fRet = FALSE;
        }
        else
        {
            // give full results
            CopyMemory( pbOut, pbEncoded, cbEncoded);
            *pcbOut = cbEncoded;
        }
    }
    else
        *pcbOut = 0;


    PkiAsn1FreeEncoded(pEnc, pbEncoded);

    // save last error from TLS madness
    SetLastError(dwErr);

    return fRet;
}

HPFX
PFXAPI
PfxImportBlob
(
    LPCWSTR  szPassword,
    PBYTE   pbIn,
    DWORD   cbIn,
    DWORD   dwFlags
)
{
    PPFX_INFO           ppfx = NULL;
    BOOL                fRet = FALSE;
    DWORD               dwErr;

    int                 iEncrType;
    OID                 oid = NULL;
    DWORD               iAuthSafes;         // # of safes in a pfx bag

    PFX                 *psPfx = NULL;
    OctetStringType     *pOctetString = NULL;
    AuthenticatedSafes  *pAuthSafes = NULL;
    PBEParameter        *pPBEParameter = NULL;
    EncryptedData       *pEncrData = NULL;
    SafeContents        *pSafeCnts = NULL;
    OctetStringType     *pNonEncryptedOctetString = NULL;

    DWORD               cbDecrData;
    PBYTE               pbDecrData = NULL;

    BYTE                *pbEncoded = NULL;
    DWORD               cbEncoded;
    ASN1decoding_t      pDec = GetDecoder();

    // alloc return struct
    if (NULL == (ppfx = (PFX_INFO*)SSAlloc(sizeof(PFX_INFO)) ))
        goto SetPfxAllocError;

    ZeroMemory(ppfx, sizeof(PFX_INFO));


    // Crack the PFX blob
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&psPfx,
            PFX_PDU,
            pbIn,
            cbIn))
        goto SetPFXDecodeError;

    // check version of the PFX bag
    if (psPfx->version != CURRENT_PFX_VERSION)
        goto SetPFXDecodeError;

    // info blurted into psPfx(PFX) - ensure content present
    if (0 == (psPfx->authSafes.bit_mask & content_present))
        goto SetPFXDecodeError;

    // could be data/signeddata
    // UNDONE: only support szOID_RSA_data
    if (!IPFX_Asn1FromObjectID( &psPfx->authSafes.contentType,  &oid))
        goto ErrorOut;
    if (0 != strcmp( oid, szOID_RSA_data))
        goto SetPFXDecodeError;
    SSFree(oid);
    // DSIE: Bug 144526.
    oid = NULL;

    // content is data: decode
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pOctetString,
            OctetStringType_PDU,
            (BYTE *) psPfx->authSafes.content.value,
            psPfx->authSafes.content.length))
        goto SetPFXDecodeError;

    if (0 != (psPfx->bit_mask & macData_present))
    {
        BYTE rgbMAC[A_SHA_DIGEST_LEN];

        if (!IPFX_Asn1FromObjectID( &psPfx->macData.safeMac.digestAlgorithm.algorithm,  &oid))
            goto ErrorOut;

        // only support SHA1
        if (0 != strcmp( oid, szOID_OIWSEC_sha1))
            goto SetPFXDecodeError;
        SSFree(oid);
        // DSIE: Bug 144526.
        oid = NULL;

        if (psPfx->macData.safeMac.digest.length != A_SHA_DIGEST_LEN)
            goto SetPFXIntegrityError;

        // check MAC
        // if there is no iterationCount then 1 is the default
        if (!(psPfx->macData.bit_mask & macIterationCount_present))
        {
        if (!FGenerateMAC(
                szPassword,
                psPfx->macData.macSalt.value,   // pb salt
                psPfx->macData.macSalt.length,  // cb salt
                1,
                pOctetString->value,            // pb data
                pOctetString->length,           // cb data
                rgbMAC))
            goto SetPFXIntegrityError;
        }
        else
        {
            if (!FGenerateMAC(
                szPassword,
                psPfx->macData.macSalt.value,   // pb salt
                psPfx->macData.macSalt.length,  // cb salt
                (DWORD)psPfx->macData.macIterationCount,
                pOctetString->value,            // pb data
                pOctetString->length,           // cb data
                rgbMAC))
            goto SetPFXIntegrityError;
        }

        if (0 != memcmp(rgbMAC, psPfx->macData.safeMac.digest.value, A_SHA_DIGEST_LEN))
            goto SetPFXIntegrityError;
    }

    // now we have octet string: this is an encoded authSafe
    if (0 != PkiAsn1Decode(
            pDec,
            (void **)&pAuthSafes,
            AuthenticatedSafes_PDU,
            pOctetString->value,
            pOctetString->length))
        goto SetPFXDecodeError;

    // handle multiple safes
    for (iAuthSafes = 0; iAuthSafes < pAuthSafes->count; iAuthSafes++)
    {
        // could be encryptedData/envelopedData

        // check to see if the content is szOID_RSA_encryptedData or szOID_RSA_data
        if (!IPFX_Asn1FromObjectID( &pAuthSafes->value[iAuthSafes].contentType,  &oid))
            goto ErrorOut;
        if (0 == strcmp( oid, szOID_RSA_encryptedData))
        {
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;

            // decode content to encryptedData
            if (0 != PkiAsn1Decode(
                    pDec,
                    (void **)&pEncrData,
                    EncryptedData_PDU,
                    (BYTE *) pAuthSafes->value[iAuthSafes].content.value,
                    pAuthSafes->value[iAuthSafes].content.length))
                goto SetPFXDecodeError;

            // chk version
            if (pEncrData->version != 0)
                goto SetPFXDecodeError;

            // chk content present, type
            if (0 == (pEncrData->encryptedContentInfo.bit_mask & encryptedContent_present))
                goto SetPFXDecodeError;
            if (!IPFX_Asn1FromObjectID(&pEncrData->encryptedContentInfo.contentType, &oid))
                goto ErrorOut;
            if (0 != strcmp( oid, szOID_RSA_data))
                goto SetPFXDecodeError;
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;

            // chk encr alg present, type
            if (0 == (pEncrData->encryptedContentInfo.contentEncryptionAlg.bit_mask & parameters_present))
                goto SetPFXDecodeError;
            if (!IPFX_Asn1FromObjectID(&pEncrData->encryptedContentInfo.contentEncryptionAlg.algorithm, &oid))
                goto ErrorOut;

            if (0 != PkiAsn1Decode(
                    pDec,
                    (void **)&pPBEParameter,
                    PBEParameter_PDU,
                    (BYTE *) pEncrData->encryptedContentInfo.contentEncryptionAlg.parameters.value,
                    pEncrData->encryptedContentInfo.contentEncryptionAlg.parameters.length))
                goto SetPFXDecodeError;


            if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And40BitRC2))
            {
                iEncrType = RC2_40;
            }
            else if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And40BitRC4))
            {
                iEncrType = RC4_40;
            }
            else if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And128BitRC2))
            {
                iEncrType = RC2_128;
            }
            else if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And128BitRC4))
            {
                iEncrType = RC4_128;
            }
            else if (0 == strcmp( oid, szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES))
            {
                // FIX - we need to differentiate between 2 and 3 key triple des
                iEncrType = TripleDES;
            }
            else
                goto SetPFXAlgIDError;
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;

            // DECRYPT encryptedData using szPassword (in place)
            cbDecrData = pEncrData->encryptedContentInfo.encryptedContent.length;
            if (NULL == (pbDecrData = (PBYTE)SSAlloc(pEncrData->encryptedContentInfo.encryptedContent.length)) )
                goto SetPfxAllocError;

            CopyMemory(pbDecrData, pEncrData->encryptedContentInfo.encryptedContent.value, cbDecrData);

            if (!PFXPasswordDecryptData(
                    iEncrType, // encr type
                    szPassword,

                    pPBEParameter->iterationCount,
                    pPBEParameter->salt.value,      // pkcs5 salt
                    pPBEParameter->salt.length,

                    &pbDecrData,
                    (PDWORD)&cbDecrData))
                goto SetPFXDecryptError;

            // set up to decode the  SafeContents
            cbEncoded = cbDecrData;
            pbEncoded = pbDecrData;
        }
        else if (0 == strcmp( oid, szOID_RSA_data))
        {
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;

            // strip off the octet string wrapper
            if (0 != PkiAsn1Decode(
                    pDec,
                    (void **)&pNonEncryptedOctetString,
                    OctetStringType_PDU,
                    (BYTE *) pAuthSafes->value[iAuthSafes].content.value,
                    pAuthSafes->value[iAuthSafes].content.length))
                goto SetPFXDecodeError;

            // the safe isn't encrypted, so just setup to decode the data as SafeContents
            cbEncoded = pNonEncryptedOctetString->length;
            pbEncoded = pNonEncryptedOctetString->value;
        }
        else
        {
            SSFree(oid);
            // DSIE: Bug 144526.
            oid = NULL;
            goto SetPFXDecodeError;
        }

        // decode the SafeContents, it is either the plaintext encryptedData or the original data
        if (0 != PkiAsn1Decode(
                pDec,
                (void **)&pSafeCnts,
                SafeContents_PDU,
                pbEncoded,
                cbEncoded))
            goto SetPFXDecodeError;

        // tear pSafeCnts apart, mash into ppfx
        if (!FPFXDumpSafeCntsToHPFX(pSafeCnts, ppfx))
             goto SetPFXDecodeError;

        // loop cleanup
        if (pEncrData) {
            PkiAsn1FreeDecoded(pDec, pEncrData, EncryptedData_PDU);
            pEncrData = NULL;
        }

        if (pPBEParameter) {
            PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);
            pPBEParameter = NULL;
        }

        if (pNonEncryptedOctetString) {
            PkiAsn1FreeDecoded(pDec, pNonEncryptedOctetString,
                OctetStringType_PDU);
            pNonEncryptedOctetString = NULL;
        }

        PkiAsn1FreeDecoded(pDec, pSafeCnts, SafeContents_PDU);
        pSafeCnts = NULL;

        if (pbDecrData)
        {
            SSFree(pbDecrData);
            pbDecrData = NULL;
        }
    }

    fRet = TRUE;
    goto Ret;


SetPFXAlgIDError:
    SetLastError(NTE_BAD_ALGID);
    goto Ret;

SetPFXIntegrityError:
    SetLastError(ERROR_INVALID_PASSWORD);
    goto Ret;


SetPFXDecodeError:
    SetLastError(CRYPT_E_BAD_ENCODE);
    goto Ret;

SetPFXDecryptError:
    SetLastError(NTE_FAIL);
    goto Ret;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    goto Ret;

ErrorOut:
Ret:

    // save any error conditions
    dwErr = GetLastError();

    PkiAsn1FreeDecoded(pDec, psPfx, PFX_PDU);
    PkiAsn1FreeDecoded(pDec, pOctetString, OctetStringType_PDU);
    PkiAsn1FreeDecoded(pDec, pAuthSafes, AuthenticatedSafes_PDU);
    PkiAsn1FreeDecoded(pDec, pEncrData, EncryptedData_PDU);
    PkiAsn1FreeDecoded(pDec, pPBEParameter, PBEParameter_PDU);
    PkiAsn1FreeDecoded(pDec, pSafeCnts, SafeContents_PDU);

    // DSIE: Bug 144526.
    if (oid)
        SSFree(oid);

    if (pbDecrData)
        SSFree(pbDecrData);

    if (!fRet)
    {
        if (ppfx)
            SSFree(ppfx);

        ppfx = NULL;
    }

    // restore error conditions AFTER GetDecoder() calls, since TLS will clobber
    SetLastError(dwErr);

    return (HPFX)ppfx;
}





BOOL FPFXDumpSafeCntsToHPFX(SafeContents* pSafeCnts, HPFX hpfx)
{
    PPFX_INFO           ppfx = (PPFX_INFO)hpfx;

    // sort and dump bags into correct areas
    ObjectID oKeyBag, oCertBag, oShroudedKeyBag;
    DWORD dw, iAttr, iAnys;

    ZeroMemory(&oKeyBag, sizeof(ObjectID));
    ZeroMemory(&oCertBag, sizeof(ObjectID));
    ZeroMemory(&oShroudedKeyBag, sizeof(ObjectID));

    if (!IPFX_Asn1ToObjectID( &szOID_PKCS_12_KEY_BAG, &oKeyBag))
        return FALSE;

    if (!IPFX_Asn1ToObjectID( &szOID_PKCS_12_CERT_BAG, &oCertBag))
        return FALSE;

    if (!IPFX_Asn1ToObjectID( &szOID_PKCS_12_SHROUDEDKEY_BAG, &oShroudedKeyBag))
        return FALSE;

    for (dw=0; dw<pSafeCnts->count; dw++)
    {
        SafeBag* pBag;
        VOID *pv = NULL;

// new begin
        // assign value to keys
        if (NULL == (pBag = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
            goto SetPfxAllocError;

        CopyMemory(pBag, &pSafeCnts->value[dw], sizeof (SafeBag));

        // obj id is static

        // alloc content
        if (NULL == (pBag->safeBagContent.value = (PBYTE)SSAlloc(pBag->safeBagContent.length) ))
            goto SetPfxAllocError;

        CopyMemory(pBag->safeBagContent.value, pSafeCnts->value[dw].safeBagContent.value, pBag->safeBagContent.length);

        // alloc attributes
        if (pBag->bit_mask & safeBagAttribs_present)
        {
            if (NULL == (pBag->safeBagAttribs.value = (Attribute*)SSAlloc(sizeof(Attribute) * pSafeCnts->value[dw].safeBagAttribs.count) ))
                goto SetPfxAllocError;

            for (iAttr=0; iAttr < pSafeCnts->value[dw].safeBagAttribs.count; iAttr++)
            {
                // copy static section of attribute
                CopyMemory(&pBag->safeBagAttribs.value[iAttr], &pSafeCnts->value[dw].safeBagAttribs.value[iAttr], sizeof(Attribute));

                // Alloc Attribute Anys
                if (pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.count != 0)
                {
                    if (NULL == (pBag->safeBagAttribs.value[iAttr].attributeValue.value = (Any*)SSAlloc(pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.count * sizeof(Any)) ))
                        goto SetPfxAllocError;

                    CopyMemory(pBag->safeBagAttribs.value[iAttr].attributeValue.value, pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.value, sizeof(Any));

                    for (iAnys=0; iAnys<pBag->safeBagAttribs.value[iAttr].attributeValue.count; iAnys++)
                    {
                        if (NULL == (pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value = (PBYTE)SSAlloc(pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.value[iAnys].length) ))
                            goto SetPfxAllocError;

                        CopyMemory(pBag->safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value, pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.value[iAnys].value, pSafeCnts->value[dw].safeBagAttribs.value[iAttr].attributeValue.value[iAnys].length);
                    }
                }
                else
                {
                    pBag->safeBagAttribs.value[iAttr].attributeValue.value = NULL;
                }
            }
        }
// new end

        if (IPFX_EqualObjectIDs(&pSafeCnts->value[dw].safeBagType, &oKeyBag) )
        {
            // inc size
            ppfx->cKeys++;
            if (ppfx->rgKeys)
            {
                pv = ppfx->rgKeys;
                #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
                ppfx->rgKeys = (void**)SSReAlloc(ppfx->rgKeys, ppfx->cKeys * sizeof(SafeBag*));
            }
            else
                ppfx->rgKeys = (void**)SSAlloc(ppfx->cKeys * sizeof(SafeBag*));

            if (ppfx->rgKeys == NULL)
            {
                if (pv != NULL)
                {
                    SSFree(pv);
                }

                goto SetPfxAllocError;
            }

            // assign to keys
            ppfx->rgKeys[ppfx->cKeys-1] = pBag;
        }
        else if (IPFX_EqualObjectIDs(&pSafeCnts->value[dw].safeBagType,
                &oShroudedKeyBag) )
        {
            // inc size
            ppfx->cShroudedKeys++;
            if (ppfx->rgShroudedKeys)
            {
                pv = ppfx->rgShroudedKeys;
                #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
                ppfx->rgShroudedKeys = (void**)SSReAlloc(ppfx->rgShroudedKeys, ppfx->cShroudedKeys * sizeof(SafeBag*));
            }
            else
                ppfx->rgShroudedKeys = (void**)SSAlloc(ppfx->cShroudedKeys * sizeof(SafeBag*));

            if (ppfx->rgShroudedKeys == NULL)
            {
                if (pv != NULL)
                {
                    SSFree(pv);
                }

                goto SetPfxAllocError;
            }

            // assign to keys
            ppfx->rgShroudedKeys[ppfx->cShroudedKeys-1] = pBag;
        }
        else if (IPFX_EqualObjectIDs(&pSafeCnts->value[dw].safeBagType,
                &oCertBag) )
        {
            // inc size
            ppfx->cCertcrls++;
            if (ppfx->rgCertcrls)
            {
                pv = ppfx->rgCertcrls;
                #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
                ppfx->rgCertcrls = (void**)SSReAlloc(ppfx->rgCertcrls, ppfx->cCertcrls * sizeof(SafeBag*));
            }
            else
                ppfx->rgCertcrls = (void**)SSAlloc(ppfx->cCertcrls * sizeof(SafeBag*));

            if (ppfx->rgCertcrls == NULL)
            {
                if (pv != NULL)
                {
                    SSFree(pv);
                }

                goto SetPfxAllocError;
            }

            // assign to certs/crls
            ppfx->rgCertcrls[ppfx->cCertcrls-1] = pBag;
        }
        else
        {
            // inc size
            ppfx->cSecrets++;
            if (ppfx->rgSecrets)
            {
                pv = ppfx->rgSecrets;
                #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
                ppfx->rgSecrets = (void**)SSReAlloc(ppfx->rgSecrets, ppfx->cSecrets * sizeof(SafeBag*));
            }
            else
                ppfx->rgSecrets = (void**)SSAlloc(ppfx->cSecrets * sizeof(SafeBag*));

            if (ppfx->rgSecrets == NULL)
            {
                if (pv != NULL)
                {
                    SSFree(pv);
                }

                goto SetPfxAllocError;
            }

            // assign to safebag
            ppfx->rgSecrets[ppfx->cSecrets-1] = pBag;
        }
    }

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}



BOOL CopyASNtoCryptSafeBag(
    SAFE_BAG*   pCryptBag,
    SafeBag*    pAsnBag)
{
    DWORD iAttrs, iAttr;

    // ensure target is zeroed
    ZeroMemory(pCryptBag, sizeof(SAFE_BAG));

    if (!IPFX_Asn1FromObjectID( &pAsnBag->safeBagType,  &pCryptBag->pszBagTypeOID))
        return FALSE;

    // copy bag contents
    pCryptBag->BagContents.cbData = pAsnBag->safeBagContent.length;
    if (NULL == (pCryptBag->BagContents.pbData = (PBYTE)SSAlloc(pCryptBag->BagContents.cbData) ))
        goto SetPfxAllocError;

    CopyMemory(pCryptBag->BagContents.pbData, pAsnBag->safeBagContent.value, pCryptBag->BagContents.cbData);

    pCryptBag->Attributes.cAttr = pAsnBag->safeBagAttribs.count;
    if (NULL == (pCryptBag->Attributes.rgAttr = (CRYPT_ATTRIBUTE*)SSAlloc(pCryptBag->Attributes.cAttr * sizeof(CRYPT_ATTRIBUTE)) ))
        goto SetPfxAllocError;

    // sizeof attribute data
    for (iAttrs=0; iAttrs<pAsnBag->safeBagAttribs.count; iAttrs++)
    {
        // pAsnBag->safeBagAttribs.value === attribute struct

        if (!IPFX_Asn1FromObjectID( &pAsnBag->safeBagAttribs.value[iAttrs].attributeType,  &pCryptBag->Attributes.rgAttr[iAttrs].pszObjId))
            continue;

        pCryptBag->Attributes.rgAttr[iAttrs].cValue = pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count;
        if (NULL == (pCryptBag->Attributes.rgAttr[iAttrs].rgValue = (CRYPT_ATTR_BLOB*)SSAlloc(pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count * sizeof(CRYPT_ATTR_BLOB)) ))
            goto SetPfxAllocError;

        for (iAttr=0; iAttr<pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count; iAttr++)
        {
            // alloc and copy: for every attribute in attrs
            pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].cbData = pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].length;
            if (NULL == (pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].pbData = (PBYTE)SSAlloc(pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].cbData) ))
                goto SetPfxAllocError;

            CopyMemory(pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].pbData, pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].value, pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].cbData);
        }
    }

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}


BOOL CopyCrypttoASNSafeBag(
    SAFE_BAG*   pCryptBag,
    SafeBag*    pAsnBag)
{
    DWORD iAttrs, iAttr;

    // ensure target is zeroed
    ZeroMemory(pAsnBag, sizeof(SafeBag));

    if (!IPFX_Asn1ToObjectID( pCryptBag->pszBagTypeOID, &pAsnBag->safeBagType))
        return FALSE;

    pAsnBag->safeBagContent.length = pCryptBag->BagContents.cbData;
    if (NULL == (pAsnBag->safeBagContent.value = (PBYTE)SSAlloc(pAsnBag->safeBagContent.length) ))
        goto SetPfxAllocError;

    CopyMemory(pAsnBag->safeBagContent.value, pCryptBag->BagContents.pbData, pAsnBag->safeBagContent.length);

    pAsnBag->safeBagAttribs.count = pCryptBag->Attributes.cAttr;
    if (NULL == (pAsnBag->safeBagAttribs.value = (Attribute*) SSAlloc(pAsnBag->safeBagAttribs.count * sizeof(Attribute)) ))
        goto SetPfxAllocError;

    //
    // always set the present bit for backwards compatibility
    //
    pAsnBag->bit_mask = safeBagAttribs_present;

    for (iAttrs=0; iAttrs<pCryptBag->Attributes.cAttr; iAttrs++)
    {
        //pAsnBag->bit_mask = safeBagAttribs_present;

        if (!IPFX_Asn1ToObjectID( pCryptBag->Attributes.rgAttr[iAttrs].pszObjId, &pAsnBag->safeBagAttribs.value[iAttrs].attributeType))
            continue;

        pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count = pCryptBag->Attributes.rgAttr[iAttrs].cValue;
        if (NULL == (pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value = (Any*)SSAlloc(pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.count * sizeof(Any)) ))
            goto SetPfxAllocError;


        for (iAttr=0; iAttr<pCryptBag->Attributes.rgAttr[iAttrs].cValue; iAttr++)
        {
            // for every attribute in attrs
            pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].length = pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].cbData;
            if (NULL == (pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].value = (PBYTE)SSAlloc(pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].length) ))
                goto SetPfxAllocError;

            CopyMemory(pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].value, pCryptBag->Attributes.rgAttr[iAttrs].rgValue[iAttr].pbData, pAsnBag->safeBagAttribs.value[iAttrs].attributeValue.value[iAttr].length);
        }
    }

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}

// new entry points for loading up the HPFX
BOOL PfxGetKeysAndCerts(
    HPFX hPfx,
    SAFE_CONTENTS* pContents
)
{
    PFX_INFO*   pPfx = (PFX_INFO*)hPfx;
    SafeBag*    pAsnBag;
    SAFE_BAG*   pCryptBag;
    DWORD       iTotal, iBag;
    DWORD       cSafeBags;

    pContents->cSafeBags = 0;
    cSafeBags = pPfx->cKeys + pPfx->cCertcrls + pPfx->cShroudedKeys;
    if (NULL == (pContents->pSafeBags = (SAFE_BAG*)SSAlloc(cSafeBags * sizeof(SAFE_BAG)) )) // make an array of safe bag *s
        goto SetPfxAllocError;

    pContents->cSafeBags = cSafeBags;

    for (iBag=0, iTotal=0; iBag<pPfx->cKeys; iBag++, iTotal++)
    {
        pCryptBag = &pContents->pSafeBags[iTotal];
        pAsnBag = (SafeBag*)pPfx->rgKeys[iBag];

        if (!CopyASNtoCryptSafeBag(pCryptBag, pAsnBag))
            continue;
    }

    iTotal = iBag;

    for (iBag=0; iBag<pPfx->cShroudedKeys; iBag++, iTotal++)
    {
        pCryptBag = &pContents->pSafeBags[iTotal];
        pAsnBag = (SafeBag*)pPfx->rgShroudedKeys[iBag];

        if (!CopyASNtoCryptSafeBag(pCryptBag, pAsnBag))
            continue;
    }

    for (iBag=0; iBag<pPfx->cCertcrls; iBag++, iTotal++)
    {
        pCryptBag = &pContents->pSafeBags[iTotal];
        pAsnBag = (SafeBag*)pPfx->rgCertcrls[iBag];

        if (!CopyASNtoCryptSafeBag(pCryptBag, pAsnBag))
            continue;
    }

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}


BOOL PfxAddSafeBags(
    HPFX hPfx,
    SAFE_BAG*   pSafeBags,
    DWORD       cSafeBags
)
{
    PFX_INFO* pPfx = (PFX_INFO*)hPfx;
    DWORD   i;

    for (i=0; i<cSafeBags; i++)
    {
        VOID *pv = NULL;

        if (0 == strcmp(pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_KEY_BAG))
        {
            pPfx->cKeys++;
            if (pPfx->rgKeys)
            {
                pv = pPfx->rgKeys;
                #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
                pPfx->rgKeys = (void**)SSReAlloc(pPfx->rgKeys, pPfx->cKeys*sizeof(SafeBag*));
            }
            else
                pPfx->rgKeys = (void**)SSAlloc(pPfx->cKeys*sizeof(SafeBag*));

            if (pPfx->rgKeys == NULL)
            {
                if (pv != NULL)
                {
                    SSFree(pv);
                }

                goto SetPfxAllocError;
            }

            if (NULL == (pPfx->rgKeys[pPfx->cKeys-1] = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            if (!CopyCrypttoASNSafeBag(&pSafeBags[i], (SafeBag*)pPfx->rgKeys[pPfx->cKeys-1]))
                continue;
        }
        else if (0 == strcmp(pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_SHROUDEDKEY_BAG))
        {
            pPfx->cShroudedKeys++;
            if (pPfx->rgShroudedKeys)
            {
                pv = pPfx->rgShroudedKeys;
                #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
                pPfx->rgShroudedKeys = (void**)SSReAlloc(pPfx->rgShroudedKeys, pPfx->cShroudedKeys*sizeof(SafeBag*));
            }
            else
                pPfx->rgShroudedKeys = (void**)SSAlloc(pPfx->cShroudedKeys*sizeof(SafeBag*));

            if (pPfx->rgShroudedKeys == NULL)
            {
                if (pv != NULL)
                {
                    SSFree(pv);
                }

                goto SetPfxAllocError;
            }

            if (NULL == (pPfx->rgShroudedKeys[pPfx->cShroudedKeys-1] = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            if (!CopyCrypttoASNSafeBag(&pSafeBags[i], (SafeBag*)pPfx->rgShroudedKeys[pPfx->cShroudedKeys-1]))
                continue;
        }
        else if (0 == strcmp(pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_CERT_BAG))
        {
            pPfx->cCertcrls++;
            if (pPfx->rgCertcrls)
            {
                pv = pPfx->rgCertcrls;
                #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
                pPfx->rgCertcrls = (void**)SSReAlloc(pPfx->rgCertcrls, pPfx->cCertcrls*sizeof(SafeBag*));
            }
            else
                pPfx->rgCertcrls = (void**)SSAlloc(pPfx->cCertcrls*sizeof(SafeBag*));

            if (pPfx->rgCertcrls == NULL)
            {
                if (pv != NULL)
                {
                    SSFree(pv);
                }

                goto SetPfxAllocError;
            }

            if (NULL == (pPfx->rgCertcrls[pPfx->cCertcrls-1] = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            if (!CopyCrypttoASNSafeBag(&pSafeBags[i], (SafeBag*)pPfx->rgCertcrls[pPfx->cCertcrls-1]))
                continue;
        }
        else if (0 == strcmp(pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_SECRET_BAG))
        {
            pPfx->cSecrets++;
            if (pPfx->rgSecrets)
            {
                pv = pPfx->rgSecrets;
                #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
                pPfx->rgSecrets = (void**)SSReAlloc(pPfx->rgSecrets, pPfx->cSecrets*sizeof(SafeBag*));
            }
            else
                pPfx->rgSecrets = (void**)SSAlloc(pPfx->cSecrets*sizeof(SafeBag*));

            if (pPfx->rgSecrets == NULL)
            {
                if (pv != NULL)
                {
                    SSFree(pv);
                }

                goto SetPfxAllocError;
            }

            if (NULL == (pPfx->rgSecrets[pPfx->cSecrets-1] = (SafeBag*)SSAlloc(sizeof(SafeBag)) ))
                goto SetPfxAllocError;

            if (!CopyCrypttoASNSafeBag(&pSafeBags[i], (SafeBag*)pPfx->rgSecrets[pPfx->cSecrets-1]))
                continue;
        }
        else
        {
#if DBG
            OutputDebugString(pSafeBags[i].pszBagTypeOID);
#endif
            continue;
        }

    }

    return TRUE;

SetPfxAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}


BOOL
PFXAPI
IsRealPFXBlob(CRYPT_DATA_BLOB* pPFX)
{
    PFX    *psPfx = NULL;
    ASN1decoding_t  pDec = GetDecoder();

    // Crack the PFX blob
    if (0 == PkiAsn1Decode(
            pDec,
            (void **)&psPfx,
            PFX_PDU,
            pPFX->pbData,
            pPFX->cbData
            ))
    {
        PkiAsn1FreeDecoded(pDec, psPfx, PFX_PDU);
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxcrypt.cpp ===
#include "global.hxx"

// crypto defs
#include <wincrypt.h>
#include "randlib.h"

#include "pfxhelp.h"

#include "pfxcmn.h"
#include "pfxcrypt.h"

#include "sha.h"
#include "shacomm.h"
#include "rc2.h"
#include "modes.h"
#include "des.h"
#include "tripldes.h"

// constants used in PKCS5-like key derivation
#define DERIVE_ENCRYPT_DECRYPT  0x1
#define DERIVE_INITIAL_VECTOR   0x2
#define DERIVE_INTEGRITY_KEY    0x3

#define HMAC_K_PADSIZE              64

BOOL    FMyPrimitiveSHA(
            PBYTE       pbData,
            DWORD       cbData,
            BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;
    A_SHA_CTX   sSHAHash;


    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    fRet = TRUE;
//Ret:

    return fRet;
}

BOOL FMyPrimitiveHMACParam(
        PBYTE       pbKeyMaterial,
        DWORD       cbKeyMaterial,
        PBYTE       pbData,
        DWORD       cbData,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;

    BYTE rgbKipad[HMAC_K_PADSIZE];
    BYTE rgbKopad[HMAC_K_PADSIZE];

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;


    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);



    BYTE  rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];

    // assert we're a multiple
    assert( (HMAC_K_PADSIZE % sizeof(DWORD)) == 0);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(DWORD dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }


    // prepend Kipad to data, Hash to get H1
    {
        // do this inline, don't call MyPrimitiveSHA since it would require data copy
        A_SHA_CTX   sSHAHash;
        BYTE        HashVal[A_SHA_DIGEST_LEN];

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, HashVal, A_SHA_DIGEST_LEN);
    }

    if (!FMyPrimitiveSHA(
            rgbHMACTmp,
            sizeof(rgbHMACTmp),
            rgbHMAC))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}

static
BOOL
CopyPassword(
    BYTE    *pbLocation,
    LPCWSTR szPassword,
    DWORD   dwMaxBytes
    )
{
    DWORD i = 0;
    DWORD cbWideChars = WSZ_BYTECOUNT(szPassword);
    BYTE  *pbWideChars = (BYTE *) szPassword;

    while ((i<cbWideChars) && (i<dwMaxBytes))
    {
        pbLocation[i] = pbWideChars[i+1];
        pbLocation[i+1] = pbWideChars[i];
        i+=2;
    }

    return TRUE;
}

//+ --------------------------------------------------------------
//  in NSCP's initial implementation of PFX020, this
//  is the algorithm they used to derive a key from a password.
//  We include it so we can interoperate.
BOOL NSCPDeriveKey(
        LPCWSTR szPassword,
        PBYTE   pbPrivacySalt,
        DWORD   cbPrivacySalt,
        int     iPKCS5Iterations,
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,
        PBYTE   pbDerivedMaterial,
        DWORD   cbDerivedMaterial)
{
    BOOL    fRet = FALSE;
    BYTE    rgbPKCS5Key[A_SHA_DIGEST_LEN];

    DWORD   cbVirtualPW = cbPrivacySalt + WSZ_BYTECOUNT(szPassword);
    PBYTE   pbVirtualPW = (PBYTE)SSAlloc(cbVirtualPW);
    if (pbVirtualPW == NULL)
        goto Ret;

    // Virtual PW = (salt | szPW)
    CopyMemory(pbVirtualPW, pbPrivacySalt, cbPrivacySalt);
    CopyPassword(&pbVirtualPW[cbPrivacySalt], szPassword, WSZ_BYTECOUNT(szPassword));

    // use PKCS#5 to generate initial bit stream (seed)
    if (!PKCS5_GenKey(
            iPKCS5Iterations,
            pbVirtualPW, cbVirtualPW,
            pbPKCS5Salt, cbPKCS5Salt,
            rgbPKCS5Key))
        goto Ret;

    if (cbDerivedMaterial > sizeof(rgbPKCS5Key))
    {
        // P_hash (secret, seed) =  HMAC_hash (secret, A(0) + seed),
        //                          HMAC_hash (secret, A(1) + seed),
        //                          HMAC_hash (secret, A(2) + seed),
        //                          HMAC_hash (secret, A(3) + seed) ...
        // where
        // A(0) = seed
        // A(i) = HMAC_hash(secret, A(i-1))
        // seed = PKCS5 salt for PKCS5 PBE param
        // secret = normal PKCS5 hashed key

        if (!P_Hash (
                rgbPKCS5Key,
                sizeof(rgbPKCS5Key),

                pbPKCS5Salt,
                cbPKCS5Salt,

                pbDerivedMaterial,      // output
                cbDerivedMaterial,      // # of output bytes requested
                TRUE) )                 // NSCP compat mode?
            goto Ret;
    }
    else
    {
        // we already have enough bits to satisfy the request
        CopyMemory(pbDerivedMaterial, rgbPKCS5Key, cbDerivedMaterial);
    }

    fRet = TRUE;
Ret:
    if (pbVirtualPW)
        SSFree(pbVirtualPW);

    return fRet;
}


static
BYTE
AddWithCarry(
    BYTE byte1,
    BYTE byte2,
    BYTE *carry  // IN and OUT
    )
{
    BYTE tempCarry = *carry;

    if (((DWORD)byte1 + (DWORD)byte2 + (DWORD)tempCarry) >= 256) {
        *carry = 1;
    }
    else {
        *carry = 0;
    }


    return (byte1 + byte2 + tempCarry);
}

// 512 bits = ? bytes
#define SHA_INTERNAL_BLOCKLEN (512/8)
#define SHA_V_LENGTH (512/8)

//+ --------------------------------------------------------------
//  In PKCS12 v1.0 Draft, this is the way they describe to
//  derive a key from a password.
BOOL
PKCS12DeriveKey(
        LPCWSTR szPassword,
        BYTE    bID,

        int     iIterations,
        PBYTE   pbSalt,
        DWORD   cbSalt,

        PBYTE   pbDerivedMaterial,
        DWORD   cbDerivedMaterial)
{
#if DBG
    if (iIterations>1)
        OutputDebugString("Perf hit: iterating key derivation! (pfxcrypt:PKCS12DeriveKey())\n");
#endif
    BOOL fRet = FALSE;

    BYTE rgSaltPwd[2*SHA_INTERNAL_BLOCKLEN];
    DWORD cbSaltPwd;
    BYTE rgDiversifier[SHA_INTERNAL_BLOCKLEN];
    BYTE B[SHA_V_LENGTH];
    DWORD i;
    DWORD cbPassword = WSZ_BYTECOUNT(szPassword);
    BYTE bCarry;
    DWORD vBlocks;

    A_SHA_CTX   sSHAHash;

    // construct D
    FillMemory(rgDiversifier, sizeof(rgDiversifier), bID);

    // concat salt to create string of length 64*(cb/64) bytes

    // copy salt (multiple) times, don't copy the last time
    for (i=0; i<(SHA_INTERNAL_BLOCKLEN-cbSalt); i+=cbSalt)
    {
        CopyMemory(&rgSaltPwd[i], pbSalt, cbSalt);
    }
    // do final copy (assert we have less than cbSalt bytes left to copy)
    assert(cbSalt >= (SHA_INTERNAL_BLOCKLEN - (i%SHA_INTERNAL_BLOCKLEN)) );
    CopyMemory(&rgSaltPwd[i], pbSalt, (SHA_INTERNAL_BLOCKLEN-(i%SHA_INTERNAL_BLOCKLEN)));


    // if the password is not NULL, concat pwd to create string of length 64*(cbPwd/64) bytes
    // copy pwd (multiple) times, don't copy the last time
    if (szPassword)
    {
        // truncate if necessary
        if (cbPassword > SHA_INTERNAL_BLOCKLEN)
            cbPassword = SHA_INTERNAL_BLOCKLEN;

        for (i=SHA_INTERNAL_BLOCKLEN; i<( (2*SHA_INTERNAL_BLOCKLEN)-cbPassword); i+=cbPassword)
        {
            // use CopyPassword because bytes need to be swapped
            CopyPassword(&rgSaltPwd[i], szPassword, cbPassword);
        }
        // do final copy (assert we have less than cbSalt bytes left to copy)
        assert(cbPassword >= (SHA_INTERNAL_BLOCKLEN - (i%SHA_INTERNAL_BLOCKLEN)) );
        CopyPassword(&rgSaltPwd[i], szPassword, (SHA_INTERNAL_BLOCKLEN-(i%SHA_INTERNAL_BLOCKLEN)));

        cbSaltPwd = sizeof(rgSaltPwd);
    }
    else
    {
        cbSaltPwd = sizeof(rgSaltPwd) / 2;
    }


    // concat S|P
    // done, available in rgSaltPwd


    // set c = cbDerivedMaterial/A_SHA_DIGEST_LEN
    //assert(0 == cbDerivedMaterial%A_SHA_DIGEST_LEN);

    // compute working size >= output size
    DWORD cBlocks = (DWORD)((cbDerivedMaterial/A_SHA_DIGEST_LEN) +1);
    DWORD cbTmpBuf = cBlocks * A_SHA_DIGEST_LEN;
    PBYTE pbTmpBuf = (PBYTE)LocalAlloc(LPTR, cbTmpBuf);
    if (pbTmpBuf == NULL)
        goto Ret;

    // now do only full blocks
    for (i=0; i< cBlocks; i++)
    {
        int iIter;
        int iCount;
        A_SHAInit(&sSHAHash);

        for (iIter=0; iIter<iIterations; iIter++)
        {
            // Tmp = Hash(D | I);
            if (iIter==0)
            {
                A_SHAUpdate(&sSHAHash, rgDiversifier, sizeof(rgDiversifier));
                A_SHAUpdate(&sSHAHash, rgSaltPwd, cbSaltPwd);
            }
            else
            {
                // rehash last output
                A_SHAUpdate(&sSHAHash, &pbTmpBuf[i*A_SHA_DIGEST_LEN], A_SHA_DIGEST_LEN);
            }

            // spit iteration output to final buffer
            A_SHAFinal(&sSHAHash, &pbTmpBuf[i*A_SHA_DIGEST_LEN]);
        }

        // concat A[x] | A[x] | ... and truncate to get 64 bytes
        iCount = 0;
        while (iCount+A_SHA_DIGEST_LEN <= sizeof(B)) {
            CopyMemory(&B[iCount], &pbTmpBuf[i*A_SHA_DIGEST_LEN], A_SHA_DIGEST_LEN);
            iCount += A_SHA_DIGEST_LEN;
        }
        CopyMemory(&B[iCount], &pbTmpBuf[i*A_SHA_DIGEST_LEN], sizeof(B) % A_SHA_DIGEST_LEN);


        // modify I by setting Ij += (B + 1) (mod 2^512)
        for (vBlocks = 0; vBlocks < cbSaltPwd; vBlocks += SHA_V_LENGTH) {
            bCarry = 1;
            for (iCount = SHA_V_LENGTH-1; iCount >= 0; iCount--)
            {
                rgSaltPwd[iCount+vBlocks] = AddWithCarry(rgSaltPwd[iCount+vBlocks], B[iCount], &bCarry);
            }
        }
    }

    // copy from (larger) working buffer to output buffer
    CopyMemory(pbDerivedMaterial, pbTmpBuf, cbDerivedMaterial);

    fRet = TRUE;
Ret:
    if (pbTmpBuf)
        LocalFree(pbTmpBuf);

    return fRet;
}

//+ --------------------------------------------------------------
//  in NSCP's initial implementation of PFX020, this
//  is the algorithm they used to decrypt data. This uses the
//  key derivation code above.
//  We include it so we can interoperate.
BOOL NSCPPasswordDecryptData(
        int     iEncrType,

        LPCWSTR szPassword,

        PBYTE   pbPrivacySalt,      // privacy salt
        DWORD   cbPrivacySalt,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,

        PBYTE*  ppbData,            // in/out
        DWORD*  pcbData)
{
    BOOL fRet = FALSE;

    BYTE    rgbDerivedKeyMatl[40]; // 320 bits is enough for 128 bit key, 64 bit IV
    DWORD   cbNeeded;

    if (iEncrType == RC2_40)
        cbNeeded = (40/8)+RC2_BLOCKLEN; // key + IV
    else
        cbNeeded = 0;

    // make next muliple of SHA dig len
    if (cbNeeded % A_SHA_DIGEST_LEN)
    {
        cbNeeded += (A_SHA_DIGEST_LEN - (cbNeeded % A_SHA_DIGEST_LEN));
    }

    assert(0 == (cbNeeded % A_SHA_DIGEST_LEN));
    assert(cbNeeded <= sizeof(rgbDerivedKeyMatl));

    if (!NSCPDeriveKey(
            szPassword,
            pbPrivacySalt,
            cbPrivacySalt,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedKeyMatl,
            cbNeeded) )
        goto Ret;

    // NOW decrypt data
    if (iEncrType == RC2_40)
    {
        DWORD dwDataPos;
        DWORD cbToBeDec = *pcbData;
        WORD  rc2Table[RC2_TABLESIZE];
        BYTE  rc2Fdbk [RC2_BLOCKLEN];

        assert( (40/8) <= sizeof(rgbDerivedKeyMatl));
        assert( 0 == cbToBeDec % RC2_BLOCKLEN );     // must be even multiple

        // key setup
        RC2Key(rc2Table, rgbDerivedKeyMatl, (40/8));    // take first 40 bits of keying material
        CopyMemory(rc2Fdbk, &rgbDerivedKeyMatl[cbNeeded - sizeof(rc2Fdbk)], sizeof(rc2Fdbk));    // fdbk is last chunk

        // decryption
        for (dwDataPos=0; cbToBeDec > 0; dwDataPos+=RC2_BLOCKLEN, cbToBeDec -= RC2_BLOCKLEN)
        {
            BYTE rgbDec[RC2_BLOCKLEN];

            CBC(
                RC2,
                RC2_BLOCKLEN,
                rgbDec,
                &(*ppbData)[dwDataPos],
                rc2Table,
                DECRYPT,
                rc2Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbDec, RC2_BLOCKLEN);
        }
    }
    else
        goto Ret;



    fRet = TRUE;

Ret:
    return fRet;
}



//+ --------------------------------------------------------------
//  in the PKCS12 v1.0 Draft, this is how they describe how to
//  encrypt data.
BOOL PFXPasswordEncryptData(
        int     iEncrType,
        LPCWSTR szPassword,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,

        PBYTE*  ppbData,
        DWORD*  pcbData)
{
    BOOL fRet = FALSE;
    BOOL fIsBlockCipher = FALSE;
    DWORD cbToBeEnc;

    BYTE    rgbDerivedKey[A_SHA_DIGEST_LEN*2];    // 320 bits is enough for 256 bit key
    BYTE    rgbDerivedIV[A_SHA_DIGEST_LEN*2];     // 320 bits is enough for 256 bit IV
    DWORD   cbKeyNeeded, cbIVNeeded, cbBlockLen;

    if (iEncrType == RC2_40)
    {
        cbKeyNeeded = (40/8);      // key
        cbIVNeeded = RC2_BLOCKLEN; // IV
        cbBlockLen = RC2_BLOCKLEN;
        fIsBlockCipher = TRUE;
    }
    else if (iEncrType == TripleDES)
    {
        cbKeyNeeded = (64/8) * 3;
        cbIVNeeded = DES_BLOCKLEN;
        cbBlockLen = DES_BLOCKLEN;
        fIsBlockCipher = TRUE;
    }
    else
    {
        cbKeyNeeded = 0;
        cbIVNeeded = 0;
        cbBlockLen = 0;
    }

    // make next muliple of SHA dig len
    if (cbKeyNeeded % A_SHA_DIGEST_LEN)
        cbKeyNeeded += (A_SHA_DIGEST_LEN - (cbKeyNeeded % A_SHA_DIGEST_LEN));

    if (cbIVNeeded % A_SHA_DIGEST_LEN)
        cbIVNeeded += (A_SHA_DIGEST_LEN - (cbIVNeeded % A_SHA_DIGEST_LEN));

    assert(0 == (cbKeyNeeded % A_SHA_DIGEST_LEN));
    assert(0 == (cbIVNeeded % A_SHA_DIGEST_LEN));

    assert(cbKeyNeeded <= sizeof(rgbDerivedKey));
    assert(cbIVNeeded <= sizeof(rgbDerivedIV));


    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_ENCRYPT_DECRYPT,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedKey,
            cbKeyNeeded) )
        goto Ret;

    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_INITIAL_VECTOR,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedIV,
            cbIVNeeded) )
        goto Ret;

    if (fIsBlockCipher)
    {
        PBYTE pTemp = *ppbData;

        // extend buffer to multiple of blocklen
        cbToBeEnc = *pcbData;
        cbToBeEnc += cbBlockLen - (cbToBeEnc%cbBlockLen);   // {1..BLOCKLEN}
        #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
        *ppbData = (PBYTE)SSReAlloc(*ppbData, cbToBeEnc);
        if (NULL == *ppbData)
        {
            SSFree(pTemp);
            goto Ret;
        }

        // pad remaining bytes with length
        FillMemory(&((*ppbData)[*pcbData]), cbToBeEnc-(*pcbData), (BYTE)(cbToBeEnc-(*pcbData)));
        *pcbData = cbToBeEnc;

        assert( cbBlockLen <= sizeof(rgbDerivedKey));
        assert( 0 == cbToBeEnc % cbBlockLen );         // must be even multiple
    }

    // NOW encrypt data
    if (iEncrType == RC2_40)
    {
        DWORD dwDataPos;
        WORD  rc2Table[RC2_TABLESIZE];
        BYTE  rc2Fdbk [RC2_BLOCKLEN];

        // already done: extend buffer, add PKCS byte padding

        // key setup
        RC2Key(rc2Table, rgbDerivedKey, (40/8));            // take first 40 bits of keying material
        CopyMemory(rc2Fdbk, rgbDerivedIV, sizeof(rc2Fdbk));

        // decryption
        for (dwDataPos=0; cbToBeEnc > 0; dwDataPos+=RC2_BLOCKLEN, cbToBeEnc -= RC2_BLOCKLEN)
        {
            BYTE rgbEnc[RC2_BLOCKLEN];

            CBC(
                RC2,
                RC2_BLOCKLEN,
                rgbEnc,
                &(*ppbData)[dwDataPos],
                rc2Table,
                ENCRYPT,
                rc2Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbEnc, sizeof(rgbEnc));
        }
    }
    else if (iEncrType == TripleDES)
    {
        DWORD       dwDataPos;
        DES3TABLE   des3Table;
        BYTE        des3Fdbk [DES_BLOCKLEN];

        // already done: extend buffer, add PKCS byte padding

        // key setup
        tripledes3key(&des3Table, rgbDerivedKey);
        CopyMemory(des3Fdbk, rgbDerivedIV, sizeof(des3Fdbk));    // fdbk is last chunk

        for (dwDataPos=0; cbToBeEnc > 0; dwDataPos+=DES_BLOCKLEN, cbToBeEnc -= DES_BLOCKLEN)
        {
            BYTE rgbEnc[DES_BLOCKLEN];

            CBC(
                tripledes,
                DES_BLOCKLEN,
                rgbEnc,
                &(*ppbData)[dwDataPos],
                (void *) &des3Table,
                ENCRYPT,
                des3Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbEnc, DES_BLOCKLEN);
        }
    }
    else
        goto Ret;

    fRet = TRUE;

Ret:
    return fRet;
}

//+ --------------------------------------------------------------
//  in the PKCS12 v1.0 Draft, this is how they describe how to
//  decrypt data.
BOOL PFXPasswordDecryptData(
        int     iEncrType,
        LPCWSTR szPassword,

        int     iPKCS5Iterations,   // pkcs5 data
        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,

        PBYTE*  ppbData,
        DWORD*  pcbData)
{
    BOOL fRet = FALSE;
    BOOL fIsBlockCipher = FALSE;

    BYTE    rgbDerivedKey[A_SHA_DIGEST_LEN*2];    // 320 bits is enough for 256 bit key
    BYTE    rgbDerivedIV[A_SHA_DIGEST_LEN*2];     // 320 bits is enough for 256 bit IV
    DWORD   cbKeyNeeded, cbIVNeeded, cbBlockLen;

    if (iEncrType == RC2_40)
    {
        cbKeyNeeded = (40/8);      // key
        cbIVNeeded = RC2_BLOCKLEN; // IV
        cbBlockLen = RC2_BLOCKLEN;
        fIsBlockCipher = TRUE;
    }
    else if (iEncrType == TripleDES)
    {
        cbKeyNeeded = (64/8) * 3;
        cbIVNeeded = DES_BLOCKLEN;
        cbBlockLen = DES_BLOCKLEN;
        fIsBlockCipher = TRUE;
    }
    else
    {
        cbKeyNeeded = 0;
        cbIVNeeded = 0;
        cbBlockLen = 0;
    }

    // make next muliple of SHA dig len
    if (cbKeyNeeded % A_SHA_DIGEST_LEN)
        cbKeyNeeded += (A_SHA_DIGEST_LEN - (cbKeyNeeded % A_SHA_DIGEST_LEN));

    if (cbIVNeeded % A_SHA_DIGEST_LEN)
        cbIVNeeded += (A_SHA_DIGEST_LEN - (cbIVNeeded % A_SHA_DIGEST_LEN));

    assert(0 == (cbKeyNeeded % A_SHA_DIGEST_LEN));
    assert(0 == (cbIVNeeded % A_SHA_DIGEST_LEN));

    assert(cbKeyNeeded <= sizeof(rgbDerivedKey));
    assert(cbIVNeeded <= sizeof(rgbDerivedIV));


    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_ENCRYPT_DECRYPT,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedKey,
            cbKeyNeeded) )
        goto Ret;

    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_INITIAL_VECTOR,
            iPKCS5Iterations,
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedIV,
            cbIVNeeded) )
        goto Ret;

    // NOW decrypt data
    if (iEncrType == RC2_40)
    {
        BYTE rgbDec[RC2_BLOCKLEN];

        DWORD dwDataPos;
        DWORD cbToBeDec = *pcbData;
        WORD  rc2Table[RC2_TABLESIZE];
        BYTE  rc2Fdbk [RC2_BLOCKLEN];

        assert( (40/8) <= sizeof(rgbDerivedKey));
        assert( 0 == cbToBeDec % RC2_BLOCKLEN );         // must be even multiple

        // key setup
        RC2Key(rc2Table, rgbDerivedKey, (40/8));            // take first 40 bits of keying material
        CopyMemory(rc2Fdbk, rgbDerivedIV, sizeof(rc2Fdbk));

        // decryption
        for (dwDataPos=0; cbToBeDec > 0; dwDataPos+=RC2_BLOCKLEN, cbToBeDec -= RC2_BLOCKLEN)
        {
            CBC(
                RC2,
                RC2_BLOCKLEN,
                rgbDec,
                &(*ppbData)[dwDataPos],
                rc2Table,
                DECRYPT,
                rc2Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbDec, sizeof(rgbDec));
        }
    }
    else if (iEncrType == TripleDES) {
        DWORD       dwDataPos;
        DWORD       cbToBeDec = *pcbData;
        DES3TABLE   des3Table;
        BYTE        des3Fdbk [DES_BLOCKLEN];


        // key setup
        tripledes3key(&des3Table, rgbDerivedKey);
        CopyMemory(des3Fdbk, rgbDerivedIV, sizeof(des3Fdbk));    // fdbk is last chunk

        for (dwDataPos=0; cbToBeDec > 0; dwDataPos += DES_BLOCKLEN, cbToBeDec -= DES_BLOCKLEN)
        {
            BYTE rgbDec[DES_BLOCKLEN];

            CBC(
                tripledes,
                DES_BLOCKLEN,
                rgbDec,
                &(*ppbData)[dwDataPos],
                (void *) &des3Table,
                DECRYPT,
                des3Fdbk);

            CopyMemory(&(*ppbData)[dwDataPos], rgbDec, DES_BLOCKLEN);
        }
    }
    else
        goto Ret;

    // Remove padding
    if (fIsBlockCipher)
    {
        PBYTE pTemp = *ppbData;

        // last byte of decr is pad byte
        BYTE iPadBytes;
        iPadBytes = (*ppbData)[*pcbData-1];
        if (iPadBytes > cbBlockLen)
            goto Ret;

        #pragma prefast(suppress:308, "the pointer was saved above (PREfast bug 506)")
        *ppbData = (PBYTE)SSReAlloc( (*ppbData), *pcbData - iPadBytes);
        if (NULL == *ppbData)
        {
            SSFree(pTemp);
            goto Ret;
        }
        *pcbData -= iPadBytes;
    }

    fRet = TRUE;

Ret:
    return fRet;
}

//+ --------------------------------------------------------------
//  in the PKCS12 v1.0 Draft, this is how they describe how to
//  generate a checksum that will prove data integrid.
BOOL FGenerateMAC(

        LPCWSTR szPassword,

        PBYTE   pbPKCS5Salt,
        DWORD   cbPKCS5Salt,
        DWORD   iterationCount,

        PBYTE   pbData,     // pb data
        DWORD   cbData,     // cb data
        BYTE    rgbMAC[])   // output
{
    // UNDONE UNDONE: Use RSABase

    BOOL    fRet = FALSE;
    BYTE    rgbDerivedKey[A_SHA_DIGEST_LEN];    // 160 bits is enough for a MAC key
    DWORD   cbKeyNeeded = A_SHA_DIGEST_LEN;

    assert(0 == (cbKeyNeeded % A_SHA_DIGEST_LEN));
    assert(cbKeyNeeded <= sizeof(rgbDerivedKey));

    if (!PKCS12DeriveKey(
            szPassword,
            DERIVE_INTEGRITY_KEY,
            iterationCount,                      // no other way to determine iterations: HARDCODE
            pbPKCS5Salt,
            cbPKCS5Salt,
            rgbDerivedKey,
            cbKeyNeeded) )
        goto Ret;

    if (!FMyPrimitiveHMACParam(
            rgbDerivedKey,
            cbKeyNeeded,
            pbData,
            cbData,
            rgbMAC))
        goto Ret;

    fRet = TRUE;
Ret:

    return fRet;
}

/////////////////////////////////////////////////////////////////
// begin tls1key.cpp
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1999
* All rights reserved.
*----------------------------------------------------------------------------*/

// the original PKCS5 algorithm for generating a key from a password
BOOL PKCS5_GenKey
(
    int     iIterations,
    PBYTE   pbPW,
    DWORD   cbPW,
    PBYTE   pbSalt,
    DWORD   cbSalt,
    BYTE    rgbPKCS5Key[A_SHA_DIGEST_LEN]
)
{
    BOOL    fRet = FALSE;

    int     i;
    DWORD   cbTmp = cbSalt + cbPW;
    PBYTE   pbTmp = (PBYTE) SSAlloc(cbTmp);
    if (pbTmp == NULL)
        goto Ret;


    // pbTmp is ( PW | Salt )
    CopyMemory(pbTmp, pbPW, cbPW);
    CopyMemory(&pbTmp[cbPW], pbSalt, cbSalt);

    for (i=0; i<iIterations; i++)
    {
        if (i == 0) {
            if (!FMyPrimitiveSHA(
                    pbTmp,             // in
                    cbTmp,             // in
                    rgbPKCS5Key))
                goto Ret;

        }
        else {
             if (!FMyPrimitiveSHA(
                    rgbPKCS5Key,       // in
                    A_SHA_DIGEST_LEN,  // in
                    rgbPKCS5Key))
                goto Ret;
        }
    }

    fRet = TRUE;
Ret:
    SSFree(pbTmp);
    return fRet;
}

//+ ---------------------------------------------------------------------
// the P_Hash algorithm from TLS that was used in NSCP's PFX020 version
// to derive a key from a password. It is included here for completeness.

// NSCP made some implementation errors when they coded this up; to interop,
// use the fNSCPInteropMode parameter. The real P_Hash algorithm is used
// when fNSCPInteropMode is FALSE.
BOOL P_Hash
(
    PBYTE  pbSecret,
    DWORD  cbSecret,

    PBYTE  pbSeed,
    DWORD  cbSeed,

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut, //# of bytes of key length they want as output.

    BOOL    fNSCPInteropMode
)
{
    BOOL    fRet = FALSE;
    BYTE    rgbDigest[A_SHA_DIGEST_LEN];
    DWORD   iKey;

    PBYTE   pbAofiDigest = (PBYTE)SSAlloc(cbSeed + A_SHA_DIGEST_LEN);
    if (pbAofiDigest == NULL)
        goto Ret;

    ZeroMemory(pbAofiDigest, cbSeed+A_SHA_DIGEST_LEN);

//   First, we define a data expansion function, P_hash(secret, data)
//   which uses a single hash function to expand a secret and seed into
//   an arbitrary quantity of output:

//       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
//                              HMAC_hash(secret, A(2) + seed) +
//                              HMAC_hash(secret, A(3) + seed) + ...

//   Where + indicates concatenation.

//   A() is defined as:
//       A(0) = seed
//       A(i) = HMAC_hash(secret, A(i-1))


    if (fNSCPInteropMode)
    {
        // NSCP interop mode: 7/7/97
        // nscp leaves (A_SHA_DIGEST_LEN-cbSeed) bytes zeroed between
        // the seed and the appended seed. For interop, do derivation this way

        // Also, they use A(0) to derive key bytes, whereas TLS spec
        // specifies to wait for A(1).
        CopyMemory(pbAofiDigest, pbSeed, cbSeed);
    }
    else
    {
        // build A(1)
        if (!FMyPrimitiveHMACParam(pbSecret, cbSecret, pbSeed, cbSeed, pbAofiDigest))
            goto Ret;
    }


    // create Aofi: (  A(i) | seed )
    CopyMemory(&pbAofiDigest[A_SHA_DIGEST_LEN], pbSeed, cbSeed);

    // make sure that cbKeyOut is a multiple of A_SHA_DIGEST_LEN
    if ((cbKeyOut % A_SHA_DIGEST_LEN) != 0)
    {
        goto Ret;
    }

    for (iKey=0; cbKeyOut; iKey++)
    {
        // build Digest = HMAC(key | A(i) | seed);
        if (!FMyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, cbSeed + A_SHA_DIGEST_LEN, rgbDigest))
            goto Ret;

        // append to pbKeyOut
        CopyMemory(pbKeyOut, rgbDigest, A_SHA_DIGEST_LEN);

        pbKeyOut += A_SHA_DIGEST_LEN;
        cbKeyOut -= A_SHA_DIGEST_LEN;

        // build A(i) = HMAC(key, A(i-1))
        if (!FMyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, A_SHA_DIGEST_LEN, pbAofiDigest))
            goto Ret;
    }

    fRet = TRUE;

Ret:
    if (pbAofiDigest)
        SSFree(pbAofiDigest);

    return fRet;
}



#if DBG

// test vector for real P_Hash
BOOL FTestPHASH_and_HMAC()
{
    BYTE rgbKey[] = {0x33, 0x62, 0xf9, 0x42, 0x43};
    CHAR szPwd[] = "My Password";

    BYTE rgbKeyOut[7*A_SHA_DIGEST_LEN];
    static BYTE rgbTestVectorOutput[] =  {
            0x24, 0xF2, 0x98, 0x75, 0xE1, 0x90, 0x6D, 0x49,
            0x96, 0x5B, 0x87, 0xB8, 0xBC, 0xD3, 0x11, 0x6C,
            0x13, 0xDC, 0xBD, 0xC2, 0x7E, 0x56, 0xD0, 0x3C,
            0xAC, 0xCD, 0x86, 0x58, 0x31, 0x67, 0x7B, 0x23,
            0x19, 0x6E, 0x36, 0x65, 0xBF, 0x9F, 0x3D, 0x03,
            0x5A, 0x9C, 0x6E, 0xD7, 0xEB, 0x3E, 0x5A, 0xE6,
            0x05, 0x86, 0x84, 0x5A, 0xC3, 0x97, 0xFC, 0x17,
            0xF5, 0xF0, 0xF5, 0x16, 0x67, 0xAD, 0x7C, 0xED,
            0x65, 0xDC, 0x0B, 0x99, 0x58, 0x5D, 0xCA, 0x66,
            0x28, 0xAD, 0xA5, 0x39, 0x54, 0x44, 0x36, 0x13,
            0x91, 0xCE, 0xE9, 0x73, 0x23, 0x43, 0x2E, 0xEC,
            0xA2, 0xC3, 0xE7, 0xFA, 0x74, 0xA7, 0xB6, 0x75,
            0x77, 0xF5, 0xF5, 0x16, 0xC2, 0xEE, 0xED, 0x7A,
            0x21, 0x86, 0x1D, 0x84, 0x6F, 0xC6, 0x03, 0xF3,
            0xCC, 0x77, 0x02, 0xFA, 0x76, 0x46, 0x64, 0x57,
            0xBB, 0x56, 0x3A, 0xF7, 0x7E, 0xB4, 0xD6, 0x52,
            0x72, 0x8C, 0x34, 0xF1, 0xA4, 0x1E, 0xA7, 0xA6,
            0xCD, 0xBD, 0x3C, 0x16, 0x4D, 0x79, 0x20, 0x50 };

    P_Hash(
        rgbKey, sizeof(rgbKey),
        (PBYTE)szPwd, strlen(szPwd),
        rgbKeyOut, sizeof(rgbKeyOut), FALSE);

    if (0 != memcmp(rgbKeyOut, rgbTestVectorOutput, sizeof(rgbKeyOut)) )
    {
        OutputDebugString("ERROR: phash vector test invalid!!!\n");
        return FALSE;
    }

    return TRUE;
}

// test vector for NSCP P_Hash
BOOL F_NSCP_TestPHASH_and_HMAC()
{
    BYTE rgbKey[] = {   0xc9, 0xc1, 0x69, 0x6e, 0x30, 0xa8, 0x91, 0x0d,
                        0x12, 0x19, 0x48, 0xef, 0x23, 0xac, 0x5b, 0x1f,
                        0x2e, 0xc4, 0x0e, 0xc2  };

    BYTE rgbSalt[] = {  0x1a, 0xb5, 0xf1, 0x1a, 0x5b, 0x6a, 0x6a, 0x5e };

    BYTE rgbKeyOut[7*A_SHA_DIGEST_LEN];
    static BYTE rgbTestVectorOutput[] =  {
                0x52, 0x7c, 0xbf, 0x90, 0xb1, 0xa1, 0xd0, 0xbf,
                0x21, 0x56, 0x34, 0xf2, 0x1f, 0x5c, 0x98, 0xcf,
                0x55, 0x95, 0xb1, 0x35, 0x65, 0xe3, 0x31, 0x44,
                0x78, 0xc5, 0x41, 0xa9, 0x2a, 0x14, 0x80, 0x19,
                0x56, 0x86, 0xa4, 0x71, 0x07, 0x24, 0x2d, 0x64 };

    assert(sizeof(rgbKeyOut) > sizeof(rgbTestVectorOutput));

    P_Hash(
        rgbKey, sizeof(rgbKey),
        rgbSalt, sizeof(rgbSalt),
        rgbKeyOut, sizeof(rgbTestVectorOutput),
        TRUE);

    if (0 != memcmp(rgbKeyOut, rgbTestVectorOutput, sizeof(rgbTestVectorOutput)) )
    {
        OutputDebugString("ERROR: NSCP phash vector test invalid!!!\n");
        return FALSE;
    }

    return TRUE;
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxhelp.h ===
#ifndef _PFXHELP_H
#define _PFXHELP_H
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       pfxhelp.h
//
//  Contents:   PFX helper function defintions and types
//
//----------------------------------------------------------------------------



#include "pfx.h"

//+-------------------------------------------------------------------------
//  Safe Bag Type Object Identifiers 
//--------------------------------------------------------------------------

#define szOID_PKCS_12_VERSION1			szOID_PKCS_12           ".10"
#define szOID_PKCS_12_BAG_IDS           szOID_PKCS_12_VERSION1  ".1"
#define szOID_PKCS_12_KEY_BAG			szOID_PKCS_12_BAG_IDS   ".1"
#define szOID_PKCS_12_SHROUDEDKEY_BAG	szOID_PKCS_12_BAG_IDS   ".2"
#define szOID_PKCS_12_CERT_BAG			szOID_PKCS_12_BAG_IDS   ".3"
#define szOID_PKCS_12_CRL_BAG			szOID_PKCS_12_BAG_IDS   ".4"
#define szOID_PKCS_12_SECRET_BAG		szOID_PKCS_12_BAG_IDS   ".5"
#define szOID_PKCS_12_SAFECONTENTS_BAG	szOID_PKCS_12_BAG_IDS   ".6"


#define PBE_SALT_LENGTH 8


typedef struct _SAFE_BAG{
	LPSTR				pszBagTypeOID;
	CRYPT_DER_BLOB		BagContents;	
	CRYPT_ATTRIBUTES	Attributes; 
} SAFE_BAG, *PSAFE_BAG;


typedef struct _SAFE_CONTENTS{
	DWORD		cSafeBags;
	SAFE_BAG	*pSafeBags;
} SAFE_CONTENTS, *PSAFE_CONTENTS;



typedef struct _EXPORT_SAFE_CALLBACK_STRUCT {
	PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC	pEncryptPrivateKeyFunc;
	LPVOID						    pVoidEncryptFunc;
} EXPORT_SAFE_CALLBACK_STRUCT, *PEXPORT_SAFE_CALLBACK_STRUCT;

//+-------------------------------------------------------------------------
// hCertStore - handle to the cert store that contains the certs whose
//				corresponding private keys are to be exported
// pSafeContents - pointer to a buffer to receive the SAFE_CONTENTS structure
//				   and supporting data
// pcbSafeContents - (in) specifies the length, in bytes, of the pSafeContents 
//					  buffer.  (out) gets filled in with the number of bytes 
//					  used by the operation.  If this is set to 0, the 
//					  required length of pSafeContents is filled in, and 
//					  pSafeContents is ignored.
// ExportSafeCallbackStruct - pointer to callbacks to handle PKCS8 encryption. If NULL, 
//              no encryption is performed.
// dwFlags - the current available flags are:
//				EXPORT_PRIVATE_KEYS
//				if this flag is set then the private keys are exported as well
//				as the certificates
//				REPORT_NO_PRIVATE_KEY
//				if this flag is set and a certificate is encountered that has no
//				no associated private key, the function will return immediately
//				with ppCertContext filled in with a pointer to the cert context
//				in question.  the caller is responsible for freeing the cert
//				context which is passed back.
//				REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//				if this flag is set and a certificate is encountered that has a 
//				non-exportable private key, the function will return immediately
//				with ppCertContext filled in with a pointer to the cert context
//				in question.  the caller is responsible for freeing the cert
//				context which is passed back.
// ppCertContext - a pointer to a pointer to a cert context.  this is used 
//				   if REPORT_NO_PRIVATE_KEY or REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//				   flags are set.  the caller is responsible for freeing the
//				   cert context.
// pvAuxInfo - reserved for future use, must be set to NULL 
//+-------------------------------------------------------------------------
BOOL WINAPI CertExportSafeContents(
	HCERTSTORE		hCertStore,			// in
	SAFE_CONTENTS	*pSafeContents,		// out
	DWORD			*pcbSafeContents,	// in, out
    EXPORT_SAFE_CALLBACK_STRUCT* ExportSafeCallbackStruct, // in
	DWORD			dwFlags,			// in
	PCCERT_CONTEXT *ppCertContext,		// out
	void			*pvAuxInfo			// in
);


// this callback is called when a private key is going to be imported,
// this gives the caller a chance specify which provider to import the 
// key to.
// the parameters are:
// pPrivateKeyInfo - a PRIVATE_KEY_INFO structure which contains all
//					 the information about the private key being imported
// dwSafeBagIndex - the idex into the safe bag array so the caller can
//					identify which SAFE_BAG this key cam out of
// phCryptProvInfo - a pointer to a HCRYPTPROV that is to be filled in
//					 with the handle of the provider to import to
// ppVoidhCryptProvQueryVoid - the LPVOID that was passed in when 
//							   CertImportSafeContents called, this is 
//							   preserved and passed back to the caller for
//							   context
typedef BOOL (CALLBACK *PHCRYPTPROV_QUERY_FUNC)(
						CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,
						DWORD   				dwSafeBagIndex,		
						HCRYPTPROV  			*phCryptProv,
						LPVOID		    		pVoidhCryptProvQuery,
                        DWORD                   dwPFXImportFlags);


typedef struct _IMPORT_SAFE_CALLBACK_STRUCT {
	PHCRYPTPROV_QUERY_FUNC		    phCryptProvQueryFunc;
	LPVOID						    pVoidhCryptProvQuery;
	PCRYPT_DECRYPT_PRIVATE_KEY_FUNC	pDecryptPrivateKeyFunc;
	LPVOID						    pVoidDecryptFunc;
} IMPORT_SAFE_CALLBACK_STRUCT, *PIMPORT_SAFE_CALLBACK_STRUCT;



//+-------------------------------------------------------------------------
// hCertStore -  handle of the cert store to import the safe contents to
// pSafeContents - pointer to the safe contents to import to the store
// dwCertAddDisposition - used when importing certificate to the store.
//						  for a full explanation of the possible values
//						  and their meanings see documentation for
//						  CertAddEncodedCertificateToStore
// ImportSafeCallbackStruct - structure that contains pointers to functions
//							  which are callled to get a HCRYPTPROV for import
//							  and to decrypt the key if a EncryptPrivateKeyInfo
//							  is encountered during import
// dwFlags - The available flags are:
//				CRYPT_EXPORTABLE 
//				this flag is used when importing private keys, for a full 
//				explanation please see the documentation for CryptImportKey.
// pvAuxInfo - reserved for future use, must be set to NULL
//+-------------------------------------------------------------------------
BOOL WINAPI CertImportSafeContents(
	HCERTSTORE					hCertStore,					// in
	SAFE_CONTENTS				*pSafeContents,				// in
	DWORD						dwCertAddDisposition,		// in
	IMPORT_SAFE_CALLBACK_STRUCT* ImportSafeCallbackStruct,	// in
	DWORD						dwFlags,					// in
	void						*pvAuxInfo					// in
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxnscp.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for PFXNSCP */

#include <windows.h>
#include "pfxnscp.h"

ASN1module_t PFXNSCP_Module = NULL;

static int ASN1CALL ASN1Enc_RSAData(ASN1encoding_t enc, ASN1uint32_t tag, RSAData *val);
static int ASN1CALL ASN1Enc_BaggageItem_unencryptedSecrets(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem_unencryptedSecrets *val);
static int ASN1CALL ASN1Enc_BaggageItem_espvks(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem_espvks *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_PBEParameter(ASN1encoding_t enc, ASN1uint32_t tag, PBEParameter *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_Baggage(ASN1encoding_t enc, ASN1uint32_t tag, Baggage *val);
static int ASN1CALL ASN1Enc_BaggageItem(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem *val);
static int ASN1CALL ASN1Enc_PvkAdditional(ASN1encoding_t enc, ASN1uint32_t tag, PvkAdditional *val);
static int ASN1CALL ASN1Enc_SafeContents(ASN1encoding_t enc, ASN1uint32_t tag, SafeContents *val);
static int ASN1CALL ASN1Enc_SafeBag(ASN1encoding_t enc, ASN1uint32_t tag, SafeBag *val);
static int ASN1CALL ASN1Enc_KeyBag(ASN1encoding_t enc, ASN1uint32_t tag, KeyBag *val);
static int ASN1CALL ASN1Enc_CertCRLBag(ASN1encoding_t enc, ASN1uint32_t tag, CertCRLBag *val);
static int ASN1CALL ASN1Enc_CertCRL(ASN1encoding_t enc, ASN1uint32_t tag, CertCRL *val);
static int ASN1CALL ASN1Enc_X509Bag(ASN1encoding_t enc, ASN1uint32_t tag, X509Bag *val);
static int ASN1CALL ASN1Enc_SDSICertBag(ASN1encoding_t enc, ASN1uint32_t tag, SDSICertBag *val);
static int ASN1CALL ASN1Enc_SecretBag(ASN1encoding_t enc, ASN1uint32_t tag, SecretBag *val);
static int ASN1CALL ASN1Enc_SecretAdditional(ASN1encoding_t enc, ASN1uint32_t tag, SecretAdditional *val);
static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_ContentEncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_MacData(ASN1encoding_t enc, ASN1uint32_t tag, MacData *val);
static int ASN1CALL ASN1Enc_AuthenticatedSafe(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticatedSafe *val);
static int ASN1CALL ASN1Enc_Thumbprint(ASN1encoding_t enc, ASN1uint32_t tag, Thumbprint *val);
static int ASN1CALL ASN1Enc_Secret(ASN1encoding_t enc, ASN1uint32_t tag, Secret *val);
static int ASN1CALL ASN1Enc_PVKSupportingData_assocCerts(ASN1encoding_t enc, ASN1uint32_t tag, PVKSupportingData_assocCerts *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Enc_PFX(ASN1encoding_t enc, ASN1uint32_t tag, PFX *val);
static int ASN1CALL ASN1Enc_PVKSupportingData(ASN1encoding_t enc, ASN1uint32_t tag, PVKSupportingData *val);
static int ASN1CALL ASN1Enc_PrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKey *val);
static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Enc_ESPVK(ASN1encoding_t enc, ASN1uint32_t tag, ESPVK *val);
static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_RSAData(ASN1decoding_t dec, ASN1uint32_t tag, RSAData *val);
static int ASN1CALL ASN1Dec_BaggageItem_unencryptedSecrets(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem_unencryptedSecrets *val);
static int ASN1CALL ASN1Dec_BaggageItem_espvks(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem_espvks *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_PBEParameter(ASN1decoding_t dec, ASN1uint32_t tag, PBEParameter *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_Baggage(ASN1decoding_t dec, ASN1uint32_t tag, Baggage *val);
static int ASN1CALL ASN1Dec_BaggageItem(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem *val);
static int ASN1CALL ASN1Dec_PvkAdditional(ASN1decoding_t dec, ASN1uint32_t tag, PvkAdditional *val);
static int ASN1CALL ASN1Dec_SafeContents(ASN1decoding_t dec, ASN1uint32_t tag, SafeContents *val);
static int ASN1CALL ASN1Dec_SafeBag(ASN1decoding_t dec, ASN1uint32_t tag, SafeBag *val);
static int ASN1CALL ASN1Dec_KeyBag(ASN1decoding_t dec, ASN1uint32_t tag, KeyBag *val);
static int ASN1CALL ASN1Dec_CertCRLBag(ASN1decoding_t dec, ASN1uint32_t tag, CertCRLBag *val);
static int ASN1CALL ASN1Dec_CertCRL(ASN1decoding_t dec, ASN1uint32_t tag, CertCRL *val);
static int ASN1CALL ASN1Dec_X509Bag(ASN1decoding_t dec, ASN1uint32_t tag, X509Bag *val);
static int ASN1CALL ASN1Dec_SDSICertBag(ASN1decoding_t dec, ASN1uint32_t tag, SDSICertBag *val);
static int ASN1CALL ASN1Dec_SecretBag(ASN1decoding_t dec, ASN1uint32_t tag, SecretBag *val);
static int ASN1CALL ASN1Dec_SecretAdditional(ASN1decoding_t dec, ASN1uint32_t tag, SecretAdditional *val);
static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_ContentEncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_MacData(ASN1decoding_t dec, ASN1uint32_t tag, MacData *val);
static int ASN1CALL ASN1Dec_AuthenticatedSafe(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticatedSafe *val);
static int ASN1CALL ASN1Dec_Thumbprint(ASN1decoding_t dec, ASN1uint32_t tag, Thumbprint *val);
static int ASN1CALL ASN1Dec_Secret(ASN1decoding_t dec, ASN1uint32_t tag, Secret *val);
static int ASN1CALL ASN1Dec_PVKSupportingData_assocCerts(ASN1decoding_t dec, ASN1uint32_t tag, PVKSupportingData_assocCerts *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Dec_PFX(ASN1decoding_t dec, ASN1uint32_t tag, PFX *val);
static int ASN1CALL ASN1Dec_PVKSupportingData(ASN1decoding_t dec, ASN1uint32_t tag, PVKSupportingData *val);
static int ASN1CALL ASN1Dec_PrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKey *val);
static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Dec_ESPVK(ASN1decoding_t dec, ASN1uint32_t tag, ESPVK *val);
static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static void ASN1CALL ASN1Free_RSAData(RSAData *val);
static void ASN1CALL ASN1Free_BaggageItem_unencryptedSecrets(BaggageItem_unencryptedSecrets *val);
static void ASN1CALL ASN1Free_BaggageItem_espvks(BaggageItem_espvks *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_PBEParameter(PBEParameter *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_Baggage(Baggage *val);
static void ASN1CALL ASN1Free_BaggageItem(BaggageItem *val);
static void ASN1CALL ASN1Free_PvkAdditional(PvkAdditional *val);
static void ASN1CALL ASN1Free_SafeContents(SafeContents *val);
static void ASN1CALL ASN1Free_SafeBag(SafeBag *val);
static void ASN1CALL ASN1Free_KeyBag(KeyBag *val);
static void ASN1CALL ASN1Free_CertCRLBag(CertCRLBag *val);
static void ASN1CALL ASN1Free_CertCRL(CertCRL *val);
static void ASN1CALL ASN1Free_X509Bag(X509Bag *val);
static void ASN1CALL ASN1Free_SDSICertBag(SDSICertBag *val);
static void ASN1CALL ASN1Free_SecretBag(SecretBag *val);
static void ASN1CALL ASN1Free_SecretAdditional(SecretAdditional *val);
static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_ContentEncryptionAlgorithmIdentifier(ContentEncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_MacData(MacData *val);
static void ASN1CALL ASN1Free_AuthenticatedSafe(AuthenticatedSafe *val);
static void ASN1CALL ASN1Free_Thumbprint(Thumbprint *val);
static void ASN1CALL ASN1Free_Secret(Secret *val);
static void ASN1CALL ASN1Free_PVKSupportingData_assocCerts(PVKSupportingData_assocCerts *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val);
static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val);
static void ASN1CALL ASN1Free_PFX(PFX *val);
static void ASN1CALL ASN1Free_PVKSupportingData(PVKSupportingData *val);
static void ASN1CALL ASN1Free_PrivateKey(PrivateKey *val);
static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val);
static void ASN1CALL ASN1Free_ESPVK(ESPVK *val);
static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[22] = {
    (ASN1EncFun_t) ASN1Enc_RSAData,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_PBEParameter,
    (ASN1EncFun_t) ASN1Enc_PvkAdditional,
    (ASN1EncFun_t) ASN1Enc_SafeContents,
    (ASN1EncFun_t) ASN1Enc_SafeBag,
    (ASN1EncFun_t) ASN1Enc_KeyBag,
    (ASN1EncFun_t) ASN1Enc_CertCRLBag,
    (ASN1EncFun_t) ASN1Enc_CertCRL,
    (ASN1EncFun_t) ASN1Enc_X509Bag,
    (ASN1EncFun_t) ASN1Enc_SDSICertBag,
    (ASN1EncFun_t) ASN1Enc_SecretBag,
    (ASN1EncFun_t) ASN1Enc_SecretAdditional,
    (ASN1EncFun_t) ASN1Enc_AuthenticatedSafe,
    (ASN1EncFun_t) ASN1Enc_Secret,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_PFX,
    (ASN1EncFun_t) ASN1Enc_PVKSupportingData,
    (ASN1EncFun_t) ASN1Enc_PrivateKey,
    (ASN1EncFun_t) ASN1Enc_EncryptedData,
    (ASN1EncFun_t) ASN1Enc_ESPVK,
    (ASN1EncFun_t) ASN1Enc_EncryptedPrivateKeyInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[22] = {
    (ASN1DecFun_t) ASN1Dec_RSAData,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_PBEParameter,
    (ASN1DecFun_t) ASN1Dec_PvkAdditional,
    (ASN1DecFun_t) ASN1Dec_SafeContents,
    (ASN1DecFun_t) ASN1Dec_SafeBag,
    (ASN1DecFun_t) ASN1Dec_KeyBag,
    (ASN1DecFun_t) ASN1Dec_CertCRLBag,
    (ASN1DecFun_t) ASN1Dec_CertCRL,
    (ASN1DecFun_t) ASN1Dec_X509Bag,
    (ASN1DecFun_t) ASN1Dec_SDSICertBag,
    (ASN1DecFun_t) ASN1Dec_SecretBag,
    (ASN1DecFun_t) ASN1Dec_SecretAdditional,
    (ASN1DecFun_t) ASN1Dec_AuthenticatedSafe,
    (ASN1DecFun_t) ASN1Dec_Secret,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_PFX,
    (ASN1DecFun_t) ASN1Dec_PVKSupportingData,
    (ASN1DecFun_t) ASN1Dec_PrivateKey,
    (ASN1DecFun_t) ASN1Dec_EncryptedData,
    (ASN1DecFun_t) ASN1Dec_ESPVK,
    (ASN1DecFun_t) ASN1Dec_EncryptedPrivateKeyInfo,
};
static const ASN1FreeFun_t freefntab[22] = {
    (ASN1FreeFun_t) ASN1Free_RSAData,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_PBEParameter,
    (ASN1FreeFun_t) ASN1Free_PvkAdditional,
    (ASN1FreeFun_t) ASN1Free_SafeContents,
    (ASN1FreeFun_t) ASN1Free_SafeBag,
    (ASN1FreeFun_t) ASN1Free_KeyBag,
    (ASN1FreeFun_t) ASN1Free_CertCRLBag,
    (ASN1FreeFun_t) ASN1Free_CertCRL,
    (ASN1FreeFun_t) ASN1Free_X509Bag,
    (ASN1FreeFun_t) ASN1Free_SDSICertBag,
    (ASN1FreeFun_t) ASN1Free_SecretBag,
    (ASN1FreeFun_t) ASN1Free_SecretAdditional,
    (ASN1FreeFun_t) ASN1Free_AuthenticatedSafe,
    (ASN1FreeFun_t) ASN1Free_Secret,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_PFX,
    (ASN1FreeFun_t) ASN1Free_PVKSupportingData,
    (ASN1FreeFun_t) ASN1Free_PrivateKey,
    (ASN1FreeFun_t) ASN1Free_EncryptedData,
    (ASN1FreeFun_t) ASN1Free_ESPVK,
    (ASN1FreeFun_t) ASN1Free_EncryptedPrivateKeyInfo,
};
static const ULONG sizetab[22] = {
    SIZE_PFXNSCP_Module_PDU_0,
    SIZE_PFXNSCP_Module_PDU_1,
    SIZE_PFXNSCP_Module_PDU_2,
    SIZE_PFXNSCP_Module_PDU_3,
    SIZE_PFXNSCP_Module_PDU_4,
    SIZE_PFXNSCP_Module_PDU_5,
    SIZE_PFXNSCP_Module_PDU_6,
    SIZE_PFXNSCP_Module_PDU_7,
    SIZE_PFXNSCP_Module_PDU_8,
    SIZE_PFXNSCP_Module_PDU_9,
    SIZE_PFXNSCP_Module_PDU_10,
    SIZE_PFXNSCP_Module_PDU_11,
    SIZE_PFXNSCP_Module_PDU_12,
    SIZE_PFXNSCP_Module_PDU_13,
    SIZE_PFXNSCP_Module_PDU_14,
    SIZE_PFXNSCP_Module_PDU_15,
    SIZE_PFXNSCP_Module_PDU_16,
    SIZE_PFXNSCP_Module_PDU_17,
    SIZE_PFXNSCP_Module_PDU_18,
    SIZE_PFXNSCP_Module_PDU_19,
    SIZE_PFXNSCP_Module_PDU_20,
    SIZE_PFXNSCP_Module_PDU_21,
};

/* forward declarations of values: */
/* definitions of value components: */
ASN1objectidentifier2_t rsa1 = {
    4, { 1, 2, 840, 113549 }
};
ASN1objectidentifier2_t pkcs_12 = {
    6, { 1, 2, 840, 113549, 1, 12 }
};
ASN1objectidentifier2_t pkcs_12ModeIds = {
    7, { 1, 2, 840, 113549, 1, 12, 1 }
};
ASN1objectidentifier2_t off_lineTransportMode = {
    8, { 1, 2, 840, 113549, 1, 12, 1, 1 }
};
/* definitions of values: */
ASN1bool_t PVKSupportingData_regenerable_default = 0;
Version AuthenticatedSafe_version_default = 1;

void ASN1CALL PFXNSCP_Module_Startup(void)
{
    PFXNSCP_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 22, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x6e786670);
}

void ASN1CALL PFXNSCP_Module_Cleanup(void)
{
    ASN1_CloseModule(PFXNSCP_Module);
    PFXNSCP_Module = NULL;
}

static int ASN1CALL ASN1Enc_RSAData(ASN1encoding_t enc, ASN1uint32_t tag, RSAData *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAData(ASN1decoding_t dec, ASN1uint32_t tag, RSAData *val)
{
    if (!ASN1BERDecOctetString(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAData(RSAData *val)
{
    if (val) {
	ASN1octetstring_free(val);
    }
}

static int ASN1CALL ASN1Enc_BaggageItem_unencryptedSecrets(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem_unencryptedSecrets *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SafeBag(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BaggageItem_unencryptedSecrets(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem_unencryptedSecrets *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (SafeBag *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_SafeBag(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BaggageItem_unencryptedSecrets(BaggageItem_unencryptedSecrets *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SafeBag(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SafeBag(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BaggageItem_espvks(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem_espvks *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_ESPVK(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BaggageItem_espvks(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem_espvks *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (ESPVK *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_ESPVK(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BaggageItem_espvks(BaggageItem_espvks *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_ESPVK(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_ESPVK(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->content);
	}
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Attribute *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_PBEParameter(ASN1encoding_t enc, ASN1uint32_t tag, PBEParameter *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->iterationCount))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PBEParameter(ASN1decoding_t dec, ASN1uint32_t tag, PBEParameter *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->iterationCount))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PBEParameter(PBEParameter *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_Baggage(ASN1encoding_t enc, ASN1uint32_t tag, Baggage *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_BaggageItem(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Baggage(ASN1decoding_t dec, ASN1uint32_t tag, Baggage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (BaggageItem *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_BaggageItem(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Baggage(Baggage *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_BaggageItem(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_BaggageItem(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_BaggageItem(ASN1encoding_t enc, ASN1uint32_t tag, BaggageItem *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_BaggageItem_espvks(enc, 0, &(val)->espvks))
	return 0;
    if (!ASN1Enc_BaggageItem_unencryptedSecrets(enc, 0, &(val)->unencryptedSecrets))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BaggageItem(ASN1decoding_t dec, ASN1uint32_t tag, BaggageItem *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_BaggageItem_espvks(dd, 0, &(val)->espvks))
	return 0;
    if (!ASN1Dec_BaggageItem_unencryptedSecrets(dd, 0, &(val)->unencryptedSecrets))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_BaggageItem(BaggageItem *val)
{
    if (val) {
	ASN1Free_BaggageItem_espvks(&(val)->espvks);
	ASN1Free_BaggageItem_unencryptedSecrets(&(val)->unencryptedSecrets);
    }
}

static int ASN1CALL ASN1Enc_PvkAdditional(ASN1encoding_t enc, ASN1uint32_t tag, PvkAdditional *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->pvkAdditionalType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->pvkAdditionalContent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PvkAdditional(ASN1decoding_t dec, ASN1uint32_t tag, PvkAdditional *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->pvkAdditionalType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->pvkAdditionalContent))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PvkAdditional(PvkAdditional *val)
{
    if (val) {
	ASN1open_free(&(val)->pvkAdditionalContent);
    }
}

static int ASN1CALL ASN1Enc_SafeContents(ASN1encoding_t enc, ASN1uint32_t tag, SafeContents *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SafeBag(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SafeContents(ASN1decoding_t dec, ASN1uint32_t tag, SafeContents *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (SafeBag *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_SafeBag(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SafeContents(SafeContents *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SafeBag(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SafeBag(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SafeBag(ASN1encoding_t enc, ASN1uint32_t tag, SafeBag *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->safeBagType))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->safeBagContent))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->safeBagName).length, ((val)->safeBagName).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SafeBag(ASN1decoding_t dec, ASN1uint32_t tag, SafeBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->safeBagType))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->safeBagContent))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1e) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->safeBagName))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SafeBag(SafeBag *val)
{
    if (val) {
	ASN1open_free(&(val)->safeBagContent);
	if ((val)->o[0] & 0x80) {
	    ASN1char16string_free(&(val)->safeBagName);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyBag(ASN1encoding_t enc, ASN1uint32_t tag, KeyBag *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_PrivateKey(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyBag(ASN1decoding_t dec, ASN1uint32_t tag, KeyBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (PrivateKey *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_PrivateKey(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyBag(KeyBag *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_PrivateKey(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_PrivateKey(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertCRLBag(ASN1encoding_t enc, ASN1uint32_t tag, CertCRLBag *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_CertCRL(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertCRLBag(ASN1decoding_t dec, ASN1uint32_t tag, CertCRLBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (CertCRL *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_CertCRL(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertCRLBag(CertCRLBag *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CertCRL(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CertCRL(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertCRL(ASN1encoding_t enc, ASN1uint32_t tag, CertCRL *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->bagId))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertCRL(ASN1decoding_t dec, ASN1uint32_t tag, CertCRL *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->bagId))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertCRL(CertCRL *val)
{
    if (val) {
	ASN1open_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_X509Bag(ASN1encoding_t enc, ASN1uint32_t tag, X509Bag *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->certOrCRL))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X509Bag(ASN1decoding_t dec, ASN1uint32_t tag, X509Bag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->certOrCRL))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_X509Bag(X509Bag *val)
{
    if (val) {
	ASN1Free_ContentInfo(&(val)->certOrCRL);
    }
}

static int ASN1CALL ASN1Enc_SDSICertBag(ASN1encoding_t enc, ASN1uint32_t tag, SDSICertBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    t = lstrlenA((val)->value);
    if (!ASN1DEREncCharString(enc, 0x16, t, (val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SDSICertBag(ASN1decoding_t dec, ASN1uint32_t tag, SDSICertBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecZeroCharString(dd, 0x16, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SDSICertBag(SDSICertBag *val)
{
    if (val) {
	ASN1ztcharstring_free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SecretBag(ASN1encoding_t enc, ASN1uint32_t tag, SecretBag *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Secret(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecretBag(ASN1decoding_t dec, ASN1uint32_t tag, SecretBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Secret *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_Secret(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecretBag(SecretBag *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Secret(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Secret(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SecretAdditional(ASN1encoding_t enc, ASN1uint32_t tag, SecretAdditional *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->secretAdditionalType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->secretAdditionalContent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecretAdditional(ASN1decoding_t dec, ASN1uint32_t tag, SecretAdditional *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->secretAdditionalType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->secretAdditionalContent))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecretAdditional(SecretAdditional *val)
{
    if (val) {
	ASN1open_free(&(val)->secretAdditionalContent);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_ContentEncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentEncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentEncryptionAlgorithmIdentifier(ContentEncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_MacData(ASN1encoding_t enc, ASN1uint32_t tag, MacData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestInfo(enc, 0, &(val)->safeMAC))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->macSalt).length, ((val)->macSalt).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MacData(ASN1decoding_t dec, ASN1uint32_t tag, MacData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestInfo(dd, 0, &(val)->safeMAC))
	return 0;
    if (!ASN1BERDecBitString(dd, 0x3, &(val)->macSalt))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MacData(MacData *val)
{
    if (val) {
	ASN1Free_DigestInfo(&(val)->safeMAC);
	ASN1bitstring_free(&(val)->macSalt);
    }
}

static int ASN1CALL ASN1Enc_AuthenticatedSafe(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticatedSafe *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->version == 1)
	o[0] &= ~0x80;
    if (!ASN1objectidentifier2_cmp(&val->transportMode, &off_lineTransportMode))
	o[0] &= ~0x40;
    if (o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	    return 0;
    }
    if (o[0] & 0x40) {
	if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->transportMode))
	    return 0;
    }
    if (o[0] & 0x20) {
	if (!ASN1DEREncBitString(enc, 0x3, ((val)->privacySalt).length, ((val)->privacySalt).value))
	    return 0;
    }
    if (o[0] & 0x10) {
	if (!ASN1Enc_Baggage(enc, 0, &(val)->baggage))
	    return 0;
    }
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->safe))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticatedSafe(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticatedSafe *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x6) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->transportMode))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x3) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecBitString(dd, 0x3, &(val)->privacySalt))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x10;
	if (!ASN1Dec_Baggage(dd, 0, &(val)->baggage))
	    return 0;
    }
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->safe))
	return 0;
    if (!((val)->o[0] & 0x80))
	(val)->version = 1;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticatedSafe(AuthenticatedSafe *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	}
	if ((val)->o[0] & 0x20) {
	    ASN1bitstring_free(&(val)->privacySalt);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_Baggage(&(val)->baggage);
	}
	ASN1Free_ContentInfo(&(val)->safe);
    }
}

static int ASN1CALL ASN1Enc_Thumbprint(ASN1encoding_t enc, ASN1uint32_t tag, Thumbprint *val)
{
    if (!ASN1Enc_DigestInfo(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Thumbprint(ASN1decoding_t dec, ASN1uint32_t tag, Thumbprint *val)
{
    if (!ASN1Dec_DigestInfo(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Thumbprint(Thumbprint *val)
{
    if (val) {
	ASN1Free_DigestInfo(val);
    }
}

static int ASN1CALL ASN1Enc_Secret(ASN1encoding_t enc, ASN1uint32_t tag, Secret *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->secretName).length, ((val)->secretName).value))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->secretType))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_SecretAdditional(enc, 0, &(val)->secretAdditional))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Secret(ASN1decoding_t dec, ASN1uint32_t tag, Secret *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->secretName))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->secretType))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->value))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_SecretAdditional(dd, 0, &(val)->secretAdditional))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Secret(Secret *val)
{
    if (val) {
	ASN1char16string_free(&(val)->secretName);
	ASN1open_free(&(val)->value);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_SecretAdditional(&(val)->secretAdditional);
	}
    }
}

static int ASN1CALL ASN1Enc_PVKSupportingData_assocCerts(ASN1encoding_t enc, ASN1uint32_t tag, PVKSupportingData_assocCerts *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Thumbprint(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PVKSupportingData_assocCerts(ASN1decoding_t dec, ASN1uint32_t tag, PVKSupportingData_assocCerts *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Thumbprint *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_Thumbprint(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PVKSupportingData_assocCerts(PVKSupportingData_assocCerts *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Thumbprint(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Thumbprint(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_PrivateKeyAlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_PrivateKeyAlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->privateKey))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_PrivateKeyAlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	ASN1octetstring_free(&(val)->privateKey);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Enc_ContentEncryptionAlgorithmIdentifier(enc, 0, &(val)->contentEncryptionAlg))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->encryptedContent).length, ((val)->encryptedContent).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Dec_ContentEncryptionAlgorithmIdentifier(dd, 0, &(val)->contentEncryptionAlg))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->encryptedContent))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val)
{
    if (val) {
	ASN1Free_ContentEncryptionAlgorithmIdentifier(&(val)->contentEncryptionAlg);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->encryptedContent);
	}
    }
}

static int ASN1CALL ASN1Enc_PFX(ASN1encoding_t enc, ASN1uint32_t tag, PFX *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MacData(enc, 0x80000000, &(val)->macData))
	    return 0;
    }
    if (!ASN1Enc_ContentInfo(enc, 0x80000001, &(val)->authSafe))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PFX(ASN1decoding_t dec, ASN1uint32_t tag, PFX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_MacData(dd, 0x80000000, &(val)->macData))
	    return 0;
    }
    if (!ASN1Dec_ContentInfo(dd, 0x80000001, &(val)->authSafe))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PFX(PFX *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MacData(&(val)->macData);
	}
	ASN1Free_ContentInfo(&(val)->authSafe);
    }
}

static int ASN1CALL ASN1Enc_PVKSupportingData(ASN1encoding_t enc, ASN1uint32_t tag, PVKSupportingData *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->regenerable)
	o[0] &= ~0x80;
    if (!ASN1Enc_PVKSupportingData_assocCerts(enc, 0, &(val)->assocCerts))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncBool(enc, 0x1, (val)->regenerable))
	    return 0;
    }
    if (!ASN1DEREncChar16String(enc, 0x1e, ((val)->nickname).length, ((val)->nickname).value))
	return 0;
    if (o[0] & 0x40) {
	if (!ASN1Enc_PvkAdditional(enc, 0, &(val)->pvkAdditional))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PVKSupportingData(ASN1decoding_t dec, ASN1uint32_t tag, PVKSupportingData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_PVKSupportingData_assocCerts(dd, 0, &(val)->assocCerts))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x1) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecBool(dd, 0x1, &(val)->regenerable))
	    return 0;
    }
    if (!ASN1BERDecChar16String(dd, 0x1e, &(val)->nickname))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_PvkAdditional(dd, 0, &(val)->pvkAdditional))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->regenerable = 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PVKSupportingData(PVKSupportingData *val)
{
    if (val) {
	ASN1Free_PVKSupportingData_assocCerts(&(val)->assocCerts);
	ASN1char16string_free(&(val)->nickname);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_PvkAdditional(&(val)->pvkAdditional);
	}
    }
}

static int ASN1CALL ASN1Enc_PrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_PVKSupportingData(enc, 0, &(val)->pvkData))
	return 0;
    if (!ASN1Enc_PrivateKeyInfo(enc, 0, &(val)->pkcs8data))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_PVKSupportingData(dd, 0, &(val)->pvkData))
	return 0;
    if (!ASN1Dec_PrivateKeyInfo(dd, 0, &(val)->pkcs8data))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKey(PrivateKey *val)
{
    if (val) {
	ASN1Free_PVKSupportingData(&(val)->pvkData);
	ASN1Free_PrivateKeyInfo(&(val)->pkcs8data);
    }
}

static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val)
{
    if (val) {
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_ESPVK(ASN1encoding_t enc, ASN1uint32_t tag, ESPVK *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->espvkObjID))
	return 0;
    if (!ASN1Enc_PVKSupportingData(enc, 0, &(val)->espvkData))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->espvkCipherText))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ESPVK(ASN1decoding_t dec, ASN1uint32_t tag, ESPVK *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->espvkObjID))
	return 0;
    if (!ASN1Dec_PVKSupportingData(dd, 0, &(val)->espvkData))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->espvkCipherText))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ESPVK(ESPVK *val)
{
    if (val) {
	ASN1Free_PVKSupportingData(&(val)->espvkData);
	ASN1open_free(&(val)->espvkCipherText);
    }
}

static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_EncryptionAlgorithmIdentifier(enc, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1Enc_EncryptedData(enc, 0, &(val)->encryptedData))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_EncryptionAlgorithmIdentifier(dd, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1Dec_EncryptedData(dd, 0, &(val)->encryptedData))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_EncryptionAlgorithmIdentifier(&(val)->encryptionAlgorithm);
	ASN1Free_EncryptedData(&(val)->encryptedData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pfxmain.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"

#include <wincrypt.h>
#include "pfxhelp.h"
#include "pfxcmn.h"
#include "pfxcrypt.h"
#include "pfx.h"
#include "impexppk.h"
#include "encdecpk.h"
#include <rpcdce.h>

HINSTANCE           g_hInst;


BOOL   
WINAPI   
CryptPFXDllMain(
        HMODULE hInst, 
        ULONG ul_reason_for_call,
        LPVOID lpReserved)
{

    if (!ImportExportDllMain(hInst, ul_reason_for_call, lpReserved))
    {
        goto ImportExportError;
    }

    if (!EncodeDecodeDllMain(hInst, ul_reason_for_call, lpReserved))
    {
        goto EncodeDecodeError;
    }

    switch( ul_reason_for_call ) 
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hInst;

        if (!InitPFX())
            goto InitPFXError;
        if (!InitNSCP())
            goto InitNSCPError;

        break;

    case DLL_PROCESS_DETACH:
        TerminatePFX();
        TerminateNSCP();
        break;

    default:
        break;
    }


    return TRUE;   

InitNSCPError:
    TerminatePFX();
InitPFXError:
    EncodeDecodeDllMain(hInst, DLL_PROCESS_DETACH, NULL);
EncodeDecodeError:
    ImportExportDllMain(hInst, DLL_PROCESS_DETACH, NULL);
ImportExportError:
    return FALSE;
}



BOOL FreeCryptSafeContents(
	SAFE_CONTENTS *pSafeContents
	)
{
	DWORD i,j,k;


	// loop for each SAFE_BAG
	for (i=0; i<pSafeContents->cSafeBags; i++) {

        if (pSafeContents->pSafeBags[i].pszBagTypeOID)
            SSFree(pSafeContents->pSafeBags[i].pszBagTypeOID);

        if (pSafeContents->pSafeBags[i].BagContents.pbData)
			SSFree(pSafeContents->pSafeBags[i].BagContents.pbData);

		// loop for each attribute
		for (j=0; j<pSafeContents->pSafeBags[i].Attributes.cAttr; j++) {
			
            if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId)
                SSFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId);

            // l0op for each value
			for (k=0; k<pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue; k++) {
				
				if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData)
					SSFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData);
			}

			// free the value struct array
			if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue)
				SSFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue);
		}

		// free the attribute struct array
		if (pSafeContents->pSafeBags[i].Attributes.rgAttr)
			SSFree(pSafeContents->pSafeBags[i].Attributes.rgAttr);
	}

    if (pSafeContents->pSafeBags)
        SSFree(pSafeContents->pSafeBags);

	return TRUE;
}



BOOL CALLBACK 
Decrypt_Private_Key(
        CRYPT_ALGORITHM_IDENTIFIER  Alg,
        CRYPT_DATA_BLOB             EncrBlob,
        BYTE*                       pbClearText,
        DWORD*                      pcbClearText,
        LPVOID                      pVoidDecrypt)
{
    BOOL    fRet = TRUE;
    DWORD   cbSalt = 0;
    BYTE    *pbSalt = NULL;
    int     iIterationCount;
    int     iEncrType;
    BYTE    *pbTempBuffer = NULL;
    DWORD   cbTempBuffer = 0;
    
    if (0 == strcmp(Alg.pszObjId, szOID_PKCS_12_pbeWithSHA1And40BitRC2)) {
        iEncrType = RC2_40;
    }
    else if (0 == strcmp(Alg.pszObjId, szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES)) {
        iEncrType = TripleDES;
    }
    else
        goto ErrorReturn;

    if (!GetSaltAndIterationCount(
            Alg.Parameters.pbData, 
            Alg.Parameters.cbData,
            &pbSalt,
            &cbSalt,
            &iIterationCount)) {
        goto ErrorReturn;
    }
    
    // since the decode is done in-place, copy the buffer to decode into a temp buffer,
    // we need to use our temp buffer because the decrypt function may do a realloc
    // on the decode buffer
    if (NULL == (pbTempBuffer = (BYTE *) SSAlloc(EncrBlob.cbData)))
        goto ErrorReturn;

    memcpy(pbTempBuffer, EncrBlob.pbData, EncrBlob.cbData);
    cbTempBuffer = EncrBlob.cbData;

    if (!PFXPasswordDecryptData(
            iEncrType, 
            (LPWSTR) pVoidDecrypt,

            iIterationCount,
            pbSalt,      
            cbSalt,

            &pbTempBuffer,
            &cbTempBuffer))
        goto SetPFXDecryptError;

    // if pcbClearText is not 0 and there is not enough space then error out
    if ((0 != *pcbClearText) && (*pcbClearText < cbTempBuffer)){
        *pcbClearText = cbTempBuffer;
        goto Ret;
    }
    else if (0 != *pcbClearText) {
        memcpy(pbClearText, pbTempBuffer, cbTempBuffer);
    }

    *pcbClearText = cbTempBuffer;

    goto Ret;

SetPFXDecryptError:
    SetLastError(NTE_FAIL);
    fRet = FALSE;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    
    if (pbSalt)
        SSFree(pbSalt);

    if (pbTempBuffer)
        SSFree(pbTempBuffer);

    return fRet;
}


typedef struct _ENCRYPT_PRIVATE_PARAM_DATASTRUCT
{
    HCRYPTPROV  hVerifyProv;
    LPCWSTR     szPwd;
} ENCRYPT_PRIVATE_PARAM_DATASTRUCT, *PENCRYPT_PRIVATE_PARAM_DATASTRUCT;


BOOL CALLBACK 
Encrypt_Private_Key(
        CRYPT_ALGORITHM_IDENTIFIER* pAlg,
        CRYPT_DATA_BLOB*            pClearTextPrivateKey,
        BYTE*                       pbEncryptedKey,
        DWORD*                      pcbEncryptedKey,
        LPVOID                      pVoidEncrypt)
{
    BOOL    fRet = TRUE;
    DWORD   cbSalt = 0;
    BYTE    *pbSalt = NULL;
    int     iIterationCount;
    int     iEncrType;
    BYTE    *pbTempBuffer = NULL;
    DWORD   cbTempBuffer = 0;

    // crack param
    ENCRYPT_PRIVATE_PARAM_DATASTRUCT* pParam = (ENCRYPT_PRIVATE_PARAM_DATASTRUCT*)pVoidEncrypt;
    HCRYPTPROV  hVerifyProv = pParam->hVerifyProv;
    LPCWSTR     szPwd = pParam->szPwd;
    
    // use hardcoded params
    iEncrType = TripleDES;
    iIterationCount = PKCS12_ENCR_PWD_ITERATIONS;
	pbSalt = (BYTE *) SSAlloc(PBE_SALT_LENGTH);
    if (pbSalt == NULL)
        goto SetPFXAllocError;

	cbSalt = PBE_SALT_LENGTH;

	if (!CryptGenRandom(hVerifyProv, cbSalt, pbSalt))
		goto ErrorReturn;

    // out param
    pAlg->pszObjId = szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES;

    if (!SetSaltAndIterationCount(
            &pAlg->Parameters.pbData, 
            &pAlg->Parameters.cbData,
            pbSalt,
            cbSalt,
            iIterationCount)) {
        goto ErrorReturn;
    }
    
    // since the decode is done in-place, copy the buffer to decode into a temp buffer,
    // we need to use our temp buffer because the decrypt function may do a realloc
    // on the decode buffer
    if (NULL == (pbTempBuffer = (BYTE *) SSAlloc(pClearTextPrivateKey->cbData)))
        goto SetPFXAllocError;

    CopyMemory(pbTempBuffer, pClearTextPrivateKey->pbData, pClearTextPrivateKey->cbData);
    cbTempBuffer = pClearTextPrivateKey->cbData;

    if (!PFXPasswordEncryptData(
            iEncrType, 
            szPwd,

            (pbEncryptedKey == NULL) ? 1 : iIterationCount,     // don't bother iterating if we're just sizing
            pbSalt,      
            cbSalt,

            &pbTempBuffer,
            &cbTempBuffer))
        goto SetPFXDecryptError;

    // if pcbEncryptedKey is not 0 and there is not enough space then error out
    if  (pbEncryptedKey == NULL)
    {
        // just sizing; return cb
        *pcbEncryptedKey = cbTempBuffer;
        goto Ret;
    }
    else if (*pcbEncryptedKey < cbTempBuffer)
    {
        // buffer passed in too small
        *pcbEncryptedKey = cbTempBuffer;
        goto ErrorReturn;
    }
    else
    {
        // buffer sufficient
        memcpy(pbEncryptedKey, pbTempBuffer, cbTempBuffer);
        *pcbEncryptedKey = cbTempBuffer;
    }


    goto Ret;

SetPFXDecryptError:
    SetLastError(NTE_FAIL);
    fRet = FALSE;
    goto Ret;

SetPFXAllocError:
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    fRet = FALSE;
    goto Ret;

ErrorReturn:
    fRet = FALSE;
Ret:
    
    if (pbSalt)
        SSFree(pbSalt);

    if (pbTempBuffer)
        SSFree(pbTempBuffer);

    return fRet;
}


BOOL 
GetNamedProviderType(
    LPCWSTR pwszProvName,
    DWORD   *pdwProvType)
{
    BOOL    fResult = FALSE;
    LPWSTR  pwszTempProvName;
    DWORD   cbTempProvName;
    DWORD   dwProvType;
    DWORD   dwProvIndex;

    for (dwProvIndex = 0; TRUE; dwProvIndex++) 
    {
        cbTempProvName = 0;
        dwProvType = 0;
        pwszTempProvName = NULL;

        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                NULL,               // pwszProvName,
                &cbTempProvName
                ) || 0 == cbTempProvName) 
        {
            if (ERROR_NO_MORE_ITEMS != GetLastError())
            {
                break;
            }
        }
        
        if (NULL == (pwszTempProvName = (LPWSTR) SSAlloc(
                (cbTempProvName + 1) * sizeof(WCHAR))))
        {
            break;
        }

        if (!CryptEnumProvidersU(
                dwProvIndex,
                NULL,               // pdwReserved
                0,                  // dwFlags
                &dwProvType,
                pwszTempProvName,
                &cbTempProvName
                )) 
        {
            SSFree(pwszTempProvName);
            break;
        }

        if (0 == wcscmp(pwszTempProvName, pwszProvName))
        {
            *pdwProvType = dwProvType;
            fResult = TRUE;
            SSFree(pwszTempProvName);
            break;
        }

        SSFree(pwszTempProvName);
    }

    return fResult;
}

BOOL CALLBACK
HCryptProv_Query_Func(
	CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,
	DWORD				dwSafeBagIndex,		
	HCRYPTPROV			*phCryptProv,
	LPVOID				pVoidhCryptProvQuery,
    DWORD               dwPFXImportFlags
	)
{
    DWORD           dwErr = ERROR_SUCCESS;

    SAFE_CONTENTS *pSafeContents = (SAFE_CONTENTS *) pVoidhCryptProvQuery;
	DWORD i = 0;
	WCHAR			szName[256];
    DWORD           dwLocalMachineFlag = 0;
    GUID            guidContainerName;
    DWORD           cbProviderName = 0;
    CERT_NAME_VALUE *providerName = NULL;
    LPWSTR          szSizeDeterminedProvider = NULL;
    DWORD           dwKeyBitLen;
    DWORD           dwProvType;
    RPC_STATUS      rpcStatus;

    // UNDONE: support other than RSA or DSA keys
    if ((pPrivateKeyInfo->Algorithm.pszObjId) &&
        !(  (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_RSA_RSA)) ||
            (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_ANSI_X942_DH)) ||
            (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_OIWSEC_dsa)) ||
            (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_X957_DSA))))
    {
        SetLastError(NTE_BAD_ALGID);
        goto ErrorReturn;
    }

    // generate a GUID as the containter name for the keyset being imported
    rpcStatus = UuidCreate(&guidContainerName);
    if ((rpcStatus != RPC_S_OK) && (rpcStatus != RPC_S_UUID_LOCAL_ONLY))
    {
        SetLastError(rpcStatus);
        goto ErrorReturn;
    }
    guid2wstr(&guidContainerName, &(szName[0]));

    // get the provider name
    while ((i<pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr) && 
		(strcmp(pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].pszObjId, szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR) != 0)) {
		i++;
	}

    // check to see if a provider name was found
    if (i<pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr)
    {
	    // decode the provider name
	    if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].rgValue[0].pbData,
			    pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].rgValue[0].cbData,
			    0,
			    NULL,
			    &cbProviderName)) {
		    goto ErrorReturn;
	    }

	    if (NULL == (providerName = (CERT_NAME_VALUE *) SSAlloc(cbProviderName)))
		    goto SetPFXAllocError;
	    
	    // decode the provider name
	    if (!CryptDecodeObject(
			    X509_ASN_ENCODING,
			    X509_UNICODE_ANY_STRING,
			    pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].rgValue[0].pbData,
			    pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].rgValue[0].cbData,
			    0,
			    (BYTE *) providerName,
			    &cbProviderName)) {
		    goto ErrorReturn;
	    }
    }
    
    // check to see if the szOID_LOCAL_MACHINE_KEYSET OID is present
    i = 0;
	while ((i<pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr) && 
		(strcmp(pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.rgAttr[i].pszObjId, szOID_LOCAL_MACHINE_KEYSET) != 0)) {
		i++;
	}
    if (i<pSafeContents->pSafeBags[dwSafeBagIndex].Attributes.cAttr)
    {
        dwLocalMachineFlag = CRYPT_MACHINE_KEYSET;    
    }

    // regardless of whether the CRYPT_MACHINE_KEYSET property was in the pfx blob,
    // if the caller specifies a preference of user or local machine honor that
    // preference ultimately
    if (dwPFXImportFlags & CRYPT_MACHINE_KEYSET)
    {
        dwLocalMachineFlag = CRYPT_MACHINE_KEYSET; 
    }
    else if (dwPFXImportFlags & CRYPT_USER_KEYSET)
    {
        dwLocalMachineFlag = 0;
    }

    // still don't know where to put this: need keysize to determine
    if ((NULL == providerName) && (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_RSA_RSA)))
    {
        PBYTE pbRSAPrivateKey = NULL;
        DWORD cbRSAPrivateKey;

        // decode the rsa der-encoded keyblob into a CAPI type keyblob
	    if (!CryptDecodeObject(X509_ASN_ENCODING,
						    PKCS_RSA_PRIVATE_KEY,
						    pPrivateKeyInfo->PrivateKey.pbData,
						    pPrivateKeyInfo->PrivateKey.cbData,
						    CRYPT_DECODE_NOCOPY_FLAG,
						    NULL,
						    &cbRSAPrivateKey))
		    goto ErrorReturn;

	    if (NULL == (pbRSAPrivateKey = (BYTE *) SSAlloc(cbRSAPrivateKey)))
		    goto SetPFXAllocError;

	    if (!CryptDecodeObject(X509_ASN_ENCODING,
						    PKCS_RSA_PRIVATE_KEY,
						    pPrivateKeyInfo->PrivateKey.pbData,
						    pPrivateKeyInfo->PrivateKey.cbData,
						    CRYPT_DECODE_NOCOPY_FLAG,
						    pbRSAPrivateKey,
						    &cbRSAPrivateKey))
        {
		    if (pbRSAPrivateKey)
                SSFree(pbRSAPrivateKey);

            goto ErrorReturn;
        }

        dwKeyBitLen = 
		    ((RSAPUBKEY*) (pbRSAPrivateKey + sizeof(BLOBHEADER)) )->bitlen;

        szSizeDeterminedProvider = (dwKeyBitLen <= 1024) ? MS_DEF_PROV_W : MS_ENHANCED_PROV_W;

        ZeroMemory(pbRSAPrivateKey, cbRSAPrivateKey);
        SSFree(pbRSAPrivateKey); 
    }
    
    if (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_RSA_RSA))
    {
        if ((providerName == NULL) || (!GetNamedProviderType((LPWSTR)providerName->Value.pbData, &dwProvType)))
        {
            dwProvType = PROV_RSA_FULL;
        }

        // if we have a prov name AND acq works, we're done
        // try prov name if given to us
        if (CryptAcquireContextU(
                        phCryptProv,
                        szName,                                 
                        (providerName != NULL) ? (LPWSTR)providerName->Value.pbData : szSizeDeterminedProvider,
                        dwProvType,
                        dwLocalMachineFlag | CRYPT_NEWKEYSET  ))
            goto CommonReturn;

        // otherwise attempt default
        if (CryptAcquireContextU(
                        phCryptProv,
                        szName,                                 
                        NULL, 
                        PROV_RSA_FULL,
                        dwLocalMachineFlag | CRYPT_NEWKEYSET  ))
            goto CommonReturn;

        // Neither succeeded; fail
    }
    else
    {
        if ((providerName == NULL) || (!GetNamedProviderType((LPWSTR)providerName->Value.pbData, &dwProvType)))
        {
            dwProvType = PROV_DSS_DH;
        }
        
        if (CryptAcquireContextU(
                        phCryptProv,
                        szName,                                 
                        (providerName != NULL) ? (LPWSTR)providerName->Value.pbData : MS_DEF_DSS_DH_PROV_W,
                        dwProvType,
                        dwLocalMachineFlag | CRYPT_NEWKEYSET  ))
        {
            goto CommonReturn;
        }
        else if (CryptAcquireContextU(
                        phCryptProv,
                        szName,                                 
                        NULL, 
                        PROV_DSS_DH,
                        dwLocalMachineFlag | CRYPT_NEWKEYSET  ))
        {
            goto CommonReturn;
        }


        // did not succeed, so fail
    }

ErrorReturn:
    dwErr = GetLastError();
    goto CommonReturn;

SetPFXAllocError:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto CommonReturn;

CommonReturn:
	
    if (providerName)
        SSFree(providerName);

    return (ERROR_SUCCESS == dwErr);
}


IMPORT_SAFE_CALLBACK_STRUCT g_sImportCallbacks = {HCryptProv_Query_Func, NULL, Decrypt_Private_Key, NULL};



//+-------------------------------------------------------------------------
//	PFXImportCertStore
//
//  Import the PFX blob and return a store containing certificates
//
//  if the password parameter is incorrect or any other problems decoding
//  the PFX blob are encountered, the function will return NULL and the
//	error code can be found from GetLastError(). 
//
//  The dwFlags parameter may be set to:
//  CRYPT_EXPORTABLE - which would then specify that any imported keys should 
//     be marked as exportable (see documentation on CryptImportKey)
//  CRYPT_USER_PROTECTED - (see documentation on CryptImportKey)
//  PKCS12_NO_DATA_COMMIT - will unpack the pfx blob but does not persist its contents.
//                       In this case, returns BOOL indicating successful unpack.
//  CRYPT_MACHINE_KEYSET - used to force the private key to be stored in the
//                        the local machine and not the current user.
//  CRYPT_USER_KEYSET - used to force the private key to be stored in the
//                      the current user and not the local machine, even if
//                      the pfx blob specifies that it should go into local machine.
//--------------------------------------------------------------------------
#define PKCS12_NO_DATA_COMMIT     0x10000000  // unpack but don't persist results

HCERTSTORE
WINAPI
PFXImportCertStore(
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD   dwFlags)
{
    BOOL    fRet = FALSE;
    BOOL    fDataCommit = TRUE;
    HPFX    hPfx = NULL;
    HCERTSTORE hStore = NULL;
    SAFE_CONTENTS sContents; MAKEZERO(sContents);
    SAFE_CONTENTS *pSafeContents = NULL; 
    LPCWSTR szOldNetscapeNull = L"";
    LPCWSTR  szNetscapePassword = NULL;

    if (dwFlags & 
            ~(  CRYPT_EXPORTABLE | CRYPT_USER_PROTECTED | PKCS12_NO_DATA_COMMIT |
                CRYPT_MACHINE_KEYSET | CRYPT_USER_KEYSET))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if ((pPFX == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    // shall we commit the data we unpack? 
    if (PKCS12_NO_DATA_COMMIT == (dwFlags & PKCS12_NO_DATA_COMMIT))
    {
        // no
        fDataCommit = FALSE;
    }
    else
    {
        // yes, open a store to populate
        hStore = CertOpenStore(
                    CERT_STORE_PROV_MEMORY, 
                    0,
                    NULL,
                    0, 
                    NULL);
    }
    
    // try to import as real PKCS12
    if (NULL != (hPfx = 
        PfxImportBlob (
            szPassword,
            pPFX->pbData,
            pPFX->cbData,
            dwFlags)) )
    {
        // break out if not saving data
        if (!fDataCommit)
        {
            fRet = TRUE;
            goto Ret;
        }

        // import all private keys and certs
        if (PfxGetKeysAndCerts(hPfx, &sContents))
        {
            g_sImportCallbacks.pVoidhCryptProvQuery = &sContents;
            g_sImportCallbacks.pVoidDecryptFunc = (void *) szPassword;

            if (!CertImportSafeContents(
                    hStore,
                    &sContents,
                    CERT_STORE_ADD_ALWAYS,
                    &g_sImportCallbacks,
                    dwFlags,
                    NULL))
                goto Ret;
        }   
    }
    else 
    {
	if (GetLastError() == CRYPT_E_BAD_ENCODE)
        {
	    // that decode failed; try an old netscape version

            // if the password is NULL then use L"" because that is what 
            // Netscape did in their old version, otherwise just use the password passed in
            if (szPassword == NULL) 
                szNetscapePassword = szOldNetscapeNull;
            else
                szNetscapePassword = szPassword;

            if (NSCPImportBlob(
		szNetscapePassword,
		pPFX->pbData,
		pPFX->cbData,
		&pSafeContents)) 
            { 

                // break out if not saving data
                if (!fDataCommit)
                {
                    fRet = TRUE;
                    goto Ret;
                }
        
                g_sImportCallbacks.pVoidhCryptProvQuery = pSafeContents;
        
	        if (!CertImportSafeContents( 
                            hStore,
                            pSafeContents,
                            CERT_STORE_ADD_ALWAYS,
                            &g_sImportCallbacks,
                            dwFlags,
			    NULL))
                        goto Ret;
        
	        SSFree(pSafeContents);
            }
            else	// nscp import fail
	        goto Ret;
        }
        else 
        {
	    // pfx import fail, not a decoding error
	    goto Ret;
        }
    }

    fRet = TRUE;
Ret:

    if (hPfx)
        PfxCloseHandle(hPfx);

    FreeCryptSafeContents(&sContents);

    if (!fRet)
    {
        if (hStore)
        {
            CertCloseStore(hStore, 0);
            hStore = NULL;
        }
    }

    if (fDataCommit)
        return hStore;
    else
        return (HCERTSTORE)(ULONG_PTR) fRet;
}


EXPORT_SAFE_CALLBACK_STRUCT g_sExportCallbacks = { Encrypt_Private_Key, NULL };


//+-------------------------------------------------------------------------
//      PFXExportCertStoreEx
//
//  Export the certificates and private keys referenced in the passed-in store 
//
//  This API encodes the blob under a stronger algorithm. The resulting
//  PKCS12 blobs are incompatible with the earlier APIs.
//
//  The value passed in the password parameter will be used to encrypt and 
//  verify the integrity of the PFX packet. If any problems encoding the store
//  are encountered, the function will return FALSE and the error code can 
//  be found from GetLastError(). 
//
//  The dwFlags parameter may be set to any combination of 
//      EXPORT_PRIVATE_KEYS
//      REPORT_NO_PRIVATE_KEY
//      REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//  These flags are as documented in the CertExportSafeContents Crypt32 API
//--------------------------------------------------------------------------
BOOL
WINAPI
PFXExportCertStoreEx(
    HCERTSTORE hStore,
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    void*   pvReserved,
    DWORD   dwFlags)
{
    return 
    PFXExportCertStore(
        hStore,
        pPFX,
        szPassword,
        (dwFlags | PKCS12_ENHANCED_STRENGTH_ENCODING) );
}

//+-------------------------------------------------------------------------
//	PFXExportCertStore
//
//  Export the certificates and private keys referenced in the passed-in store 
//
//  This is an old API kept for compatibility with IE4 clients. New applications
//  should call PfxExportCertStoreEx for enhanced security.
//
//  The value passed in the password parameter will be used to encrypt and 
//  verify the integrity of the PFX packet. If any problems encoding the store
//  are encountered, the function will return FALSE and the error code can 
//  be found from GetLastError(). 
//
//  The dwFlags parameter may be set to any combination of 
//      EXPORT_PRIVATE_KEYS
//      REPORT_NO_PRIVATE_KEY
//      REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//      PKCS12_ENHANCED_STRENGTH_ENCODING (used only by ExportCertStoreEx)
//  These flags are as documented in the CertExportSafeContents Crypt32 API
//--------------------------------------------------------------------------

BOOL
WINAPI
PFXExportCertStore(
    HCERTSTORE hStore,
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD   dwFlags)
{
    BOOL    fRet = FALSE;
    SAFE_CONTENTS* pContents = NULL;
    DWORD cbContents = 0;
    HPFX  hPfx = NULL;
    HCRYPTPROV hCrypt = NULL;
    ENCRYPT_PRIVATE_PARAM_DATASTRUCT sParam;

	PCCERT_CONTEXT	pBadCert = NULL;

    if (dwFlags & 
            ~(  EXPORT_PRIVATE_KEYS |
                REPORT_NO_PRIVATE_KEY | 
                REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY |
                PKCS12_ENHANCED_STRENGTH_ENCODING ))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    if ((hStore == NULL) ||
        (pPFX == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    // get HCRYPTPROV for rng 
    if (!CryptAcquireContextA(&hCrypt, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
        goto Ret;

    sParam.hVerifyProv = hCrypt;
    sParam.szPwd = szPassword;
    g_sExportCallbacks.pVoidEncryptFunc = &sParam;

    if (!CertExportSafeContents(
            hStore,
            pContents,
            &cbContents,
            &g_sExportCallbacks,
            dwFlags | PFX_MODE,
            &pBadCert,
            NULL))
        goto Ret;
    pContents = (SAFE_CONTENTS*)SSAlloc(cbContents);
    if (pContents == NULL)
        goto Ret;

    if (!CertExportSafeContents(
            hStore,
            pContents,
            &cbContents,
            &g_sExportCallbacks,
            (pPFX->cbData != 0) ? dwFlags | PFX_MODE | GIVE_ME_DATA : dwFlags | PFX_MODE,
            &pBadCert,
            NULL))
        goto Ret;


    if (NULL == (hPfx = PfxExportCreate(szPassword)) )
        goto Ret;

    if (!PfxAddSafeBags(hPfx, pContents->pSafeBags, pContents->cSafeBags))
        goto Ret;

    // export
    if (!PfxExportBlob(
            hPfx, 
            pPFX->pbData, 
            &pPFX->cbData, 
            dwFlags))
        goto Ret;

    fRet = TRUE;
Ret: 
    
    if (pBadCert != NULL)
        CertFreeCertificateContext(pBadCert);

    if (pContents)
        SSFree(pContents);

    if (hPfx)
        PfxCloseHandle(hPfx);

    if (hCrypt)
    {
        HRESULT hr = GetLastError();
        CryptReleaseContext(hCrypt, 0);
        SetLastError(hr);
    }

    return fRet;
}



//+-------------------------------------------------------------------------
//      IsPFXBlob
//
//  This function will try to decode the outer layer of the blob as a pfx 
//  blob, and if that works it will return TRUE, it will return FALSE otherwise
//
//--------------------------------------------------------------------------
BOOL
WINAPI
PFXIsPFXBlob(
    CRYPT_DATA_BLOB* pPFX)
{
    
    if (IsRealPFXBlob(pPFX))
    {
        return TRUE;
    }

    if (IsNetscapePFXBlob(pPFX))
    {
        return TRUE;
    }	

    return FALSE;
}

                           
//+-------------------------------------------------------------------------
//      VerifyPassword
//
//  This function will attempt to decode the outer layer of the blob as a pfx 
//  blob and decrypt with the given password. No data from the blob will be imported.
//  Return value is TRUE if password appears correct, FALSE otherwise.
//
//--------------------------------------------------------------------------
BOOL 
WINAPI
PFXVerifyPassword(
    CRYPT_DATA_BLOB* pPFX,
    LPCWSTR szPassword,
    DWORD dwFlags)
{
    // uses overloaded ImportCertStore API
    HCERTSTORE h;
    h = PFXImportCertStore(
        pPFX,
        szPassword,
        PKCS12_NO_DATA_COMMIT);

    return (h==NULL) ? FALSE:TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxnscp.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for PFXNSCP */

#ifndef _PFXNSCP_Module_H_
#define _PFXNSCP_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1objectidentifier2_t ObjectID;

typedef ASN1objectidentifier2_t ObjID;

typedef ASN1int32_t Version;
#define Version_v1 1

typedef ObjectID ContentType;

typedef ASN1octetstring_t RSAData;
#define RSAData_PDU 0
#define SIZE_PFXNSCP_Module_PDU_0 sizeof(RSAData)

typedef ASN1open_t Attribute;

typedef ASN1octetstring_t EncryptedContent;

typedef ASN1octetstring_t Digest;

typedef ObjID TransportMode;

typedef struct BaggageItem_unencryptedSecrets {
    ASN1uint32_t count;
    struct SafeBag *value;
} BaggageItem_unencryptedSecrets;

typedef struct BaggageItem_espvks {
    ASN1uint32_t count;
    struct ESPVK *value;
} BaggageItem_espvks;

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define content_present 0x80
    ASN1open_t content;
} ContentInfo;

typedef struct Attributes {
    ASN1uint32_t count;
    Attribute *value;
} Attributes;
#define Attributes_PDU 1
#define SIZE_PFXNSCP_Module_PDU_1 sizeof(Attributes)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;

typedef struct PBEParameter {
    ASN1octetstring_t salt;
    ASN1int32_t iterationCount;
} PBEParameter;
#define PBEParameter_PDU 2
#define SIZE_PFXNSCP_Module_PDU_2 sizeof(PBEParameter)

typedef AlgorithmIdentifier DigestAlgorithmIdentifier;

typedef struct Baggage {
    ASN1uint32_t count;
    struct BaggageItem *value;
} Baggage;

typedef struct BaggageItem {
    BaggageItem_espvks espvks;
    BaggageItem_unencryptedSecrets unencryptedSecrets;
} BaggageItem;

typedef struct PvkAdditional {
    ObjID pvkAdditionalType;
    ASN1open_t pvkAdditionalContent;
} PvkAdditional;
#define PvkAdditional_PDU 3
#define SIZE_PFXNSCP_Module_PDU_3 sizeof(PvkAdditional)

typedef struct SafeContents {
    ASN1uint32_t count;
    struct SafeBag *value;
} SafeContents;
#define SafeContents_PDU 4
#define SIZE_PFXNSCP_Module_PDU_4 sizeof(SafeContents)

typedef struct SafeBag {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjID safeBagType;
    ASN1open_t safeBagContent;
#   define safeBagName_present 0x80
    ASN1char16string_t safeBagName;
} SafeBag;
#define SafeBag_PDU 5
#define SIZE_PFXNSCP_Module_PDU_5 sizeof(SafeBag)

typedef struct KeyBag {
    ASN1uint32_t count;
    struct PrivateKey *value;
} KeyBag;
#define KeyBag_PDU 6
#define SIZE_PFXNSCP_Module_PDU_6 sizeof(KeyBag)

typedef struct CertCRLBag {
    ASN1uint32_t count;
    struct CertCRL *value;
} CertCRLBag;
#define CertCRLBag_PDU 7
#define SIZE_PFXNSCP_Module_PDU_7 sizeof(CertCRLBag)

typedef struct CertCRL {
    ObjID bagId;
    ASN1open_t value;
} CertCRL;
#define CertCRL_PDU 8
#define SIZE_PFXNSCP_Module_PDU_8 sizeof(CertCRL)

typedef struct X509Bag {
    ContentInfo certOrCRL;
} X509Bag;
#define X509Bag_PDU 9
#define SIZE_PFXNSCP_Module_PDU_9 sizeof(X509Bag)

typedef struct SDSICertBag {
    ASN1ztcharstring_t value;
} SDSICertBag;
#define SDSICertBag_PDU 10
#define SIZE_PFXNSCP_Module_PDU_10 sizeof(SDSICertBag)

typedef struct SecretBag {
    ASN1uint32_t count;
    struct Secret *value;
} SecretBag;
#define SecretBag_PDU 11
#define SIZE_PFXNSCP_Module_PDU_11 sizeof(SecretBag)

typedef struct SecretAdditional {
    ObjID secretAdditionalType;
    ASN1open_t secretAdditionalContent;
} SecretAdditional;
#define SecretAdditional_PDU 12
#define SIZE_PFXNSCP_Module_PDU_12 sizeof(SecretAdditional)

typedef AlgorithmIdentifier PrivateKeyAlgorithmIdentifier;

typedef AlgorithmIdentifier EncryptionAlgorithmIdentifier;

typedef AlgorithmIdentifier ContentEncryptionAlgorithmIdentifier;

typedef struct DigestInfo {
    DigestAlgorithmIdentifier digestAlgorithm;
    Digest digest;
} DigestInfo;

typedef struct MacData {
    DigestInfo safeMAC;
    ASN1bitstring_t macSalt;
} MacData;

typedef struct AuthenticatedSafe {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define version_present 0x80
    Version version;
#   define transportMode_present 0x40
    TransportMode transportMode;
#   define privacySalt_present 0x20
    ASN1bitstring_t privacySalt;
#   define baggage_present 0x10
    Baggage baggage;
    ContentInfo safe;
} AuthenticatedSafe;
#define AuthenticatedSafe_PDU 13
#define SIZE_PFXNSCP_Module_PDU_13 sizeof(AuthenticatedSafe)

typedef DigestInfo Thumbprint;

typedef struct Secret {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1char16string_t secretName;
    ObjID secretType;
    ASN1open_t value;
#   define secretAdditional_present 0x80
    SecretAdditional secretAdditional;
} Secret;
#define Secret_PDU 14
#define SIZE_PFXNSCP_Module_PDU_14 sizeof(Secret)

typedef struct PVKSupportingData_assocCerts {
    ASN1uint32_t count;
    Thumbprint *value;
} PVKSupportingData_assocCerts;

typedef struct PrivateKeyInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Version version;
    PrivateKeyAlgorithmIdentifier privateKeyAlgorithm;
    ASN1octetstring_t privateKey;
#   define attributes_present 0x80
    Attributes attributes;
} PrivateKeyInfo;
#define PrivateKeyInfo_PDU 15
#define SIZE_PFXNSCP_Module_PDU_15 sizeof(PrivateKeyInfo)

typedef struct EncryptedContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
    ContentEncryptionAlgorithmIdentifier contentEncryptionAlg;
#   define encryptedContent_present 0x80
    EncryptedContent encryptedContent;
} EncryptedContentInfo;

typedef struct PFX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define macData_present 0x80
    MacData macData;
    ContentInfo authSafe;
} PFX;
#define PFX_PDU 16
#define SIZE_PFXNSCP_Module_PDU_16 sizeof(PFX)

typedef struct PVKSupportingData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PVKSupportingData_assocCerts assocCerts;
#   define regenerable_present 0x80
    ASN1bool_t regenerable;
    ASN1char16string_t nickname;
#   define pvkAdditional_present 0x40
    PvkAdditional pvkAdditional;
} PVKSupportingData;
#define PVKSupportingData_PDU 17
#define SIZE_PFXNSCP_Module_PDU_17 sizeof(PVKSupportingData)

typedef struct PrivateKey {
    PVKSupportingData pvkData;
    PrivateKeyInfo pkcs8data;
} PrivateKey;
#define PrivateKey_PDU 18
#define SIZE_PFXNSCP_Module_PDU_18 sizeof(PrivateKey)

typedef struct EncryptedData {
    Version version;
    EncryptedContentInfo encryptedContentInfo;
} EncryptedData;
#define EncryptedData_PDU 19
#define SIZE_PFXNSCP_Module_PDU_19 sizeof(EncryptedData)

typedef struct ESPVK {
    ObjID espvkObjID;
    PVKSupportingData espvkData;
    ASN1open_t espvkCipherText;
} ESPVK;
#define ESPVK_PDU 20
#define SIZE_PFXNSCP_Module_PDU_20 sizeof(ESPVK)

typedef struct EncryptedPrivateKeyInfo {
    EncryptionAlgorithmIdentifier encryptionAlgorithm;
    EncryptedData encryptedData;
} EncryptedPrivateKeyInfo;
#define EncryptedPrivateKeyInfo_PDU 21
#define SIZE_PFXNSCP_Module_PDU_21 sizeof(EncryptedPrivateKeyInfo)

extern ASN1bool_t PVKSupportingData_regenerable_default;
extern Version AuthenticatedSafe_version_default;
extern ASN1objectidentifier2_t rsa1;
extern ASN1objectidentifier2_t pkcs_12;
extern ASN1objectidentifier2_t pkcs_12ModeIds;
extern ASN1objectidentifier2_t off_lineTransportMode;

extern ASN1module_t PFXNSCP_Module;
extern void ASN1CALL PFXNSCP_Module_Startup(void);
extern void ASN1CALL PFXNSCP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PFXNSCP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxhelp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pfxhelp.cpp
//
//  Contents:   Support functions for PFX
//
//  Functions:  CertExportSafeContents
//              CertImportSafeContents
//
//  History:    23-Feb-96   philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>
#include "pfxhelp.h"
#include "pfxpkcs.h"
#include "pfxcmn.h"
#include "pfxcrypt.h"

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

// remove when this is defined in wincrypt.h
#ifndef PP_KEYSET_TYPE
#define PP_KEYSET_TYPE          27
#endif

#define DISALLOWED_FLAG_MASK    ~(CRYPT_EXPORTABLE | CRYPT_DELETEKEYSET)

//+-------------------------------------------------------------------------
//  PFX helpe allocation and free functions
//--------------------------------------------------------------------------
static void *PFXHelpAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void *PFXHelpRealloc(
    IN void *pvOrg,
    IN size_t cbBytes
    )
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc(pvOrg, cbBytes) : malloc(cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

static void PFXHelpFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}


// this function will search an a SAFE_CONTENTS to see if any of the SAFE_BAGS have the
// same private key as the one passed to the function.  if it finds a matching private
// key it will return a pointer the encoded keyID and return TRUE, it will return FALSE
// otherwise.  NOTE that if it returns a pointer to the encoded blob that the caller
// is responsible for copying the data and must not free what is returned
static BOOL WINAPI PrivateKeyAlreadyExists(
    BYTE                *pPrivateKey,
    DWORD               cbPrivateKey,
    SAFE_CONTENTS       *pSafeContents,
    PCRYPT_DER_BLOB     pEncodedKeyID
    )
{
    BOOL    bKeyFound = FALSE;
    DWORD   i = 0;

    if (pSafeContents == NULL) {
        goto CommonReturn;
    }

    while ((!bKeyFound) && (i < pSafeContents->cSafeBags))
    {
        if ( ((strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_KEY_BAG) == 0) ||
              (strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_SHROUDEDKEY_BAG) == 0)) &&

             (cbPrivateKey == pSafeContents->pSafeBags[i].BagContents.cbData) &&
             (memcmp(pPrivateKey, pSafeContents->pSafeBags[i].BagContents.pbData, cbPrivateKey) == 0))
        {
            pEncodedKeyID->pbData = pSafeContents->pSafeBags[i].Attributes.rgAttr[0].rgValue[0].pbData;
            pEncodedKeyID->cbData = pSafeContents->pSafeBags[i].Attributes.rgAttr[0].rgValue[0].cbData;
            bKeyFound = TRUE;
        }
        else {
            i++;
        }
    }

CommonReturn:
    return bKeyFound;
}


// this function will walk through a SAFE_CONTENTS structure and free all the space
// associated with it
static BOOL WINAPI FreeSafeContents(
    SAFE_CONTENTS *pSafeContents
    )
{
    DWORD i,j,k;

    // loop for each SAFE_BAG
    for (i=0; i<pSafeContents->cSafeBags; i++) {

        if (pSafeContents->pSafeBags[i].BagContents.pbData)
            PFXHelpFree(pSafeContents->pSafeBags[i].BagContents.pbData);

        // loop for each attribute
        for (j=0; j<pSafeContents->pSafeBags[i].Attributes.cAttr; j++) {

            // l0op for each value
            for (k=0; k<pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue; k++) {

                if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData)
                    PFXHelpFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData);
            }

            // free the value struct array
            if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue)
                PFXHelpFree(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue);
        }

        // free the attribute struct array
        if (pSafeContents->pSafeBags[i].Attributes.rgAttr)
            PFXHelpFree(pSafeContents->pSafeBags[i].Attributes.rgAttr);
    }

    // finally, free the safe bag array
    if (pSafeContents->pSafeBags != NULL)
    {
        PFXHelpFree(pSafeContents->pSafeBags);
    }

    return TRUE;
}


#define SZ_NO_PROVIDER_NAME_KEY     L"Software\\Microsoft\\Windows\\CurrentVersion\\PFX"
#define SZ_NO_PROVIDER_NAME_VALUE   L"NoProviderName"

BOOL
NoProviderNameRegValueSet()
{
    HKEY    hKey = NULL;
    BOOL    fRet = FALSE;
    DWORD   dwData;
    DWORD   dwDataSize = sizeof(dwData);

    if (ERROR_SUCCESS != RegOpenKeyExU(
                                HKEY_CURRENT_USER,
                                SZ_NO_PROVIDER_NAME_KEY,
                                0,
                                KEY_EXECUTE,
                                &hKey))
    {
        goto Return;;
    }

    if (ERROR_SUCCESS == RegQueryValueExU(
                                hKey,
                                SZ_NO_PROVIDER_NAME_VALUE,
                                NULL,
                                NULL,
                                (LPBYTE) &dwData,
                                &dwDataSize))
    {
        fRet = (BOOL) dwData;
    }

Return:
    if (hKey != NULL)
        RegCloseKey(hKey);

    return fRet;
}


//+-------------------------------------------------------------------------
// hCertStore - handle to the cert store that contains the certs whose
//              corresponding private keys are to be exported
// pSafeContents - pointer to a buffer to receive the SAFE_CONTENTS structure
//                 and supporting data
// pcbSafeContents - (in) specifies the length, in bytes, of the pSafeContents
//                    buffer.  (out) gets filled in with the number of bytes
//                    used by the operation.  If this is set to 0, the
//                    required length of pSafeContents is filled in, and
//                    pSafeContents is ignored.
// dwFlags - the current available flags are:
//              EXPORT_PRIVATE_KEYS
//              if this flag is set then the private keys are exported as well
//              as the certificates
//              REPORT_NO_PRIVATE_KEY
//              if this flag is set and a certificate is encountered that has no
//              no associated private key, the function will return immediately
//              with ppCertContext filled in with a pointer to the cert context
//              in question.  the caller is responsible for freeing the cert
//              context which is passed back.
//              REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//              if this flag is set and a certificate is encountered that has a
//              non-exportable private key, the function will return immediately
//              with ppCertContext filled in with a pointer to the cert context
//              in question.  the caller is responsible for freeing the cert
//              context which is passed back.
// ppCertContext - a pointer to a pointer to a cert context.  this is used
//                 if REPORT_NO_PRIVATE_KEY or REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY
//                 flags are set.  the caller is responsible for freeing the
//                 cert context.
// pvAuxInfo - reserved for future use, must be set to NULL
//+-------------------------------------------------------------------------
BOOL WINAPI CertExportSafeContents(
    HCERTSTORE                      hCertStore,         // in
    SAFE_CONTENTS                   *pSafeContents,     // out
    DWORD                           *pcbSafeContents,   // in, out
    EXPORT_SAFE_CALLBACK_STRUCT     *ExportSafeCallbackStruct, // in
    DWORD                           dwFlags,            // in
    PCCERT_CONTEXT                  *ppCertContext,     // out
    void                            *pvAuxInfo          // in
)
{
    BOOL                fResult = TRUE;
    PCCERT_CONTEXT      pCertContext = NULL;
    DWORD               dwKeySpec;
    DWORD               dwBytesRequired = sizeof(SAFE_CONTENTS);
    SAFE_CONTENTS       localSafeContents;
    BYTE                *pCurrentBufferLocation = NULL;
    DWORD               dwIDs = 1;
    DWORD               i,j,k;

    // all these variables are used in the while loop that enumerates through
    // the cert contexts
    CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo = NULL;
    DWORD               cbCryptKeyProvInfo = 0;
    HCRYPTPROV          hCryptProv = NULL;
    BYTE                *pPrivateKey = NULL;
    DWORD               cbPrivateKey = 0;
    void                *pTempMemBlock = NULL;
    SAFE_BAG            *pCurrentSafeBag = NULL;
    DWORD               dwKeyID = 0;
    CRYPT_ATTR_BLOB     keyID;
    CRYPT_DER_BLOB      EncodedKeyID;
    CERT_NAME_VALUE     wideFriendlyName;
    BYTE                *pFriendlyName = NULL;
    DWORD               cbFriendlyName = 0;
    DWORD               dwFriendlyNameAttributeIndex = 0;
    BOOL                fAddProviderName;
    LPWSTR              pwszProviderName = NULL;
    DWORD               cbProviderName = 0;

    localSafeContents.cSafeBags = 0;
    localSafeContents.pSafeBags = NULL;

    // validate input parameters
    if ((pcbSafeContents == NULL)   ||
        (pvAuxInfo != NULL          ||
        ((*pcbSafeContents != 0) && (pSafeContents == NULL)))) {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        goto ErrorReturn;
    }

    if ((dwFlags & REPORT_NO_PRIVATE_KEY) || (dwFlags & REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY)) {
        if (ppCertContext == NULL) {
            SetLastError((DWORD)ERROR_INVALID_PARAMETER);
            goto ErrorReturn;
        }
        *ppCertContext = NULL;
    }

    fAddProviderName = !NoProviderNameRegValueSet();

    // loop for each certificate context in the store and export the cert and
    // corresponding private key if one exists
    while (NULL != (pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext))) {

        // initialize all loop variables
        if (pCryptKeyProvInfo)
            PFXHelpFree(pCryptKeyProvInfo);
        pCryptKeyProvInfo = NULL;
        cbCryptKeyProvInfo = 0;

        if (hCryptProv)
            CryptReleaseContext(hCryptProv, 0);
        hCryptProv = NULL;

        if (pPrivateKey)
            PFXHelpFree(pPrivateKey);
        pPrivateKey = NULL;
        cbPrivateKey = 0;

        pTempMemBlock = NULL;
        pCurrentSafeBag = NULL;

        // keyID is the CRYPT_ATTR_BLOB that is always used to encode the key id
        // for certs and private keys.  dwKeyID is the only thing that will need
        // to be set properly before calling CryptEncodeObject with keyID.
        keyID.pbData = (BYTE *) &dwKeyID;
        keyID.cbData = sizeof(DWORD);

        // initialize EncodedKeyID so when exporting the cert it can check to see if this
        // has been set
        EncodedKeyID.pbData = NULL;
        EncodedKeyID.cbData = 0;

        // if the EXPORT_PRIVATE_KEYS flag is set then
        // try to export the private key which corresponds to this certificate before
        // exporting the certificate so we know how to set the key ID on the certificate

        if (EXPORT_PRIVATE_KEYS  & dwFlags)
        // get the provider info so we can export the private key
        if (CertGetCertificateContextProperty(
                pCertContext,
                CERT_KEY_PROV_INFO_PROP_ID,
                NULL,
                &cbCryptKeyProvInfo
                )) {

            if (NULL == (pCryptKeyProvInfo = (CRYPT_KEY_PROV_INFO *)
                            PFXHelpAlloc(cbCryptKeyProvInfo))) {
                goto ErrorReturn;
            }

            if (CertGetCertificateContextProperty(
                    pCertContext,
                    CERT_KEY_PROV_INFO_PROP_ID,
                    pCryptKeyProvInfo,
                    &cbCryptKeyProvInfo
                    )) {

                // acquire the HCRYPTPROV so we can export the private key in that puppy
                if (!CryptAcquireContextU(
                        &hCryptProv,
                        pCryptKeyProvInfo->pwszContainerName,
                        pCryptKeyProvInfo->pwszProvName,
                        pCryptKeyProvInfo->dwProvType,
                        pCryptKeyProvInfo->dwFlags & (DISALLOWED_FLAG_MASK)) ) {
                    goto ErrorReturn;
                }

                CRYPT_PKCS8_EXPORT_PARAMS sExportParams = { hCryptProv,
                                                            pCryptKeyProvInfo->dwKeySpec,
                                                            pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
                                                            //szOID_RSA_RSA,  // FIX -what do I do here??, possibly look at the algorithm in the cert
                                                            (ExportSafeCallbackStruct) ? ExportSafeCallbackStruct->pEncryptPrivateKeyFunc : NULL,
                                                            (ExportSafeCallbackStruct) ? ExportSafeCallbackStruct->pVoidEncryptFunc : NULL};

                // do the actual export of the private key
                if (CryptExportPKCS8Ex(
                        &sExportParams,

                        PFX_MODE,
                        NULL,
                        NULL,
                        &cbPrivateKey
                        )) {

                    if (NULL == (pPrivateKey = (BYTE *) PFXHelpAlloc(cbPrivateKey))) {
                        goto ErrorReturn;
                    }

                    if (CryptExportPKCS8Ex(
                            &sExportParams,

                            (dwFlags & GIVE_ME_DATA) ? PFX_MODE | GIVE_ME_DATA : PFX_MODE,
                            NULL,
                            pPrivateKey,
                            &cbPrivateKey
                            )) {

                        // search the array of key bags to see if the private key is already there
                        // and take action accordingly.  if the private key already exists, the
                        // EncodedKeyID contains the encoded keyID attribute for exporting the
                        // certificate so we don't need to do anything
                        if (!PrivateKeyAlreadyExists(
                                pPrivateKey,
                                cbPrivateKey,
                                &localSafeContents,
                                &EncodedKeyID
                                )) {

                            // extend the length of the SAFE_BAGs array by one
                            if (NULL == (pTempMemBlock = PFXHelpRealloc(
                                                            localSafeContents.pSafeBags,
                                                            sizeof(SAFE_BAG) *
                                                                ++localSafeContents.cSafeBags))) {
                                goto ErrorReturn;
                            }
                            localSafeContents.pSafeBags = (SAFE_BAG *) pTempMemBlock;
                            pCurrentSafeBag =
                                &localSafeContents.pSafeBags[localSafeContents.cSafeBags - 1];
                            ZeroMemory(pCurrentSafeBag, sizeof(SAFE_BAG));
                            dwBytesRequired += sizeof(SAFE_BAG);

                            // set up the OID information for the bag type
                            pCurrentSafeBag->pszBagTypeOID = (ExportSafeCallbackStruct->pEncryptPrivateKeyFunc) ? szOID_PKCS_12_SHROUDEDKEY_BAG : szOID_PKCS_12_KEY_BAG;
                            dwBytesRequired += INFO_LEN_ALIGN(strlen(pCurrentSafeBag->pszBagTypeOID) + 1);

                            // copy the pointer to the private key into the new safe bag
                            // and NULL out the pPrivateKey pointer so the memory does not get freed
                            pCurrentSafeBag->BagContents.pbData = pPrivateKey;
                            pCurrentSafeBag->BagContents.cbData = cbPrivateKey;
                            dwBytesRequired += INFO_LEN_ALIGN(cbPrivateKey);
                            pPrivateKey = NULL;
                            cbPrivateKey = 0;

                            // set up the attributes array for the SAFE_BAG
                            // FIX - for right now just do the
                            // szOID_PKCS_12_LOCAL_KEY_ID,
                            // szOID_PKCS_12_FRIENDLY_NAME_ATTR,
                            // and szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR. (if the NoProviderName reg value not set)
                            // optional szOID_LOCAL_MACHINE_KEYSET if needed
                            pCurrentSafeBag->Attributes.cAttr = fAddProviderName ? 3 : 2;

                            if (pCryptKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                                pCurrentSafeBag->Attributes.cAttr++;

                            if (NULL == (pCurrentSafeBag->Attributes.rgAttr = (CRYPT_ATTRIBUTE *)
                                             PFXHelpAlloc(sizeof(CRYPT_ATTRIBUTE) * pCurrentSafeBag->Attributes.cAttr))) {
                                goto ErrorReturn;
                            }
                            ZeroMemory(pCurrentSafeBag->Attributes.rgAttr, sizeof(CRYPT_ATTRIBUTE) * pCurrentSafeBag->Attributes.cAttr);
                            dwBytesRequired += sizeof(CRYPT_ATTRIBUTE) * pCurrentSafeBag->Attributes.cAttr;


                            // allocate space and do setup based on whether the szOID_LOCAL_MACHINE_KEYSET
                            // attribute is needed
                            if (pCryptKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                            {
                                // since there is nothing to do for the szOID_LOCAL_MACHINE_KEYSET
                                // besides just setting the OID do it here and put it in the last
                                // attribute
                                pCurrentSafeBag->Attributes.rgAttr[pCurrentSafeBag->Attributes.cAttr-1].pszObjId =
                                    szOID_LOCAL_MACHINE_KEYSET;
                                dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_LOCAL_MACHINE_KEYSET) + 1);
                                pCurrentSafeBag->Attributes.rgAttr[pCurrentSafeBag->Attributes.cAttr-1].rgValue = NULL;
                                pCurrentSafeBag->Attributes.rgAttr[pCurrentSafeBag->Attributes.cAttr-1].cValue = 0;
                            }

                            // set the OID in the szOID_PKCS_12_LOCAL_KEY_ID attribute
                            pCurrentSafeBag->Attributes.rgAttr[0].pszObjId =
                                szOID_PKCS_12_LOCAL_KEY_ID;
                            dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1);

                            // allocate space for the single value inside the attribute
                            if (NULL == (pCurrentSafeBag->Attributes.rgAttr[0].rgValue =
                                            (CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
                                goto ErrorReturn;
                            }
                            ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[0].rgValue, sizeof(CRYPT_ATTR_BLOB));
                            dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
                            pCurrentSafeBag->Attributes.rgAttr[0].cValue = 1;

                            // set the key ID to the appropriate key ID
                            dwKeyID = dwIDs++;

                            // encode the keyID
                            pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData = NULL;
                            pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData = 0;
                            if (!CryptEncodeObject(
                                    X509_ASN_ENCODING,
                                    X509_OCTET_STRING,
                                    &keyID,
                                    NULL,
                                    &pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData)) {
                                goto ErrorReturn;
                            }

                            if (NULL == (pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData =
                                            (BYTE *) PFXHelpAlloc(pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData))) {
                                goto ErrorReturn;
                            }
                            dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData);

                            if (!CryptEncodeObject(
                                    X509_ASN_ENCODING,
                                    X509_OCTET_STRING,
                                    &keyID,
                                    pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData,
                                    &pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData)) {
                                goto ErrorReturn;
                            }

                            // set the fields in EncodedKeyID so that when the cert is exported
                            // it can just copy the already encoded keyID to it's attributes
                            EncodedKeyID.pbData = pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData;
                            EncodedKeyID.cbData = pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData;

                            // Friendly Name

                            // set the OID in the szOID_PKCS_12_FRIENDLY_NAME_ATTR attribute
                            pCurrentSafeBag->Attributes.rgAttr[1].pszObjId =
                                szOID_PKCS_12_FRIENDLY_NAME_ATTR;
                            dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_FRIENDLY_NAME_ATTR) + 1);

                            // allocate space for the single value inside the attribute
                            if (NULL == (pCurrentSafeBag->Attributes.rgAttr[1].rgValue =
                                            (CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
                                goto ErrorReturn;
                            }
                            ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[1].rgValue, sizeof(CRYPT_ATTR_BLOB));
                            dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
                            pCurrentSafeBag->Attributes.rgAttr[1].cValue = 1;

                            // encode the provider name so it can be used on import
                            wideFriendlyName.dwValueType = CERT_RDN_BMP_STRING;
                            wideFriendlyName.Value.pbData = (BYTE *) pCryptKeyProvInfo->pwszContainerName;
                            wideFriendlyName.Value.cbData = 0;

                            if (!CryptEncodeObject(
                                    X509_ASN_ENCODING,
                                    X509_UNICODE_ANY_STRING,
                                    (void *)&wideFriendlyName,
                                    NULL,
                                    &pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].cbData)) {
                                goto ErrorReturn;
                            }

                            if (NULL == (pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].pbData =
                                            (BYTE *) PFXHelpAlloc(pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].cbData))) {
                                goto ErrorReturn;
                            }
                            dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].cbData);

                            if (!CryptEncodeObject(
                                    X509_ASN_ENCODING,
                                    X509_UNICODE_ANY_STRING,
                                    (void *)&wideFriendlyName,
                                    pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].pbData,
                                    &pCurrentSafeBag->Attributes.rgAttr[1].rgValue[0].cbData)) {
                                goto ErrorReturn;
                            }

                            // Provider Name
                            if (fAddProviderName)
                            {
                                // set the OID in the szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR attribute
                                pCurrentSafeBag->Attributes.rgAttr[2].pszObjId =
                                    szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR;
                                dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR) + 1);

                                // allocate space for the single value inside the attribute
                                if (NULL == (pCurrentSafeBag->Attributes.rgAttr[2].rgValue =
                                                (CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
                                    goto ErrorReturn;
                                }
                                ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[2].rgValue, sizeof(CRYPT_ATTR_BLOB));
                                dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
                                pCurrentSafeBag->Attributes.rgAttr[2].cValue = 1;

                                // encode the provider name so it can be used on import
                                //
                                // if the provider name is NULL or the empty string, then use
                                // the default provider name for the provider type
                                //
                                wideFriendlyName.dwValueType = CERT_RDN_BMP_STRING;
                                wideFriendlyName.Value.cbData = 0;
                                if ((pCryptKeyProvInfo->pwszProvName == NULL) ||
                                    (wcscmp(pCryptKeyProvInfo->pwszProvName, L"") == 0))
                                {
                                    if (!CryptGetDefaultProviderW(
                                            pCryptKeyProvInfo->dwProvType,
                                            NULL,
                                            (pCryptKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET) ?
                                                CRYPT_MACHINE_DEFAULT : CRYPT_USER_DEFAULT,
                                            NULL,
                                            &cbProviderName))
                                    {
                                        goto ErrorReturn;
                                    }

                                    if (NULL == (pwszProviderName = (LPWSTR) PFXHelpAlloc(cbProviderName)))
                                    {
                                        goto ErrorReturn;
                                    }

                                    if (!CryptGetDefaultProviderW(
                                            pCryptKeyProvInfo->dwProvType,
                                            NULL,
                                            (pCryptKeyProvInfo->dwFlags & CRYPT_MACHINE_KEYSET) ?
                                                CRYPT_MACHINE_DEFAULT : CRYPT_USER_DEFAULT,
                                            pwszProviderName,
                                            &cbProviderName))
                                    {
                                        goto ErrorReturn;
                                    }

                                    wideFriendlyName.Value.pbData = (BYTE *) pwszProviderName;
                                }
                                else
                                {
                                    wideFriendlyName.Value.pbData = (BYTE *) pCryptKeyProvInfo->pwszProvName;
                                }

                                if (!CryptEncodeObject(
                                        X509_ASN_ENCODING,
                                        X509_UNICODE_ANY_STRING,
                                        (void *)&wideFriendlyName,
                                        NULL,
                                        &pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].cbData)) {
                                    goto ErrorReturn;
                                }

                                if (NULL == (pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].pbData =
                                                (BYTE *) PFXHelpAlloc(pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].cbData))) {
                                    goto ErrorReturn;
                                }
                                dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].cbData);

                                if (!CryptEncodeObject(
                                        X509_ASN_ENCODING,
                                        X509_UNICODE_ANY_STRING,
                                        (void *)&wideFriendlyName,
                                        pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].pbData,
                                        &pCurrentSafeBag->Attributes.rgAttr[2].rgValue[0].cbData)) {
                                    goto ErrorReturn;
                                }
                            }
                        }

                    } // if (CryptExportPKCS8Ex())
                    else {

                        // check to see if it is a non-exportable key error or no key error
                        if (GetLastError() == NTE_BAD_KEY ||
                            GetLastError() == NTE_BAD_KEY_STATE) {

                            // the user has specified whether this is a fatal error or not
                            if (dwFlags & REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY) {
                                *ppCertContext = pCertContext;
                                pCertContext = NULL;
                                goto ErrorReturn;
                            }
                        }
                        else if (GetLastError() == NTE_NO_KEY) {
                            // the user has specified whether this is a fatal error or not
                            if (dwFlags & REPORT_NO_PRIVATE_KEY) {
                                *ppCertContext = pCertContext;
                                pCertContext = NULL;
                                goto ErrorReturn;
                            }
                        }
                        else {
                            // it isn't a non-exportable key error or no key error, so it is bad... bad...
                            goto ErrorReturn;
                        }
                    }

                } // if (CryptExportPKCS8Ex())
                else {

                    // check to see if it is a non-exportable key error or no key error
                    if (GetLastError() == NTE_BAD_KEY ||
                        GetLastError() == NTE_BAD_KEY_STATE) {

                        // the user has specified whether this is a fatal error or not
                        if (dwFlags & REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY) {
                            *ppCertContext = pCertContext;
                            pCertContext = NULL;
                            goto ErrorReturn;
                        }
                    }
                    else if (GetLastError() == NTE_NO_KEY) {
                            // the user has specified whether this is a fatal error or not
                            if (dwFlags & REPORT_NO_PRIVATE_KEY) {
                                *ppCertContext = pCertContext;
                                pCertContext = NULL;
                                goto ErrorReturn;
                            }
                        }
                    else {
                        // it was not a non-exportable error,so go directly to ErrorReturn
                        goto ErrorReturn;
                    }
                }

            } // if (CertGetCertificateContextProperty())
            else {

                // if CertGetCertificateContextProperty failed then there is no corresponding
                // private key, the user has indicated via dwFlags whether this is fatal or not,
                // if it is fatal then return an error, otherwise just loop and get the next cert
                if (dwFlags & REPORT_NO_PRIVATE_KEY) {
                    *ppCertContext = pCertContext;
                    pCertContext = NULL;
                    goto ErrorReturn;
                }
            }

        } // if (CertGetCertificateContextProperty())
        else {

            // if CertGetCertificateContextProperty failed then there is no corresponding
            // private key, the user has indicated via dwFlags whether this is fatal or not,
            // if it is fatal then return an error, otherwise just continue and export the cert
            if (dwFlags & REPORT_NO_PRIVATE_KEY) {
                *ppCertContext = pCertContext;
                pCertContext = NULL;
                goto ErrorReturn;
            }
        }


        // now export the current cert!!

        // extend the length of the SAFE_BAGs array by one
        if (NULL == (pTempMemBlock = PFXHelpRealloc(
                                        localSafeContents.pSafeBags,
                                        sizeof(SAFE_BAG) * ++localSafeContents.cSafeBags))) {
            goto ErrorReturn;
        }
        localSafeContents.pSafeBags = (SAFE_BAG *) pTempMemBlock;
        pCurrentSafeBag = &localSafeContents.pSafeBags[localSafeContents.cSafeBags - 1];
        ZeroMemory(pCurrentSafeBag, sizeof(SAFE_BAG));
        dwBytesRequired += sizeof(SAFE_BAG);

        // set up the OID information for the bag type
        pCurrentSafeBag->pszBagTypeOID = szOID_PKCS_12_CERT_BAG;
        dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_CERT_BAG) + 1);

        // take the encoded cert and turn it into an encoded CertBag and place in the
        // BagContents
        pCurrentSafeBag->BagContents.cbData = 0;
        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded,
                pCertContext->cbCertEncoded,
                NULL,
                &(pCurrentSafeBag->BagContents.cbData))) {
            goto ErrorReturn;
        }

        if (NULL == (pCurrentSafeBag->BagContents.pbData =
                        (BYTE *) PFXHelpAlloc(pCurrentSafeBag->BagContents.cbData))) {
            goto ErrorReturn;
        }

        if (!MakeEncodedCertBag(
                pCertContext->pbCertEncoded,
                pCertContext->cbCertEncoded,
                pCurrentSafeBag->BagContents.pbData,
                &(pCurrentSafeBag->BagContents.cbData))) {
            goto ErrorReturn;
        }

        dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->BagContents.cbData);

        // check to see how many attributes there will be, the possibilities right now
        // are FREINDLY_NAME and LOCAL_KEY_ID

        // try to get the friendly name property from the cert context
        if (!CertGetCertificateContextProperty(
                pCertContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                NULL,
                &cbFriendlyName)) {

            // just set this to insure that it is 0 if we don't have a friendly name
            cbFriendlyName = 0;
        }

        // allocate space for the attributes array in the safe bag accordingly
        // if EncodedKeyID.pbData != NULL means there is a corresponding private
        // key, so the LOCAL_KEY_ID attribute needs to be set
        if ((cbFriendlyName != 0) && (EncodedKeyID.pbData != NULL)) {

            if (NULL == (pCurrentSafeBag->Attributes.rgAttr =
                            (CRYPT_ATTRIBUTE *) PFXHelpAlloc(sizeof(CRYPT_ATTRIBUTE) * 2))) {
                goto ErrorReturn;
            }
            ZeroMemory(pCurrentSafeBag->Attributes.rgAttr, sizeof(CRYPT_ATTRIBUTE) * 2);
            dwBytesRequired += sizeof(CRYPT_ATTRIBUTE) * 2;
            pCurrentSafeBag->Attributes.cAttr = 2;
        }
        else if ((cbFriendlyName != 0) || (EncodedKeyID.pbData != NULL)) {

            if (NULL == (pCurrentSafeBag->Attributes.rgAttr =
                            (CRYPT_ATTRIBUTE *) PFXHelpAlloc(sizeof(CRYPT_ATTRIBUTE)))) {
                goto ErrorReturn;
            }
            ZeroMemory(pCurrentSafeBag->Attributes.rgAttr, sizeof(CRYPT_ATTRIBUTE));
            dwBytesRequired += sizeof(CRYPT_ATTRIBUTE);
            pCurrentSafeBag->Attributes.cAttr = 1;
        }
        else {
            pCurrentSafeBag->Attributes.rgAttr = NULL;
            pCurrentSafeBag->Attributes.cAttr = 0;
        }

        // check to see if the cert has a corresponding private key, if so then set
        // up the first attribute to point to it.... if there is a private key then
        // LOCAL_KEY_ID will always be the 0th element in the attribute array
        if (EncodedKeyID.pbData != NULL) {

            // set the OID in the single attribute
            pCurrentSafeBag->Attributes.rgAttr[0].pszObjId = szOID_PKCS_12_LOCAL_KEY_ID;
            dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_LOCAL_KEY_ID) + 1);

            // allocate space for the single value inside the single attribute
            if (NULL == (pCurrentSafeBag->Attributes.rgAttr[0].rgValue =
                            (CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
                goto ErrorReturn;
            }
            ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[0].rgValue, sizeof(CRYPT_ATTR_BLOB));
            dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
            pCurrentSafeBag->Attributes.rgAttr[0].cValue = 1;

            // copy the encoded keyID that was set up during export of private key
            if (NULL == (pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData =
                            (BYTE *) PFXHelpAlloc(EncodedKeyID.cbData))) {
                goto ErrorReturn;
            }
            pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData = EncodedKeyID.cbData;
            dwBytesRequired += INFO_LEN_ALIGN(EncodedKeyID.cbData);
            memcpy(
                pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData,
                EncodedKeyID.pbData,
                EncodedKeyID.cbData);

        } // if (EncodedKeyID.pbData != NULL)

        // check to see if this cert has a friendly name property, if so,
        // get it and put it in an attribute
        if (cbFriendlyName != 0) {

            if ((pFriendlyName = (BYTE *) PFXHelpAlloc(cbFriendlyName)) != NULL) {

                if (CertGetCertificateContextProperty(
                        pCertContext,
                        CERT_FRIENDLY_NAME_PROP_ID,
                        pFriendlyName,
                        &cbFriendlyName)) {

                    // set the index of the attribute which will hold the FRIENDLY_NAME,
                    // if there is a LOCAL_KEY_ID attribute then the index will be 1,
                    // if there isn't then the index will be 0
                    if (EncodedKeyID.pbData != NULL) {
                        dwFriendlyNameAttributeIndex = 1;
                    }
                    else {
                        dwFriendlyNameAttributeIndex = 0;
                    }

                    // set the OID in the szOID_PKCS_12_FRIENDLY_NAME_ATTR attribute
                    pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].pszObjId =
                        szOID_PKCS_12_FRIENDLY_NAME_ATTR;
                    dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_FRIENDLY_NAME_ATTR) + 1);

                    // allocate space for the single value inside the attribute
                    if (NULL == (pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue =
                                    (CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
                        goto ErrorReturn;
                    }
                    ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue, sizeof(CRYPT_ATTR_BLOB));
                    dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
                    pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].cValue = 1;

                    // encode the friendly name, reuse the containerName variable because its there
                    wideFriendlyName.dwValueType = CERT_RDN_BMP_STRING;
                    wideFriendlyName.Value.pbData = pFriendlyName;
                    wideFriendlyName.Value.cbData = cbFriendlyName;

                    if (!CryptEncodeObject(
                            X509_ASN_ENCODING,
                            X509_UNICODE_ANY_STRING,
                            (void *)&wideFriendlyName,
                            NULL,
                            &pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].cbData)) {
                        goto ErrorReturn;
                    }

                    if (NULL == (pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].pbData =
                                    (BYTE *) PFXHelpAlloc(pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].cbData))) {
                        goto ErrorReturn;
                    }
                    dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].cbData);

                    if (!CryptEncodeObject(
                            X509_ASN_ENCODING,
                            X509_UNICODE_ANY_STRING,
                            (void *)&wideFriendlyName,
                            pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].pbData,
                            &pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].cbData)) {
                        goto ErrorReturn;
                    }

                } // if (CertGetCertificateContextProperty(CERT_FRIENDLY_NAME_PROP_ID))

            } // if (PFXHelpAlloc())

        } // if (CertGetCertificateContextProperty(CERT_FRIENDLY_NAME_PROP_ID))


    } // while (NULL != (pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext)))

    // check to see if the caller passed in a buffer with encough enough space
    if (0 == *pcbSafeContents) {
        *pcbSafeContents = dwBytesRequired;
        goto CommonReturn;
    }
    else if (*pcbSafeContents < dwBytesRequired) {
        *pcbSafeContents = dwBytesRequired;
        SetLastError((DWORD) ERROR_MORE_DATA);
        goto ErrorReturn;
    }

    // copy the contents into the callers buffer

    // initialize the SAFE_CONTENTS structure that is at the head of the buffer
    ZeroMemory(pSafeContents, dwBytesRequired);
    pCurrentBufferLocation = ((BYTE *) pSafeContents) + sizeof(SAFE_CONTENTS);

    // initialize the callers SAFE_CONTENTS
    pSafeContents->cSafeBags = localSafeContents.cSafeBags;

    if (0 == localSafeContents.cSafeBags) {
        pSafeContents->pSafeBags = NULL;
    }
    else {
        pSafeContents->pSafeBags = (SAFE_BAG *) pCurrentBufferLocation;
    }
    pCurrentBufferLocation += localSafeContents.cSafeBags * sizeof(SAFE_BAG);

    // copy each safe bag in the array
    for (i=0; i<localSafeContents.cSafeBags; i++) {

        // copy the bag type
        pSafeContents->pSafeBags[i].pszBagTypeOID = (LPSTR) pCurrentBufferLocation;
        strcpy(pSafeContents->pSafeBags[i].pszBagTypeOID, localSafeContents.pSafeBags[i].pszBagTypeOID);
        pCurrentBufferLocation += INFO_LEN_ALIGN(strlen(pSafeContents->pSafeBags[i].pszBagTypeOID) + 1);

        // copy the bag contents
        pSafeContents->pSafeBags[i].BagContents.cbData = localSafeContents.pSafeBags[i].BagContents.cbData;
        pSafeContents->pSafeBags[i].BagContents.pbData = pCurrentBufferLocation;
        memcpy(
            pSafeContents->pSafeBags[i].BagContents.pbData,
            localSafeContents.pSafeBags[i].BagContents.pbData,
            pSafeContents->pSafeBags[i].BagContents.cbData);
        pCurrentBufferLocation += INFO_LEN_ALIGN(pSafeContents->pSafeBags[i].BagContents.cbData);

        // copy the attributes
        if (localSafeContents.pSafeBags[i].Attributes.cAttr > 0)
        {
            pSafeContents->pSafeBags[i].Attributes.cAttr = localSafeContents.pSafeBags[i].Attributes.cAttr;
            pSafeContents->pSafeBags[i].Attributes.rgAttr = (PCRYPT_ATTRIBUTE) pCurrentBufferLocation;
            pCurrentBufferLocation += pSafeContents->pSafeBags[i].Attributes.cAttr * sizeof(CRYPT_ATTRIBUTE);

            for (j=0; j<pSafeContents->pSafeBags[i].Attributes.cAttr; j++) {

                // copy the OID of the attribute
                pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId =
                    (LPSTR) pCurrentBufferLocation;
                strcpy(
                    pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId,
                    localSafeContents.pSafeBags[i].Attributes.rgAttr[j].pszObjId);
                pCurrentBufferLocation +=
                    INFO_LEN_ALIGN(strlen(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId) + 1);

                // copy value count
                pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue =
                    localSafeContents.pSafeBags[i].Attributes.rgAttr[j].cValue;

                // copy the values
                if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue > 0) {

                    // setup the array of values
                    pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue =
                        (PCRYPT_ATTR_BLOB) pCurrentBufferLocation;
                    pCurrentBufferLocation +=
                        pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue * sizeof(CRYPT_ATTR_BLOB);

                    // loop once for each value in the array
                    for (k=0; k<pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue; k++) {

                        pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].cbData =
                            localSafeContents.pSafeBags[i].Attributes.rgAttr[j].rgValue[k].cbData;

                        pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData =
                            pCurrentBufferLocation;

                        memcpy(
                            pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData,
                            localSafeContents.pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData,
                            pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].cbData);

                        pCurrentBufferLocation +=
                            INFO_LEN_ALIGN(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].cbData);
                    }
                }
                else {
                    pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue = NULL;
                }

            }
        }
        else {
            pSafeContents->pSafeBags[i].Attributes.cAttr = 0;
            pSafeContents->pSafeBags[i].Attributes.rgAttr = NULL;
        }
    }

    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    FreeSafeContents(&localSafeContents);
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);
    if (pCryptKeyProvInfo)
        PFXHelpFree(pCryptKeyProvInfo);
    if (pPrivateKey)
        PFXHelpFree(pPrivateKey);
    if (pFriendlyName)
        PFXHelpFree(pFriendlyName);
    if (pwszProviderName)
        PFXHelpFree(pwszProviderName);
    if (hCryptProv)
    {
        HRESULT hr = GetLastError();
        CryptReleaseContext(hCryptProv, 0);
        SetLastError(hr);
    }
    return fResult;
}


static DWORD ResolveKeySpec(
    CRYPT_PRIVATE_KEY_INFO  *pPrivateKeyInfo)
{
    DWORD               i = 0;
    DWORD               dwKeySpec;
    DWORD               cbAttribute = 0;
    CRYPT_BIT_BLOB      *pAttribute = NULL;
    PCRYPT_ATTRIBUTES   pCryptAttributes = pPrivateKeyInfo->pAttributes;

    // set the default keyspec
    if ((0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_RSA_RSA)) ||
        (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_ANSI_X942_DH)))
    {
        dwKeySpec = AT_KEYEXCHANGE;
    }
    else
    {
        dwKeySpec = AT_SIGNATURE;
    }

    if (pCryptAttributes != NULL)
        while (i < pCryptAttributes->cAttr) {
            if (lstrcmp(pCryptAttributes->rgAttr[i].pszObjId, szOID_KEY_USAGE) == 0) {

                if (!CryptDecodeObject(
                        X509_ASN_ENCODING,
                        X509_BITS,
                        pCryptAttributes->rgAttr[i].rgValue->pbData,
                        pCryptAttributes->rgAttr[i].rgValue->cbData,
                        0,
                        NULL,
                        &cbAttribute
                        )) {
                    i++;
                    continue;
                }

                if (NULL == (pAttribute = (CRYPT_BIT_BLOB *) PFXHelpAlloc(cbAttribute))) {
                    i++;
                    continue;
                }

                if (!CryptDecodeObject(
                        X509_ASN_ENCODING,
                        X509_BITS,
                        pCryptAttributes->rgAttr[i].rgValue->pbData,
                        pCryptAttributes->rgAttr[i].rgValue->cbData,
                        0,
                        pAttribute,
                        &cbAttribute
                        )) {
                    i++;
                    PFXHelpFree(pAttribute);
                    continue;
                }

                if ((pAttribute->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE) ||
                    (pAttribute->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE)) {
                    dwKeySpec = AT_KEYEXCHANGE;
                    goto CommonReturn;
                }
                else if ((pAttribute->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE) ||
                        (pAttribute->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE) ||
                        (pAttribute->pbData[0] & CERT_CRL_SIGN_KEY_USAGE)) {
                    dwKeySpec = AT_SIGNATURE;
                    goto CommonReturn;
                }
            } // if (lstrcmp(pCryptAttributes->rgAttr[i].pszObjId, szOID_KEY_USAGE) == 0)

            i++;
        } // while (i < pCryptAttributes->cAttr)

//ErrorReturn:
CommonReturn:
    if (pAttribute)
        PFXHelpFree(pAttribute);
    return dwKeySpec;
}



typedef struct _HCRYPT_QUERY_FUNC_STATE {
    DWORD                   dwSafeBagIndex;
    PHCRYPTPROV_QUERY_FUNC  phCryptQueryFunc;
    LPVOID                  pVoid;
    DWORD                   dwKeySpec;
    DWORD                   dwPFXImportFlags;
} HCRYPT_QUERY_FUNC_STATE, *PHCRYPT_QUERY_FUNC_STATE;

// this is the callback handler for resolving what HCRYPTPROV should
// be used to import the key to, it is handed in to the ImportPKCS8
// call, and will be called from that context.
// this callback will just turn around and call the callback provided
// when CertImportSafeContents was called.
static BOOL CALLBACK ResolvehCryptFunc(
    CRYPT_PRIVATE_KEY_INFO  *pPrivateKeyInfo,
    HCRYPTPROV              *phCryptProv,
    LPVOID                  pVoidResolveFunc)
{
    HCRYPT_QUERY_FUNC_STATE *pState = (HCRYPT_QUERY_FUNC_STATE *) pVoidResolveFunc;

    // set the dwKeySpec field in the HCRYPT_QUERY_FUNC_STATE structure
    // so that the CertImportSafeContents function can use it
    pState->dwKeySpec = ResolveKeySpec(pPrivateKeyInfo);

    return (pState->phCryptQueryFunc(
                        pPrivateKeyInfo,
                        pState->dwSafeBagIndex,
                        phCryptProv,
                        pState->pVoid,
                        pState->dwPFXImportFlags));

}


// this function will seach through two arrays of attributes and find the KeyID
// attributes and see if they match
static BOOL WINAPI KeyIDsMatch(
    CRYPT_ATTRIBUTES *pAttr1,
    CRYPT_ATTRIBUTES *pAttr2
    )
{
    BOOL            bMatch = FALSE;
    BOOL            bFound = FALSE;
    DWORD           i = 0;
    DWORD           j = 0;
    CRYPT_ATTR_BLOB *pDecodedAttr1 = NULL;
    DWORD           cbDecodedAttr1 = 0;
    CRYPT_ATTR_BLOB *pDecodedAttr2 = NULL;
    DWORD           cbDecodedAttr2 = 0;

    // search the first attribute array for a key id
    while ((i<pAttr1->cAttr) && (!bFound)) {

        if ((strcmp(pAttr1->rgAttr[i].pszObjId, szOID_PKCS_12_LOCAL_KEY_ID) == 0) &&
            (pAttr1->rgAttr[i].cValue != 0)){

            bFound = TRUE;
        }
        else {
            i++;
        }
    }

    // check to see if a key id was found
    if (!bFound)
        goto CommonReturn;

    // search the second attribute array for a key id
    bFound = FALSE;
    while ((j<pAttr2->cAttr) && (!bFound)) {
        if ((strcmp(pAttr2->rgAttr[j].pszObjId, szOID_PKCS_12_LOCAL_KEY_ID) == 0) &&
            (pAttr2->rgAttr[j].cValue != 0)) {

            bFound = TRUE;
        }
        else {
            j++;
        }
    }

    // check to see if a key id was found
    if (!bFound)
        goto CommonReturn;

    // decode the values
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_OCTET_STRING,
            pAttr1->rgAttr[i].rgValue[0].pbData,
            pAttr1->rgAttr[i].rgValue[0].cbData,
            0,
            NULL,
            &cbDecodedAttr1
            )) {
        goto ErrorReturn;
    }

    if (NULL == (pDecodedAttr1 = (CRYPT_ATTR_BLOB *) PFXHelpAlloc(cbDecodedAttr1))) {
        goto ErrorReturn;
    }

    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_OCTET_STRING,
            pAttr1->rgAttr[i].rgValue[0].pbData,
            pAttr1->rgAttr[i].rgValue[0].cbData,
            0,
            pDecodedAttr1,
            &cbDecodedAttr1
            )) {
        goto ErrorReturn;
    }

    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_OCTET_STRING,
            pAttr2->rgAttr[j].rgValue[0].pbData,
            pAttr2->rgAttr[j].rgValue[0].cbData,
            0,
            NULL,
            &cbDecodedAttr2
            )) {
        goto ErrorReturn;
    }

    if (NULL == (pDecodedAttr2 = (CRYPT_ATTR_BLOB *) PFXHelpAlloc(cbDecodedAttr2))) {
        goto ErrorReturn;
    }

    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_OCTET_STRING,
            pAttr2->rgAttr[j].rgValue[0].pbData,
            pAttr2->rgAttr[j].rgValue[0].cbData,
            0,
            pDecodedAttr2,
            &cbDecodedAttr2
            )) {
        goto ErrorReturn;
    }

    if ((pDecodedAttr1->cbData == pDecodedAttr2->cbData) &&
        (memcmp(pDecodedAttr1->pbData, pDecodedAttr2->pbData, pDecodedAttr1->cbData) == 0)) {
        bMatch = TRUE;
    }

    goto CommonReturn;

ErrorReturn:
    bMatch = FALSE;
CommonReturn:
    if (pDecodedAttr1)
        PFXHelpFree(pDecodedAttr1);
    if (pDecodedAttr2)
        PFXHelpFree(pDecodedAttr2);
    return bMatch;
}


// this function will search the attributes array and try to find a
// FRIENDLY_NAME attribute, if it does it will add it as a property
// to the given cert context
static
BOOL
WINAPI
AddFriendlyNameProperty(
    PCCERT_CONTEXT      pCertContext,
    CRYPT_ATTRIBUTES    *pAttr
    )
{
    BOOL            fReturn = TRUE;
    BOOL            bFound = FALSE;
    DWORD           i = 0;
    CERT_NAME_VALUE *pFriendlyName = NULL;
    DWORD           cbDecodedFriendlyName = 0;
    CRYPT_DATA_BLOB friendlyNameDataBlob;

    // search the attribute array for a FRIENDLY_NAME
    while ((i<pAttr->cAttr) && (!bFound)) {

        if ((strcmp(pAttr->rgAttr[i].pszObjId, szOID_PKCS_12_FRIENDLY_NAME_ATTR) == 0) &&
            (pAttr->rgAttr[i].cValue != 0)){

            bFound = TRUE;

            // try to decode the FRIENDLY_NAME
            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_UNICODE_ANY_STRING,
                    pAttr->rgAttr[i].rgValue[0].pbData,
                    pAttr->rgAttr[i].rgValue[0].cbData,
                    0,
                    NULL,
                    &cbDecodedFriendlyName
                    )) {
                goto ErrorReturn;
            }

            if (NULL == (pFriendlyName = (CERT_NAME_VALUE *) PFXHelpAlloc(cbDecodedFriendlyName))) {
                goto ErrorReturn;
            }

            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_UNICODE_ANY_STRING,
                    pAttr->rgAttr[i].rgValue[0].pbData,
                    pAttr->rgAttr[i].rgValue[0].cbData,
                    0,
                    pFriendlyName,
                    &cbDecodedFriendlyName
                    )) {
                goto ErrorReturn;
            }

            friendlyNameDataBlob.pbData = pFriendlyName->Value.pbData;
            friendlyNameDataBlob.cbData =
                (wcslen((LPWSTR)friendlyNameDataBlob.pbData) + 1) * sizeof(WCHAR);

            if (!CertSetCertificateContextProperty(
                    pCertContext,
                    CERT_FRIENDLY_NAME_PROP_ID,
                    0,
                    &friendlyNameDataBlob)) {
                goto ErrorReturn;
            }
        }
        else {
            i++;
        }
    }

    goto CommonReturn;

ErrorReturn:
    fReturn = FALSE;
CommonReturn:
    if (pFriendlyName)
        PFXHelpFree(pFriendlyName);
    return fReturn;
}


static BOOL GetProvType(HCRYPTPROV hCryptProv, DWORD *pdwProvType)
{
    BOOL            fRet = TRUE;
    HCRYPTKEY       hCryptKey = NULL;
    PUBLICKEYSTRUC  *pKeyBlob = NULL;
    DWORD           cbKeyBlob = 0;

    *pdwProvType = 0;

    // get a handle to the keyset to export
    if (!CryptGetUserKey(
            hCryptProv,
            AT_KEYEXCHANGE,
            &hCryptKey))
        if (!CryptGetUserKey(
                hCryptProv,
                AT_SIGNATURE,
                &hCryptKey))
            goto ErrorReturn;

    // export the key set to a CAPI blob
    if (!CryptExportKey(
            hCryptKey,
            0,
            PUBLICKEYBLOB,
            0,
            NULL,
            &cbKeyBlob))
        goto ErrorReturn;

    if (NULL == (pKeyBlob = (PUBLICKEYSTRUC *) SSAlloc(cbKeyBlob)))
        goto ErrorReturn;

    if (!CryptExportKey(
            hCryptKey,
            0,
            PUBLICKEYBLOB,
            0,
            (BYTE *)pKeyBlob,
            &cbKeyBlob))
        goto ErrorReturn;

    switch (pKeyBlob->aiKeyAlg)
    {
    case CALG_DSS_SIGN:
        *pdwProvType = PROV_DSS_DH;
        break;

    case CALG_RSA_SIGN:
        *pdwProvType = PROV_RSA_SIG;
        break;

    case CALG_RSA_KEYX:
        *pdwProvType = PROV_RSA_FULL;
        break;

    default:
        goto ErrorReturn;
    }

    goto CommonReturn;

ErrorReturn:
    fRet = FALSE;

CommonReturn:

    if (hCryptKey)
    {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(hCryptKey);
        SetLastError(dwErr);
    }

    if (pKeyBlob)
        SSFree(pKeyBlob);

    return (fRet);
}


//+-------------------------------------------------------------------------
// hCertStore -  handle of the cert store to import the safe contents to
// SafeContents - pointer to the safe contents to import to the store
// dwCertAddDisposition - used when importing certificate to the store.
//                        for a full explanation of the possible values
//                        and their meanings see documentation for
//                        CertAddEncodedCertificateToStore
// ImportSafeCallbackStruct - structure that contains pointers to functions
//                            which are callled to get a HCRYPTPROV for import
//                            and to decrypt the key if a EncryptPrivateKeyInfo
//                            is encountered during import
// dwFlags - The available flags are:
//              CRYPT_EXPORTABLE
//              this flag is used when importing private keys, for a full
//              explanation please see the documentation for CryptImportKey.
//              CRYPT_USER_PROTECTED
//              this flag is used when importing private keys, for a full
//              explanation please see the documentation for CryptImportKey.
//              CRYPT_MACHINE_KEYSET
//              this flag is used when calling CryptAcquireContext.
// pvAuxInfo - reserved for future use, must be set to NULL
//+-------------------------------------------------------------------------
BOOL WINAPI CertImportSafeContents(
    HCERTSTORE                  hCertStore,                 // in
    SAFE_CONTENTS               *pSafeContents,             // in
    DWORD                       dwCertAddDisposition,       // in
    IMPORT_SAFE_CALLBACK_STRUCT *ImportSafeCallbackStruct,  // in
    DWORD                       dwFlags,                    // in
    void                        *pvAuxInfo                  // in
)
{
    BOOL                        fResult = TRUE;
    DWORD                       i,j;
    PCCERT_CONTEXT              pCertContext = NULL;
    BOOL                        *pAlreadyInserted = NULL;
    HCRYPT_QUERY_FUNC_STATE     stateStruct;
    CRYPT_PKCS8_IMPORT_PARAMS   PrivateKeyBlobAndParams;
    HCRYPTPROV                  hCryptProv = NULL;
    CRYPT_KEY_PROV_INFO         cryptKeyProvInfo;
    LPSTR                       pszContainerName = NULL;
    DWORD                       cbContainerName = 0;
    LPSTR                       pszProviderName = NULL;
    DWORD                       cbProviderName = 0;
    DWORD                       dwProvType;
    DWORD                       cbProvType = sizeof(DWORD);
    DWORD                       dwNumWideChars = 0;
    BYTE                        *pbEncodedCert = NULL;
    DWORD                       cbEncodedCert = 0;
    DWORD                       dwKeySetType;
    DWORD                       cbKeySetType = sizeof(DWORD);

    ZeroMemory(&cryptKeyProvInfo, sizeof(CRYPT_KEY_PROV_INFO));

    // validate parameters
    if (pvAuxInfo != NULL) {
        SetLastError((DWORD)ERROR_INVALID_PARAMETER);
        goto ErrorReturn;
    }

    // set up the pAlreadyInserted array so that it has an entry for each safe
    // bag and all entries are set to false.  this is used so that the certificates
    // can be imported at the same time their corresponding private keys are imported
    if (NULL == (pAlreadyInserted = (BOOL *) PFXHelpAlloc(sizeof(BOOL) * pSafeContents->cSafeBags))) {
        goto ErrorReturn;
    }
    else {
        for (i=0; i<pSafeContents->cSafeBags; i++) {
            pAlreadyInserted[i] = FALSE;
        }
    }

    // loop for each safe bag and import it if it is a private key
    for (i=0; i<pSafeContents->cSafeBags; i++) {

        // check to see if it is a cert or a key
        if ((strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_KEY_BAG) == 0) ||
            (strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_SHROUDEDKEY_BAG) == 0)) {

            // set up the stateStruct so when the hCryptQueryFunc is called when can make
            // our callback
            stateStruct.dwSafeBagIndex      = i;
            stateStruct.phCryptQueryFunc    = ImportSafeCallbackStruct->phCryptProvQueryFunc;
            stateStruct.pVoid               = ImportSafeCallbackStruct->pVoidhCryptProvQuery;
            stateStruct.dwPFXImportFlags    = dwFlags;

            // import the private key
            PrivateKeyBlobAndParams.PrivateKey.pbData       = pSafeContents->pSafeBags[i].BagContents.pbData;
            PrivateKeyBlobAndParams.PrivateKey.cbData       = pSafeContents->pSafeBags[i].BagContents.cbData;
            PrivateKeyBlobAndParams.pResolvehCryptProvFunc  = ResolvehCryptFunc;
            PrivateKeyBlobAndParams.pVoidResolveFunc        = (LPVOID) &stateStruct;
            PrivateKeyBlobAndParams.pDecryptPrivateKeyFunc  = ImportSafeCallbackStruct->pDecryptPrivateKeyFunc;
            PrivateKeyBlobAndParams.pVoidDecryptFunc        = ImportSafeCallbackStruct->pVoidDecryptFunc;

            if (!CryptImportPKCS8(
                    PrivateKeyBlobAndParams,
                    dwFlags,
                    &hCryptProv,
                    NULL)) {
                goto ErrorReturn;
            }

            pAlreadyInserted[i] = TRUE;

            // now look at each safe bag and see if it contains a cert with a KeyID that
            // matches the private key that we just imported
            for (j=0; j<pSafeContents->cSafeBags; j++) {

                if ((strcmp(pSafeContents->pSafeBags[j].pszBagTypeOID, szOID_PKCS_12_CERT_BAG) == 0)    &&
                    (!pAlreadyInserted[j])                                                          &&
                    (KeyIDsMatch(&pSafeContents->pSafeBags[i].Attributes, &pSafeContents->pSafeBags[j].Attributes))){


                    // extract the encoded cert from an encoded cert bag
                    pbEncodedCert = NULL;
                    cbEncodedCert = 0;
                    if (!GetEncodedCertFromEncodedCertBag(
                            pSafeContents->pSafeBags[j].BagContents.pbData,
                            pSafeContents->pSafeBags[j].BagContents.cbData,
                            NULL,
                            &cbEncodedCert)) {
                        goto ErrorReturn;
                    }

                    if (NULL == (pbEncodedCert = (BYTE *) PFXHelpAlloc(cbEncodedCert))) {
                        goto ErrorReturn;
                    }

                    if (!GetEncodedCertFromEncodedCertBag(
                            pSafeContents->pSafeBags[j].BagContents.pbData,
                            pSafeContents->pSafeBags[j].BagContents.cbData,
                            pbEncodedCert,
                            &cbEncodedCert)) {
                        PFXHelpFree(pbEncodedCert);
                        goto ErrorReturn;
                    }

                    // insert the X509 cert blob into the store
                    if (!CertAddEncodedCertificateToStore(
                            hCertStore,
                            X509_ASN_ENCODING,
                            pbEncodedCert,
                            cbEncodedCert,
                            dwCertAddDisposition,
                            &pCertContext)) {
                        PFXHelpFree(pbEncodedCert);
                        goto ErrorReturn;
                    }

                    // we don't need this anymore
                    PFXHelpFree(pbEncodedCert);

                    if (!AddFriendlyNameProperty(
                            pCertContext,
                            &pSafeContents->pSafeBags[j].Attributes)) {
                        goto ErrorReturn;
                    }

                    // get information needed to set up a connection between the
                    // certificate and private key
                    if (!CryptGetProvParam(
                            hCryptProv,
                            PP_CONTAINER,
                            NULL,
                            &cbContainerName,
                            0))
                        goto ErrorReturn;

                    if (NULL == (pszContainerName =
                                    (LPSTR) PFXHelpAlloc(cbContainerName)))
                        goto ErrorReturn;

                    if (!CryptGetProvParam(
                            hCryptProv,
                            PP_CONTAINER,
                            (BYTE *) pszContainerName,
                            &cbContainerName,
                            0))
                        goto ErrorReturn;

                    if (!CryptGetProvParam(
                            hCryptProv,
                            PP_NAME,
                            NULL,
                            &cbProviderName,
                            0))
                        goto ErrorReturn;

                    if (NULL == (pszProviderName =
                                    (LPSTR) PFXHelpAlloc(cbProviderName)))
                        goto ErrorReturn;

                    if (!CryptGetProvParam(
                            hCryptProv,
                            PP_NAME,
                            (BYTE *) pszProviderName,
                            &cbProviderName,
                            0))
                        goto ErrorReturn;

                    if (!CryptGetProvParam(
                            hCryptProv,
                            PP_PROVTYPE,
                            (BYTE *) &dwProvType,
                            &cbProvType,
                            0)) {

                        // we couldn't get the information from the provider
                        // so try to figure it out ourselves
                        if (!GetProvType(hCryptProv, &dwProvType))
                        {
                            goto ErrorReturn;
                        }
                    }

                    // convert strings to wide chars
                    dwNumWideChars = MultiByteToWideChar(
                                        CP_ACP,
                                        0,
                                        pszContainerName,
                                        -1,
                                        NULL,
                                        0);

                    if (NULL == (cryptKeyProvInfo.pwszContainerName = (LPWSTR)
                                    PFXHelpAlloc(dwNumWideChars * sizeof(WCHAR)))) {
                        goto ErrorReturn;
                    }

                    if (!MultiByteToWideChar(
                                        CP_ACP,
                                        0,
                                        pszContainerName,
                                        -1,
                                        cryptKeyProvInfo.pwszContainerName,
                                        dwNumWideChars)) {
                        goto ErrorReturn;
                    }

                    dwNumWideChars = MultiByteToWideChar(
                                        CP_ACP,
                                        0,
                                        pszProviderName,
                                        -1,
                                        NULL,
                                        0);

                    if (NULL == (cryptKeyProvInfo.pwszProvName = (LPWSTR)
                                    PFXHelpAlloc(dwNumWideChars * sizeof(WCHAR)))) {
                        goto ErrorReturn;
                    }

                    if (!MultiByteToWideChar(
                                        CP_ACP,
                                        0,
                                        pszProviderName,
                                        -1,
                                        cryptKeyProvInfo.pwszProvName,
                                        dwNumWideChars)) {
                        goto ErrorReturn;
                    }

                    cryptKeyProvInfo.dwProvType = dwProvType;

                    if (CryptGetProvParam(
                            hCryptProv,
                            PP_KEYSET_TYPE,
                            (BYTE *) &dwKeySetType,
                            &cbKeySetType,
                            0)) {
                        if (CRYPT_MACHINE_KEYSET == dwKeySetType)
                        {
                            cryptKeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET;
                        }
                    }

                    // the dwKeySpec field was set by the callback generated from the
                    // CryptImportPKCS8 call.  the callback is currently used to because at
                    // the point the callback is made the private key has been decoded and
                    // the attributes are available, one of which is the key usage attribute.

                    // FIX - in the future we should be able to call CryptGetProvParam to get
                    // the dwKeySpec, right now that is not supported.
                    cryptKeyProvInfo.dwKeySpec = stateStruct.dwKeySpec;

                    // set up a property to point to the private key
                    if (!CertSetCertificateContextProperty(
                            pCertContext,
                            CERT_KEY_PROV_INFO_PROP_ID,
                            0,
                            (void *) &cryptKeyProvInfo)) {
                        CertFreeCertificateContext(pCertContext);
                        goto ErrorReturn;
                    }
                    CertFreeCertificateContext(pCertContext);
                    pAlreadyInserted[j] = TRUE;
                }

            } // for (j=0; j<pSafeContents->cSafeBags; j++)

        } // if (strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_KEY_BAG) == 0)

    } // for (i=0; i<pSafeContents->cSafeBags; i++)

    // now loop for each safe bag again and import the certificates which didn't have private keys
    for (i=0; i<pSafeContents->cSafeBags; i++) {

        // if the certificate has not been inserted, then do it
        if (!pAlreadyInserted[i]) {

            // extract the encoded cert from an encoded cert bag
            pbEncodedCert = NULL;
            cbEncodedCert = 0;
            if (!GetEncodedCertFromEncodedCertBag(
                    pSafeContents->pSafeBags[i].BagContents.pbData,
                    pSafeContents->pSafeBags[i].BagContents.cbData,
                    NULL,
                    &cbEncodedCert)) {
                goto ErrorReturn;
            }

            if (NULL == (pbEncodedCert = (BYTE *) PFXHelpAlloc(cbEncodedCert))) {
                goto ErrorReturn;
            }

            if (!GetEncodedCertFromEncodedCertBag(
                    pSafeContents->pSafeBags[i].BagContents.pbData,
                    pSafeContents->pSafeBags[i].BagContents.cbData,
                    pbEncodedCert,
                    &cbEncodedCert)) {
                PFXHelpFree(pbEncodedCert);
                goto ErrorReturn;
            }

            if (!CertAddEncodedCertificateToStore(
                    hCertStore,
                    X509_ASN_ENCODING,
                    pbEncodedCert,
                    cbEncodedCert,
                    dwCertAddDisposition,
                    &pCertContext)) {
                PFXHelpFree(pbEncodedCert);
                goto ErrorReturn;
            }

            // we don't need this anymore
            PFXHelpFree(pbEncodedCert);

            if (!AddFriendlyNameProperty(
                    pCertContext,
                    &pSafeContents->pSafeBags[i].Attributes)) {
                goto ErrorReturn;
            }

            CertFreeCertificateContext(pCertContext);
        }
    }

    goto CommonReturn;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pAlreadyInserted)
        PFXHelpFree(pAlreadyInserted);
    if (pszContainerName)
        PFXHelpFree(pszContainerName);
    if (pszProviderName)
        PFXHelpFree(pszProviderName);
    if (cryptKeyProvInfo.pwszContainerName)
        PFXHelpFree(cryptKeyProvInfo.pwszContainerName);
    if (cryptKeyProvInfo.pwszProvName)
        PFXHelpFree(cryptKeyProvInfo.pwszProvName);
    if (hCryptProv)
    {
        HRESULT hr = GetLastError();
        CryptReleaseContext(hCryptProv, 0);
        SetLastError(hr);
    }
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxpkcs.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for PFXPKCS */

#include <windows.h>
#include "pfxpkcs.h"

ASN1module_t PFXPKCS_Module = NULL;

static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_PBEParameter(ASN1encoding_t enc, ASN1uint32_t tag, PBEParameter *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_AuthenticatedSafes(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticatedSafes *val);
static int ASN1CALL ASN1Enc_SafeContents(ASN1encoding_t enc, ASN1uint32_t tag, SafeContents *val);
static int ASN1CALL ASN1Enc_SafeBag(ASN1encoding_t enc, ASN1uint32_t tag, SafeBag *val);
static int ASN1CALL ASN1Enc_CertBag(ASN1encoding_t enc, ASN1uint32_t tag, CertBag *val);
static int ASN1CALL ASN1Enc_CRLBag(ASN1encoding_t enc, ASN1uint32_t tag, CRLBag *val);
static int ASN1CALL ASN1Enc_SecretBag(ASN1encoding_t enc, ASN1uint32_t tag, SecretBag *val);
static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_ContentEncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_MacData(ASN1encoding_t enc, ASN1uint32_t tag, MacData *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Enc_PFX(ASN1encoding_t enc, ASN1uint32_t tag, PFX *val);
static int ASN1CALL ASN1Enc_KeyBag(ASN1encoding_t enc, ASN1uint32_t tag, KeyBag *val);
static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_Pkcs_8ShroudedKeyBag(ASN1encoding_t enc, ASN1uint32_t tag, Pkcs_8ShroudedKeyBag *val);
static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_PBEParameter(ASN1decoding_t dec, ASN1uint32_t tag, PBEParameter *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_AuthenticatedSafes(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticatedSafes *val);
static int ASN1CALL ASN1Dec_SafeContents(ASN1decoding_t dec, ASN1uint32_t tag, SafeContents *val);
static int ASN1CALL ASN1Dec_SafeBag(ASN1decoding_t dec, ASN1uint32_t tag, SafeBag *val);
static int ASN1CALL ASN1Dec_CertBag(ASN1decoding_t dec, ASN1uint32_t tag, CertBag *val);
static int ASN1CALL ASN1Dec_CRLBag(ASN1decoding_t dec, ASN1uint32_t tag, CRLBag *val);
static int ASN1CALL ASN1Dec_SecretBag(ASN1decoding_t dec, ASN1uint32_t tag, SecretBag *val);
static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_ContentEncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_MacData(ASN1decoding_t dec, ASN1uint32_t tag, MacData *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Dec_PFX(ASN1decoding_t dec, ASN1uint32_t tag, PFX *val);
static int ASN1CALL ASN1Dec_KeyBag(ASN1decoding_t dec, ASN1uint32_t tag, KeyBag *val);
static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_Pkcs_8ShroudedKeyBag(ASN1decoding_t dec, ASN1uint32_t tag, Pkcs_8ShroudedKeyBag *val);
static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val);
static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val);
static void ASN1CALL ASN1Free_IntegerType(IntegerType *val);
static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val);
static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_PBEParameter(PBEParameter *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_AuthenticatedSafes(AuthenticatedSafes *val);
static void ASN1CALL ASN1Free_SafeContents(SafeContents *val);
static void ASN1CALL ASN1Free_SafeBag(SafeBag *val);
static void ASN1CALL ASN1Free_CertBag(CertBag *val);
static void ASN1CALL ASN1Free_CRLBag(CRLBag *val);
static void ASN1CALL ASN1Free_SecretBag(SecretBag *val);
static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_ContentEncryptionAlgorithmIdentifier(ContentEncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_MacData(MacData *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val);
static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val);
static void ASN1CALL ASN1Free_PFX(PFX *val);
static void ASN1CALL ASN1Free_KeyBag(KeyBag *val);
static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val);
static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val);
static void ASN1CALL ASN1Free_Pkcs_8ShroudedKeyBag(Pkcs_8ShroudedKeyBag *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[22] = {
    (ASN1EncFun_t) ASN1Enc_ObjectIdentifierType,
    (ASN1EncFun_t) ASN1Enc_OctetStringType,
    (ASN1EncFun_t) ASN1Enc_IntegerType,
    (ASN1EncFun_t) ASN1Enc_RSAPublicKey,
    (ASN1EncFun_t) ASN1Enc_RSAPrivateKey,
    (ASN1EncFun_t) ASN1Enc_PBEParameter,
    (ASN1EncFun_t) ASN1Enc_AttributeSetValue,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_AuthenticatedSafes,
    (ASN1EncFun_t) ASN1Enc_SafeContents,
    (ASN1EncFun_t) ASN1Enc_SafeBag,
    (ASN1EncFun_t) ASN1Enc_CertBag,
    (ASN1EncFun_t) ASN1Enc_CRLBag,
    (ASN1EncFun_t) ASN1Enc_SecretBag,
    (ASN1EncFun_t) ASN1Enc_DigestInfo,
    (ASN1EncFun_t) ASN1Enc_MacData,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_PFX,
    (ASN1EncFun_t) ASN1Enc_KeyBag,
    (ASN1EncFun_t) ASN1Enc_EncryptedData,
    (ASN1EncFun_t) ASN1Enc_EncryptedPrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_Pkcs_8ShroudedKeyBag,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[22] = {
    (ASN1DecFun_t) ASN1Dec_ObjectIdentifierType,
    (ASN1DecFun_t) ASN1Dec_OctetStringType,
    (ASN1DecFun_t) ASN1Dec_IntegerType,
    (ASN1DecFun_t) ASN1Dec_RSAPublicKey,
    (ASN1DecFun_t) ASN1Dec_RSAPrivateKey,
    (ASN1DecFun_t) ASN1Dec_PBEParameter,
    (ASN1DecFun_t) ASN1Dec_AttributeSetValue,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_AuthenticatedSafes,
    (ASN1DecFun_t) ASN1Dec_SafeContents,
    (ASN1DecFun_t) ASN1Dec_SafeBag,
    (ASN1DecFun_t) ASN1Dec_CertBag,
    (ASN1DecFun_t) ASN1Dec_CRLBag,
    (ASN1DecFun_t) ASN1Dec_SecretBag,
    (ASN1DecFun_t) ASN1Dec_DigestInfo,
    (ASN1DecFun_t) ASN1Dec_MacData,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_PFX,
    (ASN1DecFun_t) ASN1Dec_KeyBag,
    (ASN1DecFun_t) ASN1Dec_EncryptedData,
    (ASN1DecFun_t) ASN1Dec_EncryptedPrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_Pkcs_8ShroudedKeyBag,
};
static const ASN1FreeFun_t freefntab[22] = {
    (ASN1FreeFun_t) ASN1Free_ObjectIdentifierType,
    (ASN1FreeFun_t) ASN1Free_OctetStringType,
    (ASN1FreeFun_t) ASN1Free_IntegerType,
    (ASN1FreeFun_t) ASN1Free_RSAPublicKey,
    (ASN1FreeFun_t) ASN1Free_RSAPrivateKey,
    (ASN1FreeFun_t) ASN1Free_PBEParameter,
    (ASN1FreeFun_t) ASN1Free_AttributeSetValue,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_AuthenticatedSafes,
    (ASN1FreeFun_t) ASN1Free_SafeContents,
    (ASN1FreeFun_t) ASN1Free_SafeBag,
    (ASN1FreeFun_t) ASN1Free_CertBag,
    (ASN1FreeFun_t) ASN1Free_CRLBag,
    (ASN1FreeFun_t) ASN1Free_SecretBag,
    (ASN1FreeFun_t) ASN1Free_DigestInfo,
    (ASN1FreeFun_t) ASN1Free_MacData,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_PFX,
    (ASN1FreeFun_t) ASN1Free_KeyBag,
    (ASN1FreeFun_t) ASN1Free_EncryptedData,
    (ASN1FreeFun_t) ASN1Free_EncryptedPrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_Pkcs_8ShroudedKeyBag,
};
static const ULONG sizetab[22] = {
    SIZE_PFXPKCS_Module_PDU_0,
    SIZE_PFXPKCS_Module_PDU_1,
    SIZE_PFXPKCS_Module_PDU_2,
    SIZE_PFXPKCS_Module_PDU_3,
    SIZE_PFXPKCS_Module_PDU_4,
    SIZE_PFXPKCS_Module_PDU_5,
    SIZE_PFXPKCS_Module_PDU_6,
    SIZE_PFXPKCS_Module_PDU_7,
    SIZE_PFXPKCS_Module_PDU_8,
    SIZE_PFXPKCS_Module_PDU_9,
    SIZE_PFXPKCS_Module_PDU_10,
    SIZE_PFXPKCS_Module_PDU_11,
    SIZE_PFXPKCS_Module_PDU_12,
    SIZE_PFXPKCS_Module_PDU_13,
    SIZE_PFXPKCS_Module_PDU_14,
    SIZE_PFXPKCS_Module_PDU_15,
    SIZE_PFXPKCS_Module_PDU_16,
    SIZE_PFXPKCS_Module_PDU_17,
    SIZE_PFXPKCS_Module_PDU_18,
    SIZE_PFXPKCS_Module_PDU_19,
    SIZE_PFXPKCS_Module_PDU_20,
    SIZE_PFXPKCS_Module_PDU_21,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
ASN1int32_t MacData_macIterationCount_default = 1;

void ASN1CALL PFXPKCS_Module_Startup(void)
{
    PFXPKCS_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 22, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x70786670);
}

void ASN1CALL PFXPKCS_Module_Cleanup(void)
{
    ASN1_CloseModule(PFXPKCS_Module);
    PFXPKCS_Module = NULL;
}

static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1BERDecOctetString(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val)
{
    if (val) {
	ASN1octetstring_free(val);
    }
}

static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BEREncSX(enc, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BERDecSXVal(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IntegerType(IntegerType *val)
{
    if (val) {
	ASN1intx_free(val);
    }
}

static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
	ASN1intx_free(&(val)->publicExponent);
    }
}

static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
	ASN1intx_free(&(val)->privateExponent);
	ASN1intx_free(&(val)->prime1);
	ASN1intx_free(&(val)->prime2);
	ASN1intx_free(&(val)->exponent1);
	ASN1intx_free(&(val)->exponent2);
	ASN1intx_free(&(val)->coefficient);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_PBEParameter(ASN1encoding_t enc, ASN1uint32_t tag, PBEParameter *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->iterationCount))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PBEParameter(ASN1decoding_t dec, ASN1uint32_t tag, PBEParameter *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->iterationCount))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PBEParameter(PBEParameter *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (AttributeSetValue_Set *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Attribute *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->content);
	}
    }
}

static int ASN1CALL ASN1Enc_AuthenticatedSafes(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticatedSafes *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ContentInfo(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticatedSafes(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticatedSafes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (ContentInfo *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_ContentInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticatedSafes(AuthenticatedSafes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_ContentInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_ContentInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SafeContents(ASN1encoding_t enc, ASN1uint32_t tag, SafeContents *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SafeBag(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SafeContents(ASN1decoding_t dec, ASN1uint32_t tag, SafeContents *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (SafeBag *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_SafeBag(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SafeContents(SafeContents *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SafeBag(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SafeBag(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SafeBag(ASN1encoding_t enc, ASN1uint32_t tag, SafeBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->safeBagType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->safeBagContent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->safeBagAttribs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SafeBag(ASN1decoding_t dec, ASN1uint32_t tag, SafeBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->safeBagType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->safeBagContent))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->safeBagAttribs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SafeBag(SafeBag *val)
{
    if (val) {
	ASN1open_free(&(val)->safeBagContent);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->safeBagAttribs);
	}
    }
}

static int ASN1CALL ASN1Enc_CertBag(ASN1encoding_t enc, ASN1uint32_t tag, CertBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->certType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertBag(ASN1decoding_t dec, ASN1uint32_t tag, CertBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->certType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertBag(CertBag *val)
{
    if (val) {
	ASN1open_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_CRLBag(ASN1encoding_t enc, ASN1uint32_t tag, CRLBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->crlType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRLBag(ASN1decoding_t dec, ASN1uint32_t tag, CRLBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->crlType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CRLBag(CRLBag *val)
{
    if (val) {
	ASN1open_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_SecretBag(ASN1encoding_t enc, ASN1uint32_t tag, SecretBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->secretType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->secretContent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecretBag(ASN1decoding_t dec, ASN1uint32_t tag, SecretBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->secretType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->secretContent))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecretBag(SecretBag *val)
{
    if (val) {
	ASN1open_free(&(val)->secretContent);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_ContentEncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentEncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentEncryptionAlgorithmIdentifier(ContentEncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_MacData(ASN1encoding_t enc, ASN1uint32_t tag, MacData *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->macIterationCount == 1)
	o[0] &= ~0x80;
    if (!ASN1Enc_DigestInfo(enc, 0, &(val)->safeMac))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->macSalt).length, ((val)->macSalt).value))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->macIterationCount))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MacData(ASN1decoding_t dec, ASN1uint32_t tag, MacData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_DigestInfo(dd, 0, &(val)->safeMac))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->macSalt))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->macIterationCount))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->macIterationCount = 1;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MacData(MacData *val)
{
    if (val) {
	ASN1Free_DigestInfo(&(val)->safeMac);
	ASN1octetstring_free(&(val)->macSalt);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_PrivateKeyAlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_PrivateKeyAlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->privateKey))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_PrivateKeyAlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	ASN1octetstring_free(&(val)->privateKey);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Enc_ContentEncryptionAlgorithmIdentifier(enc, 0, &(val)->contentEncryptionAlg))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->encryptedContent).length, ((val)->encryptedContent).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Dec_ContentEncryptionAlgorithmIdentifier(dd, 0, &(val)->contentEncryptionAlg))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->encryptedContent))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val)
{
    if (val) {
	ASN1Free_ContentEncryptionAlgorithmIdentifier(&(val)->contentEncryptionAlg);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->encryptedContent);
	}
    }
}

static int ASN1CALL ASN1Enc_PFX(ASN1encoding_t enc, ASN1uint32_t tag, PFX *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->authSafes))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MacData(enc, 0, &(val)->macData))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PFX(ASN1decoding_t dec, ASN1uint32_t tag, PFX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->authSafes))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_MacData(dd, 0, &(val)->macData))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PFX(PFX *val)
{
    if (val) {
	ASN1Free_ContentInfo(&(val)->authSafes);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MacData(&(val)->macData);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyBag(ASN1encoding_t enc, ASN1uint32_t tag, KeyBag *val)
{
    if (!ASN1Enc_PrivateKeyInfo(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyBag(ASN1decoding_t dec, ASN1uint32_t tag, KeyBag *val)
{
    if (!ASN1Dec_PrivateKeyInfo(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyBag(KeyBag *val)
{
    if (val) {
	ASN1Free_PrivateKeyInfo(val);
    }
}

static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val)
{
    if (val) {
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_EncryptionAlgorithmIdentifier(enc, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1Enc_EncryptedData(enc, 0, &(val)->encryptedData))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_EncryptionAlgorithmIdentifier(dd, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1Dec_EncryptedData(dd, 0, &(val)->encryptedData))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_EncryptionAlgorithmIdentifier(&(val)->encryptionAlgorithm);
	ASN1Free_EncryptedData(&(val)->encryptedData);
    }
}

static int ASN1CALL ASN1Enc_Pkcs_8ShroudedKeyBag(ASN1encoding_t enc, ASN1uint32_t tag, Pkcs_8ShroudedKeyBag *val)
{
    if (!ASN1Enc_EncryptedPrivateKeyInfo(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Pkcs_8ShroudedKeyBag(ASN1decoding_t dec, ASN1uint32_t tag, Pkcs_8ShroudedKeyBag *val)
{
    if (!ASN1Dec_EncryptedPrivateKeyInfo(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Pkcs_8ShroudedKeyBag(Pkcs_8ShroudedKeyBag *val)
{
    if (val) {
	ASN1Free_EncryptedPrivateKeyInfo(val);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\pfxpkcs.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for PFXPKCS */

#ifndef _PFXPKCS_Module_H_
#define _PFXPKCS_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1open_t AttributeSetValue_Set;

typedef ASN1objectidentifier2_t ObjectID;

typedef ObjectID ObjID;

typedef ASN1open_t Any;

typedef ObjectID ObjectIdentifierType;
#define ObjectIdentifierType_PDU 0
#define SIZE_PFXPKCS_Module_PDU_0 sizeof(ObjectIdentifierType)

typedef ASN1octetstring_t OctetStringType;
#define OctetStringType_PDU 1
#define SIZE_PFXPKCS_Module_PDU_1 sizeof(OctetStringType)

typedef ASN1intx_t IntegerType;
#define IntegerType_PDU 2
#define SIZE_PFXPKCS_Module_PDU_2 sizeof(IntegerType)

typedef ASN1intx_t HugeInteger;

typedef ASN1int32_t Version;

typedef ASN1octetstring_t PrivateKey;

typedef ASN1octetstring_t EncryptedContent;

typedef ASN1octetstring_t Digest;

typedef ObjectID ContentType;

typedef ASN1octetstring_t X509Cert;

typedef ASN1ztcharstring_t SDSICert;

typedef ASN1octetstring_t X509CRL;

typedef struct RSAPublicKey {
    HugeInteger modulus;
    HugeInteger publicExponent;
} RSAPublicKey;
#define RSAPublicKey_PDU 3
#define SIZE_PFXPKCS_Module_PDU_3 sizeof(RSAPublicKey)

typedef struct RSAPrivateKey {
    Version version;
    HugeInteger modulus;
    ASN1int32_t publicExponent;
    HugeInteger privateExponent;
    HugeInteger prime1;
    HugeInteger prime2;
    HugeInteger exponent1;
    HugeInteger exponent2;
    HugeInteger coefficient;
} RSAPrivateKey;
#define RSAPrivateKey_PDU 4
#define SIZE_PFXPKCS_Module_PDU_4 sizeof(RSAPrivateKey)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;

typedef struct PBEParameter {
    ASN1octetstring_t salt;
    ASN1int32_t iterationCount;
} PBEParameter;
#define PBEParameter_PDU 5
#define SIZE_PFXPKCS_Module_PDU_5 sizeof(PBEParameter)

typedef AlgorithmIdentifier DigestAlgorithmIdentifier;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    AttributeSetValue_Set *value;
} AttributeSetValue;
#define AttributeSetValue_PDU 6
#define SIZE_PFXPKCS_Module_PDU_6 sizeof(AttributeSetValue)

typedef struct Attribute {
    ObjectID attributeType;
    AttributeSetValue attributeValue;
} Attribute;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;
#define Attributes_PDU 7
#define SIZE_PFXPKCS_Module_PDU_7 sizeof(Attributes)

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define content_present 0x80
    ASN1open_t content;
} ContentInfo;

typedef struct AuthenticatedSafes {
    ASN1uint32_t count;
    struct ContentInfo *value;
} AuthenticatedSafes;
#define AuthenticatedSafes_PDU 8
#define SIZE_PFXPKCS_Module_PDU_8 sizeof(AuthenticatedSafes)

typedef struct SafeContents {
    ASN1uint32_t count;
    struct SafeBag *value;
} SafeContents;
#define SafeContents_PDU 9
#define SIZE_PFXPKCS_Module_PDU_9 sizeof(SafeContents)

typedef struct SafeBag {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID safeBagType;
    ASN1open_t safeBagContent;
#   define safeBagAttribs_present 0x80
    Attributes safeBagAttribs;
} SafeBag;
#define SafeBag_PDU 10
#define SIZE_PFXPKCS_Module_PDU_10 sizeof(SafeBag)

typedef struct CertBag {
    ObjectID certType;
    ASN1open_t value;
} CertBag;
#define CertBag_PDU 11
#define SIZE_PFXPKCS_Module_PDU_11 sizeof(CertBag)

typedef struct CRLBag {
    ObjectID crlType;
    ASN1open_t value;
} CRLBag;
#define CRLBag_PDU 12
#define SIZE_PFXPKCS_Module_PDU_12 sizeof(CRLBag)

typedef struct SecretBag {
    ObjectID secretType;
    ASN1open_t secretContent;
} SecretBag;
#define SecretBag_PDU 13
#define SIZE_PFXPKCS_Module_PDU_13 sizeof(SecretBag)

typedef AlgorithmIdentifier PrivateKeyAlgorithmIdentifier;

typedef AlgorithmIdentifier EncryptionAlgorithmIdentifier;

typedef AlgorithmIdentifier ContentEncryptionAlgorithmIdentifier;

typedef struct DigestInfo {
    DigestAlgorithmIdentifier digestAlgorithm;
    Digest digest;
} DigestInfo;
#define DigestInfo_PDU 14
#define SIZE_PFXPKCS_Module_PDU_14 sizeof(DigestInfo)

typedef struct MacData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DigestInfo safeMac;
    ASN1octetstring_t macSalt;
#   define macIterationCount_present 0x80
    ASN1int32_t macIterationCount;
} MacData;
#define MacData_PDU 15
#define SIZE_PFXPKCS_Module_PDU_15 sizeof(MacData)

typedef struct PrivateKeyInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Version version;
    PrivateKeyAlgorithmIdentifier privateKeyAlgorithm;
    PrivateKey privateKey;
#   define attributes_present 0x80
    Attributes attributes;
} PrivateKeyInfo;
#define PrivateKeyInfo_PDU 16
#define SIZE_PFXPKCS_Module_PDU_16 sizeof(PrivateKeyInfo)

typedef struct EncryptedContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
    ContentEncryptionAlgorithmIdentifier contentEncryptionAlg;
#   define encryptedContent_present 0x80
    EncryptedContent encryptedContent;
} EncryptedContentInfo;

typedef struct PFX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Version version;
    ContentInfo authSafes;
#   define macData_present 0x80
    MacData macData;
} PFX;
#define PFX_PDU 17
#define SIZE_PFXPKCS_Module_PDU_17 sizeof(PFX)

typedef PrivateKeyInfo KeyBag;
#define KeyBag_PDU 18
#define SIZE_PFXPKCS_Module_PDU_18 sizeof(KeyBag)

typedef struct EncryptedData {
    Version version;
    EncryptedContentInfo encryptedContentInfo;
} EncryptedData;
#define EncryptedData_PDU 19
#define SIZE_PFXPKCS_Module_PDU_19 sizeof(EncryptedData)

typedef struct EncryptedPrivateKeyInfo {
    EncryptionAlgorithmIdentifier encryptionAlgorithm;
    EncryptedData encryptedData;
} EncryptedPrivateKeyInfo;
#define EncryptedPrivateKeyInfo_PDU 20
#define SIZE_PFXPKCS_Module_PDU_20 sizeof(EncryptedPrivateKeyInfo)

typedef EncryptedPrivateKeyInfo Pkcs_8ShroudedKeyBag;
#define Pkcs_8ShroudedKeyBag_PDU 21
#define SIZE_PFXPKCS_Module_PDU_21 sizeof(Pkcs_8ShroudedKeyBag)

extern ASN1int32_t MacData_macIterationCount_default;

extern ASN1module_t PFXPKCS_Module;
extern void ASN1CALL PFXPKCS_Module_Startup(void);
extern void ASN1CALL PFXPKCS_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PFXPKCS_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


#define IDS_ROOT_MSG_BOX_TITLE              6100
#define IDS_ROOT_MSG_BOX_SUBJECT            6110
#define IDS_ROOT_MSG_BOX_ISSUER             6120
#define IDS_ROOT_MSG_BOX_SELF_ISSUED        6121
#define IDS_ROOT_MSG_BOX_SERIAL_NUMBER      6130
#define IDS_ROOT_MSG_BOX_SHA1_THUMBPRINT    6140
#define IDS_ROOT_MSG_BOX_MD5_THUMBPRINT     6150
#define IDS_ROOT_MSG_BOX_TIME_VALIDITY      6160
#define IDS_ROOT_MSG_BOX_ADD_ACTION         6170
#define IDS_ROOT_MSG_BOX_DELETE_ACTION      6180
#define	IDS_FRMT_SPACE						6200
#define	IDS_FRMT_A							6201
#define	IDS_FRMT_ZERO						6202
#define	IDS_FRMT_HEX						6203
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\cba.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cba.h
//
//  Contents:   CCryptBlobArray class definition
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CBA_H__)
#define __CBA_H__

#include <windows.h>
#include <wincrypt.h>

//
// class CCryptBlobArray.  This class manages a CRYPT_BLOB_ARRAY structure.
// Note that the freeing of the internal array structure must be done
// explicitly
//

class CCryptBlobArray
{
public:

    //
    // Construction
    //

    CCryptBlobArray (ULONG cMinBlobs, ULONG cGrowBlobs, BOOL& rfResult);

    // NOTE: Only accepts native form blob arrays or read-only single buffer
    //       encoded arrays
    CCryptBlobArray (PCRYPT_BLOB_ARRAY pcba, ULONG cGrowBlobs);

    ~CCryptBlobArray () {};

    //
    // Blob management methods
    //

    static LPBYTE AllocBlob (ULONG cb);
    static LPBYTE ReallocBlob (LPBYTE pb, ULONG cb);
    static VOID FreeBlob (LPBYTE pb);

    BOOL AddBlob (ULONG cb, LPBYTE pb, BOOL fCopyBlob);

    PCRYPT_DATA_BLOB GetBlob (ULONG index);

    //
    // Array management methods
    //

    ULONG GetBlobCount ();

    VOID GetArrayInNativeForm (PCRYPT_BLOB_ARRAY pcba);

    BOOL GetArrayInSingleBufferEncodedForm (
                 PCRYPT_BLOB_ARRAY* ppcba,
                 ULONG* pcb = NULL
                 );

    VOID FreeArray (BOOL fFreeBlobs);

private:

    //
    // Internal blob array
    //

    CRYPT_BLOB_ARRAY m_cba;

    //
    // Current blob array size
    //

    ULONG            m_cArray;

    //
    // Grow blobs by
    //

    ULONG            m_cGrowBlobs;

    //
    // Private methods
    //

    BOOL GrowArray ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\prvtkey.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#ifndef _PRVTKEY_Module_H_
#define _PRVTKEY_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1objectidentifier2_t ObjectID;

typedef ASN1int32_t Version;

typedef OCTETSTRING PrivateKey;

typedef OCTETSTRING EncryptedData;

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} AlgorithmIdentifier;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    NOCOPYANY *value;
} AttributeSetValue;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;

typedef struct RSAPrivateKey {
    Version version;
    HUGEINTEGER modulus;
    ASN1int32_t publicExponent;
    HUGEINTEGER privateExponent;
    HUGEINTEGER prime1;
    HUGEINTEGER prime2;
    HUGEINTEGER exponent1;
    HUGEINTEGER exponent2;
    HUGEINTEGER coefficient;
} RSAPrivateKey;
#define RSAPrivateKey_PDU 0
#define SIZE_PRVTKEY_Module_PDU_0 sizeof(RSAPrivateKey)

typedef AlgorithmIdentifier PrivateKeyAlgorithmIdentifier;

typedef struct PrivateKeyInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Version version;
    PrivateKeyAlgorithmIdentifier privateKeyAlgorithm;
    PrivateKey privateKey;
#   define privateKeyAttributes_present 0x80
    Attributes privateKeyAttributes;
} PrivateKeyInfo;
#define PrivateKeyInfo_PDU 1
#define SIZE_PRVTKEY_Module_PDU_1 sizeof(PrivateKeyInfo)

typedef AlgorithmIdentifier EncryptionAlgorithmIdentifier;

typedef struct EncryptedPrivateKeyInfo {
    EncryptionAlgorithmIdentifier encryptionAlgorithm;
    EncryptedData encryptedData;
} EncryptedPrivateKeyInfo;
#define EncryptedPrivateKeyInfo_PDU 2
#define SIZE_PRVTKEY_Module_PDU_2 sizeof(EncryptedPrivateKeyInfo)

typedef struct Attribute {
    ObjectID type;
    AttributeSetValue values;
} Attribute;
#define Attribute_PDU 3
#define SIZE_PRVTKEY_Module_PDU_3 sizeof(Attribute)


extern ASN1module_t PRVTKEY_Module;
extern void ASN1CALL PRVTKEY_Module_Startup(void);
extern void ASN1CALL PRVTKEY_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PRVTKEY_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\pfxlib\prvtkey.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#include <windows.h>
#include "prvtkey.h"

ASN1module_t PRVTKEY_Module = NULL;

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val);
static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val);
static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[4] = {
    (ASN1EncFun_t) ASN1Enc_RSAPrivateKey,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_EncryptedPrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_Attribute,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[4] = {
    (ASN1DecFun_t) ASN1Dec_RSAPrivateKey,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_EncryptedPrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_Attribute,
};
static const ASN1FreeFun_t freefntab[4] = {
    (ASN1FreeFun_t) ASN1Free_RSAPrivateKey,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_EncryptedPrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_Attribute,
};
static const ULONG sizetab[4] = {
    SIZE_PRVTKEY_Module_PDU_0,
    SIZE_PRVTKEY_Module_PDU_1,
    SIZE_PRVTKEY_Module_PDU_2,
    SIZE_PRVTKEY_Module_PDU_3,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL PRVTKEY_Module_Startup(void)
{
    PRVTKEY_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 4, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x74767270);
}

void ASN1CALL PRVTKEY_Module_Cleanup(void)
{
    ASN1_CloseModule(PRVTKEY_Module);
    PRVTKEY_Module = NULL;
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (NOCOPYANY *) pvASN1DecRealloc;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    void *pvASN1DecRealloc;
	    n = n ? (n << 1) : 16;
	    if (!(pvASN1DecRealloc = ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	    (val)->value = (Attribute *) pvASN1DecRealloc;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
	ASN1intx_free(&(val)->privateExponent);
	ASN1intx_free(&(val)->prime1);
	ASN1intx_free(&(val)->prime2);
	ASN1intx_free(&(val)->exponent1);
	ASN1intx_free(&(val)->exponent2);
	ASN1intx_free(&(val)->coefficient);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_PrivateKeyAlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->privateKeyAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_PrivateKeyAlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->privateKey))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->privateKeyAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_PrivateKeyAlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->privateKeyAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_EncryptionAlgorithmIdentifier(enc, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedData).length, ((val)->encryptedData).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_EncryptionAlgorithmIdentifier(dd, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->encryptedData))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_EncryptionAlgorithmIdentifier(&(val)->encryptionAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\cgou.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cgou.cpp
//
//  Contents:   CryptGetObjectUrl implementation
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   CryptGetObjectUrl
//
//  Synopsis:   get a locator from a CAPI object
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptGetObjectUrl (
     IN LPCSTR pszUrlOid,
     IN LPVOID pvPara,
     IN DWORD dwFlags,
     OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
     IN OUT DWORD* pcbUrlArray,
     OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
     IN OUT OPTIONAL DWORD* pcbUrlInfo,
     IN OPTIONAL LPVOID pvReserved
     )
{
    BOOL                    fResult;
    HCRYPTOIDFUNCADDR       hGetObjectUrl;
    PFN_GET_OBJECT_URL_FUNC pfnGetObjectUrl;
    DWORD                   LastError;

    if ( CryptGetOIDFunctionAddress(
              hGetObjectUrlFuncSet,
              X509_ASN_ENCODING,
              pszUrlOid,
              0,
              (LPVOID *)&pfnGetObjectUrl,
              &hGetObjectUrl
              ) == FALSE )
    {
        return( FALSE );
    }

    if ( dwFlags == 0 )
    {
        dwFlags |= CRYPT_GET_URL_FROM_PROPERTY;
        dwFlags |= CRYPT_GET_URL_FROM_EXTENSION;
        dwFlags |= CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE;
        dwFlags |= CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE;
    }

    fResult = ( *pfnGetObjectUrl )(
                       pszUrlOid,
                       pvPara,
                       dwFlags,
                       pUrlArray,
                       pcbUrlArray,
                       pUrlInfo,
                       pcbUrlInfo,
                       pvReserved
                       );

    LastError = GetLastError();
    CryptFreeOIDFunctionAddress( hGetObjectUrl, 0 );
    SetLastError( LastError );

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\cba.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cba.cpp
//
//  Contents:   Implementation of CCryptBlobArray
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::CCryptBlobArray, public
//
//  Synopsis:   Initialize the internal CRYPT_BLOB_ARRAY
//
//----------------------------------------------------------------------------
CCryptBlobArray::CCryptBlobArray (
                       ULONG cMinBlobs,
                       ULONG cGrowBlobs,
                       BOOL& rfResult
                       )
{
    rfResult = TRUE;
    m_cGrowBlobs = cGrowBlobs;
    m_cba.cBlob = 0;
    m_cba.rgBlob = new CRYPT_DATA_BLOB [cMinBlobs];
    if ( m_cba.rgBlob != NULL )
    {
        memset( m_cba.rgBlob, 0, sizeof(CRYPT_DATA_BLOB)*cMinBlobs );
        m_cArray = cMinBlobs;
    }
    else
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::CCryptBlobArray, public
//
//  Synopsis:   Initialize the internal CRYPT_BLOB_ARRAY with a native form
//              blob array created via ::GetArrayInNativeForm
//
//----------------------------------------------------------------------------
CCryptBlobArray::CCryptBlobArray (
                       PCRYPT_BLOB_ARRAY pcba,
                       ULONG cGrowBlobs
                       )
{
    m_cGrowBlobs = cGrowBlobs;
    m_cba.cBlob = pcba->cBlob;
    m_cba.rgBlob = pcba->rgBlob;
    m_cArray = pcba->cBlob;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::AllocBlob, public, static
//
//  Synopsis:   allocate a blob using the same allocator used for ::AddBlob
//              copies.  This means that the resulting blob can be added
//              without copying.
//
//----------------------------------------------------------------------------
LPBYTE
CCryptBlobArray::AllocBlob (ULONG cb)
{
    return( (LPBYTE)CryptMemAlloc( cb ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::ReallocBlob, public, static
//
//  Synopsis:   see ::AllocBlob
//
//----------------------------------------------------------------------------
LPBYTE
CCryptBlobArray::ReallocBlob (LPBYTE pb, ULONG cb)
{
    return( (LPBYTE)CryptMemRealloc( pb, cb ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::FreeBlob, public
//
//  Synopsis:   free blob allocated using ::AllocBlob or ::ReallocBlob
//
//----------------------------------------------------------------------------
VOID
CCryptBlobArray::FreeBlob (LPBYTE pb)
{
    CryptMemFree( pb );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::AddBlob, public
//
//  Synopsis:   add a blob
//
//----------------------------------------------------------------------------
BOOL
CCryptBlobArray::AddBlob (
                    ULONG cb,
                    LPBYTE pb,
                    BOOL fCopyBlob
                    )
{
    BOOL   fResult = TRUE;
    LPBYTE pbToUse;

    //
    // If we need to copy the blob, do so
    //

    if ( fCopyBlob == TRUE )
    {
        pbToUse = AllocBlob( cb );
        if ( pbToUse != NULL )
        {
            memcpy( pbToUse, pb, cb );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }
    }
    else
    {
        pbToUse = pb;
    }

    //
    // If we need to grow the array, do so
    //

    if ( m_cArray == m_cba.cBlob )
    {
        fResult = GrowArray();
    }

    //
    // Add the blob to the array
    //

    if ( fResult == TRUE )
    {
        m_cba.rgBlob[m_cba.cBlob].cbData = cb;
        m_cba.rgBlob[m_cba.cBlob].pbData = pbToUse;
        m_cba.cBlob += 1;
    }
    else if ( fCopyBlob == TRUE )
    {
        FreeBlob( pbToUse );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GetBlob, public
//
//  Synopsis:   gets blob given an index
//
//----------------------------------------------------------------------------
PCRYPT_DATA_BLOB
CCryptBlobArray::GetBlob (ULONG index)
{
    assert( m_cba.cBlob > index );

    return( &m_cba.rgBlob[index] );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GetBlobCount, public
//
//  Synopsis:   get the count of blobs
//
//----------------------------------------------------------------------------
ULONG
CCryptBlobArray::GetBlobCount ()
{
    return( m_cba.cBlob );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GetArrayInNativeForm, public
//
//  Synopsis:   get the array in native form
//
//----------------------------------------------------------------------------
VOID
CCryptBlobArray::GetArrayInNativeForm (PCRYPT_BLOB_ARRAY pcba)
{
    pcba->cBlob = m_cba.cBlob;
    pcba->rgBlob = m_cba.rgBlob;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GetArrayInSingleBufferEncodedForm, public
//
//  Synopsis:   gets the array in a single buffer encoded form
//
//----------------------------------------------------------------------------
BOOL
CCryptBlobArray::GetArrayInSingleBufferEncodedForm (
                         PCRYPT_BLOB_ARRAY* ppcba,
                         ULONG* pcb
                         )
{
    ULONG             cbStruct;
    ULONG             cbPointers;
    ULONG             cbData;
    ULONG             cb;
    ULONG             cbSize;
    ULONG             cCount;
    PCRYPT_BLOB_ARRAY pcba = NULL;

    //
    // Calculate the buffer size we will need and allocate it
    //

    cbStruct = sizeof( CRYPT_BLOB_ARRAY );
    cbPointers = m_cba.cBlob * sizeof( CRYPT_DATA_BLOB );

    for ( cCount = 0, cbData = 0; cCount < m_cba.cBlob; cCount++ )
    {
        cbData += m_cba.rgBlob[cCount].cbData;
    }

    cbSize = cbStruct + cbPointers + cbData;
    pcba = (PCRYPT_BLOB_ARRAY)CryptMemAlloc( cbSize );
    if ( pcba == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    //
    // Fill in the data
    //

    pcba->cBlob = m_cba.cBlob;
    pcba->rgBlob = (PCRYPT_DATA_BLOB)((LPBYTE)pcba+cbStruct);

    __try
    {
        for ( cCount = 0, cb = 0; cCount < m_cba.cBlob; cCount++ )
        {
            pcba->rgBlob[cCount].cbData = m_cba.rgBlob[cCount].cbData;
            pcba->rgBlob[cCount].pbData = (LPBYTE)pcba+cbStruct+cbPointers+cb;

            memcpy(
               pcba->rgBlob[cCount].pbData,
               m_cba.rgBlob[cCount].pbData,
               m_cba.rgBlob[cCount].cbData
               );

            cb += m_cba.rgBlob[cCount].cbData;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        CryptMemFree( pcba );
        SetLastError( GetExceptionCode() );
        return( FALSE );
    }

    *ppcba = pcba;

    if ( pcb != NULL )
    {
        *pcb = cbSize;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::FreeArray, public
//
//  Synopsis:   frees the array and optionally frees the blobs
//
//----------------------------------------------------------------------------
VOID
CCryptBlobArray::FreeArray (BOOL fFreeBlobs)
{
    if ( fFreeBlobs == TRUE )
    {
        ULONG cCount;

        for ( cCount = 0; cCount < m_cba.cBlob; cCount++ )
        {
            FreeBlob( m_cba.rgBlob[cCount].pbData );
        }
    }

    delete m_cba.rgBlob;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GrowArray, private
//
//  Synopsis:   grows the array
//
//----------------------------------------------------------------------------
BOOL
CCryptBlobArray::GrowArray ()
{
    ULONG            cNewArray;
    PCRYPT_DATA_BLOB pcba;

    //
    // Check if we are allowed to grow
    //
    //

    if ( m_cGrowBlobs == 0 )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    //
    // Allocate and initialize the new array
    //

    cNewArray = m_cArray + m_cGrowBlobs;
    pcba = new CRYPT_DATA_BLOB [cNewArray];
    if ( pcba == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    memset(pcba, 0, cNewArray*sizeof( CRYPT_DATA_BLOB ));

    //
    // Copy the old to the new
    //

    memcpy(pcba, m_cba.rgBlob, m_cba.cBlob*sizeof( CRYPT_DATA_BLOB ) );

    //
    // Free the old and use the new
    //

    delete m_cba.rgBlob;
    m_cba.rgBlob = pcba;
    m_cArray = cNewArray;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\crobu.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crobu.h
//
//  Contents:   CryptRetrieveObjectByUrl and support functions
//
//  History:    02-Jun-00    philh    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#if !defined(__CRYPTNET_CROBU_H__)
#define __CRYPTNET_CROBU_H__

VOID
WINAPI
InitializeCryptRetrieveObjectByUrl(
    HMODULE hModule
    );

VOID
WINAPI
DeleteCryptRetrieveObjectByUrl();

BOOL
I_CryptNetIsDebugErrorPrintEnabled();

BOOL
I_CryptNetIsDebugTracePrintEnabled();

void
I_CryptNetDebugPrintfA(
    LPCSTR szFormat,
    ...
    );

void
I_CryptNetDebugErrorPrintfA(
    LPCSTR szFormat,
    ...
    );

void
I_CryptNetDebugTracePrintfA(
    LPCSTR szFormat,
    ...
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\ctxpvdr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctxpvdr.cpp
//
//  Contents:   Context Providers for Remote Object Retrieval
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>

//+---------------------------------------------------------------------------
//  Function:   CreateObjectContext
//
//  Synopsis:   create single context or store containing multiple contexts
//----------------------------------------------------------------------------
BOOL WINAPI CreateObjectContext (
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 IN DWORD dwExpectedContentTypeFlags,
                 IN BOOL fQuerySingleContext,
                 OUT LPVOID* ppvContext
                 )
{
    BOOL       fResult = TRUE;
    HCERTSTORE hStore;
    DWORD      cCount;
    int        iQueryResult;
    DWORD      dwQueryErr = 0;
    
    if ( !( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) )
    {
        assert( pObject->cBlob > 0 );

        return( CryptQueryObject(
                     CERT_QUERY_OBJECT_BLOB,
                     (const void *)&(pObject->rgBlob[0]),
                     fQuerySingleContext ?
                         (dwExpectedContentTypeFlags &
                             ( CERT_QUERY_CONTENT_FLAG_CERT |
                               CERT_QUERY_CONTENT_FLAG_CTL  |
                               CERT_QUERY_CONTENT_FLAG_CRL  ))
                         : dwExpectedContentTypeFlags,
                     CERT_QUERY_FORMAT_FLAG_ALL,
                     0,
                     NULL,
                     NULL,
                     NULL,
                     fQuerySingleContext ? NULL : (HCERTSTORE *) ppvContext,
                     NULL,
                     fQuerySingleContext ? (const void **) ppvContext : NULL
                     ) );
    }
                       
    if ( ( hStore = CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        0,
                        NULL,
                        0,
                        NULL
                        ) ) == NULL )
    {
        return( FALSE );
    }
    
    //  0 =>  no CryptQueryObject()
    //  1 =>  1 successful CryptQueryObject()
    // -1 =>  all CryptQueryObject()'s failed
    iQueryResult = 0;

    for ( cCount = 0; 
          ( fResult == TRUE ) && ( cCount < pObject->cBlob ); 
          cCount++ )
    {
        PCERT_BLOB pBlob = &pObject->rgBlob[cCount];
        HCERTSTORE hChildStore;

        // Skip empty blobs. I have seen empty LDAP attributes containing
        // a single byte set to 0.
        if (0 == pBlob->cbData ||
                (1 == pBlob->cbData && 0 == pBlob->pbData[0]))
        {
            continue;
        }

        if (CryptQueryObject(
                       CERT_QUERY_OBJECT_BLOB,
                       (LPVOID) pBlob,
                       dwExpectedContentTypeFlags,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hChildStore,
                       NULL,
                       NULL
                       ))
        {
            if (fQuerySingleContext)
            {
                if (0 == (dwExpectedContentTypeFlags &
                            CERT_QUERY_CONTENT_FLAG_CERT))
                {
                    PCCERT_CONTEXT pDeleteCert;
                    while (pDeleteCert = CertEnumCertificatesInStore(
                            hChildStore, NULL))
                    {
                        CertDeleteCertificateFromStore(pDeleteCert);
                    }
                }

                if (0 == (dwExpectedContentTypeFlags &
                            CERT_QUERY_CONTENT_FLAG_CRL))
                {
                    PCCRL_CONTEXT pDeleteCrl;
                    while (pDeleteCrl = CertEnumCRLsInStore(
                            hChildStore, NULL))
                    {
                        CertDeleteCRLFromStore(pDeleteCrl);
                    }
                }
            }

            fResult = I_CertUpdateStore( hStore, hChildStore, 0, NULL );
            CertCloseStore( hChildStore, 0 );
            iQueryResult = 1;
        }
        else if (iQueryResult == 0)
        {
            iQueryResult = -1;
            dwQueryErr = GetLastError();
        }
    }

    if ( fResult == TRUE && iQueryResult < 0)
    {
        fResult = FALSE;
        SetLastError(dwQueryErr);
    }
    
    if ( fResult == TRUE )
    {
        *ppvContext = (LPVOID)hStore;
    }
    else
    {
        CertCloseStore( hStore, 0 );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertificateCreateObjectContext
//
//  Synopsis:   creates a certificate context from encoded certificate bits
//
//----------------------------------------------------------------------------
BOOL WINAPI CertificateCreateObjectContext (
                       IN LPCSTR pszObjectOid,
                       IN DWORD dwRetrievalFlags,
                       IN PCRYPT_BLOB_ARRAY pObject,
                       OUT LPVOID* ppvContext
                       )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_CERT |
                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                    CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
                TRUE,                               // fQuerySingleContext
                ppvContext
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   CTLCreateObjectContext
//
//  Synopsis:   creates a CTL context from encoded CTL bits
//
//----------------------------------------------------------------------------
BOOL WINAPI CTLCreateObjectContext (
                     IN LPCSTR pszObjectOid,
                     IN DWORD dwRetrievalFlags,
                     IN PCRYPT_BLOB_ARRAY pObject,
                     OUT LPVOID* ppvContext
                     )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_CTL,
                TRUE,                               // fQuerySingleContext
                ppvContext
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   CRLCreateObjectContext
//
//  Synopsis:   creates a CRL context from encoded CRL bits
//
//----------------------------------------------------------------------------
BOOL WINAPI CRLCreateObjectContext (
                     IN LPCSTR pszObjectOid,
                     IN DWORD dwRetrievalFlags,
                     IN PCRYPT_BLOB_ARRAY pObject,
                     OUT LPVOID* ppvContext
                     )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_CRL |
                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                TRUE,                               // fQuerySingleContext
                ppvContext
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   Pkcs7CreateObjectContext
//
//  Synopsis:   creates a certificate store context from a PKCS7 message
//
//----------------------------------------------------------------------------
BOOL WINAPI Pkcs7CreateObjectContext (
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 OUT LPVOID* ppvContext
                 )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                FALSE,                              // fQuerySingleContext
                ppvContext
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   Capi2CreateObjectContext
//
//  Synopsis:   create a store of CAPI objects
//
//----------------------------------------------------------------------------
BOOL WINAPI Capi2CreateObjectContext (
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 OUT LPVOID* ppvContext
                 )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_CERT |
                    CERT_QUERY_CONTENT_FLAG_CTL |
                    CERT_QUERY_CONTENT_FLAG_CRL |
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL |
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL |
                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                    CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
                FALSE,                              // fQuerySingleContext
                ppvContext
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\demand.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       demand.h
//
//  Contents:   On demand loading
//
//  History:    12-Dec-98    philh    Created
//              01-Jan-02    philh    Moved from wininet to winhttp
//
//----------------------------------------------------------------------------
#if !defined(__CRYPTNET_DEMAND_H__)
#define __CRYPTNET_DEMAND_H__


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\cua.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cua.h
//
//  Contents:   CCryptUrlArray class definition
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CUA_H__)
#define __CUA_H__

#include <windows.h>
#include <wincrypt.h>

//
// CCryptUrlArray.  This class manages a CRYPT_URL_ARRAY structure.  Note that
// the freeing of the internal array structure must be done explicitly
//

class CCryptUrlArray
{
public:

    //
    // Construction
    //

    CCryptUrlArray (ULONG cMinUrls, ULONG cGrowUrls, BOOL& rfResult);

    // NOTE: Only accepts native form URL arrays or read-only single buffer
    //       encoded arrays
    CCryptUrlArray (PCRYPT_URL_ARRAY pcua, ULONG cGrowUrls);

    ~CCryptUrlArray () {};

    //
    // URL management methods
    //

    static LPWSTR AllocUrl (ULONG cw);
    static LPWSTR ReallocUrl (LPWSTR pwszUrl, ULONG cw);
    static VOID FreeUrl (LPWSTR pwszUrl);

    BOOL AddUrl (LPWSTR pwszUrl, BOOL fCopyUrl);

    LPWSTR GetUrl (ULONG Index);

    //
    // Array management methods
    //

    DWORD GetUrlCount ();

    VOID GetArrayInNativeForm (PCRYPT_URL_ARRAY pcua);

    BOOL GetArrayInSingleBufferEncodedForm (
                 PCRYPT_URL_ARRAY* ppcua,
                 ULONG* pcb = NULL
                 );

    VOID FreeArray (BOOL fFreeUrls);

private:

    //
    // Internal URL array
    //

    CRYPT_URL_ARRAY m_cua;

    //
    // Current URL array size
    //

    ULONG           m_cArray;

    //
    // Grow URLs by
    //

    ULONG           m_cGrowUrls;

    //
    // Private methods
    //

    BOOL GrowArray ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\crobu.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crobu.cpp
//
//  Contents:   CryptRetrieveObjectByUrl
//
//  History:    23-Jul-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

#ifndef INTERNET_MAX_PATH_LENGTH
#define INTERNET_MAX_PATH_LENGTH        2048
#endif

// Initial commit size of the stack, in bytes. Estimate of 20K needed for
// wininet.
#define URL_WITH_TIMEOUT_THREAD_STACK_SIZE      0x5000

//
// CryptRetrieveObjectByUrl Entry
//
// Passed to the thread that does the real URL retrieval. The creator
// thread waits for either the URL retrieval to complete or a timeout.
//
typedef struct _CROBU_ENTRY CROBU_ENTRY, *PCROBU_ENTRY;
struct _CROBU_ENTRY {
    LPWSTR                      pwszUrl;
    LPCSTR                      pszObjectOid;
    DWORD                       dwRetrievalFlags;
    DWORD                       dwTimeout;
    LPVOID                      pvObject;

    CRYPT_RETRIEVE_AUX_INFO     AuxInfo;
    FILETIME                    LastSyncTime;

    BOOL                        fResult;
    DWORD                       dwErr;

    HMODULE                     hModule;
    HANDLE                      hWaitEvent;
    DWORD                       dwState;
    PCROBU_ENTRY                pNext;
    PCROBU_ENTRY                pPrev;
};

#define CROBU_RUN_STATE         1
#define CROBU_DONE_STATE        2
#define CROBU_PENDING_STATE     3

CRITICAL_SECTION            CrobuCriticalSection;
HMODULE                     hCrobuModule;

// Linked list of pending URL retrievals
PCROBU_ENTRY                pCrobuPendingHead;

VOID
WINAPI
InitializeCryptRetrieveObjectByUrl(
    HMODULE hModule
    )
{
    Pki_InitializeCriticalSection(&CrobuCriticalSection);
    hCrobuModule = hModule;
}

VOID
WINAPI
DeleteCryptRetrieveObjectByUrl()
{
    DeleteCriticalSection(&CrobuCriticalSection);
}


//
// Local Functions (Forward Reference)
// 

BOOL WINAPI IsPendingCryptRetrieveObjectByUrl (
                 IN LPCWSTR pwszUrl
                 );
BOOL WINAPI CryptRetrieveObjectByUrlWithTimeout (
                 IN LPCWSTR pwszUrl,
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN DWORD dwTimeout,
                 OUT LPVOID* ppvObject,
                 IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 );

void
DebugPrintUrlRetrievalError(
    IN LPCWSTR pwszUrl,
    IN DWORD dwTimeout,
    IN DWORD dwErr
    );


//+---------------------------------------------------------------------------
//
//  Function:   CryptRetrieveObjectByUrlA
//
//  Synopsis:   retrieve PKI object given an URL
//
//----------------------------------------------------------------------------
BOOL WINAPI CryptRetrieveObjectByUrlA (
                 IN LPCSTR pszUrl,
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN DWORD dwTimeout,
                 OUT LPVOID* ppvObject,
                 IN HCRYPTASYNC hAsyncRetrieve,
                 IN PCRYPT_CREDENTIALS pCredentials,
                 IN LPVOID pvVerify,
                 IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 )
{
    WCHAR pwszUrl[INTERNET_MAX_PATH_LENGTH+1];

    if ( !MultiByteToWideChar(
            CP_ACP,
            0,
            pszUrl,
            -1,
            pwszUrl,
            INTERNET_MAX_PATH_LENGTH+1
            ))
    {
        return( FALSE );
    }

    return( CryptRetrieveObjectByUrlW(
                 pwszUrl,
                 pszObjectOid,
                 dwRetrievalFlags,
                 dwTimeout,
                 ppvObject,
                 hAsyncRetrieve,
                 pCredentials,
                 pvVerify,
                 pAuxInfo
                 ) );

}


//+---------------------------------------------------------------------------
//
//  Function:   CryptRetrieveObjectByUrlW
//
//  Synopsis:   retrieve PKI object given an URL
//
//----------------------------------------------------------------------------
BOOL WINAPI CryptRetrieveObjectByUrlW (
                 IN LPCWSTR pwszUrl,
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN DWORD dwTimeout,
                 OUT LPVOID* ppvObject,
                 IN HCRYPTASYNC hAsyncRetrieve,
                 IN PCRYPT_CREDENTIALS pCredentials,
                 IN LPVOID pvVerify,
                 IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 )
{
    BOOL                     fResult;
    CObjectRetrievalManager* porm = NULL;

    // Remove any leading spaces
    while (L' ' == *pwszUrl)
        pwszUrl++;


    I_CryptNetDebugTracePrintfA(
        "CRYPTNET.DLL --> %s URL to retrieve: %S\n",
        0 != (dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL) ?
            "Cached" : "Wire", pwszUrl);

    // For a nonCache retrieval with timeout, do the retrieval in another
    // thread. wininet and winldap don't always honor the timeout value.
    //
    // Check for parameters not supported by doing in another thread.
    //
    // Also, check that a cancel callback hasn't been registered via
    // CryptInstallCancelRetrieval()
    if (0 != dwTimeout && !(dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL) &&
            0xFFFF >= (DWORD_PTR) pszObjectOid &&
            NULL == hAsyncRetrieve && NULL == pCredentials &&
            NULL == pvVerify &&
	        NULL == I_CryptGetTls(hCryptNetCancelTls) )
    {
        if (IsPendingCryptRetrieveObjectByUrl( pwszUrl ))
        {
            I_CryptNetDebugErrorPrintfA(
                "CRYPTNET.DLL --> CryptRetrieveObjectByUrl, already pending for : %S\n",
                pwszUrl);
            SetLastError( (DWORD) ERROR_BAD_NET_RESP );
            return( FALSE );
        }
        else
        {
            return CryptRetrieveObjectByUrlWithTimeout (
                 pwszUrl,
                 pszObjectOid,
                 dwRetrievalFlags,
                 dwTimeout,
                 ppvObject,
                 pAuxInfo
                 );
        }
    }
            
            

    porm = new CObjectRetrievalManager;
    if ( porm == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = porm->RetrieveObjectByUrl(
                            pwszUrl,
                            pszObjectOid,
                            dwRetrievalFlags,
                            dwTimeout,
                            ppvObject,
                            NULL,
                            NULL,
                            hAsyncRetrieve,
                            pCredentials,
                            pvVerify,
                            pAuxInfo
                            );

    porm->Release();

    if (!fResult)
    {
        DWORD dwLastErr = GetLastError();

        I_CryptNetDebugErrorPrintfA(
            "CRYPTNET.DLL --> %s URL to retrieve: %S, failed: %d (0x%x)\n",
            0 != (dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL) ?
                "Cached" : "Wire", pwszUrl, dwLastErr, dwLastErr);

        SetLastError(dwLastErr);
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptCancelAsyncRetrieval
//
//  Synopsis:   cancel asynchronous object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI CryptCancelAsyncRetrieval (HCRYPTASYNC hAsyncRetrieval)
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+===========================================================================
//
//  Functions supporting URL retrieval with timeout. The actual retrieval
//  is done in another, created thread.
//
//============================================================================


//+---------------------------------------------------------------------------
//  Returns TRUE if the previously initiated URL retrieval hasn't completed.
//----------------------------------------------------------------------------
BOOL WINAPI IsPendingCryptRetrieveObjectByUrl (
    IN LPCWSTR pwszUrl
    )
{
    BOOL fPending = FALSE;
    PCROBU_ENTRY pEntry;

    EnterCriticalSection(&CrobuCriticalSection);

    for (pEntry = pCrobuPendingHead; NULL != pEntry; pEntry = pEntry->pNext) {
        assert(CROBU_PENDING_STATE == pEntry->dwState);

        if (0 == wcscmp(pwszUrl, pEntry->pwszUrl)) {
            fPending = TRUE;
            break;
        }
    }

    LeaveCriticalSection(&CrobuCriticalSection);

    return fPending;
}

//+-------------------------------------------------------------------------
//  Duplicate the Dll library's handle
//--------------------------------------------------------------------------
static HMODULE DuplicateLibrary(
    IN HMODULE hDll
    )
{
    if (hDll) {
        WCHAR wszModule[_MAX_PATH + 1];
        if (0 == GetModuleFileNameU(hDll, wszModule, _MAX_PATH))
            goto GetModuleFileNameError;
        wszModule[_MAX_PATH] = L'\0';
        if (NULL == (hDll = LoadLibraryExU(wszModule, NULL, 0)))
            goto LoadLibraryError;
    }

CommonReturn:
    return hDll;
ErrorReturn:
    hDll = NULL;
    goto CommonReturn;
TRACE_ERROR(GetModuleFileNameError)
TRACE_ERROR(LoadLibraryError)
}

//+---------------------------------------------------------------------------
//  Thread procedure that does the actual URL retrieval.
//
//  Note, even if the creator thread times out, this thread will continue to
//  execute until the underlying URL retrieval returns.
//----------------------------------------------------------------------------
DWORD WINAPI CryptRetrieveObjectByUrlWithTimeoutThreadProc (
    LPVOID lpThreadParameter
    )
{
    PCROBU_ENTRY pEntry = (PCROBU_ENTRY) lpThreadParameter;
    CObjectRetrievalManager* porm = NULL;
    HMODULE hModule;

    // Do the actual URL retrieval using the parameters passed to this
    // thread by the creator thread.
    porm = new CObjectRetrievalManager;
    if (NULL == porm ) {
        pEntry->dwErr = (DWORD) E_OUTOFMEMORY;
        pEntry->fResult = FALSE;
    } else {
        pEntry->fResult = porm->RetrieveObjectByUrl(
                            pEntry->pwszUrl,
                            pEntry->pszObjectOid,
                            pEntry->dwRetrievalFlags,
                            pEntry->dwTimeout,
                            &pEntry->pvObject,
                            NULL,                   // ppfnFreeObject
                            NULL,                   // ppvFreeContext
                            NULL,                   // hAsyncRetrieve
                            NULL,                   // pCredentials
                            NULL,                   // pvVerify
                            &pEntry->AuxInfo
                            );
        pEntry->dwErr = GetLastError();
        porm->Release();
    }

    EnterCriticalSection(&CrobuCriticalSection);

    // The creator thread incremented cryptnet's ref count to prevent us
    // from being unloaded until this thread exits.
    hModule = pEntry->hModule;
    pEntry->hModule = NULL;

    if (CROBU_RUN_STATE == pEntry->dwState) {
        // The creator thread didn't timeout. Wake it up and set the
        // state to indicate we completed.

        assert(pEntry->hWaitEvent);
        SetEvent(pEntry->hWaitEvent);
        pEntry->dwState = CROBU_DONE_STATE;

        LeaveCriticalSection(&CrobuCriticalSection);

    } else {
        // The creator thread timed out. We were added to the pending
        // list when it timed out.

        LPVOID pv = pEntry->pvObject;
        LPCSTR pOID = pEntry->pszObjectOid;

        assert(CROBU_PENDING_STATE == pEntry->dwState);
        assert(NULL == pEntry->hWaitEvent);

        // Remove from pending list
        if (pEntry->pNext)
            pEntry->pNext->pPrev = pEntry->pPrev;

        if (pEntry->pPrev)
            pEntry->pPrev->pNext = pEntry->pNext;
        else {
            assert(pCrobuPendingHead == pEntry);
            pCrobuPendingHead = pEntry->pNext;
        }

        LeaveCriticalSection(&CrobuCriticalSection);

        I_CryptNetDebugErrorPrintfA(
            "CRYPTNET.DLL --> CryptRetrieveObjectByUrl, pending completed for : %S\n",
            pEntry->pwszUrl);

        if (pv) {
            // Free the returned object
            if (NULL == pOID)
                CryptMemFree( pv );
            else if (pEntry->dwRetrievalFlags &
                    CRYPT_RETRIEVE_MULTIPLE_OBJECTS)
                CertCloseStore((HCERTSTORE) pv, 0);
            else if (CONTEXT_OID_CERTIFICATE == pOID)
                CertFreeCertificateContext((PCCERT_CONTEXT) pv);
            else if (CONTEXT_OID_CTL == pOID)
                CertFreeCTLContext((PCCTL_CONTEXT) pv);
            else if (CONTEXT_OID_CRL == pOID)
                CertFreeCRLContext((PCCRL_CONTEXT) pv);
            else {
                assert(CONTEXT_OID_CAPI2_ANY == pOID ||
                    CONTEXT_OID_PKCS7 == pOID);
                if (CONTEXT_OID_CAPI2_ANY == pOID ||
                        CONTEXT_OID_PKCS7 == pOID)
                    CertCloseStore((HCERTSTORE) pv, 0);
             }
        }
        

        // Finally free the entry
        PkiFree(pEntry);
    }


    if (hModule)
        FreeLibraryAndExitThread(hModule, 0);
    else
        ExitThread(0);
}

//+---------------------------------------------------------------------------
//  Creates another thread to do the URL retrieval. Waits for either the
//  URL retrieval to complete or the timeout. For a timeout, the URL retrieval
//  entry is added to a pending list and the URL retrieval is allowed to
//  complete. However, for a timeout, this procedure returns.
//
//  This function guarantees the timeout value is honored.
//----------------------------------------------------------------------------
BOOL WINAPI CryptRetrieveObjectByUrlWithTimeout (
                 IN LPCWSTR pwszUrl,
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN DWORD dwTimeout,
                 OUT LPVOID* ppvObject,
                 IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 )
{
    BOOL fResult;
    DWORD dwErr = 0;
    PCROBU_ENTRY pEntry = NULL;
    HANDLE hThread = NULL;
    HANDLE hToken = NULL;
    DWORD dwThreadId;
    DWORD cchUrl;

    // Allocate and initialize the entry to be passed to the created
    // thread for doing the URL retrieval.

    cchUrl = wcslen(pwszUrl) + 1;

    pEntry = (PCROBU_ENTRY) PkiZeroAlloc(sizeof(CROBU_ENTRY) +
        cchUrl * sizeof(WCHAR));
    if (NULL == pEntry)
        goto OutOfMemory;

    pEntry->pwszUrl = (LPWSTR) &pEntry[1];
    memcpy(pEntry->pwszUrl, pwszUrl, cchUrl * sizeof(WCHAR));

    assert(0xFFFF >= (DWORD_PTR) pszObjectOid);
    pEntry->pszObjectOid = pszObjectOid;
    pEntry->dwRetrievalFlags = dwRetrievalFlags;
    pEntry->dwTimeout = dwTimeout;
    // pEntry->pvObject

    pEntry->AuxInfo.cbSize = sizeof(pEntry->AuxInfo);
    pEntry->AuxInfo.pLastSyncTime = &pEntry->LastSyncTime;

    if ( pAuxInfo &&
            offsetof(CRYPT_RETRIEVE_AUX_INFO, dwMaxUrlRetrievalByteCount) <
                        pAuxInfo->cbSize ) {
        pEntry->AuxInfo.dwMaxUrlRetrievalByteCount =
            pAuxInfo->dwMaxUrlRetrievalByteCount;
    }
    // else
    //  pEntry->AuxInfo = zero'ed via PkiZeroAlloc

    // pEntry->LastSyncTime
    // pEntry->fResult
    // pEntry->dwErr
    // pEntry->hModule
    // pEntry->hWaitEvent
    // pEntry->dwState
    // pEntry->pNext
    // pEntry->pPrev


    if (NULL == (pEntry->hWaitEvent =
            CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
        goto CreateWaitEventError;

    // Inhibit cryptnet.dll from being unloaded until the created thread
    // exits.
    pEntry->hModule = DuplicateLibrary(hCrobuModule);
    pEntry->dwState = CROBU_RUN_STATE;

    // Create the thread to do the Url retrieval
    if (NULL == (hThread = CreateThread(
            NULL,           // lpThreadAttributes
            URL_WITH_TIMEOUT_THREAD_STACK_SIZE,
            CryptRetrieveObjectByUrlWithTimeoutThreadProc,
            pEntry,
            CREATE_SUSPENDED,
            &dwThreadId
            )))
        goto CreateThreadError;

    // If we are impersonating, then, the created thread should also impersonate
    if (OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                TRUE,
                &hToken
                )) {
        // There isn't any security problem if the following fails.
        // If it fails will do the retrieval using the process's identity.
        if (!SetThreadToken(&hThread, hToken)) {
            DWORD dwLastErr = GetLastError();

            I_CryptNetDebugErrorPrintfA(
                "CRYPTNET.DLL --> SetThreadToken failed: %d (0x%x)\n",
                dwLastErr, dwLastErr);
        }
        CloseHandle(hToken);
        hToken = NULL;
    }

    ResumeThread(hThread);
    CloseHandle(hThread);
    hThread = NULL;


    // Wait for either the Url retrieval to complete or a timeout
    WaitForSingleObjectEx(
        pEntry->hWaitEvent,
        dwTimeout,
        FALSE                       // bAlertable
        );

    EnterCriticalSection(&CrobuCriticalSection);

    if (CROBU_DONE_STATE == pEntry->dwState) {
        // The URL retrieval completed in the created thread. Copy the
        // results from the entry block shared by this and the created
        // thread.

        fResult = pEntry->fResult;
        dwErr = pEntry->dwErr;

        *ppvObject = pEntry->pvObject;
        if ( pAuxInfo &&
                offsetof(CRYPT_RETRIEVE_AUX_INFO, pLastSyncTime) <
                            pAuxInfo->cbSize &&
                pAuxInfo->pLastSyncTime )
        {
            *pAuxInfo->pLastSyncTime = pEntry->LastSyncTime;
        }

        LeaveCriticalSection(&CrobuCriticalSection);
    } else {
        // The URL retrieval didn't complete in the created thread.
        // Add to the pending queue and return URL retrieval failure status.
        // Note, the created thread will be allowed to complete the initiated
        // retrieval.

        assert(CROBU_RUN_STATE == pEntry->dwState);

        CloseHandle(pEntry->hWaitEvent);
        pEntry->hWaitEvent = NULL;
        pEntry->dwState = CROBU_PENDING_STATE;

        // Add to the pending queue
        if (pCrobuPendingHead) {
            pCrobuPendingHead->pPrev = pEntry;
            pEntry->pNext = pCrobuPendingHead;
        }
        pCrobuPendingHead = pEntry;

        I_CryptNetDebugErrorPrintfA(
            "CRYPTNET.DLL --> CryptRetrieveObjectByUrl, %d timeout for : %S\n",
            pEntry->dwTimeout, pEntry->pwszUrl);

        pEntry = NULL;

        LeaveCriticalSection(&CrobuCriticalSection);
        goto RetrieveObjectByUrlTimeout;
    }

CommonReturn:
    if (!fResult)
        DebugPrintUrlRetrievalError(
            pwszUrl,
            dwTimeout,
            dwErr
            );

    if (pEntry) {
        if (pEntry->hWaitEvent)
            CloseHandle(pEntry->hWaitEvent);
        if (pEntry->hModule)
            FreeLibrary(pEntry->hModule);
        PkiFree(pEntry);
    }
    SetLastError(dwErr);
    return fResult;

ErrorReturn:
    dwErr = GetLastError();
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateWaitEventError)
TRACE_ERROR(CreateThreadError)
SET_ERROR(RetrieveObjectByUrlTimeout, ERROR_TIMEOUT)
}

DWORD
GetCryptNetDebugFlags()
{
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);

    DWORD dwLastErr = GetLastError();

    if (ERROR_SUCCESS != RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\crypt32",
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))
        goto ErrorReturn;

    if (ERROR_SUCCESS != RegQueryValueExA(
            hKey,
            "DebugFlags",
            NULL,               // pdwReserved
            &dwType,
            (BYTE *) &dwValue,
            &cbValue
            ))
        goto ErrorReturn;

    if (dwType != REG_DWORD || cbValue != sizeof(dwValue))
        goto ErrorReturn;

CommonReturn:
    if (NULL != hKey)
        RegCloseKey(hKey);

    SetLastError(dwLastErr);
    return dwValue;

ErrorReturn:
    dwValue = 0;
    goto CommonReturn;
}

BOOL
I_CryptNetIsDebugErrorPrintEnabled()
{
    return 0 != (GetCryptNetDebugFlags() & 0x1);
}

BOOL
I_CryptNetIsDebugTracePrintEnabled()
{
    static BOOL fIKnow = FALSE;
    static BOOL fIsDebugTracePrintEnabled = FALSE;

    if (!fIKnow) {
        fIsDebugTracePrintEnabled =
            (0 != (GetCryptNetDebugFlags() & 0x2));
        fIKnow = TRUE;
    }

    return fIsDebugTracePrintEnabled;
}


void
I_CryptNetDebugPrintfA(
    LPCSTR szFormat,
    ...
    )
{
    char szBuffer[1024];
    va_list arglist;

    DWORD dwLastErr = GetLastError();

    _try
    {
        va_start(arglist, szFormat);
        _vsnprintf(szBuffer, sizeof(szBuffer), szFormat, arglist);
        szBuffer[sizeof(szBuffer) - 1] = '\0';
        va_end(arglist);

        OutputDebugStringA(szBuffer);
    } _except( EXCEPTION_EXECUTE_HANDLER) {
    }

    SetLastError(dwLastErr);
}


void
I_CryptNetDebugErrorPrintfA(
    LPCSTR szFormat,
    ...
    )
{
    if (!I_CryptNetIsDebugErrorPrintEnabled())
        return;
    else {
        char szBuffer[1024];
        va_list arglist;

        DWORD dwLastErr = GetLastError();

        _try
        {
            va_start(arglist, szFormat);
            _vsnprintf(szBuffer, sizeof(szBuffer), szFormat, arglist);
            szBuffer[sizeof(szBuffer) - 1] = '\0';
            va_end(arglist);

            OutputDebugStringA(szBuffer);
        } _except( EXCEPTION_EXECUTE_HANDLER) {
        }

        SetLastError(dwLastErr);
    }
}

void
I_CryptNetDebugTracePrintfA(
    LPCSTR szFormat,
    ...
    )
{
    if (!I_CryptNetIsDebugTracePrintEnabled())
        return;
    else {
        char szBuffer[1024];
        va_list arglist;

        DWORD dwLastErr = GetLastError();

        _try
        {
            va_start(arglist, szFormat);
            _vsnprintf(szBuffer, sizeof(szBuffer), szFormat, arglist);
            szBuffer[sizeof(szBuffer) - 1] = '\0';
            va_end(arglist);

            OutputDebugStringA(szBuffer);
        } _except( EXCEPTION_EXECUTE_HANDLER) {
        }

        SetLastError(dwLastErr);
    }
}

void
DebugPrintUrlRetrievalError(
    IN LPCWSTR pwszUrl,
    IN DWORD dwTimeout,
    IN DWORD dwErr
    )
{
    I_CryptNetDebugErrorPrintfA("CRYPTNET.DLL --> Url retrieval timeout: %d  error: %d (0x%x) for::\n  %S\n",
         dwTimeout, dwErr, dwErr, pwszUrl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\filesp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       filesp.cpp
//
//  Contents:   File Scheme Provider
//
//  History:    08-Aug-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   FileRetrieveEncodedObject
//
//  Synopsis:   retrieve encoded object via Win32 File I/O
//
//----------------------------------------------------------------------------
BOOL WINAPI FileRetrieveEncodedObject (
                IN LPCWSTR pwszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                )
{
    BOOL              fResult;
    IObjectRetriever* por = NULL;

    if ( !( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        por = new CFileSynchronousRetriever;
    }

    if ( por == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = por->RetrieveObjectByUrl(
                           pwszUrl,
                           pszObjectOid,
                           dwRetrievalFlags,
                           dwTimeout,
                           (LPVOID *)pObject,
                           ppfnFreeObject,
                           ppvFreeContext,
                           hAsyncRetrieve,
                           pCredentials,
                           NULL,
                           pAuxInfo
                           );

    por->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileFreeEncodedObject
//
//  Synopsis:   free encoded object retrieved via FileRetrieveEncodedObject
//
//----------------------------------------------------------------------------
VOID WINAPI FileFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                )
{
    BOOL           fFreeBlobs = TRUE;
    PFILE_BINDINGS pfb = (PFILE_BINDINGS)pvFreeContext;

    //
    // If no file bindings were given in the context then this
    // must be a mapped file so we deal with it as such
    //

    if ( pfb != NULL )
    {
        fFreeBlobs = FALSE;
        FileFreeBindings( pfb );
    }

    FileFreeCryptBlobArray( pObject, fFreeBlobs );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileCancelAsyncRetrieval
//
//  Synopsis:   cancel asynchronous object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI FileCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                )
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::CFileSynchronousRetriever, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CFileSynchronousRetriever::CFileSynchronousRetriever ()
{
    m_cRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::~CFileSynchronousRetriever, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CFileSynchronousRetriever::~CFileSynchronousRetriever ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::AddRef, public
//
//  Synopsis:   IRefCountedObject::AddRef
//
//----------------------------------------------------------------------------
VOID
CFileSynchronousRetriever::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::Release, public
//
//  Synopsis:   IRefCountedObject::Release
//
//----------------------------------------------------------------------------
VOID
CFileSynchronousRetriever::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::RetrieveObjectByUrl, public
//
//  Synopsis:   IObjectRetriever::RetrieveObjectByUrl
//
//----------------------------------------------------------------------------
BOOL
CFileSynchronousRetriever::RetrieveObjectByUrl (
                                   LPCWSTR pwszUrl,
                                   LPCSTR pszObjectOid,
                                   DWORD dwRetrievalFlags,
                                   DWORD dwTimeout,
                                   LPVOID* ppvObject,
                                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                   LPVOID* ppvFreeContext,
                                   HCRYPTASYNC hAsyncRetrieve,
                                   PCRYPT_CREDENTIALS pCredentials,
                                   LPVOID pvVerify,
                                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                   )
{
    BOOL           fResult = FALSE;
    DWORD          LastError = 0;
    PFILE_BINDINGS pfb = NULL;
    LPVOID         pvFreeContext = NULL;
    BOOL           fIsUncUrl;

    assert( hAsyncRetrieve == NULL );

    fIsUncUrl = FileIsUncUrl( pwszUrl );

    if ( ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) &&
         ( fIsUncUrl == TRUE ) )
    {
        return( SchemeRetrieveCachedCryptBlobArray(
                      pwszUrl,
                      dwRetrievalFlags,
                      (PCRYPT_BLOB_ARRAY)ppvObject,
                      ppfnFreeObject,
                      ppvFreeContext,
                      pAuxInfo
                      ) );
    }

    fResult = FileGetBindings(
        pwszUrl,
        dwRetrievalFlags,
        pCredentials,
        &pfb,
        pAuxInfo
        );

    if ( fResult == TRUE )
    {
        if ( pfb->fMapped == FALSE )
        {
            fResult = FileSendReceiveUrlRequest(
                          pfb,
                          (PCRYPT_BLOB_ARRAY)ppvObject
                          );

            LastError = GetLastError();
            FileFreeBindings( pfb );
        }
        else
        {
            fResult = FileConvertMappedBindings(
                          pfb,
                          (PCRYPT_BLOB_ARRAY)ppvObject
                          );

            if ( fResult == TRUE )
            {
                pvFreeContext = (LPVOID)pfb;
            }
            else
            {
                LastError = GetLastError();
                FileFreeBindings( pfb );
            }
        }
    }

    if ( fResult == TRUE ) 
    {
        if ( !( dwRetrievalFlags & CRYPT_DONT_CACHE_RESULT ) &&
              ( fIsUncUrl == TRUE ) )
        {
            fResult = SchemeCacheCryptBlobArray(
                            pwszUrl,
                            dwRetrievalFlags,
                            (PCRYPT_BLOB_ARRAY)ppvObject,
                            pAuxInfo
                            );

            if ( fResult == FALSE )
            {
                FileFreeEncodedObject(
                    pszObjectOid,
                    (PCRYPT_BLOB_ARRAY)ppvObject,
                    pvFreeContext
                    );
            }
        }
        else
        {
            SchemeRetrieveUncachedAuxInfo( pAuxInfo );
        }
    }

    if ( fResult == TRUE )
    {

        *ppfnFreeObject = FileFreeEncodedObject;
        *ppvFreeContext = pvFreeContext;
    }

    if ( LastError != 0 )
    {
        SetLastError( LastError );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::CancelAsyncRetrieval, public
//
//  Synopsis:   IObjectRetriever::CancelAsyncRetrieval
//
//----------------------------------------------------------------------------
BOOL
CFileSynchronousRetriever::CancelAsyncRetrieval ()
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileGetBindings
//
//  Synopsis:   get the file bindings
//
//----------------------------------------------------------------------------
BOOL
FileGetBindings (
    LPCWSTR pwszUrl,
    DWORD dwRetrievalFlags,
    PCRYPT_CREDENTIALS pCredentials,
    PFILE_BINDINGS* ppfb,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    )
{
    DWORD          LastError;
    LPWSTR         pwszFile = (LPWSTR)pwszUrl;
    HANDLE         hFile;
    HANDLE         hFileMap;
    LPVOID         pvMap = NULL;
    DWORD          dwSize;
    PFILE_BINDINGS pfb;

    BOOL           fResult;
    WIN32_FILE_ATTRIBUTE_DATA FileAttr;
    DWORD          dwMaxUrlRetrievalByteCount = 0; // 0 => no max
    

    if (pAuxInfo &&
            offsetof(CRYPT_RETRIEVE_AUX_INFO, dwMaxUrlRetrievalByteCount) <
                        pAuxInfo->cbSize)
        dwMaxUrlRetrievalByteCount = pAuxInfo->dwMaxUrlRetrievalByteCount;

    if ( pCredentials != NULL )
    {
        SetLastError( (DWORD) E_NOTIMPL );
        return( FALSE );
    }

    if ( wcsstr( pwszUrl, FILE_SCHEME_PLUSPLUS ) != NULL )
    {
        pwszFile += wcslen( FILE_SCHEME_PLUSPLUS );
    }

    fResult = GetFileAttributesExW(
        pwszFile,
        GetFileExInfoStandard,
        &FileAttr
        );

    if (!fResult)
    {
        return(FALSE);
    }

    dwSize = FileAttr.nFileSizeLow;

    if ((FileAttr.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ||
            (0 != FileAttr.nFileSizeHigh) || (0 == dwSize)
                        ||
            ((0 != dwMaxUrlRetrievalByteCount)  &&
                (dwSize > dwMaxUrlRetrievalByteCount)))
    {
        I_CryptNetDebugErrorPrintfA(
            "CRYPTNET.DLL --> Invalid File(%S):: Attributes: 0x%x Size: %d\n",
            pwszFile, FileAttr.dwFileAttributes, FileAttr.nFileSizeLow);

        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }


    pfb = new FILE_BINDINGS;
    if ( pfb == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }


    hFile = CreateFileW(
                  pwszFile,
                  GENERIC_READ,
                  FILE_SHARE_READ,
                  NULL,
                  OPEN_EXISTING,
                  0,
                  NULL
                  );


    if ( hFile == INVALID_HANDLE_VALUE )
    {
        delete pfb;
        return( FALSE );
    }

    if ( dwSize <= FILE_MAPPING_THRESHOLD )
    {
        pfb->hFile = hFile;
        pfb->dwSize = dwSize;
        pfb->fMapped = FALSE;
        pfb->hFileMap = NULL;
        pfb->pvMap = NULL;

        *ppfb = pfb;

        return( TRUE );
    }

    hFileMap = CreateFileMappingA(
                     hFile,
                     NULL,
                     PAGE_READONLY,
                     0,
                     0,
                     NULL
                     );

    if ( hFileMap != NULL )
    {
        pvMap = MapViewOfFile( hFileMap, FILE_MAP_READ, 0, 0, 0 );
    }

    if ( pvMap != NULL )
    {
        pfb->hFile = hFile;
        pfb->dwSize = dwSize;
        pfb->fMapped = TRUE;
        pfb->hFileMap = hFileMap;
        pfb->pvMap = pvMap;

        *ppfb = pfb;

        return( TRUE );
    }

    LastError = GetLastError();

    if ( hFileMap != NULL )
    {
        CloseHandle( hFileMap );
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }

    delete pfb;

    SetLastError( LastError );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileFreeBindings
//
//  Synopsis:   free the file bindings
//
//----------------------------------------------------------------------------
VOID
FileFreeBindings (
    PFILE_BINDINGS pfb
    )
{
    if ( pfb->fMapped == TRUE )
    {
        UnmapViewOfFile( pfb->pvMap );
        CloseHandle( pfb->hFileMap );
    }

    CloseHandle( pfb->hFile );
    delete pfb;
}

//+---------------------------------------------------------------------------
//
//  Function:   FileSendReceiveUrlRequest
//
//  Synopsis:   synchronously process the request for the file bits using
//              Win32 File API.  Note that this only works for non-mapped
//              file bindings, for mapped file bindings use
//              FileConvertMappedBindings
//
//----------------------------------------------------------------------------
BOOL
FileSendReceiveUrlRequest (
    PFILE_BINDINGS pfb,
    PCRYPT_BLOB_ARRAY pcba
    )
{
    BOOL   fResult;
    LPBYTE pb;
    DWORD  dwRead;

    assert( pfb->fMapped == FALSE );

    pb = CCryptBlobArray::AllocBlob( pfb->dwSize );
    if ( pb == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = ReadFile( pfb->hFile, pb, pfb->dwSize, &dwRead, NULL );
    if ( fResult == TRUE )
    {
        CCryptBlobArray cba( 1, 1, fResult );

        if ( dwRead == pfb->dwSize )
        {
            fResult = cba.AddBlob( pfb->dwSize, pb, FALSE );
        }
        else
        {
            SetLastError( (DWORD) E_FAIL );
            fResult = FALSE;
        }

        if ( fResult == TRUE )
        {
            cba.GetArrayInNativeForm( pcba );
        }
        else
        {
            cba.FreeArray( FALSE );
        }
    }

    if ( fResult == FALSE )
    {
        CCryptBlobArray::FreeBlob( pb );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileConvertMappedBindings
//
//  Synopsis:   convert mapped bindings to a CRYPT_BLOB_ARRAY
//
//----------------------------------------------------------------------------
BOOL
FileConvertMappedBindings (
    PFILE_BINDINGS pfb,
    PCRYPT_BLOB_ARRAY pcba
    )
{
    BOOL fResult;

    assert( pfb->fMapped == TRUE );

    CCryptBlobArray cba( 1, 1, fResult );

    if ( fResult == TRUE )
    {
        fResult = cba.AddBlob( pfb->dwSize, (LPBYTE)pfb->pvMap, FALSE );
    }

    if ( fResult == TRUE )
    {
        cba.GetArrayInNativeForm( pcba );
    }
    else
    {
        cba.FreeArray( FALSE );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileFreeCryptBlobArray
//
//  Synopsis:   free the CRYPT_BLOB_ARRAY
//
//----------------------------------------------------------------------------
VOID
FileFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba,
    BOOL fFreeBlobs
    )
{
    CCryptBlobArray cba( pcba, 0 );

    cba.FreeArray( fFreeBlobs );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileIsUncUrl
//
//  Synopsis:   is this a UNC path URL?
//
//----------------------------------------------------------------------------
BOOL
FileIsUncUrl (
    LPCWSTR pwszUrl
    )
{
    DWORD cch = 0;

    if ( wcsstr( pwszUrl, FILE_SCHEME_PLUSPLUS ) != NULL )
    {
        cch += wcslen( FILE_SCHEME_PLUSPLUS );
    }

    if ( ( pwszUrl[ cch ] == L'\\' ) && ( pwszUrl[ cch + 1 ] == L'\\' ) )
    {
        return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\cua.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cua.cpp
//
//  Contents:   CCryptUrlArray implementation
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::CCryptUrlArray, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCryptUrlArray::CCryptUrlArray (ULONG cMinUrls, ULONG cGrowUrls, BOOL& rfResult)
{
    rfResult = TRUE;
    m_cGrowUrls = cGrowUrls;
    m_cua.cUrl = 0;
    m_cua.rgwszUrl = new LPWSTR [cMinUrls];
    if ( m_cua.rgwszUrl != NULL )
    {
        memset( m_cua.rgwszUrl, 0, sizeof(LPWSTR)*cMinUrls );
        m_cArray = cMinUrls;
    }
    else
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::CCryptUrlArray, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCryptUrlArray::CCryptUrlArray (PCRYPT_URL_ARRAY pcua, ULONG cGrowUrls)
{
    m_cGrowUrls = cGrowUrls;
    m_cua.cUrl = pcua->cUrl;
    m_cua.rgwszUrl = pcua->rgwszUrl;
    m_cArray = pcua->cUrl;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::AllocUrl, public, static
//
//  Synopsis:   allocate an URL using the same allocator used for ::AddUrl
//              copies.  This means that the resulting URL can be added
//              without copying.
//
//----------------------------------------------------------------------------
LPWSTR
CCryptUrlArray::AllocUrl (ULONG cw)
{
    return( (LPWSTR)CryptMemAlloc( cw * sizeof( WCHAR ) ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::ReallocUrl, public, static
//
//  Synopsis:   see ::AllocUrl
//
//----------------------------------------------------------------------------
LPWSTR
CCryptUrlArray::ReallocUrl (LPWSTR pwszUrl, ULONG cw)
{
    return( (LPWSTR)CryptMemRealloc( pwszUrl, cw * sizeof( WCHAR ) ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::FreeUrl, public, static
//
//  Synopsis:   free URL allocated using ::AllocBlob or ::ReallocBlob
//
//----------------------------------------------------------------------------
VOID
CCryptUrlArray::FreeUrl (LPWSTR pwszUrl)
{
    CryptMemFree( pwszUrl );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::AddUrl, public
//
//  Synopsis:   add an URL to the array
//
//----------------------------------------------------------------------------
BOOL
CCryptUrlArray::AddUrl (LPWSTR pwszUrl, BOOL fCopyUrl)
{
    BOOL   fResult = TRUE;
    LPWSTR pwszToUse;

    //
    // If we need to copy the URL, do so
    //

    if ( fCopyUrl == TRUE )
    {
        ULONG cw = wcslen( pwszUrl ) + 1;

        pwszToUse = AllocUrl( cw );
        if ( pwszToUse != NULL )
        {
            memcpy( pwszToUse, pwszUrl, cw * sizeof( WCHAR ) );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }
    }
    else
    {
        pwszToUse = pwszUrl;
    }

    //
    // If we need to grow the array, do so
    //

    if ( m_cArray == m_cua.cUrl )
    {
        fResult = GrowArray();
    }

    //
    // Add the URL to the array
    //

    if ( fResult == TRUE )
    {
        m_cua.rgwszUrl[m_cua.cUrl] = pwszToUse;
        m_cua.cUrl += 1;
    }
    else if ( fCopyUrl == TRUE )
    {
        FreeUrl( pwszToUse );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GetUrl, public
//
//  Synopsis:   get an URL from the array
//
//----------------------------------------------------------------------------
LPWSTR
CCryptUrlArray::GetUrl (ULONG Index)
{
    assert( m_cua.cUrl > Index );

    return( m_cua.rgwszUrl[Index] );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GetUrlCount, public
//
//  Synopsis:   get the count of URLs in the array
//
//----------------------------------------------------------------------------
ULONG
CCryptUrlArray::GetUrlCount ()
{
    return( m_cua.cUrl );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GetArrayInNativeForm, public
//
//  Synopsis:   get the array in native form
//
//----------------------------------------------------------------------------
VOID
CCryptUrlArray::GetArrayInNativeForm (PCRYPT_URL_ARRAY pcua)
{
    pcua->cUrl = m_cua.cUrl;
    pcua->rgwszUrl = m_cua.rgwszUrl;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GetArrayInSingleBufferEncodedForm, public
//
//  Synopsis:   get the array encoded in a single buffer
//
//----------------------------------------------------------------------------
BOOL
CCryptUrlArray::GetArrayInSingleBufferEncodedForm (
                        PCRYPT_URL_ARRAY* ppcua,
                        ULONG* pcb
                        )
{
    ULONG            cbStruct;
    ULONG            cbPointers;
    ULONG            cbData;
    ULONG            cb;
    ULONG            cbSize;
    ULONG            cCount;
    PCRYPT_URL_ARRAY pcua = NULL;
    ULONG            cbUrl;

    //
    // Calculate the buffer size we will need and allocate it
    //

    cbStruct = sizeof( CRYPT_URL_ARRAY );
    cbPointers = m_cua.cUrl * sizeof( LPWSTR );

    for ( cCount = 0, cbData = 0; cCount < m_cua.cUrl; cCount++ )
    {
        cbData += ( wcslen( m_cua.rgwszUrl[cCount] ) + 1 ) * sizeof( WCHAR );
    }

    cbSize = cbStruct + cbPointers + cbData;

    if ( ppcua == NULL )
    {
        if ( pcb != NULL )
        {
            *pcb = cbSize;
            return( TRUE );
        }

        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( *ppcua == NULL )
    {
        pcua = (PCRYPT_URL_ARRAY)CryptMemAlloc( cbSize );
        if ( pcua == NULL )
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }
    }
    else
    {
        if ( pcb == NULL )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return( FALSE );
        }
        else if ( *pcb < cbSize )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return( FALSE );
        }

        pcua = *ppcua;
    }

    //
    // Fill in the data
    //

    pcua->cUrl = m_cua.cUrl;
    pcua->rgwszUrl = (LPWSTR *)((LPBYTE)pcua+cbStruct);

    for ( cCount = 0, cb = 0; cCount < m_cua.cUrl; cCount++ )
    {
        pcua->rgwszUrl[cCount] = (LPWSTR)((LPBYTE)pcua+cbStruct+cbPointers+cb);

        cbUrl = ( wcslen( m_cua.rgwszUrl[cCount] ) + 1 ) * sizeof( WCHAR );

        memcpy( pcua->rgwszUrl[cCount], m_cua.rgwszUrl[cCount], cbUrl );

        cb += cbUrl;
    }

    if ( *ppcua != pcua )
    {
        *ppcua = pcua;

        if ( pcb != NULL )
        {
            *pcb = cbSize;
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::FreeArray, public
//
//  Synopsis:   free the URL array
//
//----------------------------------------------------------------------------
VOID
CCryptUrlArray::FreeArray (BOOL fFreeUrls)
{
    if ( fFreeUrls == TRUE )
    {
        ULONG cCount;

        for ( cCount = 0; cCount < m_cua.cUrl; cCount++ )
        {
            FreeUrl( m_cua.rgwszUrl[cCount] );
        }
    }

    delete m_cua.rgwszUrl;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GrowArray, private
//
//  Synopsis:   grow the URL array
//
//----------------------------------------------------------------------------
BOOL
CCryptUrlArray::GrowArray ()
{
    ULONG   cNewArray;
    LPWSTR* rgwsz;

    //
    // Check if we are allowed to grow
    //
    //

    if ( m_cGrowUrls == 0 )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    //
    // Allocate and initialize the new array
    //

    cNewArray = m_cArray + m_cGrowUrls;
    rgwsz = new LPWSTR [cNewArray];
    if ( rgwsz == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    memset( rgwsz, 0, cNewArray * sizeof( LPWSTR ) );

    //
    // Copy the old to the new
    //

    memcpy( rgwsz, m_cua.rgwszUrl, m_cua.cUrl*sizeof( LPWSTR ) );

    //
    // Free the old and use the new
    //

    delete m_cua.rgwszUrl;
    m_cua.rgwszUrl = rgwsz;
    m_cArray = cNewArray;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\demand.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       demand.cpp
//
//  Contents:   On demand loading
//
//  History:    12-Dec-98    philh    Created
//              01-Jan-02    philh    Moved from wininet to winhttp
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <winwlx.h>
#include <sensapi.h>


//+---------------------------------------------------------------------------
//
//  Function:   DemandLoadDllMain
//
//  Synopsis:   DLL Main like initialization of on demand loading
//
//----------------------------------------------------------------------------
BOOL WINAPI DemandLoadDllMain (
                HMODULE hModule,
                ULONG ulReason,
                LPVOID pvReserved
                )
{
    BOOL fRet = TRUE;

    switch ( ulReason )
    {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    }

    return( fRet );
}



//+---------------------------------------------------------------------------
//
//  Function:   CryptnetWlxLogoffEvent
//
//  Synopsis:   logoff event processing
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptnetWlxLogoffEvent (PWLX_NOTIFICATION_INFO pNotificationInfo)
{

    return TRUE;
}

BOOL
WINAPI
I_CryptNetIsConnected()
{
    DWORD dwFlags;
    BOOL fIsConnected;

    fIsConnected = IsNetworkAlive(&dwFlags);

    if (!fIsConnected) {
        DWORD dwLastError = GetLastError();

        I_CryptNetDebugErrorPrintfA(
            "CRYPTNET.DLL --> NOT CONNECTED : Error %d (0x%x)\n",
            dwLastError, dwLastError);
    }

    return fIsConnected;
}

//
// Cracks the Url and returns the host name component.
//
BOOL
WINAPI
I_CryptNetGetHostNameFromUrl (
        IN LPWSTR pwszUrl,
        IN DWORD cchHostName,
        OUT LPWSTR pwszHostName
        )
{
    BOOL fResult = TRUE;
    HRESULT hr;
    DWORD cchOut = cchHostName - 1;

    *pwszHostName = L'\0';

    // Remove any leading spaces
    while (L' ' == *pwszUrl)
        pwszUrl++;

    hr = UrlGetPartW(
        pwszUrl,
        pwszHostName,
        &cchOut,
        URL_PART_HOSTNAME,
        0                   // dwFlags
        );

    if (S_OK != hr)
    {
        SetLastError( (DWORD) hr );
        fResult = FALSE;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\filesp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       filesp.h
//
//  Contents:   File Scheme Provider definitions
//
//  History:    08-Aug-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#if !defined(__FILESP_H__)
#define __FILESP_H__

#include <orm.h>
#include <winhttp.h>

//
// File scheme provider entry points
//

#define FILE_SCHEME          "file"

#define FILE_SCHEME_PLUSPLUS L"file://"

BOOL WINAPI FileRetrieveEncodedObject (
                IN LPCWSTR pwszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                );

VOID WINAPI FileFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                );

BOOL WINAPI FileCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                );

//
// File Synchronous Object Retriever
//

class CFileSynchronousRetriever : public IObjectRetriever
{
public:

    //
    // Construction
    //

    CFileSynchronousRetriever ();
    ~CFileSynchronousRetriever ();

    //
    // IRefCountedObject methods
    //

    virtual VOID AddRef ();
    virtual VOID Release ();

    //
    // IObjectRetriever methods
    //

    virtual BOOL RetrieveObjectByUrl (
                         LPCWSTR pwszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         );

    virtual BOOL CancelAsyncRetrieval ();

private:

    //
    // Reference count
    //

    ULONG m_cRefs;
};

//
// File Scheme Provider support API
//

#define FILE_MAPPING_THRESHOLD 20*4096

typedef struct _FILE_BINDINGS {

    HANDLE hFile;
    DWORD  dwSize;
    BOOL   fMapped;
    HANDLE hFileMap;
    LPVOID pvMap;

} FILE_BINDINGS, *PFILE_BINDINGS;

BOOL
FileGetBindings (
    LPCWSTR pwszUrl,
    DWORD dwRetrievalFlags,
    PCRYPT_CREDENTIALS pCredentials,
    PFILE_BINDINGS* ppfb,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    );

VOID
FileFreeBindings (
    PFILE_BINDINGS pfb
    );

BOOL
FileSendReceiveUrlRequest (
    PFILE_BINDINGS pfb,
    PCRYPT_BLOB_ARRAY pcba
    );

BOOL
FileConvertMappedBindings (
    PFILE_BINDINGS pfb,
    PCRYPT_BLOB_ARRAY pcba
    );

VOID
FileFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba,
    BOOL fFreeBlobs
    );

BOOL
FileIsUncUrl (
    LPCWSTR pwszUrl
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\inetsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       inetsp.h
//
//  Contents:   Inet (HTTP, HTTPS) scheme provider definitions
//
//  History:    05-Aug-97    kirtd    Created
//              01-Jan-02    philh    Moved from wininet to winhttp
//
//----------------------------------------------------------------------------
#if !defined(__INETSP_H__)
#define __INETSP_H__

#include <orm.h>
#include <winhttp.h>

//
// Inet scheme provider entry points
//

#define HTTP_SCHEME   "http"

extern HCRYPTTLS hCryptNetCancelTls;

typedef struct _CRYPTNET_CANCEL_BLOCK {
    PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel; 
    void *pvArg;
} CRYPTNET_CANCEL_BLOCK, *PCRYPTNET_CANCEL_BLOCK;



BOOL WINAPI InetRetrieveEncodedObject (
                IN LPCWSTR pwszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                );

VOID WINAPI InetFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                );

BOOL WINAPI InetCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                );

//
// Inet Synchronous Object Retriever
//

class CInetSynchronousRetriever : public IObjectRetriever
{
public:

    //
    // Construction
    //

    CInetSynchronousRetriever ();
    ~CInetSynchronousRetriever ();

    //
    // IRefCountedObject methods
    //

    virtual VOID AddRef ();
    virtual VOID Release ();

    //
    // IObjectRetriever methods
    //

    virtual BOOL RetrieveObjectByUrl (
                         LPCWSTR pwszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         );

    virtual BOOL CancelAsyncRetrieval ();

private:

    //
    // Reference count
    //

    ULONG m_cRefs;
};

//
// Inet Scheme Provider Support API
//

#define INET_INITIAL_DATA_BUFFER_SIZE 4096
#define INET_GROW_DATA_BUFFER_SIZE    4096

BOOL
InetGetBindings (
    LPCWSTR pwszUrl,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,
    HINTERNET* phInetSession
    );

VOID
InetFreeBindings (
    HINTERNET hInetSession
    );

BOOL
InetSendReceiveUrlRequest (
    HINTERNET hInetSession,
    LPCWSTR pwszUrl,
    DWORD dwRetrievalFlags,
    PCRYPT_CREDENTIALS pCredentials,
    PCRYPT_BLOB_ARRAY pcba,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    );

VOID
InetFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba
    );

VOID WINAPI
InetAsyncStatusCallback (
    HINTERNET hInet,
    DWORD dwContext,
    DWORD dwInternetStatus,
    LPVOID pvStatusInfo,
    DWORD dwStatusLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\ldapsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ldapsp.cpp
//
//  Contents:   LDAP Scheme Provider for Remote Object Retrieval
//
//  History:    23-Jul-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#include <global.hxx>

#ifndef INTERNET_MAX_PATH_LENGTH
#define INTERNET_MAX_PATH_LENGTH        2048
#endif


//+---------------------------------------------------------------------------
//
//  Function:   LdapRetrieveEncodedObject
//
//  Synopsis:   retrieve encoded object via LDAP protocol
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapRetrieveEncodedObject (
                IN LPCWSTR pwszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                )
{
    BOOL              fResult;
    IObjectRetriever* por = NULL;

    if ( !( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        por = new CLdapSynchronousRetriever;
    }

    if ( por == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = por->RetrieveObjectByUrl(
                           pwszUrl,
                           pszObjectOid,
                           dwRetrievalFlags,
                           dwTimeout,
                           (LPVOID *)pObject,
                           ppfnFreeObject,
                           ppvFreeContext,
                           hAsyncRetrieve,
                           pCredentials,
                           NULL,
                           pAuxInfo
                           );

    por->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeEncodedObject
//
//  Synopsis:   free encoded object retrieved via LdapRetrieveEncodedObject
//
//----------------------------------------------------------------------------
VOID WINAPI LdapFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                )
{
    assert( pvFreeContext == NULL );

    LdapFreeCryptBlobArray( pObject );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapCancelAsyncRetrieval
//
//  Synopsis:   cancel asynchronous object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                )
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::CLdapSynchronousRetriever, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLdapSynchronousRetriever::CLdapSynchronousRetriever ()
{
    m_cRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::~CLdapSynchronousRetriever, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLdapSynchronousRetriever::~CLdapSynchronousRetriever ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::AddRef, public
//
//  Synopsis:   IRefCountedObject::AddRef
//
//----------------------------------------------------------------------------
VOID
CLdapSynchronousRetriever::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::Release, public
//
//  Synopsis:   IRefCountedObject::Release
//
//----------------------------------------------------------------------------
VOID
CLdapSynchronousRetriever::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::RetrieveObjectByUrl, public
//
//  Synopsis:   IObjectRetriever::RetrieveObjectByUrl
//
//----------------------------------------------------------------------------
BOOL
CLdapSynchronousRetriever::RetrieveObjectByUrl (
                                   LPCWSTR pwszUrl,
                                   LPCSTR pszObjectOid,
                                   DWORD dwRetrievalFlags,
                                   DWORD dwTimeout,
                                   LPVOID* ppvObject,
                                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                   LPVOID* ppvFreeContext,
                                   HCRYPTASYNC hAsyncRetrieve,
                                   PCRYPT_CREDENTIALS pCredentials,
                                   LPVOID pvVerify,
                                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                   )
{
    BOOL                fResult;
    DWORD               LastError = 0;
    LDAP_URL_COMPONENTS LdapUrlComponents;
    LDAP*               pld = NULL;
    BOOL                fLdapUrlCracked = FALSE;

    assert( hAsyncRetrieve == NULL );

    if ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL )
    {
        return( SchemeRetrieveCachedCryptBlobArray(
                      pwszUrl,
                      dwRetrievalFlags,
                      (PCRYPT_BLOB_ARRAY)ppvObject,
                      ppfnFreeObject,
                      ppvFreeContext,
                      pAuxInfo
                      ) );
    }

    fResult = LdapCrackUrl( pwszUrl, &LdapUrlComponents );

#if DBG

    if ( fResult == TRUE )
    {
        LdapDisplayUrlComponents( &LdapUrlComponents );
    }

#endif

    if ( fResult == TRUE )
    {
        fLdapUrlCracked = TRUE;

        if ( dwRetrievalFlags & CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL )
        {
            if ( LdapUrlComponents.Scope != LDAP_SCOPE_BASE )
            {
                fResult = FALSE;
                SetLastError( (DWORD) E_INVALIDARG );
            }
        }
    }

    if ( fResult == TRUE )
    {
        DWORD iAuth;

        if ( dwRetrievalFlags &
                (CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL |
                    CRYPT_LDAP_SIGN_RETRIEVAL) )
        {
            // Only attempt AUTH_SSPI binds
            iAuth = 1;
        }
        else
        {
            // First attempt AUTH_SIMPLE bind. If that fails or returns
            // nothing, then, attempt AUTH_SSPI bind.
            iAuth = 0;
        }

        for ( ; iAuth < 2; iAuth++)
        {
            fResult = LdapGetBindings(
                LdapUrlComponents.pwszHost,
                LdapUrlComponents.Port,
                dwRetrievalFlags,
                0 == iAuth ? LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG :
                             LDAP_BIND_AUTH_SSPI_ENABLE_FLAG,
                dwTimeout,
                pCredentials,
                &pld
                );

            if ( fResult == TRUE )
            {
                fResult = LdapSendReceiveUrlRequest(
                    pld,
                    &LdapUrlComponents,
                    dwRetrievalFlags,
                    dwTimeout,
                    (PCRYPT_BLOB_ARRAY)ppvObject,
                    pAuxInfo
                    );

                if ( fResult == TRUE )
                {
                    break;
                }
                else
                {
                    LastError = GetLastError();
                    LdapFreeBindings( pld );
                    pld = NULL;
                    SetLastError( LastError );
                }
            }
        }
    }

    if ( fResult == TRUE )
    {
        if ( !( dwRetrievalFlags & CRYPT_DONT_CACHE_RESULT ) )
        {
            fResult = SchemeCacheCryptBlobArray(
                            pwszUrl,
                            dwRetrievalFlags,
                            (PCRYPT_BLOB_ARRAY)ppvObject,
                            pAuxInfo
                            );

            if ( fResult == FALSE )
            {
                LdapFreeEncodedObject(
                    pszObjectOid,
                    (PCRYPT_BLOB_ARRAY)ppvObject,
                    NULL
                    );
            }
        }
        else
        {
            SchemeRetrieveUncachedAuxInfo( pAuxInfo );
        }
    }

    if ( fResult == TRUE )
    {
        *ppfnFreeObject = LdapFreeEncodedObject;
        *ppvFreeContext = NULL;
    }
    else
    {
        LastError = GetLastError();
    }

    if ( fLdapUrlCracked == TRUE )
    {
        LdapFreeUrlComponents( &LdapUrlComponents );
    }

    LdapFreeBindings( pld );

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::CancelAsyncRetrieval, public
//
//  Synopsis:   IObjectRetriever::CancelAsyncRetrieval
//
//----------------------------------------------------------------------------
BOOL
CLdapSynchronousRetriever::CancelAsyncRetrieval ()
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapCrackUrl
//
//  Synopsis:   Crack an LDAP URL into its relevant parts.  The result must
//              be freed using LdapFreeUrlComponents
//
//----------------------------------------------------------------------------
BOOL
LdapCrackUrl (
    LPCWSTR pwszUrl,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    BOOL   fResult = TRUE;
    LPWSTR pwszHostInfo = NULL;
    LPWSTR pwszDN = NULL;
    LPWSTR pwszAttrList = NULL;
    LPWSTR pwszScope = NULL;
    LPWSTR pwszFilter = NULL;
    LPWSTR pwszToken = NULL;
    WCHAR  pwsz[INTERNET_MAX_PATH_LENGTH+1];
    ULONG  cchUrl = INTERNET_MAX_PATH_LENGTH;

    //
    // Capture the URL and initialize the out parameter
    //

    __try
    {
        HRESULT hr;


#if 0
        // UrlCanonicalizeW() moves stuff after the # character to
        // the end of Url.
        hr = UrlCanonicalizeW(
                pwszUrl,
                pwsz,
                &cchUrl,
                URL_UNESCAPE  | URL_WININET_COMPATIBILITY
                );
#else
        // UrlUnescapeW() handles the # character properly
        hr = UrlUnescapeW(
                (LPWSTR) pwszUrl,
                pwsz,
                &cchUrl,
                0
                );

#endif

        if (S_OK != hr)
        {
            SetLastError( (DWORD) hr );
            return( FALSE );
        }

        if ( pwsz[0] == L'\0' )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return( FALSE );
        }

        pwsz[sizeof(pwsz)/sizeof(pwsz[0]) - 1] = L'\0';
            
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        return( FALSE );
    }

    memset( pLdapUrlComponents, 0, sizeof( LDAP_URL_COMPONENTS ) );

    //
    // Find the host
    //

    pwszHostInfo = pwsz + wcslen( L"ldap://" );
    if ( *pwszHostInfo == L'/' )
    {
        pwszToken = pwszHostInfo + 1;
        pwszHostInfo = NULL;
    }
    else
    {
#if 0
        pwszHostInfo = wcstok( pszHostInfo, "/" );
#else
        pwszToken = pwszHostInfo;
        while ( ( *pwszToken != L'\0' ) && ( *pwszToken != L'/' ) )
            pwszToken++;

        if ( *pwszToken == L'/' )
        {
            *pwszToken = L'\0';
            pwszToken += 1;
        }

        while ( *pwszToken == L'/' )
            pwszToken++;
#endif

    }

    //
    // Find the DN
    //

    if ( pwszToken != NULL )
    {
        pwszDN = L"";

        if ( *pwszToken != L'\0' )
        {
            if ( *pwszToken == L'?' )
            {
                pwszToken += 1;
            }
            else
            {
                pwszDN = pwszToken;

                do
                {
                    pwszToken += 1;
                }
                while ( ( *pwszToken != L'\0' ) && ( *pwszToken != L'?' ) );

                if ( *pwszToken == L'?' )
                {
                    *pwszToken = L'\0';
                    pwszToken += 1;
                }
            }
        }
    }
    else
    {
        pwszDN = wcstok( pwszToken, L"?" );
        pwszToken = NULL;
        if ( pwszDN == NULL )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return( FALSE );
        }
    }

    //
    // Check for attributes
    //

    if ( pwszToken != NULL )
    {
        if ( *pwszToken == L'?' )
        {
            pwszAttrList = L"";
            pwszToken += 1;
        }
        else if ( *pwszToken == L'\0' )
        {
            pwszAttrList = NULL;
        }
        else
        {
            pwszAttrList = wcstok( pwszToken, L"?" );
            pwszToken = NULL;
        }
    }
    else
    {
        pwszAttrList = wcstok( NULL, L"?" );
    }

    //
    // Check for a scope and filter
    //

    if ( pwszAttrList != NULL )
    {
        pwszScope = wcstok( pwszToken, L"?" );
        if ( pwszScope != NULL )
        {
            pwszFilter = wcstok( NULL, L"?" );
        }
    }

    if ( pwszScope == NULL )
    {
        pwszScope = L"base";
    }

    if ( pwszFilter == NULL )
    {
        pwszFilter = L"(objectClass=*)";
    }

    //
    // Now we build up our URL components
    //

    fResult = LdapParseCrackedHost( pwszHostInfo, pLdapUrlComponents );

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedDN( pwszDN, pLdapUrlComponents );
    }

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedAttributeList(
                      pwszAttrList,
                      pLdapUrlComponents
                      );
    }

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedScopeAndFilter(
                      pwszScope,
                      pwszFilter,
                      pLdapUrlComponents
                      );
    }

    if ( fResult != TRUE )
    {
        LdapFreeUrlComponents( pLdapUrlComponents );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedHost
//
//  Synopsis:   Parse the cracked host string (pszHost is modified)
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedHost (
    LPWSTR pwszHost,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    LPWSTR pwszPort;

    if ( pwszHost != NULL )
    {
        pwszHost = wcstok( pwszHost, L" " );
    }

    if ( pwszHost == NULL )
    {
        pLdapUrlComponents->pwszHost = NULL;
        pLdapUrlComponents->Port = LDAP_PORT;
        return( TRUE );
    }

    // See if multiple host names are present
    if ( NULL != wcstok( NULL, L" " ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }


    pwszPort = wcschr( pwszHost, L':' );
    if ( pwszPort != NULL )
    {
        *pwszPort = L'\0';
        pwszPort++;
    }

    pLdapUrlComponents->pwszHost = new WCHAR [wcslen( pwszHost ) + 1];
    if ( pLdapUrlComponents->pwszHost == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszHost, pwszHost );
    pLdapUrlComponents->Port = 0;

    if ( pwszPort != NULL )
    {
        pLdapUrlComponents->Port = _wtol( pwszPort );
    }

    if ( pLdapUrlComponents->Port == 0 )
    {
        pLdapUrlComponents->Port = LDAP_PORT;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedDN
//
//  Synopsis:   Parse the cracked DN
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedDN (
    LPWSTR pwszDN,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    pLdapUrlComponents->pwszDN = new WCHAR [wcslen( pwszDN ) + 1];
    if ( pLdapUrlComponents->pwszDN == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszDN, pwszDN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedAttributeList
//
//  Synopsis:   Parse the cracked attribute list
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedAttributeList (
    LPWSTR pwszAttrList,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    LPWSTR pwsz;
    LPWSTR pwszAttr;
    ULONG cAttr = 0;
    ULONG cCount;

    if ( ( pwszAttrList == NULL ) || ( wcslen( pwszAttrList ) == 0 ) )
    {
        pLdapUrlComponents->cAttr = 0;
        pLdapUrlComponents->apwszAttr = NULL;
        return( TRUE );
    }

    pwsz = new WCHAR [wcslen( pwszAttrList ) + 1];
    if ( pwsz == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pwsz, pwszAttrList );

    pwszAttr = wcstok( pwsz, L"," );
    while ( pwszAttr != NULL )
    {
        cAttr += 1;
        pwszAttr = wcstok( NULL, L"," );
    }

    pLdapUrlComponents->apwszAttr = new LPWSTR [cAttr+1];
    if ( pLdapUrlComponents->apwszAttr == NULL )
    {
        delete [] pwsz;
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    pLdapUrlComponents->cAttr = cAttr;
    for ( cCount = 0; cCount < cAttr; cCount++ )
    {
        pLdapUrlComponents->apwszAttr[cCount] = pwsz;
        pwsz += ( wcslen(pwsz) + 1 );
    }

    pLdapUrlComponents->apwszAttr[cAttr] = NULL;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedScopeAndFilter
//
//  Synopsis:   Parse the cracked scope and filter
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedScopeAndFilter (
    LPWSTR pwszScope,
    LPWSTR pwszFilter,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    ULONG Scope;

    if ( _wcsicmp( pwszScope, L"base" ) == 0 )
    {
        Scope = LDAP_SCOPE_BASE;
    }
    else if ( _wcsicmp( pwszScope, L"one" ) == 0 )
    {
        Scope = LDAP_SCOPE_ONELEVEL;
    }
    else if ( _wcsicmp( pwszScope, L"sub" ) == 0 )
    {
        Scope = LDAP_SCOPE_SUBTREE;
    }
    else
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    pLdapUrlComponents->pwszFilter = new WCHAR [wcslen( pwszFilter ) + 1];
    if ( pLdapUrlComponents->pwszFilter == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszFilter, pwszFilter );
    pLdapUrlComponents->Scope = Scope;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeUrlComponents
//
//  Synopsis:   Frees allocate URL components returned from LdapCrackUrl
//
//----------------------------------------------------------------------------
VOID
LdapFreeUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    delete [] pLdapUrlComponents->pwszHost;
    delete [] pLdapUrlComponents->pwszDN;

    if ( pLdapUrlComponents->apwszAttr != NULL )
    {
        delete pLdapUrlComponents->apwszAttr[0];
    }

    delete [] pLdapUrlComponents->apwszAttr;
    delete [] pLdapUrlComponents->pwszFilter;
}


//+---------------------------------------------------------------------------
//
//  Function:   LdapGetBindings
//
//  Synopsis:   allocates and initializes the LDAP session binding
//
//----------------------------------------------------------------------------
BOOL
LdapGetBindings (
    LPWSTR pwszHost,
    ULONG Port,
    DWORD dwRetrievalFlags,
    DWORD dwBindFlags,
    DWORD dwTimeout,                    // milliseconds
    PCRYPT_CREDENTIALS pCredentials,
    LDAP** ppld
    )
{
    BOOL                        fResult = TRUE;
    DWORD                       LastError = 0;
    CRYPT_PASSWORD_CREDENTIALSW PasswordCredentials;
    LDAP*                       pld = NULL;
    BOOL                        fFreeCredentials = FALSE;

    memset( &PasswordCredentials, 0, sizeof( PasswordCredentials ) );
    PasswordCredentials.cbSize = sizeof( PasswordCredentials );

    if ( SchemeGetPasswordCredentialsW(
               pCredentials,
               &PasswordCredentials,
               &fFreeCredentials
               ) == FALSE )
    {
        return( FALSE );
    }

    pld = ldap_initW( pwszHost, Port );
    if ( pld != NULL )
    {
        SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;
        ULONG                     ldaperr;
        struct l_timeval          tv;
        struct l_timeval          *ptv = NULL;

        if ((dwRetrievalFlags & CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL) &&
                (NULL != pwszHost))
        {
            void                      *pvOn;
            pvOn = LDAP_OPT_ON;
            ldap_set_option(
                pld,
                LDAP_OPT_AREC_EXCLUSIVE,
                &pvOn
                );
        }

        // Note, dwTimeout is in units of milliseconds.
        // LDAP_OPT_TIMELIMIT is in units of seconds.
        if ( 0 != dwTimeout )
        {
            DWORD dwTimeoutSeconds = dwTimeout / 1000;

            if ( LDAP_MIN_TIMEOUT_SECONDS > dwTimeoutSeconds )
            {
                dwTimeoutSeconds = LDAP_MIN_TIMEOUT_SECONDS;
            }

            tv.tv_sec = dwTimeoutSeconds;
            tv.tv_usec = 0;
            ptv = &tv;

            ldap_set_option( pld, LDAP_OPT_TIMELIMIT,
                (void *)&dwTimeoutSeconds );
        }

        ldaperr = ldap_connect( pld, ptv );

        if ( ( ldaperr != LDAP_SUCCESS ) && ( pwszHost == NULL ) )
        {
            DWORD dwFlags = DS_FORCE_REDISCOVERY;
            ULONG ldapsaveerr = ldaperr;

            ldaperr = ldap_set_option(
                           pld,
                           LDAP_OPT_GETDSNAME_FLAGS,
                           (LPVOID)&dwFlags
                           );

            if ( ldaperr == LDAP_SUCCESS )
            {
                ldaperr = ldap_connect( pld, ptv );

            }
            else
            {
                ldaperr = ldapsaveerr;
            }
        }

        if ( ldaperr != LDAP_SUCCESS )
        {
            fResult = FALSE;
            SetLastError( I_CryptNetLdapMapErrorToWin32( pld, ldaperr ) );
        }

        if ( fResult == TRUE )
        {
            fResult = SchemeGetAuthIdentityFromPasswordCredentialsW(
                  &PasswordCredentials,
                  &AuthIdentity
                  );

            if ( fResult == TRUE )
            {

#if 0
                printf(
                   "Credentials = %S\\%S <%S>\n",
                   AuthIdentity.Domain,
                   AuthIdentity.User,
                   AuthIdentity.Password
                   );
#endif

                fResult = LdapSSPIOrSimpleBind(
                          pld,
                          &AuthIdentity,
                          dwRetrievalFlags,
                          dwBindFlags
                          );

                // following doesn't globber LastError
                SchemeFreeAuthIdentityFromPasswordCredentialsW(
                    &PasswordCredentials,
                    &AuthIdentity
                    );
            }
        }
    }
    else
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *ppld = pld;
    }
    else
    {
        LastError = GetLastError();
        LdapFreeBindings( pld );
    }

    if ( fFreeCredentials == TRUE )
    {
        SchemeFreePasswordCredentialsW( &PasswordCredentials );
    }

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeBindings
//
//  Synopsis:   frees allocated LDAP session binding
//
//----------------------------------------------------------------------------
VOID
LdapFreeBindings (
    LDAP* pld
    )
{
    if ( pld != NULL )
    {
        ldap_unbind_s( pld );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapSendReceiveUrlRequest
//
//  Synopsis:   sends an URL based search request to the LDAP server, receives
//              the result message and converts it to a CRYPT_BLOB_ARRAY of
//              encoded object bits
//
//----------------------------------------------------------------------------
BOOL
LdapSendReceiveUrlRequest (
    LDAP* pld,
    PLDAP_URL_COMPONENTS pLdapUrlComponents,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,        // milliseconds
    PCRYPT_BLOB_ARRAY pcba,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    )
{
    BOOL         fResult;
    DWORD        LastError = 0;
    ULONG        lderr;
    LDAPMessage* plm = NULL;

    if ( 0 != dwTimeout )
    {
        DWORD dwTimeoutSeconds = dwTimeout / 1000;
        struct l_timeval tv;

        if ( LDAP_MIN_TIMEOUT_SECONDS > dwTimeoutSeconds )
        {
            dwTimeoutSeconds = LDAP_MIN_TIMEOUT_SECONDS;
        }

        tv.tv_sec = dwTimeoutSeconds;
        tv.tv_usec = 0;

        lderr = ldap_search_stW(
                 pld,
                 pLdapUrlComponents->pwszDN,
                 pLdapUrlComponents->Scope,
                 pLdapUrlComponents->pwszFilter,
                 pLdapUrlComponents->apwszAttr,
                 FALSE,
                 &tv,
                 &plm
                 );
    }
    else
    {
        lderr = ldap_search_sW(
                 pld,
                 pLdapUrlComponents->pwszDN,
                 pLdapUrlComponents->Scope,
                 pLdapUrlComponents->pwszFilter,
                 pLdapUrlComponents->apwszAttr,
                 FALSE,
                 &plm
                 );
    }

    if ( lderr != LDAP_SUCCESS )
    {
        if ( plm != NULL )
        {
            ldap_msgfree( plm );
        }

        SetLastError( I_CryptNetLdapMapErrorToWin32( pld, lderr ) );
        return( FALSE );
    }

    fResult = LdapConvertLdapResultMessage( pld, plm, dwRetrievalFlags, pcba, pAuxInfo);
    if ( !fResult )
    {
        LastError = GetLastError();
    }
    ldap_msgfree( plm );

    SetLastError( LastError );
    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   LdapConvertResultMessage
//
//  Synopsis:   convert returned LDAP message to a crypt blob array
//
//----------------------------------------------------------------------------
BOOL
LdapConvertLdapResultMessage (
    LDAP* pld,
    PLDAPMessage plm,
    DWORD dwRetrievalFlags,
    PCRYPT_BLOB_ARRAY pcba,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    )
{
    BOOL            fResult = TRUE;
    PLDAPMessage    plmElem;
    BerElement*     pber;
    CHAR*           pszAttr;
    struct berval** apbv;
    ULONG           cCount;
    CCryptBlobArray cba( 10, 5, fResult );
    DWORD           dwIndex;
    ULONG           cbIndex = 0;
    char            szIndex[33];

    ULONG           cbTotalVal = 0;
    DWORD           dwMaxUrlRetrievalByteCount = 0; // 0 => no max

    if (pAuxInfo &&
            offsetof(CRYPT_RETRIEVE_AUX_INFO, dwMaxUrlRetrievalByteCount) <
                        pAuxInfo->cbSize)
        dwMaxUrlRetrievalByteCount = pAuxInfo->dwMaxUrlRetrievalByteCount;

    for ( plmElem = ldap_first_entry( pld, plm ), dwIndex = 0;
          ( plmElem != NULL ) && ( fResult == TRUE );
          plmElem = ldap_next_entry( pld, plmElem ), dwIndex++ )
    {
        if ( dwRetrievalFlags & CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE )
        {
            _ltoa(dwIndex, szIndex, 10);
            cbIndex = strlen(szIndex) + 1;
        }

        for ( pszAttr = ldap_first_attributeA( pld, plmElem, &pber );
              ( pszAttr != NULL ) && ( fResult == TRUE );
              pszAttr = ldap_next_attributeA( pld, plmElem, pber ) )
        {
            apbv = ldap_get_values_lenA( pld, plmElem, pszAttr );
            if ( apbv == NULL )
            {
                fResult = FALSE;
            }

            for ( cCount = 0;
                  ( fResult == TRUE ) && ( apbv[cCount] != NULL );
                  cCount++ )
            {
                ULONG cbAttr = 0;
                ULONG cbVal;
                ULONG cbToAdd;
                LPBYTE pbToAdd;

                cbToAdd = cbVal = apbv[cCount]->bv_len;

                cbTotalVal += cbVal;
                if ((0 != dwMaxUrlRetrievalByteCount)  &&
                        (cbTotalVal > dwMaxUrlRetrievalByteCount))
                {
                    I_CryptNetDebugErrorPrintfA(
                        "CRYPTNET.DLL --> Exceeded MaxUrlRetrievalByteCount for: Ldap Url\n");

                    SetLastError(ERROR_INVALID_DATA);
                    fResult = FALSE;
                    continue;
                }

                if ( dwRetrievalFlags & CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE )
                {
                    cbAttr = strlen(pszAttr) + 1;
                    cbToAdd += cbIndex + cbAttr;
                }

                pbToAdd = cba.AllocBlob( cbToAdd );
                if ( pbToAdd != NULL )
                {
                    LPBYTE pb;

                    pb = pbToAdd;
                    if ( dwRetrievalFlags & CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE )
                    {
                        memcpy( pb, szIndex, cbIndex );
                        pb += cbIndex;
                        memcpy( pb, pszAttr, cbAttr );
                        pb += cbAttr;
                    }
                    memcpy( pb, (LPBYTE)apbv[cCount]->bv_val, cbVal );
                }
                else
                {
                    SetLastError( (DWORD) E_OUTOFMEMORY );
                    fResult = FALSE;
                }

                if ( fResult == TRUE )
                {
                    fResult = cba.AddBlob(
                                     cbToAdd,
                                     pbToAdd,
                                     FALSE
                                     );
                    if ( fResult == FALSE )
                    {
                        cba.FreeBlob( pbToAdd );
                    }
                }
            }

            ldap_value_free_len( apbv );
        }
    }

    if ( fResult == TRUE )
    {
        if ( cba.GetBlobCount() > 0 )
        {
            cba.GetArrayInNativeForm( pcba );
        }
        else
        {
            cba.FreeArray( TRUE );
            SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
            fResult = FALSE;
        }
    }
    else
    {
        cba.FreeArray( TRUE );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeCryptBlobArray
//
//  Synopsis:   free CRYPT_BLOB_ARRAY allocated in LdapConvertLdapResultMessage
//
//----------------------------------------------------------------------------
VOID
LdapFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba
    )
{
    CCryptBlobArray cba( pcba, 0 );

    cba.FreeArray( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapHasWriteAccess
//
//  Synopsis:   check if the caller has write access to the given LDAP URL
//              query components
//
//----------------------------------------------------------------------------
BOOL
LdapHasWriteAccess (
    LDAP* pld,
    PLDAP_URL_COMPONENTS pLdapUrlComponents,
    DWORD dwTimeout
    )
{
    BOOL                fResult = FALSE;
    LPWSTR              pwszAttr = L"allowedAttributesEffective";
    LPWSTR              apwszAttr[2] = {pwszAttr, NULL};
    LDAP_URL_COMPONENTS LdapUrlComponents;
    CRYPT_BLOB_ARRAY    cba;
    ULONG               cCount;
    ULONG               cchAttr;
    LPSTR               pszUrlAttr = NULL;

    if ( ( pLdapUrlComponents->cAttr != 1 ) ||
         ( pLdapUrlComponents->Scope != LDAP_SCOPE_BASE ) )
    {
        return( FALSE );
    }

    memset( &LdapUrlComponents, 0, sizeof( LdapUrlComponents ) );

    LdapUrlComponents.pwszHost = pLdapUrlComponents->pwszHost;
    LdapUrlComponents.Port = pLdapUrlComponents->Port;
    LdapUrlComponents.pwszDN = pLdapUrlComponents->pwszDN;

    LdapUrlComponents.cAttr = 1;
    LdapUrlComponents.apwszAttr = apwszAttr;

    LdapUrlComponents.Scope = LDAP_SCOPE_BASE;
    LdapUrlComponents.pwszFilter = L"(objectClass=*)";

    if ( LdapSendReceiveUrlRequest( pld, &LdapUrlComponents, 0, dwTimeout, &cba, NULL ) == FALSE )
    {
        return( FALSE );
    }

    cchAttr = wcslen( pLdapUrlComponents->apwszAttr[ 0 ] );
    pszUrlAttr = new CHAR [cchAttr + 1];
    if ( pszUrlAttr == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( WideCharToMultiByte(
             CP_ACP,
             0,
             pLdapUrlComponents->apwszAttr[ 0 ],
             -1,
             pszUrlAttr,
             cchAttr + 1,
             NULL,
             NULL
             ) == FALSE )
    {
        delete [] pszUrlAttr;
        return( FALSE );
    }

    for ( cCount = 0; cCount < cba.cBlob; cCount++ )
    {
        if ( cba.rgBlob[ cCount ].cbData != cchAttr )
        {
            continue;
        }

        if ( _strnicmp(
                 pszUrlAttr,
                 (LPSTR)cba.rgBlob[ cCount ].pbData,
                 cchAttr
                 ) == 0 )
        {
            fResult = TRUE;
            break;
        }
    }

    LdapFreeCryptBlobArray( &cba );

    delete [] pszUrlAttr;

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapSSPIOrSimpleBind
//
//  Synopsis:   do a SSPI and/or simple bind
//
//----------------------------------------------------------------------------
BOOL
LdapSSPIOrSimpleBind (
    LDAP* pld,
    SEC_WINNT_AUTH_IDENTITY_W* pAuthIdentity,
    DWORD dwRetrievalFlags,
    DWORD dwBindFlags
    )
{
    BOOL  fResult = TRUE;
    ULONG ldaperr;
	ULONG uVersion= LDAP_VERSION3;

    // Per bug 25497, do V3 negotiate instead of the default V2.
    ldap_set_option(pld, LDAP_OPT_VERSION, &uVersion);

    if (dwRetrievalFlags & CRYPT_LDAP_SIGN_RETRIEVAL)
    {
        void *pvOn;
        pvOn = LDAP_OPT_ON;

        ldaperr = ldap_set_option(
                       pld,
                       LDAP_OPT_SIGN,
                       &pvOn
                       );
        if ( ldaperr != LDAP_SUCCESS )
        {
            SetLastError( I_CryptNetLdapMapErrorToWin32( pld, ldaperr ) );
            return FALSE;
        }
    }

    ldaperr = LDAP_AUTH_METHOD_NOT_SUPPORTED;

    if (dwBindFlags & LDAP_BIND_AUTH_SSPI_ENABLE_FLAG)
    {

        ldaperr = ldap_bind_sW(
                       pld,
                       NULL,
                       (PWCHAR)pAuthIdentity,
                       LDAP_AUTH_SSPI
                       );
    }

    if (dwBindFlags & LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG)
    {
        // Per Anoop's 4/25/00 email:
        //  You should fall back to anonymous bind only if the server returns
        //  LDAP_AUTH_METHOD_NOT_SUPPORTED.
        //
        // Per sergiod/trevorf 4/25/01 also need to check for invalid creds
        // because target server could be in a different forest.

        if ( ldaperr == LDAP_AUTH_METHOD_NOT_SUPPORTED ||
             ldaperr == LDAP_INVALID_CREDENTIALS )

        {
            ldaperr = ldap_bind_sW(
                           pld,
                           NULL,
                           NULL,
                           LDAP_AUTH_SIMPLE
                           );

            if ( ldaperr != LDAP_SUCCESS )
            {
                uVersion = LDAP_VERSION2;

                if ( LDAP_SUCCESS == ldap_set_option(pld,
                                            LDAP_OPT_VERSION,
                                            &uVersion) )
                {
                    ldaperr = ldap_bind_sW(
                                   pld,
                                   NULL,
                                   NULL,
                                   LDAP_AUTH_SIMPLE
                                   );
                }
            }
        }
    }

    if ( ldaperr != LDAP_SUCCESS )
    {
        fResult = FALSE;

        if ( ldaperr != LDAP_LOCAL_ERROR )
        {
            SetLastError( I_CryptNetLdapMapErrorToWin32( pld, ldaperr ) );
        }
        // else per Anoop's 4/25/00 email:
        //  For LDAP_LOCAL_ERROR, its an underlying security error where
        //  LastError has already been updated with a more meaningful error
        //  value.
    }

    return( fResult );
}

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   LdapDisplayUrlComponents
//
//  Synopsis:   display the URL components
//
//----------------------------------------------------------------------------
VOID
LdapDisplayUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    ULONG cCount;

    printf( "pLdapUrlComponents->pwszHost = %S\n",
        pLdapUrlComponents->pwszHost );
    printf( "pLdapUrlComponents->Port = %d\n", pLdapUrlComponents->Port );
    printf( "pLdapUrlComponents->pwszDN = %S\n", pLdapUrlComponents->pwszDN );
    printf( "pLdapUrlComponents->cAttr = %d\n", pLdapUrlComponents->cAttr );

    for ( cCount = 0; cCount < pLdapUrlComponents->cAttr; cCount++ )
    {
        printf(
           "pLdapUrlComponents->apwszAttr[%d] = %S\n",
           cCount,
           pLdapUrlComponents->apwszAttr[cCount]
           );
    }

    printf( "pLdapUrlComponents->Scope = %d\n", pLdapUrlComponents->Scope );
    printf( "pLdapUrlComponents->pwszFilter = %S\n",
        pLdapUrlComponents->pwszFilter );
}
#endif



DWORD g_dwLdapServerExtError;
CHAR g_rgszLdapServerError[128];


ULONG
I_CryptNetLdapMapErrorToWin32(
    LDAP* pld,
    ULONG LdapError
    )
{
    if (NULL != pld) {
        CHAR *pszError = NULL;
        DWORD dwError = ERROR_SUCCESS;
        ULONG ldaperr;

        ldaperr = ldap_get_option(pld, LDAP_OPT_SERVER_ERROR, &pszError);

        if (LDAP_SUCCESS == ldaperr && NULL != pszError) {
            DWORD cchBuf = sizeof(g_rgszLdapServerError) /
                    sizeof(g_rgszLdapServerError[0]);
            strncpy(g_rgszLdapServerError, pszError, cchBuf - 1);
            g_rgszLdapServerError[cchBuf - 1] = '\0';
        }

        ldaperr = ldap_get_option(pld, LDAP_OPT_SERVER_EXT_ERROR, &dwError);
        if (LDAP_SUCCESS == ldaperr)
            g_dwLdapServerExtError = dwError;

        I_CryptNetDebugErrorPrintfA("CRYPTNET.DLL --> LdapError: 0x%x <%s>\n",
            LdapError, pszError);

        if (NULL != pszError)
            ldap_memfreeA(pszError);
    }

    return LdapMapErrorToWin32(LdapError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\init.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       init.cpp
//
//  Contents:   Initialization for Remote Object Retrieval
//
//  History:    23-Jul-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#include <global.hxx>

//
// Remote Object Retrieval Function Set definitions
//

HCRYPTOIDFUNCSET hSchemeRetrieveFuncSet;
HCRYPTOIDFUNCSET hContextCreateFuncSet;
HCRYPTOIDFUNCSET hGetObjectUrlFuncSet;
HCRYPTOIDFUNCSET hGetTimeValidObjectFuncSet;
HCRYPTOIDFUNCSET hFlushTimeValidObjectFuncSet;

static const CRYPT_OID_FUNC_ENTRY SchemeRetrieveFuncTable[] = {
    LDAP_SCHEME, LdapRetrieveEncodedObject,
    HTTP_SCHEME, InetRetrieveEncodedObject,
    FILE_SCHEME, FileRetrieveEncodedObject
};

static const CRYPT_OID_FUNC_ENTRY ContextCreateFuncTable[] = {
    CONTEXT_OID_CERTIFICATE, CertificateCreateObjectContext,
    CONTEXT_OID_CTL, CTLCreateObjectContext,
    CONTEXT_OID_CRL, CRLCreateObjectContext,
    CONTEXT_OID_PKCS7, Pkcs7CreateObjectContext,
    CONTEXT_OID_CAPI2_ANY, Capi2CreateObjectContext
};

static const CRYPT_OID_FUNC_ENTRY GetObjectUrlFuncTable[] = {
    URL_OID_CERTIFICATE_ISSUER, CertificateIssuerGetObjectUrl,
    URL_OID_CERTIFICATE_CRL_DIST_POINT, CertificateCrlDistPointGetObjectUrl,
    URL_OID_CTL_ISSUER, CtlIssuerGetObjectUrl,
    URL_OID_CTL_NEXT_UPDATE, CtlNextUpdateGetObjectUrl,
    URL_OID_CRL_ISSUER, CrlIssuerGetObjectUrl,
    URL_OID_CERTIFICATE_FRESHEST_CRL, CertificateFreshestCrlGetObjectUrl,
    URL_OID_CRL_FRESHEST_CRL, CrlFreshestCrlGetObjectUrl,
    URL_OID_CROSS_CERT_DIST_POINT, CertificateCrossCertDistPointGetObjectUrl
};

static const CRYPT_OID_FUNC_ENTRY GetTimeValidObjectFuncTable[] = {
    TIME_VALID_OID_GET_CTL, CtlGetTimeValidObject,
    TIME_VALID_OID_GET_CRL, CrlGetTimeValidObject,
    TIME_VALID_OID_GET_CRL_FROM_CERT, CrlFromCertGetTimeValidObject,
    TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT, FreshestCrlFromCertGetTimeValidObject,
    TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL, FreshestCrlFromCrlGetTimeValidObject
};

static const CRYPT_OID_FUNC_ENTRY FlushTimeValidObjectFuncTable[] = {
    TIME_VALID_OID_FLUSH_CTL, CtlFlushTimeValidObject,
    TIME_VALID_OID_FLUSH_CRL, CrlFlushTimeValidObject,
    TIME_VALID_OID_FLUSH_CRL_FROM_CERT, CrlFromCertFlushTimeValidObject,
    TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT, FreshestCrlFromCertFlushTimeValidObject,
    TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL, FreshestCrlFromCrlFlushTimeValidObject
};

#define SCHEME_RETRIEVE_FUNC_COUNT (sizeof(SchemeRetrieveFuncTable)/ \
                                    sizeof(SchemeRetrieveFuncTable[0]))

#define CONTEXT_CREATE_FUNC_COUNT (sizeof(ContextCreateFuncTable)/ \
                                   sizeof(ContextCreateFuncTable[0]))

#define GET_OBJECT_URL_FUNC_COUNT (sizeof(GetObjectUrlFuncTable)/ \
                                   sizeof(GetObjectUrlFuncTable[0]))

#define GET_TIME_VALID_OBJECT_FUNC_COUNT (sizeof(GetTimeValidObjectFuncTable)/ \
                                          sizeof(GetTimeValidObjectFuncTable[0]))

#define FLUSH_TIME_VALID_OBJECT_FUNC_COUNT (sizeof(FlushTimeValidObjectFuncTable)/ \
                                            sizeof(FlushTimeValidObjectFuncTable[0]))

HCRYPTTLS hCryptNetCancelTls;

CTVOAgent* g_pProcessTVOAgent = NULL;

CRITICAL_SECTION MSCtlDefaultStoresCriticalSection;
extern void MSCtlCloseDefaultStores ();


static
VOID
WINAPI
CancelRetrievalFree(
    IN LPVOID pv
    )
{
    if (pv) 
        free(pv);
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptInstallCancelRetrieval
//
//  Synopsis:   Install the call back function to cancel object retrieval
//				by HTTP, HTTPS, GOPHER, and FTP protocols.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CryptInstallCancelRetrieval(
    IN PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, 
    IN const void *pvArg,
    IN DWORD dwFlags,
    IN void *pvReserved
)
{
	PCRYPTNET_CANCEL_BLOCK	pCancelBlock=NULL;

	if(NULL == pfnCancel)
	{
		SetLastError((DWORD) E_INVALIDARG);
		return FALSE;
	}

	pCancelBlock = (PCRYPTNET_CANCEL_BLOCK)malloc(sizeof(CRYPTNET_CANCEL_BLOCK));

	if(NULL == pCancelBlock)
	{
		SetLastError((DWORD) E_OUTOFMEMORY);
		return FALSE;
	}

	pCancelBlock->pfnCancel=pfnCancel;
	pCancelBlock->pvArg=(void *)pvArg;
	
	//uninstall the previous one
	if(!CryptUninstallCancelRetrieval(0, NULL))
	{
		free(pCancelBlock);
		return FALSE;
	}

	if(!I_CryptSetTls(hCryptNetCancelTls, pCancelBlock))
	{
		free(pCancelBlock);
		return FALSE;
	}

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CryptUninstallCancelRetrieval
//
//  Synopsis:   Uninstall the call back function to cancel object retrieval
//				by HTTP, HTTPS, GOPHER, and FTP protocols.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CryptUninstallCancelRetrieval(
	IN DWORD dwFlags,
	IN void  *pvReserved
	)
{
	PCRYPTNET_CANCEL_BLOCK	pCancelBlock=NULL;
	
	//we just free the memory if there is one
	pCancelBlock = (PCRYPTNET_CANCEL_BLOCK)I_CryptGetTls(hCryptNetCancelTls);

	if(pCancelBlock)
	{
		free(pCancelBlock);
		I_CryptSetTls(hCryptNetCancelTls, NULL);
	}

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   RPORDllMain
//
//  Synopsis:   DLL Main like initialization of Remote PKI object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI RPORDllMain (
                HMODULE hModule,
                ULONG ulReason,
                LPVOID pvReserved
                )
{
    switch ( ulReason )
    {
    case DLL_PROCESS_ATTACH:

        hSchemeRetrieveFuncSet = CryptInitOIDFunctionSet(
                                      SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC,
                                      0
                                      );

        hContextCreateFuncSet = CryptInitOIDFunctionSet(
                                     CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC,
                                     0
                                     );

        hGetObjectUrlFuncSet = CryptInitOIDFunctionSet(
                                    URL_OID_GET_OBJECT_URL_FUNC,
                                    0
                                    );

        hGetTimeValidObjectFuncSet = CryptInitOIDFunctionSet(
                                          TIME_VALID_OID_GET_OBJECT_FUNC,
                                          0
                                          );

        hFlushTimeValidObjectFuncSet = CryptInitOIDFunctionSet(
                                            TIME_VALID_OID_FLUSH_OBJECT_FUNC,
                                            0
                                            );

        if ( ( hSchemeRetrieveFuncSet == NULL ) ||
             ( hContextCreateFuncSet == NULL ) ||
             ( hGetObjectUrlFuncSet == NULL ) ||
             ( hGetTimeValidObjectFuncSet == NULL ) ||
             ( hFlushTimeValidObjectFuncSet == NULL ) )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC,
                  SCHEME_RETRIEVE_FUNC_COUNT,
                  SchemeRetrieveFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC,
                  CONTEXT_CREATE_FUNC_COUNT,
                  ContextCreateFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  URL_OID_GET_OBJECT_URL_FUNC,
                  GET_OBJECT_URL_FUNC_COUNT,
                  GetObjectUrlFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  TIME_VALID_OID_GET_OBJECT_FUNC,
                  GET_TIME_VALID_OBJECT_FUNC_COUNT,
                  GetTimeValidObjectFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  TIME_VALID_OID_FLUSH_OBJECT_FUNC,
                  FLUSH_TIME_VALID_OBJECT_FUNC_COUNT,
                  FlushTimeValidObjectFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

		hCryptNetCancelTls = I_CryptAllocTls();

		if (hCryptNetCancelTls == NULL )
			return( FALSE );

        InitializeOfflineUrlCache();

        InitializeCryptRetrieveObjectByUrl(hModule);

        if ( CreateProcessTVOAgent( &g_pProcessTVOAgent ) == FALSE )
        {
            return( FALSE );
        }

        if ( !Pki_InitializeCriticalSection(
                &MSCtlDefaultStoresCriticalSection ) )
        {
            return( FALSE );
        }
        
        return( TRUE );
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
		I_CryptFreeTls( hCryptNetCancelTls, CancelRetrievalFree );
        delete g_pProcessTVOAgent;

        DeleteCryptRetrieveObjectByUrl();

        DeleteOfflineUrlCache();

        MSCtlCloseDefaultStores();
        DeleteCriticalSection( &MSCtlDefaultStoresCriticalSection );
        break;

    case DLL_THREAD_DETACH:
		CancelRetrievalFree(I_CryptDetachTls(hCryptNetCancelTls));

        break;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   RPORDllRegisterServer
//
//  Synopsis:   DllRegisterServer like registration of RPOR functions
//
//----------------------------------------------------------------------------
STDAPI RPORDllRegisterServer (HMODULE hModule)
{
    CHAR  pszDll[MAX_PATH+1];
    WCHAR pwszDll[MAX_PATH+1];
    LPSTR pszDllRel = NULL;

    if ( GetModuleFileNameA( hModule, pszDll, MAX_PATH ) == 0 )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }
    pszDll[MAX_PATH] = '\0';

    pszDllRel = strrchr( pszDll, '\\' );

    assert( pszDllRel != NULL );

    pszDllRel += 1;

    if ( MultiByteToWideChar(
              CP_ACP,
              0,
              pszDllRel,
              -1,
              pwszDll,
              MAX_PATH+1
              ) == 0 )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptRegisterDefaultOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                CRYPT_REGISTER_FIRST_INDEX,
                pwszDll
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_EXISTS ) )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptRegisterDefaultOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
                CRYPT_REGISTER_FIRST_INDEX,
                pwszDll
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_EXISTS ) )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptRegisterOIDFunction(
                0,
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                sz_CERT_STORE_PROV_LDAP,
                pwszDll,
                LDAP_OPEN_STORE_PROV_FUNC
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_EXISTS ) )
    {
        return( GetLastError() );
    }

    if ( ( CryptRegisterOIDFunction(
                0,
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                CERT_STORE_PROV_LDAP,
                pwszDll,
                LDAP_OPEN_STORE_PROV_FUNC
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_EXISTS ) )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   RPORDllUnregisterServer
//
//  Synopsis:   DllUnregisterServer like registration of RPOR functions
//
//----------------------------------------------------------------------------
STDAPI RPORDllUnregisterServer (HMODULE hModule)
{
    CHAR  pszDll[MAX_PATH+1];
    WCHAR pwszDll[MAX_PATH+1];
    LPSTR pszDllRel = NULL;

    if ( GetModuleFileNameA( hModule, pszDll, MAX_PATH ) == 0 )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }
    pszDll[MAX_PATH] = '\0';

    pszDllRel = strrchr( pszDll, '\\' );

    assert( pszDllRel != NULL );

    pszDllRel += 1;

    if ( MultiByteToWideChar(
              CP_ACP,
              0,
              pszDllRel,
              -1,
              pwszDll,
              MAX_PATH+1
              ) == 0 )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptUnregisterDefaultOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                pwszDll
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptUnregisterDefaultOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
                pwszDll
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptUnregisterOIDFunction(
                0,
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                sz_CERT_STORE_PROV_LDAP
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
    {
        return( GetLastError() );
    }

    if ( ( CryptUnregisterOIDFunction(
                0,
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                CERT_STORE_PROV_LDAP
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   RPORDllRegUnregServer
//
//  Synopsis:   reg unreg server entry point for RPOR
//
//----------------------------------------------------------------------------
HRESULT WINAPI RPORDllRegUnregServer (HMODULE hModule, BOOL fRegUnreg)
{
    if ( fRegUnreg == TRUE )
    {
        return( RPORDllRegisterServer( hModule ) );
    }

    return( RPORDllUnregisterServer( hModule ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\ldapsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ldapsp.h
//
//  Contents:   LDAP Scheme Provider definitions
//
//  History:    28-Jul-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#if !defined(__LDAPSP_H__)
#define __LDAPSP_H__

#include <orm.h>
#include <winldap.h>
#include <dsgetdc.h>

//
// The minimum time to allow for LDAP timeouts
//

#define LDAP_MIN_TIMEOUT_SECONDS    10

//
// LDAP Scheme Provider Entry Points
//

#define LDAP_SCHEME "ldap"

BOOL WINAPI LdapRetrieveEncodedObject (
                IN LPCWSTR pwszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                );

VOID WINAPI LdapFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                );

BOOL WINAPI LdapCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                );

//
// LDAP Scheme Provider Notes.  The LDAP API model has synchronous with
// timeout and asynchronous via polling mechanisms.
//

//
// LDAP Synchronous Object Retriever
//

class CLdapSynchronousRetriever : public IObjectRetriever
{
public:

    //
    // Construction
    //

    CLdapSynchronousRetriever ();
    ~CLdapSynchronousRetriever ();

    //
    // IRefCountedObject methods
    //

    virtual VOID AddRef ();
    virtual VOID Release ();

    //
    // IObjectRetriever methods
    //

    virtual BOOL RetrieveObjectByUrl (
                         LPCWSTR pwszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         );

    virtual BOOL CancelAsyncRetrieval ();

private:

    //
    // Reference count
    //

    ULONG m_cRefs;
};

//
// LDAP Scheme Provider Support API
//

typedef struct _LDAP_URL_COMPONENTS {

    LPWSTR  pwszHost;
    ULONG   Port;
    LPWSTR  pwszDN;
    ULONG   cAttr;
    LPWSTR* apwszAttr;
    ULONG   Scope;
    LPWSTR  pwszFilter;

} LDAP_URL_COMPONENTS, *PLDAP_URL_COMPONENTS;

BOOL
LdapCrackUrl (
    LPCWSTR pwszUrl,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedHost (
    LPWSTR pwszHost,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedDN (
    LPWSTR pwszDN,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedAttributeList (
    LPWSTR pwszAttrList,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedScopeAndFilter (
    LPWSTR pwszScope,
    LPWSTR pwszFilter,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

VOID
LdapFreeUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

VOID
LdapDisplayUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

#define LDAP_BIND_AUTH_SSPI_ENABLE_FLAG     0x1
#define LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG   0x2

BOOL
LdapGetBindings (
    LPWSTR pwszHost,
    ULONG Port,
    DWORD dwRetrievalFlags,
    DWORD dwBindFlags,
    DWORD dwTimeout,
    PCRYPT_CREDENTIALS pCredentials,
    LDAP** ppld
    );

VOID
LdapFreeBindings (
    LDAP* pld
    );

BOOL
LdapSendReceiveUrlRequest (
    LDAP* pld,
    PLDAP_URL_COMPONENTS pLdapUrlComponents,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,
    PCRYPT_BLOB_ARRAY pcba,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    );

BOOL
LdapConvertLdapResultMessage (
    LDAP* pld,
    PLDAPMessage plm,
    DWORD dwRetrievalFlags,
    PCRYPT_BLOB_ARRAY pcba,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    );

VOID
LdapFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba
    );

BOOL
LdapHasWriteAccess (
    LDAP* pld,
    PLDAP_URL_COMPONENTS pLdapUrlComponents,
    DWORD dwTimeout
    );

BOOL
LdapSSPIOrSimpleBind (
    LDAP* pld,
    SEC_WINNT_AUTH_IDENTITY_W* pAuthIdentity,
    DWORD dwRetrievalFlags,
    DWORD dwBindFlags
    );



ULONG
I_CryptNetLdapMapErrorToWin32(
    LDAP* pld,
    ULONG LdapError
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\ldapstor.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ldapstor.cpp
//
//  Contents:   Ldap Store Provider implementation
//
//  History:    17-Oct-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::CLdapStore, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLdapStore::CLdapStore ( 
              OUT BOOL& rfResult
              )
                
           : m_pBinding( NULL ),
             m_hCacheStore( NULL ),
             m_dwOpenFlags( 0 ),
             m_fDirty( FALSE )
{
    rfResult = TRUE;
    memset( &m_UrlComponents, 0, sizeof( m_UrlComponents ) );

    if (! Pki_InitializeCriticalSection( &m_StoreLock ))
    {
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::~CLdapStore, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLdapStore::~CLdapStore ()
{
    DeleteCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::OpenStore, public
//
//  Synopsis:   open store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::OpenStore (
                LPCSTR pszStoreProv,
                DWORD dwMsgAndCertEncodingType,
                HCRYPTPROV hCryptProv,
                DWORD dwFlags,
                const void* pvPara,
                HCERTSTORE hCertStore,
                PCERT_STORE_PROV_INFO pStoreProvInfo
                )
{
    BOOL    fResult = TRUE;
    DWORD   dwRetrievalFlags;
    DWORD   dwBindFlags;

    assert( m_pBinding == NULL );
    assert( m_hCacheStore == NULL );
    assert( m_dwOpenFlags == 0 );
    assert( m_fDirty == FALSE );

    m_dwOpenFlags = dwFlags;
    m_hCacheStore = hCertStore;

    if ( pvPara == NULL )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( (dwFlags & CERT_STORE_UNSAFE_PHYSICAL_FLAG) &&
            (dwFlags & CERT_LDAP_STORE_OPENED_FLAG) ) 
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    __try
    {
        LPCWSTR pwszUrl;

        if (dwFlags & CERT_LDAP_STORE_OPENED_FLAG)
        {
            PCERT_LDAP_STORE_OPENED_PARA pOpenedPara;

            // Will set this before returning. Don't want to do an
            // unbind if the open fails.
            m_dwOpenFlags &= ~CERT_LDAP_STORE_UNBIND_FLAG;

            pOpenedPara = (PCERT_LDAP_STORE_OPENED_PARA) pvPara;
            m_pBinding = (LDAP *) pOpenedPara->pvLdapSessionHandle;
            pwszUrl = pOpenedPara->pwszLdapUrl;
        }
        else
        {
            pwszUrl = (LPCWSTR) pvPara;
            m_dwOpenFlags |= CERT_LDAP_STORE_UNBIND_FLAG;
        }

        if ( LdapCrackUrl( pwszUrl, &m_UrlComponents ) == FALSE )
        {
            return( FALSE );
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        return( FALSE );
    }

    dwRetrievalFlags = 0;
    dwBindFlags = LDAP_BIND_AUTH_SSPI_ENABLE_FLAG |
                    LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG;

    if (dwFlags & CERT_LDAP_STORE_SIGN_FLAG)
    {
        dwRetrievalFlags |= CRYPT_LDAP_SIGN_RETRIEVAL;
        dwBindFlags &= ~LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG;
    }

    if (dwFlags & CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG)
    {
        dwRetrievalFlags |= CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL;
        dwBindFlags &= ~LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG;
    }

    if (!( dwFlags & CERT_LDAP_STORE_OPENED_FLAG ) )
    {
        fResult = LdapGetBindings(
                  m_UrlComponents.pwszHost,
                  m_UrlComponents.Port,
                  dwRetrievalFlags,
                  dwBindFlags,
                  LDAP_STORE_TIMEOUT,
                  NULL,
                  &m_pBinding
                  );
    }

    if ( ( fResult == TRUE ) && !( dwFlags & CERT_STORE_READONLY_FLAG ) )
    {
        fResult = LdapHasWriteAccess( m_pBinding, &m_UrlComponents,
            LDAP_STORE_TIMEOUT );

        if ( fResult == FALSE )
        {
            SetLastError( (DWORD) ERROR_ACCESS_DENIED );
        }
    }

    if ( fResult == TRUE )
    {
        if ( m_dwOpenFlags & CERT_STORE_DELETE_FLAG )
        {
            m_fDirty = TRUE;

            fResult = InternalCommit( 0 );

            if ( fResult == TRUE )
            {
                pStoreProvInfo->dwStoreProvFlags = CERT_STORE_PROV_DELETED_FLAG;

                if (dwFlags & CERT_LDAP_STORE_UNBIND_FLAG)
                {
                    m_dwOpenFlags |= CERT_LDAP_STORE_UNBIND_FLAG;
                }
            }

            CloseStore( 0 );
            return( fResult );
        }

        fResult = FillCacheStore( FALSE );

        // Note, LDAP_REFERRAL gets mapped to ERROR_MORE_DATA. Sometimes
        // referral errors aren't detected until doing the ldap search.
        if ( !fResult   && 
                !(dwFlags & CERT_LDAP_STORE_OPENED_FLAG)  &&
                ((LDAP_BIND_AUTH_SSPI_ENABLE_FLAG |
                    LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG) == dwBindFlags)
                        &&
                (ERROR_MORE_DATA == GetLastError()) )
        {
            // Try again doing simple bind.

            LdapFreeBindings( m_pBinding );
            m_pBinding = NULL;

            fResult = LdapGetBindings(
                  m_UrlComponents.pwszHost,
                  m_UrlComponents.Port,
                  dwRetrievalFlags,
                  LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG,
                  LDAP_STORE_TIMEOUT,
                  NULL,
                  &m_pBinding
                  );

            if ( fResult )
            {
                fResult = FillCacheStore( FALSE );
            }
        }
    }

    if ( fResult == TRUE )
    {
        pStoreProvInfo->cStoreProvFunc = LDAP_PROV_FUNC_COUNT;
        pStoreProvInfo->rgpvStoreProvFunc = (void **)rgpvLdapProvFunc;
        pStoreProvInfo->hStoreProv = (HCERTSTOREPROV)this;

        if (dwFlags & CERT_LDAP_STORE_UNBIND_FLAG)
        {
            m_dwOpenFlags |= CERT_LDAP_STORE_UNBIND_FLAG;
        }
    }
    else
    {
        CloseStore( 0 );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::CloseStore, public
//
//  Synopsis:   close the store
//
//----------------------------------------------------------------------------
VOID
CLdapStore::CloseStore (DWORD dwFlags)
{
    DWORD LastError = GetLastError();

    EnterCriticalSection( &m_StoreLock );

    InternalCommit( 0 );

    LdapFreeUrlComponents( &m_UrlComponents );
    memset( &m_UrlComponents, 0, sizeof( m_UrlComponents ) );

    if (m_dwOpenFlags & CERT_LDAP_STORE_UNBIND_FLAG)
    {
        LdapFreeBindings( m_pBinding );
    }
    m_pBinding = NULL;

    LeaveCriticalSection( &m_StoreLock );

    SetLastError( LastError );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::DeleteCert, public
//
//  Synopsis:   delete cert from store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CERTIFICATE,
                 (LPVOID)pCertContext,
                 0
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::DeleteCrl, public
//
//  Synopsis:   delete CRL from store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::DeleteCrl (PCCRL_CONTEXT pCrlContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CRL,
                 (LPVOID)pCrlContext,
                 0
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::DeleteCtl, public
//
//  Synopsis:   delete CTL from store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::DeleteCtl (PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CTL,
                 (LPVOID)pCtlContext,
                 0
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::SetCertProperty, public
//
//  Synopsis:   set a property on the cert
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::SetCertProperty (
               PCCERT_CONTEXT pCertContext,
               DWORD dwPropId,
               DWORD dwFlags,
               const void* pvPara
               )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::SetCrlProperty, public
//
//  Synopsis:   set a property on the CRL
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::SetCrlProperty (
               PCCRL_CONTEXT pCrlContext,
               DWORD dwPropId,
               DWORD dwFlags,
               const void* pvPara
               )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::SetCtlProperty, public
//
//  Synopsis:   set a property on the CTL
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::SetCtlProperty (
               PCCTL_CONTEXT pCrlContext,
               DWORD dwPropId,
               DWORD dwFlags,
               const void* pvPara
               )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::WriteCert, public
//
//  Synopsis:   write cert to store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CERTIFICATE,
                 (LPVOID)pCertContext,
                 dwFlags
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::WriteCrl, public
//
//  Synopsis:   write CRL to store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::WriteCrl (PCCRL_CONTEXT pCrlContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CRL,
                 (LPVOID)pCrlContext,
                 dwFlags
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::WriteCtl, public
//
//  Synopsis:   write CTL to store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::WriteCtl (PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CTL,
                 (LPVOID)pCtlContext,
                 dwFlags
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::StoreControl, public
//
//  Synopsis:   store control dispatch
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::StoreControl (DWORD dwFlags, DWORD dwCtrlType, LPVOID pvCtrlPara)
{
    switch ( dwCtrlType )
    {
    case CERT_STORE_CTRL_COMMIT:
         return( Commit( dwFlags ) );
    case CERT_STORE_CTRL_RESYNC:
         return( Resync() );
    }

    SetLastError( (DWORD) ERROR_CALL_NOT_IMPLEMENTED );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::Commit, public
//
//  Synopsis:   commit the store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::Commit (DWORD dwFlags)
{
    BOOL fResult;

    EnterCriticalSection( &m_StoreLock );

    fResult = InternalCommit( dwFlags );

    LeaveCriticalSection( &m_StoreLock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::Resync, public
//
//  Synopsis:   resync the store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::Resync ()
{
    BOOL fResult;

    EnterCriticalSection( &m_StoreLock );

    fResult = FillCacheStore( TRUE );

    LeaveCriticalSection( &m_StoreLock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::FillCacheStore, private
//
//  Synopsis:   fill the cache store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::FillCacheStore (BOOL fClearCache)
{
    BOOL             fResult;
    CRYPT_BLOB_ARRAY cba;

    if ( fClearCache == TRUE )
    {
        if ( ObjectContextDeleteAllObjectsFromStore( m_hCacheStore ) == FALSE )
        {
            return( FALSE );
        }
    }

    fResult = LdapSendReceiveUrlRequest(
                  m_pBinding,
                  &m_UrlComponents,
                  0,                    // dwRetrievalFlags
                  LDAP_STORE_TIMEOUT,
                  &cba,
                  NULL
                  );

    if (fResult)
    {
        HCERTSTORE hStore = NULL;

        fResult = CreateObjectContext (
            CRYPT_RETRIEVE_MULTIPLE_OBJECTS,
            &cba,
            CERT_QUERY_CONTENT_FLAG_CERT                |
                CERT_QUERY_CONTENT_FLAG_CTL             |
                CERT_QUERY_CONTENT_FLAG_CRL             |
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED    |
                CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
            FALSE,          // fQuerySingleContext
            (LPVOID*) &hStore
            );

        if (fResult)
        {
            fResult = I_CertUpdateStore( m_hCacheStore, hStore, 0, NULL );
            CertCloseStore( hStore, 0 );
        }

        CCryptBlobArray BlobArray( &cba, 0 );

        BlobArray.FreeArray( TRUE );
    }
    else if (GetLastError() == CRYPT_E_NOT_FOUND)
    {
        fResult = TRUE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::InternalCommit, private
//
//  Synopsis:   commit current changes
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::InternalCommit (DWORD dwFlags)
{
    BOOL            fResult = TRUE;
    LPCSTR          pszContextOid = CONTEXT_OID_CERTIFICATE;
    LPVOID          pvContext = NULL;
    struct berval** abv;
    struct berval** newabv;
    DWORD           cbv = 0;
    DWORD           cCount;
    DWORD           cArray = MIN_BERVAL;

    if ( dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG )
    {
        m_fDirty = FALSE;
        return( TRUE );
    }

    if ( m_dwOpenFlags & CERT_STORE_READONLY_FLAG )
    {
        SetLastError( (DWORD) ERROR_ACCESS_DENIED );
        return( FALSE );
    }

    if ( ( m_fDirty == FALSE ) &&
         !( dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG ) )
    {
        return( TRUE );
    }

    abv = (struct berval**)malloc( cArray * sizeof( struct berval* ) );
    if ( abv == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    memset( abv, 0, cArray * sizeof( struct berval * ) );

    while ( ( fResult == TRUE ) &&
            ( ( pvContext = ObjectContextEnumObjectsInStore(
                                  m_hCacheStore,
                                  pszContextOid,
                                  pvContext,
                                  &pszContextOid
                                  ) ) != NULL ) )
    {
        abv[cbv] = (struct berval*)malloc( sizeof( struct berval ) );
        if ( abv[cbv] != NULL )
        {
            ObjectContextGetEncodedBits(
                  pszContextOid,
                  pvContext,
                  &(abv[cbv]->bv_len),
                  (LPBYTE *)&(abv[cbv]->bv_val)
                  );

            cbv += 1;
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
            ObjectContextFree( pszContextOid, pvContext );
        }

        if ( cbv == ( cArray - 1 ) )
        {
            newabv = (struct berval**)realloc(
                                     abv,
                                     ( cArray + GROW_BERVAL ) *
                                     sizeof( struct berval* )
                                     );

            if ( newabv != NULL )
            {
                abv = newabv;
                memset( &abv[cArray], 0, GROW_BERVAL * sizeof( struct berval* ) );
                cArray += GROW_BERVAL;
            }
            else
            {
                SetLastError( (DWORD) E_OUTOFMEMORY );
                fResult = FALSE;
            }
        }
    }

    if ( fResult == TRUE )
    {
        ULONG     lderr;
        LDAPModW  mod;
        LDAPModW* amod[2];

        assert( m_UrlComponents.cAttr == 1 );

        mod.mod_type = m_UrlComponents.apwszAttr[0];
        mod.mod_op = LDAP_MOD_BVALUES;

        amod[0] = &mod;
        amod[1] = NULL;

        if ( cbv > 0 )
        {
            mod.mod_op |= LDAP_MOD_REPLACE;
            mod.mod_bvalues = abv;
        }
        else
        {
            mod.mod_op |= LDAP_MOD_DELETE;
            mod.mod_bvalues = NULL;
        }

        if ( ( lderr = ldap_modify_sW(
                            m_pBinding,
                            m_UrlComponents.pwszDN,
                            amod
                            ) ) == LDAP_SUCCESS )
        {
            m_fDirty = FALSE;
        }
        else
        {
            SetLastError( I_CryptNetLdapMapErrorToWin32( m_pBinding, lderr ) );
            fResult = FALSE;
        }
    }

    for ( cCount = 0; cCount < cbv; cCount++ )
    {
        free( abv[cCount] );
    }

    free( abv );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::WriteCheckSetDirtyWithLock, private
//
//  Synopsis:   if the store is writable, set the dirty flag taking the store
//              lock where appropriate
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::WriteCheckSetDirtyWithLock (
                 LPCSTR pszContextOid,
                 LPVOID pvContext,
                 DWORD dwFlags
                 )
{
    if ( m_dwOpenFlags & CERT_STORE_READONLY_FLAG )
    {
        SetLastError( (DWORD) ERROR_ACCESS_DENIED );
        return( FALSE );
    }

    EnterCriticalSection( &m_StoreLock );

    if ( ( dwFlags >> 16 ) == CERT_STORE_ADD_ALWAYS )
    {
        LPVOID pv;

        if ( ( pv = ObjectContextFindCorrespondingObject(
                          m_hCacheStore,
                          pszContextOid,
                          pvContext
                          ) ) != NULL )
        {
            ObjectContextFree( pszContextOid, pv );
            SetLastError( (DWORD) CRYPT_E_EXISTS );

            LeaveCriticalSection( &m_StoreLock );

            return( FALSE );
        }
    }

    m_fDirty = TRUE;

    LeaveCriticalSection( &m_StoreLock );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvOpenStore
//
//  Synopsis:   provider open store entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvOpenStore (
                IN LPCSTR pszStoreProv,
                IN DWORD dwMsgAndCertEncodingType,
                IN HCRYPTPROV hCryptProv,
                IN DWORD dwFlags,
                IN const void* pvPara,
                IN HCERTSTORE hCertStore,
                IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                )
{
    BOOL        fResult = FALSE;
    CLdapStore* pLdap;

    pLdap = new CLdapStore ( fResult );
    if ( pLdap == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == FALSE )
    {
        delete pLdap;
        return( FALSE );
    }

    fResult = pLdap->OpenStore(
                         pszStoreProv,
                         dwMsgAndCertEncodingType,
                         hCryptProv,
                         dwFlags,
                         pvPara,
                         hCertStore,
                         pStoreProvInfo
                         );

    if ( fResult == FALSE )
    {
        delete pLdap;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvCloseStore
//
//  Synopsis:   provider close store entry point
//
//----------------------------------------------------------------------------
void WINAPI LdapProvCloseStore (
                IN HCERTSTOREPROV hStoreProv,
                IN DWORD dwFlags
                )
{
    ( (CLdapStore *)hStoreProv )->CloseStore( dwFlags );
    delete (CLdapStore *)hStoreProv;
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvDeleteCert
//
//  Synopsis:   provider delete certificate entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvDeleteCert (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->DeleteCert( pCertContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvDeleteCrl
//
//  Synopsis:   provider delete CRL entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvDeleteCrl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->DeleteCrl( pCrlContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvDeleteCtl
//
//  Synopsis:   provider delete CTL entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvDeleteCtl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->DeleteCtl( pCtlContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvSetCertProperty
//
//  Synopsis:   provider set certificate property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvSetCertProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                )
{
    return( ( (CLdapStore *)hStoreProv )->SetCertProperty(
                                             pCertContext,
                                             dwPropId,
                                             dwFlags,
                                             pvData
                                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvSetCrlProperty
//
//  Synopsis:   provider set CRL property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvSetCrlProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                )
{
    return( ( (CLdapStore *)hStoreProv )->SetCrlProperty(
                                             pCrlContext,
                                             dwPropId,
                                             dwFlags,
                                             pvData
                                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvSetCtlProperty
//
//  Synopsis:   provider set CTL property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvSetCtlProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                )
{
    return( ( (CLdapStore *)hStoreProv )->SetCtlProperty(
                                             pCtlContext,
                                             dwPropId,
                                             dwFlags,
                                             pvData
                                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvWriteCert
//
//  Synopsis:   provider write certificate entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvWriteCert (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->WriteCert( pCertContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvWriteCrl
//
//  Synopsis:   provider write CRL entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvWriteCrl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->WriteCrl( pCrlContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvWriteCtl
//
//  Synopsis:   provider write CTL entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvWriteCtl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->WriteCtl( pCtlContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvStoreControl
//
//  Synopsis:   provider control entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvStoreControl (
                IN HCERTSTOREPROV hStoreProv,
                IN DWORD dwFlags,
                IN DWORD dwCtrlType,
                IN LPVOID pvCtrlPara
                )
{
    return( ( (CLdapStore *)hStoreProv )->StoreControl(
                                               dwFlags,
                                               dwCtrlType,
                                               pvCtrlPara
                                               ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptNetGetUserDsStoreUrl
//
//  Synopsis:   get user DS store URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptNetGetUserDsStoreUrl (
          IN LPWSTR pwszUserAttribute,
          OUT LPWSTR* ppwszUrl
          )
{
    BOOL               fResult;
    DWORD              dwLastError = 0;
    WCHAR              wszUser[MAX_PATH];
    ULONG              nUser = MAX_PATH;
    LPWSTR             pwszUser = wszUser;
    HMODULE            hModule = NULL;
    PFN_GETUSERNAMEEXW pfnGetUserNameExW = NULL;

    hModule = LoadLibraryA( "secur32.dll" );
    if ( hModule == NULL )
    {
        return( FALSE );
    }

    pfnGetUserNameExW = (PFN_GETUSERNAMEEXW)GetProcAddress(
                                               hModule,
                                               "GetUserNameExW"
                                               );

    if ( pfnGetUserNameExW == NULL )
    {
        FreeLibrary( hModule );
        return( FALSE );
    }

    fResult = ( *pfnGetUserNameExW )( NameFullyQualifiedDN, pwszUser, &nUser );
    if ( fResult == FALSE )
    {
        if ( ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ||
             ( GetLastError() == ERROR_MORE_DATA ) )
        {
            pwszUser = new WCHAR [nUser];
            if ( pwszUser != NULL )
            {
                fResult = ( *pfnGetUserNameExW )(
                                   NameFullyQualifiedDN,
                                   pwszUser,
                                   &nUser
                                   );
            }
            else
            {
                SetLastError( (DWORD) E_OUTOFMEMORY );
                fResult = FALSE;
            }
        }
    }



    if ( fResult == TRUE )
    {
        DWORD              cchUrl = 0;
        LPWSTR             pwszUrl = NULL;

        cchUrl = wcslen(USER_DS_STORE_URL_PREFIX) + wcslen(pwszUser) +
            wcslen(USER_DS_STORE_URL_SEPARATOR) + wcslen(pwszUserAttribute) + 1;

        pwszUrl = (LPWSTR)CryptMemAlloc(cchUrl * sizeof(WCHAR));

        if ( pwszUrl != NULL )
        {
            wcscpy(pwszUrl, USER_DS_STORE_URL_PREFIX);
            wcscat(pwszUrl, pwszUser);
            wcscat(pwszUrl, USER_DS_STORE_URL_SEPARATOR);
            wcscat(pwszUrl, pwszUserAttribute);

            *ppwszUrl = pwszUrl;
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    dwLastError = GetLastError();

    if ( pwszUser != wszUser )
    {
        delete [] pwszUser;
    }

    FreeLibrary( hModule );

    SetLastError(dwLastError);

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\inetsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       inetsp.cpp
//
//  Contents:   Inet Scheme Provider for Remote Object Retrieval
//
//  History:    06-Aug-97    kirtd    Created
//              01-Jan-02    philh    Moved from wininet to winhttp
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include "cryptver.h"
#include <dbgdef.h>


//+---------------------------------------------------------------------------
//
//  Function:   InetRetrieveEncodedObject
//
//  Synopsis:   retrieve encoded object via HTTP, HTTPS protocols
//
//----------------------------------------------------------------------------
BOOL WINAPI InetRetrieveEncodedObject (
                IN LPCWSTR pwszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                )
{
    BOOL              fResult;
    IObjectRetriever* por = NULL;

    if ( !( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        por = new CInetSynchronousRetriever;
    }

    if ( por == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = por->RetrieveObjectByUrl(
                           pwszUrl,
                           pszObjectOid,
                           dwRetrievalFlags,
                           dwTimeout,
                           (LPVOID *)pObject,
                           ppfnFreeObject,
                           ppvFreeContext,
                           hAsyncRetrieve,
                           pCredentials,
                           NULL,
                           pAuxInfo
                           );

    por->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetFreeEncodedObject
//
//  Synopsis:   free encoded object retrieved via InetRetrieveEncodedObject
//
//----------------------------------------------------------------------------
VOID WINAPI InetFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                )
{
    assert( pvFreeContext == NULL );

    InetFreeCryptBlobArray( pObject );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetCancelAsyncRetrieval
//
//  Synopsis:   cancel asynchronous object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI InetCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                )
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::CInetSynchronousRetriever, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CInetSynchronousRetriever::CInetSynchronousRetriever ()
{
    m_cRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::~CInetSynchronousRetriever, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CInetSynchronousRetriever::~CInetSynchronousRetriever ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::AddRef, public
//
//  Synopsis:   IRefCountedObject::AddRef
//
//----------------------------------------------------------------------------
VOID
CInetSynchronousRetriever::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::Release, public
//
//  Synopsis:   IRefCountedObject::Release
//
//----------------------------------------------------------------------------
VOID
CInetSynchronousRetriever::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::RetrieveObjectByUrl, public
//
//  Synopsis:   IObjectRetriever::RetrieveObjectByUrl
//
//----------------------------------------------------------------------------
BOOL
CInetSynchronousRetriever::RetrieveObjectByUrl (
                                   LPCWSTR pwszUrl,
                                   LPCSTR pszObjectOid,
                                   DWORD dwRetrievalFlags,
                                   DWORD dwTimeout,
                                   LPVOID* ppvObject,
                                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                   LPVOID* ppvFreeContext,
                                   HCRYPTASYNC hAsyncRetrieve,
                                   PCRYPT_CREDENTIALS pCredentials,
                                   LPVOID pvVerify,
                                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                   )
{
    BOOL      fResult;
    DWORD     LastError = 0;
    HINTERNET hInetSession = NULL;

    assert( hAsyncRetrieve == NULL );

    if ( ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
    {
        return( SchemeRetrieveCachedCryptBlobArray(
                      pwszUrl,
                      dwRetrievalFlags,
                      (PCRYPT_BLOB_ARRAY)ppvObject,
                      ppfnFreeObject,
                      ppvFreeContext,
                      pAuxInfo
                      ) );
    }

    fResult = InetGetBindings(
                  pwszUrl,
                  dwRetrievalFlags,
                  dwTimeout,
                  &hInetSession
                  );


    if ( fResult == TRUE )
    {
        fResult = InetSendReceiveUrlRequest(
                      hInetSession,
                      pwszUrl,
                      dwRetrievalFlags,
                      pCredentials,
                      (PCRYPT_BLOB_ARRAY)ppvObject,
                      pAuxInfo
                      );
    }

    if ( fResult == TRUE )
    {
        *ppfnFreeObject = InetFreeEncodedObject;
        *ppvFreeContext = NULL;
    }
    else
    {
        LastError = GetLastError();
    }

    InetFreeBindings( hInetSession );

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::CancelAsyncRetrieval, public
//
//  Synopsis:   IObjectRetriever::CancelAsyncRetrieval
//
//----------------------------------------------------------------------------
BOOL
CInetSynchronousRetriever::CancelAsyncRetrieval ()
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetGetBindings
//
//  Synopsis:   get the session bindings
//
//----------------------------------------------------------------------------
BOOL
InetGetBindings (
    LPCWSTR pwszUrl,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,
    HINTERNET* phInetSession
    )
{
    BOOL        fResult = TRUE;
    DWORD       LastError = 0;
    HINTERNET   hInetSession;
    WCHAR       wszUserAgent[64];
    const DWORD cchUserAgent = sizeof(wszUserAgent) / sizeof(wszUserAgent[0]);

    _snwprintf(wszUserAgent, cchUserAgent - 1,
        L"Microsoft-CryptoAPI/%S", VER_PRODUCTVERSION_STR);
    wszUserAgent[cchUserAgent - 1] = L'\0';

    hInetSession = WinHttpOpen(
        wszUserAgent,
        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,  // dwAccessType
        WINHTTP_NO_PROXY_NAME,              // pwszProxyName   OPTIONAL
        WINHTTP_NO_PROXY_BYPASS,            // pwszProxyBypass OPTIONAL
        0                                   // dwFlags
        );

    if ( hInetSession == NULL )
    {
        return( FALSE );
    }

    if ( ( fResult == TRUE ) && ( dwTimeout != 0 ) )
    {
        int iTimeout = (int) dwTimeout;

        fResult = WinHttpSetTimeouts(
            hInetSession,
            iTimeout,           // nResolveTimeout
            iTimeout,           // nConnectTimeout
            iTimeout,           // nSendTimeout
            iTimeout            // nReceiveTimeout
            );
    }

    if ( fResult == TRUE )
    {
        DWORD dwOptionFlag;

        dwOptionFlag = WINHTTP_DISABLE_PASSPORT_AUTH;
        WinHttpSetOption(
            hInetSession,
            WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH,
            &dwOptionFlag,
            sizeof(dwOptionFlag)
            );
    }


    if ( fResult == TRUE )
    {
        *phInetSession = hInetSession;
    }
    else
    {
        LastError = GetLastError();
        WinHttpCloseHandle( hInetSession );
    }

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetFreeBindings
//
//  Synopsis:   free the inet session bindings
//
//----------------------------------------------------------------------------
VOID
InetFreeBindings (
    HINTERNET hInetSession
    )
{
    if ( hInetSession != NULL )
    {
        WinHttpCloseHandle( hInetSession );
    }
}

//+=========================================================================
//  WinHttp doesn't support proxy failure rollover to the next proxy in
//  the list. When this is fixed, we can revert back to OLD_InetSetProxy.
//-=========================================================================

//+-------------------------------------------------------------------------
//  Calls the WinHttp proxy APIs to get the list of one or more proxy
//  servers.
//
//  The returned *ppProxyInfo must be freed by calling PkiFree()
//
//  For no proxy servers, TRUE is returned with *ppProxyInfo set to NULL.
//--------------------------------------------------------------------------
BOOL
InetGetProxy(
    IN HINTERNET hInetSession,
    IN HINTERNET hInetRequest,
    IN LPCWSTR pwszUrl,
    IN DWORD dwRetrievalFlags,
    OUT WINHTTP_PROXY_INFO **ppProxyInfo
    )
{
    BOOL fResult = TRUE;
    WINHTTP_PROXY_INFO *pProxyInfo = NULL;

    //
    // Detect IE settings and look up proxy if necessary.
    // Boilerplate from Stephen Sulzer.
    //
    // I copied from CACHED_AUTOPROXY::Generate() at
    // \admin\services\drizzle\newjob\downloader.cpp
    //
    WINHTTP_PROXY_INFO ProxyInfo;
    WINHTTP_AUTOPROXY_OPTIONS AutoProxyOptions;
    WINHTTP_CURRENT_USER_IE_PROXY_CONFIG    IEProxyConfig;
    BOOL fTryAutoProxy = FALSE;
    BOOL fSuccess = FALSE;

    ZeroMemory(&ProxyInfo, sizeof(ProxyInfo));
    ZeroMemory(&AutoProxyOptions, sizeof(AutoProxyOptions));
    ZeroMemory(&IEProxyConfig, sizeof(IEProxyConfig));

    if (WinHttpGetIEProxyConfigForCurrentUser(&IEProxyConfig)) {
        if (IEProxyConfig.fAutoDetect) {
            AutoProxyOptions.dwFlags = WINHTTP_AUTOPROXY_AUTO_DETECT;
            fTryAutoProxy = TRUE;
        }

        if (IEProxyConfig.lpszAutoConfigUrl) {
            AutoProxyOptions.dwFlags |= WINHTTP_AUTOPROXY_CONFIG_URL;
            AutoProxyOptions.lpszAutoConfigUrl = IEProxyConfig.lpszAutoConfigUrl;
            fTryAutoProxy = TRUE;
        }

        AutoProxyOptions.fAutoLogonIfChallenged = TRUE;
    } else {
        // WinHttpGetIEProxyForCurrentUser failed, try autodetection anyway...
        AutoProxyOptions.dwFlags =           WINHTTP_AUTOPROXY_AUTO_DETECT;
        fTryAutoProxy = TRUE;
    }

    if (fTryAutoProxy) {
        if (AutoProxyOptions.dwFlags & WINHTTP_AUTOPROXY_AUTO_DETECT) {
            // First try using the faster DNS_A option
            AutoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DNS_A;

            fSuccess = WinHttpGetProxyForUrl( hInetSession,
                                          pwszUrl,
                                          &AutoProxyOptions,
                                          &ProxyInfo
                                          );

            if (!fSuccess) {
                DWORD dwLastErr = GetLastError();

                I_CryptNetDebugErrorPrintfA(
                    "CRYPTNET.DLL --> WinHttpGetProxyForUrl(DNS) failed: %d (0x%x)\n",
                    dwLastErr, dwLastErr);

                // Try again using the slower DHCP
                AutoProxyOptions.dwAutoDetectFlags |=
                    WINHTTP_AUTO_DETECT_TYPE_DHCP;
            }
        }

        if (!fSuccess)
            fSuccess = WinHttpGetProxyForUrl( hInetSession,
                                          pwszUrl,
                                          &AutoProxyOptions,
                                          &ProxyInfo
                                          );

        if (fSuccess &&
                WINHTTP_ACCESS_TYPE_NO_PROXY == ProxyInfo.dwAccessType &&
                !(dwRetrievalFlags & CRYPT_NO_AUTH_RETRIEVAL))
        {
            // Need to set to low to allow access to such internal sites as:
            // http://msw, http://hrweb
            DWORD dwOptionFlag = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;

            if (!WinHttpSetOption(
                    hInetRequest,
                    WINHTTP_OPTION_AUTOLOGON_POLICY,
                    &dwOptionFlag,
                    sizeof(dwOptionFlag)
                   ))
            {
                DWORD dwLastErr = GetLastError();

                I_CryptNetDebugErrorPrintfA(
                    "CRYPTNET.DLL --> WinHttpSetOption(WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW) failed: %d (0x%x)\n",
                    dwLastErr, dwLastErr);
            }
        }
    }

    // If we didn't do autoproxy or if it failed, see
    // if there's an explicit proxy server in the IE
    // proxy configuration...
    //
    // This is where the WinHttpGetIEProxyConfigForCurrentUser API
    // really comes in handy: in environments in which autoproxy is
    // not supported and so the user's IE browser must be
    // configured with an explicit proxy server.
    //
    if (!fTryAutoProxy || !fSuccess) {
        if (IEProxyConfig.lpszProxy) {
            ProxyInfo.dwAccessType    = WINHTTP_ACCESS_TYPE_NAMED_PROXY;

            ProxyInfo.lpszProxy       = IEProxyConfig.lpszProxy;
            IEProxyConfig.lpszProxy   = NULL;

            ProxyInfo.lpszProxyBypass = IEProxyConfig.lpszProxyBypass;
            IEProxyConfig.lpszProxyBypass = NULL;
        }
    }

    I_CryptNetDebugTracePrintfA(
        "CRYPTNET.DLL --> ProxyInfo:: AccessType:%d Proxy:%S ProxyByPass:%S\n",
        ProxyInfo.dwAccessType,
        ProxyInfo.lpszProxy,
        ProxyInfo.lpszProxyBypass
        );

    if (NULL != ProxyInfo.lpszProxy) {
        DWORD cbProxyInfo;
        DWORD cchProxy;                 // including NULL terminator
        DWORD cchProxyBypass;           // including NULL terminator

        cchProxy = wcslen(ProxyInfo.lpszProxy) + 1;
        if (NULL != ProxyInfo.lpszProxyBypass) {
            cchProxyBypass = wcslen(ProxyInfo.lpszProxyBypass) + 1;
        } else {
            cchProxyBypass = 0;
        }

        cbProxyInfo = sizeof(ProxyInfo) +
            (cchProxy + cchProxyBypass) * sizeof(WCHAR);

        pProxyInfo = (WINHTTP_PROXY_INFO *) PkiNonzeroAlloc(cbProxyInfo);
        if (NULL == pProxyInfo) {
            fResult = FALSE;
        } else {
            *pProxyInfo = ProxyInfo;

            pProxyInfo->lpszProxy = (LPWSTR) &pProxyInfo[1];
            memcpy(pProxyInfo->lpszProxy, ProxyInfo.lpszProxy,
                cchProxy * sizeof(WCHAR));

            if (0 != cchProxyBypass) {
                pProxyInfo->lpszProxyBypass = pProxyInfo->lpszProxy + cchProxy;
                memcpy(pProxyInfo->lpszProxyBypass, ProxyInfo.lpszProxyBypass,
                    cchProxyBypass * sizeof(WCHAR));
            } else {
                assert(NULL == pProxyInfo->lpszProxyBypass);
            }
        }
    }

    if (IEProxyConfig.lpszAutoConfigUrl)
        GlobalFree(IEProxyConfig.lpszAutoConfigUrl);
    if (IEProxyConfig.lpszProxy)
        GlobalFree(IEProxyConfig.lpszProxy);
    if (IEProxyConfig.lpszProxyBypass)
        GlobalFree(IEProxyConfig.lpszProxyBypass);

    if (ProxyInfo.lpszProxy)
        GlobalFree(ProxyInfo.lpszProxy);
    if (ProxyInfo.lpszProxyBypass)
        GlobalFree(ProxyInfo.lpszProxyBypass);

    *ppProxyInfo = pProxyInfo;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Update both the Session and Request handles with proxy list.
//  Currently, WinHttp only uses the first proxy server in the list.
//
//  Also, for proxies to work using https, it must also be set on the
//  session handle.
//--------------------------------------------------------------------------
BOOL
InetSetProxy(
    IN HINTERNET hInetSession,
    IN HINTERNET hInetRequest,
    IN WINHTTP_PROXY_INFO *pProxyInfo
    )
{
    BOOL fResult;

    if (NULL == pProxyInfo || NULL == pProxyInfo->lpszProxy) {
        return TRUE;
    }

    //
    // Set the proxy on the session handle
    //
    fResult = WinHttpSetOption( hInetSession,
                       WINHTTP_OPTION_PROXY,
                       pProxyInfo,
                       sizeof(*pProxyInfo)
                       );

    if (fResult) {
        //
        // Now set the proxy on the request handle.
        //
        fResult = WinHttpSetOption( hInetRequest,
                       WINHTTP_OPTION_PROXY,
                       pProxyInfo,
                       sizeof(*pProxyInfo)
                       );
    }

    return fResult;
}

//+-------------------------------------------------------------------------
//  Since WinHttp doesn't support proxy rollover we will advance to the
//  next proxy if WinHttpSendRequest returns one of the following errors.
//--------------------------------------------------------------------------
BOOL
InetIsPossibleBadProxy(
    IN DWORD dwErr
    )
{
    switch (dwErr) {
        case ERROR_WINHTTP_NAME_NOT_RESOLVED:
        case ERROR_WINHTTP_CANNOT_CONNECT:
        case ERROR_WINHTTP_CONNECTION_ERROR:
        case ERROR_WINHTTP_TIMEOUT:
            return TRUE;

        default:
            return FALSE;
    }
}

//+-------------------------------------------------------------------------
//  Advances the lpszProxy to point to the next proxy in the list. Assumes
//  that ";" is the delimiter and no proxy server contains this in their
//  name.
//
//  LastError is preserved. Returns TRUE if successfully found and set the
//  next proxy.
//--------------------------------------------------------------------------
BOOL
InetSetNextProxy(
    IN HINTERNET hInetSession,
    IN HINTERNET hInetRequest,
    IN OUT WINHTTP_PROXY_INFO *pProxyInfo
    )
{
    BOOL fResult = FALSE;

    if (NULL != pProxyInfo && NULL != pProxyInfo->lpszProxy) {
        DWORD dwLastError = GetLastError();
        LPWSTR lpszProxy = pProxyInfo->lpszProxy;

        I_CryptNetDebugErrorPrintfA(
            "CRYPTNET.DLL --> Error:: %d (0x%x) Bad Proxy:%S\n",
            dwLastError, dwLastError, lpszProxy);

        // Assumption:: L';' is used to separater proxy names
        while (L'\0' != *lpszProxy && L';' != *lpszProxy) {
            lpszProxy++;
        }

        if (L';' == *lpszProxy) {
            lpszProxy++;

            // Skip any leading whitespace
            while (iswspace(*lpszProxy)) {
                lpszProxy++;
            }
        }

        if (L'\0' == *lpszProxy) {
            pProxyInfo->lpszProxy = NULL;
        } else {
            pProxyInfo->lpszProxy = lpszProxy;

            fResult = InetSetProxy(
                hInetSession,
                hInetRequest,
                pProxyInfo
                );
        }

        SetLastError(dwLastError);
    }

    return fResult;
}

#if 0
//+-------------------------------------------------------------------------
//  When WinHttp is fixed to support proxy fail rollover, we can revert
//  back to this simpler proxy function.
//--------------------------------------------------------------------------
BOOL
OLD_InetSetProxy(
    IN HINTERNET hInetSession,
    IN HINTERNET hInetRequest,
    IN LPCWSTR pwszUrl,
    IN DWORD dwRetrievalFlags
    )
{
    BOOL fResult = TRUE;

    //
    // Detect IE settings and look up proxy if necessary.
    // Boilerplate from Stephen Sulzer.
    //
    // I copied from CACHED_AUTOPROXY::Generate() at
    // \admin\services\drizzle\newjob\downloader.cpp
    //
    WINHTTP_PROXY_INFO ProxyInfo;
    WINHTTP_AUTOPROXY_OPTIONS AutoProxyOptions;
    WINHTTP_CURRENT_USER_IE_PROXY_CONFIG    IEProxyConfig;
    BOOL fTryAutoProxy = FALSE;
    BOOL fSuccess = FALSE;

    ZeroMemory(&ProxyInfo, sizeof(ProxyInfo));
    ZeroMemory(&AutoProxyOptions, sizeof(AutoProxyOptions));
    ZeroMemory(&IEProxyConfig, sizeof(IEProxyConfig));


    if (WinHttpGetIEProxyConfigForCurrentUser(&IEProxyConfig)) {
        if (IEProxyConfig.fAutoDetect) {
            AutoProxyOptions.dwFlags = WINHTTP_AUTOPROXY_AUTO_DETECT;
            fTryAutoProxy = TRUE;
        }

        if (IEProxyConfig.lpszAutoConfigUrl) {
            AutoProxyOptions.dwFlags |= WINHTTP_AUTOPROXY_CONFIG_URL;
            AutoProxyOptions.lpszAutoConfigUrl = IEProxyConfig.lpszAutoConfigUrl;
            fTryAutoProxy = TRUE;
        }

        AutoProxyOptions.fAutoLogonIfChallenged = TRUE;
    } else {
        // WinHttpGetIEProxyForCurrentUser failed, try autodetection anyway...
        AutoProxyOptions.dwFlags =           WINHTTP_AUTOPROXY_AUTO_DETECT;
        fTryAutoProxy = TRUE;
    }

    if (fTryAutoProxy) {
        if (AutoProxyOptions.dwFlags & WINHTTP_AUTOPROXY_AUTO_DETECT) {
            // First try using the faster DNS_A option
            AutoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DNS_A;

            fSuccess = WinHttpGetProxyForUrl( hInetSession,
                                          pwszUrl,
                                          &AutoProxyOptions,
                                          &ProxyInfo
                                          );

            if (!fSuccess) {
                DWORD dwLastErr = GetLastError();

                I_CryptNetDebugErrorPrintfA(
                    "CRYPTNET.DLL --> WinHttpGetProxyForUrl(DNS) failed: %d (0x%x)\n",
                    dwLastErr, dwLastErr);

                // Try again using the slower DHCP
                AutoProxyOptions.dwAutoDetectFlags |=
                    WINHTTP_AUTO_DETECT_TYPE_DHCP;
            }
        }

        if (!fSuccess)
            fSuccess = WinHttpGetProxyForUrl( hInetSession,
                                          pwszUrl,
                                          &AutoProxyOptions,
                                          &ProxyInfo
                                          );

        if (fSuccess &&
                WINHTTP_ACCESS_TYPE_NO_PROXY == ProxyInfo.dwAccessType &&
                !(dwRetrievalFlags & CRYPT_NO_AUTH_RETRIEVAL))
        {
            // Need to set to low to allow access to such internal sites as:
            // http://msw, http://hrweb
            DWORD dwOptionFlag = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;

            if (!WinHttpSetOption(
                    hInetRequest,
                    WINHTTP_OPTION_AUTOLOGON_POLICY,
                    &dwOptionFlag,
                    sizeof(dwOptionFlag)
                   ))
            {
                DWORD dwLastErr = GetLastError();

                I_CryptNetDebugErrorPrintfA(
                    "CRYPTNET.DLL --> WinHttpSetOption(WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW) failed: %d (0x%x)\n",
                    dwLastErr, dwLastErr);
            }
        }
    }

    // If we didn't do autoproxy or if it failed, see
    // if there's an explicit proxy server in the IE
    // proxy configuration...
    //
    // This is where the WinHttpGetIEProxyConfigForCurrentUser API
    // really comes in handy: in environments in which autoproxy is
    // not supported and so the user's IE browser must be
    // configured with an explicit proxy server.
    //
    if (!fTryAutoProxy || !fSuccess) {
        if (IEProxyConfig.lpszProxy) {
            ProxyInfo.dwAccessType    = WINHTTP_ACCESS_TYPE_NAMED_PROXY;

            ProxyInfo.lpszProxy       = IEProxyConfig.lpszProxy;
            IEProxyConfig.lpszProxy   = NULL;

            ProxyInfo.lpszProxyBypass = IEProxyConfig.lpszProxyBypass;
            IEProxyConfig.lpszProxyBypass = NULL;
        }
    }

    I_CryptNetDebugTracePrintfA(
        "CRYPTNET.DLL --> ProxyInfo:: AccessType:%d Proxy:%S ProxyByPass:%S\n",
        ProxyInfo.dwAccessType,
        ProxyInfo.lpszProxy,
        ProxyInfo.lpszProxyBypass
        );

    if (NULL != ProxyInfo.lpszProxy) {
        //
        // Set the proxy on the session handle
        //
        fResult = WinHttpSetOption( hInetSession,
                           WINHTTP_OPTION_PROXY,
                           &ProxyInfo,
                           sizeof(ProxyInfo)
                           );

        if (fResult)
            //
            // Now set the proxy on the request handle.
            //
            fResult = WinHttpSetOption( hInetRequest,
                           WINHTTP_OPTION_PROXY,
                           &ProxyInfo,
                           sizeof(ProxyInfo)
                           );
    }

    if (IEProxyConfig.lpszAutoConfigUrl)
        GlobalFree(IEProxyConfig.lpszAutoConfigUrl);
    if (IEProxyConfig.lpszProxy)
        GlobalFree(IEProxyConfig.lpszProxy);
    if (IEProxyConfig.lpszProxyBypass)
        GlobalFree(IEProxyConfig.lpszProxyBypass);

    if (ProxyInfo.lpszProxy)
        GlobalFree(ProxyInfo.lpszProxy);
    if (ProxyInfo.lpszProxyBypass)
        GlobalFree(ProxyInfo.lpszProxyBypass);

    return fResult;
}

#endif


//+-------------------------------------------------------------------------
//  Handles all of the possible errors that WinHttp can return
//  when sending the request.
//--------------------------------------------------------------------------
BOOL
InetSendAuthenticatedRequestAndReceiveResponse(
    IN HINTERNET hInetSession,
    IN HINTERNET hInetRequest,
    IN LPCWSTR pwszUrl,
    IN DWORD dwRetrievalFlags,
    IN PCRYPT_CREDENTIALS pCredentials
    )
{
    BOOL fResult;
    DWORD dwLastError = 0;
    DWORD dwStatus = HTTP_STATUS_BAD_REQUEST;
    CRYPT_PASSWORD_CREDENTIALSW PasswordCredentials;
    BOOL fFreeCredentials = FALSE;
    LPWSTR pwszUserName = NULL;             // not allocated
    LPWSTR pwszPassword = NULL;             // not allocated

#define INET_MAX_RESEND_REQUEST_COUNT   5
    DWORD dwResendRequestCount = 0;

#define INET_SET_PROXY_OR_SERVER_CRED_STATE 0
#define INET_SET_ONLY_SERVER_CRED_STATE     1
#define INET_SET_NO_CRED_STATE              2
    DWORD dwSetCredState = INET_SET_NO_CRED_STATE;

#define INET_MAX_BAD_PROXY_COUNT        3
    DWORD dwBadProxyCount = 0;
    WINHTTP_PROXY_INFO *pProxyInfo = NULL;
    
    if (NULL != pCredentials) {
        memset( &PasswordCredentials, 0, sizeof( PasswordCredentials ) );
        PasswordCredentials.cbSize = sizeof( PasswordCredentials );

        if (!SchemeGetPasswordCredentialsW(
                pCredentials,
                &PasswordCredentials,
                &fFreeCredentials
                ))
            goto GetPasswordCredentialsError;

        pwszUserName = PasswordCredentials.pszUsername;
        pwszPassword = PasswordCredentials.pszPassword;

        dwSetCredState = INET_SET_PROXY_OR_SERVER_CRED_STATE;
    }

    if (!InetGetProxy(
            hInetSession,
            hInetRequest,
            pwszUrl,
            dwRetrievalFlags,
            &pProxyInfo
            ))
        goto GetProxyError;

    if (!InetSetProxy(
            hInetSession,
            hInetRequest,
            pProxyInfo
            ))
        goto SetProxyError;

    while (TRUE) {
        DWORD dwSizeofStatus;
        DWORD dwIndex;
        DWORD dwSetCredAuthTarget;

        if (!WinHttpSendRequest(
                hInetRequest,
                WINHTTP_NO_ADDITIONAL_HEADERS,      // pwszHeaders
                0,                                  // dwHeadersLength
                WINHTTP_NO_REQUEST_DATA,            // lpOptional
                0,                                  // dwOptionalLength
                0,                                  // dwTotalLength
                0                                   // dwContext
                )) {
            dwLastError = GetLastError();
            if (ERROR_WINHTTP_RESEND_REQUEST == dwLastError) {
                dwResendRequestCount++;
                if (INET_MAX_RESEND_REQUEST_COUNT < dwResendRequestCount)
                    goto ExceededMaxResendRequestCount;
                else
                    continue;
            } else if (InetIsPossibleBadProxy(dwLastError)) {
                dwBadProxyCount++;
                if (INET_MAX_BAD_PROXY_COUNT <= dwBadProxyCount)
                    goto ExceededMaxBadProxyCount;

                if (InetSetNextProxy(
                        hInetSession,
                        hInetRequest,
                        pProxyInfo
                        ))
                    continue;
            }

            goto WinHttpSendRequestError;
        }

        dwResendRequestCount = 0;

        if (!WinHttpReceiveResponse(
                hInetRequest,
                NULL                                // lpReserved
                ))
            goto WinHttpReceiveResponseError;

        if (I_CryptNetIsDebugTracePrintEnabled()) {
            for (DWORD i = 0; i < 2; i++) {
                BYTE rgbBuf[4096];
                DWORD cbBuf;
                DWORD dwInfo;

                memset(rgbBuf, 0, sizeof(rgbBuf));
                cbBuf = sizeof(rgbBuf);

                dwInfo = WINHTTP_QUERY_RAW_HEADERS_CRLF;
                if (0 == i)
                    dwInfo |= WINHTTP_QUERY_FLAG_REQUEST_HEADERS;

                dwIndex = 0;
                if (WinHttpQueryHeaders(
                        hInetRequest,
                        dwInfo,
                        WINHTTP_HEADER_NAME_BY_INDEX,   // pwszName OPTIONAL
                        rgbBuf,
                        &cbBuf,
                        &dwIndex
                        )) {
                    if (0 == i)
                        I_CryptNetDebugPrintfA(
                            "CRYPTNET.DLL --> Request Headers::\n");
                    else
                        I_CryptNetDebugPrintfA(
                            "CRYPTNET.DLL --> Response Headers::\n");

                    I_CryptNetDebugPrintfA("%S", rgbBuf);
                }
            }
        }

        dwSizeofStatus = sizeof( dwStatus );
        dwIndex = 0;
        if (!WinHttpQueryHeaders(
                hInetRequest,
                WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                WINHTTP_HEADER_NAME_BY_INDEX,   // pwszName OPTIONAL
                &dwStatus,
                &dwSizeofStatus,
                &dwIndex
                ))
            goto WinHttpQueryStatusCodeError;

        switch (dwStatus) {
            case HTTP_STATUS_OK:
                goto SuccessReturn;
                break;
            case HTTP_STATUS_PROXY_AUTH_REQ:
                if (INET_SET_PROXY_OR_SERVER_CRED_STATE < dwSetCredState)
                    goto BadHttpProxyAuthStatus;
                dwSetCredState = INET_SET_ONLY_SERVER_CRED_STATE;
                dwSetCredAuthTarget = WINHTTP_AUTH_TARGET_PROXY;
                break;
            case HTTP_STATUS_DENIED:
                if (INET_SET_ONLY_SERVER_CRED_STATE < dwSetCredState)
                    goto BadHttpServerAuthStatus;
                dwSetCredState = INET_SET_NO_CRED_STATE;
                dwSetCredAuthTarget = WINHTTP_AUTH_TARGET_SERVER;
                break;
            default:
                goto BadHttpStatus;
        }

        {
            DWORD dwSupportedSchemes = 0;
            DWORD dwPreferredScheme = 0;
            DWORD dwAuthTarget = 0;
            DWORD dwSetCredScheme;

            assert(HTTP_STATUS_PROXY_AUTH_REQ == dwStatus ||
                HTTP_STATUS_DENIED == dwStatus);

            if (!WinHttpQueryAuthSchemes(
                    hInetRequest,
                    &dwSupportedSchemes,
                    &dwPreferredScheme,
                    &dwAuthTarget
                    ))
                goto WinHttpQueryAuthSchemesError;

            if (dwAuthTarget != dwSetCredAuthTarget)
                goto InvalidQueryAuthTarget;

            if (dwSupportedSchemes & WINHTTP_AUTH_SCHEME_NEGOTIATE)
                dwSetCredScheme = WINHTTP_AUTH_SCHEME_NEGOTIATE;
            else if (dwSupportedSchemes & WINHTTP_AUTH_SCHEME_NTLM)
                dwSetCredScheme = WINHTTP_AUTH_SCHEME_NTLM;
            else
                goto UnsupportedAuthScheme;
            
            if (!WinHttpSetCredentials(
                    hInetRequest,
                    dwSetCredAuthTarget,
                    dwSetCredScheme,
                    pwszUserName,
                    pwszPassword,
                    NULL                                // pvAuthParams
                    ))
                goto WinHttpSetCredentialsError;
        }
    }

SuccessReturn:
    fResult = TRUE;

CommonReturn:
    PkiFree(pProxyInfo);

    if (fFreeCredentials)
        SchemeFreePasswordCredentialsW(&PasswordCredentials);

    SetLastError(dwLastError);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    dwLastError = GetLastError();
    goto CommonReturn;

TRACE_ERROR(GetPasswordCredentialsError)
TRACE_ERROR(GetProxyError)
TRACE_ERROR(SetProxyError)
TRACE_ERROR(ExceededMaxResendRequestCount)
TRACE_ERROR(ExceededMaxBadProxyCount)
TRACE_ERROR(WinHttpSendRequestError)
TRACE_ERROR(WinHttpReceiveResponseError)
TRACE_ERROR(WinHttpQueryStatusCodeError)
TRACE_ERROR(WinHttpQueryAuthSchemesError)
TRACE_ERROR(WinHttpSetCredentialsError)

SET_ERROR_VAR(BadHttpStatus, dwStatus)
SET_ERROR_VAR(BadHttpProxyAuthStatus, dwStatus)
SET_ERROR_VAR(BadHttpServerAuthStatus, dwStatus)
SET_ERROR_VAR(InvalidQueryAuthTarget, dwStatus)
SET_ERROR_VAR(UnsupportedAuthScheme, dwStatus)
}


//+---------------------------------------------------------------------------
//
//  Function:   InetSendReceiveUrlRequest
//
//  Synopsis:   synchronous processing of an URL via WinInet
//
//----------------------------------------------------------------------------
BOOL
InetSendReceiveUrlRequest (
    HINTERNET hInetSession,
    LPCWSTR pwszUrl,
    DWORD dwRetrievalFlags,
    PCRYPT_CREDENTIALS pCredentials,
    PCRYPT_BLOB_ARRAY pcba,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    )
{
    BOOL                        fResult;
    DWORD                       dwLastError = 0;
    HINTERNET                   hInetConnect = NULL;
    HINTERNET                   hInetRequest = NULL;;
    URL_COMPONENTS              UrlComponents;
	PCRYPTNET_CANCEL_BLOCK		pCancelBlock=NULL;
    LPCWSTR                     pwszEmpty = L"";
    LPWSTR                      pwszHostName = NULL;
    LPWSTR                      pwszUrlPathPlusExtraInfo = NULL;
    LPCWSTR                     rgpwszAcceptTypes[] = { L"*/*", NULL };
    DWORD                       dwOpenRequestFlags = 0;
    LPBYTE                      pb = NULL;
    ULONG                       cbRead;
    ULONG                       cb;
    DWORD                       dwMaxUrlRetrievalByteCount = 0; // 0 => no max
    BOOL                        fCacheBlob;

    if (pAuxInfo &&
            offsetof(CRYPT_RETRIEVE_AUX_INFO, dwMaxUrlRetrievalByteCount) <
                        pAuxInfo->cbSize)
        dwMaxUrlRetrievalByteCount = pAuxInfo->dwMaxUrlRetrievalByteCount;


    // Extract the HostName and UrlPath from the URL string

    memset( &UrlComponents, 0, sizeof( UrlComponents ) );
    UrlComponents.dwStructSize = sizeof( UrlComponents );
    UrlComponents.dwHostNameLength = (DWORD) -1;
    UrlComponents.dwUrlPathLength = (DWORD) -1;
    UrlComponents.dwExtraInfoLength = (DWORD) -1;

    if (!WinHttpCrackUrl(
            pwszUrl,
            0,         // dwUrlLength, 0 implies null terminated
            0,         // dwCanonicalizeFlags
            &UrlComponents
            ))
        goto WinHttpCrackUrlError;

    if (NULL == UrlComponents.lpszHostName) {
        UrlComponents.dwHostNameLength = 0;
        UrlComponents.lpszHostName = (LPWSTR) pwszEmpty;
    }

    if (NULL == UrlComponents.lpszUrlPath) {
        UrlComponents.dwUrlPathLength = 0;
        UrlComponents.lpszUrlPath = (LPWSTR) pwszEmpty;
    }

    if (NULL == UrlComponents.lpszExtraInfo) {
        UrlComponents.dwExtraInfoLength = 0;
        UrlComponents.lpszExtraInfo = (LPWSTR) pwszEmpty;
    }

    pwszHostName = (LPWSTR) PkiNonzeroAlloc(
        (UrlComponents.dwHostNameLength + 1) * sizeof(WCHAR));
    pwszUrlPathPlusExtraInfo = (LPWSTR) PkiNonzeroAlloc(
        (UrlComponents.dwUrlPathLength +
            UrlComponents.dwExtraInfoLength + 1) * sizeof(WCHAR));

    if (NULL == pwszHostName || NULL == pwszUrlPathPlusExtraInfo)
        goto OutOfMemory;

    memcpy(pwszHostName, UrlComponents.lpszHostName,
        UrlComponents.dwHostNameLength * sizeof(WCHAR));
    pwszHostName[UrlComponents.dwHostNameLength] = L'\0';

    memcpy(pwszUrlPathPlusExtraInfo, UrlComponents.lpszUrlPath,
        UrlComponents.dwUrlPathLength * sizeof(WCHAR));
    memcpy(pwszUrlPathPlusExtraInfo + UrlComponents.dwUrlPathLength,
        UrlComponents.lpszExtraInfo,
        UrlComponents.dwExtraInfoLength * sizeof(WCHAR));
    pwszUrlPathPlusExtraInfo[
        UrlComponents.dwUrlPathLength +
            UrlComponents.dwExtraInfoLength] = L'\0';

    hInetConnect = WinHttpConnect(
        hInetSession,
        pwszHostName,
        UrlComponents.nPort,
        0                         // dwReserved
        );
    if (NULL == hInetConnect)
        goto WinHttpConnectError;

    if ( !(dwRetrievalFlags & CRYPT_AIA_RETRIEVAL) ) {
        dwOpenRequestFlags |= WINHTTP_FLAG_BYPASS_PROXY_CACHE;
    }

    hInetRequest = WinHttpOpenRequest(
        hInetConnect,
        NULL,                           // pwszVerb, NULL implies GET
        pwszUrlPathPlusExtraInfo,       // pwszObjectName
        NULL,                           // pwszVersion, NULL implies HTTP/1.1
        WINHTTP_NO_REFERER,             // pwszReferrer
        rgpwszAcceptTypes,
        dwOpenRequestFlags
        );
    if (NULL == hInetRequest)
        goto WinHttpOpenRequestError;

    if (dwRetrievalFlags & CRYPT_NO_AUTH_RETRIEVAL) {
        DWORD dwOptionFlag;

        dwOptionFlag = WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH;
        if (!WinHttpSetOption(
                hInetRequest,
                WINHTTP_OPTION_AUTOLOGON_POLICY,
                &dwOptionFlag,
                sizeof(dwOptionFlag)
                ))
            goto SetAutoLogonSecurityOptionError;

        dwOptionFlag = WINHTTP_DISABLE_AUTHENTICATION;
        if (!WinHttpSetOption(
                hInetRequest,
                WINHTTP_OPTION_DISABLE_FEATURE,
                &dwOptionFlag,
                sizeof(dwOptionFlag)
                ))
            goto SetDisableAuthenticationOptionError;
    }


#if 0
    if (!OLD_InetSetProxy(hInetSession, hInetRequest, pwszUrl, dwRetrievalFlags))
        goto SetProxyError;
#endif

    if (!InetSendAuthenticatedRequestAndReceiveResponse(
            hInetSession,
            hInetRequest,
            pwszUrl,
            dwRetrievalFlags,
            pCredentials
            ))
        goto InetSendAuthenticatedRequestAndReceiveResponseError;

    cbRead = 0;
    cb = INET_INITIAL_DATA_BUFFER_SIZE;
    pb = CCryptBlobArray::AllocBlob( cb );
    if (NULL == pb)
        goto OutOfMemory;

	pCancelBlock=(PCRYPTNET_CANCEL_BLOCK)I_CryptGetTls(hCryptNetCancelTls);

    while (TRUE) {
        ULONG                       cbData;
        ULONG                       cbPerRead;

		if (pCancelBlock) {
			if (pCancelBlock->pfnCancel(0, pCancelBlock->pvArg))
                goto CanceledRead;

        }

        cbData = 0;
        if (!WinHttpQueryDataAvailable(hInetRequest, &cbData) || 0 == cbData)
            break;

        if (0 != dwMaxUrlRetrievalByteCount  &&
                (cbRead + cbData) > dwMaxUrlRetrievalByteCount) {
            I_CryptNetDebugErrorPrintfA(
                "CRYPTNET.DLL --> Exceeded MaxUrlRetrievalByteCount for: %S\n",
                pwszUrl);
            goto ExceededMaxUrlRetrievalByteCount;
        }

        if (cb < (cbRead + cbData)) {
            BYTE *pbRealloc;

            pbRealloc = CCryptBlobArray::ReallocBlob(
                pb,
                cb + cbData + INET_GROW_DATA_BUFFER_SIZE
                );
            if (NULL == pbRealloc)
                goto OutOfMemory;

            pb = pbRealloc;
            cb += cbData + INET_GROW_DATA_BUFFER_SIZE;
        }

        cbPerRead = 0;
        if (!WinHttpReadData(
                hInetRequest,
                pb+cbRead,
                cbData,
                &cbPerRead
                ))
            goto WinHttpReadDataError;

        cbRead += cbPerRead;
    }

    {
        fResult = TRUE;
        CCryptBlobArray cba( 1, 1, fResult );

        if (fResult)
            fResult = cba.AddBlob( cbRead, pb, FALSE );

        if (fResult)
            cba.GetArrayInNativeForm(pcba);
        else {
            cba.FreeArray( FALSE );
            goto OutOfMemory;
        }
    }

    fCacheBlob = FALSE;

    if ( !( dwRetrievalFlags & CRYPT_DONT_CACHE_RESULT ) ) {
        if ( dwRetrievalFlags & CRYPT_AIA_RETRIEVAL ) {
            assert(0 < pcba->cBlob);

            // Only cache if we are able to decode it.
            fCacheBlob = CryptQueryObject(
                CERT_QUERY_OBJECT_BLOB,
                (const void *) &(pcba->rgBlob[0]),
                CERT_QUERY_CONTENT_FLAG_CERT |
                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                    CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
                CERT_QUERY_FORMAT_FLAG_ALL,
                0,      // dwFlags
                NULL,   // pdwMsgAndCertEncodingType
                NULL,   // pdwContentType
                NULL,   // pdwFormatType
                NULL,   // phCertStore
                NULL,   // phMsg
                NULL    // ppvContext
                );

            if (!fCacheBlob) {
                I_CryptNetDebugErrorPrintfA(
                    "CRYPTNET.DLL --> Invalid AIA content, no caching: %S\n",
                    pwszUrl);
            }
        } else {
            fCacheBlob = TRUE;
        }

        if (fCacheBlob)
            fCacheBlob = SchemeCacheCryptBlobArray(
                pwszUrl,
                dwRetrievalFlags,
                pcba,
                pAuxInfo
                );
    }

    if (!fCacheBlob) {
        if (!SchemeRetrieveUncachedAuxInfo(pAuxInfo))
            goto RetrieveUncachedAuxInfoError;
    }

    fResult = TRUE;

CommonReturn:
    WinHttpCloseHandle(hInetRequest);
    WinHttpCloseHandle(hInetConnect);

    PkiFree(pwszHostName);
    PkiFree(pwszUrlPathPlusExtraInfo);

    SetLastError(dwLastError);
    return fResult;
ErrorReturn:
    if (NULL != pb)
        CCryptBlobArray::FreeBlob(pb);
    dwLastError = GetLastError();


    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(WinHttpCrackUrlError)
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
TRACE_ERROR(WinHttpConnectError)
TRACE_ERROR(WinHttpOpenRequestError)
TRACE_ERROR(SetAutoLogonSecurityOptionError)
TRACE_ERROR(SetDisableAuthenticationOptionError)
TRACE_ERROR(InetSendAuthenticatedRequestAndReceiveResponseError)
SET_ERROR(CanceledRead, ERROR_CANCELLED)
SET_ERROR(ExceededMaxUrlRetrievalByteCount, ERROR_INVALID_DATA)
TRACE_ERROR(WinHttpReadDataError)
TRACE_ERROR(RetrieveUncachedAuxInfoError)

}

//+---------------------------------------------------------------------------
//
//  Function:   InetFreeCryptBlobArray
//
//  Synopsis:   free the crypt blob array
//
//----------------------------------------------------------------------------
VOID
InetFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba
    )
{
    CCryptBlobArray cba( pcba, 0 );

    cba.FreeArray( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetAsyncStatusCallback
//
//  Synopsis:   status callback for async
//
//----------------------------------------------------------------------------
VOID WINAPI
InetAsyncStatusCallback (
    HINTERNET hInet,
    DWORD dwContext,
    DWORD dwInternetStatus,
    LPVOID pvStatusInfo,
    DWORD dwStatusLength
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\ldapstor.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ldapstor.h
//
//  Contents:   LDAP Certificate Store Provider definitions
//
//  History:    16-Oct-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#if !defined(__LDAPSTOR_H__)
#define __LDAPSTOR_H__

#include <ldapsp.h>
#define SECURITY_WIN32
#include <security.h>

//
// Store provider open store function name
//

#define LDAP_OPEN_STORE_PROV_FUNC "LdapProvOpenStore"

//
// BERVAL array definitions
//

#define MIN_BERVAL  10
#define GROW_BERVAL 50

//
// User DS Store URL format
//

#define USER_DS_STORE_URL_PREFIX        L"ldap:///"
#define USER_DS_STORE_URL_SEPARATOR     L"?"

//
// Store timeout (15 seconds)
//

#define LDAP_STORE_TIMEOUT 15000

//
// GetUserNameExA function pointer prototype
//

typedef BOOLEAN (SEC_ENTRY *PFN_GETUSERNAMEEXW) (
                                EXTENDED_NAME_FORMAT NameFormat,
                                LPWSTR lpNameBuffer,
                                PULONG nSize
                                );

//
// CLdapStore.  This class implements all callbacks for the Ldap Store
// provider.  A pointer to an instance of this class is used as the hStoreProv
// parameter for the callback functions implemented
//

class CLdapStore
{
public:

    //
    // Construction
    //

    CLdapStore (
             OUT BOOL& rfResult
             );
    ~CLdapStore ();

    //
    // Store functions
    //

    BOOL OpenStore (
             LPCSTR pszStoreProv,
             DWORD dwMsgAndCertEncodingType,
             HCRYPTPROV hCryptProv,
             DWORD dwFlags,
             const void* pvPara,
             HCERTSTORE hCertStore,
             PCERT_STORE_PROV_INFO pStoreProvInfo
             );

    VOID CloseStore (DWORD dwFlags);

    BOOL DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL DeleteCrl (PCCRL_CONTEXT pCrlContext, DWORD dwFlags);

    BOOL DeleteCtl (PCCTL_CONTEXT pCtlContext, DWORD dwFlags);

    BOOL SetCertProperty (
            PCCERT_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL SetCrlProperty (
            PCCRL_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL SetCtlProperty (
            PCCTL_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL WriteCrl (PCCRL_CONTEXT pCertContext, DWORD dwFlags);

    BOOL WriteCtl (PCCTL_CONTEXT pCertContext, DWORD dwFlags);

    BOOL StoreControl (DWORD dwFlags, DWORD dwCtrlType, LPVOID pvCtrlPara);

    BOOL Commit (DWORD dwFlags);

    BOOL Resync ();

private:

    //
    // Object lock
    //

    CRITICAL_SECTION    m_StoreLock;

    //
    // LDAP URL
    //

    LDAP_URL_COMPONENTS m_UrlComponents;

    //
    // LDAP binding
    //

    LDAP*               m_pBinding;

    //
    // Cache store reference
    //

    HCERTSTORE          m_hCacheStore;

    //
    // Open Store flags
    //

    DWORD               m_dwOpenFlags;

    //
    // Dirty flag
    //

    BOOL                m_fDirty;

    //
    // Private methods
    //

    BOOL FillCacheStore (BOOL fClearCache);

    BOOL InternalCommit (DWORD dwFlags);

    BOOL WriteCheckSetDirtyWithLock (
              LPCSTR pszContextOid,
              LPVOID pvContext,
              DWORD dwFlags
              );
};

//
// Ldap Store Provider functions
//

BOOL WINAPI LdapProvOpenStore (
                IN LPCSTR pszStoreProv,
                IN DWORD dwMsgAndCertEncodingType,
                IN HCRYPTPROV hCryptProv,
                IN DWORD dwFlags,
                IN const void* pvPara,
                IN HCERTSTORE hCertStore,
                IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                );

void WINAPI LdapProvCloseStore (
                IN HCERTSTOREPROV hStoreProv,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvDeleteCert (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvDeleteCrl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvDeleteCtl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvSetCertProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                );

BOOL WINAPI LdapProvSetCrlProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                );

BOOL WINAPI LdapProvSetCtlProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                );

BOOL WINAPI LdapProvWriteCert (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvWriteCrl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvWriteCtl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvStoreControl (
                IN HCERTSTOREPROV hStoreProv,
                IN DWORD dwFlags,
                IN DWORD dwCtrlType,
                IN LPVOID pvCtrlPara
                );

//
// Ldap Store Provider Function table
//

static void* const rgpvLdapProvFunc[] = {

    // CERT_STORE_PROV_CLOSE_FUNC              0
    LdapProvCloseStore,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    NULL,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    LdapProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    LdapProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    LdapProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    NULL,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    LdapProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    LdapProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    LdapProvSetCrlProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    NULL,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    LdapProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    LdapProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    LdapProvSetCtlProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    LdapProvStoreControl
};

#define LDAP_PROV_FUNC_COUNT (sizeof(rgpvLdapProvFunc) / \
                              sizeof(rgpvLdapProvFunc[0]))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\octxutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       octxutil.h
//
//  Contents:   General Object Context Utility definitions and prototypes
//
//  History:    29-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__OCTXUTIL_H__)
#define __OCTXUTIL_H__

#include <origin.h>

#define MAX_HASH_SIZE 20

BOOL WINAPI
ObjectContextGetOriginIdentifier (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pIssuer,
      IN DWORD dwFlags,
      OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
      );


typedef struct _CRL_IS_VALID_EXTRA_INFO {
    // If > 0, check that the CRL's number is >=
    int                     iDeltaCrlIndicator;
} CRL_IS_VALID_EXTRA_INFO, *PCRL_IS_VALID_EXTRA_INFO;

BOOL WINAPI
ObjectContextIsValidForSubject (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN LPVOID pvSubject,
      IN OPTIONAL LPVOID pvExtraInfo
      );


PCERT_EXTENSION WINAPI
ObjectContextFindExtension (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN LPCSTR pszExtOid
      );

BOOL WINAPI
ObjectContextGetProperty (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD dwPropId,
      IN LPVOID pvData,
      IN DWORD* pcbData
      );

BOOL WINAPI
ObjectContextGetAttribute (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszAttrOid,
      IN PCRYPT_ATTRIBUTE pAttribute,
      IN OUT DWORD* pcbAttribute
      );

LPVOID WINAPI
ObjectContextDuplicate (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      );

BOOL WINAPI
ObjectContextCreate (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT LPVOID* ppvContext
      );

BOOL WINAPI
ObjectContextGetCreateAndExpireTimes (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT LPFILETIME pftCreateTime,
      OUT LPFILETIME pftExpireTime
      );

BOOL WINAPI
ObjectContextGetNextUpdateUrl (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pIssuer,
      IN LPWSTR pwszUrlHint,
      OUT PCRYPT_URL_ARRAY* ppUrlArray,
      OUT DWORD* pcbUrlArray,
      OUT DWORD* pPreferredUrlIndex,
      OUT OPTIONAL BOOL* pfHintInArray
      );

VOID WINAPI
ObjectContextFree (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      );

BOOL WINAPI
ObjectContextVerifySignature (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pSigner
      );

BOOL WINAPI
MapOidToPropertyId (
   IN LPCSTR pszOid,
   OUT DWORD* pPropId
   );

// If ppszContextOid is nonNULL, will advance on to next pszContextOid
LPVOID WINAPI
ObjectContextEnumObjectsInStore (
      IN HCERTSTORE hStore,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT OPTIONAL LPCSTR* ppszContextOid = NULL
      );

VOID WINAPI
ObjectContextGetEncodedBits (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT DWORD* pcbEncoded,
      OUT LPBYTE* ppbEncoded
      );

LPVOID WINAPI
ObjectContextFindCorrespondingObject (
      IN HCERTSTORE hStore,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      );

BOOL WINAPI
ObjectContextDeleteAllObjectsFromStore (
      IN HCERTSTORE hStore
      );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\msctl.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:	    msctl.cpp
//
//  Contents:   Default version of CertDllVerifyCTLUsage.
//
//              Default implementation:
//              - If CtlStores are specified, then, only those stores are
//                searched to find a CTL with the specified usage and optional
//                ListIdentifier.  Otherwise, the "Trust" system store is
//                searched to find a CTL.
//              - If CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, then, only the
//                SignerStores are searched to find the certificate
//                corresponding to the signer's issuer and serial number.
//                Otherwise, the CTL message's store, SignerStores,
//                "Trust" system store, "CA" system store, "ROOT" and "SPC"
//                system stores are searched to find the signer's certificate.
//                In either case, the public key in the found
//                certificate is used to verify the CTL's signature.
//              - If the CTL has a NextUpdate and
//                CERT_VERIFY_NO_TIME_CHECK_FLAG isn't set, then its
//                verified for time validity.
//              - If the CTL is time invalid, then, attempts to
//                get a time valid version. Uses either the CTL's
//                NextUpdateLocation property or CTL's NextUpdateLocation
//                extension or searches the signer's info for a
//                NextUpdateLocation attribute. The NextUpdateLocation
//                is encoded as a GeneralNames. Any non-URL name choices are
//                skipped.
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              CertDllVerifyCTLUsage
//
//  History:	29-Apr-97   philh   created
//              09-Oct-97   kirtd   simplification, use CryptGetTimeValidObject
//--------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

#define MSCTL_TIMEOUT 15000
//+-------------------------------------------------------------------------
// Default stores searched to find a CTL or signer
//--------------------------------------------------------------------------

// The CTL stores must be at the beginning. CTL stores are opened as
// READ/WRITE. Remaining stores are opened READONLY.
//
// CTL stores are also searched for signers.
static const struct {
    LPCWSTR     pwszStore;
    DWORD       dwFlags;
} rgDefaultStoreInfo[] = {
    L"TRUST",       CERT_SYSTEM_STORE_CURRENT_USER,
    L"CA",          CERT_SYSTEM_STORE_CURRENT_USER,
    L"ROOT",        CERT_SYSTEM_STORE_CURRENT_USER,
    L"SPC",         CERT_SYSTEM_STORE_LOCAL_MACHINE
};
#define NUM_DEFAULT_STORES          (sizeof(rgDefaultStoreInfo) / \
                                        sizeof(rgDefaultStoreInfo[0]))
#define NUM_DEFAULT_CTL_STORES      1
#define NUM_DEFAULT_SIGNER_STORES   NUM_DEFAULT_STORES
//+-------------------------------------------------------------------------
// The following HCERTSTORE handles once opened, remain open until
// ProcessDetach
//--------------------------------------------------------------------------
static HCERTSTORE rghDefaultStore[NUM_DEFAULT_STORES];
static BOOL fOpenedDefaultStores;
extern CRITICAL_SECTION MSCtlDefaultStoresCriticalSection;

//+-------------------------------------------------------------------------
//  Close the default stores that might have been opened
//--------------------------------------------------------------------------
void MSCtlCloseDefaultStores()
{
    if (fOpenedDefaultStores) {
        DWORD i;
        for (i = 0; i < NUM_DEFAULT_STORES; i++) {
            HCERTSTORE hStore = rghDefaultStore[i];
            if (hStore)
                CertCloseStore(hStore, 0);
        }
        fOpenedDefaultStores = FALSE;
    }
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the CTL is still time valid.
//
//  A CTL without a NextUpdate is considered time valid.
//--------------------------------------------------------------------------
static BOOL IsTimeValidCtl(
    IN LPFILETIME pTimeToVerify,
    IN PCCTL_CONTEXT pCtl
    )
{
    PCTL_INFO pCtlInfo = pCtl->pCtlInfo;

    // Note, NextUpdate is optional. When not present, its set to 0
    if ((0 == pCtlInfo->NextUpdate.dwLowDateTime &&
                0 == pCtlInfo->NextUpdate.dwHighDateTime) ||
            CompareFileTime(&pCtlInfo->NextUpdate, pTimeToVerify) >= 0)
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//  Local functions called by CertDllVerifyCTLUsage
//--------------------------------------------------------------------------
static void MSCtlOpenDefaultStores();

static BOOL VerifyCtl(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwFlags,
    IN PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    OUT PCCERT_CONTEXT *ppSigner,
    OUT DWORD *pdwSignerIndex
    );

static BOOL GetTimeValidCtl(
    IN LPFILETIME pCurrentTime,
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwFlags,
    IN PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    OUT PCCTL_CONTEXT *ppValidCtl,
    IN OUT PCCERT_CONTEXT *ppSigner,
    IN OUT DWORD *pdwSignerIndex
    );

static PCCTL_CONTEXT ReplaceCtl(
    IN HCERTSTORE hStore,
    IN PCCTL_CONTEXT pOrigCtl,
    IN PCCTL_CONTEXT pValidCtl
    );

static BOOL CompareCtlUsage(
    IN DWORD dwFindFlags,
    IN PCTL_FIND_USAGE_PARA pPara,
    IN PCCTL_CONTEXT pCtl
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;

    if ((CTL_FIND_SAME_USAGE_FLAG & dwFindFlags) &&
            pPara->SubjectUsage.cUsageIdentifier !=
                pInfo->SubjectUsage.cUsageIdentifier)
        return FALSE;
    if (pPara->SubjectUsage.cUsageIdentifier) {
        DWORD cId1 = pPara->SubjectUsage.cUsageIdentifier;
        LPSTR *ppszId1 = pPara->SubjectUsage.rgpszUsageIdentifier;
        for ( ; cId1 > 0; cId1--, ppszId1++) {
            DWORD cId2 = pInfo->SubjectUsage.cUsageIdentifier;
            LPSTR *ppszId2 = pInfo->SubjectUsage.rgpszUsageIdentifier;
            for ( ; cId2 > 0; cId2--, ppszId2++) {
                if (0 == strcmp(*ppszId1, *ppszId2))
                    break;
            }
            if (0 == cId2)
                return FALSE;
        }
    }

    if (pPara->ListIdentifier.cbData) {
        DWORD cb = pPara->ListIdentifier.cbData;
        if (CTL_FIND_NO_LIST_ID_CBDATA == cb)
            cb = 0;
        if (cb != pInfo->ListIdentifier.cbData)
            return FALSE;
        if (0 != cb && 0 != memcmp(pPara->ListIdentifier.pbData,
                pInfo->ListIdentifier.pbData, cb))
            return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Default version of CertDllVerifyCTLUsage
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDllVerifyCTLUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwError = (DWORD) CRYPT_E_NO_VERIFY_USAGE_CHECK;
    DWORD cCtlStore;
    HCERTSTORE *phCtlStore;             // not allocated or reference counted
    FILETIME CurrentTime;
    CTL_FIND_USAGE_PARA FindUsagePara;
    DWORD dwFindFlags;
    PCCTL_CONTEXT pValidCtl;
    PCCERT_CONTEXT pSigner;
    PCTL_ENTRY pEntry;
    DWORD dwSignerIndex;

    assert(NULL == pVerifyUsagePara || pVerifyUsagePara->cbSize >=
        sizeof(CTL_VERIFY_USAGE_PARA));
    assert(pVerifyUsageStatus && pVerifyUsageStatus->cbSize >=
        sizeof(CTL_VERIFY_USAGE_STATUS));

    if (pVerifyUsagePara && pVerifyUsagePara->cCtlStore > 0) {
        cCtlStore = pVerifyUsagePara->cCtlStore;
        phCtlStore = pVerifyUsagePara->rghCtlStore;
    } else {
        MSCtlOpenDefaultStores();
        dwFlags &= ~CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG;
        cCtlStore = NUM_DEFAULT_CTL_STORES;
        phCtlStore = rghDefaultStore;
    }

    // Get current time to be used to determine if CTLs are time valid
    {
        SYSTEMTIME SystemTime;
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &CurrentTime);
    }

    memset(&FindUsagePara, 0, sizeof(FindUsagePara));
    FindUsagePara.cbSize = sizeof(FindUsagePara);
    dwFindFlags = 0;
    if (pSubjectUsage) {
        FindUsagePara.SubjectUsage = *pSubjectUsage;
        if (0 == (CERT_VERIFY_ALLOW_MORE_USAGE_FLAG & dwFlags))
            dwFindFlags = CTL_FIND_SAME_USAGE_FLAG;
    }
    if (pVerifyUsagePara)
        FindUsagePara.ListIdentifier = pVerifyUsagePara->ListIdentifier;

    for ( ; ( cCtlStore > 0 ) && ( dwError != 0 ); cCtlStore--, phCtlStore++)
    {
        HCERTSTORE hCtlStore = *phCtlStore;
        PCCTL_CONTEXT pCtl;

        if (NULL == hCtlStore)
            continue;

        pCtl = NULL;
        while ( ( pCtl = CertFindCTLInStore(
                             hCtlStore,
                             dwEncodingType,
                             dwFindFlags,
                             CTL_FIND_USAGE,
                             &FindUsagePara,
                             pCtl
                             ) ) )
        {
            pValidCtl = NULL;
            pSigner = NULL;
            pEntry = NULL;
            dwSignerIndex = 0;

            if ( ( fResult = VerifyCtl(
                                   pCtl,
                                   dwFlags,
                                   pVerifyUsagePara,
                                   &pSigner,
                                   &dwSignerIndex
                                   ) ) == TRUE )
            {
                if ( !( dwFlags & CERT_VERIFY_NO_TIME_CHECK_FLAG ) &&
                      ( IsTimeValidCtl( &CurrentTime, pCtl ) == FALSE ) )
                {
                    fResult = GetTimeValidCtl(
                                 &CurrentTime,
                                 pCtl,
                                 dwFlags,
                                 pVerifyUsagePara,
                                 &pValidCtl,
                                 &pSigner,
                                 &dwSignerIndex
                                 );

                    if ( fResult == TRUE )
                    {
                        if ( !( dwFlags & CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG ) )
                        {
                            pValidCtl = ReplaceCtl( hCtlStore, pCtl, pValidCtl );
                            pVerifyUsageStatus->dwFlags |= CERT_VERIFY_UPDATED_CTL_FLAG;
                        }

                        fResult =  CompareCtlUsage(
                                          dwFindFlags,
                                          &FindUsagePara,
                                          pValidCtl
                                          );
                    }
                    else
                    {
                        dwError = (DWORD) CRYPT_E_VERIFY_USAGE_OFFLINE;
                    }
                }

                if ( fResult == TRUE )
                {
                    PCCTL_CONTEXT pCtlToUse;

                    if ( pValidCtl != NULL )
                    {
                        pCtlToUse = CertDuplicateCTLContext( pValidCtl );
                    }
                    else
                    {
                        pCtlToUse = CertDuplicateCTLContext( pCtl );
                    }

                    pEntry = CertFindSubjectInCTL(
                                 dwEncodingType,
                                 dwSubjectType,
                                 pvSubject,
                                 pCtlToUse,
                                 0
                                 );

                    if ( pEntry != NULL )
                    {
                        pVerifyUsageStatus->dwCtlEntryIndex =
                            (DWORD)(pEntry - pCtlToUse->pCtlInfo->rgCTLEntry);

                        if ( pVerifyUsageStatus->ppCtl != NULL )
                        {
                            *pVerifyUsageStatus->ppCtl = pCtlToUse;
                        }
                        else
                        {
                            CertFreeCTLContext( pCtlToUse );
                        }

                        pVerifyUsageStatus->dwSignerIndex = dwSignerIndex;

                        if ( pVerifyUsageStatus->ppSigner != NULL )
                        {
                            *pVerifyUsageStatus->ppSigner =
                                    CertDuplicateCertificateContext( pSigner );
                        }

                        dwError = 0;
                    }
                    else
                    {
                        dwError = (DWORD) CRYPT_E_NOT_IN_CTL;
                        CertFreeCTLContext( pCtlToUse );
                    }
                }
            }
            else
            {
                dwError = (DWORD) CRYPT_E_NO_TRUSTED_SIGNER;
            }

            if ( pValidCtl != NULL )
            {
                CertFreeCTLContext( pValidCtl );
            }

            if ( pSigner != NULL )
            {
                CertFreeCertificateContext( pSigner );
            }

            if ( dwError == 0 ) {
                CertFreeCTLContext(pCtl);
                break;
            }
        }
    }

    if ( dwError != 0 )
    {
        fResult = FALSE;
    }

    pVerifyUsageStatus->dwError = dwError;
    SetLastError( dwError );

    return fResult;
}

//+=========================================================================
//  Open default stores functions
//==========================================================================

static const CRYPT_OID_FUNC_ENTRY UsageFuncTable[] = {
    CRYPT_DEFAULT_OID, CertDllVerifyCTLUsage
};
#define USAGE_FUNC_COUNT (sizeof(UsageFuncTable) / sizeof(UsageFuncTable[0]))

//+-------------------------------------------------------------------------
//  Open the default stores used to find the CTL or signer. Also, install
//  ourself so we aren't unloaded.
//
//  Open and install are only done once.
//--------------------------------------------------------------------------
static void MSCtlOpenDefaultStores()
{
    if (fOpenedDefaultStores)
        return;

    assert(NUM_DEFAULT_STORES >= NUM_DEFAULT_CTL_STORES);
    assert(NUM_DEFAULT_STORES >= NUM_DEFAULT_SIGNER_STORES);

    EnterCriticalSection(&MSCtlDefaultStoresCriticalSection);
    if (!fOpenedDefaultStores) {
        DWORD i;

        for (i = 0; i < NUM_DEFAULT_STORES; i++) {
            DWORD dwFlags;

            dwFlags = rgDefaultStoreInfo[i].dwFlags;
            if (i >= NUM_DEFAULT_CTL_STORES)
                dwFlags |= CERT_STORE_READONLY_FLAG;
            rghDefaultStore[i] = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    0,                          // dwEncodingType
                    0,                          // hCryptProv
                    dwFlags,
                    (const void *) rgDefaultStoreInfo[i].pwszStore
                    );
        }

        fOpenedDefaultStores = TRUE;
    }
    LeaveCriticalSection(&MSCtlDefaultStoresCriticalSection);
}

//+=========================================================================
//  Verify and replace CTL functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Verifies the signature of the CTL.
//--------------------------------------------------------------------------
static BOOL VerifyCtl(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwFlags,
    IN PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    OUT PCCERT_CONTEXT *ppSigner,
    OUT DWORD *pdwSignerIndex
    )
{
    BOOL fResult;
    DWORD cParaStore;
    HCERTSTORE *phParaStore;  // not allocated or reference counted

    DWORD cStore;
    HCERTSTORE *phStore = NULL;
    HCERTSTORE *phAllocStore = NULL;
    DWORD dwGetFlags;

    if (pVerifyUsagePara) {
        cParaStore = pVerifyUsagePara->cSignerStore;
        phParaStore = pVerifyUsagePara->rghSignerStore;
    } else {
        cParaStore = 0;
        phParaStore = NULL;
    }

    if (dwFlags & CERT_VERIFY_TRUSTED_SIGNERS_FLAG) {
        cStore = cParaStore;
        phStore = phParaStore;
        dwGetFlags = CMSG_TRUSTED_SIGNER_FLAG;
    } else {
        MSCtlOpenDefaultStores();

        if (cParaStore) {
            cStore = cParaStore + NUM_DEFAULT_SIGNER_STORES;
            if (NULL == (phAllocStore = (HCERTSTORE *) PkiNonzeroAlloc(
                    cStore * sizeof(HCERTSTORE))))
                goto OutOfMemory;
            phStore = phAllocStore;

            memcpy(phStore, phParaStore, cParaStore * sizeof(HCERTSTORE));
            memcpy(&phStore[cParaStore], rghDefaultStore,
                NUM_DEFAULT_SIGNER_STORES * sizeof(HCERTSTORE));
        } else {
            cStore = NUM_DEFAULT_SIGNER_STORES;
            phStore = rghDefaultStore;
        }

        dwGetFlags = 0;
    }

    fResult = CryptMsgGetAndVerifySigner(
            pCtl->hCryptMsg,
            cStore,
            phStore,
            dwGetFlags,
            ppSigner,
            pdwSignerIndex);

CommonReturn:
    PkiFree(phAllocStore);
    return fResult;

ErrorReturn:
    *ppSigner = NULL;
    *pdwSignerIndex = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


//+-------------------------------------------------------------------------
//  Replaces the CTL in the store. Copies over any original properties.
//--------------------------------------------------------------------------
static PCCTL_CONTEXT ReplaceCtl(
    IN HCERTSTORE hStore,
    IN PCCTL_CONTEXT pOrigCtl,
    IN PCCTL_CONTEXT pValidCtl
    )
{
    PCCTL_CONTEXT pNewCtl;

    if (CertAddCTLContextToStore(
            hStore,
            pValidCtl,
            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
            &pNewCtl))
        CertFreeCTLContext(pValidCtl);
    else
        pNewCtl = pValidCtl;

    return pNewCtl;
}

//+=========================================================================
//  Get time valid CTL via URL obtained from old CTL's NextUpdateLocation
//  property, extension or signer attribute.
//==========================================================================
static BOOL GetTimeValidCtl(
    IN LPFILETIME pCurrentTime,
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwFlags,
    IN PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    OUT PCCTL_CONTEXT *ppValidCtl,
    IN OUT PCCERT_CONTEXT *ppSigner,
    IN OUT DWORD *pdwSignerIndex
    )
{
    BOOL fResult;

    *ppValidCtl = NULL;

    fResult = CryptGetTimeValidObject(
                   TIME_VALID_OID_GET_CTL,
                   (LPVOID)pCtl,
                   *ppSigner,
                   pCurrentTime,
                   0,
                   MSCTL_TIMEOUT,
                   (LPVOID *)ppValidCtl,
                   NULL,
                   NULL
                   );

    if ( fResult == FALSE )
    {
        fResult = CryptGetTimeValidObject(
                       TIME_VALID_OID_GET_CTL,
                       (LPVOID)pCtl,
                       *ppSigner,
                       pCurrentTime,
                       CRYPT_DONT_VERIFY_SIGNATURE,
                       MSCTL_TIMEOUT,
                       (LPVOID *)ppValidCtl,
                       NULL,
                       NULL
                       );

        if ( fResult == TRUE )
        {
            DWORD          dwSignerIndex = *pdwSignerIndex;
            PCCERT_CONTEXT pSigner = *ppSigner;

            fResult = VerifyCtl(
                            *ppValidCtl,
                            dwFlags,
                            pVerifyUsagePara,
                            ppSigner,
                            pdwSignerIndex
                            );

            if ( fResult == TRUE )
            {
                CertFreeCertificateContext( pSigner );
            }
            else
            {
                *pdwSignerIndex = dwSignerIndex;
                *ppSigner = pSigner;

                CertFreeCTLContext( *ppValidCtl );
                SetLastError( (DWORD) CRYPT_E_NO_TRUSTED_SIGNER );
            }
        }
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\octxutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       octxutil.cpp
//
//  Contents:   General Object Context Utility Function implemention
//
//  History:    29-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetOriginIdentifier
//
//  Synopsis:   get origin identifier for a CAPI2 object
//
//----------------------------------------------------------------------------
BOOL WINAPI ObjectContextGetOriginIdentifier (
                  IN LPCSTR pszContextOid,
                  IN LPVOID pvContext,
                  IN PCCERT_CONTEXT pIssuer,
                  IN DWORD dwFlags,
                  OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                  )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        return( CertGetOriginIdentifier(
                    (PCCERT_CONTEXT)pvContext,
                    pIssuer,
                    dwFlags,
                    OriginIdentifier
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        return( CtlGetOriginIdentifier(
                   (PCCTL_CONTEXT)pvContext,
                   pIssuer,
                   dwFlags,
                   OriginIdentifier
                   ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        return( CrlGetOriginIdentifier(
                   (PCCRL_CONTEXT)pvContext,
                   pIssuer,
                   dwFlags,
                   OriginIdentifier
                   ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextIsValidForSubject
//
//  Synopsis:   returns TRUE if the object context is valid for the specified
//              subject
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextIsValidForSubject (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN LPVOID pvSubject,
      IN OPTIONAL LPVOID pvExtraInfo
      )
{
    if ( pszContextOid == CONTEXT_OID_CRL && pvSubject != NULL )
    {
        BOOL fResult;
        PCCRL_CONTEXT pCrl = (PCCRL_CONTEXT) pvContext;
        fResult = CertIsValidCRLForCertificate(
                (PCCERT_CONTEXT) pvSubject,
                pCrl,
                0,                              // dwFlags
                NULL                            // pvReserved
                );
        if (fResult && pvExtraInfo)
        {
            int iDeltaCrlIndicator = 0;

        
            // Since we are using a reserved parameter, guard against someone
            // passing in a nonNULL pointer when they shouldn't
            __try
            {
                iDeltaCrlIndicator =
                    ((PCRL_IS_VALID_EXTRA_INFO) pvExtraInfo)->iDeltaCrlIndicator;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                iDeltaCrlIndicator = 0;
            }

            if (0 < iDeltaCrlIndicator)
            {
                PCERT_EXTENSION pCrlNumberExt;
                int iCrlNumber = 0;
                DWORD cbInt = sizeof(iCrlNumber);

                if (NULL == (pCrlNumberExt = CertFindExtension(
                        szOID_CRL_NUMBER,
                        pCrl->pCrlInfo->cExtension,
                        pCrl->pCrlInfo->rgExtension))
                                ||
                    !CryptDecodeObject(
                        pCrl->dwCertEncodingType,
                        X509_INTEGER,
                        pCrlNumberExt->Value.pbData,
                        pCrlNumberExt->Value.cbData,
                        0,                      // dwFlags
                        &iCrlNumber,
                        &cbInt)
                                ||
                        iCrlNumber < iDeltaCrlIndicator)
                {
                    fResult = FALSE;
                }
            }
        }

        return fResult;
    }
    else
    {
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFindExtension
//
//  Synopsis:   get the specified extension from the object
//
//----------------------------------------------------------------------------
PCERT_EXTENSION WINAPI
ObjectContextFindExtension (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN LPCSTR pszExtOid
      )
{
    DWORD           cExt;
    PCERT_EXTENSION rgExt;

    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        PCCERT_CONTEXT pCertContext = (PCCERT_CONTEXT)pvContext;

        cExt = pCertContext->pCertInfo->cExtension;
        rgExt = pCertContext->pCertInfo->rgExtension;
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        PCCTL_CONTEXT pCtlContext = (PCCTL_CONTEXT)pvContext;

        cExt = pCtlContext->pCtlInfo->cExtension;
        rgExt = pCtlContext->pCtlInfo->rgExtension;
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        PCCRL_CONTEXT pCrlContext = (PCCRL_CONTEXT)pvContext;

        cExt = pCrlContext->pCrlInfo->cExtension;
        rgExt = pCrlContext->pCrlInfo->rgExtension;
    }
    else
    {
        return( NULL );
    }

    return( CertFindExtension( pszExtOid, cExt, rgExt ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetProperty
//
//  Synopsis:   get the specified property from the object
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetProperty (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD dwPropId,
      IN LPVOID pvData,
      IN DWORD* pcbData
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        return( CertGetCertificateContextProperty(
                    (PCCERT_CONTEXT)pvContext,
                    dwPropId,
                    pvData,
                    pcbData
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        return( CertGetCTLContextProperty(
                    (PCCTL_CONTEXT)pvContext,
                    dwPropId,
                    pvData,
                    pcbData
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        return( CertGetCRLContextProperty(
                    (PCCRL_CONTEXT)pvContext,
                    dwPropId,
                    pvData,
                    pcbData
                    ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetAttribute
//
//  Synopsis:   find an attribute
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetAttribute (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszAttrOid,
      OUT PCRYPT_ATTRIBUTE pAttribute,
      IN OUT DWORD* pcbAttribute
      )
{
    BOOL              fResult;
    PCRYPT_ATTRIBUTES pAttributes;
    DWORD             cbData;
    DWORD             cCount;
    HCRYPTMSG         hCryptMsg;
    DWORD             dwParamType;
    BOOL              fFound = FALSE;

    if ( Index == -1 )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( dwFlags == CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE )
    {
        dwParamType = CMSG_SIGNER_UNAUTH_ATTR_PARAM;
    }
    else if ( dwFlags == CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE )
    {
        dwParamType = CMSG_SIGNER_AUTH_ATTR_PARAM;
    }
    else
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( pszContextOid == CONTEXT_OID_CTL )
    {
        hCryptMsg = ((PCCTL_CONTEXT)pvContext)->hCryptMsg;
    }
    else if ( pszContextOid == CONTEXT_OID_PKCS7 )
    {
        hCryptMsg = (HCRYPTMSG)pvContext;
    }
    else
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( CryptMsgGetParam(
              hCryptMsg,
              dwParamType,
              Index,
              NULL,
              &cbData
              ) == FALSE )
    {
        return( FALSE );
    }

    pAttributes = (PCRYPT_ATTRIBUTES)new BYTE [cbData];
    if ( pAttributes == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( CryptMsgGetParam(
              hCryptMsg,
              dwParamType,
              Index,
              pAttributes,
              &cbData
              ) == FALSE )
    {
        delete [] (BYTE *)pAttributes;
        return( FALSE );
    }

    fResult = TRUE;

    for ( cCount = 0; cCount < pAttributes->cAttr; cCount++ )
    {
        if ( strcmp( pAttributes->rgAttr[cCount].pszObjId, pszAttrOid ) == 0 )
        {
            DWORD cbAttribute;
            DWORD cbOid;

            cbAttribute = sizeof( CRYPT_ATTRIBUTE ) + sizeof( CRYPT_ATTR_BLOB );
            cbOid = strlen( pszAttrOid ) + 1;
            cbData = pAttributes->rgAttr[cCount].rgValue[0].cbData;
            cbAttribute += cbOid + cbData;

            if ( pAttribute == NULL )
            {
                if ( pcbAttribute == NULL )
                {
                    SetLastError( (DWORD) E_INVALIDARG );
                    fResult = FALSE;
                }
                else
                {
                    *pcbAttribute = cbAttribute;
                    fFound = TRUE;
                    break;
                }
            }
            else if ( *pcbAttribute < cbAttribute )
            {
                SetLastError( (DWORD) ERROR_MORE_DATA );
                fResult = FALSE;
            }

            if ( fResult == TRUE )
            {
                pAttribute->pszObjId = (LPSTR)((LPBYTE)pAttribute +
                                               sizeof( CRYPT_ATTRIBUTE ) +
                                               sizeof( CRYPT_ATTR_BLOB ));

                strcpy( pAttribute->pszObjId, pszAttrOid );

                pAttribute->cValue = 1;
                pAttribute->rgValue = (PCRYPT_ATTR_BLOB)((LPBYTE)pAttribute +
                                                     sizeof( CRYPT_ATTRIBUTE ));

                pAttribute->rgValue[0].cbData = cbData;
                pAttribute->rgValue[0].pbData = (LPBYTE)pAttribute->pszObjId +
                                                cbOid;

                memcpy(
                   pAttribute->rgValue[0].pbData,
                   pAttributes->rgAttr[cCount].rgValue[0].pbData,
                   cbData
                   );
            }

            fFound = TRUE;
            break;
        }
    }

    delete [] (BYTE *)pAttributes;

    if ( fResult == TRUE )
    {
        fResult = fFound;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextDuplicate
//
//  Synopsis:   duplicate the context
//
//----------------------------------------------------------------------------
LPVOID WINAPI
ObjectContextDuplicate (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        return( (LPVOID)CertDuplicateCertificateContext(
                            (PCCERT_CONTEXT)pvContext
                            ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        return( (LPVOID)CertDuplicateCTLContext( (PCCTL_CONTEXT)pvContext ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        return( (LPVOID)CertDuplicateCRLContext( (PCCRL_CONTEXT)pvContext ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextAdd
//
//  Synopsis:   object context create
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextCreate (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT LPVOID* ppvContext
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        return( CertAddCertificateContextToStore(
                    NULL,
                    (PCCERT_CONTEXT)pvContext,
                    CERT_STORE_ADD_ALWAYS,
                    (PCCERT_CONTEXT *)ppvContext
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        return( CertAddCTLContextToStore(
                    NULL,
                    (PCCTL_CONTEXT)pvContext,
                    CERT_STORE_ADD_ALWAYS,
                    (PCCTL_CONTEXT *)ppvContext
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        return( CertAddCRLContextToStore(
                    NULL,
                    (PCCRL_CONTEXT)pvContext,
                    CERT_STORE_ADD_ALWAYS,
                    (PCCRL_CONTEXT *)ppvContext
                    ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetCreateAndExpireTimes
//
//  Synopsis:   get create and expire times
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetCreateAndExpireTimes (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT LPFILETIME pftCreateTime,
      OUT LPFILETIME pftExpireTime
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        *pftCreateTime = ((PCCERT_CONTEXT)pvContext)->pCertInfo->NotBefore;
        *pftExpireTime = ((PCCERT_CONTEXT)pvContext)->pCertInfo->NotAfter;
        return( TRUE );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        *pftCreateTime = ((PCCTL_CONTEXT)pvContext)->pCtlInfo->ThisUpdate;
        *pftExpireTime = ((PCCTL_CONTEXT)pvContext)->pCtlInfo->NextUpdate;
        return( TRUE );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        *pftCreateTime = ((PCCRL_CONTEXT)pvContext)->pCrlInfo->ThisUpdate;
        *pftExpireTime = ((PCCRL_CONTEXT)pvContext)->pCrlInfo->NextUpdate;
        return( TRUE );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetNextUpdateUrl
//
//  Synopsis:   get the renewal URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetNextUpdateUrl (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pIssuer,
      IN LPWSTR pwszUrlHint,
      OUT PCRYPT_URL_ARRAY* ppUrlArray,
      OUT DWORD* pcbUrlArray,
      OUT DWORD* pPreferredUrlIndex,
      OUT BOOL* pfHintInArray
      )
{
    BOOL             fResult;
    DWORD            cbUrlArray;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD            PreferredUrlIndex;
    DWORD            cCount;
    DWORD            cSigner;
    DWORD            cbData;
    BOOL             fHintInArray = FALSE;
    PCCTL_CONTEXT    pCtlContext = (PCCTL_CONTEXT)pvContext;
    PCERT_INFO       pCertInfo;
    BOOL             fFoundIssuer = FALSE;
    LPVOID           apv[2];

    if ( pszContextOid != CONTEXT_OID_CTL )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    cbData = sizeof( DWORD );
    if ( CryptMsgGetParam(
              pCtlContext->hCryptMsg,
              CMSG_SIGNER_COUNT_PARAM,
              0,
              &cSigner,
              &cbData
              ) == FALSE )
    {
        return( FALSE );
    }

    for ( cCount = 0;
         ( cCount < cSigner ) && ( fFoundIssuer == FALSE );
         cCount++ )
    {
        if ( CryptMsgGetParam(
                  pCtlContext->hCryptMsg,
                  CMSG_SIGNER_CERT_INFO_PARAM,
                  cCount,
                  NULL,
                  &cbData
                  ) == FALSE )
        {
            printf("GetLastError() = %lx\n", GetLastError());
            return( FALSE );
        }

        pCertInfo = (PCERT_INFO)new BYTE [cbData];
        if ( pCertInfo == NULL )
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }

        if ( CryptMsgGetParam(
                  pCtlContext->hCryptMsg,
                  CMSG_SIGNER_CERT_INFO_PARAM,
                  cCount,
                  (LPVOID)pCertInfo,
                  &cbData
                  ) == FALSE )
        {
            delete [] (BYTE *)pCertInfo;
            return( FALSE );
        }

        if ( ( pIssuer->pCertInfo->Issuer.cbData ==
               pCertInfo->Issuer.cbData ) &&
             ( pIssuer->pCertInfo->SerialNumber.cbData ==
               pCertInfo->SerialNumber.cbData ) &&
             ( memcmp(
                  pIssuer->pCertInfo->Issuer.pbData,
                  pCertInfo->Issuer.pbData,
                  pCertInfo->Issuer.cbData
                  ) == 0 ) &&
             ( memcmp(
                  pIssuer->pCertInfo->SerialNumber.pbData,
                  pCertInfo->SerialNumber.pbData,
                  pCertInfo->SerialNumber.cbData
                  ) == 0 ) )
        {
            fFoundIssuer = TRUE;
        }

        delete [] (BYTE *)pCertInfo;
    }

    if ( fFoundIssuer == FALSE )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        return( FALSE );
    }

    apv[0] = pvContext;
    apv[1] = (LPVOID)(UINT_PTR)(cCount - 1);

    fResult = CryptGetObjectUrl(
                   URL_OID_CTL_NEXT_UPDATE,
                   apv,
                   0,
                   NULL,
                   &cbUrlArray,
                   NULL,
                   NULL,
                   NULL
                   );

    if ( fResult == TRUE )
    {
        pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
        if ( pUrlArray != NULL )
        {
            fResult = CryptGetObjectUrl(
                           URL_OID_CTL_NEXT_UPDATE,
                           apv,
                           0,
                           pUrlArray,
                           &cbUrlArray,
                           NULL,
                           NULL,
                           NULL
                           );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        GetUrlArrayIndex(
           pUrlArray,
           pwszUrlHint,
           0,
           &PreferredUrlIndex,
           &fHintInArray
           );

        *ppUrlArray = pUrlArray;
        *pcbUrlArray = cbUrlArray;

        if ( pPreferredUrlIndex != NULL )
        {
            *pPreferredUrlIndex = PreferredUrlIndex;
        }

        if ( pfHintInArray != NULL )
        {
            *pfHintInArray = fHintInArray;
        }
    }
    else if ( pUrlArray != NULL )
    {
        delete [] (BYTE *) pUrlArray;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFree
//
//  Synopsis:   free context
//
//----------------------------------------------------------------------------
VOID WINAPI
ObjectContextFree (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        CertFreeCertificateContext( (PCCERT_CONTEXT)pvContext );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        CertFreeCTLContext( (PCCTL_CONTEXT)pvContext );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        CertFreeCRLContext( (PCCRL_CONTEXT)pvContext );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextVerifySignature
//
//  Synopsis:   verify the object signature
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextVerifySignature (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pSigner
      )
{
    if ( ( pszContextOid == CONTEXT_OID_CERTIFICATE ) ||
         ( pszContextOid == CONTEXT_OID_CRL ) )
    {
#ifdef CMS_PKCS7
        DWORD dwSubjectType = 0;
#else
        DWORD  cbEncoded;
        LPBYTE pbEncoded;
#endif  // CMS_PKCS7

        if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
        {
#ifdef CMS_PKCS7
            dwSubjectType = CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT;
#else
            cbEncoded = ((PCCERT_CONTEXT)pvContext)->cbCertEncoded;
            pbEncoded = ((PCCERT_CONTEXT)pvContext)->pbCertEncoded;
#endif  // CMS_PKCS7
        }
        else if ( pszContextOid == CONTEXT_OID_CRL )
        {
#ifdef CMS_PKCS7
            dwSubjectType = CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL;
#else
            cbEncoded = ((PCCRL_CONTEXT)pvContext)->cbCrlEncoded;
            pbEncoded = ((PCCRL_CONTEXT)pvContext)->pbCrlEncoded;
#endif  // CMS_PKCS7
        }

#ifdef CMS_PKCS7
        return( CryptVerifyCertificateSignatureEx(
                    NULL,                   // hCryptProv
                    X509_ASN_ENCODING,
                    dwSubjectType,
                    pvContext,
                    CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                    (void *) pSigner,
                    0,                      // dwFlags
                    NULL                    // pvReserved
                    ) );
#else
        return( CryptVerifyCertificateSignature(
                     NULL,
                     X509_ASN_ENCODING,
                     pbEncoded,
                     cbEncoded,
                     &pSigner->pCertInfo->SubjectPublicKeyInfo
                     ) );
#endif  // CMS_PKCS7
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
#ifdef CMS_PKCS7
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =

        // Assumption: CTL only has one signer
        CtrlPara.dwSignerIndex = 0;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pSigner;

        if (CryptMsgControl(
                     ((PCCTL_CONTEXT)pvContext)->hCryptMsg,
                     0,
                     CMSG_CTRL_VERIFY_SIGNATURE_EX,
                     &CtrlPara
                     ))
            return TRUE;

        // Otherwise, fall through in case it wasn't signer 0.
#endif  // CMS_PKCS7

        return( CryptMsgControl(
                     ((PCCTL_CONTEXT)pvContext)->hCryptMsg,
                     0,
                     CMSG_CTRL_VERIFY_SIGNATURE,
                     pSigner->pCertInfo
                     ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextEnumObjectsInStore
//
//  Synopsis:   enumerate objects in a store
//
//----------------------------------------------------------------------------
LPVOID WINAPI
ObjectContextEnumObjectsInStore (
      IN HCERTSTORE hStore,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT OPTIONAL LPCSTR* ppszContextOid
      )
{
    if ( ppszContextOid )
    {
        *ppszContextOid = pszContextOid;
    }

    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        pvContext = (LPVOID)CertEnumCertificatesInStore(
                         hStore,
                         (PCCERT_CONTEXT)pvContext
                         );

        if ( pvContext != NULL )
        {
            return( pvContext );
        }

        if (ppszContextOid == NULL)
        {
            return( NULL );
        }

        *ppszContextOid = pszContextOid = CONTEXT_OID_CTL;
    }

    if ( pszContextOid == CONTEXT_OID_CTL )
    {
        pvContext = (LPVOID)CertEnumCTLsInStore(
                         hStore,
                         (PCCTL_CONTEXT)pvContext
                         );

        if ( pvContext != NULL )
        {
            return( pvContext );
        }

        if (ppszContextOid == NULL)
        {
            return( NULL );
        }

        *ppszContextOid = pszContextOid = CONTEXT_OID_CRL;
    }

    if ( pszContextOid == CONTEXT_OID_CRL )
    {
        pvContext = (LPVOID)CertEnumCRLsInStore(
                         hStore,
                         (PCCRL_CONTEXT)pvContext
                         );

        if ( pvContext != NULL )
        {
            return( pvContext );
        }
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetEncodedBits
//
//  Synopsis:   get encoded bits out of the context
//
//----------------------------------------------------------------------------
VOID WINAPI
ObjectContextGetEncodedBits (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT DWORD* pcbEncoded,
      OUT LPBYTE* ppbEncoded
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        *pcbEncoded = ((PCCERT_CONTEXT)pvContext)->cbCertEncoded;
        *ppbEncoded = ((PCCERT_CONTEXT)pvContext)->pbCertEncoded;
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        *pcbEncoded = ((PCCTL_CONTEXT)pvContext)->cbCtlEncoded;
        *ppbEncoded = ((PCCTL_CONTEXT)pvContext)->pbCtlEncoded;
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        *pcbEncoded = ((PCCRL_CONTEXT)pvContext)->cbCrlEncoded;
        *ppbEncoded = ((PCCRL_CONTEXT)pvContext)->pbCrlEncoded;
    }
    else
    {
        assert( !"Bad context" );
        *pcbEncoded = 0;
        *ppbEncoded = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFindCorrespondingObject
//
//  Synopsis:   find corresponding object
//
//----------------------------------------------------------------------------
LPVOID WINAPI
ObjectContextFindCorrespondingObject (
      IN HCERTSTORE hStore,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      )
{
    DWORD           cbHash = MAX_HASH_SIZE;
    BYTE            aHash[MAX_HASH_SIZE];
    CRYPT_HASH_BLOB HashBlob;

    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        if ( CertGetCertificateContextProperty(
                 (PCCERT_CONTEXT)pvContext,
                 CERT_HASH_PROP_ID,
                 aHash,
                 &cbHash
                 ) == FALSE )
        {
            return( NULL );
        }

        HashBlob.cbData = cbHash;
        HashBlob.pbData = aHash;

        return( (LPVOID)CertFindCertificateInStore(
                            hStore,
                            X509_ASN_ENCODING,
                            0,
                            CERT_FIND_HASH,
                            &HashBlob,
                            NULL
                            ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        if ( CertGetCTLContextProperty(
                 (PCCTL_CONTEXT)pvContext,
                 CERT_SHA1_HASH_PROP_ID,
                 aHash,
                 &cbHash
                 ) == FALSE )
        {
            return( NULL );
        }

        HashBlob.cbData = cbHash;
        HashBlob.pbData = aHash;

        return( (LPVOID)CertFindCTLInStore(
                            hStore,
                            X509_ASN_ENCODING,
                            0,
                            CTL_FIND_SHA1_HASH,
                            &HashBlob,
                            NULL
                            ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        DWORD         cbFindHash = MAX_HASH_SIZE;
        BYTE          aFindHash[MAX_HASH_SIZE];
        PCCRL_CONTEXT pFindCrl = NULL;
        DWORD         dwFlags = 0;

        if ( CertGetCRLContextProperty(
                 (PCCRL_CONTEXT)pvContext,
                 CERT_HASH_PROP_ID,
                 aHash,
                 &cbHash
                 ) == FALSE )
        {
            return( NULL );
        }

        while ( ( pFindCrl = CertGetCRLFromStore(
                                 hStore,
                                 NULL,
                                 pFindCrl,
                                 &dwFlags
                                 ) ) != NULL )
        {
            if ( CertGetCRLContextProperty(
                     pFindCrl,
                     CERT_HASH_PROP_ID,
                     aFindHash,
                     &cbFindHash
                     ) == TRUE )
            {
                if ( cbHash == cbFindHash )
                {
                    if ( memcmp( aHash, aFindHash, cbHash ) == 0 )
                    {
                        return( (LPVOID)pFindCrl );
                    }
                }
            }
        }
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextDeleteAllObjectsFromStore
//
//  Synopsis:   delete all objects from the specified store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextDeleteAllObjectsFromStore (
      IN HCERTSTORE hStore
      )
{
    PCCERT_CONTEXT pCertContext;
    PCCRL_CONTEXT  pCrlContext;
    PCCTL_CONTEXT  pCtlContext;
    DWORD          dwFlags = 0;

    while ( pCertContext = CertEnumCertificatesInStore( hStore, NULL ) )
    {
        CertDeleteCertificateFromStore( pCertContext );
    }

    while ( pCrlContext = CertGetCRLFromStore( hStore, NULL, NULL, &dwFlags ) )
    {
        CertDeleteCRLFromStore( pCrlContext );
    }

    while ( pCtlContext = CertEnumCTLsInStore( hStore, NULL ) )
    {
        CertDeleteCTLFromStore( pCtlContext );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   MapOidToPropertyId
//
//  Synopsis:   maps an OID to a property id
//
//----------------------------------------------------------------------------
BOOL WINAPI
MapOidToPropertyId (
   IN LPCSTR pszOid,
   OUT DWORD* pPropId
   )
{
    if ( (DWORD_PTR)pszOid <= 0xFFFF )
    {
        // NOTE: Switch on pszOid and map
        return( FALSE );
    }
    else if ( 0 == strcmp(pszOid, szOID_CROSS_CERT_DIST_POINTS) )
    {
        *pPropId = CERT_CROSS_CERT_DIST_POINTS_PROP_ID;
    }
    else if ( 0 == strcmp(pszOid, szOID_NEXT_UPDATE_LOCATION) )
    {
        *pPropId = CERT_NEXT_UPDATE_LOCATION_PROP_ID;
    }
    else
    {
        // NOTE: Compare pszOid and map
        return( FALSE );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\msrevoke.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:	    msrevoke.cpp
//
//  Contents:   CRL Distribution Points version of CertDllVerifyRevocation.
//
//              Restrictions:
//               - Only support CRYPT_ASN_ENCODING
//               - Only processes certificates having the
//                 szOID_CRL_DIST_POINTS extension.
//               - For szOID_CRL_DIST_POINTS extension: only URL FullName,
//                 no ReasonFlags or CRLIssuer.
//               - URLs: http:, file:
//               - CRL must be issued and signed by the issuer of the
//                 certificate
//               - CRL must not have any critical extensions
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              CertDllVerifyRevocation
//
//  History:	10-Apr-97   philh   created
//              01-Oct-97   kirtd   major simplification, use
//                                  CryptGetTimeValidObject
//
//--------------------------------------------------------------------------
#include "global.hxx"
#include <dbgdef.h>


#define MSREVOKE_TIMEOUT 15000
//+-------------------------------------------------------------------------
// Default stores searched to find an issuer of the subject certificate
//--------------------------------------------------------------------------
static struct {
    LPCWSTR     pwszStore;
    DWORD       dwFlags;
} rgDefaultIssuerStores[] = {
    L"CA",          CERT_SYSTEM_STORE_CURRENT_USER,
    L"ROOT",        CERT_SYSTEM_STORE_CURRENT_USER,
    L"SPC",         CERT_SYSTEM_STORE_LOCAL_MACHINE
};

#define NUM_DEFAULT_ISSUER_STORES (sizeof(rgDefaultIssuerStores) / \
                                   sizeof(rgDefaultIssuerStores[0]))


//+-------------------------------------------------------------------------
//  Local functions called by MicrosoftCertDllVerifyRevocation
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetIssuerCert(
    IN DWORD cCert,
    IN PCCERT_CONTEXT rgpCert[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara
    );

BOOL HasUnsupportedCrlCriticalExtension(
    IN PCCRL_CONTEXT pCrl
    );


// msrevoke specific flags that can be passed to GetTimeValidCrl
#define MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG  0x1
#define MSREVOKE_DELTA_CRL_FLAG                 0x2

BOOL GetTimeValidCrl (
        IN LPCSTR pszTimeValidOid,
        IN LPVOID pvTimeValidPara,
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN PCERT_EXTENSION pCDPExt,
        IN DWORD dwRevFlags,
        IN DWORD dwMsrevokeFlags,
        IN FILETIME *pftEndUrlRetrieval,
        OUT PCCRL_CONTEXT *ppCrl,
        IN OUT BOOL *pfWireRetrieval
        );
BOOL GetBaseCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN PCERT_EXTENSION pCDPExt,
        IN DWORD dwRevFlags,
        IN FILETIME *pftEndUrlRetrieval,
        OUT PCCRL_CONTEXT *ppBaseCrl,
        OUT BOOL *pfBaseCrlTimeValid,
        OUT BOOL *pfBaseWireRetrieval
        );
BOOL GetDeltaCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN DWORD dwRevFlags,
        IN BOOL fBaseWireRetrieval,
        IN FILETIME *pftEndUrlRetrieval,
        IN OUT PCCRL_CONTEXT *ppBaseCrl,
        IN OUT BOOL *pfCrlTimeValid,
        OUT PCCRL_CONTEXT *ppDeltaCrl,
        OUT DWORD *pdwFreshnessTime
        );

DWORD GetCrlReason(
        IN PCRL_ENTRY pCrlEntry
        );

BOOL CrlIssuerIsCertIssuer (
        IN PCCERT_CONTEXT pCert,
        IN PCERT_EXTENSION pCrlDistPointExt
        );

//+-------------------------------------------------------------------------
//  External functions called by CertDllVerifyRevocation
//--------------------------------------------------------------------------

BOOL
WINAPI
NetscapeCertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PVOID pvReserved,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    );

//+-------------------------------------------------------------------------
//  MicrosoftCertDllVerifyRevocation using CRL Distribution Points extension.
//--------------------------------------------------------------------------
BOOL
WINAPI
MicrosoftCertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult;
    DWORD dwIndex = 0;
    DWORD dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
    DWORD dwReason = 0;
    PCCERT_CONTEXT pCert;                       // not allocated
    PCCERT_CONTEXT pIssuer = NULL;
    PCCRL_CONTEXT pBaseCrl = NULL;
    PCCRL_CONTEXT pDeltaCrl = NULL;
    PCRL_ENTRY pCrlEntry = NULL;                // not allocated
    BOOL fDeltaCrlEntry = FALSE;
    BOOL fCrlTimeValid = FALSE;
    BOOL fBaseWireRetrieval = FALSE;
    PCERT_EXTENSION pCDPExt;
    BOOL fSaveCheckFreshnessTime;
    DWORD dwFreshnessTime;

    CERT_REVOCATION_PARA RevPara;
    FILETIME ftCurrent;

    // Following is only used for CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG
    FILETIME ftEndUrlRetrieval;

    // Ensure we have a structure containing all the possible parameters
    memset(&RevPara, 0, sizeof(RevPara));
    if (pRevPara != NULL)
        memcpy(&RevPara, pRevPara, min(pRevPara->cbSize, sizeof(RevPara)));
    RevPara.cbSize = sizeof(RevPara);
    if (0 == RevPara.dwUrlRetrievalTimeout)
        RevPara.dwUrlRetrievalTimeout = MSREVOKE_TIMEOUT;
    if (NULL == RevPara.pftCurrentTime) {
        GetSystemTimeAsFileTime(&ftCurrent);
        RevPara.pftCurrentTime = &ftCurrent;
    }
    pRevPara = &RevPara;

    if (dwFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
        FILETIME ftStartUrlRetrieval;

        GetSystemTimeAsFileTime(&ftStartUrlRetrieval);
        I_CryptIncrementFileTimeByMilliseconds(
            &ftStartUrlRetrieval, pRevPara->dwUrlRetrievalTimeout,
            &ftEndUrlRetrieval);
    }

    if (cContext == 0)
        goto NoContextError;
    if (GET_CERT_ENCODING_TYPE(dwEncodingType) != CRYPT_ASN_ENCODING)
        goto NoRevocationCheckForEncodingTypeError;
    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE)
        goto NoRevocationCheckForRevTypeError;

    pCert = (PCCERT_CONTEXT) rgpvContext[0];

    // Check if we have a CRL dist point
    pCDPExt = CertFindExtension(
               szOID_CRL_DIST_POINTS,
               pCert->pCertInfo->cExtension,
               pCert->pCertInfo->rgExtension
               );

    // On 04-05-01 changed back to W2K semantics. Continue to check
    // if expired certificates are on the CRL.

    // If we have a CDP and an expired certificate,
    // then, the CA no longer maintains CRL information for the 
    // certificate. We must consider it as being revoked.
    //  if (NULL != pCDPExt &&
    //          0 < CompareFileTime(RevPara.pftCurrentTime,
    //              &pCert->pCertInfo->NotAfter)) {
    //      dwReason = CRL_REASON_CESSATION_OF_OPERATION;
    //      goto ExpiredCertError;
    //  }

    // Get the certificate's issuer
    if (NULL == (pIssuer = GetIssuerCert(
            cContext,
            (PCCERT_CONTEXT *) rgpvContext,
            dwFlags,
            &RevPara
            )))
        goto NoIssuerError;


    // Get the Base CRL for the subject certificate.
    //
    // Remember and disable the freshness retrieval option.
    fSaveCheckFreshnessTime = RevPara.fCheckFreshnessTime;
    RevPara.fCheckFreshnessTime = FALSE;
    if (!GetBaseCrl(
            pCert,
            pIssuer,
            &RevPara,
            pCDPExt,
            dwFlags,
            &ftEndUrlRetrieval,
            &pBaseCrl,
            &fCrlTimeValid,
            &fBaseWireRetrieval
            ))
        goto GetBaseCrlError;
    RevPara.fCheckFreshnessTime = fSaveCheckFreshnessTime;


    // If either the base crl or subject cert has a freshest, delta CRL,
    // get it
    if (!GetDeltaCrl(
            pCert,
            pIssuer,
            &RevPara,
            dwFlags,
            fBaseWireRetrieval,
            &ftEndUrlRetrieval,
            &pBaseCrl,
            &fCrlTimeValid,
            &pDeltaCrl,
            &dwFreshnessTime
            ))
        goto GetDeltaCrlError;

    if (NULL == pDeltaCrl) {
        dwFreshnessTime = I_CryptSubtractFileTimes(
            RevPara.pftCurrentTime, &pBaseCrl->pCrlInfo->ThisUpdate);

        if (RevPara.fCheckFreshnessTime) {
            if (RevPara.dwFreshnessTime >= dwFreshnessTime)
                fCrlTimeValid = TRUE;
            else {
                // Attempt to get a base CRL with better "freshness"
                PCCRL_CONTEXT pNewCrl;

                if (GetBaseCrl(
                        pCert,
                        pIssuer,
                        &RevPara,
                        pCDPExt,
                        dwFlags,
                        &ftEndUrlRetrieval,
                        &pNewCrl,
                        &fCrlTimeValid,
                        &fBaseWireRetrieval
                        )) {
                    CertFreeCRLContext(pBaseCrl);
                    pBaseCrl = pNewCrl;
                    dwFreshnessTime = I_CryptSubtractFileTimes(
                        RevPara.pftCurrentTime,
                            &pBaseCrl->pCrlInfo->ThisUpdate);
                } else
                    fCrlTimeValid = FALSE;
            }
        }
    } else {
        if (!CertFindCertificateInCRL(
                pCert,
                pDeltaCrl,
                0,                      // dwFlags
                NULL,                   // pvReserved
                &pCrlEntry
                ))
            goto CertFindCertificateInDeltaCRLError;
    }

    if (pCrlEntry) {
        // Delta CRL entry

        dwReason = GetCrlReason(pCrlEntry);
        if (CRL_REASON_REMOVE_FROM_CRL != dwReason)
            fDeltaCrlEntry = TRUE;
        else {
            if (!CertFindCertificateInCRL(
                    pCert,
                    pBaseCrl,
                    0,                      // dwFlags
                    NULL,                   // pvReserved
                    &pCrlEntry
                    ))
                goto CertFindCertificateInBaseCRLError;
            if (pCrlEntry) {
                dwReason = GetCrlReason(pCrlEntry);
                if (CRL_REASON_CERTIFICATE_HOLD == dwReason)
                    pCrlEntry = NULL;
            }

            if (NULL == pCrlEntry)
                dwReason = 0;
        }
    } else {
        if (!CertFindCertificateInCRL(
                pCert,
                pBaseCrl,
                0,                      // dwFlags
                NULL,                   // pvReserved
                &pCrlEntry
                ))
            goto CertFindCertificateInBaseCRLError;

        if (pCrlEntry)
            dwReason = GetCrlReason(pCrlEntry);
    }

    dwError = 0;
    if ( ( pCrlEntry != NULL ) &&
         ( ( RevPara.pftTimeToUse == NULL ) ||
           ( CompareFileTime(
                    RevPara.pftTimeToUse,
                    &pCrlEntry->RevocationDate ) >= 0 ) ) )
    {
        dwError = (DWORD) CRYPT_E_REVOKED;
    }
    else if (!fCrlTimeValid)
    {
        dwError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
    }

    if (pRevStatus->cbSize >=
            (offsetof(CERT_REVOCATION_STATUS, dwFreshnessTime) +
                sizeof(pRevStatus->dwFreshnessTime))) {
        pRevStatus->fHasFreshnessTime = TRUE;
        pRevStatus->dwFreshnessTime = dwFreshnessTime;
    }

    if (RevPara.pCrlInfo) {
        PCERT_REVOCATION_CRL_INFO pInfo = RevPara.pCrlInfo;

        if (pInfo->cbSize >= sizeof(*pInfo)) {
            if (pInfo->pBaseCrlContext)
                CertFreeCRLContext(pInfo->pBaseCrlContext);
            pInfo->pBaseCrlContext = CertDuplicateCRLContext(pBaseCrl);
            if (pInfo->pDeltaCrlContext) {
                CertFreeCRLContext(pInfo->pDeltaCrlContext);
                pInfo->pDeltaCrlContext = NULL;
            }

            if (pDeltaCrl)
                pInfo->pDeltaCrlContext = CertDuplicateCRLContext(pDeltaCrl);

            pInfo->fDeltaCrlEntry = fDeltaCrlEntry;
            pInfo->pCrlEntry = pCrlEntry;
                
        }
    }

CommonReturn:
    if (0 == dwError) {
        // Successfully checked that the certificate wasn't revoked
        if (1 < cContext) {
            dwIndex = 1;
            dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
            fResult = FALSE;
        } else
            fResult = TRUE;
    } else
        fResult = FALSE;


    if (pIssuer)
        CertFreeCertificateContext(pIssuer);
    if (pBaseCrl)
        CertFreeCRLContext(pBaseCrl);
    if (pDeltaCrl)
        CertFreeCRLContext(pDeltaCrl);

    pRevStatus->dwIndex = dwIndex;
    pRevStatus->dwError = dwError;
    pRevStatus->dwReason = dwReason;
    SetLastError(dwError);
    return fResult;
ErrorReturn:
    dwError = GetLastError();
    if (0 == dwError)
        dwError = (DWORD) E_UNEXPECTED;
    goto CommonReturn;

SET_ERROR(NoContextError, E_INVALIDARG)
SET_ERROR(NoRevocationCheckForEncodingTypeError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoRevocationCheckForRevTypeError, CRYPT_E_NO_REVOCATION_CHECK)
// SET_ERROR(ExpiredCertError, CRYPT_E_REVOKED)
TRACE_ERROR(NoIssuerError)
TRACE_ERROR(GetBaseCrlError)
TRACE_ERROR(GetDeltaCrlError)
TRACE_ERROR(CertFindCertificateInDeltaCRLError)
TRACE_ERROR(CertFindCertificateInBaseCRLError)
}



//+---------------------------------------------------------------------------
//
//  Function:   HasUnsupportedCrlCriticalExtension
//
//  Synopsis:   checks if the CRL has an unsupported critical section
//
//----------------------------------------------------------------------------

LPCSTR rgpszSupportedCrlExtensionOID[] = {
    szOID_DELTA_CRL_INDICATOR,
    szOID_ISSUING_DIST_POINT,
    szOID_FRESHEST_CRL,
    szOID_CRL_NUMBER,
    szOID_AUTHORITY_KEY_IDENTIFIER2,
    NULL
};

BOOL IsSupportedCrlExtension(
    PCERT_EXTENSION pExt
    )
{
    LPSTR pszExtOID = pExt->pszObjId;
    LPCSTR *ppSupOID;
    for (ppSupOID = rgpszSupportedCrlExtensionOID;
                                            NULL != *ppSupOID; ppSupOID++) {
        if (0 == strcmp(pszExtOID, *ppSupOID))
            return TRUE;
    }

    return FALSE;
}

BOOL HasUnsupportedCrlCriticalExtension(
    IN PCCRL_CONTEXT pCrl
    )
{
    PCRL_INFO pCrlInfo = pCrl->pCrlInfo;
    DWORD cExt = pCrlInfo->cExtension;
    PCERT_EXTENSION pExt = pCrlInfo->rgExtension;

    for ( ; 0 < cExt; cExt--, pExt++) {
        if (pExt->fCritical && !IsSupportedCrlExtension(pExt))
            return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetTimeValidCrl
//
//  Synopsis:   get a time valid base or delta CRL
//
//----------------------------------------------------------------------------
BOOL GetTimeValidCrl (
        IN LPCSTR pszTimeValidOid,
        IN LPVOID pvTimeValidPara,
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN PCERT_EXTENSION pCDPExt,
        IN DWORD dwRevFlags,
        IN DWORD dwMsrevokeFlags,
        IN FILETIME *pftEndUrlRetrieval,
        OUT PCCRL_CONTEXT *ppCrl,
        IN OUT BOOL *pfWireRetrieval
        )
{
    BOOL  fResult = FALSE;
    DWORD dwFlags = 0;
    FILETIME ftFreshness;
    LPFILETIME pftValidFor;

    if (pRevPara->fCheckFreshnessTime)
    {
        I_CryptDecrementFileTimeBySeconds(
            pRevPara->pftCurrentTime,
            pRevPara->dwFreshnessTime,
            &ftFreshness);
        pftValidFor = &ftFreshness;

        dwFlags |= CRYPT_CHECK_FRESHNESS_TIME_VALIDITY;
    }
    else
    {
        pftValidFor = pRevPara->pftCurrentTime;
    }

    if ( dwMsrevokeFlags & MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG )
    {
        dwFlags |= CRYPT_DONT_CHECK_TIME_VALIDITY;
    }

    if ( pCDPExt != NULL )
    {
        fResult = CryptGetTimeValidObject(
                       pszTimeValidOid,
                       pvTimeValidPara,
                       pIssuer,
                       pftValidFor,
                       dwFlags | CRYPT_CACHE_ONLY_RETRIEVAL,
                       0,                                       // dwTimeout
                       (LPVOID *)ppCrl,
                       NULL,                                    // pCredentials
                       NULL                                     // pvReserved
                       );
    }

    if ( fResult == FALSE )
    {
        DWORD dwSaveErr = 0;
        HCERTSTORE hCrlStore = pRevPara->hCrlStore;

        *ppCrl = NULL;

        if ( hCrlStore != NULL )
        {
            PCCRL_CONTEXT pFindCrl = NULL;
            DWORD dwFindFlags;
            CRL_FIND_ISSUED_FOR_PARA FindPara;

            dwSaveErr = GetLastError();

            dwFindFlags = CRL_FIND_ISSUED_BY_AKI_FLAG |
                CRL_FIND_ISSUED_BY_SIGNATURE_FLAG;
            if (dwMsrevokeFlags & MSREVOKE_DELTA_CRL_FLAG)
                dwFindFlags |= CRL_FIND_ISSUED_BY_DELTA_FLAG;
            else
                dwFindFlags |= CRL_FIND_ISSUED_BY_BASE_FLAG;

            FindPara.pSubjectCert = pSubject;
            FindPara.pIssuerCert = pIssuer;

            while ((pFindCrl = CertFindCRLInStore(
                    hCrlStore,
                    pIssuer->dwCertEncodingType,
                    dwFindFlags,
                    CRL_FIND_ISSUED_FOR,
                    (const void *) &FindPara,
                    pFindCrl
                    )))
            {
                if (!CertIsValidCRLForCertificate(
                        pSubject,
                        pFindCrl,
                        0,                  // dwFlags
                        NULL                // pvReserved
                        ))
                    continue;

                if ( !(dwMsrevokeFlags &
                            MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG ))
                {
                    if (pRevPara->fCheckFreshnessTime)
                    {
                        if (CompareFileTime(pftValidFor,
                                &pFindCrl->pCrlInfo->ThisUpdate) > 0)
                        {
                            continue;
                        }
                    }
                    else
                    {
                        if ( CompareFileTime(
                                    pftValidFor,
                                    &pFindCrl->pCrlInfo->NextUpdate
                                    ) > 0 && 
                             !I_CryptIsZeroFileTime(
                                    &pFindCrl->pCrlInfo->NextUpdate) )
                        {
                            continue;
                        }
                    }
                }

                if ( NULL == *ppCrl )
                {
                    *ppCrl = CertDuplicateCRLContext(pFindCrl);
                }
                else
                {
                    PCCRL_CONTEXT pPrevCrl = *ppCrl;

                    // See if this CRL is newer
                    if ( CompareFileTime(
                            &pFindCrl->pCrlInfo->ThisUpdate,
                            &pPrevCrl->pCrlInfo->ThisUpdate
                            ) > 0 )
                    {
                        CertFreeCRLContext(pPrevCrl);
                        *ppCrl = CertDuplicateCRLContext(pFindCrl);
                    }
                }
            }
        }

        if ( *ppCrl != NULL )
        {
            return( TRUE );
        }
        else if ( pCDPExt == NULL )
        {
            SetLastError( (DWORD) CRYPT_E_NO_REVOCATION_CHECK );
            return( FALSE );
        }

        if ( !( dwRevFlags & CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION ) )
        {
            if (dwRevFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
                pRevPara->dwUrlRetrievalTimeout =
                    I_CryptRemainingMilliseconds(pftEndUrlRetrieval);
                if (0 == pRevPara->dwUrlRetrievalTimeout)
                    pRevPara->dwUrlRetrievalTimeout = 1;

                dwFlags |= CRYPT_ACCUMULATIVE_TIMEOUT;
            }

            fResult = CryptGetTimeValidObject(
                           pszTimeValidOid,
                           pvTimeValidPara,
                           pIssuer,
                           pftValidFor,
                           dwFlags | CRYPT_WIRE_ONLY_RETRIEVAL,
                           pRevPara->dwUrlRetrievalTimeout,
                           (LPVOID *)ppCrl,
                           NULL,                            // pCredentials
                           NULL                             // pvReserved
                           );
            *pfWireRetrieval = TRUE;
        }
        else if ( hCrlStore != NULL )
        {
            SetLastError( dwSaveErr );
        }

        assert( pCDPExt );
        if (!fResult)
        {
            if ( CRYPT_E_NOT_FOUND == GetLastError() )
            {
                SetLastError( (DWORD) CRYPT_E_NO_REVOCATION_CHECK );
            }
            else
            {
                SetLastError( (DWORD) CRYPT_E_REVOCATION_OFFLINE );
            }
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetBaseCrl
//
//  Synopsis:   get the base CRL associated with the subject certificate
//
//----------------------------------------------------------------------------
BOOL GetBaseCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN PCERT_EXTENSION pCDPExt,
        IN DWORD dwRevFlags,
        IN FILETIME *pftEndUrlRetrieval,
        OUT PCCRL_CONTEXT *ppBaseCrl,
        OUT BOOL *pfBaseCrlTimeValid,
        OUT BOOL *pfBaseWireRetrieval
        )
{
    BOOL fResult;
    PCCRL_CONTEXT pBaseCrl = NULL;

    *pfBaseWireRetrieval = FALSE;

    if (GetTimeValidCrl(
            TIME_VALID_OID_GET_CRL_FROM_CERT,
            (LPVOID) pSubject,
            pSubject,
            pIssuer,
            pRevPara,
            pCDPExt,
            dwRevFlags,
            0,                  // dwMsrevokeFlags
            pftEndUrlRetrieval,
            &pBaseCrl,
            pfBaseWireRetrieval
            )) {
        *pfBaseCrlTimeValid = TRUE;
    } else {
        *pfBaseCrlTimeValid = FALSE;

        if (!GetTimeValidCrl(
                TIME_VALID_OID_GET_CRL_FROM_CERT,
                (LPVOID) pSubject,
                pSubject,
                pIssuer,
                pRevPara,
                pCDPExt,
                dwRevFlags,
                MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG,
                pftEndUrlRetrieval,
                &pBaseCrl,
                pfBaseWireRetrieval
                ))
        {
            goto GetTimeInvalidCrlError;
        }
    }

    if (HasUnsupportedCrlCriticalExtension(pBaseCrl))
        goto HasUnsupportedCriticalExtensionError;

    fResult = TRUE;

CommonReturn:
    *ppBaseCrl = pBaseCrl;
    return fResult;
ErrorReturn:
    if (pBaseCrl) {
        CertFreeCRLContext(pBaseCrl);
        pBaseCrl = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetTimeInvalidCrlError)
SET_ERROR(HasUnsupportedCriticalExtensionError, CRYPT_E_NO_REVOCATION_CHECK)
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDeltaCrl
//
//  Synopsis:   get the delta CRL associated with the subject certificate and
//              its base CRL
//
//  For now, always return TRUE. If not able to find a delta CRL, set
//  *pfCrlTimeValid to FALSE.
//
//----------------------------------------------------------------------------
BOOL GetDeltaCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN DWORD dwRevFlags,
        IN BOOL fBaseWireRetrieval,
        IN FILETIME *pftEndUrlRetrieval,
        IN OUT PCCRL_CONTEXT *ppBaseCrl,
        IN OUT BOOL *pfCrlTimeValid,
        OUT PCCRL_CONTEXT *ppDeltaCrl,
        OUT DWORD *pdwFreshnessTime
        )
{
    PCERT_EXTENSION pFreshestExt;
    PCCRL_CONTEXT pBaseCrl = *ppBaseCrl;
    PCCRL_CONTEXT pDeltaCrl = NULL;
    LPCSTR pszTimeValidOid;
    LPVOID pvTimeValidPara;
    CERT_CRL_CONTEXT_PAIR CertCrlPair;
    BOOL fDeltaWireRetrieval;

    PCERT_EXTENSION pBaseCrlNumberExt;
    PCERT_EXTENSION pDeltaCrlIndicatorExt;
    int iBaseCrlNumber = 0;
    int iDeltaCrlIndicator = 0;
    DWORD cbInt;

    LPFILETIME pFreshnessThisUpdate;

    assert(pBaseCrl);

    // Check if the base CRL or the subject certificate has a freshest
    // ext
    if (pFreshestExt = CertFindExtension(
            szOID_FRESHEST_CRL,
            pBaseCrl->pCrlInfo->cExtension,
            pBaseCrl->pCrlInfo->rgExtension
            )) {
        pszTimeValidOid = TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL;

        CertCrlPair.pCertContext = pSubject;
        CertCrlPair.pCrlContext = pBaseCrl;
        pvTimeValidPara = (LPVOID) &CertCrlPair;
    } else if (pFreshestExt = CertFindExtension(
            szOID_FRESHEST_CRL,
            pSubject->pCertInfo->cExtension,
            pSubject->pCertInfo->rgExtension
            )) {
        pszTimeValidOid = TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT;
        pvTimeValidPara = (LPVOID) pSubject;
    } else {
        goto NoDeltaCrlReturn;
    }

    if (GetTimeValidCrl(
            pszTimeValidOid,
            pvTimeValidPara,
            pSubject,
            pIssuer,
            pRevPara,
            pFreshestExt,
            dwRevFlags,
            MSREVOKE_DELTA_CRL_FLAG,
            pftEndUrlRetrieval,
            &pDeltaCrl,
            &fDeltaWireRetrieval
            )) {
        *pfCrlTimeValid = TRUE;
    } else {
        *pfCrlTimeValid = FALSE;

        if (!GetTimeValidCrl(
                pszTimeValidOid,
                pvTimeValidPara,
                pSubject,
                pIssuer,
                pRevPara,
                pFreshestExt,
                dwRevFlags,
                MSREVOKE_DELTA_CRL_FLAG |
                    MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG,
                pftEndUrlRetrieval,
                &pDeltaCrl,
                &fDeltaWireRetrieval
                ))
        {
            goto GetTimeInvalidCrlError;
        }
    }

    if (HasUnsupportedCrlCriticalExtension(pDeltaCrl))
        goto HasUnsupportedCriticalExtensionError;

    // Check that the base CRL number >= delta CRL indicator
    if (NULL == (pBaseCrlNumberExt = CertFindExtension(
            szOID_CRL_NUMBER,
            pBaseCrl->pCrlInfo->cExtension,
            pBaseCrl->pCrlInfo->rgExtension
            )))
        goto MissingBaseCrlNumberError;
    if (NULL == (pDeltaCrlIndicatorExt = CertFindExtension(
            szOID_DELTA_CRL_INDICATOR,
            pDeltaCrl->pCrlInfo->cExtension,
            pDeltaCrl->pCrlInfo->rgExtension
            )))
        goto MissingDeltaCrlIndicatorError;

    cbInt = sizeof(iBaseCrlNumber);
    if (!CryptDecodeObject(
            pBaseCrl->dwCertEncodingType,
            X509_INTEGER,
            pBaseCrlNumberExt->Value.pbData,
            pBaseCrlNumberExt->Value.cbData,
            0,                      // dwFlags
            &iBaseCrlNumber,
            &cbInt
            ))
        goto DecodeBaseCrlNumberError;

    cbInt = sizeof(iDeltaCrlIndicator);
    if (!CryptDecodeObject(
            pDeltaCrl->dwCertEncodingType,
            X509_INTEGER,
            pDeltaCrlIndicatorExt->Value.pbData,
            pDeltaCrlIndicatorExt->Value.cbData,
            0,                      // dwFlags
            &iDeltaCrlIndicator,
            &cbInt
            ))
        goto DecodeDeltaCrlIndicatorError;

    pFreshnessThisUpdate = &pDeltaCrl->pCrlInfo->ThisUpdate;

    if (iBaseCrlNumber < iDeltaCrlIndicator) {
        BOOL fValidBaseCrl = FALSE;

        if (!fBaseWireRetrieval &&
                0 == (dwRevFlags & CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION)) {
            // Attempt to get a more recent base CRL by hitting the wire
            PCCRL_CONTEXT pWireBaseCrl = NULL;

            CRL_IS_VALID_EXTRA_INFO CrlIsValidExtraInfo =
                { iDeltaCrlIndicator };


            if (CryptGetTimeValidObject(
                    TIME_VALID_OID_GET_CRL_FROM_CERT,
                    (LPVOID)pSubject,
                    pIssuer,
                    NULL,                           // pftValidFor
                    CRYPT_WIRE_ONLY_RETRIEVAL | CRYPT_DONT_CHECK_TIME_VALIDITY,
                    pRevPara->dwUrlRetrievalTimeout,
                    (LPVOID *) &pWireBaseCrl,
                    NULL,                                    // pCredentials
                    &CrlIsValidExtraInfo
                    )) {

                // Already checked that the new Base CRL number is valid
                CertFreeCRLContext(pBaseCrl);
                *ppBaseCrl = pBaseCrl = pWireBaseCrl;
                fValidBaseCrl = TRUE;
            }
        }

        if (!fValidBaseCrl) {
            *pfCrlTimeValid = FALSE;
            pFreshnessThisUpdate = &pBaseCrl->pCrlInfo->ThisUpdate;
        }
    }

    *pdwFreshnessTime = I_CryptSubtractFileTimes(
        pRevPara->pftCurrentTime, pFreshnessThisUpdate);

    if (pRevPara->fCheckFreshnessTime) {
        if (pRevPara->dwFreshnessTime >= *pdwFreshnessTime)
            *pfCrlTimeValid = TRUE;
        else
            *pfCrlTimeValid = FALSE;
    }

NoDeltaCrlReturn:

CommonReturn:
    *ppDeltaCrl = pDeltaCrl;
    return TRUE;
ErrorReturn:
    if (pDeltaCrl) {
        CertFreeCRLContext(pDeltaCrl);
        pDeltaCrl = NULL;
    }
    *pfCrlTimeValid = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetTimeInvalidCrlError)
SET_ERROR(HasUnsupportedCriticalExtensionError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(MissingBaseCrlNumberError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(MissingDeltaCrlIndicatorError, CRYPT_E_NO_REVOCATION_CHECK)
TRACE_ERROR(DecodeBaseCrlNumberError)
TRACE_ERROR(DecodeDeltaCrlIndicatorError)
}

//+-------------------------------------------------------------------------
//  If the CRL entry has a CRL Reason extension, the enumerated reason
//  code is returned. Otherwise, a reason code of 0 is returned.
//--------------------------------------------------------------------------
DWORD GetCrlReason(
    IN PCRL_ENTRY pCrlEntry
    )
{
    DWORD dwReason = 0;
    PCERT_EXTENSION pExt;

    // Check if the certificate has a szOID_CRL_REASON_CODE extension
    if (pExt = CertFindExtension(
            szOID_CRL_REASON_CODE,
            pCrlEntry->cExtension,
            pCrlEntry->rgExtension
            )) {
        DWORD cbInfo = sizeof(dwReason);
        CryptDecodeObject(
            CRYPT_ASN_ENCODING,
            X509_CRL_REASON_CODE,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0,                      // dwFlags
            &dwReason,
            &cbInfo);
    }
    return dwReason;
}

//+=========================================================================
//  Get Issuer Certificate Functions
//==========================================================================

PCCERT_CONTEXT FindIssuerCertInStores(
    IN PCCERT_CONTEXT pSubjectCert,
    IN DWORD cStore,
    IN HCERTSTORE rgStore[]
    )
{
    PCCERT_CONTEXT pIssuerCert = NULL;
    DWORD i;

    for (i = 0; i < cStore; i++) {
        while (TRUE) {
            DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG;
            pIssuerCert = CertGetIssuerCertificateFromStore(
                rgStore[i],
                pSubjectCert,
                pIssuerCert,
                &dwFlags);
            if (NULL == pIssuerCert) {
                if (CRYPT_E_SELF_SIGNED == GetLastError()) {
                    if (0 == (dwFlags & CERT_STORE_SIGNATURE_FLAG))
                        pIssuerCert = CertDuplicateCertificateContext(
                            pSubjectCert);
                    return pIssuerCert;
                }
                break;
            } else if (0 == (dwFlags & CERT_STORE_SIGNATURE_FLAG))
                return pIssuerCert;
        }
    }

    return NULL;
}

static PCCERT_CONTEXT FindIssuerCertInDefaultStores(
    IN PCCERT_CONTEXT pSubjectCert
    )
{
    PCCERT_CONTEXT pIssuerCert;
    HCERTSTORE hStore;
    DWORD i;

    for (i = 0; i < NUM_DEFAULT_ISSUER_STORES; i++) {
        if (hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_W,
                0,                          // dwEncodingType
                0,                          // hCryptProv
                rgDefaultIssuerStores[i].dwFlags | CERT_STORE_READONLY_FLAG,
                (const void *) rgDefaultIssuerStores[i].pwszStore
                )) {
            pIssuerCert = FindIssuerCertInStores(pSubjectCert, 1, &hStore);
            CertCloseStore(hStore, 0);
            if (pIssuerCert)
                return pIssuerCert;
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Get the issuer of the first certificate in the array
//
//  Note, pRevPara is our copy and guaranteed to contain all the fields.
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetIssuerCert(
    IN DWORD cCert,
    IN PCCERT_CONTEXT rgpCert[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara
    )
{
    PCCERT_CONTEXT pSubjectCert;
    PCCERT_CONTEXT pIssuerCert = NULL;

    assert(cCert >= 1);
    pSubjectCert = rgpCert[0];
    if (cCert == 1) {
        pIssuerCert = pRevPara->pIssuerCert;
        if (NULL == pIssuerCert && CertCompareCertificateName(
                pSubjectCert->dwCertEncodingType,
                &pSubjectCert->pCertInfo->Subject,
                &pSubjectCert->pCertInfo->Issuer))
            // Self issued
            pIssuerCert = pSubjectCert;
    } else if (dwFlags & CERT_VERIFY_REV_CHAIN_FLAG)
        pIssuerCert = rgpCert[1];

    if (pIssuerCert)
        pIssuerCert = CertDuplicateCertificateContext(pIssuerCert);
    else {
        pIssuerCert = FindIssuerCertInStores(
            pSubjectCert, pRevPara->cCertStore, pRevPara->rgCertStore);
        if (NULL == pIssuerCert)
            pIssuerCert = FindIssuerCertInDefaultStores(pSubjectCert);
    }

    if (NULL == pIssuerCert)
        SetLastError((DWORD) CRYPT_E_REVOCATION_OFFLINE);
    return pIssuerCert;
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlIssuerIsCertIssuer
//
//  Synopsis:   is the issuer of the CRL the issuer of the cert
//
//----------------------------------------------------------------------------
BOOL CrlIssuerIsCertIssuer (
        IN PCCERT_CONTEXT pCert,
        IN PCERT_EXTENSION pCrlDistPointExt
        )
{
    BOOL                  fResult = FALSE;
    DWORD                 cb = sizeof( PCRL_DIST_POINTS_INFO );
    PCRL_DIST_POINTS_INFO pDistPointInfo;

    if ( pCrlDistPointExt == NULL )
    {
        return( TRUE );
    }

    if ( CryptDecodeObjectEx(
              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
              szOID_CRL_DIST_POINTS,
              pCrlDistPointExt->Value.pbData,
              pCrlDistPointExt->Value.cbData,
              CRYPT_DECODE_ALLOC_FLAG,
              NULL,
              (void *)&pDistPointInfo,
              &cb
              ) == TRUE )
    {
        if ( pDistPointInfo->cDistPoint > 0 )
        {
            if ( pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.cAltEntry == 0 )
            {
                fResult = TRUE;
            }
            else if ( pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.rgAltEntry[ 0 ].dwAltNameChoice == CERT_ALT_NAME_DIRECTORY_NAME )
            {
                if ( pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.rgAltEntry[ 0 ].DirectoryName.cbData == 0 )
                {
                    fResult = TRUE;
                }
                else if ( ( pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.rgAltEntry[ 0 ].DirectoryName.cbData ==
                            pCert->pCertInfo->Issuer.cbData ) &&
                          ( memcmp(
                               pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.rgAltEntry[ 0 ].DirectoryName.pbData,
                               pCert->pCertInfo->Issuer.pbData,
                               pCert->pCertInfo->Issuer.cbData
                               ) == 0 ) )
                {
                    fResult = TRUE;
                }
            }
        }
        else
        {
            fResult = TRUE;
        }

        LocalFree( pDistPointInfo );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertDllVerifyRevocation
//
//  Synopsis:   Dispatches to msrevoke
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    return MicrosoftCertDllVerifyRevocation(
                       dwEncodingType,
                       dwRevType,
                       cContext,
                       rgpvContext,
                       dwFlags,
                       pRevPara,
                       pRevStatus
                       );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\offurl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       offurl.cpp
//
//  Contents:   Offline URL Caching
//
//  History:    19-Jan-00    philh    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//----------------------------------------------------------------------------
#include <global.hxx>


//
// Offline URL Cache Entry.
//
// The earliest wire retrieval is delayed according to the number of
// offline failures.
//
// For a successful wire URL retrieval, the entry is removed and deleted.
//
// Assumption: the number of offline entries is small, less than 20.
//
typedef struct _OFFLINE_URL_CACHE_ENTRY
                        OFFLINE_URL_CACHE_ENTRY, *POFFLINE_URL_CACHE_ENTRY;
struct _OFFLINE_URL_CACHE_ENTRY {
    CRYPT_DATA_BLOB             UrlBlob;
    CRYPT_DATA_BLOB             ExtraBlob;
    DWORD                       dwContextOid;
    OFFLINE_URL_TIME_INFO       OfflineUrlTimeInfo;
    POFFLINE_URL_CACHE_ENTRY    pNext;
    POFFLINE_URL_CACHE_ENTRY    pPrev;
};

CRITICAL_SECTION            OfflineUrlCacheCriticalSection;
POFFLINE_URL_CACHE_ENTRY    pOfflineUrlCacheHead;


//
// Local Functions (Forward Reference)
// 

//  Assumption: OfflineUrlCache is locked
POFFLINE_URL_CACHE_ENTRY
WINAPI
CreateAndAddOfflineUrlCacheEntry(
    IN PCRYPT_DATA_BLOB pUrlBlob,
    IN PCRYPT_DATA_BLOB pExtraBlob,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

//  Assumption: OfflineUrlCache is locked
VOID
WINAPI
RemoveAndFreeOfflineUrlCacheEntry(
    IN OUT POFFLINE_URL_CACHE_ENTRY pEntry
    );

//  Assumption: OfflineUrlCache is locked
POFFLINE_URL_CACHE_ENTRY
WINAPI
FindOfflineUrlCacheEntry(
    IN PCRYPT_DATA_BLOB pUrlBlob,
    IN PCRYPT_DATA_BLOB pExtraBlob,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );



VOID
WINAPI
InitializeOfflineUrlCache()
{
    Pki_InitializeCriticalSection(&OfflineUrlCacheCriticalSection);
}

VOID
WINAPI
DeleteOfflineUrlCache()
{
    while (pOfflineUrlCacheHead)
        RemoveAndFreeOfflineUrlCacheEntry(pOfflineUrlCacheHead);

    DeleteCriticalSection(&OfflineUrlCacheCriticalSection);
}


//
// Return status:
//  +1 - Online
//   0 - Offline, current time >= earliest online time, hit the wire
//  -1 - Offline, current time < earliest onlime time
//
LONG
WINAPI
GetOfflineUrlTimeStatus(
    IN POFFLINE_URL_TIME_INFO pInfo
    )
{
    FILETIME CurrentTime;

    if (0 == pInfo->dwOfflineCnt)
    {
        return 1;
    }

    GetSystemTimeAsFileTime(&CurrentTime);
    if (0 <= CompareFileTime(&CurrentTime, &pInfo->EarliestOnlineTime))
    {
        return 0;
    }
    else
    {
        return -1;
    }
}


const DWORD rgdwOfflineUrlDeltaSeconds[] = {
    15,                 // 15 seconds
    15,                 // 15 seconds
    60,                 // 1 minute
    60 * 5,             // 5 minutes
    60 * 10,            // 10 minutes
    60 * 30,            // 30 minutes
};

#define OFFLINE_URL_DELTA_SECONDS_CNT \
    (sizeof(rgdwOfflineUrlDeltaSeconds) / \
        sizeof(rgdwOfflineUrlDeltaSeconds[0]))


VOID
WINAPI
SetOfflineUrlTime(
    IN OUT POFFLINE_URL_TIME_INFO pInfo
    )
{
    DWORD dwOfflineCnt;
    FILETIME CurrentTime;

    dwOfflineCnt = ++pInfo->dwOfflineCnt;

    if (OFFLINE_URL_DELTA_SECONDS_CNT < dwOfflineCnt)
    {
        dwOfflineCnt = OFFLINE_URL_DELTA_SECONDS_CNT;
    }

    GetSystemTimeAsFileTime( &CurrentTime );
    I_CryptIncrementFileTimeBySeconds(
        &CurrentTime,
        rgdwOfflineUrlDeltaSeconds[dwOfflineCnt - 1],
        &pInfo->EarliestOnlineTime
        );
}

VOID
WINAPI
SetOnlineUrlTime(
    IN OUT POFFLINE_URL_TIME_INFO pInfo
    )
{
    pInfo->dwOfflineCnt = 0;
}




//
// Return status:
//  +1 - Online
//   0 - Offline, current time >= earliest online time, hit the wire
//  -1 - Offline, current time < earliest onlime time
//
LONG
WINAPI
GetOriginUrlStatusW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    LONG lStatus;
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = OriginIdentifier;
    ExtraBlob.cbData = MD5DIGESTLEN;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );
    if (pEntry)
        lStatus = GetOfflineUrlTimeStatus(&pEntry->OfflineUrlTimeInfo);
    else
        lStatus = 1;

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);

    return lStatus;
}

VOID
WINAPI
SetOnlineOriginUrlW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = OriginIdentifier;
    ExtraBlob.cbData = MD5DIGESTLEN;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );
    if (pEntry)
        RemoveAndFreeOfflineUrlCacheEntry(pEntry);

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);
}

VOID
WINAPI
SetOfflineOriginUrlW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = OriginIdentifier;
    ExtraBlob.cbData = MD5DIGESTLEN;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );

    if (NULL == pEntry)
        pEntry = CreateAndAddOfflineUrlCacheEntry( 
            &UrlBlob,
            &ExtraBlob,
            pszContextOid,
            dwRetrievalFlags
            );

    if (pEntry)
        SetOfflineUrlTime(&pEntry->OfflineUrlTimeInfo);

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);
}


//
// Return status:
//  +1 - Online
//   0 - Offline, current time >= earliest online time, hit the wire
//  -1 - Offline, current time < earliest onlime time
//
LONG
WINAPI
GetUrlStatusW(
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    LONG lStatus;
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = NULL;
    ExtraBlob.cbData = 0;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );
    if (pEntry)
        lStatus = GetOfflineUrlTimeStatus(&pEntry->OfflineUrlTimeInfo);
    else
        lStatus = 1;

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);

    return lStatus;
}

VOID
WINAPI
SetOnlineUrlW(
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = NULL;
    ExtraBlob.cbData = 0;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );
    if (pEntry)
        RemoveAndFreeOfflineUrlCacheEntry(pEntry);

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);
}

VOID
WINAPI
SetOfflineUrlW(
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = NULL;
    ExtraBlob.cbData = 0;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );

    if (NULL == pEntry)
        pEntry = CreateAndAddOfflineUrlCacheEntry( 
            &UrlBlob,
            &ExtraBlob,
            pszContextOid,
            dwRetrievalFlags
            );

    if (pEntry)
        SetOfflineUrlTime(&pEntry->OfflineUrlTimeInfo);

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);
}

inline
DWORD
GetOfflineUrlCacheContextOid(
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    DWORD dwContextOid;

    if (0xFFFF >= (DWORD) ((DWORD_PTR) pszContextOid))
        dwContextOid = (DWORD) ((DWORD_PTR) pszContextOid);
    else
        dwContextOid = 0x10000;

    if (dwRetrievalFlags & CRYPT_WIRE_ONLY_RETRIEVAL)
        dwContextOid |= 0x20000;

    return dwContextOid;
}

//  Assumption: OfflineUrlCache is locked
POFFLINE_URL_CACHE_ENTRY
WINAPI
CreateAndAddOfflineUrlCacheEntry(
    IN PCRYPT_DATA_BLOB pUrlBlob,
    IN PCRYPT_DATA_BLOB pExtraBlob,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    DWORD cbEntry;
    BYTE *pb;

    cbEntry = sizeof(OFFLINE_URL_CACHE_ENTRY) +
        pUrlBlob->cbData + pExtraBlob->cbData;

    pEntry = (POFFLINE_URL_CACHE_ENTRY) new BYTE [cbEntry];

    if (pEntry == NULL)
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( NULL );
    }

    memset( pEntry, 0, sizeof( OFFLINE_URL_CACHE_ENTRY ) );
    pb = (BYTE *) &pEntry[1];

    if (pUrlBlob->cbData) {
        pEntry->UrlBlob.pbData = pb;
        pEntry->UrlBlob.cbData = pUrlBlob->cbData;
        memcpy(pb, pUrlBlob->pbData, pUrlBlob->cbData);
        pb += pUrlBlob->cbData;
    }

    if (pExtraBlob->cbData) {
        pEntry->ExtraBlob.pbData = pb;
        pEntry->ExtraBlob.cbData = pExtraBlob->cbData;
        memcpy(pb, pExtraBlob->pbData, pExtraBlob->cbData);
    }

    pEntry->dwContextOid =
        GetOfflineUrlCacheContextOid(pszContextOid, dwRetrievalFlags);

    if (pOfflineUrlCacheHead) {
        assert(NULL == pOfflineUrlCacheHead->pPrev);
        pOfflineUrlCacheHead->pPrev = pEntry;
        pEntry->pNext = pOfflineUrlCacheHead;
    }
    // else
    //  pEntry->pNext = NULL;        // already zeroed above

    // pEntry->pPrev = NULL;        // already zeroed above
    pOfflineUrlCacheHead = pEntry;

    return pEntry;
}


//  Assumption: OfflineUrlCache is locked
VOID
WINAPI
RemoveAndFreeOfflineUrlCacheEntry(
    IN OUT POFFLINE_URL_CACHE_ENTRY pEntry
    )
{
    if (pEntry->pNext)
    {
        pEntry->pNext->pPrev = pEntry->pPrev;
    }

    if (pEntry->pPrev)
    {
        pEntry->pPrev->pNext = pEntry->pNext;
    }
    else
    {
        assert(pOfflineUrlCacheHead == pEntry);
        pOfflineUrlCacheHead = pEntry->pNext;
    }

    delete (LPBYTE) pEntry;
}

//  Assumption: OfflineUrlCache is locked
POFFLINE_URL_CACHE_ENTRY
WINAPI
FindOfflineUrlCacheEntry(
    IN PCRYPT_DATA_BLOB pUrlBlob,
    IN PCRYPT_DATA_BLOB pExtraBlob,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    DWORD cbUrl = pUrlBlob->cbData;
    BYTE *pbUrl = pUrlBlob->pbData;
    DWORD cbExtra = pExtraBlob->cbData;
    BYTE *pbExtra = pExtraBlob->pbData;
    DWORD dwContextOid;
    POFFLINE_URL_CACHE_ENTRY pEntry;

    dwContextOid =
        GetOfflineUrlCacheContextOid(pszContextOid, dwRetrievalFlags);

    for (pEntry = pOfflineUrlCacheHead; pEntry; pEntry = pEntry->pNext)
    {
        if (pEntry->dwContextOid == dwContextOid
                        &&
            pEntry->UrlBlob.cbData == cbUrl
                        &&
            pEntry->ExtraBlob.cbData == cbExtra
                        &&
            (0 == cbExtra || 0 == memcmp(
                pEntry->ExtraBlob.pbData, pbExtra, cbExtra))
                        &&
            (0 == cbUrl || 0 == memcmp(
                pEntry->UrlBlob.pbData, pbUrl, cbUrl))
                        )
        {
            return pEntry;
        }
    }

    return ( NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\origin.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       origin.cpp
//
//  Contents:   Origin Identifier implementation
//
//  History:    10-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   CertGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetOriginIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    PCERT_INFO pIssuerCertInfo = pIssuer->pCertInfo;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pIssuerCertInfo->Subject.pbData, pIssuerCertInfo->Subject.cbData );
    MD5Update( &md5ctx, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData );

    MD5Update(
       &md5ctx,
       (LPBYTE)pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
       strlen( pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId )
       );

    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData
       );

    // We assume that the unused public key bits are zero
    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a CTL
//
//----------------------------------------------------------------------------
BOOL WINAPI CtlGetOriginIdentifier (
                IN PCCTL_CONTEXT pCtlContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    DWORD      cCount;
    PCTL_INFO  pCtlInfo = pCtlContext->pCtlInfo;
    PCTL_USAGE pCtlUsage = &( pCtlContext->pCtlInfo->SubjectUsage );
    PCERT_INFO pIssuerCertInfo = pIssuer->pCertInfo;

    MD5Init( &md5ctx );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->Subject.pbData,
       pIssuerCertInfo->Subject.cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SerialNumber.pbData,
       pIssuerCertInfo->SerialNumber.cbData
       );

    for ( cCount = 0; cCount < pCtlUsage->cUsageIdentifier; cCount++ )
    {
        MD5Update(
           &md5ctx,
           (LPBYTE)pCtlUsage->rgpszUsageIdentifier[cCount],
           strlen( pCtlUsage->rgpszUsageIdentifier[cCount] )
           );
    }

    MD5Update(
       &md5ctx,
       pCtlInfo->ListIdentifier.pbData,
       pCtlInfo->ListIdentifier.cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetOriginIdentifierFromCrlIssuer
//
//  Synopsis:   get origin identifier for a CRL given the CRL's issuer cert
//
//  Comments:   A freshest, delta CRL will have a different OriginIdentifier
//              from a base CRL having the same issuer.
//
//----------------------------------------------------------------------------
BOOL WINAPI CrlGetOriginIdentifierFromCrlIssuer (
               IN PCCERT_CONTEXT pIssuerContext,
               IN PCERT_NAME_BLOB pIssuerName,
               IN BOOL fFreshest,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               )
{
    MD5_CTX    md5ctx;
    PCERT_INFO pIssuerCertInfo = pIssuerContext->pCertInfo;
    BYTE       bFreshest;


    MD5Init( &md5ctx );
    
    if (fFreshest)
    {
        bFreshest = 1;
    }
    else
    {
        bFreshest = 0;
    }

    MD5Update(
       &md5ctx,
       &bFreshest,
       sizeof(bFreshest)
       );

    MD5Update(
       &md5ctx,
       pIssuerName->pbData,
       pIssuerName->cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI CrlGetOriginIdentifier (
                IN PCCRL_CONTEXT pCrlContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    BOOL fFreshest;

    // See if this is a delta, freshest CRL.
    if (CertFindExtension(
            szOID_DELTA_CRL_INDICATOR,
            pCrlContext->pCrlInfo->cExtension,
            pCrlContext->pCrlInfo->rgExtension
            ))
    {
        fFreshest = TRUE;
    }
    else
    {
        fFreshest = FALSE;
    }

    return CrlGetOriginIdentifierFromCrlIssuer (
        pIssuer,
        &pCrlContext->pCrlInfo->Issuer,
        fFreshest,
        OriginIdentifier
        );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetOriginIdentifierFromSubjectCert
//
//  Synopsis:   get origin identifier for a CRL given the subject cert
//
//  Comments:   OBJECT_CONTEXT_FRESHEST_CRL_FLAG can be set in dwFlags.
//
//  Assumption: Subject certificate and CRL's issuer are the same.
//----------------------------------------------------------------------------
BOOL WINAPI CrlGetOriginIdentifierFromSubjectCert (
               IN PCCERT_CONTEXT pSubjectCert,
               IN PCCERT_CONTEXT pIssuer,
               IN BOOL fFreshest,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               )
{
    //
    // NOTENOTE: For the first version of this code we assume that the
    //           issuer of the CRL and the issuer of a subject certificate
    //           in the CRL are the same.  Therefore, we can calculate
    //           the CRL origin identifier by using the subject cert's
    //           issuer name
    //

    return CrlGetOriginIdentifierFromCrlIssuer (
        pIssuer,
        &pSubjectCert->pCertInfo->Issuer,
        fFreshest,
        OriginIdentifier
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\offurl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       offurl.h
//
//  Contents:   Offline URL Caching
//
//  History:    19-Jan-00    philh    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#if !defined(__CRYPTNET_OFFURL_H__)
#define __CRYPTNET_OFFURL_H__

#include <origin.h>

VOID
WINAPI
InitializeOfflineUrlCache();

VOID
WINAPI
DeleteOfflineUrlCache();

//
// Offline Url Time Information.
//
// For each offline detection, dwOfflineCnt is incrmented and
// EarliestOnlineTime =
//      CurrentTime + rgdwOfflineUrlDeltaSeconds[dwOfflineCnt - 1]
//
// On the next online detection, dwOfflineCnt is cleared.
//
typedef struct _OFFLINE_URL_TIME_INFO {
    // If dwOfflineCnt != 0, then, offline and the wire
    // won't be hit until CurrentTime >= EarliestOnlineTime
    DWORD                   dwOfflineCnt;
    FILETIME                EarliestOnlineTime;
} OFFLINE_URL_TIME_INFO, *POFFLINE_URL_TIME_INFO;

//
// Return status:
//  +1 - Online
//   0 - Offline, current time >= earliest online time, hit the wire
//  -1 - Offline, current time < earliest onlime time
//
LONG
WINAPI
GetOfflineUrlTimeStatus(
    IN POFFLINE_URL_TIME_INFO pInfo
    );

VOID
WINAPI
SetOfflineUrlTime(
    IN OUT POFFLINE_URL_TIME_INFO pInfo
    );

VOID
WINAPI
SetOnlineUrlTime(
    IN OUT POFFLINE_URL_TIME_INFO pInfo
    );

LONG
WINAPI
GetOriginUrlStatusW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

VOID
WINAPI
SetOnlineOriginUrlW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

VOID
WINAPI
SetOfflineOriginUrlW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

LONG
WINAPI
GetUrlStatusW(
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

VOID
WINAPI
SetOnlineUrlW(
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

VOID
WINAPI
SetOfflineUrlW(
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\origin.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       origin.h
//
//  Contents:   Crypt Origin Identifier Definitions
//
//  History:    10-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ORIGIN_H__)
#define __ORIGIN_H__

#include <md5.h>

//
// A CRYPT_ORIGIN_IDENTIFIER is an MD5 hash of selected components of a
// CAPI2 object.  This allows a unique identifier to be derived for any
// CAPI2 object where any two objects with the same origin identifier
// are the same object at possibly different points in its evolution.
// If those objects have the same HASH id then they are the same object
// at the same point in time.  For the main CAPI2 objects the selected
// components are as follows:
//
// All objects: Issuer public key
//
// Certificate: Issuer Name, Subject Name, Public Key
//
// CTL: Appropriate Issuer Name and Issuer Serial No., Usage, List Identifier
//
// CRL: Issuer Name (an issuer can only publish ONE CRL, Hygiene work in
//      progress)
//

typedef BYTE CRYPT_ORIGIN_IDENTIFIER[ MD5DIGESTLEN ];

//
// Function prototypes
//

BOOL WINAPI CertGetOriginIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                );

BOOL WINAPI CtlGetOriginIdentifier (
               IN PCCTL_CONTEXT pCtlContext,
               IN PCCERT_CONTEXT pIssuer,
               IN DWORD dwFlags,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               );

BOOL WINAPI CrlGetOriginIdentifier (
               IN PCCRL_CONTEXT pCrlContext,
               IN PCCERT_CONTEXT pIssuer,
               IN DWORD dwFlags,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               );

BOOL WINAPI CrlGetOriginIdentifierFromSubjectCert (
               IN PCCERT_CONTEXT pSubjectCert,
               IN PCCERT_CONTEXT pIssuer,
               IN BOOL fFreshest,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\orm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       orm.h
//
//  Contents:   Object Retrieval Manager class definition
//
//  History:    24-Jul-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#if !defined(__ORM_H__)
#define __ORM_H__

//
// IRefCountedObject.  Abstract base class to provide reference counting
//

class IRefCountedObject
{
public:

    virtual VOID AddRef () = 0;
    virtual VOID Release () = 0;
};

//
// IObjectRetriever.  Abstract base class for object retrieval
//

class IObjectRetriever : public IRefCountedObject
{
public:

    virtual BOOL RetrieveObjectByUrl (
                         LPCWSTR pwszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         ) = 0;

    virtual BOOL CancelAsyncRetrieval () = 0;
};

//
// CObjectRetrievalManager.  Manages retrieval of PKI objects when requested
// via CryptRetrieveObjectByUrl.
//

class CObjectRetrievalManager : public IObjectRetriever
{
public:

    //
    // Construction
    //

    CObjectRetrievalManager ();
    ~CObjectRetrievalManager ();

    //
    // IRefCountedObject methods
    //

    virtual VOID AddRef ();
    virtual VOID Release ();

    //
    // IObjectRetriever methods
    //

    virtual BOOL RetrieveObjectByUrl (
                         LPCWSTR pwszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         );

    virtual BOOL CancelAsyncRetrieval ();

    //
    // Retrieval Notification methods
    //

    BOOL OnRetrievalCompletion (
                    DWORD dwCompletionCode,
                    LPCWSTR pwszUrl,
                    LPCSTR pszObjectOid,
                    DWORD dwRetrievalFlags,
                    PCRYPT_BLOB_ARRAY pObject,
                    PFN_FREE_ENCODED_OBJECT_FUNC pfnFreeObject,
                    LPVOID pvFreeContext,
                    LPVOID pvVerify,
                    LPVOID* ppvObject
                    );

private:

    //
    // Reference count
    //

    ULONG                        m_cRefs;

    //
    // Scheme Provider entry points
    //

    HCRYPTOIDFUNCADDR            m_hSchemeRetrieve;
    PFN_SCHEME_RETRIEVE_FUNC     m_pfnSchemeRetrieve;

    //
    // Context Provider entry points
    //

    HCRYPTOIDFUNCADDR            m_hContextCreate;
    PFN_CONTEXT_CREATE_FUNC      m_pfnContextCreate;

    //
    // Private methods
    //

    //
    // Parameter validation
    //

    BOOL ValidateRetrievalArguments (
                 LPCWSTR pwszUrl,
                 LPCSTR pszObjectOid,
                 DWORD dwRetrievalFlags,
                 DWORD dwTimeout,
                 LPVOID* ppvObject,
                 HCRYPTASYNC hAsyncRetrieve,
                 PCRYPT_CREDENTIALS pCredentials,
                 LPVOID pvVerify,
                 PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 );

    //
    // Provider initialization
    //

    BOOL LoadProviders (
             LPCWSTR pwszUrl,
             LPCSTR pszObjectOid
             );

    VOID UnloadProviders ();

    //
    // Provider entry point usage
    //

    BOOL CallSchemeRetrieveObjectByUrl (
                   LPCWSTR pwszUrl,
                   LPCSTR pszObjectOid,
                   DWORD dwRetrievalFlags,
                   DWORD dwTimeout,
                   PCRYPT_BLOB_ARRAY pObject,
                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                   LPVOID* ppvFreeContext,
                   HCRYPTASYNC hAsyncRetrieve,
                   PCRYPT_CREDENTIALS pCredentials,
                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                   );

    BOOL CallContextCreateObjectContext (
                    LPCSTR pszObjectOid,
                    DWORD dwRetrievalFlags,
                    PCRYPT_BLOB_ARRAY pObject,
                    LPVOID* ppvContext
                    );
};

//
// Provider table externs
//

extern HCRYPTOIDFUNCSET hSchemeRetrieveFuncSet;
extern HCRYPTOIDFUNCSET hContextCreateFuncSet;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\orm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       orm.cpp
//
//  Contents:   Implementation of object retrieval manager
//
//  History:    24-Jul-97    kirtd    Created
//              01-Jan-02    philh    Changed to internally use UNICODE Urls
//
//----------------------------------------------------------------------------
#include <global.hxx>

#ifndef INTERNET_MAX_SCHEME_LENGTH
#define INTERNET_MAX_SCHEME_LENGTH      32          // longest protocol name length
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::CObjectRetrievalManager, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CObjectRetrievalManager::CObjectRetrievalManager ()
{
    m_cRefs = 1;
    m_hSchemeRetrieve = NULL;
    m_pfnSchemeRetrieve = NULL;
    m_hContextCreate = NULL;
    m_pfnContextCreate = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::~CObjectRetrievalManager, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CObjectRetrievalManager::~CObjectRetrievalManager ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::AddRef, public
//
//  Synopsis:   IRefCountedObject::AddRef
//
//----------------------------------------------------------------------------
VOID
CObjectRetrievalManager::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::Release, public
//
//  Synopsis:   IRefCountedObject::Release
//
//----------------------------------------------------------------------------
VOID
CObjectRetrievalManager::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::RetrieveObjectByUrl, public
//
//  Synopsis:   object retrieval given an URL
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::RetrieveObjectByUrl (
                                 LPCWSTR pwszUrl,
                                 LPCSTR pszObjectOid,
                                 DWORD dwRetrievalFlags,
                                 DWORD dwTimeout,
                                 LPVOID* ppvObject,
                                 PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                 LPVOID* ppvFreeContext,
                                 HCRYPTASYNC hAsyncRetrieve,
                                 PCRYPT_CREDENTIALS pCredentials,
                                 LPVOID pvVerify,
                                 PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                 )
{
    BOOL                          fResult;
    CRYPT_BLOB_ARRAY              cba;
    PFN_FREE_ENCODED_OBJECT_FUNC  pfnFreeObject = NULL;
    LPVOID                        pvFreeContext = NULL;

    assert( ppfnFreeObject == NULL );
    assert( ppvFreeContext == NULL );

    //
    // Validate arguments and initialize the providers
    //

    fResult = ValidateRetrievalArguments(
                      pwszUrl,
                      pszObjectOid,
                      dwRetrievalFlags,
                      dwTimeout,
                      ppvObject,
                      hAsyncRetrieve,
                      pCredentials,
                      pvVerify,
                      pAuxInfo
                      );

    if ( fResult == TRUE )
    {
        fResult = LoadProviders( pwszUrl, pszObjectOid );
    }

    //
    // For Async support we should prepare here
    //

    //
    // Call the scheme provider to process the retrieval
    //

    if ( fResult == TRUE )
    {
        //  +1 - Online
        //   0 - Offline, current time >= earliest online time, hit the wire
        //  -1 - Offline, current time < earliest onlime time
        LONG lStatus;

        if ( CRYPT_OFFLINE_CHECK_RETRIEVAL ==
                ( dwRetrievalFlags & ( CRYPT_OFFLINE_CHECK_RETRIEVAL |
                                       CRYPT_CACHE_ONLY_RETRIEVAL ) ) )
        {
            lStatus = GetUrlStatusW( pwszUrl, pszObjectOid, dwRetrievalFlags );
        }
        else
        {
            lStatus = 1;
        }

        if (lStatus >= 0)
        {
            fResult = CallSchemeRetrieveObjectByUrl(
                            pwszUrl,
                            pszObjectOid,
                            dwRetrievalFlags,
                            dwTimeout,
                            &cba,
                            &pfnFreeObject,
                            &pvFreeContext,
                            hAsyncRetrieve,
                            pCredentials,
                            pAuxInfo
                            );
            if ( CRYPT_OFFLINE_CHECK_RETRIEVAL ==
                    ( dwRetrievalFlags & ( CRYPT_OFFLINE_CHECK_RETRIEVAL |
                                           CRYPT_CACHE_ONLY_RETRIEVAL ) ) )
            {
                if ( fResult != TRUE )
                {
                    DWORD dwErr = GetLastError();
                    SetOfflineUrlW( pwszUrl, pszObjectOid, dwRetrievalFlags );
                    SetLastError( dwErr );
                }
                else if ( lStatus == 0 )
                {
                    SetOnlineUrlW( pwszUrl, pszObjectOid, dwRetrievalFlags );
                }
            }
        }
        else
        {
            SetLastError( (DWORD) ERROR_NOT_CONNECTED );
            fResult = FALSE;
        }
    }

    //
    // If we successfully retrieved the object and this is a synchronous
    // retrieval, then we call our own OnRetrievalCompletion in order
    // to complete the processing
    //

    if ( ( fResult == TRUE ) && !( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        fResult = OnRetrievalCompletion(
                             S_OK,
                             pwszUrl,
                             pszObjectOid,
                             dwRetrievalFlags,
                             &cba,
                             pfnFreeObject,
                             pvFreeContext,
                             pvVerify,
                             ppvObject
                             );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::CancelAsyncRetrieval, public
//
//  Synopsis:   cancel asynchronous retrieval
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::CancelAsyncRetrieval ()
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::OnRetrievalCompletion, public
//
//  Synopsis:   completion notification
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::OnRetrievalCompletion (
                                    DWORD dwCompletionCode,
                                    LPCWSTR pwszUrl,
                                    LPCSTR pszObjectOid,
                                    DWORD dwRetrievalFlags,
                                    PCRYPT_BLOB_ARRAY pObject,
                                    PFN_FREE_ENCODED_OBJECT_FUNC pfnFreeObject,
                                    LPVOID pvFreeContext,
                                    LPVOID pvVerify,
                                    LPVOID* ppvObject
                                    )
{
    BOOL fResult = FALSE;

    //
    // If the retrieval was successfully completed, we go about getting the
    // appropriate return value for *ppvObject.  If an OID was given then
    // we must use the context provider to convert the encoded bits into
    // a context value.  Otherwise, we hand back a buffer with the encoded
    // bits
    //

    if ( dwCompletionCode == (DWORD)S_OK )
    {
        if ( pszObjectOid != NULL )
        {
            fResult = CallContextCreateObjectContext(
                                 pszObjectOid,
                                 dwRetrievalFlags,
                                 pObject,
                                 ppvObject
                                 );

            if ( fResult == TRUE )
            {
                if ( dwRetrievalFlags & CRYPT_VERIFY_CONTEXT_SIGNATURE )
                {
                    fResult = ObjectContextVerifySignature(
                                    pszObjectOid,
                                    *ppvObject,
                                    (PCCERT_CONTEXT)pvVerify
                                    );
                }
            }
        }
        else
        {
            CCryptBlobArray cba( pObject, 0 );

            fResult = cba.GetArrayInSingleBufferEncodedForm(
                                  (PCRYPT_BLOB_ARRAY *)ppvObject
                                  );
        }

        ( *pfnFreeObject )( pszObjectOid, pObject, pvFreeContext );
    }

    //
    // We can now unload the providers
    //

    UnloadProviders();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::ValidateRetrievalArguments, private
//
//  Synopsis:   validate arguments to RetrieveObjectByUrl
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::ValidateRetrievalArguments (
                                 LPCWSTR pwszUrl,
                                 LPCSTR pszObjectOid,
                                 DWORD dwRetrievalFlags,
                                 DWORD dwTimeout,
                                 LPVOID* ppvObject,
                                 HCRYPTASYNC hAsyncRetrieve,
                                 PCRYPT_CREDENTIALS pCredentials,
                                 LPVOID pvVerify,
                                 PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                 )
{
    //
    // Assume badness :-)
    //

    SetLastError( (DWORD) E_INVALIDARG );

    //
    // Must have an URL
    //
    //         It is possible that this will be ok in the async case
    //         and the URLs will be parameters on the HCRYPTASYNC
    //

    if ( pwszUrl == NULL )
    {
        return( FALSE );
    }

    //
    // NOTENOTE: For now we fail async support and I know that I have
    //           other async flag checks below, they are there as a
    //           reminder :-)
    //

    if ( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL )
    {
        return( FALSE );
    }

    //
    // If we retrieve from the cache then we can't be async
    //

    if ( ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) &&
         ( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        return( FALSE );
    }

    //
    // If we retrieve from the wire we can't be only retrieving from the
    // cache
    //

    if ( ( dwRetrievalFlags & CRYPT_WIRE_ONLY_RETRIEVAL ) &&
         ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
    {
        return( FALSE );
    }

    //
    // If we are retrieving async we must have an async handle
    //

    if ( ( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) &&
         ( hAsyncRetrieve == NULL ) )
    {
        return( FALSE );
    }

    //
    //         This is a temporary check since CRYPT_VERIFY_DATA_HASH is not
    //         yet implemented
    //

    if ( dwRetrievalFlags & CRYPT_VERIFY_DATA_HASH )
    {
        SetLastError( (DWORD) E_NOTIMPL );
        return( FALSE );
    }

    //
    // We can't have both CRYPT_VERIFY_CONTEXT_SIGNATURE and
    // CRYPT_VERIFY_DATA_HASH set
    //

    if ( ( dwRetrievalFlags &
           ( CRYPT_VERIFY_CONTEXT_SIGNATURE | CRYPT_VERIFY_DATA_HASH ) ) ==
         ( CRYPT_VERIFY_CONTEXT_SIGNATURE | CRYPT_VERIFY_DATA_HASH ) )
    {
        return( FALSE );
    }

    //
    // If either of the above is set, then pvVerify should be non NULL and
    // CRYPT_RETRIEVE_MULTIPLE_OBJECTS should not be set
    //

    if ( ( dwRetrievalFlags &
           ( CRYPT_VERIFY_CONTEXT_SIGNATURE | CRYPT_VERIFY_DATA_HASH ) ) &&
         ( ( pvVerify == NULL ) ||
           ( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) ) )
    {
        return( FALSE );
    }

    //
    // We must have an out parameter
    //

    if ( ppvObject == NULL )
    {
        return( FALSE );
    }

    SetLastError( 0 );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::LoadProviders, private
//
//  Synopsis:   load scheme and context providers based on URL and OID resp.
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::LoadProviders (
                             LPCWSTR pwszUrl,
                             LPCSTR pszObjectOid
                             )
{
    WCHAR           pwszScheme[INTERNET_MAX_SCHEME_LENGTH+1];
    DWORD           cchScheme = INTERNET_MAX_SCHEME_LENGTH;
    CHAR            pszScheme[INTERNET_MAX_SCHEME_LENGTH+1];
    HRESULT         hr = E_UNEXPECTED;

    //
    // Get the scheme
    //

    __try
    {

        hr = UrlGetPartW(
            pwszUrl,
            pwszScheme,
            &cchScheme,
            URL_PART_SCHEME,
            0                   // dwFlags
            );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_UNEXPECTED;
    }

    if (S_OK != hr || 0 == cchScheme)
    {
        LPWSTR pwsz;
        DWORD cch;

        pwsz = wcschr( pwszUrl, L':' );
        if ( pwsz != NULL )
        {
            cch = (DWORD)(pwsz - pwszUrl);
            if ( cch > INTERNET_MAX_SCHEME_LENGTH )
            {
                return( FALSE );
            }

            memcpy( pwszScheme, pwszUrl, cch * sizeof(WCHAR) );
            pwszScheme[cch] = L'\0';
        }
        else
        {
            wcscpy( pwszScheme, L"file" );
        }
    }

    if (!WideCharToMultiByte(
             CP_ACP,
             0,
             pwszScheme,
             -1,
             pszScheme,
             sizeof(pszScheme) - 1,
             NULL,
             NULL
             ))
    {
        return( FALSE );
    }


    //
    // Use the scheme to load the appropriate scheme provider
    //

    if ( CryptGetOIDFunctionAddress(
              hSchemeRetrieveFuncSet,
              X509_ASN_ENCODING,
              pszScheme,
              0,
              (LPVOID *)&m_pfnSchemeRetrieve,
              &m_hSchemeRetrieve
              ) == FALSE )
    {
        return( FALSE );
    }

    //
    // Load the appropriate context provider using the object oid
    //

    if ( pszObjectOid != NULL )
    {
        if ( CryptGetOIDFunctionAddress(
                  hContextCreateFuncSet,
                  X509_ASN_ENCODING,
                  pszObjectOid,
                  0,
                  (LPVOID *)&m_pfnContextCreate,
                  &m_hContextCreate
                  ) == FALSE )
        {
            return( FALSE );
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::UnloadProviders, private
//
//  Synopsis:   unload scheme and context providers
//
//----------------------------------------------------------------------------
VOID
CObjectRetrievalManager::UnloadProviders ()
{
    if ( m_hSchemeRetrieve != NULL )
    {
        CryptFreeOIDFunctionAddress( m_hSchemeRetrieve, 0 );
        m_hSchemeRetrieve = NULL;
    }

    if ( m_hContextCreate != NULL )
    {
        CryptFreeOIDFunctionAddress( m_hContextCreate, 0 );
        m_hContextCreate = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::CallSchemeRetrieveObjectByUrl, private
//
//  Synopsis:   Call the scheme provider RetrieveObjectByUrl entry point
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::CallSchemeRetrieveObjectByUrl (
                                   LPCWSTR pwszUrl,
                                   LPCSTR pszObjectOid,
                                   DWORD dwRetrievalFlags,
                                   DWORD dwTimeout,
                                   PCRYPT_BLOB_ARRAY pObject,
                                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                   LPVOID* ppvFreeContext,
                                   HCRYPTASYNC hAsyncRetrieve,
                                   PCRYPT_CREDENTIALS pCredentials,
                                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                   )
{
    return( ( *m_pfnSchemeRetrieve ) (
                          pwszUrl,
                          pszObjectOid,
                          dwRetrievalFlags,
                          dwTimeout,
                          pObject,
                          ppfnFreeObject,
                          ppvFreeContext,
                          hAsyncRetrieve,
                          pCredentials,
                          pAuxInfo
                          ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::CallContextCreateObjectContext, private
//
//  Synopsis:   call the context provider CreateObjectContext entry point
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::CallContextCreateObjectContext (
                                    LPCSTR pszObjectOid,
                                    DWORD dwRetrievalFlags,
                                    PCRYPT_BLOB_ARRAY pObject,
                                    LPVOID* ppvContext
                                    )
{
    return( ( *m_pfnContextCreate ) (
                           pszObjectOid,
                           dwRetrievalFlags,
                           pObject,
                           ppvContext
                           ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\rporprov.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rporprov.h
//
//  Contents:   Remote PKI Object Retrieval Provider Prototypes
//
//  History:    23-Jul-97    kirtd    Created
//              01-Jan-02    philh    Moved from wininet to winhttp
//
//----------------------------------------------------------------------------
#if !defined(__RPORPROV_H__)
#define __RPORPROV_H__

#include <md5.h>

#if defined(__cplusplus)
extern "C" {
#endif


// The cached URL Blob Arrays are stored at:
//  - %UserProfile%\Microsoft\CryptnetUrlCache\MetaData
//  - %UserProfile%\Microsoft\CryptnetUrlCache\Content
//
// Where each filename is the ASCII HEX of the MD5 hash of its Unicode URL
// string excluding the NULL terminator.

#define SCHEME_URL_FILENAME_LEN         (MD5DIGESTLEN * 2 + 1)

#define SCHEME_CRYPTNET_URL_CACHE_DIR   L"\\Microsoft\\CryptnetUrlCache\\"
#define SCHEME_META_DATA_SUBDIR         L"MetaData"
#define SCHEME_CCH_META_DATA_SUBDIR     (wcslen(SCHEME_META_DATA_SUBDIR))
#define SCHEME_CONTENT_SUBDIR           L"Content"
#define SCHEME_CCH_CONTENT_SUBDIR       (wcslen(SCHEME_CONTENT_SUBDIR))


// The MetaData file consists of: 
//  - SCHEME_CACHE_META_DATA_HEADER (cbSize bytes in length)
//  - DWORD rgcbBlob[cBlob] - length of each blob in the Content file
//  - BYTE rgbUrl[cbUrl] - NULL terminated Unicode URL

// The Content file consists of:
//  BYTE rgbBlob[][cBlob] - where the length of each blob is obtained from
//  rgcbBlob[] in the MetaData file

typedef struct _SCHEME_CACHE_META_DATA_HEADER {
    DWORD           cbSize;
    DWORD           dwMagic;
    DWORD           cBlob;
    DWORD           cbUrl;
    FILETIME        LastSyncTime;
} SCHEME_CACHE_META_DATA_HEADER, *PSCHEME_CACHE_META_DATA_HEADER;

#define SCHEME_CACHE_META_DATA_MAGIC    0x20020101



//
// Scheme provider prototypes
//

typedef BOOL (WINAPI *PFN_SCHEME_RETRIEVE_FUNC) (
                          IN LPCWSTR pwszUrl,
                          IN LPCSTR pszObjectOid,
                          IN DWORD dwRetrievalFlags,
                          IN DWORD dwTimeout,
                          OUT PCRYPT_BLOB_ARRAY pObject,
                          OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                          OUT LPVOID* ppvFreeContext,
                          IN HCRYPTASYNC hAsyncRetrieve,
                          IN PCRYPT_CREDENTIALS pCredentials,
                          IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                          );

typedef BOOL (WINAPI *PFN_CONTEXT_CREATE_FUNC) (
                          IN LPCSTR pszObjectOid,
                          IN DWORD dwRetrievalFlags,
                          IN PCRYPT_BLOB_ARRAY pObject,
                          OUT LPVOID* ppvContext
                          );

//
// Generic scheme provider utility functions
//


BOOL WINAPI
SchemeCacheCryptBlobArray (
      IN LPCWSTR pwszUrl,
      IN DWORD dwRetrievalFlags,
      IN PCRYPT_BLOB_ARRAY pcba,
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      );

BOOL WINAPI
SchemeRetrieveCachedCryptBlobArray (
      IN LPCWSTR pwszUrl,
      IN DWORD dwRetrievalFlags,
      OUT PCRYPT_BLOB_ARRAY pcba,
      OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
      OUT LPVOID* ppvFreeContext,
      IN OUT PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      );

BOOL WINAPI
SchemeRetrieveUncachedAuxInfo (
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      );

BOOL WINAPI
SchemeDeleteUrlCacheEntry (
      IN LPCWSTR pwszUrl
      );

VOID WINAPI
SchemeFreeEncodedCryptBlobArray (
      IN LPCSTR pszObjectOid,
      IN PCRYPT_BLOB_ARRAY pcba,
      IN LPVOID pvFreeContext
      );

BOOL WINAPI
SchemeGetPasswordCredentialsW (
      IN PCRYPT_CREDENTIALS pCredentials,
      OUT PCRYPT_PASSWORD_CREDENTIALSW pPasswordCredentials,
      OUT BOOL* pfFreeCredentials
      );

VOID WINAPI
SchemeFreePasswordCredentialsW (
      IN PCRYPT_PASSWORD_CREDENTIALSW pPasswordCredentials
      );

BOOL WINAPI
SchemeGetAuthIdentityFromPasswordCredentialsW (
      IN PCRYPT_PASSWORD_CREDENTIALSW pPasswordCredentials,
      OUT PSEC_WINNT_AUTH_IDENTITY_W pAuthIdentity
      );

VOID WINAPI
SchemeFreeAuthIdentityFromPasswordCredentialsW (
      IN PCRYPT_PASSWORD_CREDENTIALSW pPasswordCredentials,
      IN OUT PSEC_WINNT_AUTH_IDENTITY_W pAuthIdentity
      );

//
// LDAP
//

#include <ldapsp.h>

//
// HTTP, HTTPS
//

#include <inetsp.h>

//
// Win32 File I/O
//

#include <filesp.h>

//
// Context Provider prototypes
//

//
// Any, controlled via fQuerySingleContext and dwExpectedContentTypeFlags
//

BOOL WINAPI CreateObjectContext (
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 IN DWORD dwExpectedContentTypeFlags,
                 IN BOOL fQuerySingleContext,
                 OUT LPVOID* ppvContext
                 );

//
// Certificate
//

BOOL WINAPI CertificateCreateObjectContext (
                       IN LPCSTR pszObjectOid,
                       IN DWORD dwRetrievalFlags,
                       IN PCRYPT_BLOB_ARRAY pObject,
                       OUT LPVOID* ppvContext
                       );

//
// CTL
//

BOOL WINAPI CTLCreateObjectContext (
                     IN LPCSTR pszObjectOid,
                     IN DWORD dwRetrievalFlags,
                     IN PCRYPT_BLOB_ARRAY pObject,
                     OUT LPVOID* ppvContext
                     );

//
// CRL
//

BOOL WINAPI CRLCreateObjectContext (
                     IN LPCSTR pszObjectOid,
                     IN DWORD dwRetrievalFlags,
                     IN PCRYPT_BLOB_ARRAY pObject,
                     OUT LPVOID* ppvContext
                     );

//
// PKCS7
//

BOOL WINAPI Pkcs7CreateObjectContext (
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 OUT LPVOID* ppvContext
                 );

//
// CAPI2 objects
//

BOOL WINAPI Capi2CreateObjectContext (
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 OUT LPVOID* ppvContext
                 );

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\scheme.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scheme.cpp
//
//  Contents:   Generic Scheme Provider Utility Functions
//
//  History:    18-Aug-97    kirtd    Created
//              01-Jan-02    philh    Moved from wininet to winhttp
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <userenv.h>
#include <userenvp.h>    // for GetUserAppDataPathW
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  For impersonation, return thread token, otherwise, return process token
//--------------------------------------------------------------------------
HANDLE
WINAPI
I_SchemeGetToken()
{
    HANDLE hToken = NULL;
    DWORD dwErr;

    //
    // first, attempt to look at the thread token.  If none exists,
    // which is true if the thread is not impersonating, try the
    // process token.
    //

    if (!OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                TRUE,
                &hToken
                )) {
        dwErr = GetLastError();
        if (ERROR_NO_TOKEN != dwErr)
            goto OpenThreadTokenError;

        if (!OpenProcessToken(GetCurrentProcess(),
                TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE, &hToken)) {
            dwErr = GetLastError();
            goto OpenProcessTokenError;
        }
    }

CommonReturn:
    return hToken;
ErrorReturn:
    hToken = NULL;
    goto CommonReturn;
SET_ERROR_VAR(OpenThreadTokenError, dwErr)
SET_ERROR_VAR(OpenProcessTokenError, dwErr)
}

//+-------------------------------------------------------------------------
//  Ensure LastError is preserved
//--------------------------------------------------------------------------
VOID
WINAPI
I_SchemeCloseHandle(
    IN HANDLE h
    )
{
    if (h) {
        DWORD dwErr = GetLastError();

        CloseHandle(h);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  Returns %UserProfile%\Microsoft\CryptnetUrlCache\ which must be
//  freed via PkiFree().
//--------------------------------------------------------------------------
LPWSTR
WINAPI
I_SchemeGetCryptnetUrlCacheDir()
{
    DWORD dwErr;
    HANDLE hToken = NULL;
    LPWSTR pwszDir = NULL;
    DWORD cchDir;
    WCHAR wszAppDataPath[MAX_PATH + 1];

    hToken = I_SchemeGetToken();

    wszAppDataPath[0] = L'\0';
    dwErr = GetUserAppDataPathW(
        hToken,
        FALSE,              // fLocalAppData
        wszAppDataPath
        );

    if (ERROR_SUCCESS != dwErr || L'\0' == wszAppDataPath[0])
        goto GetUserAppDataPathError;

    wszAppDataPath[MAX_PATH] = L'\0';

#if DBG
    DbgPrintf(DBG_SS_CRYPT32, "userenv!GetUserAppDataPathW:: %S\n",
        wszAppDataPath);
#endif

    cchDir = wcslen(wszAppDataPath) + wcslen(SCHEME_CRYPTNET_URL_CACHE_DIR) + 1;

    pwszDir = (LPWSTR) PkiNonzeroAlloc(cchDir * sizeof(WCHAR));
    if (NULL == pwszDir)
        goto OutOfMemory;

    wcscpy(pwszDir, wszAppDataPath);
    wcscat(pwszDir, SCHEME_CRYPTNET_URL_CACHE_DIR);

CommonReturn:
    if (hToken)
        I_SchemeCloseHandle(hToken);
    return pwszDir;
ErrorReturn:
    pwszDir = NULL;
    goto CommonReturn;

SET_ERROR_VAR(GetUserAppDataPathError, dwErr)
TRACE_ERROR(OutOfMemory)
}

//+-------------------------------------------------------------------------
//  Converts the bytes into UNICODE HEX
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
VOID
WINAPI
I_SchemeBytesToWStr(DWORD cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (DWORD i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        b = *pb & 0x0F;
        *wsz++ = (WCHAR)( (b <= 9) ? b + L'0' : (b - 10) + L'A');
        pb++;
    }
    *wsz++ = 0;
}


//+-------------------------------------------------------------------------
//  Gets the URL's filename by formatting its MD5 hash as UNICODE hex
//--------------------------------------------------------------------------
VOID
WINAPI
I_SchemeGetUrlFileName(
    IN LPCWSTR pwszUrl,
    OUT WCHAR wszUrlFileName[SCHEME_URL_FILENAME_LEN]
    )
{
    MD5_CTX md5ctx;

    MD5Init(&md5ctx);
    MD5Update(&md5ctx, (const BYTE *) pwszUrl, wcslen(pwszUrl) * sizeof(WCHAR));
    MD5Final(&md5ctx);

    // convert to a string
    I_SchemeBytesToWStr(MD5DIGESTLEN, md5ctx.digest, wszUrlFileName);
}

static DWORD rgdwCreateFileRetryMilliseconds[] =
    { 1, 10, 100, 500, 1000, 5000 };

#define MAX_CREATE_FILE_RETRY_COUNT     \
            (sizeof(rgdwCreateFileRetryMilliseconds) / \
                sizeof(rgdwCreateFileRetryMilliseconds[0]))

//+-------------------------------------------------------------------------
//  For ERROR_SHARING_VIOLATION or ERROR_ACCESS_DENIED errors returned
//  by CreateFileW(), retries after sleeping the above times.
//
//  Note, the file to be created is under %UserProfile%. Therefore, unless
//  opened by another thread shouldn't get the above errors.
//
//  If unable to create the file, returns NULL and not INVALID_HANDLE_VALUE.
//--------------------------------------------------------------------------
HANDLE
WINAPI
I_SchemeCreateFile(
    IN LPCWSTR pwszFileName,
    IN BOOL fWrite
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr;
    DWORD dwRetryCount;

    dwRetryCount = 0;
    while (INVALID_HANDLE_VALUE == (hFile = CreateFileW(
              pwszFileName,
              fWrite ? (GENERIC_WRITE | GENERIC_READ) : GENERIC_READ,
              fWrite ? 0 : FILE_SHARE_READ,
              NULL,                   // lpsa
              fWrite ? CREATE_ALWAYS : OPEN_EXISTING,
              fWrite ? FILE_ATTRIBUTE_SYSTEM : FILE_ATTRIBUTE_NORMAL,
              NULL                    // hTemplateFile
              ))) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else {
            if (ERROR_PATH_NOT_FOUND == dwErr)
                dwErr = ERROR_FILE_NOT_FOUND;
            goto CreateFileError;
        }
    }

CommonReturn:
    return hFile;
ErrorReturn:
    hFile = NULL;
    goto CommonReturn;

SET_ERROR_VAR(CreateFileError, dwErr)
}


//+-------------------------------------------------------------------------
//  The MetaData file is always opened first and closed last.
//  Its opened for writing without sharing.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_SchemeCreateCacheFiles(
    IN LPCWSTR pwszUrl,
    IN BOOL fWrite,
    OUT HANDLE *phMetaDataFile,
    OUT HANDLE *phContentFile
    )
{
    BOOL fResult;
    LPWSTR pwszCryptnetUrlCacheDir = NULL;
    DWORD cchCryptnetUrlCacheDir;
    LPWSTR pwszMetaDataFile = NULL;
    LPWSTR pwszContentFile = NULL;

    HANDLE hMetaDataFile = NULL;
    HANDLE hContentFile = NULL;
    WCHAR wszUrlFileName[SCHEME_URL_FILENAME_LEN];

    pwszCryptnetUrlCacheDir = I_SchemeGetCryptnetUrlCacheDir();
    if (NULL == pwszCryptnetUrlCacheDir)
        goto GetCryptnetUrlCacheDirError;

    cchCryptnetUrlCacheDir = wcslen(pwszCryptnetUrlCacheDir);

    pwszMetaDataFile = (LPWSTR) PkiNonzeroAlloc(
        (cchCryptnetUrlCacheDir + wcslen(SCHEME_META_DATA_SUBDIR) + 1 +
            SCHEME_URL_FILENAME_LEN) * sizeof(WCHAR));
    pwszContentFile = (LPWSTR) PkiNonzeroAlloc(
        (cchCryptnetUrlCacheDir + wcslen(SCHEME_CONTENT_SUBDIR) + 1 +
            SCHEME_URL_FILENAME_LEN) * sizeof(WCHAR));

    if (NULL == pwszMetaDataFile || NULL == pwszContentFile)
        goto OutOfMemory;

    wcscpy(pwszMetaDataFile, pwszCryptnetUrlCacheDir);
    wcscat(pwszMetaDataFile, SCHEME_META_DATA_SUBDIR);
    wcscpy(pwszContentFile, pwszCryptnetUrlCacheDir);
    wcscat(pwszContentFile, SCHEME_CONTENT_SUBDIR);
    

    if (fWrite) {
        if (!I_RecursiveCreateDirectory(pwszMetaDataFile, NULL))
            goto CreateMetaDataDirError;
        if (!I_RecursiveCreateDirectory(pwszContentFile, NULL))
            goto CreateContentDirError;
    }

    I_SchemeGetUrlFileName(pwszUrl, wszUrlFileName);

    wcscat(pwszMetaDataFile, L"\\");
    wcscat(pwszMetaDataFile, wszUrlFileName);
    hMetaDataFile = I_SchemeCreateFile(pwszMetaDataFile, fWrite);
    if (NULL == hMetaDataFile)
        goto CreateMetaDataFileError;

    wcscat(pwszContentFile, L"\\");
    wcscat(pwszContentFile, wszUrlFileName);
    hContentFile = I_SchemeCreateFile(pwszContentFile, fWrite);
    if (NULL == hContentFile)
        goto CreateContentFileError;

    fResult = TRUE;

CommonReturn:
    PkiFree(pwszCryptnetUrlCacheDir);
    PkiFree(pwszMetaDataFile);
    PkiFree(pwszContentFile);

    *phMetaDataFile = hMetaDataFile;
    *phContentFile = hContentFile;
    return fResult;

ErrorReturn:
    if (NULL != hContentFile) {
        I_SchemeCloseHandle(hContentFile);
        hContentFile = NULL;
    }
    if (NULL != hMetaDataFile) {
        I_SchemeCloseHandle(hMetaDataFile);
        hMetaDataFile = NULL;
    }

    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetCryptnetUrlCacheDirError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateMetaDataDirError)
TRACE_ERROR(CreateContentDirError)
TRACE_ERROR(CreateMetaDataFileError)
TRACE_ERROR(CreateContentFileError)
}


//+-------------------------------------------------------------------------
//  The returned MetaDataHeader must be freed via PkiFree(). Returns NULL
//  for any errors. pcbBlob and pwszUrl point to memory following the
//  header and don't need to be freed.
//
//  The pwsUrl is guaranteed to be NULL terminated.
//--------------------------------------------------------------------------
PSCHEME_CACHE_META_DATA_HEADER
WINAPI
I_SchemeReadAndValidateMetaDataFile(
    IN HANDLE hMetaDataFile,
    OUT OPTIONAL DWORD **ppcbBlob,      // Not allocated
    OUT OPTIONAL LPCWSTR *ppwszUrl      // Not allocated
    )
{
    PSCHEME_CACHE_META_DATA_HEADER pMetaDataHeader = NULL;
    DWORD *pcbBlob = NULL;
    LPWSTR pwszUrl = NULL;

    DWORD cbMetaData;
    DWORD cbBytesRead;
    DWORD cBlob;
    DWORD cchUrl;
    DWORD dwUrlOffset;

    cbMetaData = GetFileSize(hMetaDataFile, NULL);
    if (INVALID_FILE_SIZE == cbMetaData ||
            sizeof(SCHEME_CACHE_META_DATA_HEADER) > cbMetaData)
        goto InvalidMetaDataFile;

    pMetaDataHeader = (PSCHEME_CACHE_META_DATA_HEADER) PkiZeroAlloc(
        cbMetaData);
    if (NULL == pMetaDataHeader)
        goto OutOfMemory;

    if (!ReadFile(
            hMetaDataFile,
            pMetaDataHeader,
            cbMetaData,
            &cbBytesRead,
            NULL            // lpOverlapped
            ) || cbMetaData != cbBytesRead)
        goto ReadMetaDataFileError;

    cBlob = pMetaDataHeader->cBlob;

    if (sizeof(SCHEME_CACHE_META_DATA_HEADER) > pMetaDataHeader->cbSize ||
            cbMetaData < pMetaDataHeader->cbSize ||
            0 != (pMetaDataHeader->cbSize % sizeof(DWORD)) ||
            cBlob > (cbMetaData - pMetaDataHeader->cbSize) / sizeof(DWORD))
        goto InvalidMetaDataFile;

    pcbBlob = (DWORD *) (((BYTE*)pMetaDataHeader) + pMetaDataHeader->cbSize);

    cchUrl = pMetaDataHeader->cbUrl / sizeof(WCHAR);
    dwUrlOffset = pMetaDataHeader->cbSize + sizeof(DWORD) * cBlob;
    if (0 == cchUrl ||
            cchUrl > (cbMetaData - dwUrlOffset) / sizeof(WCHAR))
        goto InvalidMetaDataFile;
    pwszUrl = (LPWSTR) (((BYTE*)pMetaDataHeader) + dwUrlOffset);
    pwszUrl[cchUrl - 1] = L'\0';

CommonReturn:
    if (ppcbBlob)
        *ppcbBlob = pcbBlob;
    if (ppwszUrl)
        *ppwszUrl = (LPCWSTR) pwszUrl;

    return pMetaDataHeader;

ErrorReturn:
    if (pMetaDataHeader) {
        PkiFree(pMetaDataHeader);
        pMetaDataHeader = NULL;
    }
    pcbBlob = NULL;
    pwszUrl = NULL;

    goto CommonReturn;

SET_ERROR(InvalidMetaDataFile, CRYPT_E_FILE_ERROR)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ReadMetaDataFileError)
}



//+---------------------------------------------------------------------------
//
//  Function:   SchemeCacheCryptBlobArray
//
//  Synopsis:   cache the crypt blob array under the given URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeCacheCryptBlobArray (
      IN LPCWSTR pwszUrl,
      IN DWORD dwRetrievalFlags,
      IN PCRYPT_BLOB_ARRAY pcba,
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      )
{
    BOOL fResult;
    SCHEME_CACHE_META_DATA_HEADER MetaDataHeader;
    HANDLE hMetaDataFile = NULL;
    HANDLE hContentFile = NULL;
    DWORD cbBytesWritten;
    DWORD i;

    if (!I_SchemeCreateCacheFiles(
            pwszUrl,
            TRUE,           // fWrite
            &hMetaDataFile,
            &hContentFile
            ))
        goto CreateCacheFilesError;

    memset(&MetaDataHeader, 0, sizeof(MetaDataHeader));
    MetaDataHeader.cbSize = sizeof(MetaDataHeader);
    MetaDataHeader.dwMagic = SCHEME_CACHE_META_DATA_MAGIC;
    MetaDataHeader.cBlob = pcba->cBlob;
    MetaDataHeader.cbUrl = (wcslen(pwszUrl) + 1) * sizeof(WCHAR);
    GetSystemTimeAsFileTime(&MetaDataHeader.LastSyncTime);

    if (!WriteFile(
            hMetaDataFile,
            &MetaDataHeader,
            sizeof(MetaDataHeader),
            &cbBytesWritten,
            NULL            // lpOverlapped
            ))
        goto WriteMetaDataHeaderError;

    for (i = 0; i < pcba->cBlob; i++) {
        DWORD cbBlob = pcba->rgBlob[i].cbData;

        if (!WriteFile(
                hMetaDataFile,
                &cbBlob,
                sizeof(cbBlob),
                &cbBytesWritten,
                NULL            // lpOverlapped
                ))
            goto WriteBlobLengthError;

        if (0 != cbBlob) {
            if (!WriteFile(
                    hContentFile,
                    pcba->rgBlob[i].pbData,
                    cbBlob,
                    &cbBytesWritten,
                    NULL            // lpOverlapped
                    ))
                goto WriteBlobContentError;
        }
    }

    if (!WriteFile(
            hMetaDataFile,
            pwszUrl,
            MetaDataHeader.cbUrl,
            &cbBytesWritten,
            NULL            // lpOverlapped
            ))
        goto WriteUrlError;

    if (pAuxInfo &&
            offsetof(CRYPT_RETRIEVE_AUX_INFO, pLastSyncTime) <
                        pAuxInfo->cbSize && pAuxInfo->pLastSyncTime)
        *pAuxInfo->pLastSyncTime = MetaDataHeader.LastSyncTime;

    fResult = TRUE;

CommonReturn:
    if (NULL != hContentFile)
        I_SchemeCloseHandle(hContentFile);
    if (NULL != hMetaDataFile)
        I_SchemeCloseHandle(hMetaDataFile);
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateCacheFilesError)
TRACE_ERROR(WriteMetaDataHeaderError)
TRACE_ERROR(WriteBlobLengthError)
TRACE_ERROR(WriteBlobContentError)
TRACE_ERROR(WriteUrlError)
}


//+---------------------------------------------------------------------------
//
//  Function:   SchemeRetrieveCachedCryptBlobArray
//
//  Synopsis:   retrieve cached blob array bits
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeRetrieveCachedCryptBlobArray (
      IN LPCWSTR pwszUrl,
      IN DWORD dwRetrievalFlags,
      OUT PCRYPT_BLOB_ARRAY pcba,
      OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
      OUT LPVOID* ppvFreeContext,
      IN OUT PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      )
{
    BOOL fResult;
    HANDLE hMetaDataFile = NULL;
    HANDLE hContentFile = NULL;
    PSCHEME_CACHE_META_DATA_HEADER pMetaDataHeader = NULL;
    DWORD *pcbBlob;         // not allocated
    DWORD cbContent;
    DWORD cBlob;
    PCRYPT_BLOB_ARRAY pCachedArray = NULL;
    PCRYPT_DATA_BLOB pBlob; // not allocated
    BYTE *pbBlob;           // not allocated
    DWORD cbBlobHeader;
    DWORD cbBytesRead;
    DWORD i;

    if (!I_SchemeCreateCacheFiles(
            pwszUrl,
            FALSE,           // fWrite
            &hMetaDataFile,
            &hContentFile
            ))
        goto CreateCacheFilesError;

    pMetaDataHeader = I_SchemeReadAndValidateMetaDataFile(
        hMetaDataFile,
        &pcbBlob,
        NULL            // ppwszUrl
        );
    if (NULL == pMetaDataHeader)
        goto ReadMetaDataFileError;

    cBlob = pMetaDataHeader->cBlob;

    cbContent = 0;
    for (i = 0; i < cBlob; i++)
        cbContent += pcbBlob[i];

    cbBlobHeader = sizeof(CRYPT_BLOB_ARRAY) + cBlob * sizeof(CRYPT_DATA_BLOB);
    pCachedArray = (PCRYPT_BLOB_ARRAY) PkiZeroAlloc(
        cbBlobHeader + cbContent);
    if (NULL == pCachedArray)
        goto OutOfMemory;

    pBlob = (PCRYPT_DATA_BLOB) &pCachedArray[1];
    pbBlob = (BYTE *) &pBlob[cBlob];

    if (0 != cbContent) {
        if (!ReadFile(
                hContentFile,
                pbBlob,
                cbContent,
                &cbBytesRead,
                NULL            // lpOverlapped
                ) || cbContent != cbBytesRead)
            goto ReadContentFileError;
    }

    pCachedArray->cBlob = cBlob;
    pCachedArray->rgBlob = pBlob;

    for (i = 0; i < cBlob; i++) {
        pBlob[i].cbData = pcbBlob[i];
        pBlob[i].pbData = pbBlob;
        pbBlob += pcbBlob[i];
    }

    pcba->cBlob = pCachedArray->cBlob;
    pcba->rgBlob = pCachedArray->rgBlob;

    *ppfnFreeObject = SchemeFreeEncodedCryptBlobArray;
    *ppvFreeContext = (LPVOID) pCachedArray;

    if (pAuxInfo && offsetof(CRYPT_RETRIEVE_AUX_INFO, pLastSyncTime) <
            pAuxInfo->cbSize && pAuxInfo->pLastSyncTime)
        *pAuxInfo->pLastSyncTime = pMetaDataHeader->LastSyncTime;

    fResult = TRUE;

CommonReturn:
    if (NULL != hContentFile)
        I_SchemeCloseHandle(hContentFile);
    if (NULL != hMetaDataFile)
        I_SchemeCloseHandle(hMetaDataFile);
    PkiFree(pMetaDataHeader);
    return fResult;

ErrorReturn:
    PkiFree(pCachedArray);
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateCacheFilesError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ReadMetaDataFileError)
TRACE_ERROR(ReadContentFileError)
}

//+-------------------------------------------------------------------------
//  For ERROR_SHARING_VIOLATION or ERROR_ACCESS_DENIED errors returned
//  by DeleteFileW(), retries after sleeping an increasing array of times.
//
//  Note, the file to be deleted is under %UserProfile%. Therefore, unless
//  opened by another thread shouldn't get the above errors.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_SchemeDeleteFile(
    IN LPCWSTR pwszFileName
    )
{
    BOOL fResult;
    DWORD dwErr;
    DWORD dwRetryCount;

    dwRetryCount = 0;
    while (!DeleteFileU(pwszFileName)) {
        dwErr = GetLastError();
        if ((ERROR_SHARING_VIOLATION == dwErr ||
                ERROR_ACCESS_DENIED == dwErr) &&
                MAX_CREATE_FILE_RETRY_COUNT > dwRetryCount) {
            Sleep(rgdwCreateFileRetryMilliseconds[dwRetryCount]);
            dwRetryCount++;
        } else
            goto DeleteFileError;
    }

    fResult = TRUE;

CommonReturn:
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR_VAR(DeleteFileError, dwErr)
}


//+---------------------------------------------------------------------------
//
//  Function:   SchemeDeleteUrlCacheEntry
//
//  Synopsis:   delete URL cache entry
//
//              For no cache entry returns FALSE with LastError set to
//              ERROR_FILE_NOT_FOUND
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeDeleteUrlCacheEntry (
      IN LPCWSTR pwszUrl
      )
{
    BOOL fResult;
    LPWSTR pwszCryptnetUrlCacheDir = NULL;
    DWORD cchCryptnetUrlCacheDir;
    LPWSTR pwszMetaDataFile = NULL;
    LPWSTR pwszContentFile = NULL;
    WCHAR wszUrlFileName[SCHEME_URL_FILENAME_LEN];


    // Format the MetaData and Content filenames
    //  - %UserProfile%\Microsoft\CryptnetUrlCache\MetaData\14A1AE3A6A7648689AE8F94F367AC606
    //  - %UserProfile%\Microsoft\CryptnetUrlCache\Content\14A1AE3A6A7648689AE8F94F367AC606
    //  Where 14A1AE3A6A7648689AE8F94F367AC606 is the Unicode Hex of md5 hash
    //  of the URL string

    pwszCryptnetUrlCacheDir = I_SchemeGetCryptnetUrlCacheDir();
    if (NULL == pwszCryptnetUrlCacheDir)
        goto GetCryptnetUrlCacheDirError;

    cchCryptnetUrlCacheDir = wcslen(pwszCryptnetUrlCacheDir);

    pwszMetaDataFile = (LPWSTR) PkiNonzeroAlloc(
        (cchCryptnetUrlCacheDir + wcslen(SCHEME_META_DATA_SUBDIR) + 1 +
            SCHEME_URL_FILENAME_LEN) * sizeof(WCHAR));
    pwszContentFile = (LPWSTR) PkiNonzeroAlloc(
        (cchCryptnetUrlCacheDir + wcslen(SCHEME_CONTENT_SUBDIR) + 1 +
            SCHEME_URL_FILENAME_LEN) * sizeof(WCHAR));

    if (NULL == pwszMetaDataFile || NULL == pwszContentFile)
        goto OutOfMemory;

    I_SchemeGetUrlFileName(pwszUrl, wszUrlFileName);

    wcscpy(pwszMetaDataFile, pwszCryptnetUrlCacheDir);
    wcscat(pwszMetaDataFile, SCHEME_META_DATA_SUBDIR);
    wcscat(pwszMetaDataFile, L"\\");
    wcscat(pwszMetaDataFile, wszUrlFileName);

    wcscpy(pwszContentFile, pwszCryptnetUrlCacheDir);
    wcscat(pwszContentFile, SCHEME_CONTENT_SUBDIR);
    wcscat(pwszContentFile, L"\\");
    wcscat(pwszContentFile, wszUrlFileName);

    // Delete both the content and meta data files.
    if (!I_SchemeDeleteFile(pwszContentFile)) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            goto DeleteContentFileError;
    }

    fResult = I_SchemeDeleteFile(pwszMetaDataFile);

CommonReturn:
    PkiFree(pwszCryptnetUrlCacheDir);
    PkiFree(pwszMetaDataFile);
    PkiFree(pwszContentFile);

    return fResult;

ErrorReturn:

    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetCryptnetUrlCacheDirError)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(DeleteContentFileError)
}



//+---------------------------------------------------------------------------
//
//  Function:   SchemeFreeEncodedCryptBlobArray
//
//  Synopsis:   free encoded crypt blob array
//
//----------------------------------------------------------------------------
VOID WINAPI
SchemeFreeEncodedCryptBlobArray (
      IN LPCSTR pszObjectOid,
      IN PCRYPT_BLOB_ARRAY pcba,
      IN LPVOID pvFreeContext
      )
{
    PkiFree(pvFreeContext);
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeGetPasswordCredentialsW
//
//  Synopsis:   get password credentials from crypt credentials
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeGetPasswordCredentialsW (
      IN PCRYPT_CREDENTIALS pCredentials,
      OUT PCRYPT_PASSWORD_CREDENTIALSW pPasswordCredentials,
      OUT BOOL* pfFreeCredentials
      )
{
    DWORD                        cwUsername;
    DWORD                        cwPassword;
    PCRYPT_PASSWORD_CREDENTIALSA pPassCredA;
    PCRYPT_PASSWORD_CREDENTIALSW pPassCredW;
    LPWSTR                       pszUsername;
    LPWSTR                       pszPassword;

    if ( pPasswordCredentials->cbSize != sizeof( CRYPT_PASSWORD_CREDENTIALS ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( pCredentials == NULL )
    {
        pPasswordCredentials->pszUsername = NULL;
        pPasswordCredentials->pszPassword = NULL;
        *pfFreeCredentials = FALSE;

        return( TRUE );
    }

    if ( pCredentials->pszCredentialsOid ==
         CREDENTIAL_OID_PASSWORD_CREDENTIALS_W )
    {
        pPassCredW = (PCRYPT_PASSWORD_CREDENTIALSW)pCredentials->pvCredentials;
        *pPasswordCredentials = *pPassCredW;
        *pfFreeCredentials = FALSE;

        return( TRUE );
    }

    if ( pCredentials->pszCredentialsOid !=
         CREDENTIAL_OID_PASSWORD_CREDENTIALS_A )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    pPassCredA = (PCRYPT_PASSWORD_CREDENTIALSA)pCredentials->pvCredentials;
    cwUsername = strlen( pPassCredA->pszUsername ) + 1;
    cwPassword = strlen( pPassCredA->pszPassword ) + 1;

    pszUsername = new WCHAR [ cwUsername ];
    pszPassword = new WCHAR [ cwPassword ];

    if ( ( pszUsername == NULL ) || ( pszPassword == NULL ) )
    {
        delete [] pszUsername;
        delete [] pszPassword;
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    *pfFreeCredentials = TRUE;

    MultiByteToWideChar(
        CP_ACP,
        0,
        pPassCredA->pszUsername,
        cwUsername,
        pszUsername,
        cwUsername
        );
    pszUsername[cwUsername - 1] = L'\0';

    MultiByteToWideChar(
        CP_ACP,
        0,
        pPassCredA->pszPassword,
        cwPassword,
        pszPassword,
        cwPassword
        );
    pszPassword[cwPassword - 1] = L'\0';

    pPasswordCredentials->pszUsername = pszUsername;
    pPasswordCredentials->pszPassword = pszPassword;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeFreePasswordCredentialsA
//
//  Synopsis:   free password credentials
//
//----------------------------------------------------------------------------
VOID WINAPI
SchemeFreePasswordCredentialsW (
      IN PCRYPT_PASSWORD_CREDENTIALSW pPasswordCredentials
      )
{
    DWORD cch;

    // Ensure allocated credentials are cleared out before being freed.

    if (pPasswordCredentials->pszUsername)
    {
        cch = wcslen(pPasswordCredentials->pszUsername);
        SecureZeroMemory(pPasswordCredentials->pszUsername,
            cch * sizeof(WCHAR));
        delete [] pPasswordCredentials->pszUsername;
    }


    if (pPasswordCredentials->pszPassword)
    {
        cch = wcslen(pPasswordCredentials->pszPassword);
        SecureZeroMemory(pPasswordCredentials->pszPassword,
            cch * sizeof(WCHAR));
        delete [] pPasswordCredentials->pszPassword;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeGetAuthIdentityFromPasswordCredentialsW
//
//  Synopsis:   converts a CRYPT_PASSWORD_CREDENTIALSW to a
//              SEC_WINNT_AUTH_IDENTITY_W
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeGetAuthIdentityFromPasswordCredentialsW (
      IN PCRYPT_PASSWORD_CREDENTIALSW pPasswordCredentials,
      OUT PSEC_WINNT_AUTH_IDENTITY_W pAuthIdentity
      )
{
    DWORD cDomain = 0;

    if ( pPasswordCredentials->pszUsername == NULL )
    {
        pAuthIdentity->User = NULL;
        pAuthIdentity->UserLength = 0;
        pAuthIdentity->Domain = NULL;
        pAuthIdentity->DomainLength = 0;
        pAuthIdentity->Password = NULL;
        pAuthIdentity->PasswordLength = 0;
        pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        return TRUE;
    }

    while ( ( pPasswordCredentials->pszUsername[cDomain] != L'\0' ) &&
            ( pPasswordCredentials->pszUsername[cDomain] != L'\\' ) )
    {
        cDomain += 1;
    }

    if ( cDomain != (DWORD)wcslen( pPasswordCredentials->pszUsername ) )
    {
        LPWSTR pwszDomain;

        pwszDomain = new WCHAR [ cDomain + 1 ];

        if ( pwszDomain == NULL )
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }

        memcpy(pwszDomain, pPasswordCredentials->pszUsername,
            cDomain * sizeof(WCHAR));
        pwszDomain[cDomain] = L'\0';

        pAuthIdentity->Domain = (USHORT *)pwszDomain;
        pAuthIdentity->DomainLength = cDomain;

        pAuthIdentity->User = (USHORT *)&pPasswordCredentials->pszUsername[
                                                                 cDomain+1
                                                                 ];

        pAuthIdentity->UserLength = wcslen( (LPCWSTR)pAuthIdentity->User );
    }
    else
    {
        pAuthIdentity->Domain = NULL;
        pAuthIdentity->DomainLength = 0;
        pAuthIdentity->User = (USHORT *)pPasswordCredentials->pszUsername;
        pAuthIdentity->UserLength = cDomain;
    }

    pAuthIdentity->Password = (USHORT *)pPasswordCredentials->pszPassword;
    pAuthIdentity->PasswordLength = wcslen( (LPCWSTR)pAuthIdentity->Password );
    pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeFreeAuthIdentityFromPasswordCredentialsW
//
//  Synopsis:   restore the backslash to the domain username pair
//
//----------------------------------------------------------------------------
VOID WINAPI
SchemeFreeAuthIdentityFromPasswordCredentialsW (
      IN PCRYPT_PASSWORD_CREDENTIALSW pPasswordCredentials,
      IN OUT PSEC_WINNT_AUTH_IDENTITY_W pAuthIdentity
      )
{
    if ( pAuthIdentity->Domain != NULL )
    {
        DWORD dwLastError = GetLastError();

        delete [] pAuthIdentity->Domain;

        SetLastError(dwLastError);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SchemeRetrieveUncachedAuxInfo
//
//  Synopsis:   update the LastSyncTime in the retrieval AuxInfo with the
//              current time.
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeRetrieveUncachedAuxInfo (
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      )
{
    if ( pAuxInfo &&
            offsetof(CRYPT_RETRIEVE_AUX_INFO, pLastSyncTime) <
                        pAuxInfo->cbSize &&
            pAuxInfo->pLastSyncTime )
    {
        GetSystemTimeAsFileTime( pAuxInfo->pLastSyncTime );
    }

    return( TRUE );
}


//+-------------------------------------------------------------------------
//  Iterate through the Url Cache MetaData files in:
//  %UserProfile%\Microsoft\CryptnetUrlCache\MetaData
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptNetEnumUrlCacheEntry(
    IN DWORD dwFlags,
    IN LPVOID pvReserved,
    IN LPVOID pvArg,
    IN PFN_CRYPTNET_ENUM_URL_CACHE_ENTRY_CALLBACK pfnEnumCallback
    )
{
    BOOL fResult;
    DWORD dwLastError = 0;
    DWORD cchCryptnetUrlCacheDir;
    LPWSTR pwszCryptnetUrlCacheDir = NULL;
    DWORD cchMetaDataDir;
    LPWSTR pwszMetaDataFile = NULL;
    DWORD cchContentDir;
    LPWSTR pwszContentFile = NULL;
    HANDLE hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAW FindFileData;

    pwszCryptnetUrlCacheDir = I_SchemeGetCryptnetUrlCacheDir();
    if (NULL == pwszCryptnetUrlCacheDir)
        goto GetCryptnetUrlCacheDirError;

    cchCryptnetUrlCacheDir = wcslen(pwszCryptnetUrlCacheDir);
    cchMetaDataDir = cchCryptnetUrlCacheDir + SCHEME_CCH_META_DATA_SUBDIR + 1;
    cchContentDir = cchCryptnetUrlCacheDir + SCHEME_CCH_CONTENT_SUBDIR + 1;

    pwszMetaDataFile = (LPWSTR) PkiNonzeroAlloc(
        (cchMetaDataDir + SCHEME_URL_FILENAME_LEN) * sizeof(WCHAR));
    pwszContentFile = (LPWSTR) PkiNonzeroAlloc(
        (cchContentDir + SCHEME_URL_FILENAME_LEN) * sizeof(WCHAR));

    if (NULL == pwszMetaDataFile || NULL == pwszContentFile)
        goto OutOfMemory;

    memcpy(pwszMetaDataFile, pwszCryptnetUrlCacheDir,
        cchCryptnetUrlCacheDir * sizeof(WCHAR));
    memcpy(pwszMetaDataFile + cchCryptnetUrlCacheDir,
        SCHEME_META_DATA_SUBDIR,
        SCHEME_CCH_META_DATA_SUBDIR * sizeof(WCHAR));
    wcscpy(&pwszMetaDataFile[cchMetaDataDir - 1], L"\\*");

    if (INVALID_HANDLE_VALUE == (hFindFile = FindFirstFileW(
            pwszMetaDataFile,
            &FindFileData
            ))) {
        dwLastError = GetLastError();
        if (ERROR_PATH_NOT_FOUND == dwLastError)
            dwLastError = ERROR_FILE_NOT_FOUND;
        goto FindFirstFileError;
    }

    memcpy(pwszContentFile, pwszCryptnetUrlCacheDir,
        cchCryptnetUrlCacheDir * sizeof(WCHAR));
    memcpy(pwszContentFile + cchCryptnetUrlCacheDir,
        SCHEME_CONTENT_SUBDIR, SCHEME_CCH_CONTENT_SUBDIR * sizeof(WCHAR));
    pwszContentFile[cchContentDir - 1] = L'\\';


    while (TRUE) {
        DWORD cchFileName = wcslen(FindFileData.cFileName);

        if (0 == (FILE_ATTRIBUTE_DIRECTORY & FindFileData.dwFileAttributes) &&
                0 == FindFileData.nFileSizeHigh &&
                0 != FindFileData.nFileSizeLow &&
                L'\0' != FindFileData.cFileName[0] &&
                SCHEME_URL_FILENAME_LEN > cchFileName) {

            HANDLE hMetaDataFile;

            memcpy(pwszMetaDataFile + cchMetaDataDir,
                FindFileData.cFileName, (cchFileName + 1) * sizeof(WCHAR));
            memcpy(pwszContentFile + cchContentDir,
                FindFileData.cFileName, (cchFileName + 1) * sizeof(WCHAR));

            hMetaDataFile = I_SchemeCreateFile(
                pwszMetaDataFile,
                FALSE                   // fWrite
                );
            if (NULL != hMetaDataFile) {
                PSCHEME_CACHE_META_DATA_HEADER pMetaDataHeader;
                CRYPTNET_URL_CACHE_ENTRY UrlCacheEntry;

                pMetaDataHeader = I_SchemeReadAndValidateMetaDataFile(
                    hMetaDataFile,
                    &UrlCacheEntry.pcbBlob,     // Not allocated
                    &UrlCacheEntry.pwszUrl      // Not allocated
                    );

                I_SchemeCloseHandle(hMetaDataFile);

                if (NULL != pMetaDataHeader) {
                    UrlCacheEntry.cbSize = sizeof(UrlCacheEntry);
                    UrlCacheEntry.dwMagic = pMetaDataHeader->dwMagic;
                    UrlCacheEntry.LastSyncTime = pMetaDataHeader->LastSyncTime;
                    UrlCacheEntry.cBlob = pMetaDataHeader->cBlob;
                    // UrlCacheEntry.pcbBlob =
                    // UrlCacheEntry.pwszUrl = 
                    UrlCacheEntry.pwszMetaDataFileName = pwszMetaDataFile;
                    UrlCacheEntry.pwszContentFileName = pwszContentFile;

                    fResult = pfnEnumCallback(
                        &UrlCacheEntry,
                        0,                  // dwFlags
                        NULL,               // pvReserved
                        pvArg
                        );

                    PkiFree(pMetaDataHeader);
                    if (!fResult)
                        goto ErrorReturn;
                }
            }
        }

        if (!FindNextFileW(hFindFile, &FindFileData)) {
            dwLastError = GetLastError();
            if (ERROR_NO_MORE_FILES == dwLastError)
                goto SuccessReturn;
            else
                goto FindNextFileError;
        }
    }

SuccessReturn:
    fResult = TRUE;

CommonReturn:
    PkiFree(pwszCryptnetUrlCacheDir);
    PkiFree(pwszMetaDataFile);
    PkiFree(pwszContentFile);
    if (INVALID_HANDLE_VALUE != hFindFile)
        FindClose(hFindFile);

    SetLastError(dwLastError);
    return fResult;

ErrorReturn:
    dwLastError = GetLastError();
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetCryptnetUrlCacheDirError)
TRACE_ERROR(OutOfMemory)
SET_ERROR_VAR(FindFirstFileError, dwLastError)
SET_ERROR_VAR(FindNextFileError, dwLastError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\tvo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       tvo.h
//
//  Contents:   Get Time Valid Object Definitions and Prototypes
//
//  History:    25-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__TVO_H__)
#define __TVO_H__

#include <origin.h>
#include <lrucache.h>
#include <offurl.h>

//
// CryptGetTimeValidObject provider prototypes
//

typedef BOOL (WINAPI *PFN_GET_TIME_VALID_OBJECT_FUNC) (
                          IN LPCSTR pszTimeValidOid,
                          IN LPVOID pvPara,
                          IN PCCERT_CONTEXT pIssuer,
                          IN LPFILETIME pftValidFor,
                          IN DWORD dwFlags,
                          IN DWORD dwTimeout,
                          OUT OPTIONAL LPVOID* ppvObject,
                          IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
                          IN OPTIONAL LPVOID pvReserved
                          );

BOOL WINAPI
CtlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

BOOL WINAPI
CrlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

BOOL WINAPI
CrlFromCertGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

BOOL WINAPI
FreshestCrlFromCertGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

BOOL WINAPI
FreshestCrlFromCrlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

//
// CryptFlushTimeValidObject provider prototypes
//

typedef BOOL (WINAPI *PFN_FLUSH_TIME_VALID_OBJECT_FUNC) (
                          IN LPCSTR pszFlushTimeValidOid,
                          IN LPVOID pvPara,
                          IN PCCERT_CONTEXT pIssuer,
                          IN DWORD dwFlags,
                          IN LPVOID pvReserved
                          );

BOOL WINAPI
CtlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CrlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CrlFromCertFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

BOOL WINAPI
FreshestCrlFromCertFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

BOOL WINAPI
FreshestCrlFromCrlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

//
// Provider table externs
//

extern HCRYPTOIDFUNCSET hGetTimeValidObjectFuncSet;
extern HCRYPTOIDFUNCSET hFlushTimeValidObjectFuncSet;


//
// The TVO Cache.  This is a cache of time valid objects by origin identifier
// which is used to support the CryptGetTimeValidObject process.  It is
// used by a process wide TVO agent with each cache entry consisting of
// the following information:
//
// Object Origin Identifier
// Object Context Oid
// Object Context
// Object Retrieval URL
// Object Expire Time
// Object Offline URL Time Information
//

typedef struct _TVO_CACHE_ENTRY {

    CRYPT_ORIGIN_IDENTIFIER OriginIdentifier;
    LPCSTR                  pszContextOid;
    LPVOID                  pvContext;
    DWORD                   cbUrlArrayThis;
    PCRYPT_URL_ARRAY        pUrlArrayThis;
    DWORD                   UrlIndexThis;
    DWORD                   cbUrlArrayNext;
    PCRYPT_URL_ARRAY        pUrlArrayNext;
    DWORD                   UrlIndexNext;
    FILETIME                CreateTime;
    FILETIME                ExpireTime;
    HLRUENTRY               hLruEntry;
    OFFLINE_URL_TIME_INFO   OfflineUrlTimeInfo;
} TVO_CACHE_ENTRY, *PTVO_CACHE_ENTRY;

class CTVOCache
{
public:

    //
    // Construction
    //

    CTVOCache (
        DWORD cCacheBuckets,
        DWORD MaxCacheEntries,
        BOOL& rfResult
        );

    ~CTVOCache ();

    //
    // Direct cache entry manipulation
    //

    VOID InsertCacheEntry (PTVO_CACHE_ENTRY pEntry);

    VOID RemoveCacheEntry (PTVO_CACHE_ENTRY pEntry, BOOL fSuppressFree = FALSE);

    VOID TouchCacheEntry (PTVO_CACHE_ENTRY pEntry);

    //
    // Origin identifier based cache entry manipulation
    //
    // For CONTEXT_OID_CRL, pvSubject is the certificate that the CRL is
    // valid for. Skips CRL entries that aren't valid for the certificate.
    //

    PTVO_CACHE_ENTRY FindCacheEntry (
                         CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
                         LPCSTR pszContextOid,
                         LPVOID pvSubject
                         );

    //
    // Remove all cache entries
    //

    VOID RemoveAllCacheEntries ();

    //
    // Access to the cache handle
    //

    inline HLRUCACHE LruCacheHandle ();

private:

    //
    // Cache handle
    //

    HLRUCACHE m_hCache;
};

DWORD WINAPI TVOCacheHashOriginIdentifier (PCRYPT_DATA_BLOB pIdentifier);

VOID WINAPI TVOCacheOnRemoval (LPVOID pvData, LPVOID pvRemovalContext);


//
// The TVO Agent.  This per process service takes care of the retrieval of
// time valid CAPI2 objects.  It allows this to be done on-demand or with
// auto-update
//

class CTVOAgent
{
public:

    //
    // Construction
    //

    CTVOAgent (
        DWORD cCacheBuckets,
        DWORD MaxCacheEntries,
        BOOL& rfResult
        );

    ~CTVOAgent ();

    //
    // Get Time Valid Object methods
    //

    BOOL GetTimeValidObject (
            IN LPCSTR pszTimeValidOid,
            IN LPVOID pvPara,
            IN LPCSTR pszContextOid,
            IN PCCERT_CONTEXT pIssuer,
            IN LPFILETIME pftValidFor,
            IN DWORD dwFlags,
            IN DWORD dwTimeout,
            OUT OPTIONAL LPVOID* ppvObject,
            IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
            IN OPTIONAL LPVOID pvReserved
            );

    BOOL GetTimeValidObjectByUrl (
            IN DWORD cbUrlArray,
            IN PCRYPT_URL_ARRAY pUrlArray,
            IN DWORD PreferredUrlIndex,
            IN LPCSTR pszContextOid,
            IN PCCERT_CONTEXT pIssuer,
            IN LPVOID pvSubject,
            IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
            IN LPFILETIME pftValidFor,
            IN DWORD dwFlags,
            IN DWORD dwTimeout,
            OUT OPTIONAL LPVOID* ppvObject,
            IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
            IN OPTIONAL LPWSTR pwszUrlExtra,
            OUT BOOL* pfArrayOwned,
            IN OPTIONAL LPVOID pvReserved
            );

    BOOL FlushTimeValidObject (
              IN LPCSTR pszFlushTimeValidOid,
              IN LPVOID pvPara,
              IN LPCSTR pszFlushContextOid,
              IN PCCERT_CONTEXT pIssuer,
              IN DWORD dwFlags,
              IN LPVOID pvReserved
              );

private:

    //
    // Object lock
    //

    CRITICAL_SECTION m_Lock;

    //
    // TVO cache
    //

    CTVOCache        m_Cache;
};

//
// Utility functions
//

BOOL WINAPI
IsValidCreateOrExpireTime (
    IN BOOL fCheckFreshnessTime,
    IN LPFILETIME pftValidFor,
    IN LPFILETIME pftCreateTime,
    IN LPFILETIME pftExpireTime
    );

BOOL WINAPI
ObjectContextCreateTVOCacheEntry (
      IN HLRUCACHE hCache,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
      IN DWORD cbUrlArrayThis,
      IN PCRYPT_URL_ARRAY pUrlArrayThis,
      IN DWORD UrlIndexThis,
      IN PCCERT_CONTEXT pIssuer,
      OUT PTVO_CACHE_ENTRY* ppEntry
      );

VOID WINAPI
ObjectContextFreeTVOCacheEntry (
      IN PTVO_CACHE_ENTRY pEntry
      );


BOOL WINAPI
CertificateGetCrlDistPointUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN LPWSTR pwszUrlHint,
           OUT PCRYPT_URL_ARRAY* ppUrlArray,
           OUT DWORD* pcbUrlArray,
           OUT DWORD* pPreferredUrlIndex,
           OUT BOOL* pfHintInArray
           );

BOOL WINAPI
RetrieveTimeValidObjectByUrl (
        IN LPWSTR pwszUrl,
        IN LPCSTR pszContextOid,
        IN LPFILETIME pftValidFor,
        IN DWORD dwFlags,
        IN DWORD dwTimeout,
        IN PCRYPT_CREDENTIALS pCredentials,
        IN PCCERT_CONTEXT pSigner,
        IN LPVOID pvSubject,
        IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
        OUT LPVOID* ppvObject,
        IN OPTIONAL LPVOID pvReserved
        );

#define TVO_KEY_NAME "Software\\Microsoft\\Cryptography\\TVO"
#define TVO_CACHE_BUCKETS_VALUE_NAME "DefaultProcessCacheBuckets"
#define TVO_MAX_CACHE_ENTRIES_VALUE_NAME "DefaultProcessMaxCacheEntries"

#define TVO_DEFAULT_CACHE_BUCKETS     32
#define TVO_DEFAULT_MAX_CACHE_ENTRIES 128

BOOL WINAPI
CreateProcessTVOAgent (
      OUT CTVOAgent** ppAgent
      );

//
// Extern for process global agent
//

extern CTVOAgent* g_pProcessTVOAgent;

//
// Inline functions
//

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::LruCacheHandle, public
//
//  Synopsis:   return the HLRUCACHE
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CTVOCache::LruCacheHandle ()
{
    return( m_hCache );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\urlprov.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       urlprov.cpp
//
//  Contents:   CryptGetObjectUrl provider implementation
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   CertificateIssuerGetObjectUrl
//
//  Synopsis:   get certificate issuer URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateIssuerGetObjectUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           )
{
    return( ObjectContextUrlFromInfoAccess(
                  CONTEXT_OID_CERTIFICATE,
                  pvPara,
                  (DWORD) -1L,
                  szOID_AUTHORITY_INFO_ACCESS,
                  dwFlags,
                  szOID_PKIX_CA_ISSUERS,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertificateCrlDistPointGetObjectUrl
//
//  Synopsis:   get certificate CRL URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateCrlDistPointGetObjectUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           )
{
    return( ObjectContextUrlFromCrlDistPoint(
                  CONTEXT_OID_CERTIFICATE,
                  pvPara,
                  (DWORD) -1L,
                  dwFlags,
                  szOID_CRL_DIST_POINTS,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}


//+---------------------------------------------------------------------------
//
//  Function:   CertificateFreshestCrlGetObjectUrl
//
//  Synopsis:   get certificate freshest CRL URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateFreshestCrlGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           )
{

    return( ObjectContextUrlFromCrlDistPoint(
                  CONTEXT_OID_CERTIFICATE,
                  pvPara,
                  (DWORD) -1L,
                  dwFlags,
                  szOID_FRESHEST_CRL,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlFreshestCrlGetObjectUrl
//
//  Synopsis:   get freshest CRL URL from the certificate's base CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlFreshestCrlGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           )
{
    PCCERT_CRL_CONTEXT_PAIR pCertCrlPair = (PCCERT_CRL_CONTEXT_PAIR) pvPara;

    return( ObjectContextUrlFromCrlDistPoint(
                  CONTEXT_OID_CRL,
                  (LPVOID) pCertCrlPair->pCrlContext,
                  (DWORD) -1L,
                  dwFlags,
                  szOID_FRESHEST_CRL,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlIssuerGetObjectUrl
//
//  Synopsis:   get CTL issuer URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CtlIssuerGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   )
{
    PURL_OID_CTL_ISSUER_PARAM pParam = (PURL_OID_CTL_ISSUER_PARAM)pvPara;

    return( ObjectContextUrlFromInfoAccess(
                  CONTEXT_OID_CTL,
                  (LPVOID)pParam->pCtlContext,
                  pParam->SignerIndex,
                  szOID_AUTHORITY_INFO_ACCESS,
                  CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE |
                  CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE,
                  szOID_PKIX_CA_ISSUERS,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlNextUpdateGetObjectUrl
//
//  Synopsis:   get CTL renewal URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CtlNextUpdateGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   )
{
    LPVOID* apv = (LPVOID *)pvPara;

    return( ObjectContextUrlFromNextUpdateLocation(
                  CONTEXT_OID_CTL,
                  apv[0],
                  (DWORD)(DWORD_PTR)apv[1],
                  dwFlags,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlIssuerGetObjectUrl
//
//  Synopsis:   get CRL issuer URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlIssuerGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   )
{
    return( ObjectContextUrlFromInfoAccess(
                  CONTEXT_OID_CRL,
                  pvPara,
                  (DWORD) -1L,
                  szOID_AUTHORITY_INFO_ACCESS,
                  dwFlags,
                  szOID_PKIX_CA_ISSUERS,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextUrlFromInfoAccess
//
//  Synopsis:   get the URLs specified by the access method OID from the given
//              context and format it as a CRYPT_URL_ARRAY
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextUrlFromInfoAccess (
           IN LPCSTR pszContextOid,
           IN LPVOID pvContext,
           IN DWORD Index,
           IN LPCSTR pszInfoAccessOid,
           IN DWORD dwFlags,
           IN LPCSTR pszAccessMethodOid,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           )
{
    BOOL               fResult = FALSE;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    ULONG              cRawData = MAX_RAW_URL_DATA;

    fResult = ObjectContextGetRawUrlData(
                    pszContextOid,
                    pvContext,
                    Index,
                    dwFlags,
                    pszInfoAccessOid,
                    RawData,
                    &cRawData
                    );

    if ( fResult == TRUE )
    {
        fResult = GetUrlArrayAndInfoFromInfoAccess(
                     cRawData,
                     RawData,
                     pszAccessMethodOid,
                     pUrlArray,
                     pcbUrlArray,
                     pUrlInfo,
                     pcbUrlInfo
                     );

        ObjectContextFreeRawUrlData( cRawData, RawData );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextUrlFromCrlDistPoint
//
//  Synopsis:   get the URLs from the CRL distribution point on the object and
//              format as a CRYPT_URL_ARRAY
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextUrlFromCrlDistPoint (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszSourceOid,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      )
{
    BOOL               fResult = FALSE;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    ULONG              cRawData = MAX_RAW_URL_DATA;

    fResult = ObjectContextGetRawUrlData(
                    pszContextOid,
                    pvContext,
                    Index,
                    dwFlags,
                    pszSourceOid,
                    RawData,
                    &cRawData
                    );

    if ( fResult == TRUE )
    {
        fResult = GetUrlArrayAndInfoFromCrlDistPoint(
                     cRawData,
                     RawData,
                     pUrlArray,
                     pcbUrlArray,
                     pUrlInfo,
                     pcbUrlInfo
                     );

        ObjectContextFreeRawUrlData( cRawData, RawData );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextUrlFromNextUpdateLocation
//
//  Synopsis:   get the URLs from the next update location
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextUrlFromNextUpdateLocation (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      )
{
    BOOL               fResult = FALSE;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    ULONG              cRawData = MAX_RAW_URL_DATA;

    fResult = ObjectContextGetRawUrlData(
                    pszContextOid,
                    pvContext,
                    Index,
                    dwFlags,
                    szOID_NEXT_UPDATE_LOCATION,
                    RawData,
                    &cRawData
                    );

    if ( fResult == TRUE )
    {
        fResult = GetUrlArrayAndInfoFromNextUpdateLocation(
                     cRawData,
                     RawData,
                     pUrlArray,
                     pcbUrlArray,
                     pUrlInfo,
                     pcbUrlInfo
                     );

        ObjectContextFreeRawUrlData( cRawData, RawData );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeDefaultUrlInfo
//
//  Synopsis:   initialize default URL info
//
//----------------------------------------------------------------------------
VOID WINAPI
InitializeDefaultUrlInfo (
          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
          IN OUT DWORD* pcbUrlInfo
          )
{

    if ( pUrlInfo == NULL )
    {
        *pcbUrlInfo = sizeof( CRYPT_URL_INFO );
        return;
    }

    if (*pcbUrlInfo >= sizeof( CRYPT_URL_INFO ))
    {
        *pcbUrlInfo = sizeof( CRYPT_URL_INFO );
        memset( pUrlInfo, 0, sizeof( CRYPT_URL_INFO ) );
        pUrlInfo->cbSize = sizeof( CRYPT_URL_INFO );
    }
    else if (*pcbUrlInfo >= sizeof( DWORD ))
    {
        *pcbUrlInfo = sizeof( DWORD );
        pUrlInfo->cbSize = sizeof( DWORD );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetRawUrlData
//
//  Synopsis:   Raw URL data is a decoded extension, property or attribute
//              specified by a source OID that contains locator information.
//              This API retrieves and decodes such data
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetRawUrlData (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszSourceOid,
      OUT PCRYPT_RAW_URL_DATA aRawUrlData,
      IN OUT DWORD* pcRawUrlData
      )
{
    BOOL               fResult = TRUE;
    DWORD              cCount;
    DWORD              cError = 0;
    DWORD              cRawData = 0;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    CRYPT_DATA_BLOB    DataBlob = {0, NULL};
    BOOL               fFreeDataBlob = FALSE;
    DWORD              cbDecoded;
    LPBYTE             pbDecoded = NULL;
    PCRYPT_ATTRIBUTE   pAttr = NULL;
    DWORD              cbAttr;

    if ( dwFlags & CRYPT_GET_URL_FROM_PROPERTY )
    {
        RawData[cRawData].dwFlags = CRYPT_GET_URL_FROM_PROPERTY;
        RawData[cRawData].pvData = NULL;
        cRawData += 1;
    }

    if ( dwFlags & CRYPT_GET_URL_FROM_EXTENSION )
    {
        RawData[cRawData].dwFlags = CRYPT_GET_URL_FROM_EXTENSION;
        RawData[cRawData].pvData = NULL;
        cRawData += 1;
    }

    if ( dwFlags & CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE )
    {
        RawData[cRawData].dwFlags = CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE;
        RawData[cRawData].pvData = NULL;
        cRawData += 1;
    }

    if ( dwFlags & CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE )
    {
        RawData[cRawData].dwFlags = CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE;
        RawData[cRawData].pvData = NULL;
        cRawData += 1;
    }

    if ( *pcRawUrlData < cRawData )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    for ( cCount = 0; cCount < cRawData; cCount++ )
    {
        switch ( RawData[cCount].dwFlags )
        {
        case CRYPT_GET_URL_FROM_PROPERTY:
            {
                DWORD PropId;

                fResult = MapOidToPropertyId( pszSourceOid, &PropId );
                if ( fResult == TRUE )
                {
                    fResult = ObjectContextGetProperty(
                                  pszContextOid,
                                  pvContext,
                                  PropId,
                                  NULL,
                                  &DataBlob.cbData
                                  );
                }

                if ( fResult == TRUE )
                {
                    DataBlob.pbData = new BYTE [ DataBlob.cbData ];
                    if ( DataBlob.pbData != NULL )
                    {
                        fFreeDataBlob = TRUE;

                        fResult = ObjectContextGetProperty(
                                      pszContextOid,
                                      pvContext,
                                      PropId,
                                      DataBlob.pbData,
                                      &DataBlob.cbData
                                      );
                    }
                    else
                    {
                        fResult = FALSE;
                        SetLastError( (DWORD) E_OUTOFMEMORY );
                    }
                }
            }
            break;
        case CRYPT_GET_URL_FROM_EXTENSION:
            {
                PCERT_EXTENSION pExt;

                pExt = ObjectContextFindExtension(
                           pszContextOid,
                           pvContext,
                           pszSourceOid
                           );

                if ( pExt != NULL )
                {
                    DataBlob.cbData = pExt->Value.cbData;
                    DataBlob.pbData = pExt->Value.pbData;
                    fResult = TRUE;
                }
                else
                {
                    fResult = FALSE;
                }
            }
            break;
        case CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE:
        case CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE:
            {
                fResult = ObjectContextGetAttribute(
                                pszContextOid,
                                pvContext,
                                Index,
                                RawData[cCount].dwFlags,
                                pszSourceOid,
                                NULL,
                                &cbAttr
                                );

                if ( fResult == TRUE )
                {
                    pAttr = (PCRYPT_ATTRIBUTE)new BYTE [cbAttr];
                    if ( pAttr != NULL )
                    {
                        fResult = ObjectContextGetAttribute(
                                        pszContextOid,
                                        pvContext,
                                        Index,
                                        RawData[cCount].dwFlags,
                                        pszSourceOid,
                                        pAttr,
                                        &cbAttr
                                        );
                    }
                    else
                    {
                        fResult = FALSE;
                        SetLastError( (DWORD) E_OUTOFMEMORY );
                    }
                }

                if ( fResult == TRUE )
                {
                    // We only deal with single valued attributes
                    DataBlob.cbData = pAttr->rgValue[0].cbData;
                    DataBlob.pbData = pAttr->rgValue[0].pbData;
                }
            }
            break;
        }

        if ( fResult == TRUE )
        {
            fResult = CryptDecodeObject(
                           X509_ASN_ENCODING,
                           pszSourceOid,
                           DataBlob.pbData,
                           DataBlob.cbData,
                           0,
                           NULL,
                           &cbDecoded
                           );

            if ( fResult == TRUE )
            {
                pbDecoded = new BYTE [ cbDecoded ];
                if ( pbDecoded != NULL )
                {
                    fResult = CryptDecodeObject(
                                   X509_ASN_ENCODING,
                                   pszSourceOid,
                                   DataBlob.pbData,
                                   DataBlob.cbData,
                                   0,
                                   pbDecoded,
                                   &cbDecoded
                                   );
                }
                else
                {
                    fResult = FALSE;
                }
            }
        }

        if ( fResult == TRUE )
        {
            RawData[cCount].pvData = (LPVOID)pbDecoded;
        }
        else
        {
            if ( pbDecoded != NULL )
            {
                delete [] pbDecoded;
            }
            cError += 1;
        }
        pbDecoded = NULL;

        if ( fFreeDataBlob == TRUE )
        {
            delete [] DataBlob.pbData;
            fFreeDataBlob = FALSE;
        }

        if ( pAttr != NULL )
        {
            delete [] (BYTE *)pAttr;
            pAttr = NULL;
        }
    }

    if ( cError != cRawData )
    {
        memcpy( aRawUrlData, RawData, cRawData * sizeof( CRYPT_RAW_URL_DATA ) );
        *pcRawUrlData = cRawData;
        fResult = TRUE;
    }
    else
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFreeRawUrlData
//
//  Synopsis:   free the raw URL data
//
//----------------------------------------------------------------------------
VOID WINAPI
ObjectContextFreeRawUrlData (
      IN DWORD cRawUrlData,
      IN PCRYPT_RAW_URL_DATA aRawUrlData
      )
{
    DWORD cCount;

    for ( cCount = 0; cCount < cRawUrlData; cCount++ )
    {
        delete [] (BYTE *) aRawUrlData[cCount].pvData;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayAndInfoFromAuthInfoAccess
//
//  Synopsis:   get URL data using decoded info access data
//
//----------------------------------------------------------------------------
BOOL WINAPI
GetUrlArrayAndInfoFromInfoAccess (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   IN LPCSTR pszAccessMethodOid,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   )
{
    BOOL                        fResult = FALSE;
    PCERT_AUTHORITY_INFO_ACCESS pAuthInfoAccess = NULL;
    PCERT_ACCESS_DESCRIPTION    rgAccDescr = NULL;
    DWORD                       cRaw;
    DWORD                       cCount;
    BOOL                        fAnyFound = FALSE;
    CCryptUrlArray              cua( 1, 5, fResult );

    for ( cRaw = 0; ( fResult == TRUE ) && ( cRaw < cRawUrlData ); cRaw++ )
    {
        pAuthInfoAccess = (PCERT_AUTHORITY_INFO_ACCESS)aRawUrlData[cRaw].pvData;
        if ( pAuthInfoAccess != NULL )
        {
            rgAccDescr = pAuthInfoAccess->rgAccDescr;

            for ( cCount = 0;
                  ( cCount < pAuthInfoAccess->cAccDescr ) &&
                  ( fResult == TRUE );
                  cCount++ )
            {
                if ( !strcmp(
                         pszAccessMethodOid,
                         rgAccDescr[cCount].pszAccessMethod
                         ) )
                {
                    if ( rgAccDescr[cCount].AccessLocation.dwAltNameChoice ==
                         CERT_ALT_NAME_URL )
                    {
                        fResult = cua.AddUrl(
                                      rgAccDescr[cCount].AccessLocation.pwszURL,
                                      TRUE
                                      );

                        fAnyFound = TRUE;
                    }
                }
            }
        }
    }

    if ( ( fAnyFound == FALSE ) && ( fResult == TRUE ) )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        PCRYPT_URL_ARRAY* ppUrlArray = NULL;

        if ( pUrlArray != NULL )
        {
            ppUrlArray = &pUrlArray;
        }

        fResult = cua.GetArrayInSingleBufferEncodedForm(
                              ppUrlArray,
                              pcbUrlArray
                              );
    }

    if ( ( fResult == TRUE ) && ( pcbUrlInfo != NULL ) )
    {
        InitializeDefaultUrlInfo( pUrlInfo, pcbUrlInfo );
    }

    cua.FreeArray( TRUE );
    return( fResult );
}

#define DIR_NAME_LDAP_URL_PREFIX    L"ldap://"

#define URL_OID_CDP_DIR_NAME_LDAP_HOST_PORTS_VALUE_NAME \
            L"DirectoryNameLdapHostPorts"
#define URL_OID_CDP_DIR_NAME_LDAP_SUFFIX_VALUE_NAME \
            L"DirectoryNameLdapSuffix"

LPCWSTR pwszDefaultCDPDirNameLdapUrlHostPorts = L"\0\0"; 

LPCWSTR pwszDefaultCDPDirNameLdapUrlSuffix=
    L"?certificateRevocationList;binary,authorityRevocationList;binary,deltaRevocationList;binary";

LPWSTR WINAPI
GetCDPOIDFunctionValue(
    IN LPCWSTR pwszValueName
    )
{
    BOOL fResult;
    DWORD dwType;
    DWORD cchValue;
    DWORD cbValue = 0;
    LPWSTR pwszValue = NULL;

    fResult = CryptGetOIDFunctionValue(
        X509_ASN_ENCODING,
        URL_OID_GET_OBJECT_URL_FUNC,
        URL_OID_CERTIFICATE_CRL_DIST_POINT,
        pwszValueName,
        &dwType,
        NULL,
        &cbValue
        );
    cchValue = cbValue / sizeof(WCHAR);
    if (!fResult || 0 == cchValue ||
            !(REG_MULTI_SZ == dwType || REG_SZ == dwType ||
                 REG_EXPAND_SZ == dwType))
        goto ErrorReturn;

    pwszValue = new WCHAR [cchValue + 2];
    if (NULL == pwszValue)
        goto OutOfMemory;

    fResult = CryptGetOIDFunctionValue(
        X509_ASN_ENCODING,
        URL_OID_GET_OBJECT_URL_FUNC,
        URL_OID_CERTIFICATE_CRL_DIST_POINT,
        pwszValueName,
        &dwType,
        (BYTE *) pwszValue,
        &cbValue
        );
    if (!fResult)
        goto ErrorReturn;

    // Ensure the value has two null terminators
    pwszValue[cchValue] = L'\0';
    pwszValue[cchValue + 1] = L'\0';

CommonReturn:
    return pwszValue;
ErrorReturn:
    if (pwszValue) {
        delete [] pwszValue;
        pwszValue = NULL;
    }
    goto CommonReturn;
OutOfMemory:
    SetLastError( (DWORD) E_OUTOFMEMORY );
    goto ErrorReturn;
}

// For an error or no found registry value,
// returns pwszDefaultCDPDirNameLdapUrlHostPorts
LPWSTR WINAPI
GetCDPDirNameLdapUrlHostPorts()
{
    LPWSTR pwszHostPorts;

    pwszHostPorts = GetCDPOIDFunctionValue(
        URL_OID_CDP_DIR_NAME_LDAP_HOST_PORTS_VALUE_NAME);
    if (NULL == pwszHostPorts)
        pwszHostPorts = (LPWSTR) pwszDefaultCDPDirNameLdapUrlHostPorts;

    return pwszHostPorts;
}

// For an error or no found registry value,
// returns pwszDefaultCDPDirNameLdapUrlSuffix
LPWSTR WINAPI
GetCDPDirNameLdapUrlSuffix()
{
    LPWSTR pwszSuffix = NULL;

    pwszSuffix = GetCDPOIDFunctionValue(
        URL_OID_CDP_DIR_NAME_LDAP_SUFFIX_VALUE_NAME);
    if (NULL == pwszSuffix)
        pwszSuffix = (LPWSTR) pwszDefaultCDPDirNameLdapUrlSuffix;

    return pwszSuffix;
}

BOOL WINAPI
AddUrlsFromCDPDirectoryName (
    IN PCERT_NAME_BLOB pDirNameBlob,
    IN OUT CCryptUrlArray *pcua
    )
{
    BOOL fResult;
    LPWSTR pwszHP;
    LPWSTR pwszHostPorts;
    LPWSTR pwszSuffix;
    LPWSTR pwszDirName = NULL;
    DWORD cchDirName;

    pwszHostPorts = GetCDPDirNameLdapUrlHostPorts();
    pwszSuffix = GetCDPDirNameLdapUrlSuffix();
    assert(NULL != pwszHostPorts && NULL != pwszSuffix);

    cchDirName = CertNameToStrW(
        X509_ASN_ENCODING,
        pDirNameBlob,
        CERT_X500_NAME_STR  | CERT_NAME_STR_REVERSE_FLAG,
        NULL,                   // pwsz
        0                       // cch
        );
    if (1 >= cchDirName)
        goto ErrorReturn;
    pwszDirName = new WCHAR [cchDirName];
    if (NULL == pwszDirName)
        goto OutOfMemory;
    cchDirName = CertNameToStrW(
        X509_ASN_ENCODING,
        pDirNameBlob,
        CERT_X500_NAME_STR  | CERT_NAME_STR_REVERSE_FLAG,
        pwszDirName,
        cchDirName
        );
    if (1 >= cchDirName)
        goto ErrorReturn;
    cchDirName--;           // exclude trailing L'\0'

    pwszHP = pwszHostPorts;
    while (TRUE) {
        DWORD cchHP;
        LPWSTR pwszUrl;
        DWORD cchUrl;

        // Skip past any spaces in the HostPort
        while (L' ' == *pwszHP)
            pwszHP++;
        cchHP = wcslen(pwszHP);

        cchUrl = wcslen(DIR_NAME_LDAP_URL_PREFIX);
        cchUrl += cchHP;
        cchUrl += 1;        // L'/'
        cchUrl += cchDirName;
        cchUrl += wcslen(pwszSuffix);
        cchUrl += 1;        // L'\0'

        pwszUrl = new WCHAR [cchUrl];
        if (NULL == pwszUrl)
            goto OutOfMemory;

        wcscpy(pwszUrl, DIR_NAME_LDAP_URL_PREFIX);
        wcscat(pwszUrl, pwszHP);
        wcscat(pwszUrl, L"/");
        wcscat(pwszUrl, pwszDirName);
        wcscat(pwszUrl, pwszSuffix);

        fResult = pcua->AddUrl(pwszUrl, TRUE);

        delete [] pwszUrl;
        if (!fResult)
            goto ErrorReturn;

        pwszHP += cchHP + 1;
        if (L'\0' == *pwszHP)
            break;
    }

    fResult = TRUE;
CommonReturn:
    if (pwszDirName)
        delete [] pwszDirName;
    if (pwszHostPorts != pwszDefaultCDPDirNameLdapUrlHostPorts)
        delete [] pwszHostPorts;
    if (pwszSuffix != pwszDefaultCDPDirNameLdapUrlSuffix)
        delete [] pwszSuffix;

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

OutOfMemory:
    SetLastError( (DWORD) E_OUTOFMEMORY );
    goto ErrorReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayAndInfoFromCrlDistPoint
//
//  Synopsis:   get URL data using decoded CRL distribution point info
//
//----------------------------------------------------------------------------
BOOL WINAPI
GetUrlArrayAndInfoFromCrlDistPoint (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   )
{
    BOOL                  fResult = FALSE;
    PCRL_DIST_POINTS_INFO pDistPointsInfo;
    PCRL_DIST_POINT       rgDistPoint;
    PCRL_DIST_POINT_NAME  pDistPointName;
    PCERT_ALT_NAME_ENTRY  rgAltEntry;
    DWORD                 cRaw;
    DWORD                 cCount;
    DWORD                 cEntry;
    BOOL                  fAnyFound = FALSE;
    CCryptUrlArray        cua( 1, 5, fResult );

    for ( cRaw = 0; ( fResult == TRUE ) && ( cRaw < cRawUrlData ); cRaw++ )
    {
        pDistPointsInfo = (PCRL_DIST_POINTS_INFO)aRawUrlData[cRaw].pvData;
        if ( pDistPointsInfo != NULL )
        {
            rgDistPoint = pDistPointsInfo->rgDistPoint;

            for ( cCount = 0;
                  ( cCount < pDistPointsInfo->cDistPoint ) &&
                  ( fResult == TRUE );
                  cCount++ )
            {
                // Assumption:: don't support partial reasons

                // For now, will ignore CRL issuers, they might
                // be the same as the cert's issuer. That was the case
                // with a Netscape CDP
                if (rgDistPoint[cCount].ReasonFlags.cbData)
                    continue;

                pDistPointName = &rgDistPoint[cCount].DistPointName;

                if ( pDistPointName->dwDistPointNameChoice ==
                     CRL_DIST_POINT_FULL_NAME )
                {
                    rgAltEntry = pDistPointName->FullName.rgAltEntry;

                    for ( cEntry = 0;
                          ( fResult == TRUE ) &&
                          ( cEntry < pDistPointName->FullName.cAltEntry );
                          cEntry++ )
                    {
                        switch (rgAltEntry[cEntry].dwAltNameChoice) {
                        case CERT_ALT_NAME_URL:
                            fResult = cua.AddUrl(
                                             rgAltEntry[cEntry].pwszURL,
                                             TRUE
                                             );
                            fAnyFound = TRUE;
                            break;
                        case CERT_ALT_NAME_DIRECTORY_NAME:
                            fResult = AddUrlsFromCDPDirectoryName(
                                &rgAltEntry[cEntry].DirectoryName,
                                &cua
                                );
                            fAnyFound = TRUE;
                            break;
                        default:
                            break;
                        }
                    }
                }
            }
        }
    }

    if ( ( fAnyFound == FALSE ) && ( fResult == TRUE ) )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        PCRYPT_URL_ARRAY* ppUrlArray = NULL;

        if ( pUrlArray != NULL )
        {
            ppUrlArray = &pUrlArray;
        }

        fResult = cua.GetArrayInSingleBufferEncodedForm(
                              ppUrlArray,
                              pcbUrlArray
                              );
    }

    if ( ( fResult == TRUE ) && ( pcbUrlInfo != NULL ) )
    {
        InitializeDefaultUrlInfo( pUrlInfo, pcbUrlInfo );
    }

    cua.FreeArray( TRUE );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayAndInfoFromNextUpdateLocation
//
//  Synopsis:   get URL data using decoded next update location data
//
//----------------------------------------------------------------------------
BOOL WINAPI
GetUrlArrayAndInfoFromNextUpdateLocation (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   )
{
    BOOL                 fResult = FALSE;
    PCERT_ALT_NAME_INFO  pAltNameInfo;
    PCERT_ALT_NAME_ENTRY rgAltEntry;
    DWORD                cRaw;
    DWORD                cEntry;
    BOOL                 fAnyFound = FALSE;
    CCryptUrlArray       cua( 1, 5, fResult );

    for ( cRaw = 0; ( fResult == TRUE ) && ( cRaw < cRawUrlData ); cRaw++ )
    {
        pAltNameInfo = (PCERT_ALT_NAME_INFO)aRawUrlData[cRaw].pvData;
        if ( pAltNameInfo != NULL )
        {
            rgAltEntry = pAltNameInfo->rgAltEntry;

            for ( cEntry = 0;
                  ( cEntry < pAltNameInfo->cAltEntry ) &&
                  ( fResult == TRUE );
                  cEntry++ )
            {
                if ( rgAltEntry[cEntry].dwAltNameChoice == CERT_ALT_NAME_URL )
                {
                    fResult = cua.AddUrl( rgAltEntry[cEntry].pwszURL, TRUE );
                    fAnyFound = TRUE;
                }
            }
        }
    }

    if ( ( fAnyFound == FALSE ) && ( fResult == TRUE ) )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        PCRYPT_URL_ARRAY* ppUrlArray = NULL;

        if ( pUrlArray != NULL )
        {
            ppUrlArray = &pUrlArray;
        }

        fResult = cua.GetArrayInSingleBufferEncodedForm(
                              ppUrlArray,
                              pcbUrlArray
                              );
    }

    if ( ( fResult == TRUE ) && ( pcbUrlInfo != NULL ) )
    {
        InitializeDefaultUrlInfo( pUrlInfo, pcbUrlInfo );
    }

    cua.FreeArray( TRUE );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyUrlArray
//
//  Synopsis:   copy URL array
//
//----------------------------------------------------------------------------
BOOL WINAPI
CopyUrlArray (
    IN PCRYPT_URL_ARRAY pDest,
    IN PCRYPT_URL_ARRAY pSource,
    IN DWORD cbDest
    )
{
    DWORD cCount;
    DWORD cb;
    DWORD cbStruct;
    DWORD cbPointers;
    DWORD cbUrl;

    cbStruct = sizeof( CRYPT_URL_ARRAY );
    cbPointers = pSource->cUrl * sizeof( LPWSTR );

    if (cbDest < (cbStruct + cbPointers))
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return FALSE;
    }

    pDest->cUrl = pSource->cUrl;
    pDest->rgwszUrl = (LPWSTR *)( (LPBYTE)pDest + cbStruct );

    for ( cCount = 0, cb = 0; cCount < pSource->cUrl; cCount++ )
    {
        pDest->rgwszUrl[cCount] = (LPWSTR)((LPBYTE)pDest+cbStruct+cbPointers+cb);

        cbUrl = ( wcslen( pSource->rgwszUrl[cCount] ) + 1 ) * sizeof( WCHAR );

        if (cbDest < (cbStruct + cbPointers + cb + cbUrl))
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return FALSE;
        }

        memcpy( pDest->rgwszUrl[cCount], pSource->rgwszUrl[cCount], cbUrl );

        cb += cbUrl;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayIndex
//
//  Synopsis:   get index of an URL in the URL array
//
//----------------------------------------------------------------------------
VOID WINAPI
GetUrlArrayIndex (
   IN PCRYPT_URL_ARRAY pUrlArray,
   IN LPWSTR pwszUrl,
   IN DWORD DefaultIndex,
   OUT DWORD* pUrlIndex,
   OUT BOOL* pfHintInArray
   )
{
    DWORD cCount;

    if ( pUrlIndex != NULL )
    {
        *pUrlIndex = DefaultIndex;
    }

    if ( pfHintInArray != NULL )
    {
        *pfHintInArray = FALSE;
    }

    if ( pwszUrl == NULL )
    {
        return;
    }

    for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
    {
        if ( wcscmp( pUrlArray->rgwszUrl[cCount], pwszUrl ) == 0 )
        {
            if ( pUrlIndex != NULL )
            {
                *pUrlIndex = cCount;
            }

            if ( pfHintInArray != NULL )
            {
                *pfHintInArray = TRUE;
            }

            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayAndInfoFromCrossCertDistPoint
//
//  Synopsis:   get URL data using decoded Cross Cert distribution point info
//
//----------------------------------------------------------------------------
BOOL WINAPI
GetUrlArrayAndInfoFromCrossCertDistPoint (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   )
{
    BOOL                  fResult = FALSE;
    PCROSS_CERT_DIST_POINTS_INFO pDistPointsInfo;
    PCERT_ALT_NAME_INFO   rgDistPoint;
    PCERT_ALT_NAME_ENTRY  rgAltEntry;
    DWORD                 cRaw;
    DWORD                 cCount;
    DWORD                 cEntry;
    BOOL                  fAnyFound = FALSE;
    CCryptUrlArray        cua( 1, 5, fResult );

    DWORD                 dwSyncDeltaTime = 0;
    DWORD                 cMaxGroup = 0;
    DWORD                 cGroup = 0;
    DWORD                 *pcGroupEntry = NULL;
    DWORD                 cGroupEntry;
    DWORD                 cbUrlInfo;

    // Get maximum number of groups
    for ( cRaw = 0; cRaw < cRawUrlData; cRaw++ )
    {
        pDistPointsInfo =
            (PCROSS_CERT_DIST_POINTS_INFO)aRawUrlData[cRaw].pvData;
        if ( pDistPointsInfo != NULL )
        {
            cMaxGroup += pDistPointsInfo->cDistPoint;
        }
    }

    if (cMaxGroup > 0)
    {
        pcGroupEntry = new DWORD [cMaxGroup];
        if ( pcGroupEntry == NULL)
        {
            fResult = FALSE;
            SetLastError( (DWORD) E_OUTOFMEMORY );
        }
    }

    for ( cRaw = 0; ( fResult == TRUE ) && ( cRaw < cRawUrlData ); cRaw++ )
    {
        pDistPointsInfo =
            (PCROSS_CERT_DIST_POINTS_INFO)aRawUrlData[cRaw].pvData;
        if ( pDistPointsInfo != NULL )
        {
            if ( dwSyncDeltaTime == 0 )
            {
                dwSyncDeltaTime = pDistPointsInfo->dwSyncDeltaTime;
            }

            rgDistPoint = pDistPointsInfo->rgDistPoint;

            for ( cCount = 0;
                  ( cCount < pDistPointsInfo->cDistPoint ) &&
                  ( fResult == TRUE );
                  cCount++ )
            {
                rgAltEntry = rgDistPoint[cCount].rgAltEntry;
                cGroupEntry = 0;

                for ( cEntry = 0;
                      ( fResult == TRUE ) &&
                      ( cEntry < rgDistPoint[cCount].cAltEntry );
                      cEntry++ )
                {
                    switch (rgAltEntry[cEntry].dwAltNameChoice) {
                    case CERT_ALT_NAME_URL:
                        fResult = cua.AddUrl(
                                         rgAltEntry[cEntry].pwszURL,
                                         TRUE
                                         );
                        fAnyFound = TRUE;
                        cGroupEntry++;
                        break;
                    default:
                        break;
                    }
                }

                if ( cGroupEntry > 0 )
                {
                    if (cGroup < cMaxGroup)
                    {
                        pcGroupEntry[cGroup] = cGroupEntry;
                        cGroup++;
                    }
                    else
                    {
                        fResult = FALSE;
                        SetLastError( (DWORD) E_UNEXPECTED );
                    }
                }
            }
        }
    }

    if ( ( fAnyFound == FALSE ) && ( fResult == TRUE ) )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        PCRYPT_URL_ARRAY* ppUrlArray = NULL;

        if ( pUrlArray != NULL )
        {
            ppUrlArray = &pUrlArray;
        }

        fResult = cua.GetArrayInSingleBufferEncodedForm(
                              ppUrlArray,
                              pcbUrlArray
                              );
    }

    if ( ( fResult == TRUE ) && ( pcbUrlInfo != NULL ) )
    {
        cbUrlInfo = sizeof( CRYPT_URL_INFO ) + cGroup * sizeof(DWORD);
        if ( pUrlInfo != NULL )
        {
            if (*pcbUrlInfo < cbUrlInfo)
            {
                fResult = FALSE;
                SetLastError( (DWORD) E_INVALIDARG );
            }
            else
            {
                pUrlInfo->cbSize = sizeof( CRYPT_URL_INFO );
                pUrlInfo->dwSyncDeltaTime = dwSyncDeltaTime;
                pUrlInfo->cGroup = cGroup;

                if ( cGroup > 0 )
                {
                    pUrlInfo->rgcGroupEntry = (DWORD *) &pUrlInfo[ 1 ];
                    memcpy(pUrlInfo->rgcGroupEntry, pcGroupEntry,
                        cGroup * sizeof(DWORD));
                }
                else
                {
                    pUrlInfo->rgcGroupEntry = NULL;
                }
            }
        }
        *pcbUrlInfo = cbUrlInfo;
    }

    cua.FreeArray( TRUE );
    if (pcGroupEntry)
    {
        delete [] pcGroupEntry;
    }
    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   CertificateCrossCertDistPointGetObjectUrl
//
//  Synopsis:   get certificate cross certificate URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateCrossCertDistPointGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           )
{
    BOOL               fResult = FALSE;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    ULONG              cRawData = MAX_RAW_URL_DATA;

    fResult = ObjectContextGetRawUrlData(
                    CONTEXT_OID_CERTIFICATE,
                    pvPara,
                    (DWORD) -1L,                         // Index
                    dwFlags,
                    szOID_CROSS_CERT_DIST_POINTS,
                    RawData,
                    &cRawData
                    );

    if ( fResult == TRUE )
    {
        fResult = GetUrlArrayAndInfoFromCrossCertDistPoint(
                     cRawData,
                     RawData,
                     pUrlArray,
                     pcbUrlArray,
                     pUrlInfo,
                     pcbUrlInfo
                     );

        ObjectContextFreeRawUrlData( cRawData, RawData );
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\urlprov.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       urlprov.h
//
//  Contents:   CryptGetObjectUrl provider definitions
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__URLPROV_H__)
#define __URLPROV_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// CryptGetObjectUrl provider prototypes
//

typedef BOOL (WINAPI *PFN_GET_OBJECT_URL_FUNC) (
                          IN LPCSTR pszUrlOid,
                          IN LPVOID pvPara,
                          IN DWORD dwFlags,
                          OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
                          IN OUT DWORD* pcbUrlArray,
                          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
                          IN OUT OPTIONAL DWORD* pcbUrlInfo,
                          IN OPTIONAL LPVOID pvReserved
                          );

BOOL WINAPI
CertificateIssuerGetObjectUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           );

BOOL WINAPI
CertificateCrlDistPointGetObjectUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           );

typedef struct _URL_OID_CTL_ISSUER_PARAM {

    PCCTL_CONTEXT pCtlContext;
    DWORD         SignerIndex;

} URL_OID_CTL_ISSUER_PARAM, *PURL_OID_CTL_ISSUER_PARAM;

BOOL WINAPI
CtlIssuerGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CtlNextUpdateGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CrlIssuerGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CertificateFreshestCrlGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           );

BOOL WINAPI
CrlFreshestCrlGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           );

BOOL WINAPI
CertificateCrossCertDistPointGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           );

//
// CryptGetObjectUrl helper function prototypes
//

BOOL WINAPI
ObjectContextUrlFromInfoAccess (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN LPCSTR pszInfoAccessOid,
      IN DWORD dwFlags,
      IN LPCSTR pszAccessMethodOid,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      );

BOOL WINAPI
ObjectContextUrlFromCrlDistPoint (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszSourceOid,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      );

BOOL WINAPI
ObjectContextUrlFromNextUpdateLocation (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      );

VOID WINAPI
InitializeDefaultUrlInfo (
          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
          IN OUT DWORD* pcbUrlInfo
          );

#define MAX_RAW_URL_DATA 4

typedef struct _CRYPT_RAW_URL_DATA {

    DWORD  dwFlags;
    LPVOID pvData;

} CRYPT_RAW_URL_DATA, *PCRYPT_RAW_URL_DATA;

BOOL WINAPI
ObjectContextGetRawUrlData (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszSourceOid,
      OUT PCRYPT_RAW_URL_DATA aRawUrlData,
      IN OUT DWORD* pcRawUrlData
      );

VOID WINAPI
ObjectContextFreeRawUrlData (
      IN DWORD cRawUrlData,
      IN PCRYPT_RAW_URL_DATA aRawUrlData
      );

BOOL WINAPI
GetUrlArrayAndInfoFromInfoAccess (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   IN LPCSTR pszAccessMethodOid,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   );

BOOL WINAPI
GetUrlArrayAndInfoFromCrlDistPoint (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   );

BOOL WINAPI
GetUrlArrayAndInfoFromNextUpdateLocation (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   );

BOOL WINAPI
CopyUrlArray (
    IN PCRYPT_URL_ARRAY pDest,
    IN PCRYPT_URL_ARRAY pSource,
    IN DWORD cbDest
    );

VOID WINAPI
GetUrlArrayIndex (
   IN PCRYPT_URL_ARRAY pUrlArray,
   IN LPWSTR pwszUrl,
   IN DWORD DefaultIndex,
   OUT DWORD* pUrlIndex,
   OUT BOOL* pfHintInArray
   );

//
// Provider table externs
//

extern HCRYPTOIDFUNCSET hGetObjectUrlFuncSet;

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\rpor\tvo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       tvo.cpp
//
//  Contents:   Implementation of CryptGetTimeValidObject
//
//  History:    25-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   CryptGetTimeValidObject
//
//  Synopsis:   get a time valid CAPI2 object
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptGetTimeValidObject (
     IN LPCSTR pszTimeValidOid,
     IN LPVOID pvPara,
     IN PCCERT_CONTEXT pIssuer,
     IN LPFILETIME pftValidFor,
     IN DWORD dwFlags,
     IN DWORD dwTimeout,
     OUT OPTIONAL LPVOID* ppvObject,
     IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
     IN OPTIONAL LPVOID pvReserved
     )
{
    BOOL                           fResult;
    HCRYPTOIDFUNCADDR              hGetTimeValidObject;
    PFN_GET_TIME_VALID_OBJECT_FUNC pfnGetTimeValidObject;
    DWORD                          LastError;
    FILETIME                       CurrentTime;

    if ( CryptGetOIDFunctionAddress(
              hGetTimeValidObjectFuncSet,
              X509_ASN_ENCODING,
              pszTimeValidOid,
              0,
              (LPVOID *)&pfnGetTimeValidObject,
              &hGetTimeValidObject
              ) == FALSE )
    {
        return( FALSE );
    }

    if ( pftValidFor == NULL )
    {
        GetSystemTimeAsFileTime( &CurrentTime );
        pftValidFor = &CurrentTime;
    }

    fResult = ( *pfnGetTimeValidObject )(
                       pszTimeValidOid,
                       pvPara,
                       pIssuer,
                       pftValidFor,
                       dwFlags,
                       dwTimeout,
                       ppvObject,
                       pCredentials,
                       pvReserved
                       );

    LastError = GetLastError();
    CryptFreeOIDFunctionAddress( hGetTimeValidObject, 0 );
    SetLastError( LastError );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlGetTimeValidObject
//
//  Synopsis:   get a time valid CTL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CtlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CTL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetTimeValidObject
//
//  Synopsis:   get a time valid CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CRL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlFromCertGetTimeValidObject
//
//  Synopsis:   get a time valid CRL from a subject certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlFromCertGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CRL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   FreshestCrlFromCertGetTimeValidObject
//
//  Synopsis:   get a time valid freshest, delta CRL from a subject certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
FreshestCrlFromCertGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CRL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   FreshestCrlFromCrlGetTimeValidObject
//
//  Synopsis:   get a time valid freshest, delta CRL from a base CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI
FreshestCrlFromCrlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CRL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptFlushTimeValidObject
//
//  Synopsis:   flush the object from the "TVO" system
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptFlushTimeValidObject (
     IN LPCSTR pszFlushTimeValidOid,
     IN LPVOID pvPara,
     IN PCCERT_CONTEXT pIssuer,
     IN DWORD dwFlags,
     IN LPVOID pvReserved
     )
{
    BOOL                             fResult;
    HCRYPTOIDFUNCADDR                hFlushTimeValidObject;
    PFN_FLUSH_TIME_VALID_OBJECT_FUNC pfnFlushTimeValidObject;
    DWORD                            LastError;

    if ( CryptGetOIDFunctionAddress(
              hFlushTimeValidObjectFuncSet,
              X509_ASN_ENCODING,
              pszFlushTimeValidOid,
              0,
              (LPVOID *)&pfnFlushTimeValidObject,
              &hFlushTimeValidObject
              ) == FALSE )
    {
        return( FALSE );
    }

    fResult = ( *pfnFlushTimeValidObject )(
                         pszFlushTimeValidOid,
                         pvPara,
                         pIssuer,
                         dwFlags,
                         pvReserved
                         );

    LastError = GetLastError();
    CryptFreeOIDFunctionAddress( hFlushTimeValidObject, 0 );
    SetLastError( LastError );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlFlushTimeValidObject
//
//  Synopsis:   flush a CTL from the "TVO" system
//
//----------------------------------------------------------------------------
BOOL WINAPI
CtlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CTL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlFlushTimeValidObject
//
//  Synopsis:   flush a CRL from the "TVO" system
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CRL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlFromCertFlushTimeValidObject
//
//  Synopsis:   flush a CRL from the "TVO" system given a subject cert
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlFromCertFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CRL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   FreshedtCrlFromCertFlushTimeValidObject
//
//  Synopsis:   flush a freshest, delta CRL from the "TVO" system given a
//              subject cert
//
//----------------------------------------------------------------------------
BOOL WINAPI
FreshestCrlFromCertFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CRL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   FreshestCrlFromCrlFlushTimeValidObject
//
//  Synopsis:   flush a freshest, delta CRL from the "TVO" system given a
//              base CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI
FreshestCrlFromCrlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CRL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::CTVOCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CTVOCache::CTVOCache (
               DWORD cCacheBuckets,
               DWORD MaxCacheEntries,
               BOOL& rfResult
               )
{
    LRU_CACHE_CONFIG CacheConfig;

    assert( MaxCacheEntries > 0 );

    memset( &CacheConfig, 0, sizeof( CacheConfig ) );

    CacheConfig.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    CacheConfig.cBuckets = cCacheBuckets;
    CacheConfig.MaxEntries = MaxCacheEntries;
    CacheConfig.pfnHash = TVOCacheHashOriginIdentifier;
    CacheConfig.pfnOnRemoval = TVOCacheOnRemoval;

    rfResult = I_CryptCreateLruCache( &CacheConfig, &m_hCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::~CTVOCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CTVOCache::~CTVOCache ()
{
    I_CryptFreeLruCache( m_hCache, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::InsertCacheEntry, public
//
//  Synopsis:   insert entry into cache
//
//----------------------------------------------------------------------------
VOID
CTVOCache::InsertCacheEntry (PTVO_CACHE_ENTRY pEntry)
{
    I_CryptInsertLruEntry( pEntry->hLruEntry, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::RemoveCacheEntry, public
//
//  Synopsis:   remove entry from cache
//
//----------------------------------------------------------------------------
VOID
CTVOCache::RemoveCacheEntry (PTVO_CACHE_ENTRY pEntry, BOOL fSuppressFree)
{
    DWORD dwFlags = 0;

    if ( fSuppressFree == TRUE )
    {
        dwFlags = LRU_SUPPRESS_REMOVAL_NOTIFICATION;
    }

    I_CryptRemoveLruEntry( pEntry->hLruEntry, dwFlags, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::TouchCacheEntry, public
//
//  Synopsis:   touch an entry
//
//----------------------------------------------------------------------------
VOID
CTVOCache::TouchCacheEntry (PTVO_CACHE_ENTRY pEntry)
{
    I_CryptTouchLruEntry( pEntry->hLruEntry, 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::FindCacheEntry, public
//
//  Synopsis:   find an entry in the cache given the origin identifier.
//              Skip entries that aren't valid for the subject.
//
//----------------------------------------------------------------------------
PTVO_CACHE_ENTRY
CTVOCache::FindCacheEntry (
    CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    LPCSTR pszContextOid,
    LPVOID pvSubject
    )
{
    HLRUENTRY        hEntry;
    CRYPT_DATA_BLOB  DataBlob;
    PTVO_CACHE_ENTRY pEntry = NULL;

    DataBlob.cbData = MD5DIGESTLEN;
    DataBlob.pbData = OriginIdentifier;

    hEntry = I_CryptFindLruEntry( m_hCache, &DataBlob );
    while ( hEntry != NULL )
    {
        pEntry = (PTVO_CACHE_ENTRY)I_CryptGetLruEntryData( hEntry );
        assert(pEntry);
        assert(pszContextOid == pEntry->pszContextOid);
        if (pszContextOid == pEntry->pszContextOid && 
            ObjectContextIsValidForSubject (
                pszContextOid,
                pEntry->pvContext,
                pvSubject,
                NULL                // pvExtraInfo
                ))
        {
            I_CryptReleaseLruEntry( hEntry );
            break;
        }
        else
        {
            pEntry = NULL;
            hEntry = I_CryptEnumMatchingLruEntries ( hEntry );
        }
    }

    return( pEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::RemoveAllCacheEntries, public
//
//  Synopsis:   remove all cache entries
//
//----------------------------------------------------------------------------
VOID
CTVOCache::RemoveAllCacheEntries ()
{
    I_CryptFlushLruCache( m_hCache, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   TVOCacheHashOriginIdentifier
//
//  Synopsis:   hash the origin identifier to a DWORD, since the origin
//              identifier is already a unique MD5 hash our algorithm is
//              to simply use some of the bytes
//
//----------------------------------------------------------------------------
DWORD WINAPI
TVOCacheHashOriginIdentifier (PCRYPT_DATA_BLOB pIdentifier)
{
    DWORD Hash;

    assert( pIdentifier->cbData == MD5DIGESTLEN );

    memcpy( &Hash, pIdentifier->pbData, sizeof( DWORD ) );

    return( Hash );
}

//+---------------------------------------------------------------------------
//
//  Function:   TVOCacheOnRemoval
//
//  Synopsis:   removal notification callback
//
//----------------------------------------------------------------------------
VOID WINAPI
TVOCacheOnRemoval (LPVOID pvData, LPVOID pvRemovalContext)
{
    ObjectContextFreeTVOCacheEntry( (PTVO_CACHE_ENTRY)pvData );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::CTVOAgent, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CTVOAgent::CTVOAgent (
               DWORD cCacheBuckets,
               DWORD MaxCacheEntries,
               BOOL& rfResult
               )
              : m_Cache( cCacheBuckets, MaxCacheEntries, rfResult )
{
    if (!Pki_InitializeCriticalSection( &m_Lock ))
    {
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::~CTVOAgent, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CTVOAgent::~CTVOAgent ()
{
    m_Cache.RemoveAllCacheEntries();

    DeleteCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::GetTimeValidObject, public
//
//  Synopsis:   get a time valid CAPI2 object
//
//----------------------------------------------------------------------------
BOOL
CTVOAgent::GetTimeValidObject (
              IN LPCSTR pszTimeValidOid,
              IN LPVOID pvPara,
              IN LPCSTR pszContextOid,
              IN PCCERT_CONTEXT pIssuer,
              IN LPFILETIME pftValidFor,
              IN DWORD dwFlags,
              IN DWORD dwTimeout,
              OUT OPTIONAL LPVOID* ppvObject,
              IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
              IN OPTIONAL LPVOID pvReserved
              )
{
    BOOL                    fResult = TRUE;
    CRYPT_ORIGIN_IDENTIFIER OriginIdentifier;
    PTVO_CACHE_ENTRY        pCacheEntry = NULL;
    DWORD                   PreferredUrlIndex = 0;
    PCRYPT_URL_ARRAY        pUrlArray = NULL;
    DWORD                   cb = 0;
    DWORD                   cbUrlArray = 0;
    PCRYPT_URL_ARRAY        pCacheUrlArray = NULL;
    LPWSTR                  pwszUrlHint = NULL;
    BOOL                    fHintInArray = FALSE;
    BOOL                    fArrayOwned = FALSE;

    BOOL                    fCrlFromCert = FALSE;
    LPCSTR                  pszUrlOidCrlFromCert = NULL;
    LPVOID                  pvSubject = NULL;
    BOOL                    fFreshest = FALSE;

    if ( pszTimeValidOid == TIME_VALID_OID_GET_CRL_FROM_CERT )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CERTIFICATE_CRL_DIST_POINT;
        pvSubject = pvPara;
    }
    else if ( pszTimeValidOid == TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CERTIFICATE_FRESHEST_CRL;
        pvSubject = pvPara;
        fFreshest = TRUE;
    }
    else if ( pszTimeValidOid == TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CRL_FRESHEST_CRL;
        pvSubject = (LPVOID) ((PCCERT_CRL_CONTEXT_PAIR)pvPara)->pCertContext;
        fFreshest = TRUE;
    }

    if (fCrlFromCert)
    {
        if ( CrlGetOriginIdentifierFromSubjectCert(
                   (PCCERT_CONTEXT)pvSubject,
                   pIssuer,
                   fFreshest,
                   OriginIdentifier
                   ) == FALSE )
        {
            return( FALSE );
        }

        assert( pszContextOid == CONTEXT_OID_CRL );
    }
    else
    {
        if ( ObjectContextGetOriginIdentifier(
                   pszContextOid,
                   pvPara,
                   pIssuer,
                   0,
                   OriginIdentifier
                   ) == FALSE )
        {
            return( FALSE );
        }
    }

    PreferredUrlIndex = 0;
    pUrlArray = NULL;

    EnterCriticalSection( &m_Lock );

    pCacheEntry = m_Cache.FindCacheEntry(
        OriginIdentifier,
        pszContextOid,
        pvSubject
        );

    if ( pCacheEntry != NULL )
    {
        if ( !( dwFlags & CRYPT_WIRE_ONLY_RETRIEVAL ) )
        {
            if ( ( dwFlags & CRYPT_DONT_CHECK_TIME_VALIDITY ) ||
                        IsValidCreateOrExpireTime (
                              0 != (dwFlags & CRYPT_CHECK_FRESHNESS_TIME_VALIDITY),
                              pftValidFor,
                              &pCacheEntry->CreateTime,
                              &pCacheEntry->ExpireTime ) )
            {
                m_Cache.TouchCacheEntry( pCacheEntry );

                if ( ppvObject != NULL )
                {
                    *ppvObject = ObjectContextDuplicate(
                                       pCacheEntry->pszContextOid,
                                       pCacheEntry->pvContext
                                       );
                }

                LeaveCriticalSection( &m_Lock );

                return( TRUE );
            }
        }

        if ( !( dwFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
        {
            if ( GetOfflineUrlTimeStatus(&pCacheEntry->OfflineUrlTimeInfo) < 0
                            ||
                    !I_CryptNetIsConnected() )
            {
                if ( dwFlags & CRYPT_WIRE_ONLY_RETRIEVAL )
                {
                    LeaveCriticalSection( &m_Lock );
                    SetLastError( (DWORD) ERROR_NOT_CONNECTED );
                    return( FALSE );
                }
                else
                {
                    dwFlags |= CRYPT_CACHE_ONLY_RETRIEVAL;
                }
            }
        }

        if ( pCacheEntry->pUrlArrayNext != NULL )
        {
            cbUrlArray = pCacheEntry->cbUrlArrayNext;
            pCacheUrlArray = pCacheEntry->pUrlArrayNext;
            PreferredUrlIndex = pCacheEntry->UrlIndexNext;
        }
        else
        {
            cbUrlArray = pCacheEntry->cbUrlArrayThis;
            pCacheUrlArray = pCacheEntry->pUrlArrayThis;
            PreferredUrlIndex = pCacheEntry->UrlIndexThis;
        }
    }
    else if ( !( dwFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
    {
        if ( !I_CryptNetIsConnected() )
        {
            if ( dwFlags & CRYPT_WIRE_ONLY_RETRIEVAL )
            {
                LeaveCriticalSection( &m_Lock );
                SetLastError( (DWORD) ERROR_NOT_CONNECTED );
                return( FALSE );
            }
            else
            {
                dwFlags |= CRYPT_CACHE_ONLY_RETRIEVAL;
            }
        }
    }

    if ( ( fResult == TRUE ) && ( pUrlArray == NULL ) )
    {
        if ( pCacheEntry != NULL )
        {
            pwszUrlHint = pCacheUrlArray->rgwszUrl[ PreferredUrlIndex ];
        }

        if ( fCrlFromCert )
        {
            fResult = CertificateGetCrlDistPointUrl(
                                 pszUrlOidCrlFromCert,
                                 pvPara,
                                 pwszUrlHint,
                                 &pUrlArray,
                                 &cb,
                                 &PreferredUrlIndex,
                                 &fHintInArray
                                 );
        }
        else if ( pszTimeValidOid == TIME_VALID_OID_GET_CTL )
        {
            fResult = ObjectContextGetNextUpdateUrl(
                            pszContextOid,
                            pvPara,
                            pIssuer,
                            pwszUrlHint,
                            &pUrlArray,
                            &cb,
                            &PreferredUrlIndex,
                            &fHintInArray
                            );
        }
        else
        {
            SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
            fResult = FALSE;
        }

        if ( fResult == TRUE )
        {
            cbUrlArray = cb;
        }
        else if ( pCacheEntry != NULL )
        {
            pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
            if ( pUrlArray != NULL )
            {
                if (CopyUrlArray( pUrlArray, pCacheUrlArray, cbUrlArray ))
                {
                    fHintInArray = TRUE;
                    fResult = TRUE;
                }
                else
                {
                    delete [] (BYTE *) pUrlArray;
                    pUrlArray = NULL;
                    SetLastError( (DWORD) E_INVALIDARG );
                }
            }
            else
            {
                SetLastError( (DWORD) E_OUTOFMEMORY );
            }
        }
    }

    LeaveCriticalSection( &m_Lock );

    if ( fResult == TRUE )
    {
        fResult = GetTimeValidObjectByUrl(
                     cbUrlArray,
                     pUrlArray,
                     PreferredUrlIndex,
                     pszContextOid,
                     pIssuer,
                     pvSubject,
                     OriginIdentifier,
                     pftValidFor,
                     dwFlags,
                     dwTimeout,
                     ppvObject,
                     pCredentials,
                     NULL,
                     &fArrayOwned,
                     pvReserved
                     );
    }

    if ( fArrayOwned == FALSE )
    {
        delete [] (BYTE *) pUrlArray;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::GetTimeValidObjectByUrl, public
//
//  Synopsis:   get a time valid object using URL
//
//----------------------------------------------------------------------------
BOOL
CTVOAgent::GetTimeValidObjectByUrl (
              IN DWORD cbUrlArray,
              IN PCRYPT_URL_ARRAY pUrlArray,
              IN DWORD PreferredUrlIndex,
              IN LPCSTR pszContextOid,
              IN PCCERT_CONTEXT pIssuer,
              IN LPVOID pvSubject,
              IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
              IN LPFILETIME pftValidFor,
              IN DWORD dwFlags,
              IN DWORD dwTimeout,
              OUT OPTIONAL LPVOID* ppvObject,
              IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
              IN OPTIONAL LPWSTR pwszUrlExtra,
              OUT BOOL* pfArrayOwned,
              IN OPTIONAL LPVOID pvReserved
              )
{
    BOOL             fResult = FALSE;
    DWORD            cCount;
    LPWSTR           pwsz;
    LPVOID           pvContext = NULL;
    PTVO_CACHE_ENTRY pEntry = NULL;
    PTVO_CACHE_ENTRY pFound;
    DWORD            LastError;

    // Following is only used for CRYPT_ACCUMULATIVE_TIMEOUT
    FILETIME ftEndUrlRetrieval;

    if ( PreferredUrlIndex != 0 )
    {
        pwsz = pUrlArray->rgwszUrl[PreferredUrlIndex];
        pUrlArray->rgwszUrl[PreferredUrlIndex] = pUrlArray->rgwszUrl[0];
        pUrlArray->rgwszUrl[0] = pwsz;
    }

    if (dwFlags & CRYPT_ACCUMULATIVE_TIMEOUT)
    {
        if (0 == dwTimeout)
        {
            dwFlags &= ~CRYPT_ACCUMULATIVE_TIMEOUT;
        }
        else
        {
            FILETIME ftStartUrlRetrieval;

            GetSystemTimeAsFileTime(&ftStartUrlRetrieval);
            I_CryptIncrementFileTimeByMilliseconds(
                &ftStartUrlRetrieval, dwTimeout,
                &ftEndUrlRetrieval);
        }
    }

    for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
    {
        if (dwFlags & CRYPT_ACCUMULATIVE_TIMEOUT)
        {
            // Limit each URL timeout to half of the remaining time
            dwTimeout = I_CryptRemainingMilliseconds(&ftEndUrlRetrieval) / 2;
            if (0 == dwTimeout)
            {
                dwTimeout = 1;
            }
        }

        fResult = RetrieveTimeValidObjectByUrl(
                          pUrlArray->rgwszUrl[cCount],
                          pszContextOid,
                          pftValidFor,
                          dwFlags,
                          dwTimeout,
                          pCredentials,
                          pIssuer,
                          pvSubject,
                          OriginIdentifier,
                          &pvContext,
                          pvReserved
                          );

        if ( fResult == TRUE )
        {
            fResult = ObjectContextCreateTVOCacheEntry(
                            m_Cache.LruCacheHandle(),
                            pszContextOid,
                            pvContext,
                            OriginIdentifier,
                            cbUrlArray,
                            pUrlArray,
                            cCount,
                            pIssuer,
                            &pEntry
                            );

            *pfArrayOwned = fResult;
            break;
        }
    }

    if ( ( PreferredUrlIndex != 0 ) && ( *pfArrayOwned == FALSE ) )
    {
        pwsz = pUrlArray->rgwszUrl[PreferredUrlIndex];
        pUrlArray->rgwszUrl[PreferredUrlIndex] = pUrlArray->rgwszUrl[0];
        pUrlArray->rgwszUrl[0] = pwsz;
    }

    if ( ( fResult == FALSE ) && ( pwszUrlExtra != NULL ) )
    {
        if (dwFlags & CRYPT_ACCUMULATIVE_TIMEOUT)
        {
            // Limit each URL timeout to half of the remaining time
            dwTimeout = I_CryptRemainingMilliseconds(&ftEndUrlRetrieval) / 2;
            if (0 == dwTimeout)
            {
                dwTimeout = 1;
            }
        }

        fResult = RetrieveTimeValidObjectByUrl(
                          pwszUrlExtra,
                          pszContextOid,
                          pftValidFor,
                          dwFlags,
                          dwTimeout,
                          pCredentials,
                          pIssuer,
                          pvSubject,
                          OriginIdentifier,
                          &pvContext,
                          pvReserved
                          );

        if ( fResult == TRUE )
        {
            CCryptUrlArray   cua( pUrlArray->cUrl + 1, 5, fResult );
            DWORD            cb = 0;
            PCRYPT_URL_ARRAY pcua = NULL;

            if ( fResult == TRUE )
            {
                for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
                {
                    fResult = cua.AddUrl( pUrlArray->rgwszUrl[cCount], FALSE );
                    if ( fResult == FALSE )
                    {
                        break;
                    }
                }
            }

            if ( fResult == TRUE )
            {
                fResult = cua.GetArrayInSingleBufferEncodedForm(
                                 &pcua,
                                 &cb
                                 );
            }

            if ( fResult == TRUE )
            {
                fResult = ObjectContextCreateTVOCacheEntry(
                                m_Cache.LruCacheHandle(),
                                pszContextOid,
                                pvContext,
                                OriginIdentifier,
                                cb,
                                pcua,
                                pUrlArray->cUrl,
                                pIssuer,
                                &pEntry
                                );

                if ( fResult == FALSE )
                {
                    CryptMemFree( pcua );
                }
            }

            cua.FreeArray( FALSE );
        }
    }

    LastError = GetLastError();

    EnterCriticalSection( &m_Lock );

    pFound = m_Cache.FindCacheEntry(
        OriginIdentifier,
        pszContextOid,
        pvSubject
        );

    if ( !fResult && pFound && !( dwFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
    {
        SetOfflineUrlTime( &pFound->OfflineUrlTimeInfo );
    }

    if ( ( fResult == TRUE ) && !( dwFlags & CRYPT_DONT_VERIFY_SIGNATURE ) )
    {
        if ( ( pFound != NULL ) &&
             ( CompareFileTime(
                      &pFound->CreateTime,
                      &pEntry->CreateTime
                      ) >= 0 ) )
        {
            ObjectContextFree( pszContextOid, pvContext );

            pvContext = ObjectContextDuplicate(
                              pFound->pszContextOid,
                              pFound->pvContext
                              );

            SetOnlineUrlTime( &pFound->OfflineUrlTimeInfo );

            ObjectContextFreeTVOCacheEntry( pEntry );
        }
        else
        {
            if ( pFound != NULL )
            {
                m_Cache.RemoveCacheEntry( pFound );
            }

            m_Cache.InsertCacheEntry( pEntry );
        }

    }
    else if ( pEntry != NULL )
    {
        ObjectContextFreeTVOCacheEntry( pEntry );
    }

    LeaveCriticalSection( &m_Lock );

    if ( pvContext != NULL )
    {
        if ( ( ppvObject != NULL ) && ( fResult == TRUE ) )
        {
            *ppvObject = pvContext;
        }
        else
        {
            ObjectContextFree( pszContextOid, pvContext );
        }
    }

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::FlushTimeValidObject, public
//
//  Synopsis:   flush time valid object
//
//----------------------------------------------------------------------------
BOOL
CTVOAgent::FlushTimeValidObject (
                IN LPCSTR pszFlushTimeValidOid,
                IN LPVOID pvPara,
                IN LPCSTR pszFlushContextOid,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                IN LPVOID pvReserved
                )
{
    BOOL                    fResult = TRUE;
    CRYPT_ORIGIN_IDENTIFIER OriginIdentifier;
    PTVO_CACHE_ENTRY        pCacheEntry = NULL;
    PCRYPT_URL_ARRAY        pUrlArray = NULL;
    DWORD                   cbUrlArray;
    DWORD                   dwError = 0;
    DWORD                   cCount;

    BOOL                    fCrlFromCert = FALSE;
    LPCSTR                  pszUrlOidCrlFromCert = NULL;
    LPVOID                  pvSubject = NULL;
    BOOL                    fFreshest = FALSE;

    if ( pszFlushTimeValidOid == TIME_VALID_OID_GET_CRL_FROM_CERT )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CERTIFICATE_CRL_DIST_POINT;
        pvSubject = pvPara;
    }
    else if ( pszFlushTimeValidOid == TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CERTIFICATE_FRESHEST_CRL;
        pvSubject = pvPara;
        fFreshest = TRUE;
    }
    else if ( pszFlushTimeValidOid == TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CRL_FRESHEST_CRL;
        pvSubject = (LPVOID) ((PCCERT_CRL_CONTEXT_PAIR)pvPara)->pCertContext;
        fFreshest = TRUE;
    }

    if (fCrlFromCert)
    {
        if ( CrlGetOriginIdentifierFromSubjectCert(
                   (PCCERT_CONTEXT)pvSubject,
                   pIssuer,
                   fFreshest,
                   OriginIdentifier
                   ) == FALSE )
        {
            return( FALSE );
        }

        assert( pszFlushContextOid == CONTEXT_OID_CRL );
    }
    else
    {
        if ( ObjectContextGetOriginIdentifier(
                   pszFlushContextOid,
                   pvPara,
                   pIssuer,
                   0,
                   OriginIdentifier
                   ) == FALSE )
        {
            return( FALSE );
        }
    }

    EnterCriticalSection( &m_Lock );

    pCacheEntry = m_Cache.FindCacheEntry(
        OriginIdentifier,
        pszFlushContextOid,
        pvSubject
        );

    if ( pCacheEntry != NULL )
    {
        // Remove the entry but suppress the freeing of it since we are going
        // to use the data structure later
        m_Cache.RemoveCacheEntry( pCacheEntry, TRUE );
    }

    LeaveCriticalSection( &m_Lock );

    if ( pCacheEntry != NULL )
    {
        if ( pCacheEntry->pUrlArrayThis != NULL )
        {
            for ( cCount = 0;
                  cCount < pCacheEntry->pUrlArrayThis->cUrl;
                  cCount++ )
            {
                if ( ( SchemeDeleteUrlCacheEntry(
                             pCacheEntry->pUrlArrayThis->rgwszUrl[cCount]
                             ) == FALSE ) &&
                     ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
                {
                    dwError = GetLastError();
                }
            }
        }

        if ( pCacheEntry->pUrlArrayNext != NULL )
        {
            for ( cCount = 0;
                  cCount < pCacheEntry->pUrlArrayNext->cUrl;
                  cCount++ )
            {
                if ( ( SchemeDeleteUrlCacheEntry(
                             pCacheEntry->pUrlArrayNext->rgwszUrl[cCount]
                             ) == FALSE ) &&
                     ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
                {
                    dwError = GetLastError();
                }
            }
        }

        //
        //         Can place optimization here where if the hashes of the
        //         cache object and the passed in object are the same,
        //         we don't need to do any more work
        //

        ObjectContextFreeTVOCacheEntry( pCacheEntry );
    }

    if ( fCrlFromCert )
    {
        fResult = CertificateGetCrlDistPointUrl(
                             pszUrlOidCrlFromCert,
                             pvPara,
                             NULL,                      // pwszUrlHint
                             &pUrlArray,
                             &cbUrlArray,
                             NULL,                      // pPreferredUrlIndex
                             NULL                       // pfHintInArray
                             );
    }
    else if ( pszFlushTimeValidOid == TIME_VALID_OID_GET_CTL )
    {
        fResult = ObjectContextGetNextUpdateUrl(
                        pszFlushContextOid,
                        pvPara,
                        pIssuer,
                        NULL,
                        &pUrlArray,
                        &cbUrlArray,
                        NULL,
                        NULL
                        );
    }

    if ( ( fResult == TRUE ) && ( pUrlArray != NULL ) )
    {
        for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
        {
            if ( ( SchemeDeleteUrlCacheEntry(
                         pUrlArray->rgwszUrl[cCount]
                         ) == FALSE ) &&
                 ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
            {
                dwError = GetLastError();
            }
        }
    }

    if ( pUrlArray )
    {
        delete [] (BYTE *) pUrlArray;
    }

    if ( ( fResult == TRUE ) && ( dwError != 0 ) )
    {
        SetLastError( dwError );
        fResult = FALSE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidCreateOrExpireTime
//
//  Synopsis:   for fCheckFreshnessTime, checks if the
//              specified time is before or the same as the create time.
//              Otherwise, checks if the specified time is before or the
//              same as the expire time. A zero expire time matches any time.
//
//----------------------------------------------------------------------------
BOOL WINAPI
IsValidCreateOrExpireTime (
    IN BOOL fCheckFreshnessTime,
    IN LPFILETIME pftValidFor,
    IN LPFILETIME pftCreateTime,
    IN LPFILETIME pftExpireTime
    )
{
    if (fCheckFreshnessTime) {
        if (CompareFileTime(pftValidFor, pftCreateTime) <= 0)
            return TRUE;
        else
            return FALSE;
    } else {
        if (CompareFileTime(pftValidFor, pftExpireTime) <= 0 ||
                I_CryptIsZeroFileTime(pftExpireTime))
            return TRUE;
        else
            return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextCreateTVOCacheEntry
//
//  Synopsis:   create a TVO cache entry
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextCreateTVOCacheEntry (
      IN HLRUCACHE hCache,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
      IN DWORD cbUrlArrayThis,
      IN PCRYPT_URL_ARRAY pUrlArrayThis,
      IN DWORD UrlIndexThis,
      IN PCCERT_CONTEXT pIssuer,
      OUT PTVO_CACHE_ENTRY* ppEntry
      )
{
    BOOL             fResult = TRUE;
    PTVO_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB  DataBlob;

    pEntry = new TVO_CACHE_ENTRY;
    if ( pEntry == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    memset( pEntry, 0, sizeof( TVO_CACHE_ENTRY ) );

    // NOTENOTE: This presumes a predefined context oid constant
    pEntry->pszContextOid = pszContextOid;
    pEntry->pvContext = ObjectContextDuplicate( pszContextOid, pvContext );
    memcpy(pEntry->OriginIdentifier, OriginIdentifier,
        sizeof(pEntry->OriginIdentifier));

    DataBlob.cbData = MD5DIGESTLEN;
    DataBlob.pbData = pEntry->OriginIdentifier;

    fResult = I_CryptCreateLruEntry(
                     hCache,
                     &DataBlob,
                     pEntry,
                     &pEntry->hLruEntry
                     );

    if ( fResult == TRUE )
    {
        ObjectContextGetNextUpdateUrl(
              pszContextOid,
              pvContext,
              pIssuer,
              pUrlArrayThis->rgwszUrl[UrlIndexThis],
              &pEntry->pUrlArrayNext,
              &pEntry->cbUrlArrayNext,
              &pEntry->UrlIndexNext,
              NULL
              );

        fResult = ObjectContextGetCreateAndExpireTimes(
                        pszContextOid,
                        pvContext,
                        &pEntry->CreateTime,
                        &pEntry->ExpireTime
                        );
    }

    if ( fResult == TRUE )
    {
        pEntry->cbUrlArrayThis = cbUrlArrayThis;
        pEntry->pUrlArrayThis = pUrlArrayThis;
        pEntry->UrlIndexThis = UrlIndexThis;

        *ppEntry = pEntry;
    }
    else
    {
        ObjectContextFreeTVOCacheEntry( pEntry );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFreeTVOCacheEntry
//
//  Synopsis:   free TVO cache entry
//
//----------------------------------------------------------------------------
VOID WINAPI
ObjectContextFreeTVOCacheEntry (
      IN PTVO_CACHE_ENTRY pEntry
      )
{
    if ( pEntry->hLruEntry != NULL )
    {
        I_CryptReleaseLruEntry( pEntry->hLruEntry );
    }

    delete [] (BYTE *) pEntry->pUrlArrayThis;
    delete [] (BYTE *) pEntry->pUrlArrayNext;

    if ( pEntry->pvContext != NULL )
    {
        ObjectContextFree( pEntry->pszContextOid, pEntry->pvContext );
    }

    delete pEntry;
}


//+---------------------------------------------------------------------------
//
//  Function:   CertificateGetCrlDistPointUrl
//
//  Synopsis:   get crl dist point URL from certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateGetCrlDistPointUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN LPWSTR pwszUrlHint,
           OUT PCRYPT_URL_ARRAY* ppUrlArray,
           OUT DWORD* pcbUrlArray,
           OUT DWORD* pPreferredUrlIndex,
           OUT BOOL* pfHintInArray
           )
{
    BOOL             fResult;
    DWORD            cbUrlArray;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD            PreferredUrlIndex;

    fResult = CryptGetObjectUrl(
                   pszUrlOid,
                   pvPara,
                   0,
                   NULL,
                   &cbUrlArray,
                   NULL,
                   NULL,
                   NULL
                   );

    if ( fResult == TRUE )
    {
        pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
        if ( pUrlArray != NULL )
        {
            fResult = CryptGetObjectUrl(
                           pszUrlOid,
                           pvPara,
                           0,
                           pUrlArray,
                           &cbUrlArray,
                           NULL,
                           NULL,
                           NULL
                           );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        BOOL fHintInArray = FALSE;

        GetUrlArrayIndex(
           pUrlArray,
           pwszUrlHint,
           0,
           &PreferredUrlIndex,
           &fHintInArray
           );

        *ppUrlArray = pUrlArray;
        *pcbUrlArray = cbUrlArray;

        if ( pfHintInArray != NULL )
        {
            *pfHintInArray = fHintInArray;
        }

        if ( pPreferredUrlIndex != NULL )
        {
            *pPreferredUrlIndex = PreferredUrlIndex;
        }
    }
    else
    {
        if ( pUrlArray )
        {
            delete [] (BYTE *) pUrlArray;
        }
    }

    return( fResult );
}

BOOL WINAPI
RetrieveObjectByUrlValidForSubject(
        IN LPWSTR pwszUrl,
        IN LPCSTR pszContextOid,
        IN BOOL fCheckFreshnessTime,
        IN LPFILETIME pftValidFor,
        IN DWORD dwRetrievalFlags,
        IN DWORD dwTimeout,
        IN PCRYPT_CREDENTIALS pCredentials,
        IN PCCERT_CONTEXT pSigner,
        IN LPVOID pvSubject,
        IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
        OUT LPVOID* ppvObject,
        IN OPTIONAL LPVOID pvReserved
        )
{
    BOOL fResult;
    HCERTSTORE hUrlStore = NULL;
    LPVOID pvObject;

    fResult = CryptRetrieveObjectByUrlW(
        pwszUrl,
        pszContextOid,
        (dwRetrievalFlags | 
                CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
                CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL) &
            ~CRYPT_VERIFY_CONTEXT_SIGNATURE,
        dwTimeout,
        (LPVOID *) &hUrlStore,
        NULL,                               // hAsyncRetrieve
        NULL,                               // pCredentials
        NULL,                               // pSigner
        NULL                                // pvReserved
        );

    if (!fResult)
        goto CommonReturn;

    pvObject = NULL;
    while (pvObject = ObjectContextEnumObjectsInStore (
            hUrlStore,
            pszContextOid,
            pvObject
            ))
    {
        CRYPT_ORIGIN_IDENTIFIER ObjectOriginIdentifier;

        if (!ObjectContextGetOriginIdentifier(
                    pszContextOid,
                    pvObject,
                    pSigner,
                    0,
                    ObjectOriginIdentifier
                    ))
            continue;

        if (0 != memcmp(OriginIdentifier, ObjectOriginIdentifier,
                sizeof(ObjectOriginIdentifier)))
            continue;

        if (dwRetrievalFlags & CRYPT_VERIFY_CONTEXT_SIGNATURE) {
            if (!ObjectContextVerifySignature (
                    pszContextOid,
                    pvObject,
                    pSigner
                    ))
                continue;
        }

        if (!ObjectContextIsValidForSubject (
                pszContextOid,
                pvObject,
                pvSubject,
                pvReserved
                ))
            continue;

        if (NULL != pftValidFor) {
            FILETIME CreateTime;
            FILETIME ExpireTime;

            if (!ObjectContextGetCreateAndExpireTimes(
                    pszContextOid,
                    pvObject,
                    &CreateTime,
                    &ExpireTime
                    ))
                continue;

            if (!IsValidCreateOrExpireTime (
                    fCheckFreshnessTime,
                    pftValidFor,
                    &CreateTime,
                    &ExpireTime ) )
                continue;
        }

        *ppvObject = pvObject;
        fResult = TRUE;
        goto CommonReturn;
    }

    // Make sure the error isn't CRYPT_E_NOT_FOUND. msrevoke will
    // return CRYPT_E_NO_REVOCATION_CHECK instead of
    // CRYPT_E_REVOCATION_OFFLINE for CRYPT_E_NOT_FOUND.
    SetLastError(ERROR_FILE_NOT_FOUND);
    fResult = FALSE;

CommonReturn:
    if (hUrlStore)
        CertCloseStore(hUrlStore, 0);
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   RetrieveTimeValidObjectByUrl
//
//  Synopsis:   retrieve a time valid object given an URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
RetrieveTimeValidObjectByUrl (
        IN LPWSTR pwszUrl,
        IN LPCSTR pszContextOid,
        IN LPFILETIME pftValidFor,
        IN DWORD dwFlags,
        IN DWORD dwTimeout,
        IN PCRYPT_CREDENTIALS pCredentials,
        IN PCCERT_CONTEXT pSigner,
        IN LPVOID pvSubject,
        IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
        OUT LPVOID* ppvObject,
        IN OPTIONAL LPVOID pvReserved
        )
{
    BOOL     fResult = FALSE;
    LPVOID   pvContext = NULL;
    DWORD    dwVerifyFlags = 0;
    DWORD    dwCacheStoreFlags = CRYPT_DONT_CACHE_RESULT;

    if ( dwFlags & CRYPT_DONT_CHECK_TIME_VALIDITY )
    {
        pftValidFor = NULL;
    }

    if ( !( dwFlags & CRYPT_DONT_VERIFY_SIGNATURE ) )
    {
        dwVerifyFlags |= CRYPT_VERIFY_CONTEXT_SIGNATURE;
        dwCacheStoreFlags &= ~CRYPT_DONT_CACHE_RESULT;
    }

    if ( !( dwFlags & CRYPT_WIRE_ONLY_RETRIEVAL ) )
    {
        fResult = RetrieveObjectByUrlValidForSubject(
                       pwszUrl,
                       pszContextOid,
                       0 != (dwFlags & CRYPT_CHECK_FRESHNESS_TIME_VALIDITY),
                       pftValidFor,
                       CRYPT_CACHE_ONLY_RETRIEVAL |
                           dwVerifyFlags,
                       0,                               // dwTimeout
                       NULL,                            // pCredentials
                       pSigner,
                       pvSubject,
                       OriginIdentifier,
                       &pvContext,
                       pvReserved
                       );
    }

    if ( fResult == FALSE )
    {
        if ( !( dwFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
        {
            DWORD dwRetrievalFlags = CRYPT_WIRE_ONLY_RETRIEVAL |
                                       dwCacheStoreFlags |
                                       dwVerifyFlags;

            LONG lStatus;

            //  +1 - Online
            //   0 - Offline, current time >= earliest online time, hit the wire
            //  -1 - Offline, current time < earliest onlime time
            lStatus = GetOriginUrlStatusW(
                            OriginIdentifier,
                            pwszUrl,
                            pszContextOid,
                            dwRetrievalFlags
                            );

            if (lStatus >= 0)
            {
                fResult = RetrieveObjectByUrlValidForSubject(
                           pwszUrl,
                           pszContextOid,
                           0 != (dwFlags & CRYPT_CHECK_FRESHNESS_TIME_VALIDITY),
                           pftValidFor,
                           dwRetrievalFlags,
                           dwTimeout,
                           pCredentials,
                           pSigner,
                           pvSubject,
                           OriginIdentifier,
                           &pvContext,
                           pvReserved
                           );
                if (!fResult)
                {
                    DWORD dwErr = GetLastError();

                    SetOfflineOriginUrlW(
                        OriginIdentifier,
                        pwszUrl,
                        pszContextOid,
                        dwRetrievalFlags
                        );

                    SetLastError( dwErr );
                }
                else if (lStatus == 0)
                {
                    // Remove from offline list
                    SetOnlineOriginUrlW(
                            OriginIdentifier,
                            pwszUrl,
                            pszContextOid,
                            dwRetrievalFlags
                            );
                }
            }

        }
    }

    *ppvObject = pvContext;

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateProcessTVOAgent
//
//  Synopsis:   create process TVO agent
//
//----------------------------------------------------------------------------
BOOL WINAPI
CreateProcessTVOAgent (
      OUT CTVOAgent** ppAgent
      )
{
    BOOL       fResult = FALSE;
    HKEY       hKey = NULL;
    DWORD      dwType = REG_DWORD;
    DWORD      dwSize = sizeof( DWORD );
    DWORD      cCacheBuckets;
    DWORD      MaxCacheEntries;
    CTVOAgent* pAgent;

    if ( RegOpenKeyA(
            HKEY_LOCAL_MACHINE,
            TVO_KEY_NAME,
            &hKey
            ) == ERROR_SUCCESS )
    {
        if ( RegQueryValueExA(
                hKey,
                TVO_CACHE_BUCKETS_VALUE_NAME,
                NULL,
                &dwType,
                (LPBYTE)&cCacheBuckets,
                &dwSize
                ) != ERROR_SUCCESS )
        {
            cCacheBuckets = TVO_DEFAULT_CACHE_BUCKETS;
        }

        if ( RegQueryValueExA(
                hKey,
                TVO_MAX_CACHE_ENTRIES_VALUE_NAME,
                NULL,
                &dwType,
                (LPBYTE)&MaxCacheEntries,
                &dwSize
                ) != ERROR_SUCCESS )
        {
            MaxCacheEntries = TVO_DEFAULT_MAX_CACHE_ENTRIES;
        }

        RegCloseKey(hKey);
    }
    else
    {
        cCacheBuckets = TVO_DEFAULT_CACHE_BUCKETS;
        MaxCacheEntries = TVO_DEFAULT_MAX_CACHE_ENTRIES;
    }

    pAgent = new CTVOAgent( cCacheBuckets, MaxCacheEntries, fResult );
    if ( pAgent == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == TRUE )
    {
        *ppAgent = pAgent;
    }
    else
    {
        delete pAgent;
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\setx509\setx509.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:	    setx509.cpp
//
//  Contents:   SET Certificate Extension Encode/Decode Functions
//
//              ASN.1 implementation uses the OSS compiler.
//
//  Functions:  DllRegisterServer
//              DllUnregisterServer
//              DllMain
//              SetAsn1AccountAliasEncode
//              SetAsn1AccountAliasDecode
//              SetAsn1HashedRootKeyEncode
//              SetAsn1HashedRootKeyDecode
//              SetAsn1CertificateTypeEncode
//              SetAsn1CertificateTypeDecode
//              SetAsn1MerchantDataEncode
//              SetAsn1MerchantDataDecode
//
//              CertDllVerifyRevocation
//
//  History:	21-Nov-96	philh   created
//
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static HCRYPTASN1MODULE hAsn1Module;

// The following is for test purposes
#define TLS_TEST_COUNT 20
static HCRYPTTLS hTlsTest[TLS_TEST_COUNT];

static HMODULE hMyModule;

// Set to 1 via InterlockedExchange when installed. Only install the
// first time when changed from 0 to 1.
static LONG lInstallDecodeFunctions = 0;

static LONG lInstallRevFunctions = 0;

//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static ASN1encoding_t GetEncoder(void)
{
    // The following is for test purposes only
    for (DWORD i = 0; i < TLS_TEST_COUNT; i++) {
        DWORD_PTR dw = (DWORD_PTR) I_CryptGetTls(hTlsTest[i]);
        if (dw == 0)
            dw = i;
        else
            dw++;
        I_CryptSetTls(hTlsTest[i], (void *) dw);
    }

    return I_CryptGetAsn1Encoder(hAsn1Module);
}
static ASN1decoding_t GetDecoder(void)
{
    // The following is for test purposes only
    for (DWORD i = 0; i < TLS_TEST_COUNT; i++) {
        DWORD_PTR dw = (DWORD_PTR) I_CryptGetTls(hTlsTest[i]);
        if (dw == 0)
            dw = i;
        else
            dw++;
        I_CryptSetTls(hTlsTest[i], (void *) dw);
    }

    return I_CryptGetAsn1Decoder(hAsn1Module);
}


//+-------------------------------------------------------------------------
//  SetX509 allocation and free functions
//--------------------------------------------------------------------------
static void *SetX509Alloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void SetX509Free(
    IN void *pv
    )
{
    free(pv);
}

static HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//  OSS X509 v3 SET Private Extension ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1AccountAliasEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BOOL *pbInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SetAsn1AccountAliasDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BOOL *pbInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL
WINAPI
SetAsn1HashedRootKeyEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SetAsn1HashedRootKeyDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        IN OUT DWORD *pcbInfo
        );
BOOL
WINAPI
SetAsn1CertificateTypeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SetAsn1CertificateTypeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL
WINAPI
SetAsn1MerchantDataEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSET_MERCHANT_DATA_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SetAsn1MerchantDataDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSET_MERCHANT_DATA_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

typedef struct _OID_REG_ENTRY {
    LPCSTR   pszOID;
    LPCSTR   pszOverrideFuncName;
} OID_REG_ENTRY, *POID_REG_ENTRY;

static const OID_REG_ENTRY RegEncodeBeforeTable[] = {
    szOID_SET_ACCOUNT_ALIAS, "SetAsn1AccountAliasEncode",
    szOID_SET_HASHED_ROOT_KEY, "SetAsn1HashedRootKeyEncode",

    X509_SET_ACCOUNT_ALIAS, "SetAsn1AccountAliasEncode",
    X509_SET_HASHED_ROOT_KEY, "SetAsn1HashedRootKeyEncode",
};
#define REG_ENCODE_BEFORE_COUNT (sizeof(RegEncodeBeforeTable) / sizeof(RegEncodeBeforeTable[0]))

static const OID_REG_ENTRY RegEncodeAfterTable[] = {
    szOID_SET_CERTIFICATE_TYPE, "SetAsn1CertificateTypeEncode",
    szOID_SET_MERCHANT_DATA, "SetAsn1MerchantDataEncode",

    X509_SET_CERTIFICATE_TYPE, "SetAsn1CertificateTypeEncode",
    X509_SET_MERCHANT_DATA, "SetAsn1MerchantDataEncode"
};
#define REG_ENCODE_AFTER_COUNT (sizeof(RegEncodeAfterTable) / sizeof(RegEncodeAfterTable[0]))

static const OID_REG_ENTRY RegDecodeTable[] = {
    szOID_SET_ACCOUNT_ALIAS, "SetAsn1AccountAliasDecode",
    szOID_SET_HASHED_ROOT_KEY, "SetAsn1HashedRootKeyDecode",
    szOID_SET_CERTIFICATE_TYPE, "SetAsn1CertificateTypeDecode",
    szOID_SET_MERCHANT_DATA, "SetAsn1MerchantDataDecode",

    X509_SET_ACCOUNT_ALIAS, "SetAsn1AccountAliasDecode",
    X509_SET_HASHED_ROOT_KEY, "SetAsn1HashedRootKeyDecode",
    X509_SET_CERTIFICATE_TYPE, "SetAsn1CertificateTypeDecode",
    X509_SET_MERCHANT_DATA, "SetAsn1MerchantDataDecode"
};
#define REG_DECODE_COUNT (sizeof(RegDecodeTable) / sizeof(RegDecodeTable[0]))

#define OID_INFO_LEN sizeof(CRYPT_OID_INFO)

// Ordered lists of acceptable RDN attribute value types. 0 terminates.
static const DWORD rgdwPrintableValueType[] = { CERT_RDN_PRINTABLE_STRING, 0 };
static const DWORD rgdwIA5ValueType[] = { CERT_RDN_IA5_STRING, 0 };
static const DWORD rgdwNumericValueType[] = { CERT_RDN_NUMERIC_STRING, 0 };

#define RDN_ATTR_ENTRY(pszOID, pwszName, rgdwValueType) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 64, \
    sizeof(rgdwValueType), (BYTE *) rgdwValueType
#define DEFAULT_RDN_ATTR_ENTRY(pszOID, pwszName) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 128, 0, NULL

#define EXT_ATTR_ENTRY(pszOID, pwszName) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_EXT_OR_ATTR_OID_GROUP_ID, 0, 0, NULL

#define PUBKEY_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, 0, NULL
#define PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, Algid, dwFlags) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, sizeof(dwFlags), (BYTE *) &dwFlags

static const DWORD dwDSSTestFlags = CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG;


static const DWORD rgdwTestRsaSign[] = {
    CALG_RSA_SIGN,
    0,
    PROV_RSA_FULL
};

#define TEST_SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, aiHash, rgdwExtra) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_SIGN_ALG_OID_GROUP_ID, aiHash, \
    sizeof(rgdwExtra), (BYTE *) rgdwExtra

#define TEST_RSA_SIGN_ALG_ENTRY(pszOID, pwszName, aiHash) \
    TEST_SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, aiHash, rgdwTestRsaSign)


static CCRYPT_OID_INFO OIDInfoAfterTable[] = {
    DEFAULT_RDN_ATTR_ENTRY("1.2.1", L"TestRDNAttr #1"),
    RDN_ATTR_ENTRY("1.2.2", L"TestRDNAttr #2", rgdwPrintableValueType),
    EXT_ATTR_ENTRY(szOID_SET_CERTIFICATE_TYPE, L"SETCertificateType"),
    EXT_ATTR_ENTRY(szOID_SET_HASHED_ROOT_KEY, L"SETHashedRootKey"),
};
#define OID_INFO_AFTER_CNT (sizeof(OIDInfoAfterTable) / \
                                        sizeof(OIDInfoAfterTable[0]))

static CCRYPT_OID_INFO OIDInfoBeforeTable[] = {
//    PUBKEY_EXTRA_ALG_ENTRY(szOID_OIWSEC_dsa, L"SETDSSTest", CALG_DSS_SIGN,
//        dwDSSTestFlags),
//    TEST_RSA_SIGN_ALG_ENTRY(szOID_RSA_SHA1RSA, L"sha1RSA", CALG_SHA1),
//    TEST_RSA_SIGN_ALG_ENTRY(szOID_RSA_MD5RSA, L"md5RSA", CALG_MD5),
    EXT_ATTR_ENTRY(szOID_SET_ACCOUNT_ALIAS, L"SETAccountAlias"),
    EXT_ATTR_ENTRY(szOID_SET_MERCHANT_DATA, L"SETMerchantData"),
};
#define OID_INFO_BEFORE_CNT (sizeof(OIDInfoBeforeTable) / \
                                        sizeof(OIDInfoBeforeTable[0]))

//+-------------------------------------------------------------------------
//  Localized Name Table
//--------------------------------------------------------------------------
typedef struct _LOCALIZED_NAME_INFO {
    LPCWSTR         pwszCryptName;
    LPCWSTR         pwszLocalizedName;
} LOCALIZED_NAME_INFO, *PLOCALIZED_NAME_INFO;


static LOCALIZED_NAME_INFO LocalizedNameTable[] = {
    L"Test",        L"*** Test ***",
    L"TestTrust",   L"### TestTrust ###",
};
#define LOCALIZED_NAME_CNT  (sizeof(LocalizedNameTable) / \
                                    sizeof(LocalizedNameTable[0]))

BOOL
WINAPI
CertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwRevFlags,
    IN PVOID pvReserved,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    );


STDAPI DllRegisterServer(void)
{
    int i;

    for (i = 0; i < REG_ENCODE_BEFORE_COUNT; i++) {
        DWORD dwFlags = CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG;
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeBeforeTable[i].pszOID,
                L"setx509.dll",
                RegEncodeBeforeTable[i].pszOverrideFuncName
                ))
            return HError();
        if (!CryptSetOIDFunctionValue(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeBeforeTable[i].pszOID,
                CRYPT_OID_REG_FLAGS_VALUE_NAME,
                REG_DWORD,
                (BYTE *) &dwFlags,
                sizeof(dwFlags)
                ))
            return HError();
    }
    for (i = 0; i < REG_ENCODE_AFTER_COUNT; i++)
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeAfterTable[i].pszOID,
                L"setx509.dll",
                RegEncodeAfterTable[i].pszOverrideFuncName
                ))
            return HError();

    for (i = 0; i < REG_DECODE_COUNT; i++)
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                RegDecodeTable[i].pszOID,
                L"setx509.dll",
                RegDecodeTable[i].pszOverrideFuncName
                ))
            return HError();

    if (!CryptRegisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            CRYPT_REGISTER_LAST_INDEX,
            L"setx509.dll"
            )) {
        if (ERROR_FILE_EXISTS != GetLastError())
            return HError();
    }

    for (i = 0; i < OID_INFO_BEFORE_CNT; i++)
        if (!CryptRegisterOIDInfo(
                &OIDInfoBeforeTable[i],
                CRYPT_INSTALL_OID_INFO_BEFORE_FLAG
                ))
            return HError();
    for (i = 0; i < OID_INFO_AFTER_CNT; i++)
        if (!CryptRegisterOIDInfo(
                &OIDInfoAfterTable[i],
                0                           // dwFlags
                ))
            return HError();

    for (i = 0; i < LOCALIZED_NAME_CNT; i++)
        if (!CryptSetOIDFunctionValue(
                CRYPT_LOCALIZED_NAME_ENCODING_TYPE,
                CRYPT_OID_FIND_LOCALIZED_NAME_FUNC,
                CRYPT_LOCALIZED_NAME_OID,
                LocalizedNameTable[i].pwszCryptName,
                REG_SZ,
                (const BYTE *) LocalizedNameTable[i].pwszLocalizedName,
                (wcslen(LocalizedNameTable[i].pwszLocalizedName) + 1) *
                    sizeof(WCHAR)
                ))
            return HError();
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;
    int i;

    for (i = 0; i < REG_ENCODE_BEFORE_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeBeforeTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < REG_ENCODE_AFTER_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeAfterTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < REG_DECODE_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                RegDecodeTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    if (!CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"setx509.dll"
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

    for (i = 0; i < OID_INFO_BEFORE_CNT; i++) {
        if (!CryptUnregisterOIDInfo(
                &OIDInfoBeforeTable[i]
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }
    for (i = 0; i < OID_INFO_AFTER_CNT; i++) {
        if (!CryptUnregisterOIDInfo(
                &OIDInfoAfterTable[i]
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < LOCALIZED_NAME_CNT; i++)
        if (!CryptSetOIDFunctionValue(
                CRYPT_LOCALIZED_NAME_ENCODING_TYPE,
                CRYPT_OID_FIND_LOCALIZED_NAME_FUNC,
                CRYPT_LOCALIZED_NAME_OID,
                LocalizedNameTable[i].pwszCryptName,
                REG_SZ,
                NULL,
                0
                ))
            return HError();

    return hr;
}

static const CRYPT_OID_FUNC_ENTRY SetEncodeFuncTable[] = {
    szOID_SET_ACCOUNT_ALIAS, SetAsn1AccountAliasEncode,
    szOID_SET_HASHED_ROOT_KEY, SetAsn1HashedRootKeyEncode,
    szOID_SET_CERTIFICATE_TYPE, SetAsn1CertificateTypeEncode,
    szOID_SET_MERCHANT_DATA, SetAsn1MerchantDataEncode,

    X509_SET_ACCOUNT_ALIAS, SetAsn1AccountAliasEncode,
    X509_SET_HASHED_ROOT_KEY, SetAsn1HashedRootKeyEncode,
    X509_SET_CERTIFICATE_TYPE, SetAsn1CertificateTypeEncode,
    X509_SET_MERCHANT_DATA, SetAsn1MerchantDataEncode,
};

#define SET_ENCODE_FUNC_COUNT (sizeof(SetEncodeFuncTable) / \
                                    sizeof(SetEncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY SetDecodeFuncTable[] = {
    szOID_SET_ACCOUNT_ALIAS, SetAsn1AccountAliasDecode,
    szOID_SET_HASHED_ROOT_KEY, SetAsn1HashedRootKeyDecode,
    szOID_SET_CERTIFICATE_TYPE, SetAsn1CertificateTypeDecode,
    szOID_SET_MERCHANT_DATA, SetAsn1MerchantDataDecode,

    X509_SET_ACCOUNT_ALIAS, SetAsn1AccountAliasDecode,
    X509_SET_HASHED_ROOT_KEY, SetAsn1HashedRootKeyDecode,
    X509_SET_CERTIFICATE_TYPE, SetAsn1CertificateTypeDecode,
    X509_SET_MERCHANT_DATA, SetAsn1MerchantDataDecode
};

#define SET_DECODE_FUNC_COUNT (sizeof(SetDecodeFuncTable) / \
                                    sizeof(SetDecodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY SetRevFuncTable[] = {
    CRYPT_DEFAULT_OID, CertDllVerifyRevocation
};

#define SET_REV_FUNC_COUNT (sizeof(SetRevFuncTable) / \
                                    sizeof(SetRevFuncTable[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;
    DWORD   i;
    DWORD_PTR dwTlsValue;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        //  The following is for test purposes only
        for (i = 0; i < TLS_TEST_COUNT; i++) {
            if (NULL == (hTlsTest[i] = I_CryptAllocTls()))
                goto CryptAllocTlsError;
        }

#ifdef OSS_CRYPT_ASN1
        if (0 == (hAsn1Module = I_CryptInstallAsn1Module(ossx509, 0, NULL)))
#else
        X509_Module_Startup();
        if (0 == (hAsn1Module = I_CryptInstallAsn1Module(
                X509_Module, 0, NULL)))
#endif  // OSS_CRYPT_ASN1
            goto CryptInstallAsn1ModuleError;

#if 0
        // For testing purposes not installed. Always want to call the
        // encode functions via dll load.
        if (!CryptInstallOIDFunctionAddress(
                hModule,
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                SET_ENCODE_FUNC_COUNT,
                SetEncodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
#endif

#if 0
        // For testing purposes deferred until first Decode
        if (!CryptInstallOIDFunctionAddress(
                hModule,
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                SET_DECODE_FUNC_COUNT,
                SetDecodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
#endif
        hMyModule = hModule;
        break;

    case DLL_PROCESS_DETACH:
        I_CryptUninstallAsn1Module(hAsn1Module);
#ifndef OSS_CRYPT_ASN1
        X509_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1

        //  The following is for test purposes only
        for (i = 0; i < TLS_TEST_COUNT; i++) {
            I_CryptFreeTls(hTlsTest[i], NULL);
        }
        break;

    case DLL_THREAD_DETACH:
        // The following is for test purposes only
        for (i = 0; i < TLS_TEST_COUNT; i++)
            dwTlsValue = (DWORD_PTR) I_CryptDetachTls(hTlsTest[i]);
        break;
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptAllocTlsError)
TRACE_ERROR(CryptInstallAsn1ModuleError)
#if 0
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
#endif
}

// Defer installation until the first decode. Called by each of the decode
// functions.
//
// Do the InterlockedExchange to ensure a single installation
static void InstallDecodeFunctions()
{
#if 0
    if (0 == InterlockedExchange(&lInstallDecodeFunctions, 1)) {
        if (!CryptInstallOIDFunctionAddress(
                hMyModule,
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                SET_DECODE_FUNC_COUNT,
                SetDecodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
#endif
}

// Defer installation until the first revocation.
//
// Do the InterlockedExchange to ensure a single installation
static void InstallRevFunctions()
{
    if (0 == InterlockedExchange(&lInstallRevFunctions, 1)) {
        if (!CryptInstallOIDFunctionAddress(
                hMyModule,
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                SET_REV_FUNC_COUNT,
                SetRevFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}

BOOL
WINAPI
CertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwRevFlags,
    IN PVOID pvReserved,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwIndex = 0;
    DWORD dwError = 0;
    HCERTSTORE hStore = NULL;
    HCERTSTORE hLinkStore = NULL;

    InstallRevFunctions();

    if (GET_CERT_ENCODING_TYPE(dwEncodingType) != CRYPT_ASN_ENCODING)
        goto NoRevocationCheckForEncodingTypeError;
    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE)
        goto NoRevocationCheckForRevTypeError;

    hStore = CertOpenSystemStore(NULL, "Test");
    if (NULL == hStore)
        goto OpenTestStoreError;

    hLinkStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
    if (NULL == hLinkStore)
        goto OpenLinkStoreError;

    for (dwIndex = 0; dwIndex < cContext; dwIndex++) {
        PCCERT_CONTEXT pCert = (PCCERT_CONTEXT) rgpvContext[dwIndex];
        PCERT_EXTENSION pExt;
        PCCERT_CONTEXT pIssuer;
        DWORD dwFlags;
        // Check that the certificate has a SET extension
        if (NULL == (pExt = CertFindExtension(szOID_SET_CERTIFICATE_TYPE,
                            pCert->pCertInfo->cExtension,
                            pCert->pCertInfo->rgExtension)))
            goto NoSETX509ExtensionError;

        // Attempt to get the certificate's issuer from the test store.
        // If found check signature and revocation.

        // For testing purposes: first found issuer.
        dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG;
        if (NULL == (pIssuer = CertGetIssuerCertificateFromStore(
                hStore,
                pCert,
                NULL,   // pPrevIssuerContext,
                &dwFlags)))
            goto NoIssuerError;
        else {
            BOOL fLinkResult;
            DWORD dwLinkFlags =
                CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG;
            PCCERT_CONTEXT pLinkIssuer = NULL;

            // Check that we get the same results if we put a link to the
            // issuer in a store and try to verify using the link.
            fLinkResult = CertAddCertificateLinkToStore(
                hLinkStore,
                pIssuer,
                CERT_STORE_ADD_ALWAYS,
                &pLinkIssuer
                );
            CertFreeCertificateContext(pIssuer);
            if (!fLinkResult)
                goto AddCertificateLinkError;

            if (!CertVerifySubjectCertificateContext(
                    pCert,
                    pLinkIssuer,
                    &dwLinkFlags
                    ))
                goto VerifySubjectCertificateContextError;

            if (dwLinkFlags != dwFlags)
                goto BadLinkVerifyResults;

            if (dwFlags & CERT_STORE_SIGNATURE_FLAG)
                goto BadCertificateSignatureError;
            if (dwFlags & CERT_STORE_NO_CRL_FLAG)
                goto NoCRLError;
            if (dwFlags & CERT_STORE_REVOCATION_FLAG) {
                pRevStatus->dwReason = CRL_REASON_KEY_COMPROMISE;
                goto CertificateRevocationError;
            }
            // else
            //  A checked certificate that hasn't been revoked.
            assert(dwFlags == 0);
        }
    }

    fResult = TRUE;
    dwIndex = 0;

CommonReturn:
    if (hStore)
        CertCloseStore(hStore, 0);
    if (hLinkStore)
        CertCloseStore(hLinkStore, CERT_CLOSE_STORE_FORCE_FLAG);
    pRevStatus->dwIndex = dwIndex;
    pRevStatus->dwError = dwError;
    return fResult;
ErrorReturn:
    dwError = GetLastError();
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenTestStoreError)
TRACE_ERROR(OpenLinkStoreError)
SET_ERROR(NoRevocationCheckForEncodingTypeError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoRevocationCheckForRevTypeError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoSETX509ExtensionError, CRYPT_E_NO_REVOCATION_CHECK)
TRACE_ERROR(NoIssuerError)
SET_ERROR(BadCertificateSignatureError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoCRLError, CRYPT_E_NO_REVOCATION_CHECK)

SET_ERROR(CertificateRevocationError, CRYPT_E_REVOKED)
TRACE_ERROR(AddCertificateLinkError)
TRACE_ERROR(VerifySubjectCertificateContextError)
SET_ERROR(BadLinkVerifyResults, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  OSS X509 v3 ASN.1 Set / Get functions
//
//  Called by the OSS X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
static inline void SetX509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pOss
        )
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
static inline void SetX509GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_BIT_BLOB
//--------------------------------------------------------------------------
static inline void SetX509SetBit(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BITSTRING *pOss
        )
{
    PkiAsn1SetBitString(pInfo, &pOss->length, &pOss->value);
}
static inline void SetX509GetBit(
        IN BITSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBitString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get LPSTR (IA5 String)
//--------------------------------------------------------------------------
static inline void SetX509SetIA5(
        IN LPSTR psz,
        OUT IA5STRING *pOss
        )
{
    pOss->value = psz;
    pOss->length = strlen(psz);
}
static inline void SetX509GetIA5(
        IN IA5STRING *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5String(pOss->length, pOss->value, dwFlags,
        ppsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the SetX509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL SetAsn1Encode(
        IN int pdunum,
        IN void *pOssInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfo(
        GetEncoder(),
        pdunum,
        pOssInfo,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the SetX509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL SetAsn1DecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppOssInfo
        )
{
    // For testing purposes, defer installation of decode functions until
    // first decode which is loaded via being registered.
    InstallDecodeFunctions();

    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppOssInfo);
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the SetX509*Decode() functions.
//--------------------------------------------------------------------------
static void SetAsn1Free(
        IN int pdunum,
        IN void *pOssInfo
        )
{
    if (pOssInfo) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pOssInfo);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  SET Account Alias Private Extension Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1AccountAliasEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BOOL *pbInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ossBoolean OssSETAccountAlias = (ossBoolean) *pbInfo;
    return SetAsn1Encode(
        SETAccountAlias_PDU,
        &OssSETAccountAlias,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SET Account Alias Private Extension Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1AccountAliasDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BOOL *pbInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    ossBoolean *pSETAccountAlias = NULL;

    if ((fResult = SetAsn1DecodeAndAlloc(
            SETAccountAlias_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pSETAccountAlias))) {
        if (*pcbInfo < sizeof(BOOL)) {
            if (pbInfo) {
                fResult = FALSE;
                SetLastError((DWORD) ERROR_MORE_DATA);
            }
        } else
            *pbInfo = (BOOL) *pSETAccountAlias;
        *pcbInfo = sizeof(BOOL);
    } else {
        if (*pcbInfo >= sizeof(BOOL))
            *pbInfo = FALSE;
        *pcbInfo = 0;
    }

    SetAsn1Free(SETAccountAlias_PDU, pSETAccountAlias);

    return fResult;
}

//+-------------------------------------------------------------------------
//  SET Hashed Root Private Extension Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1HashedRootKeyEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    OCTETSTRING OssSETHashedRootKey;

    OssSETHashedRootKey.value = rgbInfo;
    OssSETHashedRootKey.length = SET_HASHED_ROOT_LEN;
    return SetAsn1Encode(
        SETHashedRootKey_PDU,
        &OssSETHashedRootKey,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SET Hashed Root Private Extension Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1HashedRootKeyDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    OCTETSTRING *pSETHashedRootKey = NULL;

    if ((fResult = SetAsn1DecodeAndAlloc(
            SETHashedRootKey_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pSETHashedRootKey))) {
        if (pSETHashedRootKey->length != SET_HASHED_ROOT_LEN) {
            fResult = FALSE;
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            *pcbInfo = 0;
        } else {
            if (*pcbInfo < SET_HASHED_ROOT_LEN) {
                if (rgbInfo) {
                    fResult = FALSE;
                    SetLastError((DWORD) ERROR_MORE_DATA);
                }
            } else
                memcpy(rgbInfo, pSETHashedRootKey->value, SET_HASHED_ROOT_LEN);
            *pcbInfo = SET_HASHED_ROOT_LEN;
        }
    } else
        *pcbInfo = 0;

    SetAsn1Free(SETHashedRootKey_PDU, pSETHashedRootKey);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SET Certificate Type Private Extension Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1CertificateTypeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BITSTRING OssSETCertificateType;

    SetX509SetBit(pInfo, &OssSETCertificateType);
    return SetAsn1Encode(
        SETCertificateType_PDU,
        &OssSETCertificateType,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SET Certificate Type Private Extension Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1CertificateTypeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    BITSTRING *pSETCertificateType = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!SetAsn1DecodeAndAlloc(
            SETCertificateType_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pSETCertificateType))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CRYPT_BIT_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_BIT_BLOB);

    SetX509GetBit(pSETCertificateType, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    SetAsn1Free(SETCertificateType_PDU, pSETCertificateType);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SET Merchant Data Private Extension Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1MerchantDataEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSET_MERCHANT_DATA_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    SETMerchantData OssSETMerchantData;
    HCRYPTOIDFUNCSET hX509EncodeFuncSet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    SetX509SetIA5(pInfo->pszMerID, &OssSETMerchantData.merID);
    SetX509SetIA5(pInfo->pszMerAcquirerBIN,
        (IA5STRING *) &OssSETMerchantData.merAcquirerBIN);
    SetX509SetIA5(pInfo->pszMerTermID, &OssSETMerchantData.merTermID);
    SetX509SetIA5(pInfo->pszMerName, &OssSETMerchantData.merName);
    SetX509SetIA5(pInfo->pszMerCity, &OssSETMerchantData.merCity);
    SetX509SetIA5(pInfo->pszMerStateProvince,
        &OssSETMerchantData.merStateProvince);
    SetX509SetIA5(pInfo->pszMerPostalCode, &OssSETMerchantData.merPostalCode);
    SetX509SetIA5(pInfo->pszMerCountry, &OssSETMerchantData.merCountry);
    SetX509SetIA5(pInfo->pszMerPhone, &OssSETMerchantData.merPhone);
    OssSETMerchantData.merPhoneRelease = (pInfo->fMerPhoneRelease != 0);
    OssSETMerchantData.merAuthFlag = (pInfo->fMerAuthFlag != 0);

    // For testing purposes, verify that CryptGetOIDFunctionAddress fails
    // to find a pre-installed function
    if (NULL == (hX509EncodeFuncSet = CryptInitOIDFunctionSet(
            CRYPT_OID_ENCODE_OBJECT_FUNC,
            0)))
        goto CryptInitOIDFunctionSetError;
    if (CryptGetOIDFunctionAddress(
            hX509EncodeFuncSet,
            X509_ASN_ENCODING,
            szOID_SET_MERCHANT_DATA,
            CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
            &pvFuncAddr,
            &hFuncAddr
            )) {
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        goto GotUnexpectedPreinstalledFunction;
    }

    // Verify we get our registered address
    if (!CryptGetOIDFunctionAddress(
            hX509EncodeFuncSet,
            X509_ASN_ENCODING,
            szOID_SET_MERCHANT_DATA,
            0,                              // dwFlags
            &pvFuncAddr,
            &hFuncAddr
            ))
        goto DidNotGetRegisteredFunction;
    else
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);


    return SetAsn1Encode(
        SETMerchantData_PDU,
        &OssSETMerchantData,
        pbEncoded,
        pcbEncoded
        );

ErrorReturn:
    *pcbEncoded = 0;
    return FALSE;
TRACE_ERROR(CryptInitOIDFunctionSetError)
SET_ERROR(GotUnexpectedPreinstalledFunction, E_UNEXPECTED)
SET_ERROR(DidNotGetRegisteredFunction, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  SET Merchant Data Private Extension Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1MerchantDataDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSET_MERCHANT_DATA_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SETMerchantData *pSETMerchantData = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!SetAsn1DecodeAndAlloc(
            SETMerchantData_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pSETMerchantData))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SET_MERCHANT_DATA_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Update fields not needing extra memory after the
        // SET_MERCHANT_DATA_INFO
        pInfo->fMerPhoneRelease = pSETMerchantData->merPhoneRelease;
        pInfo->fMerAuthFlag = pSETMerchantData->merAuthFlag;
        pbExtra = (BYTE *) pInfo + sizeof(SET_MERCHANT_DATA_INFO);
    }

    SetX509GetIA5(&pSETMerchantData->merID, dwFlags, &pInfo->pszMerID,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5((IA5STRING *) &pSETMerchantData->merAcquirerBIN, dwFlags,
        &pInfo->pszMerAcquirerBIN, &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merTermID, dwFlags, &pInfo->pszMerTermID,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merName, dwFlags, &pInfo->pszMerName,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merCity, dwFlags, &pInfo->pszMerCity,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merStateProvince, dwFlags,
        &pInfo->pszMerStateProvince, &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merPostalCode, dwFlags,
        &pInfo->pszMerPostalCode, &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merCountry, dwFlags, &pInfo->pszMerCountry,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merPhone, dwFlags, &pInfo->pszMerPhone,
        &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    SetAsn1Free(SETMerchantData_PDU, pSETMerchantData);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\setx509\x509.c ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for SET X509 v3 certificates */

#include <windows.h>
#include "x509.h"

ASN1module_t X509_Module = NULL;

static int ASN1CALL ASN1Enc_SETAccountAlias(ASN1encoding_t enc, ASN1uint32_t tag, SETAccountAlias *val);
static int ASN1CALL ASN1Enc_SETHashedRootKey(ASN1encoding_t enc, ASN1uint32_t tag, SETHashedRootKey *val);
static int ASN1CALL ASN1Enc_SETCertificateType(ASN1encoding_t enc, ASN1uint32_t tag, SETCertificateType *val);
static int ASN1CALL ASN1Enc_SETMerchantData(ASN1encoding_t enc, ASN1uint32_t tag, SETMerchantData *val);
static int ASN1CALL ASN1Dec_SETAccountAlias(ASN1decoding_t dec, ASN1uint32_t tag, SETAccountAlias *val);
static int ASN1CALL ASN1Dec_SETHashedRootKey(ASN1decoding_t dec, ASN1uint32_t tag, SETHashedRootKey *val);
static int ASN1CALL ASN1Dec_SETCertificateType(ASN1decoding_t dec, ASN1uint32_t tag, SETCertificateType *val);
static int ASN1CALL ASN1Dec_SETMerchantData(ASN1decoding_t dec, ASN1uint32_t tag, SETMerchantData *val);
static void ASN1CALL ASN1Free_SETHashedRootKey(SETHashedRootKey *val);
static void ASN1CALL ASN1Free_SETCertificateType(SETCertificateType *val);
static void ASN1CALL ASN1Free_SETMerchantData(SETMerchantData *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[4] = {
    (ASN1EncFun_t) ASN1Enc_SETAccountAlias,
    (ASN1EncFun_t) ASN1Enc_SETHashedRootKey,
    (ASN1EncFun_t) ASN1Enc_SETCertificateType,
    (ASN1EncFun_t) ASN1Enc_SETMerchantData,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[4] = {
    (ASN1DecFun_t) ASN1Dec_SETAccountAlias,
    (ASN1DecFun_t) ASN1Dec_SETHashedRootKey,
    (ASN1DecFun_t) ASN1Dec_SETCertificateType,
    (ASN1DecFun_t) ASN1Dec_SETMerchantData,
};
static const ASN1FreeFun_t freefntab[4] = {
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_SETHashedRootKey,
    (ASN1FreeFun_t) ASN1Free_SETCertificateType,
    (ASN1FreeFun_t) ASN1Free_SETMerchantData,
};
static const ULONG sizetab[4] = {
    SIZE_X509_Module_PDU_0,
    SIZE_X509_Module_PDU_1,
    SIZE_X509_Module_PDU_2,
    SIZE_X509_Module_PDU_3,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL X509_Module_Startup(void)
{
    X509_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 4, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x746573);
}

void ASN1CALL X509_Module_Cleanup(void)
{
    ASN1_CloseModule(X509_Module);
    X509_Module = NULL;
}

static int ASN1CALL ASN1Enc_SETAccountAlias(ASN1encoding_t enc, ASN1uint32_t tag, SETAccountAlias *val)
{
    if (!ASN1BEREncBool(enc, tag ? tag : 0x1, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SETAccountAlias(ASN1decoding_t dec, ASN1uint32_t tag, SETAccountAlias *val)
{
    if (!ASN1BERDecBool(dec, tag ? tag : 0x1, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SETHashedRootKey(ASN1encoding_t enc, ASN1uint32_t tag, SETHashedRootKey *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SETHashedRootKey(ASN1decoding_t dec, ASN1uint32_t tag, SETHashedRootKey *val)
{
    if (!ASN1BERDecOctetString2(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SETHashedRootKey(SETHashedRootKey *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SETCertificateType(ASN1encoding_t enc, ASN1uint32_t tag, SETCertificateType *val)
{
    if (!ASN1DEREncBitString(enc, tag ? tag : 0x3, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SETCertificateType(ASN1decoding_t dec, ASN1uint32_t tag, SETCertificateType *val)
{
    if (!ASN1BERDecBitString2(dec, tag ? tag : 0x3, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SETCertificateType(SETCertificateType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SETMerchantData(ASN1encoding_t enc, ASN1uint32_t tag, SETMerchantData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merID).length, ((val)->merID).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x12, ((val)->merAcquirerBIN).length, ((val)->merAcquirerBIN).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merTermID).length, ((val)->merTermID).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merName).length, ((val)->merName).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merCity).length, ((val)->merCity).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merStateProvince).length, ((val)->merStateProvince).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merPostalCode).length, ((val)->merPostalCode).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merCountry).length, ((val)->merCountry).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merPhone).length, ((val)->merPhone).value))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->merPhoneRelease))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->merAuthFlag))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SETMerchantData(ASN1decoding_t dec, ASN1uint32_t tag, SETMerchantData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merID))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x12, &(val)->merAcquirerBIN))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merTermID))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merName))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merCity))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merStateProvince))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merPostalCode))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merCountry))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merPhone))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->merPhoneRelease))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->merAuthFlag))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SETMerchantData(SETMerchantData *val)
{
    if (val) {
	ASN1charstring_free(&(val)->merID);
	ASN1charstring_free(&(val)->merAcquirerBIN);
	ASN1charstring_free(&(val)->merTermID);
	ASN1charstring_free(&(val)->merName);
	ASN1charstring_free(&(val)->merCity);
	ASN1charstring_free(&(val)->merStateProvince);
	ASN1charstring_free(&(val)->merPostalCode);
	ASN1charstring_free(&(val)->merCountry);
	ASN1charstring_free(&(val)->merPhone);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\setx509\x509.h ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for SET X509 v3 certificates */

#ifndef _X509_Module_H_
#define _X509_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1bool_t SETAccountAlias;
#define SETAccountAlias_PDU 0
#define SIZE_X509_Module_PDU_0 sizeof(SETAccountAlias)

typedef OCTETSTRING SETHashedRootKey;
#define SETHashedRootKey_PDU 1
#define SIZE_X509_Module_PDU_1 sizeof(SETHashedRootKey)

typedef BITSTRING SETCertificateType;
#define SETCertificateType_PDU 2
#define SIZE_X509_Module_PDU_2 sizeof(SETCertificateType)

typedef struct SETMerchantData {
    IA5STRING merID;
    NUMERICSTRING merAcquirerBIN;
    IA5STRING merTermID;
    IA5STRING merName;
    IA5STRING merCity;
    IA5STRING merStateProvince;
    IA5STRING merPostalCode;
    IA5STRING merCountry;
    IA5STRING merPhone;
    ASN1bool_t merPhoneRelease;
    ASN1bool_t merAuthFlag;
} SETMerchantData;
#define SETMerchantData_PDU 3
#define SIZE_X509_Module_PDU_3 sizeof(SETMerchantData)


extern ASN1module_t X509_Module;
extern void ASN1CALL X509_Module_Startup(void);
extern void ASN1CALL X509_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _X509_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\siphelp\sipadd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipadd.cpp
//
//  Contents:   Microsoft Internet Security SIP Provider
//
//  Functions:  CryptSIPAddProvider
//
//              *** local functions ***
//              _RegisterSIPFunc
//
//  History:    04-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cryptreg.h"
#include    "wintrust.h"
#include    "sipbase.h"

BOOL _RegisterSIPFunc(char *pszTag, char *pszGuid, WCHAR *pwszDll, WCHAR *pwszFunc);

BOOL WINAPI CryptSIPAddProvider(IN SIP_ADD_NEWPROVIDER *psNewProv)
{
    BOOL    fRet;
    char    szGuid[REG_MAX_GUID_TEXT];

    fRet = TRUE;

    if (!(psNewProv) ||
        !(WVT_ISINSTRUCT(SIP_ADD_NEWPROVIDER, psNewProv->cbStruct, pwszRemoveFuncName)) ||
        !(psNewProv->pwszDLLFileName) ||
        !(psNewProv->pwszGetFuncName) ||
        !(psNewProv->pwszPutFuncName) ||
        !(psNewProv->pwszCreateFuncName) ||
        !(psNewProv->pwszVerifyFuncName) ||
        !(psNewProv->pwszRemoveFuncName))
    {
        goto InvalidParam;
    }

    if (!(_Guid2Sz(psNewProv->pgSubject, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_PUTSIGNATURE, &szGuid[0], 
                           psNewProv->pwszDLLFileName, psNewProv->pwszPutFuncName)))
    {
        goto RegisterPutFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_GETSIGNATURE, &szGuid[0],
                           psNewProv->pwszDLLFileName, psNewProv->pwszGetFuncName)))
    {
        goto RegisterGetFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_REMSIGNATURE, &szGuid[0],
                           psNewProv->pwszDLLFileName, psNewProv->pwszRemoveFuncName)))
    {
        goto RegisterRemoveFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_CREATEINDIRECT, &szGuid[0],
                           psNewProv->pwszDLLFileName, psNewProv->pwszCreateFuncName)))
    {
        goto RegisterCreateFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_VERIFYINDIRECT, &szGuid[0],
                           psNewProv->pwszDLLFileName, psNewProv->pwszVerifyFuncName)))
    {
        goto RegisterVerifyFailed;
    }

    if (psNewProv->pwszIsFunctionName)
    {
        if (!(_RegisterSIPFunc(SIPFUNC_ISMYTYPE, &szGuid[0],
                            psNewProv->pwszDLLFileName, psNewProv->pwszIsFunctionName)))
        {
            goto RegisterIsMyTypeFailed;
        }
    }

    if ((WVT_ISINSTRUCT(SIP_ADD_NEWPROVIDER, psNewProv->cbStruct, pwszIsFunctionNameFmt2)) &&
        (psNewProv->pwszIsFunctionNameFmt2))
    {
        if (!(_RegisterSIPFunc(SIPFUNC_ISMYTYPE2, &szGuid[0],
                            psNewProv->pwszDLLFileName, psNewProv->pwszIsFunctionNameFmt2)))
        {
            goto RegisterIsMyType2Failed;
        }
    }
    

    fRet = TRUE;

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, RegisterPutFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterGetFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterRemoveFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterCreateFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterVerifyFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterIsMyTypeFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterIsMyType2Failed);
    TRACE_ERROR_EX(DBG_SS, GuidConvertFailed);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL WINAPI CryptSIPRemoveProvider(GUID *pgProv)
{
    BOOL    fRet;
    char    szGuid[REG_MAX_GUID_TEXT];

    if (!(pgProv))
    {
        goto InvalidParam;
    }

    if (!(_Guid2Sz(pgProv, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    fRet = TRUE;

    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_PUTSIGNATURE, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_GETSIGNATURE, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_REMSIGNATURE, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_CREATEINDIRECT, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_VERIFYINDIRECT, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_ISMYTYPE, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_ISMYTYPE2, &szGuid[0]);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, GuidConvertFailed);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL _RegisterSIPFunc(char *pszTag, char *pszGuid, WCHAR *pwszDll, WCHAR *pwszFunc)
{
    char    szFunc[REG_MAX_FUNC_NAME];

    WideCharToMultiByte(0, 0, pwszFunc, -1, &szFunc[0], REG_MAX_FUNC_NAME, NULL, NULL);

    return(CryptRegisterOIDFunction(0, pszTag, pszGuid, pwszDll, &szFunc[0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\siphelp\sipload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipload.cpp
//
//  Contents:   Microsoft Internet Security SIP Provider
//
//  Functions:  CryptLoadSip
//              CryptUnloadSips
//
//  History:    04-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

// backwords compatibility w/tools!
extern "C"
BOOL WINAPI CryptLoadSip(const GUID *pgSubject, DWORD dwFlags, SIP_DISPATCH_INFO *psSipTable)
{
    return(CryptSIPLoad(pgSubject, dwFlags, psSipTable));
}

BOOL WINAPI CryptSIPLoad(const GUID *pgSubject, DWORD dwFlags, SIP_DISPATCH_INFO *psSipTable)
{
    if (!(pgSubject) ||
        (dwFlags != 0) ||
        !(psSipTable))
    {
        SetLastError((DWORD) ERROR_INVALID_PARAMETER);
        return(FALSE);
    }


    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPPutSignedDataMsg   pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz((GUID *)pgSubject, &szGuid[0])))
    {
        SetLastError((DWORD) TRUST_E_SUBJECT_FORM_UNKNOWN);
        return(FALSE);
    }

    if (!(CryptGetOIDFunctionAddress(hPutFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        SetLastError((DWORD) TRUST_E_SUBJECT_FORM_UNKNOWN);
        return(FALSE);
    }

    CryptFreeOIDFunctionAddress(hPfn, 0);

    psSipTable->hSIP                = NULL;
    psSipTable->pfGet               = CryptSIPGetSignedDataMsg;
    psSipTable->pfPut               = CryptSIPPutSignedDataMsg;
    psSipTable->pfCreate            = CryptSIPCreateIndirectData;
    psSipTable->pfVerify            = CryptSIPVerifyIndirectData;
    psSipTable->pfRemove            = CryptSIPRemoveSignedDataMsg;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\sp3crmsg\sp3crmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sp3crmsg.cpp
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  File:       sp3crmsg.cpp
//
//  Contents:   Installable OID functions providing backwards compatiblity
//              with the way the NT4.0 SP3 and IE 3.02 versions of crypt32.dll
//              encrypted the symmetric key in a PKCS #7 EnvelopedData message.
//
//              The SP3 version of crypt32.dll failed to byte reverse the
//              encrypted symmetric key. It also added zero salt instead
//              of no salt.
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              SP3ImportEncryptKey
//              SP3GenEncryptKey
//              SP3ExportEncryptKey
#ifdef CMS_PKCS7
//              DllInstall
//              CryptMsgDllGenContentEncryptKey
//              CryptMsgDllExportKeyTrans
//              CryptMsgDllImportKeyTrans
//              NotImplCryptMsgDllImportKeyTrans
#endif  // CMS_PKCS7
//--------------------------------------------------------------------------

#define CMS_PKCS7       1
#include <windows.h>
#include <wincrypt.h>

#include "sp3crmsg.h"

// memory management
#define SP3Alloc(cb)                ((void*)LocalAlloc(LPTR, cb))
#define SP3Free(pv)                 (LocalFree((HLOCAL)pv))

// The Thread Local Storage (TLS) referenced by iSP3TLS has pointer of
// ((void *) 0x1) if SP3 compatible encryption is enabled. Otherwise, its 0.
static DWORD iSP3TLS = 0xFFFFFFFF;
#define SP3_TLS_POINTER             ((void *) 0x1)

typedef struct _SIMPLEBLOBHEADER {
    ALG_ID  aiEncAlg;
} SIMPLEBLOBHEADER, *PSIMPLEBLOBHEADER;

typedef struct _OID_REG_ENTRY {
    LPCSTR   pszOID;
    LPCSTR   pszOverrideFuncName;
} OID_REG_ENTRY, *POID_REG_ENTRY;

//+-------------------------------------------------------------------------
//  ImportEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
static HCRYPTOIDFUNCSET hImportEncryptKeyFuncSet;
static PFN_CMSG_IMPORT_ENCRYPT_KEY pfnDefaultImportEncryptKey = NULL;

BOOL
WINAPI
SP3ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey);

static const CRYPT_OID_FUNC_ENTRY ImportEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, SP3ImportEncryptKey,
    szOID_RSA_RC2CBC, SP3ImportEncryptKey,
    szOID_RSA_RC4, SP3ImportEncryptKey
};
#define IMPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ImportEncryptKeyFuncTable) / \
                                        sizeof(ImportEncryptKeyFuncTable[0]))

static const OID_REG_ENTRY ImportEncryptKeyRegTable[] = {
    szOID_OIWSEC_desCBC, "SP3ImportEncryptKey",
    szOID_RSA_RC2CBC, "SP3ImportEncryptKey",
    szOID_RSA_RC4, "SP3ImportEncryptKey"
};
#define IMPORT_ENCRYPT_KEY_REG_COUNT (sizeof(ImportEncryptKeyRegTable) / \
                                        sizeof(ImportEncryptKeyRegTable[0]))

//+-------------------------------------------------------------------------
//  GenEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
static HCRYPTOIDFUNCSET hGenEncryptKeyFuncSet;
static PFN_CMSG_GEN_ENCRYPT_KEY pfnDefaultGenEncryptKey = NULL;

BOOL
WINAPI
SP3GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT PDWORD                      pcbEncryptParameters);

static const CRYPT_OID_FUNC_ENTRY GenEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, SP3GenEncryptKey,
    szOID_RSA_RC2CBC, SP3GenEncryptKey,
    szOID_RSA_RC4, SP3GenEncryptKey
};
#define GEN_ENCRYPT_KEY_FUNC_COUNT (sizeof(GenEncryptKeyFuncTable) / \
                                        sizeof(GenEncryptKeyFuncTable[0]))

static const OID_REG_ENTRY GenEncryptKeyRegTable[] = {
    szOID_OIWSEC_desCBC, "SP3GenEncryptKey",
    szOID_RSA_RC2CBC, "SP3GenEncryptKey",
    szOID_RSA_RC4, "SP3GenEncryptKey"
};
#define GEN_ENCRYPT_KEY_REG_COUNT (sizeof(GenEncryptKeyRegTable) / \
                                        sizeof(GenEncryptKeyRegTable[0]))

//+-------------------------------------------------------------------------
//  ExportEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
static HCRYPTOIDFUNCSET hExportEncryptKeyFuncSet;
static PFN_CMSG_EXPORT_ENCRYPT_KEY pfnDefaultExportEncryptKey = NULL;

BOOL
WINAPI
SP3ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT PDWORD                   pcbData);

static const CRYPT_OID_FUNC_ENTRY ExportEncryptKeyFuncTable[] = {
    szOID_RSA_RSA, SP3ExportEncryptKey
};
#define EXPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ExportEncryptKeyFuncTable) / \
                                        sizeof(ExportEncryptKeyFuncTable[0]))

static const OID_REG_ENTRY ExportEncryptKeyRegTable[] = {
    szOID_RSA_RSA, "SP3ExportEncryptKey"
};
#define EXPORT_ENCRYPT_KEY_REG_COUNT (sizeof(ExportEncryptKeyRegTable) / \
                                        sizeof(ExportEncryptKeyRegTable[0]))

static char szCrypt32[]="crypt32.dll";

// First post IE4.0 versions of crypt32.dll start with "5.101.1681.1"
static DWORD dwLowVersion    = (1681 << 16) | 1;
static DWORD dwHighVersion   = (5 << 16) | 101; 

static BOOL IsPostIE4Crypt32()
{
    BOOL fPostIE4 = FALSE;   // default to IE4
    DWORD dwHandle = 0;
    DWORD cbInfo;
    void *pvInfo = NULL;
	VS_FIXEDFILEINFO *pFixedFileInfo = NULL;   // not allocated
	UINT ccFixedFileInfo = 0;

    if (0 == (cbInfo = GetFileVersionInfoSizeA(szCrypt32, &dwHandle)))
        goto ErrorReturn;

    if (NULL == (pvInfo = SP3Alloc(cbInfo)))
        goto ErrorReturn;

    if (!GetFileVersionInfoA(
            szCrypt32,
            0,          // dwHandle, ignored
            cbInfo,
            pvInfo
            ))
        goto ErrorReturn;

    if (!VerQueryValueA(
            pvInfo,
            "\\",       // VS_FIXEDFILEINFO
            (void **) &pFixedFileInfo,
            &ccFixedFileInfo
            ))
        goto ErrorReturn;

    if (pFixedFileInfo->dwFileVersionMS > dwHighVersion ||
            (pFixedFileInfo->dwFileVersionMS == dwHighVersion &&
                pFixedFileInfo->dwFileVersionLS >= dwLowVersion))
        fPostIE4 = TRUE;

CommonReturn:
    if (pvInfo)
        SP3Free(pvInfo);
    return fPostIE4;
ErrorReturn:
    goto CommonReturn;
}

static HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}


STDAPI DllRegisterServer(void)
{
    int i;

    DWORD dwFlags = CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG;
    for (i = 0; i < IMPORT_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                ImportEncryptKeyRegTable[i].pszOID,
                L"sp3crmsg.dll",
                ImportEncryptKeyRegTable[i].pszOverrideFuncName
                ))
            return HError();

        if (!CryptSetOIDFunctionValue(
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                ImportEncryptKeyRegTable[i].pszOID,
                CRYPT_OID_REG_FLAGS_VALUE_NAME,
                REG_DWORD,
                (BYTE *) &dwFlags,
                sizeof(dwFlags)
                ))
            return HError();
    }

    for (i = 0; i < GEN_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GenEncryptKeyRegTable[i].pszOID,
                L"sp3crmsg.dll",
                GenEncryptKeyRegTable[i].pszOverrideFuncName
                ))
            return HError();

        if (!CryptSetOIDFunctionValue(
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GenEncryptKeyRegTable[i].pszOID,
                CRYPT_OID_REG_FLAGS_VALUE_NAME,
                REG_DWORD,
                (BYTE *) &dwFlags,
                sizeof(dwFlags)
                ))
            return HError();
    }

    for (i = 0; i < EXPORT_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                ExportEncryptKeyRegTable[i].pszOID,
                L"sp3crmsg.dll",
                ExportEncryptKeyRegTable[i].pszOverrideFuncName
                ))
            return HError();

        if (!CryptSetOIDFunctionValue(
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                ExportEncryptKeyRegTable[i].pszOID,
                CRYPT_OID_REG_FLAGS_VALUE_NAME,
                REG_DWORD,
                (BYTE *) &dwFlags,
                sizeof(dwFlags)
                ))
            return HError();
    }
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;
    int i;

    for (i = 0; i < IMPORT_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                ImportEncryptKeyRegTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < GEN_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GenEncryptKeyRegTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < EXPORT_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                ExportEncryptKeyRegTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

#ifdef CMS_PKCS7
    if (!CryptUnregisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
            szOID_RSA_RC2CBC
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

    if (!CryptUnregisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_EXPORT_KEY_TRANS_FUNC,
            szOID_RSA_RSA
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

    if (!CryptUnregisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_IMPORT_KEY_TRANS_FUNC,
            szOID_RSA_RSA "!" szOID_RSA_RC2CBC
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

    if (!CryptUnregisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_IMPORT_KEY_TRANS_FUNC,
            szOID_RSA_RC2CBC
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

#endif  // CMS_PKCS7

    return hr;
}

#ifdef CMS_PKCS7
//+---------------------------------------------------------------------------
//
//  Function:   DllInstall
//
//  Synopsis:   dll installation entry point
//
//----------------------------------------------------------------------------
STDAPI DllInstall (BOOL fRegister, LPCSTR pszCommand)
{
    if (!fRegister)
        return DllUnregisterServer();

    if (!CryptRegisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
            szOID_RSA_RC2CBC,
            L"sp3crmsg.dll",
            NULL                                    // pszOverrideFuncName
            ))
        return HError();

    if (!CryptRegisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_EXPORT_KEY_TRANS_FUNC,
            szOID_RSA_RSA,
            L"sp3crmsg.dll",
            NULL                                    // pszOverrideFuncName
            ))
        return HError();

    if (!CryptRegisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_IMPORT_KEY_TRANS_FUNC,
            szOID_RSA_RSA "!" szOID_RSA_RC2CBC,
            L"sp3crmsg.dll",
            "NotImplCryptMsgDllImportKeyTrans"
            ))
        return HError();

    if (!CryptRegisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_IMPORT_KEY_TRANS_FUNC,
            szOID_RSA_RC2CBC,
            L"sp3crmsg.dll",
            NULL                                    // pszOverrideFuncName
            ))
        return HError();

    return S_OK;
}
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Function:  DllMain
//
//  Synopsis:  Process/Thread attach/detach
//
//             At process attach install the SP3 compatible version of
//             CryptMsgDllImportEncryptKey, CryptMsgDllGenEncryptKey and
//             CryptMsgDllExportEncryptKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fResult;
    HCRYPTOIDFUNCADDR hFuncAddr;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
#if 0
        // Post IE 4.0 releases of crypt32.dll already have the SP3
        // backwards compatible fix.
        if (IsPostIE4Crypt32())
            return TRUE;
#endif

        if (NULL == (hImportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto ErrorReturn;
        if (NULL == (hGenEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                0)))
            goto ErrorReturn;
        if (NULL == (hExportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto ErrorReturn;

        // Get the default import encrypt key function which we will call if
        // unable to do a successful import without byte reversing the
        // encrypted symmetric key.
        if (CryptGetOIDFunctionAddress(
                hImportEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                szOID_RSA_RC2CBC,
                CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
                (void **) &pfnDefaultImportEncryptKey,
                &hFuncAddr))
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);

#if 0
        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                IMPORT_ENCRYPT_KEY_FUNC_COUNT,
                ImportEncryptKeyFuncTable,
                CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG      // dwFlags
                ))
            goto ErrorReturn;
#endif

        // Get the default gen and export encrypt key functions which we will
        // call if pvEncryptionAuxInfo points to a
        // CMSG_SP3_COMPATIBLE_AUX_INFO data structure.
        if (CryptGetOIDFunctionAddress(
                hGenEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                szOID_RSA_RC2CBC,
                CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
                (void **) &pfnDefaultGenEncryptKey,
                &hFuncAddr))
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        if (CryptGetOIDFunctionAddress(
                hExportEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                szOID_RSA_RSA,
                CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
                (void **) &pfnDefaultExportEncryptKey,
                &hFuncAddr))
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);

#if 0
        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GEN_ENCRYPT_KEY_FUNC_COUNT,
                GenEncryptKeyFuncTable,
                CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG      // dwFlags
                ))
            goto ErrorReturn;
        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                EXPORT_ENCRYPT_KEY_FUNC_COUNT,
                ExportEncryptKeyFuncTable,
                CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG      // dwFlags
                ))
            goto ErrorReturn;
#endif

        // Allocate TLS which contains a pointer of ((void *) 0x1) for SP3
        // compatible encryption. This pointer will be passed from
        // SP3GenEncryptKey() to SP3ExportEncryptKey().
        //
        // If not SP3 encryption, the pointer is NULL.
        if ((iSP3TLS = TlsAlloc()) == 0xFFFFFFFF)
            goto ErrorReturn;
        break;

    case DLL_PROCESS_DETACH:
        if (iSP3TLS != 0xFFFFFFFF) {
            TlsFree(iSP3TLS);
            iSP3TLS = 0xFFFFFFFF;
        }
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  SP3 import of the encryption key.
//
//  The SP3 version of crypt32.dll didn't include any parameters for the
//  encryption algorithm. Later versions of crypt32.dll do. Therefore, we only
//  need to attempt to import the key without byte reversal if there aren't
//  any parameters present.
//--------------------------------------------------------------------------
BOOL
WINAPI
SP3ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey
    )
{
    BOOL                    fResult;
    HCRYPTKEY               hEncryptKey = 0;
    HCRYPTKEY               hUserKey = 0;
    DWORD                   dwAlgIdEncrypt;
    DWORD                   dwAlgIdPubKey;
    PBYTE                   pbCspKey = NULL;
    DWORD                   cbCspKey;
    PUBLICKEYSTRUC          *ppks;
    PSIMPLEBLOBHEADER       psbh;
    PCCRYPT_OID_INFO        pOIDInfo;

    // Check if more than just the NULL parameters
    if (2 < paiEncrypt->Parameters.cbData) {
        fResult = FALSE;
        goto DefaultImport;
    }

    // Map the ASN algorithm identifier to the CSP ALG_ID.
    if (NULL == (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiEncrypt->pszObjId,
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID)))
        goto GetEncryptAlgidError;
    dwAlgIdEncrypt = pOIDInfo->Algid;

    // Create the CSP encrypted symmetric key structure WITHOUT BYTE REVERSAL.
    dwAlgIdPubKey = CALG_RSA_KEYX;
    cbCspKey = cbEncodedKey + sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);
    if (NULL == (pbCspKey = (PBYTE)SP3Alloc( cbCspKey)))
        goto OutOfMemory;
    ppks = (PUBLICKEYSTRUC *)pbCspKey;
    ppks->bType = SIMPLEBLOB;
    ppks->bVersion = CUR_BLOB_VERSION;
    ppks->reserved = 0;
    ppks->aiKeyAlg = dwAlgIdEncrypt;
    psbh = (PSIMPLEBLOBHEADER)(ppks + 1);
    psbh->aiEncAlg = dwAlgIdPubKey;
    // NO BYTE REVERSAL as done in SP3.
    memcpy( (PBYTE)(psbh+1), pbEncodedKey, cbEncodedKey);

    if (0 != dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }

    // Try importing as an NT4.0 SP3 encypted key that wasn't byte
    // reversed and with zero salt.
    fResult = CryptImportKey(
        hCryptProv,
        pbCspKey,
        cbCspKey,
        hUserKey,
        0,          // dwFlags
        &hEncryptKey);
    if (!fResult && hUserKey) {
        // Try without using the specified user key.
        fResult = CryptImportKey(
            hCryptProv,
            pbCspKey,
            cbCspKey,
            0,          // hUserKey
            0,          // dwFlags
            &hEncryptKey);
    }

    if (!fResult)
        goto ImportKeyFailed;

    fResult = TRUE;
CommonReturn:
    if (pbCspKey)
        SP3Free(pbCspKey);
    if (hUserKey) {
        DWORD dwError = GetLastError();
        CryptDestroyKey(hUserKey);
        SetLastError(dwError);
    }

DefaultImport:
    if (!fResult && pfnDefaultImportEncryptKey)
        // Try importing using the default
        return pfnDefaultImportEncryptKey(
            hCryptProv,
            dwKeySpec,
            paiEncrypt,
            paiPubKey,
            pbEncodedKey,
            cbEncodedKey,
            phEncryptKey);
    else {
        *phEncryptKey = hEncryptKey;
        return fResult;
    }


GetEncryptAlgidError:
OutOfMemory:
GetUserKeyFailed:
ImportKeyFailed:
    hEncryptKey = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  SP3 generation of the encryption key.
//
//  The SP3 version of crypt32.dll didn't include the IV octet string for the
//  encryption algorithm. Also, the encryption key had zero salt instead
//  of no salt.
//
//  For SP3 compatible generation, the caller must pass in a non-NULL
//  hCryptProv and set pvEncryptAuxInfo to point to a
//  CMSG_SP3_COMPATIBLE_AUX_INFO data structure with the
//  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG set.
//--------------------------------------------------------------------------
BOOL
WINAPI
SP3GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT PDWORD                      pcbEncryptParameters
    )
{
    HCRYPTPROV hCryptProv;
    PCMSG_SP3_COMPATIBLE_AUX_INFO pSP3AuxInfo =
        (PCMSG_SP3_COMPATIBLE_AUX_INFO) pvEncryptAuxInfo;
    PCCRYPT_OID_INFO pOIDInfo;
    DWORD dwAlgIdEncrypt;

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv || NULL == pSP3AuxInfo ||
            sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO) > pSP3AuxInfo->cbSize ||
            0 == (pSP3AuxInfo->dwFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)) {

        // Let SP3ExportEncryptKey() know this will be a default export
        TlsSetValue(iSP3TLS, NULL);

        if (pfnDefaultGenEncryptKey)
            // Generate using the default
            return pfnDefaultGenEncryptKey(
                phCryptProv,
                paiEncrypt,
                pvEncryptAuxInfo,
                pPublicKeyInfo,
                pfnAlloc,
                phEncryptKey,
                ppbEncryptParameters,
                pcbEncryptParameters
                );
        else {
            // We don't have a default
            *phEncryptKey = 0;
            SetLastError((DWORD) E_UNEXPECTED);
            return FALSE;
        }
    }

    // Let SP3ExportEncryptKey() know this will be a SP3 compatible export.
    TlsSetValue(iSP3TLS, SP3_TLS_POINTER);

    // Map the ASN algorithm identifier to the CSP ALG_ID.
    if (NULL == (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiEncrypt->pszObjId,
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID))) {
        *phEncryptKey = 0;
        return FALSE;
    }
    dwAlgIdEncrypt = pOIDInfo->Algid;

    // Since CRYPT_NO_SALT flag isn't set, uses zero salt
    if (!CryptGenKey(
            hCryptProv,
            dwAlgIdEncrypt,
            CRYPT_EXPORTABLE,
            phEncryptKey)) {
        *phEncryptKey = 0;    
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  SP3 export of the encryption key.
//
//  The SP3 version of crypt32.dll encoded the encrypted symmetric key as
//  little endian instead of as big endian.
//--------------------------------------------------------------------------
BOOL
WINAPI
SP3ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT PDWORD                   pcbData
    )
{
    BOOL            fResult;
    DWORD           dwError = ERROR_SUCCESS;
    HCRYPTKEY       hPubKey = NULL;
    PBYTE           pb = NULL;
    DWORD           cb;

    if (SP3_TLS_POINTER != TlsGetValue(iSP3TLS)) {
        if (pfnDefaultExportEncryptKey)
            // Export using the default function
            return pfnDefaultExportEncryptKey(
                hCryptProv,
                hEncryptKey,
                pPublicKeyInfo,
                pbData,
                pcbData
                );
        else {
            // We don't have a default
            *pcbData = 0;
            SetLastError((DWORD) E_UNEXPECTED);
            return FALSE;
        }
    }

    // SP3 compatible export and encode


    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPublicKeyInfo,
            &hPubKey))
        goto ImportKeyError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            NULL,
            &cb))
        goto ExportKeySizeError;
    if (NULL == (pb = (PBYTE) SP3Alloc(cb)))
        goto ExportKeyAllocError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            pb,
            &cb))
        goto ExportKeyError;
    cb -= sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);

    fResult = TRUE;
    if (pbData) {
        if (*pcbData < cb) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else if (0 < cb) {
            // Don't byte reverse
            memcpy(pbData,
                 pb + (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)), cb);
        }
    }

CommonReturn:
    *pcbData = cb;
    if (pb)
        SP3Free(pb);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    SetLastError(dwError);
    return fResult;

ImportKeyError:
ExportKeySizeError:
ExportKeyAllocError:
ExportKeyError:
    dwError = GetLastError();
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}

#ifdef CMS_PKCS7

BOOL
WINAPI
CryptMsgDllGenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCSET hGenContentFuncSet;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY pfnDefaultGenContent;

    if (NULL == (hGenContentFuncSet = CryptInitOIDFunctionSet(
            CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC, 0)))
        return FALSE;

    // Get the default gen content encrypt key function which we will call
    if (!CryptGetOIDFunctionAddress(
            hGenContentFuncSet,
            X509_ASN_ENCODING,
            CMSG_DEFAULT_INSTALLABLE_FUNC_OID,
            CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
            (void **) &pfnDefaultGenContent,
            &hFuncAddr))
        return FALSE;

    fResult = pfnDefaultGenContent(
        pContentEncryptInfo,
        dwFlags,
        pvReserved
        );

    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fResult;
}

BOOL
WINAPI
CryptMsgDllExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCSET hExportKeyTransFuncSet;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PFN_CMSG_EXPORT_KEY_TRANS pfnDefaultExportKeyTrans;

    if (NULL == (hExportKeyTransFuncSet = CryptInitOIDFunctionSet(
            CMSG_OID_EXPORT_KEY_TRANS_FUNC, 0)))
        return FALSE;

    // Get the default export key trans function which we will call
    if (!CryptGetOIDFunctionAddress(
            hExportKeyTransFuncSet,
            X509_ASN_ENCODING,
            CMSG_DEFAULT_INSTALLABLE_FUNC_OID,
            CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
            (void **) &pfnDefaultExportKeyTrans,
            &hFuncAddr))
        return FALSE;

    fResult = pfnDefaultExportKeyTrans(
        pContentEncryptInfo,
        pKeyTransEncodeInfo,
        pKeyTransEncryptInfo,
        dwFlags,
        pvReserved
        );

    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fResult;
}

BOOL
WINAPI
CryptMsgDllImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCSET hImportKeyTransFuncSet;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PFN_CMSG_IMPORT_KEY_TRANS pfnDefaultImportKeyTrans;

    if (NULL == (hImportKeyTransFuncSet = CryptInitOIDFunctionSet(
            CMSG_OID_IMPORT_KEY_TRANS_FUNC, 0)))
        return FALSE;

    // Get the default import key trans function which we will call
    if (!CryptGetOIDFunctionAddress(
            hImportKeyTransFuncSet,
            X509_ASN_ENCODING,
            CMSG_DEFAULT_INSTALLABLE_FUNC_OID,
            CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
            (void **) &pfnDefaultImportKeyTrans,
            &hFuncAddr))
        return FALSE;

    fResult = pfnDefaultImportKeyTrans(
        pContentEncryptionAlgorithm,
        pKeyTransDecryptPara,
        dwFlags,
        pvReserved,
        phContentEncryptKey
        );

    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fResult;
}

BOOL
WINAPI
NotImplCryptMsgDllImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    SetLastError((DWORD) E_NOTIMPL);
    return FALSE;
}

#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\siphelp\sipguid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipguid.cpp
//
//  Contents:   Microsoft Internet Security SIP Provider
//
//  Functions:  CryptSIPRetrieveSubjectGuid
//
//              *** local functions ***
//              _DetermineWhichPE
//              _QueryLoadedIsMyFileType
//              _QueryRegisteredIsMyFileType
//
//  History:    03-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cryptreg.h"
#include    "sipbase.h"
#include    "mssip.h"
#include    "mscat.h"
#include    "sipguids.h"    // located in pki-mssip32

BOOL     _FindGuidFromMagicNumber(BYTE *pszMN, GUID *pgRet);
BOOL    _DetermineWhichPE(BYTE *pbFile, DWORD cbFile, GUID *pgRet);

static inline DWORD FourBToDWORD(BYTE rgb[])
{
    return  ((DWORD)rgb[0]<<24) |
            ((DWORD)rgb[1]<<16) |
            ((DWORD)rgb[2]<<8)  |
            ((DWORD)rgb[3]<<0);
}

static inline void DWORDToFourB(DWORD dwIn, BYTE *pszOut)
{
    pszOut[0] = (BYTE)((dwIn >> 24) & 0x000000FF);
    pszOut[1] = (BYTE)((dwIn >> 16) & 0x000000FF);
    pszOut[2] = (BYTE)((dwIn >>  8) & 0x000000FF);
    pszOut[3] = (BYTE)( dwIn        & 0x000000FF);
}


#define PE_EXE_HEADER_TAG       "MZ"
#define CAB_MAGIC_NUMBER        "MSCF"

BOOL WINAPI CryptSIPRetrieveSubjectGuid(IN LPCWSTR FileName, IN OPTIONAL HANDLE hFileIn, OUT GUID *pgSubject)
{
    BYTE    *pbFile;
    DWORD   cbFile;
    DWORD   dwCheck;
    HANDLE  hMappedFile;
    BOOL    bCloseFile;
    BOOL    fRet;
	DWORD			dwException=0;
    PCCTL_CONTEXT   pCTLContext=NULL;

    bCloseFile  = FALSE;
    pbFile      = NULL;
    fRet        = TRUE;

    if (!(pgSubject))
    {
        goto InvalidParameter;
    }

    memset(pgSubject, 0x00, sizeof(GUID));

    if ((hFileIn == NULL) || (hFileIn == INVALID_HANDLE_VALUE))
    {
        if (!(FileName))
        {
            goto InvalidParameter;
        }

        if ((hFileIn = CreateFileU(FileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                   NULL)) == INVALID_HANDLE_VALUE)
        {
            goto FileOpenError;
        }

        bCloseFile = TRUE;
    }

    hMappedFile = CreateFileMapping(hFileIn, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        goto FileMapError;
    }

    pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0);

    CloseHandle(hMappedFile);

    cbFile = GetFileSize(hFileIn, NULL);


    if (cbFile < SIP_MAX_MAGIC_NUMBER)
    {
        goto FileSizeError;
    }

    //we need to check for the pbFile
    if(NULL == pbFile)
        goto FileMapError;

	//we need to handle the exception when we access the mapped file
	__try {

    //
    //  PE
    //
    if (memcmp(&pbFile[0], PE_EXE_HEADER_TAG, strlen(PE_EXE_HEADER_TAG)) == 0)
    {
        //
        //  if it is an Exe, Dll, Ocx, etc. make sure it is a 32 bit PE and set the
        //  "internal" magic number.
        //
        if (_DetermineWhichPE(pbFile, cbFile, pgSubject))
        {
            goto CommonReturn;
        }
    }

    //
    //  CAB
    //
    if (memcmp(&pbFile[0], CAB_MAGIC_NUMBER, strlen(CAB_MAGIC_NUMBER)) == 0)
    {
        GUID    gCAB    = CRYPT_SUBJTYPE_CABINET_IMAGE;

        memcpy(pgSubject, &gCAB, sizeof(GUID));

        goto CommonReturn;
    }

    //
    //  JAVA Class
    //
    dwCheck = FourBToDWORD(&pbFile[0]);

    if (dwCheck == 0xCAFEBABE)
    {
        GUID    gJClass = CRYPT_SUBJTYPE_JAVACLASS_IMAGE;

        memcpy(pgSubject, &gJClass, sizeof(GUID));

        goto CommonReturn;
    }


    //
    //  Catalog/CTL
    //
    if (pbFile[0] == 0x30)   // could be a PKCS#7!
    {
        //
        //  we could be a PKCS7....  check for CTL
        //

        pCTLContext = (PCCTL_CONTEXT) CertCreateContext(
            CERT_STORE_CTL_CONTEXT,
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            pbFile,
            cbFile,
            CERT_CREATE_CONTEXT_NOCOPY_FLAG |
                CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG |
                CERT_CREATE_CONTEXT_NO_ENTRY_FLAG,
            NULL                                        // pCreatePara
            );

        if (pCTLContext)
        {
            if (pCTLContext->pCtlInfo->SubjectUsage.cUsageIdentifier)
            {
                char *pszCatalogListUsageOID = szOID_CATALOG_LIST;

                if (strcmp(pCTLContext->pCtlInfo->SubjectUsage.rgpszUsageIdentifier[0],
                            pszCatalogListUsageOID) == 0)
                {
                    GUID    gCat = CRYPT_SUBJTYPE_CATALOG_IMAGE;

                    memcpy(pgSubject, &gCat, sizeof(GUID));

                    CertFreeCTLContext(pCTLContext);
					pCTLContext=NULL;

                    goto CommonReturn;
                }
            }

            //
            //  otherwise, it is a CTL of some other type...
            //
            GUID    gCTL = CRYPT_SUBJTYPE_CTL_IMAGE;

            memcpy(pgSubject, &gCTL, sizeof(GUID));

            CertFreeCTLContext(pCTLContext);
            pCTLContext=NULL;

            goto CommonReturn;
        }
    }


    //we need to unmap the file
    if(pbFile)
    {
        UnmapViewOfFile(pbFile);
        pbFile=NULL;
    }
	
	//
    //  none that we know about...  Check the providers...
    //
    if (_QueryRegisteredIsMyFileType(hFileIn, FileName, pgSubject))
    {
        goto CommonReturn;
    }

	} __except(EXCEPTION_EXECUTE_HANDLER) {
			dwException = GetExceptionCode();
            goto ExceptionError;
	}

    //
    //  cant find any provider to support this file type...
    //
    goto NoSIPProviderFound;

CommonReturn:

	//we need to handle the exception when we access the mapped file
    if (pbFile)
    {
        UnmapViewOfFile(pbFile);
    }

	if(pCTLContext)
	{
        CertFreeCTLContext(pCTLContext);
	}

    if ((hFileIn) && (hFileIn != INVALID_HANDLE_VALUE))
    {
        if (bCloseFile)
        {
            CloseHandle(hFileIn);
        }
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, InvalidParameter,      ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, NoSIPProviderFound,    TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, FileOpenError,         GetLastError());
    SET_ERROR_VAR_EX(DBG_SS, FileMapError,          GetLastError());
    SET_ERROR_VAR_EX(DBG_SS, FileSizeError,         ERROR_INVALID_PARAMETER);
	SET_ERROR_VAR_EX(DBG_SS, ExceptionError,		dwException);
}

BOOL _DetermineWhichPE(BYTE *pbFile, DWORD cbFile, GUID *pgRet)
{
    IMAGE_DOS_HEADER    *pDosHead;

    pDosHead        = (IMAGE_DOS_HEADER *)pbFile;

    if (pDosHead->e_magic == IMAGE_DOS_SIGNATURE)
    {
        if (cbFile >= sizeof(IMAGE_DOS_HEADER))
        {
            if (cbFile >= (sizeof(IMAGE_DOS_HEADER) + pDosHead->e_lfanew))
            {
                IMAGE_NT_HEADERS    *pNTHead;

                pNTHead = (IMAGE_NT_HEADERS *)((ULONG_PTR)pDosHead + pDosHead->e_lfanew);

                if (pNTHead->Signature == IMAGE_NT_SIGNATURE)
                {
                    GUID    gPE     = CRYPT_SUBJTYPE_PE_IMAGE;

                    memcpy(pgRet, &gPE, sizeof(GUID));

                    return(TRUE);
                }
            }
        }
    }

    return(FALSE);
}


BOOL WINAPI CryptSIPRetrieveSubjectGuidForCatalogFile(IN LPCWSTR FileName, IN OPTIONAL HANDLE hFileIn, OUT GUID *pgSubject)
{
    BYTE    *pbFile;
    DWORD   cbFile;
    HANDLE  hMappedFile;
    BOOL    bCloseFile;
    BOOL    fRet;
	DWORD   dwException = 0;
    GUID    gFlat       = CRYPT_SUBJTYPE_FLAT_IMAGE;
    
    bCloseFile  = FALSE;
    pbFile      = NULL;
    fRet        = TRUE;

    if (!(pgSubject))
    {
        goto InvalidParameter;
    }

    memset(pgSubject, 0x00, sizeof(GUID));

    if ((hFileIn == NULL) || (hFileIn == INVALID_HANDLE_VALUE))
    {
        if (!(FileName))
        {
            goto InvalidParameter;
        }

        if ((hFileIn = CreateFileU(FileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                   NULL)) == INVALID_HANDLE_VALUE)
        {
            goto FileOpenError;
        }

        bCloseFile = TRUE;
    }

    hMappedFile = CreateFileMapping(hFileIn, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        goto FileMapError;
    }

    pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0);

    CloseHandle(hMappedFile);

    cbFile = GetFileSize(hFileIn, NULL);


    if (cbFile < SIP_MAX_MAGIC_NUMBER)
    {
        goto FlatFile;
    }

    //we need to check for the pbFile
    if(NULL == pbFile)
        goto FileMapError;

	//we need to handle the exception when we access the mapped file
	__try {

    //
    //  PE
    //
    if (memcmp(&pbFile[0], PE_EXE_HEADER_TAG, strlen(PE_EXE_HEADER_TAG)) == 0)
    {
        //
        //  if it is an Exe, Dll, Ocx, etc. make sure it is a 32 bit PE and set the
        //  "internal" magic number.
        //
        if (_DetermineWhichPE(pbFile, cbFile, pgSubject))
        {
            goto CommonReturn;
        }
    }

    //
    //  CAB
    //
    if (memcmp(&pbFile[0], CAB_MAGIC_NUMBER, strlen(CAB_MAGIC_NUMBER)) == 0)
    {
        GUID    gCAB    = CRYPT_SUBJTYPE_CABINET_IMAGE;

        memcpy(pgSubject, &gCAB, sizeof(GUID));

        goto CommonReturn;
    }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
			dwException = GetExceptionCode();
            goto ExceptionError;
	}

    //
    //  Not PE, so go for flat
    //
FlatFile:

    memcpy(pgSubject, &gFlat, sizeof(GUID));

CommonReturn:

	__try {
    if (pbFile)
    {
        UnmapViewOfFile(pbFile);
    }
    } __except(EXCEPTION_EXECUTE_HANDLER) {			
        // can't really do anything            
	}

	if ((hFileIn) && (hFileIn != INVALID_HANDLE_VALUE))
    {
        if (bCloseFile)
        {
            CloseHandle(hFileIn);
        }
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, InvalidParameter,      ERROR_INVALID_PARAMETER);

    SET_ERROR_VAR_EX(DBG_SS, FileOpenError,         GetLastError());
    SET_ERROR_VAR_EX(DBG_SS, FileMapError,          GetLastError());
	SET_ERROR_VAR_EX(DBG_SS, ExceptionError,		dwException);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\siphelp\sipfuncs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipfuncs.cpp
//
//  Contents:   Microsoft Internet Security SIP Provider
//
//  Functions:  CryptSIPDllMain
//              CryptSIPPutSignedDataMsg
//              CryptSIPGetSignedDataMsg
//              CryptSIPRemoveSignedDataMsg
//              CryptSIPCreateIndirectData
//              CryptSIPVerifyIndirectData
//
//              *** local functions ***
//              _Guid2Sz
//              _LoadIsFuncs
//              _EnumOIDCallback
//
//  History:    01-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

HCRYPTOIDFUNCSET hPutFuncSet;
HCRYPTOIDFUNCSET hGetFuncSet;
HCRYPTOIDFUNCSET hRemoveFuncSet;
HCRYPTOIDFUNCSET hCreateFuncSet;
HCRYPTOIDFUNCSET hVerifyFuncSet;
HCRYPTOIDFUNCSET hIsMyFileFuncSet;
HCRYPTOIDFUNCSET hIsMyFileFuncSet2;

CRITICAL_SECTION SIP_CriticalSection;
BOOL             fLoadedIsFuncs = FALSE;

typedef struct ISFUNCREF_
{
    DWORD   cGuids;
    GUID    *pGuids;

} ISFUNCREF;

ISFUNCREF       sIsGuids;
ISFUNCREF       sIsGuids2;

void _LoadIsFuncs(void);
BOOL _CallIsMyFileType2(GUID *pgIn, WCHAR *pwszFile, GUID *pgOut);
BOOL _CallIsMyFileType(GUID *pgIn, HANDLE hFile, GUID *pgOut);

BOOL WINAPI _EnumOIDCallback(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID,
                             DWORD cValue, const DWORD rgdwValueType[], LPCWSTR const rgpwszValueName[],
                             const BYTE * const rgpbValueData[], const DWORD rgcbValueData[],
                             void *pvArg);

BOOL WINAPI CryptSIPDllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)
{
    BOOL    fRet;

    fRet = TRUE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            memset(&sIsGuids, 0x00, sizeof(ISFUNCREF));
            memset(&sIsGuids2, 0x00, sizeof(ISFUNCREF));

            if (!(hPutFuncSet = CryptInitOIDFunctionSet(SIPFUNC_PUTSIGNATURE, 0))) 
            {
                goto PutFuncSetFailed;
            }

            if (!(hGetFuncSet = CryptInitOIDFunctionSet(SIPFUNC_GETSIGNATURE, 0))) 
            {
                goto GetFuncSetFailed;
            }

            if (!(hRemoveFuncSet = CryptInitOIDFunctionSet(SIPFUNC_REMSIGNATURE, 0))) 
            {
                goto RemoveFuncSetFailed;
            }

            if (!(hCreateFuncSet = CryptInitOIDFunctionSet(SIPFUNC_CREATEINDIRECT, 0))) 
            {
                goto CreateFuncSetFailed;
            }

            if (!(hVerifyFuncSet = CryptInitOIDFunctionSet(SIPFUNC_VERIFYINDIRECT, 0))) 
            {
                goto VerifyFuncSetFailed;
            }
            
            if (!(hIsMyFileFuncSet = CryptInitOIDFunctionSet(SIPFUNC_ISMYTYPE, 0))) 
            {
                goto VerifyFuncSetFailed;
            }

            if (!(hIsMyFileFuncSet2 = CryptInitOIDFunctionSet(SIPFUNC_ISMYTYPE2, 0))) 
            {
                goto VerifyFuncSetFailed;
            }

            if (!Pki_InitializeCriticalSection(&SIP_CriticalSection))
            {
                goto InitCritSectionFailed;
            }

            break;

        case DLL_PROCESS_DETACH:
        
            if (fLoadedIsFuncs)
            {
                EnterCriticalSection(&SIP_CriticalSection);
                    DELETE_OBJECT(sIsGuids.pGuids);
                    DELETE_OBJECT(sIsGuids2.pGuids);
                    sIsGuids.cGuids = 0;
                    sIsGuids2.cGuids = 0;
                    fLoadedIsFuncs = FALSE;
                LeaveCriticalSection(&SIP_CriticalSection);
            }

            DeleteCriticalSection(&SIP_CriticalSection);
            break;
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, InitCritSectionFailed);
    TRACE_ERROR_EX(DBG_SS, PutFuncSetFailed);
    TRACE_ERROR_EX(DBG_SS, GetFuncSetFailed);
    TRACE_ERROR_EX(DBG_SS, RemoveFuncSetFailed);
    TRACE_ERROR_EX(DBG_SS, CreateFuncSetFailed);
    TRACE_ERROR_EX(DBG_SS, VerifyFuncSetFailed);
}


BOOL WINAPI CryptSIPPutSignedDataMsg(SIP_SUBJECTINFO *pSubjectInfo,
                                     DWORD dwEncodingType,
                                     DWORD *pdwIndex,
                                     DWORD cbSignedDataMsg,
                                     BYTE *pbSignedDataMsg)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPPutSignedDataMsg   pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hPutFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, dwEncodingType, pdwIndex, cbSignedDataMsg, pbSignedDataMsg);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}


BOOL WINAPI CryptSIPGetSignedDataMsg(SIP_SUBJECTINFO *pSubjectInfo,
                                     DWORD *pdwEncodingType,
                                     DWORD dwIndex,
                                     DWORD *pcbSignedDataMsg,
                                     BYTE *pbSignedDataMsg)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPGetSignedDataMsg   pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hGetFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, pdwEncodingType, dwIndex, pcbSignedDataMsg, pbSignedDataMsg);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL WINAPI CryptSIPRemoveSignedDataMsg(SIP_SUBJECTINFO *pSubjectInfo,
                                        DWORD dwIndex)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPRemoveSignedDataMsg pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hRemoveFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, dwIndex);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL WINAPI CryptSIPCreateIndirectData(SIP_SUBJECTINFO *pSubjectInfo,
                                       DWORD *pcbIndirectData,
                                       SIP_INDIRECT_DATA *pIndirectData)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPCreateIndirectData pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hCreateFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, pcbIndirectData, pIndirectData);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL WINAPI CryptSIPVerifyIndirectData(SIP_SUBJECTINFO *pSubjectInfo,
                                       SIP_INDIRECT_DATA *pIndirectData)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPVerifyIndirectData pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hVerifyFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, pIndirectData);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}


BOOL _Guid2Sz(GUID *pgGuid, char *pszGuid)
{
    WCHAR wszGuid[REG_MAX_GUID_TEXT];

    if (!(guid2wstr(pgGuid, &wszGuid[0])))
    {
        return(FALSE);
    }

    if (WideCharToMultiByte(0, 0, &wszGuid[0], -1, pszGuid, REG_MAX_GUID_TEXT, NULL, NULL) == 0)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL _QueryRegisteredIsMyFileType(HANDLE hFile, LPCWSTR pwszFile, GUID *pgSubject)
{
    if (!(fLoadedIsFuncs))
    {
        EnterCriticalSection(&SIP_CriticalSection);

            if (!(fLoadedIsFuncs))
            {
                CryptEnumOIDFunction(0, SIPFUNC_ISMYTYPE, NULL, 0, (void *)&sIsGuids, _EnumOIDCallback);
                CryptEnumOIDFunction(0, SIPFUNC_ISMYTYPE2, NULL, 0, (void *)&sIsGuids2, _EnumOIDCallback);
                fLoadedIsFuncs = TRUE;
            }

        LeaveCriticalSection(&SIP_CriticalSection);
    }


    DWORD       i;
    
    i = 0;
    while (i < sIsGuids.cGuids)
    {
        if (_CallIsMyFileType(&sIsGuids.pGuids[i], hFile, pgSubject))
        {
            return(TRUE);
        }

        i++;
    }
    
    i = 0;
    while (i < sIsGuids2.cGuids)
    {
        if (_CallIsMyFileType2(&sIsGuids2.pGuids[i], (WCHAR *)pwszFile, pgSubject))
        {
            return(TRUE);
        }

        i++;
    }

    return(FALSE);
}

BOOL _CallIsMyFileType(GUID *pgIn, HANDLE hFile, GUID *pgOut)
{
    BOOL    fRet;

    HCRYPTOIDFUNCADDR           hPfn;
    pfnIsFileSupported          pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pgIn, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hIsMyFileFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(hFile, pgOut);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, GetFuncAddrFailed);
    TRACE_ERROR_EX(DBG_SS, GuidConvertFailed);
}

BOOL _CallIsMyFileType2(GUID *pgIn, WCHAR *pwszFile, GUID *pgOut)
{
    BOOL                        fRet;

    HCRYPTOIDFUNCADDR           hPfn;
    pfnIsFileSupported          pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pgIn, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hIsMyFileFuncSet2, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pwszFile, pgOut);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, GetFuncAddrFailed);
    TRACE_ERROR_EX(DBG_SS, GuidConvertFailed);
}

void *SIPRealloc(void *pvOrg, size_t cb)
{
    void *pv;

    pv = (pvOrg) ? realloc(pvOrg, cb) : malloc(cb);

    if (!(pv))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(pv);
}


BOOL WINAPI _EnumOIDCallback(IN DWORD dwEncodingType,
                            IN LPCSTR pszFuncName,
                            IN LPCSTR pszOID,
                            IN DWORD cValue,
                            IN const DWORD rgdwValueType[],
                            IN LPCWSTR const rgpwszValueName[],
                            IN const BYTE * const rgpbValueData[],
                            IN const DWORD rgcbValueData[],
                            IN void *pvArg)
{
    WCHAR   wszGuid[REG_MAX_GUID_TEXT];
    GUID    g;

    wszGuid[0] = NULL;
    MultiByteToWideChar(0, 0, pszOID, -1, &wszGuid[0], REG_MAX_GUID_TEXT);

    if (wszGuid[0])
    {
        if (wstr2guid(&wszGuid[0], &g))
        {
            ISFUNCREF *pIsGuids;

            pIsGuids = (ISFUNCREF *)pvArg;

            if (!(pvArg))
            {
                return(TRUE);
            }
            
            pIsGuids->cGuids++;
            pIsGuids->pGuids = (GUID *)SIPRealloc(pIsGuids->pGuids, pIsGuids->cGuids * sizeof(GUID));

            if (!(pIsGuids->pGuids))
            {
                pIsGuids->cGuids = 0;
                return(FALSE);
            }

            memcpy(&pIsGuids->pGuids[pIsGuids->cGuids - 1], &g, sizeof(GUID));
        }
    }

    return(TRUE);   // keep going!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\sp3crmsg\sp3crmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sp3crmsg.h
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  File:       sp3crmsg.h
//
//  Contents:   Data structure for enabling NT 4.0 SP3 and IE 3.02 compatible
//              PKCS #7 EnvelopeData messages.
//
//              The SP3 version of crypt32.dll failed to byte reverse the
//              encrypted symmetric key. It also added zero salt instead
//              of no salt.
//--------------------------------------------------------------------------

#ifndef __SP3CRMSG_H__
#define __SP3CRMSG_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  To enable SP3 compatible encryption, the pvEncryptionAuxInfo field in either
//  CMSG_ENVELOPED_ENCODE_INFO for CryptMsgOpenToEncode() or
//  CRYPT_ENCRYPT_MESSAGE_PARA for CryptSignAndEncryptMessage() or
//  CryptSignAndEncryptMessage() should point to the following
//  CMSG_SP3_COMPATIBLE_AUX_INFO data structure.
//--------------------------------------------------------------------------


// The following is defined in newer versions of wincrypt.h, starting with
// IE 4.01 and  NT 5.0 Beta 2

#ifndef CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG

//+-------------------------------------------------------------------------
//  CMSG_SP3_COMPATIBLE_AUX_INFO
//
//  AuxInfo for enabling SP3 compatible encryption.
//
//  The CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG is set in dwFlags to enable SP3
//  compatible encryption. When set, uses zero salt instead of no salt,
//  the encryption algorithm parameters are NULL instead of containing the
//  encoded RC2 parameters or encoded IV octet string and the encrypted
//  symmetric key is encoded little endian instead of big endian.
//--------------------------------------------------------------------------
typedef struct _CMSG_SP3_COMPATIBLE_AUX_INFO {
    DWORD                       cbSize;
    DWORD                       dwFlags;
} CMSG_SP3_COMPATIBLE_AUX_INFO, *PCMSG_SP3_COMPATIBLE_AUX_INFO;

#define CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG    0x80000000

#endif  // CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG

#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif // __SP3CRMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\tools\bin264\bin264.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fdecrypt.cpp
//
//  Contents:   File Decryption tool. Decrypts a file looking in the MY
//              system certificate store for private keys.
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <wincrypt.h>

//+-------------------------------------------------------------------------
//  Display Bin264 usage.
//--------------------------------------------------------------------------
void
Usage(void)
{
    printf("Usage: Bin264 <Binary File> <Base64 Encoded File> \n");
    exit(1);
}

//+-------------------------------------------------------------------------
//  Generalized error routine
//--------------------------------------------------------------------------
#define PRINTERROR(psz, err)	_PrintError((psz), (err), __LINE__)
void
_PrintError(char *pszMsg, DWORD err, DWORD line)
{
    printf("%s failed on line %u: (%x)\n", pszMsg, line, err);
}

//+-------------------------------------------------------------------------
//  Main program. Open a file to decyrpt,
//  decrypts it and then writes the clear text
//  file out.
//--------------------------------------------------------------------------
int __cdecl
main(int argc, char * argv[])
{

    DWORD		dwExitValue	    = 0;
    DWORD		err		    = ERROR_SUCCESS;
    DWORD		cb		    = 0;

    HANDLE hFileOut                         = INVALID_HANDLE_VALUE;
    HANDLE hFile                            = INVALID_HANDLE_VALUE;
    DWORD  cbFile                           = 0;
    HANDLE hMap                             = NULL;
    PBYTE  pbFile                           = NULL;

    PBYTE  pbBase64			    = NULL;
    DWORD  cchBase64			    = 0;

    // must have the parameters
    if(argc != 3)
        Usage();

    // Read in the file.
    if(

        // open the file to decrypt
        (hFile =  CreateFileA(
            argv[1],	            // pointer to name of the file
            GENERIC_READ,	        // access (read-write) mode
            FILE_SHARE_READ,	    // share mode
            NULL,	                // pointer to security descriptor
            OPEN_EXISTING,	        // how to create
            FILE_ATTRIBUTE_NORMAL,	// file attributes
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        // create a file mapping object
        (hMap = CreateFileMapping(
            hFile,	                // handle to file to map
            NULL,	                // optional security attributes
            PAGE_READONLY,	        // protection for mapping object
            0,	                    // high-order 32 bits of object size
            0,	                    // low-order 32 bits of object size
            NULL 	                // name of file-mapping object
            ))  == NULL                     ||

        // Map the file into the address space
        (pbFile = (PBYTE) MapViewOfFileEx(
            hMap,	                // file-mapping object to map into address space
            FILE_MAP_READ,	        // access mode
            0,	                    // high-order 32 bits of file offset
            0,	                    // low-order 32 bits of file offset
            0,	                    // number of bytes to map
            NULL 	                // suggested starting address for mapped view
            )) == NULL
        )
    {

        PRINTERROR("File Open", GetLastError());
        goto ErrCleanUp;
    }

    // get the size of the file
    if( (cbFile = GetFileSize(
            hFile,	                // handle of file to get size of
            NULL 	                // address of high-order word for file size
            )) == 0
        )
    {
        printf("File %s has a 0 length.\n", argv[2]);
        goto ErrCleanUp;
    }

    // at this point we have a file mapping, base64 encode the file


    if(!CryptBinaryToStringA(
		pbFile,
		cbFile,
                CRYPT_STRING_BASE64,
		NULL,
		&cchBase64)) {
        err = GetLastError();
	PRINTERROR("CryptBinaryToStringA", err);
	goto ErrCleanUp;
    }


    if( (pbBase64 = (PBYTE) malloc(cchBase64 * sizeof(char))) == NULL ) {
	PRINTERROR("malloc", ERROR_OUTOFMEMORY);
	goto ErrCleanUp;
    }

    if(!CryptBinaryToStringA(
		pbFile,
		cbFile,
                CRYPT_STRING_BASE64,
		(char *) pbBase64,
		&cchBase64)) {
        err = GetLastError();
	PRINTERROR("CryptBinaryToStringA", err);
	goto ErrCleanUp;
    }

    // write out the clear text file
    if(

        // open the output file
        (hFileOut =  CreateFileA(
            argv[2],	            // pointer to name of the file
	    GENERIC_WRITE,	    // access (read-write) mode
            FILE_SHARE_READ,	    // share mode
	    NULL,		    // pointer to security descriptor
	    CREATE_ALWAYS,	    // how to create
	    FILE_ATTRIBUTE_NORMAL,  //file attributes
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        //write to the decrypted data to the file
        !WriteFile(
            hFileOut,	            // handle to file to write to
	    pbBase64,		    // pointer to data to write to file
	    cchBase64 * sizeof(char),// number of bytes to write
	    &cb,		    // pointer to number of bytes written
	    NULL		    // pointer to structure needed for overlapped I/O
            )
        )
     {
        PRINTERROR("File Write", GetLastError());
        goto ErrCleanUp;
     }


    CleanUp:

        if(hMap != NULL)
            CloseHandle(hMap);

        if(hFile != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFile);

        if(hFileOut != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFileOut);

	if(pbBase64 != NULL)
	    free(pbBase64);

    return(dwExitValue);

    ErrCleanUp:
        dwExitValue = 1;
        goto CleanUp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\tools\fencrypt\fencrypt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fencrypt.cpp
//
//  Contents:   File encryption tool. Encrypts a file looking in the MY
//              system certificate store for the specifed subject common name
//              with exchange private keys.
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>

//+-------------------------------------------------------------------------
//  Helper function to make MBCS from Unicode string
//--------------------------------------------------------------------------
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB) {

    DWORD   cbConverted;

    assert(pszMB != NULL);
    *pszMB = NULL;
    if(wsz == NULL)
        return(TRUE);

    // how long is the mb string
    cbConverted = WideCharToMultiByte(  0,
                                        0,
                                        wsz,
                                        -1,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);

    // get a buffer long enough
    if(pbBuff != NULL  &&  cbConverted < cbBuff)
        *pszMB = (char *) pbBuff;
    else
        *pszMB = (char *) malloc(cbConverted);


    if(*pszMB == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // now convert to MB
    WideCharToMultiByte(0,
                        0,
                        wsz,
                        -1,
                        *pszMB,
                        cbConverted,
                        NULL,
                        NULL);
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Frees string allocated by the above function
//--------------------------------------------------------------------------
void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB) {

    if((szMB != NULL) &&  (pbBuff != (PBYTE)szMB))
        free(szMB);
}

//+-------------------------------------------------------------------------
//  Win95 only supports CryptAcquireContextA. This function converts the
//  unicode parameters to multibyte.
//--------------------------------------------------------------------------
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szContainer = NULL;
    char *  szProvider = NULL;
    LONG    err;

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpContainer, &szContainer)  &&
        MkMBStr(rgb2, _MAX_PATH, lpProvider, &szProvider)    )
        err = CryptAcquireContextA (
                phProv,
                szContainer,
                szProvider,
                dwProvType,
                dwFlags
               );

    FreeMBStr(rgb1, szContainer);
    FreeMBStr(rgb2, szProvider);

    return(err);
}

//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CryptDecodeObject.
//--------------------------------------------------------------------------
BOOL
WINAPI
MDecodeObject(
    IN DWORD	    dwEncodingType,
    IN LPCSTR	    lpszStructureType,
    IN const PBYTE  pbEncoded,
    IN DWORD	    cbEncoded,
    OUT PVOID *	    ppvoid
    )
{
    DWORD cb = 0;
    
    assert(ppvoid != NULL);
    *ppvoid = NULL;

    // get the size
    if(!CryptDecodeObject(
        dwEncodingType,
        lpszStructureType,
        pbEncoded,
        cbEncoded,
        0,                  // dwFlags
        NULL,
        &cb
        ))
        return(FALSE);
    
    // allocate the buffer
    if( (*ppvoid = malloc(cb)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    // Decode the data
    if(!CryptDecodeObject(
        dwEncodingType,
        lpszStructureType,
        pbEncoded,
        cbEncoded,
        0,                  // dwFlags
        *ppvoid,
        &cb
        )) 
    {

        free(*ppvoid);
        *ppvoid = NULL;
        return(FALSE);
    }
        
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CertRDNValueToStr.
//--------------------------------------------------------------------------
DWORD
WINAPI
MCertRDNValueToStr(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPSTR * ppsz
    ) 
{

    DWORD cb = 0;
    
    assert(ppsz != NULL);
    *ppsz = NULL;

    // get the size
    cb = CertRDNValueToStrA(
        dwValueType,
        pValue,
        NULL,
        0);
    
    // allocate the buffer
    if( (*ppsz = (LPSTR) malloc(cb)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0);
    }

    // now convert the CERT_RDN Value to an 
    // ascii string based on the specified 
    // ASN value type.
    // This shouldn't fail.
    return(CertRDNValueToStrA(
        dwValueType,
        pValue,
        *ppsz,
        cb));
}


//+-------------------------------------------------------------------------
//  Helper function to get and allocate the exported public key info
//--------------------------------------------------------------------------
BOOL
WINAPI
MCryptExportPublicKeyInfo(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    DWORD cbPubKeyInfo;
    assert(ppPubKeyInfo != NULL);
    *ppPubKeyInfo = NULL;
    

    // get the size
    if(!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            X509_ASN_ENCODING,
            NULL,                   // pPubKeyInfo
            &cbPubKeyInfo
            )
        )
        return(FALSE);
    
    // allocate the buffer
    if( (*ppPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) malloc(cbPubKeyInfo)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    if(!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            X509_ASN_ENCODING,
            *ppPubKeyInfo,
            &cbPubKeyInfo
            )
        ) 
    {
        free(*ppPubKeyInfo);
        *ppPubKeyInfo = NULL;
        
        return(FALSE);
    }
        
    return(TRUE);
}
//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CertGetCertificateContextProperty.
//--------------------------------------------------------------------------
BOOL
WINAPI
MCertGetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void ** ppvData
    )
{

    DWORD cb = 0;
    
    assert(ppvData != NULL);
    *ppvData = NULL;

    // get the size
    if( !CertGetCertificateContextProperty(
            pCertContext,
            dwPropId,
            NULL,
            &cb))
        return(FALSE);
    
    // allocate the buffer
    if( (*ppvData = malloc(cb)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    // Get the property out of the cert
    if( !CertGetCertificateContextProperty(
            pCertContext,
            dwPropId,
            *ppvData,
            &cb)) 
    {

        free(*ppvData);
        *ppvData = NULL;
        return(FALSE);
    }
        
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CryptEncryptMessage.
//--------------------------------------------------------------------------
BOOL
WINAPI
MCryptEncryptMessage(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE **ppbEncryptedBlob,
    OUT DWORD *pcbEncryptedBlob
    )
{
    
    assert(ppbEncryptedBlob != NULL);
    *ppbEncryptedBlob = NULL;

    assert(pcbEncryptedBlob != NULL);
    *pcbEncryptedBlob = 0;

    // get the size
    if(!CryptEncryptMessage(
        pEncryptPara,
        cRecipientCert,
        rgpRecipientCert,
        pbToBeEncrypted,
        cbToBeEncrypted,
        NULL,
        pcbEncryptedBlob
        ))
        return(FALSE);
    
    // allocate the buffer
    if( (*ppbEncryptedBlob = (BYTE *) malloc(*pcbEncryptedBlob)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    // encrypt the data
    if(!CryptEncryptMessage(
        pEncryptPara,
        cRecipientCert,
        rgpRecipientCert,
        pbToBeEncrypted,
        cbToBeEncrypted,
        *ppbEncryptedBlob,
        pcbEncryptedBlob)) 
    {
        free(*ppbEncryptedBlob);
        *ppbEncryptedBlob = NULL;
        *pcbEncryptedBlob = 0;
        return(FALSE);
    }
        
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Display FEncrypt usage.
//--------------------------------------------------------------------------
void
Usage(void)
{
    printf("Usage: FEncrypt [options] <SubjectName> <ClearTextFileName> <EncryptedFileName>\n");
    printf("Options are:\n");
    printf("  -RC2          - RC2 encryption\n");
    printf("  -RC4          - RC4 encryption\n");
    printf("  -SP3          - SP3 compatible encryption\n");
    printf("  -FIX          - Fix by loading sp3crmsg.dll\n");
    exit(1);
}

//+-------------------------------------------------------------------------
//  Generalized error routine
//--------------------------------------------------------------------------
#define PRINTERROR(psz, err)	_PrintError((psz), (err), __LINE__)
void
_PrintError(char *pszMsg, DWORD err, DWORD line)
{
    printf("%s failed on line %u: %u(%x)\n", pszMsg, line, err, err);
}

//+-------------------------------------------------------------------------
//  Grovels the cert store looking for a cert with the specified
//  subject common name. Then checks to see that there are private
//  and public exchange keys.
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetSubjectCertFromStore(
    HCERTSTORE      hMyStore,
    const char *    szSubjectName,
    HCRYPTPROV *    phProv 
    )
{

    DWORD               i, j;
    PCCERT_CONTEXT      pCertContext        = NULL;
    PCCERT_CONTEXT      pCertContextLast    = NULL;
    PCERT_NAME_INFO          pNameInfo           = NULL;
    LPSTR               sz                  = NULL;
    PCRYPT_KEY_PROV_INFO      pProvInfo           = NULL;
    HCRYPTPROV          hProv               = NULL;
    PCERT_PUBLIC_KEY_INFO    pPubKeyInfo         = NULL;

    assert(hMyStore != NULL);
    assert(phProv != NULL);
    *phProv = NULL;
    
    // Enum all certs looking for the requested common 
    // subject name that has private keys (so we know we can decrypt)
    while(   hProv == NULL && 
            (pCertContext = CertEnumCertificatesInStore(
                                hMyStore, 
                                pCertContextLast)) != NULL) 
    {

        // decode the subject name into RDNs
        if(MDecodeObject(X509_ASN_ENCODING, X509_NAME,
                pCertContext->pCertInfo->Subject.pbData,
                pCertContext->pCertInfo->Subject.cbData,
                (void **) &pNameInfo)
            ) 
        {

            // loop thru looking for an CERT_RDN and COMMON Name that works
            for(i=0; i<pNameInfo->cRDN && hProv == NULL; i++) 
            {
                for(j=0; j<pNameInfo->rgRDN[i].cRDNAttr && hProv == NULL; j++) 
                {

                    // check to see if this is the common name
                    if( !strcmp(pNameInfo->rgRDN[i].rgRDNAttr[j].pszObjId, 
                                szOID_COMMON_NAME) ) 
                    {
                            
                        // convert the string to something I can read
                        MCertRDNValueToStr(
                            pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType,
                            &pNameInfo->rgRDN[i].rgRDNAttr[j].Value,
                            &sz);

                        // see if this is a viable certificate to use
                        if( sz == NULL              || 
                        
                            // see if it is the common name we are looking for
                            _stricmp(sz, szSubjectName)             ||

                            // see if there are associated private keys
                            // to ensure we can decrypt the data later
                            !MCertGetCertificateContextProperty(
                                pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                (void **) &pProvInfo)               ||

                            // Make sure it is an exchange key for encryption
                            pProvInfo->dwKeySpec != AT_KEYEXCHANGE  ||

                            // see if the keys are really there
                            !CryptAcquireContextU(
                                &hProv, 
                                pProvInfo->pwszContainerName,
                                pProvInfo->pwszProvName,
                                pProvInfo->dwProvType,
                                pProvInfo->dwFlags &
                                    ~CERT_SET_KEY_CONTEXT_PROP_ID)
                            ) 
                        {

                            // On an error we didn't find a valid
                            // key provider. Unfortunately, the CSP
                            // may not leave the prov handle NULL
                            // so clear it out
                            hProv = NULL;
                        }

                        
                        // Make sure the public keys in the
                        // CSP match the public key in the certificate
                        else if( 
                            // export the public key blob
                            !MCryptExportPublicKeyInfo(
                                hProv,
                                pProvInfo->dwKeySpec,
                                &pPubKeyInfo
                                )               ||

                            // see if the public keys compare with 
                            // what is in the certificate
                            !CertComparePublicKeyInfo(
                                X509_ASN_ENCODING,
                                &pCertContext->pCertInfo->SubjectPublicKeyInfo,
                                pPubKeyInfo
                                )
                            )
                        // if the keys didn't compare, then we don't
                        // want to use this ceritificate
                        {

                            // close the hProv, we didn't find a valid cert
                            assert(hProv != NULL);
                            CryptReleaseContext(hProv, 0);
                            hProv = NULL;
                        }

                        // free public key info
                        if(pPubKeyInfo != NULL)
                        {
                            free(pPubKeyInfo); 
                            pPubKeyInfo = NULL;
                        }

                        // clean up opened prov info
                        if(pProvInfo != NULL) 
                        {
                            free(pProvInfo);
                            pProvInfo = NULL;
                        }

                        // free the space for the ascii common name
                        if(sz != NULL) 
                        {
                            free(sz);
                            sz = NULL;
                        }
                    }
                }
            }
            
            // free the name info data
            if(pNameInfo != NULL) 
            {
                free(pNameInfo);
                pNameInfo = NULL;
            }
        }

        // go to the next certificate
        pCertContextLast = pCertContext;
    }

    assert(pProvInfo == NULL);
    assert(sz == NULL);
    assert(pNameInfo == NULL);

    // There is a good cert in the store, return it
    if(hProv != NULL)
    {
        *phProv = hProv;
        assert(pCertContext != NULL);
        return(pCertContext);
    }

    return(NULL);
}

//+-------------------------------------------------------------------------
//  Main program. Open a file to encrypt,
//  encrypts it and then writes the encrypted 
//  data to the output file.
//--------------------------------------------------------------------------
int __cdecl
main(int argc, char * argv[])
{

    DWORD               dwExitValue         = 0;
    
    HCERTSTORE          hMyStore            = NULL;
    PCCERT_CONTEXT      pCertContext        = NULL;
    HCRYPTPROV          hProv               = NULL;
    
    HANDLE hFileOut                         = INVALID_HANDLE_VALUE;
    HANDLE hFile                            = INVALID_HANDLE_VALUE;
    DWORD  cbFile                           = 0;
    HANDLE hMap                             = NULL;
    PBYTE  pbFile                           = NULL;

    BOOL fResult;
    HMODULE hDll = NULL;
    CMSG_SP3_COMPATIBLE_AUX_INFO SP3AuxInfo;
    BOOL fSP3 = FALSE;
    BOOL fFix = FALSE;
    
    CRYPT_ALGORITHM_IDENTIFIER    encryptAlgId        = {szOID_RSA_RC4, 0};
    CRYPT_ENCRYPT_MESSAGE_PARA    encryptInfo;
    PBYTE               pbEncryptedBlob     = NULL;
    DWORD               cbEncryptedBlob     = 0;
    DWORD               cb                  = 0;


    // Advance past fencrypt.exe and check for leading options
    while (--argc > 0) {
        if (**++argv != '-')
            break;

        if (0 == _stricmp(argv[0], "-RC2"))
            encryptAlgId.pszObjId = szOID_RSA_RC2CBC;
        else if (0 == _stricmp(argv[0], "-RC4"))
            encryptAlgId.pszObjId = szOID_RSA_RC4;
        else if (0 == _stricmp(argv[0], "-SP3"))
            fSP3 = TRUE;
        else if (0 == _stricmp(argv[0], "-FIX"))
            fFix = TRUE;
        else {
            printf("Bad option: %s\n", argv[0]);
            Usage();
        }
    }
        
    
    // must have the parameters
    if (argc != 3)
        Usage();

    if (fFix) {
        if (NULL == (hDll = LoadLibraryA("sp3crmsg.dll"))) 
        {
            PRINTERROR("LoadLibraryA(sp3crmsg.dll)", GetLastError());
            goto ErrCleanUp;
        }
    }

    // Open the MY store
    if( (hMyStore = CertOpenSystemStore(NULL, "My")) == NULL ) 
    {
        PRINTERROR("CertOpenSystemStore", GetLastError());
        goto ErrCleanUp;
    }

    // Find a certificate in the MY store that
    // matches the subject name and has private keys
    if( (pCertContext = GetSubjectCertFromStore(hMyStore, argv[0], &hProv)) == NULL)
    {
        printf("Unable to find certificate %s with valid keys.\n", argv[0]);
        goto ErrCleanUp;
    }
        
    // At this point we have a provider, Cert and a public key.
    // We should be able to encrypt

    // Read in the clear text file
    if(
    
        // read in the file to encrypt
        (hFile =  CreateFileA(
            argv[1],	            // pointer to name of the file 
            GENERIC_READ,	        // access (read-write) mode 
            FILE_SHARE_READ,	    // share mode 
            NULL,	                // pointer to security descriptor 
            OPEN_EXISTING,	        // how to create 
            FILE_ATTRIBUTE_NORMAL,	// file attributes 
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        // create a file mapping object         
        (hMap = CreateFileMapping(
            hFile,	                // handle to file to map 
            NULL,	                // optional security attributes 
            PAGE_READONLY,	        // protection for mapping object 
            0,	                    // high-order 32 bits of object size  
            0,	                    // low-order 32 bits of object size  
            NULL 	                // name of file-mapping object 
            ))  == NULL                     ||

        // Map the file into the address space
        (pbFile = (PBYTE) MapViewOfFileEx(
            hMap,	                // file-mapping object to map into address space  
            FILE_MAP_READ,	        // access mode 
            0,	                    // high-order 32 bits of file offset 
            0,	                    // low-order 32 bits of file offset 
            0,	                    // number of bytes to map 
            NULL 	                // suggested starting address for mapped view 
            )) == NULL                                 
        ) 
    {

        PRINTERROR("File Open", GetLastError());
        goto ErrCleanUp;
    }

    // get the size of the file         
    if( (cbFile = GetFileSize(
            hFile,	                // handle of file to get size of
            NULL 	                // address of high-order word for file size
            )) == 0 
        ) 
    {
        printf("File %s has a 0 length.\n", argv[1]);
        goto ErrCleanUp;
    }

    // at this point we have a file mapping, go ahead and encrypt the file
    
    // Do rc4 encryption
    memset(&encryptInfo, 0, sizeof(CRYPT_ENCRYPT_MESSAGE_PARA));
    encryptInfo.cbSize =
        sizeof(CRYPT_ENCRYPT_MESSAGE_PARA);
    encryptInfo.dwMsgEncodingType            = PKCS_7_ASN_ENCODING;
    encryptInfo.hCryptProv                   = hProv;
    encryptInfo.ContentEncryptionAlgorithm   = encryptAlgId;

    if (fSP3) {
        memset(&SP3AuxInfo, 0, sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO));
        SP3AuxInfo.cbSize = sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO);
        SP3AuxInfo.dwFlags = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
        encryptInfo.pvEncryptionAuxInfo = &SP3AuxInfo;
    }

    // encrypt it
    fResult = MCryptEncryptMessage(
            &encryptInfo,
            1,
            &pCertContext,
            pbFile,
            cbFile,
            &pbEncryptedBlob,
            &cbEncryptedBlob
            );
    if (!fResult && fSP3 && (DWORD) E_INVALIDARG == GetLastError()) {
        printf(
            "Non-NULL pvEncryptionAuxInfo not supported in SP3 crypt32.dll\n");
    
        encryptInfo.pvEncryptionAuxInfo = NULL;
        fResult = MCryptEncryptMessage(
            &encryptInfo,
            1,
            &pCertContext,
            pbFile,
            cbFile,
            &pbEncryptedBlob,
            &cbEncryptedBlob
            );
    }
    if (!fResult) {
        PRINTERROR("MCryptEncryptMessage", GetLastError());
        goto ErrCleanUp;
    }

    // write the encrypted file out
    if(
    
        // open the output file
        (hFileOut =  CreateFileA(
            argv[2],	            // pointer to name of the file 
            GENERIC_WRITE,	        // access (read-write) mode 
            FILE_SHARE_READ,	    // share mode 
            NULL,	                // pointer to security descriptor 
            CREATE_ALWAYS,	        // how to create 
            FILE_ATTRIBUTE_NORMAL,	// file attributes 
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        //write to the file
        !WriteFile(
            hFileOut,	            // handle to file to write to 
            pbEncryptedBlob,	    // pointer to data to write to file 
            cbEncryptedBlob,	    // number of bytes to write 
            &cb,	                // pointer to number of bytes written 
            NULL 	                // pointer to structure needed for overlapped I/O
            )
        )
     {
        PRINTERROR("File Write", GetLastError());
        goto ErrCleanUp;
     }


    CleanUp:

        if(hDll)
            FreeLibrary(hDll);

        if(hMap != NULL)
            CloseHandle(hMap);
        
        if(hFile != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFile);
            
        if(hFileOut != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFileOut);

        if(pCertContext != NULL)
            CertFreeCertificateContext(pCertContext);   
            
        if(hProv != NULL)
            CryptReleaseContext(hProv, 0);

        if(hMyStore != NULL)
            CertCloseStore(hMyStore, 0);

        if(pbEncryptedBlob != NULL)
            free(pbEncryptedBlob);

    return(dwExitValue);

    ErrCleanUp:
        dwExitValue = 1;
        goto CleanUp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\tools\642bin\642bin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fdecrypt.cpp
//
//  Contents:   File Decryption tool. Decrypts a file looking in the MY
//              system certificate store for private keys.
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <wincrypt.h>

//+-------------------------------------------------------------------------
//  Display Bin264 usage.
//--------------------------------------------------------------------------
void
Usage(void)
{
    printf("Usage: 642bin <Base64 Encoded File> <Binary File> \n");
    exit(1);
}

//+-------------------------------------------------------------------------
//  Generalized error routine
//--------------------------------------------------------------------------
#define PRINTERROR(psz, err)	_PrintError((psz), (err), __LINE__)
void
_PrintError(char *pszMsg, DWORD err, DWORD line)
{
    printf("%s failed on line %u: (%x)\n", pszMsg, line, err);
}

//+-------------------------------------------------------------------------
//  Main program. Open a file to decyrpt,
//  decrypts it and then writes the clear text
//  file out.
//--------------------------------------------------------------------------
int __cdecl
main(int argc, char * argv[])
{

    DWORD		dwExitValue	    = 0;
    DWORD		err		    = ERROR_SUCCESS;
    DWORD		cbT		    = 0;

    HANDLE hFileOut                         = INVALID_HANDLE_VALUE;
    HANDLE hFile                            = INVALID_HANDLE_VALUE;
    DWORD  cbFile                           = 0;
    HANDLE hMap                             = NULL;
    PBYTE  pbFile                           = NULL;

    PBYTE  pb		    = NULL;
    DWORD  cb		    = 0;

    // must have the parameters
    if(argc != 3)
        Usage();

    // Read in the file.
    if(

        // open the file to decrypt
        (hFile =  CreateFileA(
            argv[1],	            // pointer to name of the file
            GENERIC_READ,	        // access (read-write) mode
            FILE_SHARE_READ,	    // share mode
            NULL,	                // pointer to security descriptor
            OPEN_EXISTING,	        // how to create
            FILE_ATTRIBUTE_NORMAL,	// file attributes
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        // create a file mapping object
        (hMap = CreateFileMapping(
            hFile,	                // handle to file to map
            NULL,	                // optional security attributes
            PAGE_READONLY,	        // protection for mapping object
            0,	                    // high-order 32 bits of object size
            0,	                    // low-order 32 bits of object size
            NULL 	                // name of file-mapping object
            ))  == NULL                     ||

        // Map the file into the address space
        (pbFile = (PBYTE) MapViewOfFileEx(
            hMap,	                // file-mapping object to map into address space
            FILE_MAP_READ,	        // access mode
            0,	                    // high-order 32 bits of file offset
            0,	                    // low-order 32 bits of file offset
            0,	                    // number of bytes to map
            NULL 	                // suggested starting address for mapped view
            )) == NULL
        )
    {

        PRINTERROR("File Open", GetLastError());
        goto ErrCleanUp;
    }

    // get the size of the file
    if( (cbFile = GetFileSize(
            hFile,	                // handle of file to get size of
            NULL 	                // address of high-order word for file size
            )) == 0
        )
    {
        printf("File %s has a 0 length.\n", argv[2]);
        goto ErrCleanUp;
    }

    // at this point we have a file mapping, base64 encode the file

    if(!CryptStringToBinaryA(
		(const char *) pbFile,
		cbFile,
                CRYPT_STRING_ANY,
		NULL,
		&cb,
                NULL,
                NULL)) {
        err = GetLastError();
	PRINTERROR("CryptStringToBinaryA", err);
	goto ErrCleanUp;
    }

    if( (pb = (PBYTE) malloc(cb)) == NULL ) {
	PRINTERROR("malloc", ERROR_OUTOFMEMORY);
	goto ErrCleanUp;
    }

    if(!CryptStringToBinaryA(
		(const char *) pbFile,
		cbFile,
                CRYPT_STRING_ANY,
		pb,
		&cb,
                NULL,
                NULL)) {
        err = GetLastError();
	PRINTERROR("CryptStringToBinaryA", err);
	goto ErrCleanUp;
    }

    // write out the clear text file
    if(

        // open the output file
        (hFileOut =  CreateFileA(
            argv[2],	            // pointer to name of the file
	        GENERIC_WRITE,	    // access (read-write) mode
            FILE_SHARE_READ,	    // share mode
    	    NULL,		    // pointer to security descriptor
    	    CREATE_ALWAYS,	    // how to create
    	    FILE_ATTRIBUTE_NORMAL,  //file attributes
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        //write to the decrypted data to the file
        !WriteFile(
            hFileOut,	            // handle to file to write to
    	    pb,		    // pointer to data to write to file
    	    cb,		    // number of bytes to write
    	    &cbT,		    // pointer to number of bytes written
    	    NULL		    // pointer to structure needed for overlapped I/O
            )
        )
     {
        PRINTERROR("File Write", GetLastError());
        goto ErrCleanUp;
     }


    CleanUp:

        if(hMap != NULL)
            CloseHandle(hMap);

        if(hFile != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFile);

        if(hFileOut != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFileOut);

	if(pb != NULL)
	    free(pb);

    return(dwExitValue);

    ErrCleanUp:
        dwExitValue = 1;
        goto CleanUp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\tools\fdecrypt\fdecrypt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fdecrypt.cpp
//
//  Contents:   File Decryption tool. Decrypts a file looking in the MY
//              system certificate store for private keys.
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>

//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CryptDecryptMessage.
//--------------------------------------------------------------------------
BOOL
WINAPI
MCryptDecryptMessage(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE ** ppbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    
    assert(ppbDecrypted != NULL);
    *ppbDecrypted = NULL;

    assert(pcbDecrypted != NULL);
    *pcbDecrypted = 0;

    // get the size
    if(!CryptDecryptMessage(
            pDecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            NULL,
            pcbDecrypted,
            NULL
            ))
        return(FALSE);
    
    // allocate the buffer
    if( (*ppbDecrypted = (BYTE *) malloc(*pcbDecrypted)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    // Decrypt the data
    if(!CryptDecryptMessage(
            pDecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            *ppbDecrypted,
            pcbDecrypted,
            ppXchgCert)) 
    {
        free(*ppbDecrypted);
        *ppbDecrypted = NULL;
        *pcbDecrypted = 0;
        return(FALSE);
    }
        
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Display FDecrypt usage.
//--------------------------------------------------------------------------
void
Usage(void)
{
    printf("Usage: FDecrypt [options] <EncryptedFileName> <ClearTextFileName> \n");
    printf("Options are:\n");
    printf("  -FIX          - Fix by loading sp3crmsg.dll\n");
    exit(1);
}

//+-------------------------------------------------------------------------
//  Generalized error routine
//--------------------------------------------------------------------------
#define PRINTERROR(psz, err)	_PrintError((psz), (err), __LINE__)
void
_PrintError(char *pszMsg, DWORD err, DWORD line)
{
    printf("%s failed on line %u: %u(%x)\n", pszMsg, line, err, err);
}

//+-------------------------------------------------------------------------
//  Main program. Open a file to decyrpt,
//  decrypts it and then writes the clear text
//  file out.
//--------------------------------------------------------------------------
int __cdecl
main(int argc, char * argv[])
{

    DWORD               dwExitValue         = 0;
    DWORD               i, j;
    
    HCERTSTORE          hMyStore            = NULL;
    
    HANDLE hFileOut                         = INVALID_HANDLE_VALUE;
    HANDLE hFile                            = INVALID_HANDLE_VALUE;
    DWORD  cbFile                           = 0;
    HANDLE hMap                             = NULL;
    PBYTE  pbFile                           = NULL;

    PBYTE  pbDecryptedBlob                  = NULL;
    DWORD  cbDecryptedBlob                  = 0;
    
    CRYPT_DECRYPT_MESSAGE_PARA    decryptInfo;
    DWORD               cb                  = 0;

    HMODULE hDll = NULL;
    BOOL fFix = FALSE;

    // Advance past fdencrypt.exe and check for leading options
    while (--argc > 0) {
        if (**++argv != '-')
            break;

        if (0 == _stricmp(argv[0], "-FIX"))
            fFix = TRUE;
        else {
            printf("Bad option: %s\n", argv[0]);
            Usage();
        }
    }
    
    // must have the parameters
    if(argc != 2)
        Usage();

    if (fFix) {
        if (NULL == (hDll = LoadLibraryA("sp3crmsg.dll"))) 
        {
            PRINTERROR("LoadLibraryA(sp3crmsg.dll)", GetLastError());
            goto ErrCleanUp;
        }
    }

    // Open the MY store
    if( (hMyStore = CertOpenSystemStore(NULL, "My")) == NULL ) 
    {
        PRINTERROR("CertOpenSystemStore", GetLastError());
        goto ErrCleanUp;
    }

    // Read in the file.
    if(
    
        // open the file to decrypt
        (hFile =  CreateFileA(
            argv[0],	            // pointer to name of the file 
            GENERIC_READ,	        // access (read-write) mode 
            FILE_SHARE_READ,	    // share mode 
            NULL,	                // pointer to security descriptor 
            OPEN_EXISTING,	        // how to create 
            FILE_ATTRIBUTE_NORMAL,	// file attributes 
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        // create a file mapping object         
        (hMap = CreateFileMapping(
            hFile,	                // handle to file to map 
            NULL,	                // optional security attributes 
            PAGE_READONLY,	        // protection for mapping object 
            0,	                    // high-order 32 bits of object size  
            0,	                    // low-order 32 bits of object size  
            NULL 	                // name of file-mapping object 
            ))  == NULL                     ||

        // Map the file into the address space
        (pbFile = (PBYTE) MapViewOfFileEx(
            hMap,	                // file-mapping object to map into address space  
            FILE_MAP_READ,	        // access mode 
            0,	                    // high-order 32 bits of file offset 
            0,	                    // low-order 32 bits of file offset 
            0,	                    // number of bytes to map 
            NULL 	                // suggested starting address for mapped view 
            )) == NULL                                 
        ) 
    {

        PRINTERROR("File Open", GetLastError());
        goto ErrCleanUp;
    }

    // get the size of the file         
    if( (cbFile = GetFileSize(
            hFile,	                // handle of file to get size of
            NULL 	                // address of high-order word for file size
            )) == 0 
        ) 
    {
        printf("File %s has a 0 length.\n", argv[0]);
        goto ErrCleanUp;
    }

    // at this point we have a file mapping, go ahead and decrypt the file
    
    // Initialize the decryption structure.
    // Since the MY store is the store with 
    // the private keys, only check the MY store
    memset(&decryptInfo, 0, sizeof(CRYPT_DECRYPT_MESSAGE_PARA));
    decryptInfo.cbSize = sizeof(CRYPT_DECRYPT_MESSAGE_PARA);
    decryptInfo.dwMsgAndCertEncodingType =
        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    decryptInfo.cCertStore                  = 1;
    decryptInfo.rghCertStore                = &hMyStore;

    // decrypt the data
    if(!MCryptDecryptMessage(
            &decryptInfo,
            pbFile,
            cbFile,
            &pbDecryptedBlob,
            &cbDecryptedBlob,
            NULL
            )
        )
    {
        PRINTERROR("MCryptEncryptMessage", GetLastError());
        goto ErrCleanUp;
    }

    // write out the clear text file
    if(
    
        // open the output file
        (hFileOut =  CreateFileA(
            argv[1],	            // pointer to name of the file 
            GENERIC_WRITE,	        // access (read-write) mode 
            FILE_SHARE_READ,	    // share mode 
            NULL,	                // pointer to security descriptor 
            CREATE_ALWAYS,	        // how to create 
            FILE_ATTRIBUTE_NORMAL,	// file attributes 
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        //write to the decrypted data to the file
        !WriteFile(
            hFileOut,	            // handle to file to write to 
            pbDecryptedBlob,	    // pointer to data to write to file 
            cbDecryptedBlob,	    // number of bytes to write 
            &cb,	                // pointer to number of bytes written 
            NULL 	                // pointer to structure needed for overlapped I/O
            )
        )
     {
        PRINTERROR("File Write", GetLastError());
        goto ErrCleanUp;
     }


    CleanUp:
        if(hDll)
            FreeLibrary(hDll);

        if(hMap != NULL)
            CloseHandle(hMap);
        
        if(hFile != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFile);
            
        if(hFileOut != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFileOut);

        if(hMyStore != NULL)
            CertCloseStore(hMyStore, 0);

        if(pbDecryptedBlob != NULL)
            free(pbDecryptedBlob);

    return(dwExitValue);

    ErrCleanUp:
        dwExitValue = 1;
        goto CleanUp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\crmsgp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crmsgp.h
//
//  Contents:   Private Header for Cryptographic Message APIs
//
//  History:    12-Dec-96   kevinr    created
//
//--------------------------------------------------------------------------

#ifndef __WINCRMSG_P_INCLUDED__
#define __WINCRMSG_P_INCLUDED__

#if DBG
#define STATIC
#else
#define STATIC static
#endif

#ifndef OSS_CRYPT_ASN1
#define parameters_present AlgorithmIdentifier_parameters_present
#define unauthAttributes_present SignerInfo_unauthAttributes_present
#define certificates_present SignedData_certificates_present
#define crls_present SignedData_crls_present
#define date_present RecipientKeyIdentifier_date_present
#define other_present RecipientKeyIdentifier_other_present
#define content_present ContentInfo_content_present
#define authAttributes_present SignerInfoWithBlobs_authAttributes_present

#define issuerAndSerialNumber_chosen CertIdentifier_issuerAndSerialNumber_chosen
#define subjectKeyIdentifier_chosen CertIdentifier_subjectKeyIdentifier_chosen

#endif  // OSS_CRYPT_ASN1


#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define STRUCT_CBSIZE(StructName, FieldName)   \
    (offsetof(StructName, FieldName) + sizeof(((StructName *) 0)->FieldName))

#define ICM_TAG_NULL            0x00
#define ICM_TAG_CONSTRUCTED     0x20
#define ICM_TAG_SEQ             0x30
#define ICM_TAG_SET             0x31
#define ICM_TAG_OCTETSTRING     0x04
#define ICM_TAG_NULL_OCTETS     0x05
#define ICM_TAG_CONTEXT_0       0x80
#define ICM_TAG_CONTEXT_1       0x81

#define ICM_TAG_CONSTRUCTED_CONTEXT_0     (ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0)
#define ICM_TAG_CONSTRUCTED_CONTEXT_1     (ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1)

#define ICM_LENGTH_INDEFINITE   0x80


// Streaming flags
#define ICMS_QUEUE_OUTPUT_FLAG  0x80000000


typedef struct _SIMPLEBLOBHEADER {
    ALG_ID  aiEncAlg;
} SIMPLEBLOBHEADER, *PSIMPLEBLOBHEADER;

#define SIZE_OSS_OID    16

extern ObjectID aoidMessages[];

extern const CRYPT_OBJID_TABLE aotSign[];
extern const DWORD COUNTOF_aotSign;

extern const LPSTR apszObjIdPKCS7[];
extern const DWORD COUNTOF_apszObjIdPKCS7;

extern const CRYPT_OBJID_TABLE aotContentEncryption[];
extern const DWORD COUNTOF_aotContentEncryption;

extern const LPSTR pszObjIdDataType;
extern const LPSTR pszObjIdContentType;
extern const LPSTR pszObjIdMessageDigest;

#define INVALID_ENCODING_SIZE (0xFFFFFFFE)

#define ZEROSTRUCT(arg) (memset( &arg, 0, sizeof(arg)))

typedef struct _ICM_BUFFER {
    PBYTE   pbData;
    DWORD   cbSize;
    DWORD   cbUsed;
    DWORD   cbDead;
} ICM_BUFFER, *PICM_BUFFER;

#define ICM_BUFFER_SIZE_INCR    1024

void *
WINAPI
ICM_Alloc(
    IN size_t cbBytes);

void *
WINAPI
ICM_AllocZero(
    IN size_t cb);

void *
WINAPI
ICM_ReAlloc(
    IN void     *pvOrg,
    IN size_t   cb);

void
WINAPI
ICM_Free(
    IN void *pv);

BOOL
WINAPI
ICM_AppendBlob(
    PCRYPT_DATA_BLOB    pblob,
    const BYTE          *pbIn,
    DWORD               cbIn);

BOOL
WINAPI
ICM_CopyOssObjectIdentifier(
    OUT ObjectID    *poiDst,
    IN  ObjectID    *poiSrc);


typedef struct _CONTENT_INFO {
    LPSTR           pszContentType;
    CRYPT_DATA_BLOB content;
} CONTENT_INFO, *PCONTENT_INFO;

class CHashList;
class CBlobList;
class CSignerList;
class COssDecodeInfoList;

#ifdef CMS_PKCS7
class CHashNode;
typedef struct _SIGNER_ENCODE_DATA_INFO {
    HCRYPTPROV          hCryptProv;
    DWORD               dwKeySpec;
    CHashNode           *pHashNode;
} SIGNER_ENCODE_DATA_INFO, *PSIGNER_ENCODE_DATA_INFO;
#endif  // CMS_PKCS7

typedef struct _SIGNED_DATA_INFO {
    int             version;
    CBlobList       *pAlgidList;
    PCONTENT_INFO   pci;
    CBlobList       *pCertificateList;
    CBlobList       *pCrlList;
    CSignerList     *pSignerList;
} SIGNED_DATA_INFO, *PSIGNED_DATA_INFO;

typedef struct _CRYPT_MSG_INFO {
    CRITICAL_SECTION    CriticalSection;
    BOOL                fInitializedCriticalSection;
    LONG                lRefCnt;
    HCRYPTPROV          hCryptProv;             // decode
    BOOL                fDefaultCryptProv;      // decode
    DWORD               dwKeySpec;              // key to use in CryptSignHash
    DWORD               dwEncodingType;         // encode
    DWORD               dwMsgType;
    DWORD               dwFlags;
    VOID                *pvMsg;
    BOOL                fEncoding;
    DWORD               dwPhase;
    LPSTR               pszInnerContentObjID;
    // signed or signed-and-enveloped
    PSIGNED_DATA_INFO   psdi;
    // signed, digested or signed-and-enveloped
    BOOL                fDetached;
    CHashList           *pHashList;
#ifdef CMS_PKCS7
    // encode signed
    DWORD               cSignerEncodeDataInfo;
    PSIGNER_ENCODE_DATA_INFO rgSignerEncodeDataInfo;
#endif  // CMS_PKCS7
    // enveloped or signed-and-enveloped
    HCRYPTKEY           hkeyContentCrypt;
    HCRYPTPROV          hCryptProvContentCrypt;
    CRYPT_DATA_BLOB     Plaintext;
    DWORD               dwDecryptedRecipientIndex;
#ifdef CMS_PKCS7
    DWORD               dwDecryptedRecipientEncryptedKeyIndex;
#endif  // CMS_PKCS7
#ifndef CMS_PKCS7
    PBYTE               pbEncryptParameters;        // encoded and allocated
#endif  // CMS_PKCS7
    // streaming
    PCMSG_STREAM_INFO   pStreamInfo;
    DWORD               aflStream;
    DWORD               aflDecode;
    BOOL                fStreamCallbackOutput;
    BOOL                fStreamContentExtracted;
    ICM_BUFFER          bufDecode;
    ICM_BUFFER          bufEncode;
    ICM_BUFFER          bufOutput;
    ICM_BUFFER          bufCrypt;
    ICM_BUFFER          bufPendingCrypt;
    DWORD               cbBlockSize;
    BOOL                fBlockCipher;
    DWORD               cEndNullPairs;          // decode
    DWORD               cInnerNullPairs;        // decode
    DWORD               cLevelIndefiniteInner;  // decode
    DWORD               cbDefiniteRemain;       // decode
    DWORD               cbContentInfo;          // decode
    ObjectIdentifierType *pooid;                // decode
    DWORD               aflOuter;               // decode
    DWORD               aflInner;               // decode
    COssDecodeInfoList  *plDecodeInfo;          // decode

#ifdef CMS_PKCS7
    // Optional OriginatorInfo for decoded CMS EnvelopedData
    CBlobList           *pCertificateList;
    CBlobList           *pCrlList;

    // Misc allocations, such as, Algorithm parameters
    CBlobList           *pFreeList;
#endif  // CMS_PKCS7

} CRYPT_MSG_INFO, *PCRYPT_MSG_INFO;


//--------------------------------------------------------------------------
// Decoding progress flags
#define ICMS_DECODED_PREFIX                 0x00000001
#define ICMS_DECODED_CONTENT_START          0x00000002
#define ICMS_DECODED_CONTENT                0x00000004
#define ICMS_DECODED_SUFFIX                 0x00000008

#define ICMS_DECODED_CONTENTINFO_SEQ        0x00000010
#define ICMS_DECODED_CONTENTINFO_CONTENT    0x00000020
//#define ICMS_DECODED_                       0x00000040
//#define ICMS_DECODED_                       0x00000080

// Signed
#define ICMS_DECODED_SIGNED_SEQ             0x00000100
#define ICMS_DECODED_SIGNED_VERSION         0x00000200
#define ICMS_DECODED_SIGNED_DIGESTALGOS     0x00000400
#define ICMS_DECODED_SIGNED_CONTENTINFO     0x00000800
#define ICMS_DECODED_SIGNED_CERTIFICATES    0x00001000
#define ICMS_DECODED_SIGNED_CRLS            0x00002000
#define ICMS_DECODED_SIGNED_SIGNERINFOS     0x00004000
//#define ICMS_DECODED_                       0x00008000

// Enveloped
#define ICMS_DECODED_ENVELOPED_SEQ          0x00000100
#define ICMS_DECODED_ENVELOPED_VERSION      0x00000200
#define ICMS_DECODED_ENVELOPED_RECIPINFOS   0x00000400
#define ICMS_DECODED_ENVELOPED_ECISEQ       0x00000800
#define ICMS_DECODED_ENVELOPED_ECITYPE      0x00001000
#define ICMS_DECODED_ENVELOPED_ECIALGID     0x00002000
#define ICMS_DECODED_ENVELOPED_ECICONTENT   0x00004000
#ifdef CMS_PKCS7
#define ICMS_DECODED_ENVELOPED_ORIGINATOR   0x00008000
#define ICMS_DECODED_ENVELOPED_ATTR         0x00010000
#endif  // CMS_PKCS7
//#define ICMS_DECODED_                       0x00020000

// Misc flags
#define ICMS_INNER_OCTETSTRING              0x00100000
#define ICMS_FINAL                          0x00200000
#define ICMS_NONBARE                        0x00400000
#define ICMS_RAW_DATA                       0x00800000
#define ICMS_PROCESS_CONTENT_BEGUN          0x01000000
#define ICMS_PROCESS_CONTENT_DONE           0x02000000


// Used in streaming decode parsing
#define ICMS_TOKEN_INDEFINITE           1
#define ICMS_TOKEN_NULLPAIR             2
#define ICMS_TOKEN_DEFINITE             3
#define ICMS_TOKEN_INCOMPLETE           4


#if DBG
#define CMSGP_STREAM_CRYPT_BLOCK_COUNT         1
#else
#define CMSGP_STREAM_CRYPT_BLOCK_COUNT       128
#endif
#define CMSGP_STREAM_MAX_ENCRYPT_BUFFER     1024


typedef struct _OSS_DECODE_INFO {
    int         iPDU;
    PVOID       pvPDU;
} OSS_DECODE_INFO, *POSS_DECODE_INFO;

DEFINE_LIST_AND_NODE_CLASS( COssDecodeInfoList, COssDecodeInfoNode, OSS_DECODE_INFO);


DEFINE_LIST_AND_NODE_CLASS( CBlobList, CBlobNode, CRYPT_DATA_BLOB);


typedef struct _SIGNER_DATA_INFO {
    CRYPT_DATA_BLOB     blob;
    CBlobList           *pUnauthAttrList;
} SIGNER_DATA_INFO, *PSIGNER_DATA_INFO;

DEFINE_LIST_AND_NODE_CLASS( CSignerList, CSignerNode, SIGNER_DATA_INFO);

typedef struct _ICM_HASH_INFO {
#ifndef CMS_PKCS7
    HCRYPTPROV          hCryptProv;
#endif  // CMS_PKCS7
    DWORD               dwAlgoCAPI;
    HCRYPTHASH          hHash;
    CRYPT_HASH_BLOB     HashBlob;
} ICM_HASH_INFO, *PICM_HASH_INFO;

DEFINE_LIST_AND_NODE_CLASS( CHashList, CHashNode, ICM_HASH_INFO);


extern HCRYPTASN1MODULE  ICM_hAsn1Module;
__inline ASN1encoding_t ICM_GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(ICM_hAsn1Module);
}
__inline ASN1decoding_t ICM_GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(ICM_hAsn1Module);
}

BOOL
WINAPI
ICM_GetLengthOctets(
    IN DWORD            cbContent,
    OUT OPTIONAL PBYTE  pbOut,
    IN OUT PDWORD       pcbOut);

VOID
WINAPI
ICM_SetLastError(
    IN DWORD    dwError);

BOOL
WINAPI
ICM_GetCAPI(
    IN DWORD                        dwGroupId,
    IN PCRYPT_ALGORITHM_IDENTIFIER  pai,
    OUT PDWORD                      pdwAlgId);

LONG
WINAPI
ICM_ObjIdToIndex(
    IN ObjectID *poi);

BOOL
WINAPI
ICM_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2);

BOOL
WINAPI
ICM_IsData(
    IN  LPSTR   pszContentType);

BOOL
WINAPI
ICM_InsertTailBlob(
    IN OUT CBlobList    *pBlobList,
    IN Any              *pAny);

BOOL
WINAPI
ICM_InsertTailSigner(
    IN OUT CSignerList  *pSignerList,
    IN Any              *pAny);

BOOL
WINAPI
ICM_CreateHashList(
    IN HCRYPTPROV       hCryptProv,
    IN OUT CHashList    **ppHashList,
    IN CBlobList        *pAlgidList);

BOOL
WINAPI
ICM_UpdateListDigest(
    IN CHashList    *pHashList,
    IN const BYTE   *pbData,
    IN DWORD        cbData);

#ifdef CMS_PKCS7
BOOL
WINAPI
ICM_IsDuplicateSignerEncodeHashAlgorithm(
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN PCMSG_SIGNER_ENCODE_INFO pNewSigner,
    OUT OPTIONAL DWORD *pdwPrevIndex = NULL
    );

BOOL
WINAPI
ICM_FillSignerEncodeEncryptedDigests(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fMaxLength);

#else

BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo   *psi,
    IN LPSTR        pszInnerContentObjID,
    IN CHashNode    *pnHash,
    IN DWORD        dwKeySpec,
    IN BOOL         fMaxLength);
#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_GetKeyBlockSize(
    IN HCRYPTKEY        hkey,
    OUT PDWORD          pcbBlock,
    OUT OPTIONAL PBOOL  pfBlockCipher);

#ifdef CMS_PKCS7
BOOL
WINAPI
ICM_InitializeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    );

void
WINAPI
ICM_FreeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    );

BOOL
WINAPI
ICM_FillOssCmsRecipientInfos(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT CmsRecipientInfos *poris,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    );
void
WINAPI
ICM_FreeOssCmsRecipientInfos(
    IN OUT CmsRecipientInfos *poris
    );

#else

//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_ExportEncryptKey
BOOL
WINAPI
ICM_GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2]);

// rgcbData[1] is the dwEncryptFlags passed from ICM_GenEncryptKey
BOOL
WINAPI
ICM_ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2]);

BOOL
WINAPI
ICM_ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey);

#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_EncryptBuffer(
    IN HCRYPTKEY    hkeyEncrypt,
    HCRYPTHASH      hHash,
    IN const BYTE   *pbPlain,
    IN DWORD        cbPlain,
    OUT PBYTE       *ppbCipher,
    OUT PDWORD      pcbCipher);

BOOL
WINAPI
ICMS_SetDecryptKey(
    IN PCRYPT_MSG_INFO  pcmi,
    IN HCRYPTKEY        hkeyDecrypt);

BOOL
WINAPI
ICMS_ExtractContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbDER,
    IN DWORD            cbDER,
    OUT PDWORD          pcbContent,
    OUT const BYTE      **ppbContent);

BOOL
WINAPI
ICMS_OpenToEncodeData(
    IN PCRYPT_MSG_INFO          pcmi);

BOOL
WINAPI
ICMS_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_UpdateDecodingInner(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_OpenToEncodeSignedData(
    IN PCRYPT_MSG_INFO          pcmi,
    IN PCMSG_SIGNED_ENCODE_INFO psmei);

BOOL
WINAPI
ICMS_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_OpenToEncodeEnvelopedData(
    IN PCRYPT_MSG_INFO              pcmi,
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei);

BOOL
WINAPI
ICMS_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlain,
    IN DWORD            cbPlain,
    IN BOOL             fFinal);

DWORD
WINAPI
ICM_LengthSigned(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN DWORD                    dwFlags,
    IN LPSTR                    pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent);

DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent);

// OCTET STRING callback, used for streaming
typedef BOOL (WINAPI *POSTRCALLBACK)(
        IN const void       *pvArg,
        IN OUT PICM_BUFFER  pbuf,
        IN OUT PDWORD       pcbPending,
        IN BOOL             fFinal);

BOOL
WINAPI
ICMS_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData);


BOOL
WINAPI
ICM_GetSignerIdFromSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    OUT PCERT_ID                pSignerId);

#endif  // __WINCRMSG_P_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\tools\pesigmgr\pesigmgr.cxx ===
/*++

Copyright (C) 1995-96  Microsoft Corporation

Module Name:

    certify.cxx

Abstract:

    This is the command line tool to manipulate certificates on an executable image.

Author:  Robert Reichel (robertre)   Feb 12, 1996

Revision History:



--*/

//#define UNICODE 1
//#define _UNICODE 1


#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <malloc.h>

//
// Private prototypes
//

LPWIN_CERTIFICATE
GetCertFromImage(
    LPCTSTR ImageName,
    DWORD Index
    );

SaveCertificate(
    LPCTSTR OutputFileName,
    LPCTSTR ImageName,
    DWORD CertIndex
    );

BOOL
RemoveCertificateFromImage(
    LPCTSTR ImageName,
    DWORD Index
    );

BOOL
AddCertificateToImage(
    LPCTSTR ImageName,
    LPCTSTR CertificateName,
    WORD CertificateType,
    PDWORD Index
    );

VOID
PrintCertificate(
    LPWIN_CERTIFICATE Certificate,
    DWORD Index
    );

BOOL
GetCertHeaderFromImage(
    IN LPCTSTR ImageName,
    IN DWORD Index,
    OUT LPWIN_CERTIFICATE CertificateHeader
    );

#define TYPE_X509  TEXT("X509")
#define TYPE_PKCS7 TEXT("PKCS7")
#define TYPE_UNKNOWN TEXT("Unknown")

//
// Globals
//

BOOL fVerbose = FALSE;

void
PrintUsage(
    VOID
    )
{
    fputs("Usage: PESIGMGR [switches] image-name \n"
          "            [-?] display this message\n"
          "            [-l] list the certificates in an image\n"
          "            [-a:<Filename>] add a certificate file to an image\n"
          "            [-r:<index>]    remove certificate <index> from an image\n"
          "            [-s:<Filename>] used with -r to save the removed certificate\n"
          "            [-t:<CertType>] used with -a to specify the type of the certificate\n"
          "            where CertType may be X509 or PKCS7 [default is X509]\n",
          stderr
         );
    exit(-1);
}

#if 0

PWSTR
GetArgAsUnicode(
    LPSTR s
    )
{
    ULONG n;
    PWSTR ps;

    n = strlen( s );
    ps = (PWSTR)HeapAlloc( GetProcessHeap(),
                    0,
                    (n + 1) * sizeof( WCHAR )
                  );
    if (ps == NULL) {
        printf( "Out of memory\n" );
        }

    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             s,
                             n,
                             ps,
                             n
                           ) != (LONG)n
       ) {
        printf( "Unable to convert parameter '%s' to Unicode (%u)", (ULONG)s, GetLastError() );
        }

    ps[ n ] = UNICODE_NULL;
    return ps;
}

#endif


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOL AFlagSeen = FALSE;
    BOOL LFlagSeen = FALSE;
    BOOL RFlagSeen = FALSE;
    BOOL SFlagSeen = FALSE;
    BOOL TFlagSeen = FALSE;
    BOOL Result;

    DWORD Index;
    DWORD RFlag_CertIndex;
    WORD CertificateType = WIN_CERT_TYPE_PKCS_SIGNED_DATA;  // default

    char * CertificateName;
    char * ImageName = NULL;
    char * SFlag_CertificateFile;
    char c, *p;



    if (argc < 2) {
        PrintUsage();
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            c = *++p;
            switch (toupper( c )) {
                case '?':
                    PrintUsage();
                    break;

                case 'A':  // Add Certificate to image
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {

                        if (AFlagSeen == TRUE) {
                            PrintUsage();
                            return( 0 );
                        }

                        AFlagSeen = TRUE;
                        CertificateName = ++p;
                    }
                    break;
                case 'V':
                    {
                        fVerbose = TRUE;
                        break;
                    }

                case 'T':
                    {
                        //
                        // Specify the Type of the certificate
                        //
                        c = *++p;
                        if (c != ':') {
                            PrintUsage();
                        } else {

                            if (TFlagSeen == TRUE) {
                                PrintUsage();
                                return( 0 );
                            }

                            TFlagSeen = TRUE;
                            ++p;

                            if (_stricmp(p, TYPE_X509) == 0) {
                                CertificateType = WIN_CERT_TYPE_X509;
                                if (fVerbose) {
                                    printf("Certificate type = X509\n");
                                }
                            } else {
                                if (_stricmp(p, TYPE_PKCS7) == 0) {
                                    CertificateType = WIN_CERT_TYPE_PKCS_SIGNED_DATA;
                                    if (fVerbose) {
                                        printf("Certificate type = PKCS7\n");
                                    }
                                } else {
                                    if (fVerbose) {
                                        printf("Unrecognized Certificate type %s\n",p);
                                    }
                                    PrintUsage();
                                    return (0);
                                }
                            }
                        }
                        break;
                    }

                case 'L':  // List the certificates in an image.
                    {
                        if (LFlagSeen == TRUE) {
                            PrintUsage();
                            return( 0 );
                        }

                        LFlagSeen = TRUE;
    
                        break;
                    }

                case 'R': // Remove certificate from an image
                    {
                        c = *++p;
                        if (c != ':') {
                            PrintUsage();
                        } else {
    
                            if (RFlagSeen == TRUE) {
                                PrintUsage();
                                return( 0 );
                            }
    
                            RFlagSeen = TRUE;
    
                            //
                            // Save the index
                            //
    
                            RFlag_CertIndex = atoi(++p);
                        }
    
                        break;
                    }

                case 'G':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Generate a certificate from an image.
                    }
                    break;

                case 'S': // Save the certificate
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {

                        if (SFlagSeen == TRUE) {
                            PrintUsage();
                            return( 0 );
                        }

                        SFlagSeen = TRUE;

                        //
                        // Save the name of the file to put the cert into.
                        //

                        SFlag_CertificateFile = ++p;
                    }
                    break;

                default:
                    fprintf( stderr, "CERTIFY: Invalid switch - /%c\n", c );
                    PrintUsage();
                    break;
            }

        } else {

            //
            // Should only be a single image name here
            //

            if (ImageName != NULL) {
                PrintUsage();
                return( 0 );
            }

            ImageName = *argv;
        }
    }

    //
    // Finished processing parameters, let's do the work.
    //

    if (ImageName == NULL) {
        if (fVerbose) {
            printf("Image name not specified\n");
        }
        PrintUsage();
        return(0);
    }

    if (LFlagSeen) {

        int Index = 0;
		WIN_CERTIFICATE Certificate;

        if (SFlagSeen || RFlagSeen || AFlagSeen) {
            PrintUsage();
            return(0);
        }

        do {

            Result = GetCertHeaderFromImage( ImageName, Index, &Certificate );

            if (Result) {
                PrintCertificate( &Certificate, Index );
            }

            Index++;

        } while ( Result  );
		return( 1 );
    }

    if (AFlagSeen) {

        //
        // 'A' is not used in conjunction with R or S
        //

        if (SFlagSeen || RFlagSeen) {
            PrintUsage();
            return( 0 );
        }

        Result = AddCertificateToImage(
                     ImageName,
                     CertificateName,
                     CertificateType,
                     &Index
                     );

        if (Result) {
			if (fVerbose){
				printf("Certificate %d added\n",Index);
			}

            return( 1 );
        } else {

            if (fVerbose) {
                printf("Unable to add Certificate to %s, error = %d\n",ImageName,GetLastError());
            }
            return( 0 );
        }
    }

    if (RFlagSeen) {

        if (!SFlagSeen) {
            if (fVerbose) {
                fputs("-R requires -S\n",stderr);
            }
           PrintUsage();
           return(0);
        }

        //
        // Make sure we can save the certificate data before
        // we remove it from the image
        //

        Result = SaveCertificate(
                     SFlag_CertificateFile,
                     ImageName,
                     RFlag_CertIndex
                     );

        if (!Result) {
            if (fVerbose) {
                printf("Unable to save certificate to file %s, error = %d\n",SFlag_CertificateFile,GetLastError());
            }
            return(0);
        }

        //
        // Now that the certificate is safe, remove it from the image
        //

        Result = RemoveCertificateFromImage(
                    ImageName,
                    RFlag_CertIndex
                    );

        if (!Result) {
            if (fVerbose) {
                printf("Unable to remove certificate, error = %d\n",GetLastError());
            }
            return(0);
        }
    }

    if (SFlagSeen && !RFlagSeen) {
        PrintUsage();
        return( 0 );
    }

    return 0;
}


VOID
PrintCertificate(
    LPWIN_CERTIFICATE Certificate,
    DWORD Index
    )
{
    char * CertType;

    switch (Certificate->wCertificateType) {
        case WIN_CERT_TYPE_X509:
            {
                CertType = TYPE_X509;
                break;
            }
        case WIN_CERT_TYPE_PKCS_SIGNED_DATA:
            {

                CertType = TYPE_PKCS7;
                break;
            }
        default:
            {
                CertType = TYPE_UNKNOWN;
                break;
            }
    }

    printf("\nCertificate %3d Revision %1d Type %8s",Index,Certificate->wRevision, CertType);

    return;
}


BOOL
AddCertificateToImage(
    IN LPCTSTR ImageName,
    IN LPCTSTR CertificateName,
    IN WORD CertificateType,
    OUT PDWORD Index
    )
/*++

Routine Description:

    Adds a certificate to an image, and returns its index.

Arguments:

    ImageName - Provides the full name and path to the image to be 
        modified.

    CertificateName - Provides the full name and path to a file containing 
        the certificate to be added to the image.

    CertificateType - Provides the type of the certificate being added.  
        This type will be placed in the dwType field of the resulting 
        WIN_CERTIFICATE structure.

    Index - Returns the index of the certificate after it is placed in the 
        image.


Return Value:

    TRUE on success, FALSE on failure.  More information is available via 
        GetLastError().

--*/
{
    HANDLE CertificateHandle;
    DWORD CertificateFileSize;
    DWORD CertificateSize;
    LPWIN_CERTIFICATE Certificate = NULL;
    BOOL Result = FALSE;
    HANDLE ImageHandle;
    DWORD BytesRead;

    //
    // Attempt to open the certificate file
    //

    if ((CertificateHandle = CreateFile(CertificateName,
                                        GENERIC_READ,
                                        0,
                                        0,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) == INVALID_HANDLE_VALUE)
    {
        if (fVerbose) {
            printf("Unable to open %s, error = %d\n",CertificateName,GetLastError());
        }
        goto ErrorReturn;
    }

    //
    // Read the certificate data into memory
    //

    CertificateFileSize = GetFileSize( CertificateHandle, NULL );
    CertificateSize = CertificateFileSize + (sizeof( WIN_CERTIFICATE ) - sizeof( BYTE ));

    //
    // Hack to make certs 8 byte aligned
    //

//    CertificateSize += (8 - (CertificateSize % 8));

    Certificate = (LPWIN_CERTIFICATE)malloc( CertificateSize );
    if (NULL == Certificate) {
        if (fVerbose) {
            printf("malloc failed\n");
        }
        goto ErrorReturn;
    }

    Certificate->dwLength = CertificateSize;
    Certificate->wRevision = WIN_CERT_REVISION_1_0;
    Certificate->wCertificateType = CertificateType;
    Result = ReadFile( CertificateHandle,
                       &Certificate->bCertificate,
                       CertificateFileSize,
                       &BytesRead,
                       NULL                // Overlapped
                       );

    if (!Result) {
        if (fVerbose) {
            printf("Unable to read Certificate file, error = %d\n",GetLastError());
        }
        goto ErrorReturn;
    }

    ImageHandle = CreateFile( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

    if (ImageHandle == INVALID_HANDLE_VALUE) {
        if (fVerbose) {
            printf("Unable to open image file %s, error = %d\n",ImageName,GetLastError());
        }
        goto ErrorReturn;
    }

    Result = ImageAddCertificate( ImageHandle,
                                  Certificate,
                                  Index
                                  );

    if (!Result) {
        if (fVerbose) {
            printf("ImageAddCertificate failed, error = %d\n",GetLastError());
        }
        goto ErrorReturn;
    }

CommonReturn:
    if (Certificate)
        free(Certificate);

    return( Result );

ErrorReturn:
    Result = FALSE;
    goto CommonReturn;
}

BOOL
GetCertHeaderFromImage(
    IN LPCTSTR ImageName,
    IN DWORD Index,
    OUT LPWIN_CERTIFICATE CertificateHeader
    )
{
    HANDLE ImageHandle;
    BOOL Result;

    ImageHandle = CreateFile( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

    if (ImageHandle == INVALID_HANDLE_VALUE) {
        if (fVerbose) {
            printf("Unable to open image file %s\n",ImageName);
        }
        return( FALSE );
    }

    Result = ImageGetCertificateHeader(
                 ImageHandle,
                 Index,
                 CertificateHeader
                 );

    CloseHandle( ImageHandle );

    if (!Result) {
        if (fVerbose) {
            printf("\nUnable to retrieve certificate header from %s, index=%d, error = %d\n",ImageName,Index,GetLastError());
        }
        return( FALSE );
    }

    return( TRUE );

}

LPWIN_CERTIFICATE
GetCertFromImage(
    IN LPCTSTR ImageName,
    IN DWORD Index
    )

/*++

Routine Description:

    Returns a copy of the specified certificate.

Arguments:

    ImageName - Provides the full path to the image file containing the 
        certificate.

    Index - Provides the index of the desired certificate in the image.

Return Value:

    NULL on failure.

    On Success, returns a pointer to a filled in WIN_CERTIFICATE 
        structure, which may be freed by called free().


--*/

{
    HANDLE ImageHandle;
    LPWIN_CERTIFICATE Certificate;
    DWORD RequiredLength = 0;
    BOOL Result;

    ImageHandle = CreateFile( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

    if (ImageHandle == INVALID_HANDLE_VALUE) {
        if (fVerbose) {
            printf("Unable to open image file %s\n",ImageName);
        }
        return( NULL );
    }

    Result = ImageGetCertificateData(
                 ImageHandle,
                 Index,
                 NULL,
                 &RequiredLength
                 );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        if (fVerbose) {
            printf("Unable to retrieve certificate data from %s, error = %d\n",ImageName,GetLastError());
        }
        return(NULL);
    }

    Certificate = (LPWIN_CERTIFICATE) malloc( RequiredLength );

    if (Certificate == NULL) {
        if (fVerbose) {
            printf("Out of memory in GetCertFromImage\n");
        }
        return( NULL );
    }

    Result = ImageGetCertificateData(
                 ImageHandle,
                 Index,
                 Certificate,
                 &RequiredLength
                 );

    CloseHandle( ImageHandle );

    if (!Result) {
        if (fVerbose) {
            printf("Unable to retrieve certificate from %s, error = %d\n",ImageName,GetLastError());
        }
        return( NULL );
    }

    return( Certificate );
}


BOOL
RemoveCertificateFromImage(
    LPCTSTR ImageName,
    DWORD Index
    )
{
    HANDLE ImageHandle;
    BOOL Result;

    if (fVerbose) {
        printf("Removing certificate index %d from %s\n",Index,ImageName);
    }

    ImageHandle = CreateFile( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

    if (ImageHandle == INVALID_HANDLE_VALUE) {
        printf("Unable to open image file %s\n",ImageName);
        return( FALSE );
    }

    Result = ImageRemoveCertificate(
                 ImageHandle,
                 Index
                 );

    if (!Result) {
        printf("Unable to remove certificate from %s, error = %d\n",ImageName,GetLastError());
        return( FALSE );
    }

    CloseHandle( ImageHandle );

    return( TRUE );

}

BOOL
SaveCertificate(
    LPCTSTR OutputFileName,
    LPCTSTR ImageName,
    DWORD CertIndex
    )
{
    DWORD Length;
    BOOL Result;
    DWORD BytesWritten = 0;
    LPWIN_CERTIFICATE Certificate;
    HANDLE CertificateHandle;

    Certificate = GetCertFromImage( ImageName, CertIndex );

    if (Certificate == NULL) {
        if (fVerbose) {
            printf("Unable to retrieve certificate from %s, error = %d\n",ImageName,GetLastError());
        }
        return( FALSE );
    }

    Length = Certificate->dwLength - sizeof( WIN_CERTIFICATE ) + sizeof( BYTE );

    //
    // Attempt to open the certificate file
    //

    if ((CertificateHandle = CreateFile(OutputFileName,
                                        GENERIC_WRITE,
                                        0,
                                        0,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) == INVALID_HANDLE_VALUE)
    {
        printf("Unable to create %s, error = %d\n",OutputFileName,GetLastError());
        return( FALSE );
    }

    Result = WriteFile( CertificateHandle,
                        &Certificate->bCertificate,
                        Length,
                        &BytesWritten,
                        NULL                // Overlapped
                        );

    if (!Result) {
        printf("Unable to save certificate to file %s, error = %d\n",OutputFileName,GetLastError());
        return( FALSE );
    }

    CloseHandle( CertificateHandle );

    free( Certificate );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\msgasn1.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msgasn1.cpp
//
//  Contents:   Conversion APIs to/from ASN.1 data structures
//
//  Functions:  ICM_Asn1ToAttribute
//              ICM_Asn1ToAlgorithmIdentifier
//              ICM_Asn1FromAlgorithmIdentifier
//
//  History:    16-Apr-96   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

void *ICM_Alloc( IN size_t cbBytes);
void ICM_Free( IN void *pv);

//+-------------------------------------------------------------------------
//  Convert an CRYPT_ATTRIBUTE to an ASN1 Attribute
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAttribute(
    IN PCRYPT_ATTRIBUTE       patr,
    OUT Attribute       *poatr)
{
    BOOL        fRet;
    DWORD       i;
    Any         *pAny;
    PCRYPT_ATTR_BLOB  pblob;

    DWORD       cbValue;
    PBYTE       pbValue;

    for (i=patr->cValue, pblob=patr->rgValue, cbValue = 0;
            i>0;
            i--, pblob++) {
        cbValue += pblob->cbData;
    }

    poatr->attributeType.count = 16;
    if (!PkiAsn1ToObjectIdentifier(
            patr->pszObjId,
            &poatr->attributeType.count,
            poatr->attributeType.value))
        goto PkiAsn1ToObjectIdentifierError;
    poatr->attributeValue.value = (Any *)ICM_Alloc(
        patr->cValue * sizeof(Any) + cbValue);
    if (NULL == poatr->attributeValue.value)
        goto AttributeValueMallocError;
    poatr->attributeValue.count = patr->cValue;

    pbValue = (PBYTE) (poatr->attributeValue.value + patr->cValue);
    for (i=patr->cValue, pAny=poatr->attributeValue.value, pblob=patr->rgValue;
            i>0;
            i--, pAny++, pblob++) {
        DWORD cbData = pblob->cbData;

        if (cbData)
            memcpy(pbValue, pblob->pbData, cbData);
        pAny->length = cbData;
        pAny->value  = pbValue;
        pbValue += cbData;
    }

    assert(pbValue == ((PBYTE) (poatr->attributeValue.value + patr->cValue)) +
        cbValue);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(AttributeValueMallocError)  // error already set
}


//+-------------------------------------------------------------------------
//  Convert an CRYPT_ALGORITHM_IDENTIFIER to an ASN1 AlgorithmIdentifier
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    OUT AlgorithmIdentifier *pAsn1AlgId)
{
    BOOL    fRet;
    static BYTE abDerNULL[] = {5, 0};


    pAsn1AlgId->algorithm.count = 16;
    if (!PkiAsn1ToObjectIdentifier(
            pai->pszObjId,
            &pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value))
        goto PkiAsn1ToObjectIdentifierError;
    pAsn1AlgId->bit_mask = parameters_present;
    if (0 == pai->Parameters.cbData) {
        pAsn1AlgId->parameters.length = sizeof( abDerNULL);
        pAsn1AlgId->parameters.value = abDerNULL;
    } else {
        pAsn1AlgId->parameters.length = pai->Parameters.cbData;
        pAsn1AlgId->parameters.value = pai->Parameters.pbData;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
}


//+-------------------------------------------------------------------------
//  Convert an ASN1 AlgorithmIdentifier to an CRYPT_ALGORITHM_IDENTIFIER
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1FromAlgorithmIdentifier(
    IN AlgorithmIdentifier *pAsn1AlgId,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai)
{
    DWORD   cbObjId;
    BOOL    fRet;

    cbObjId = 0;
    if (!PkiAsn1FromObjectIdentifier(
            pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value,
            NULL,
            &cbObjId))
        goto PkiAsn1FromObjectIdentifierSizeError;
    pai->pszObjId = (LPSTR)ICM_Alloc( cbObjId);
    if (!PkiAsn1FromObjectIdentifier(
            pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value,
            pai->pszObjId,
            &cbObjId))
        goto PkiAsn1FromObjectIdentifierError;
    if (pAsn1AlgId->bit_mask & parameters_present) {
        pai->Parameters.cbData = pAsn1AlgId->parameters.length;
        pai->Parameters.pbData = (PBYTE)pAsn1AlgId->parameters.value;
    } else {
        pai->Parameters.cbData = 0;
        pai->Parameters.pbData = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(PkiAsn1FromObjectIdentifierSizeError)
TRACE_ERROR(PkiAsn1FromObjectIdentifierError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\cryptoapi\pki\wincrmsg\msglen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msglen.cpp
//
//  Contents:   Cryptographic Message Length APIs
//
//  APIs:       CryptMsgCalculateEncodedLength
//
//  History:    12-Dec-96   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"


//+-------------------------------------------------------------------------
//  Calculate the length of the OBJECT IDENTIFIER encoded blob.
//  We do this by doing the encode using OSS and throwing away the result.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthObjId(
    IN LPSTR   pszObjId)
{
    DWORD           cbSize;
    DWORD           cb;
    ASN1encodedOID_t eoid;       ZEROSTRUCT(eoid); 
    ASN1encoding_t  pEnc = ICM_GetEncoder();

    if (0 == PkiAsn1DotValToEncodedOid(pEnc, pszObjId, &eoid))
        goto DotValToEncodedOidError;

    ICM_GetLengthOctets( eoid.length, NULL, &cb);
    cbSize = 1 + cb + eoid.length;                  // OBJECT IDENTIFIER

    PkiAsn1FreeEncodedOid(pEnc, &eoid);

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(DotValToEncodedOidError,CRYPT_E_OID_FORMAT)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the AlgorithmIdentifier encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN BOOL fNoNullParameters = FALSE
    )
{
    DWORD           cbSize;
    DWORD           cb;

    if (INVALID_ENCODING_SIZE == (cbSize  = ICM_LengthObjId( pai->pszObjId)))
        goto CommonReturn;
    if (!fNoNullParameters)
        cbSize += max( 2, pai->Parameters.cbData);
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // AlgorithmIdentifier seq

CommonReturn:
    return cbSize;
}


//+-------------------------------------------------------------------------
//  Calculate the length of the ContentInfo encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthContentInfo(
    IN DWORD            dwFlags,
    IN OPTIONAL LPSTR   pszContentType,
    IN DWORD            cbData,
    OUT OPTIONAL PDWORD pcbContent)
{
    DWORD           cbSize;
    DWORD           cbTmp;
    DWORD           cb;

    if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthObjId(
                pszContentType ? pszContentType : pszObjIdDataType)))
        goto LengthContentTypeError;

    if (0 == (dwFlags & CMSG_DETACHED_FLAG)) {
        cbTmp = cbData;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);

        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) &&
                        !ICM_IsData(pszContentType))
#endif  // CMS_PKCS7
                ) {
            // data, not already encoded
            // Gets its own OCTET STRING wrapper.
            cbTmp += 1 + cb;            // OCTET STRING
            ICM_GetLengthOctets( cbTmp, NULL, &cb);
        }
        cbSize += 1 + cb + cbTmp;       // [0] EXPLICIT
    }

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                   // ContentInfo seq

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthContentTypeError)     // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedContentInfo encoded blob.
//
//  The return length assumes the encrypted content is
//  encapsulated.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedContentInfo(
    IN HCRYPTKEY                    hEncryptKey,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiContentEncryption,
    IN OPTIONAL LPSTR               pszContentTypeOrg,
    IN DWORD                        cbData)
{
    DWORD       cbSize;
    DWORD       cb;
    DWORD       cbBlockSize;
    BOOL        fBlockCipher;
    DWORD       cbCipher;
    LPSTR       pszContentType = pszContentTypeOrg ? pszContentTypeOrg :
                                                     pszObjIdDataType;

    if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthObjId( pszContentType)))
        goto LengthContentTypeError;
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( paiContentEncryption)))
        goto LengthAlgorithmIdentifierError;
    cbSize += cb;

    cbCipher = cbData;
    if (0 < cbCipher) {
        if (!ICM_GetKeyBlockSize(
                hEncryptKey,
                &cbBlockSize,
                &fBlockCipher))
            goto GetEncryptBlockSizeError;

        if (fBlockCipher) {
            cbCipher += cbBlockSize;
            cbCipher -= cbCipher % cbBlockSize;
        }
    }

    ICM_GetLengthOctets( cbCipher, NULL, &cb);  // encryptedContent
    cbSize += 1 + cb + cbCipher;                // [0] IMPLICIT

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // EncryptedContentInfo seq

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthContentTypeError)
TRACE_ERROR(LengthAlgorithmIdentifierError)
TRACE_ERROR(GetEncryptBlockSizeError)
}


#ifndef CMS_PKCS7
//+-------------------------------------------------------------------------
//  Calculate the length of the IssuerAndSerialNumber encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthIssuerAndSerialNumber(
    IN PCERT_INFO   pCertInfo)
{
    DWORD           cbSize;
    DWORD           cb;

    cbSize = pCertInfo->SerialNumber.cbData;
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // SerialNumber INTEGER
    cbSize += pCertInfo->Issuer.cbData;     // Issuer already encoded
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // IssuerAndSerialNumber seq

    return cbSize;
}
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Calculate the length of the CertId encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthCertId(
    IN PCERT_ID     pCertId)
{
    DWORD           cbSize;
    DWORD           cb;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            cbSize = pCertId->IssuerSerialNumber.SerialNumber.cbData;
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // SerialNumber INTEGER
            cbSize += pCertId->IssuerSerialNumber.Issuer.cbData; // Issuer ANY
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // IssuerSerialNumber seq
            break;
        case CERT_ID_KEY_IDENTIFIER:
            cbSize = pCertId->KeyId.cbData;
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // KeyId OCTET STRING
            break;
        default:
            goto InvalidCertIdChoice;
    };

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidCertIdChoice, E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedDigest encoded blob plus the
//  algorithm identifier
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedDigestAndAlgorithm(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigestEncrypt)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSignature;
    DWORD       cbSize = 0;
    DWORD       cb;
    HCRYPTHASH  hHash = NULL;
    PCCRYPT_OID_INFO pOIDInfo;
    DWORD       dwAlgIdDigest;
    DWORD       dwAlgIdPubKey;
    DWORD       dwAlgIdFlags;
    CRYPT_ALGORITHM_IDENTIFIER aiDigestEncrypt;
    BOOL        fNoNullParameters;

    dwAlgIdPubKey = 0;
    dwAlgIdFlags = 0;
    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiDigestEncrypt->pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwAlgIdFlags = pdwExtra[0];
        }

        // Check if more than just the NULL parameters
        if (2 < paiDigestEncrypt->Parameters.cbData) {
            // Check if we should use the public key parameters
            if (0 == (dwAlgIdFlags &
                    CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG)) {
                memset(&aiDigestEncrypt, 0, sizeof(aiDigestEncrypt));
                aiDigestEncrypt.pszObjId = paiDigestEncrypt->pszObjId;
                paiDigestEncrypt = &aiDigestEncrypt;
            }
        }
    } else if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiDigestEncrypt->pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID)) {
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD))
            dwAlgIdPubKey = pdwExtra[0];
        if (2 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD))
            dwAlgIdFlags = pdwExtra[1];
    }


    if (CALG_DSS_SIGN == dwAlgIdPubKey &&
            0 == (dwAlgIdFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG))
        cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
    else {
        if (dwKeySpec == 0)
            dwKeySpec = AT_SIGNATURE;

        if (!(ICM_GetCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                paiDigest,
                &dwAlgIdDigest) ||
              ICM_GetCAPI(
                CRYPT_SIGN_ALG_OID_GROUP_ID,
                paiDigest,
                &dwAlgIdDigest)))
            goto DigestGetCAPIError;
        if (!CryptCreateHash(
                hCryptProv,
                dwAlgIdDigest,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash))
            goto CreateHashError;
        if (!CryptHashData(
                hHash,
                (PBYTE)&cb,
                sizeof(DWORD),
                0))                 // dwFlags
            goto HashDataError;

        if (CALG_NO_SIGN == dwAlgIdPubKey) {
            if (!CryptGetHashParam(
                    hHash,
                    HP_HASHVAL,
                    NULL,               // pbHash
                    &cbSignature,
                    0))                 // dwFlags
                goto GetHashParamSizeError;
        } else {
            if (!CryptSignHash(
                    hHash,
                    dwKeySpec,
                    NULL,               // description
                    0,                  // dwFlags
                    NULL,               // pb
                    &cbSignature))
                goto SignHashSizeError;
        }
    }
    ICM_GetLengthOctets( cbSignature, NULL, &cb);
    cbSize += cbSignature + cb + 1;                       // OCTET STRING

    if (0 == paiDigestEncrypt->Parameters.cbData &&
            0 != (dwAlgIdFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG))
        fNoNullParameters = TRUE;
        // NO NULL parameters
    else
        fNoNullParameters = FALSE;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier(
            paiDigestEncrypt, fNoNullParameters)))
        goto SubjectPublicKeyInfoAlgorithmError;
    cbSize += cb;

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(DigestGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(SubjectPublicKeyInfoAlgorithmError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(GetHashParamSizeError)
TRACE_ERROR(SignHashSizeError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the Digest encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthDigest(
    IN HCRYPTPROV                   hCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSize;
    DWORD       cb;
    DWORD       dwAlgIdDigest;
    HCRYPTHASH  hHash = NULL;

    if (0 == hCryptProv) {
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto GetDefaultCryptProvError;
    }

    if (!ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            paiDigest,
            &dwAlgIdDigest))
        goto DigestGetCAPIError;
    if (!CryptCreateHash(
            hCryptProv,
            dwAlgIdDigest,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!CryptHashData(
            hHash,
            (PBYTE)&cb,
            sizeof(DWORD),
            0))                 // dwFlags
        goto HashDataError;
    if (!CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            NULL,               // pbHash
            &cbSize,
            0))                 // dwFlags
        goto GetHashParamSizeError;
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // OCTET STRING

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(DigestGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(GetHashParamSizeError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the Attributes encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthAttributes(
    IN HCRYPTPROV                   hCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest,
    IN DWORD                        cAttr,
    IN PCRYPT_ATTRIBUTE             rgAttr,
    IN LPSTR                        pszInnerContentObjID,
    IN BOOL                         fAuthAttr)
{
    DWORD               cbSize = 0;
    DWORD               cbAttrS;
    DWORD               cbAttr;
    DWORD               cbTmp;
    DWORD               cb;
    PCRYPT_ATTRIBUTE    patr;
    PCRYPT_ATTR_BLOB    pblobAttr;
    DWORD               i;
    DWORD               j;
    BOOL                fDataType = !pszInnerContentObjID ||
                                    (0 == strcmp( pszInnerContentObjID, pszObjIdDataType));

    for (i=cAttr, patr=rgAttr, cbAttrS=0;
            i>0;
            i--, patr++) {
        if (0 == (cbAttr = ICM_LengthObjId( patr->pszObjId)))
            goto PatrLengthObjIdError;
        for (j=patr->cValue, pblobAttr=patr->rgValue, cbTmp=0;
                j>0;
                j--, pblobAttr++)
            cbTmp += pblobAttr->cbData;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq
    }

    if (fAuthAttr && (cAttr || !fDataType)) {
        // content type
        cbAttr = ICM_LengthObjId( szOID_RSA_contentType);
        if (INVALID_ENCODING_SIZE == (cbTmp = ICM_LengthObjId(
                        pszInnerContentObjID ?
                        pszInnerContentObjID : pszObjIdDataType)))
            goto InnerContentLengthObjIdError;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq

        // message digest
        cbAttr = ICM_LengthObjId( szOID_RSA_messageDigest);
        if (INVALID_ENCODING_SIZE == (cbTmp = ICM_LengthDigest( hCryptProv, paiDigest)))
            goto LengthDigestError;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq
    }

    if (cbAttrS) {
        ICM_GetLengthOctets( cbAttrS, NULL, &cb);
        cbSize = cbAttrS + cb + 1;          // Attributes set
    }

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(PatrLengthObjIdError)           // error already set
TRACE_ERROR(InnerContentLengthObjIdError)   // error already set
TRACE_ERROR(LengthDigestError)              // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the SignerInfos encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSignerInfos(
    IN DWORD                    cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN LPSTR                    pszInnerContentObjID
#ifdef CMS_PKCS7
    ,
    OUT BOOL                    *pfHasCmsSignerId
#endif  // CMS_PKCS7
    )
{
    DWORD                       cbSize;
    DWORD                       cbSigner;
    DWORD                       cbSignerS;
    DWORD                       cb;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DWORD                       i;
    PCRYPT_ALGORITHM_IDENTIFIER paiDigestEncrypt;
    CERT_ID                     SignerId;

#ifdef CMS_PKCS7
    *pfHasCmsSignerId = FALSE;
#endif  // CMS_PKCS7

    for (i=cSigners, psei=rgSigners, cbSignerS=0;
            i>0;
            i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
#else
            psei++) {
#endif  // CMS_PKCS7
        cbSigner = 1 + 1 + 1;               // version

        if (!ICM_GetSignerIdFromSignerEncodeInfo(psei, &SignerId))
            goto GetSignerIdError;
#ifdef CMS_PKCS7
        if (CERT_ID_ISSUER_SERIAL_NUMBER != SignerId.dwIdChoice)
            *pfHasCmsSignerId = TRUE;
#endif  // CMS_PKCS7
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthCertId( &SignerId)))
            goto CertIdError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                            psei->hCryptProv,
                            &psei->HashAlgorithm,
                            psei->cAuthAttr,
                            psei->rgAuthAttr,
                            pszInnerContentObjID,
                            TRUE)))
            goto AuthAttributesError;
        cbSigner += cb;
#ifdef CMS_PKCS7
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, HashEncryptionAlgorithm) <=
            psei->cbSize && psei->HashEncryptionAlgorithm.pszObjId)
        paiDigestEncrypt = &psei->HashEncryptionAlgorithm;
    else
#endif  // CMS_PKCS7
        paiDigestEncrypt = &psei->pCertInfo->SubjectPublicKeyInfo.Algorithm;

        if (INVALID_ENCODING_SIZE == (cb =
                        ICM_LengthEncryptedDigestAndAlgorithm(
                            psei->hCryptProv,
                            psei->dwKeySpec,
                            &psei->HashAlgorithm,
                            paiDigestEncrypt)))
            goto EncryptedDigestError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                            NULL,
                            NULL,
                            psei->cUnauthAttr,
                            psei->rgUnauthAttr,
                            NULL,
                            FALSE)))
            goto UnauthAttributesError;
        cbSigner += cb;
        ICM_GetLengthOctets( cbSigner, NULL, &cb);
        cbSignerS += cbSigner + cb + 1;     // SignerInfo seq
    }
    ICM_GetLengthOctets( cbSignerS, NULL, &cb);
    cbSize = cbSignerS + cb + 1;            // SignerInfo seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(GetSignerIdError)                       // error already set
TRACE_ERROR(CertIdError)                            // error already set
TRACE_ERROR(HashAlgorithmError)                     // error already set
TRACE_ERROR(AuthAttributesError)                    // error already set
TRACE_ERROR(UnauthAttributesError)                  // error already set
TRACE_ERROR(EncryptedDigestError)                   // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the SignedData.digestAlgorithms encoded blob.
//
#ifndef CMS_PKCS7
//  Assumes no duplicate removal. OK for single-signer case, which
//  is only one currently supported.
#endif
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSignedDigestAlgorithms(
    IN DWORD                    cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners)
{
    DWORD                       cbSize;
    DWORD                       cbAlgoS;
    DWORD                       cb;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DWORD                       i;

#ifdef CMS_PKCS7
    for (i=cSigners, psei=rgSigners, cbAlgoS=0; i>0;
            i--,
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
        assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
            psei->cbSize);
        if (ICM_IsDuplicateSignerEncodeHashAlgorithm(
                rgSigners,
                psei
                ))
            continue;

        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbAlgoS += cb;
    }
#else
    for (i=cSigners, psei=rgSigners, cbAlgoS=0;
            i>0;
            i--, psei++) {
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbAlgoS += cb;
    }
#endif  // CMS_PKCS7
    ICM_GetLengthOctets( cbAlgoS, NULL, &cb);
    cbSize = cbAlgoS + cb + 1;            // digestAlgorithms set

Com