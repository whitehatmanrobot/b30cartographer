/      IN pdmq         Queue to remove message from
//  Returns:
//      S_OK on success
//  History:
//      12/11/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrRemoveMessageFromQueue(CDestMsgQueue *pdmq)
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    BOOL  fLocal = !pdmq;  //If no link is specified... it is local

    //Search for matching queue
    for (i = 0; i < m_cDomains; i++)
    {
        //
        //  Check and see if this domain is an exact match.  This will work
        //  for local as well, since we mark the queue as NULL when we move
        //  it to the local queue.
        //
        if (pdmq == m_rgpdmqDomains[i])
        {
            //just check pending bits
            if (!pmbmapGetPending()->FTest(m_cDomains, pmbmapGetDomainBitmap(i)))
            {
                //Set Handled bits so no one else will try to deliver
                pmbmapGetHandled()->FTestAndSet(m_cDomains, pmbmapGetDomainBitmap(i));
            }

            //
            // Stop if we aren't searching for local domains (since we can
            // only have one match in that case).
            //
            if (!fLocal)
                break;
        }
    }
    return hr;
}

//---[ CMsgRef::HrQueueAdminNDRMessage ]---------------------------------------
//
//
//  Description:
//      Forcably NDRs a message for a given queue.
//  Parameters:
//      IN  pdmq    Queue to NDR message for
//  Returns:
//      S_OK on success
//  History:
//      12/12/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrQueueAdminNDRMessage(CDestMsgQueue *pdmq)
{
    HRESULT     hr = S_OK;
    CQuickList  qlst;
    CQuickList *pqlst = NULL;
    BOOL        fLocal = TRUE;
    DWORD       iListIndex = 0;
    DWORD       dwDSNFlags = 0;

    if (pdmq)
    {
        hr = qlst.HrAppendItem(pdmq, &iListIndex);
        if (FAILED(hr))
            goto Exit;

        pqlst = &qlst;
        fLocal = FALSE;

    }

    //Force NDR from this queue
    hr = HrSendDelayOrNDR(fLocal ? MSGREF_DSN_LOCAL_QUEUE : 0,
                          pqlst, AQUEUE_E_QADMIN_NDR,
                          &dwDSNFlags);

    if (FAILED(hr))
    {
        //
        //  Not really a failure if the message has already been handled
        //
        if (AQUEUE_E_MESSAGE_HANDLED == hr)
            hr  = S_OK;
        goto Exit;
    }

  Exit:
    return hr;
}


//---[ CMsgRef::GlobalFreezeMessage ]------------------------------------------
//
//
//  Description:
//      Freezes a message for all queues that it is on.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/12/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMsgRef::GlobalFreezeMessage()
{
    dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MSG_FROZEN);
}

//---[ CMsgRef::GlobalFreezeMessage ]------------------------------------------
//
//
//  Description:
//      Thaws a previously frozen messages.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      12/12/98 - MikeSwa Created
//      2/17/2000 - MikeSwa Modified to move the kick of the DMQ up a level.
//
//-----------------------------------------------------------------------------
void CMsgRef::GlobalThawMessage()
{
    dwInterlockedUnsetBits(&m_dwDataFlags, MSGREF_MSG_FROZEN);
}


//---[ CMsgRef::RetryOnDelete ]------------------------------------------------
//
//
//  Description:
//      Marks a message to retry on delete.  Basically, we hit an error
//      that requires retrying the message at a later time (i.e. - cannot
//      allocate a queue page).  However, we cannot put the message into the
//      failed retry queue until all other threads are done accessing it.
//
//      This call will mark the MsgRef so that it will be retried after its
//      final release.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      1/19/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMsgRef::RetryOnDelete()
{
    if (!(MSGREF_MSG_RETRY_ON_DELETE &
        dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MSG_RETRY_ON_DELETE)))
    {
        DEBUG_DO_IT(InterlockedIncrement((PLONG) &g_cDbgMsgRefsPendingRetryOnDelete));
    }
}


//---[ CMsgRef::QueryInterface ]-----------------------------------------------
//
//
//  Description:
//      QueryInterface for CMsgRef that supports:
//          - IUnknown
//          - CMsgRef
//
//      This is designed primarily to allow Queue Admin functionality to run
//      against a CMsgRef object as well a "true" COM interface like
//      IMailMsgProperties.
//  Parameters:
//
//  Returns:
//      S_OK on success
//  History:
//      2/21/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CMsgRef::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<CMsgRef *>(this);
    }
    else if (IID_CMsgRef == riid)
    {
        *ppvObj = static_cast<CMsgRef *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ ReleaseAndBounceUsageOnMsgAck ]-----------------------------------------
//
//
//  Description:
//      Decides if the message should be commited on the message ack.
//  Parameters:
//      DWORD       dwMsgStatus     Status of msg ack
//  Returns:
//      -
//  History:
//      7/6/99 - MikeSwa Created
//      9/9/99 - Mikeswa Updated to be more aggressive about closing handles
//      10/27/1999 - MikeSwa Added code to delete handled messages
//
//-----------------------------------------------------------------------------
void CMsgRef::ReleaseAndBounceUsageOnMsgAck(DWORD dwMsgStatus)
{
    BOOL    fBounceUsage = FALSE;

    if (MESSAGE_STATUS_RETRY & dwMsgStatus)
    {
        //If this message was Ack'd retry... we should try an bounce the usage
        //count and close the associated handle.
        fBounceUsage = TRUE;
    }
    else if (g_cMaxIMsgHandlesThreshold < m_paqinst->cCountMsgsForHandleThrottling(m_pIMailMsgProperties))
    {
        //If we are over our alloted number of messages in the system, we should
        //close the message even if was ACK'd OK.  The only time we don't want
        //to is if all domains have been handled.  In this case, we are about
        //to delete the message and usually do not want to commit it first.
        if (!pmbmapGetHandled()->FAllSet(m_cDomains))
            fBounceUsage = TRUE;

    }

    //
    //  Release the usage count added by HrPrepareDelivery
    //  NOTE: This must come before the call to Bounce... or the
    //  call to bounce usage will have no effect.  It must also
    //  occur after the above call to cCountMsgsForHandleThrottling,
    //  because it may request a property from the mailmsg.
    //
    InternalReleaseUsage();


    if (pmbmapGetHandled()->FAllSet(m_cDomains))
    {
        //There is are 2 known cases were the above could leave
        //the message handles open for a while.  In both cases, this message
        //must be queued to multiple DMQs on the same link, and be completely
        //delivered.  In one case, the message is dequeued during delivery and
        //sits on the retry queue until it is remerged.  In another case, the
        //message sits on the delivery queue until a thead pulls it off and
        //discovers that it is already handled.

        //To avoid this, we will mark the message for deletion when the
        //intneral usage count drops to 0.
        MarkMailMsgForDeletion();
    }

    if (fMailMsgMarkedForDeletion())
    {
        //Force synchronous bounce usgage since delete should be much
        //quicker than commit
        SyncBounceUsageCount();
    }
    else if (fBounceUsage)
    {
        BounceUsageCount();
    }
}

//---[ CMsgRef::MarkMailMsgForDeletion ]---------------------------------------
//
//
//  Description:
//      Sets the bit saying the that we are done with the mailmsg, and it
//      should delete it the next time the usage count drops to 0.
//
//      To force deletion, the caller should bounce the usage count after
//      calling.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/26/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMsgRef::MarkMailMsgForDeletion()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::MarkMailMsgForDeletion");
    DWORD   dwOrigFlags = 0;

    DebugTrace((LPARAM) this,
        "Marking message with ID hash of 0x%x for deletion", m_dwMsgIdHash);

    dwOrigFlags = dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MAILMSG_DELETE_PENDING);

    //If we were the first thread to set this, then update the counters
    if (!(dwOrigFlags & MSGREF_MAILMSG_DELETE_PENDING))
    {
        InterlockedIncrement((PLONG) &s_cCurrentMsgsPendingDelete);
        InterlockedIncrement((PLONG) &s_cTotalMsgsPendingDelete);
    }

    _ASSERT(fMailMsgMarkedForDeletion());

    TraceFunctLeave();
}

//---[ CMsgRef::ThreadSafeMailMsgDelete ]--------------------------------------
//
//
//  Description:
//      Used to make sure that calling thread is the only one that will call
//      Delete() on the MailMsg.  Will set the MSGREF_MAILMSG_DELETED and call
//      Delete().  Only called in ReleaseMailMsg() and InternalReleaseUsage().
//
//      The caller is responsible for making sure that other threads are not
//      reading the mailmsg or have a usage count.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/27/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CMsgRef::ThreadSafeMailMsgDelete()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::ThreadSafeMailMsgDelete");
    DWORD   dwOrigFlags = 0;
    HRESULT hr = S_OK;

    //Try to set the MSGREF_MAILMSG_DELETED.
    dwOrigFlags = dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MAILMSG_DELETED);

    //If we are the first thread to set it, then we can Delete()
    if (!(dwOrigFlags & MSGREF_MAILMSG_DELETED))
    {
        hr = m_pIMailMsgQM->Delete(NULL);

        if (FAILED(hr))
            ErrorTrace((LPARAM) this, "Delete failed with hr 0x%08X", hr);

        //If this message was marked as pending delete, then update
        //the appropriate counters
        if (dwOrigFlags & MSGREF_MAILMSG_DELETE_PENDING)
        {
            InterlockedDecrement((PLONG) &s_cCurrentMsgsPendingDelete);
            InterlockedIncrement((PLONG) &s_cTotalMsgsDeletedAfterPendingDelete);
            InterlockedIncrement((PLONG) &s_cCurrentMsgsDeletedNotReleased);
        }
    }

    TraceFunctLeave();
}

//---[ CMsgRef::InternalAddUsage ]---------------------------------------------
//
//
//  Description:
//      Wraps the mailmsg call to AddUsage.  Allows CMsgRef to call Delete()
//      on the underlying mailmsg while there are still references to the
//      CMsgRef.
//
//      Calling InternalAddUsage does not guarantee that there is backing
//      storage for the MailMsg.  Callers must call fMailMsgMarkedForDeletion()
//      *after* calling InternalAddUsage()
//
//      We do guarantee that if InternalAddUsage() is called and a then
//      subsequent call to fMailMsgMarkedForDeletion() returns TRUE, then
//      the mailmsg will not be deleted until after the corresponding
//      call to InternalReleaseUsage();
//  Parameters:
//      -
//  Returns:
//      S_OK if the message is deleted and we did not call into mailmsg
//      Error/Success code from mailmsg if we called in.
//  History:
//      10/26/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::InternalAddUsage()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::InternalAddUsage");
    HRESULT hr = S_OK;

    InterlockedIncrement((PLONG) &m_cInternalUsageCount);

    if (!fMailMsgMarkedForDeletion() && m_pIMailMsgQM)
    {
        hr = m_pIMailMsgQM->AddUsage();
    }

    //If the call to AddUsage failed, we need to decrement our own count
    if (FAILED(hr))
    {
        InterlockedDecrement((PLONG) &m_cInternalUsageCount);
        ErrorTrace((LPARAM) this, "AddUsage failed 0x%0X", hr);
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::InternalReleaseUsage ]-----------------------------------------
//
//
//  Description:
//      Wraps the mailmsg call to ReleaseUsage.  Allows us to call Delete()
//      on the mailmsg while there are still references to this CMsgRef.
//
//      If MSGREF_MAILMSG_DELETE_PENDING is set but Delete() has not yet been
//      called, this will call Delete() when the usage count hits 0.
//  Parameters:
//      -
//  Returns:
//      S_OK if the message is deleted and we did not call into mailmsg
//      Error/Success code from mailmsg if we called in.
//  History:
//      10/26/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::InternalReleaseUsage()
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::InternalReleaseUsage");
    HRESULT hr = S_OK;
    DWORD   dwOrigFlags = 0;

    //We need to call into mailmsg *before* we decrement the usage count. It is
    //theoretically possible that this would cause an extra commit after we
    //have decided to delete the message, but since we check right before
    //calling the timing window is very small.
    if (m_pIMailMsgQM && !fMailMsgMarkedForDeletion())
        hr = m_pIMailMsgQM->ReleaseUsage();

    _ASSERT(m_cInternalUsageCount); //Should never go negative

    if (FAILED(hr))
        ErrorTrace((LPARAM) this, "ReleaseUsage failed - 0x%0X", hr);

    //If we have dropped the usage count to zero, then we need to check
    //and see if we need to call delete.
    //The "at rest" value of m_cInternalUsageCount is 1, but BounceUsage
    //(which calls this function) can cause it to drop to 0.
    if (0 == InterlockedDecrement((PLONG) &m_cInternalUsageCount))
    {
        //We need to be absolutely thread safe about calling delete.  Not only
        //do we need to ensure that a single thread calls Delete(), but we
        //also need to ensure that someone has not called InternalAddUsage()
        //before MSGREF_MAILMSG_DELETE_PENDING was set, but after the
        //above InterlockedDecrement() was called.
        //
        //If we check for the MSGREF_MAILMSG_DELETE_PENDING before the
        //aboved InterlockedDecrement, we can run into a timing window where
        //the final InternalReleaseUsage does not detect that we need to delete
        //the mailmsg.
        //
        //To avoid these issues, we will check the m_cInternalUsageCount
        //again.  If it is still zero, then we will proceed, because we know
        //that the count hit zero after MSGREF_MAILMSG_DELETE_PENDING was set.
        //If the count is *not* currently zero, we know that a later thread
        //will release the usage count and hit this code path.
        if (fMailMsgMarkedForDeletion())
        {
            if (!m_cInternalUsageCount)
                ThreadSafeMailMsgDelete();
        }
    }

    TraceFunctLeave();
    return hr;
}

//---[ CMsgRef::ShouldRetry ]--------------------------------------------------
//
//
//  Description:
//      Determines if we should retry this message if an error occurs.  Will
//      return FALSE if we *know* that the backing store has been deleted.
//  Parameters:
//      -
//  Returns:
//      TRUE if we should rety the message
//      FALSE, the backing store for the message is gone... drop it
//  History:
//      1/6/2000 - MikeSwa Created
//      4/12/2000 - MikeSwa modified to call CAQSvrInst member
//
//-----------------------------------------------------------------------------
BOOL CMsgRef::fShouldRetry()
{
    IMailMsgProperties *pIMailMsgProperties = m_pIMailMsgProperties;

    if (pIMailMsgProperties && m_paqinst)
        return m_paqinst->fShouldRetryMessage(pIMailMsgProperties, FALSE);
    else
        return FALSE;
}


//---[ CMsgRef::GetStatsForMsg ]-----------------------------------------------
//
//
//  Description:
//      Fills in a CAQStats for this message
//  Parameters:
//      IN OUT  paqstat         Stats to fill in
//  Returns:
//      NULL
//  History:
//      1/15/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMsgRef::GetStatsForMsg(IN OUT CAQStats *paqstat)
{
    _ASSERT(paqstat);
    paqstat->m_cMsgs = 1;
    paqstat->m_rgcMsgPriorities[PriGetPriority()] = 1;
    paqstat->m_uliVolume.QuadPart = (ULONGLONG) dwGetMsgSize();
    paqstat->m_dwHighestPri = PriGetPriority();
}

//---[ CMsgRef::MarkQueueAsLocal ]---------------------------------------------
//
//
//  Description:
//      Marks a given DMQ as local.  This is used in the gateway delivery
//      path to prevent messages from being lost if a reroute happens after
//      it has been moved to the local delivery queue.
//  Parameters:
//      pdmq            Queue to mark as local for this message
//  Returns:
//      -
//  History:
//      2/17/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMsgRef::MarkQueueAsLocal(IN CDestMsgQueue *pdmq)
{
    DWORD i = 0;

    //
    //Search for matching queue
    //
    for (i = 0; i < m_cDomains; i++)
    {
        if (pdmq == m_rgpdmqDomains[i])
        {
            //
            //  Exact match found.  Set pointer to NULL and release it.
            //  The caller (CLinkMsgQueue) should still have a reference to
            //  the queue.
            //
            if (InterlockedCompareExchangePointer((void **) &m_rgpdmqDomains[i], NULL, pdmq) == (void *) pdmq)
                pdmq->Release();

            return;
        }
    }
    _ASSERT(0 && "Requested DMQ not found!!!!");
}


//---[ CountMessageInRemoteTotals ]--------------------------------------------
//
//
//  Description:
//      Count this message in the totals for remote messages.  This means that
//      we need to decrement the count when this message is released.
//
//      There is no exactly equivalent local count.  The counters for local
//      delivery has based on queue length and can have multiple counts per
//      message object (as can some of the remote counts as well).
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      2/28/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CMsgRef::CountMessageInRemoteTotals()
{
    dwInterlockedSetBits(&m_dwDataFlags, MSGREF_MSG_COUNTED_AS_REMOTE);
}


//---[ CMsgRef::HrPromoteMessageStatusToMailMsg ]------------------------------
//
//
//  Description:
//      Promotes extended status from MessageAck to mailmsg recipient property
//      if there is not already specific information there.
//  Parameters:
//      pdcntxt     Delivery context for this message
//      pMsgAck     Ptr to MessageAck structure for this message
//  Returns:
//      S_OK on success
//  History:
//      3/20/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrPromoteMessageStatusToMailMsg(CDeliveryContext *pdcntxt,
                                                 MessageAck *pMsgAck)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrPromoteMessageStatusToMailMsg");
    HRESULT hr = S_OK;
    HRESULT hrRecipStatus = S_OK;
    HRESULT hrTmp = S_OK;
    RECIPIENT_FILTER_CONTEXT rpfctxt;
    BOOL    fContextInit = FALSE;
    DWORD   iCurrentRecip = 0;
    DWORD   dwProp = 0; //place holder for recipient status property
    LPSTR   szExtendedStatus = NULL;
    DWORD   dwRecipMask = RP_DSN_HANDLED |              // No DSN generated
                          RP_DSN_NOTIFY_NEVER |         // NOTIFY!=NEVER
                          (RP_DELIVERED ^ RP_HANDLED);  // Not delivered
    DWORD   dwRecipFlags = 0;


    _ASSERT(pdcntxt);
    _ASSERT(pMsgAck);
    _ASSERT(m_pIMailMsgRecipients);

    //
    //  If we have no extended status, then there is nothing for us to do
    //
    if (!(pMsgAck->dwMsgStatus & MESSAGE_STATUS_EXTENDED_STATUS_CODES) ||
        !pMsgAck->cbExtendedStatus ||
        !pMsgAck->szExtendedStatus)
    {
        DebugTrace((LPARAM) this, "No extended status codes in MessageAck");
        goto Exit;
    }

    //
    //  If this was actually not a protocol error, SMTP may not have put
    //  the full status codes on it.  Instead of "250 2.0.0 OK" it may
    //  have just put "OK".  We should not write this to mailmsg as is, but
    //  should instead fix up string so it is what the DSN sink expects.
    //
    hr = HrUpdateExtendedStatus(pMsgAck->cbExtendedStatus,
                                pMsgAck->szExtendedStatus,
                                &szExtendedStatus);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "Unable to get extended status from %s - hr 0x%08X",
            pMsgAck->szExtendedStatus, hr);
        hr = S_OK; //non-fatal error... eat it
        goto Exit;
    }

    //
    //  Initialize recipient filter context so we can iterate over the
    //  recipients
    //
    hr = m_pIMailMsgRecipients->InitializeRecipientFilterContext(&rpfctxt,
                                    pdcntxt->m_dwStartDomain, dwRecipFlags,
                                    dwRecipMask);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "InitializeRecipientFilterContext failed with 0x%08X", hr);
        goto Exit;
    }

    fContextInit = TRUE;
    DebugTrace((LPARAM) this,
        "Init recip filter context with mask 0x%08X and flags 0x%08X and domain %d",
        dwRecipMask, dwRecipFlags, pdcntxt->m_dwStartDomain);

    //
    //  Loop over each recipient and update their properties if needed
    //
    for (hr = m_pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip);
         SUCCEEDED(hr);
         hr = m_pIMailMsgRecipients->GetNextRecipient(&rpfctxt, &iCurrentRecip))
    {
        DebugTrace((LPARAM) this, "Looking at recipient %d", iCurrentRecip);
        //
        //  See if we have an HRESULT... if it *is* there and is a failure
        //  then continue on to the next recipient
        //
        hrRecipStatus = S_OK;
        hr = m_pIMailMsgRecipients->GetDWORD(iCurrentRecip,
                IMMPID_RP_ERROR_CODE, (DWORD *) &hrRecipStatus);
        if (SUCCEEDED(hr) && FAILED(hrRecipStatus))
        {
            DebugTrace((LPARAM) this,
                "Recipient %d already has a status of 0x%08X",
                iCurrentRecip, hrRecipStatus);
            continue;
        }


        //
        //  Check for existing status property
        //
        hr = m_pIMailMsgRecipients->GetDWORD(iCurrentRecip,
                IMMPID_RP_SMTP_STATUS_STRING, &dwProp);
        if (MAILMSG_E_PROPNOTFOUND != hr)
        {
            DebugTrace((LPARAM) this,
                "Recipient %d has a status string (hr 0x%08X)",
                iCurrentRecip, hr);
            continue;
        }

        //
        //  There is no detailed information on the recipient.  We should
        //  promote the extended status from the message ack to the recipient
        //
        hr = m_pIMailMsgRecipients->PutStringA(iCurrentRecip,
                 IMMPID_RP_SMTP_STATUS_STRING, szExtendedStatus);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "Unable to write %s to recip %d - hr 0x%08X",
                szExtendedStatus, iCurrentRecip, hr);
            goto Exit;
        }
        DebugTrace((LPARAM) this,
            "Wrote extended status %s to recip %d",
            szExtendedStatus, iCurrentRecip);
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        hr = S_OK;  //we just reached the end of the context

  Exit:
    //
    //  Terminate context if init was called
    //
    if (fContextInit)
    {
        hrTmp = m_pIMailMsgRecipients->TerminateRecipientFilterContext(&rpfctxt);
        if (FAILED(hrTmp))
        {
            ErrorTrace((LPARAM) this,
                "TerminateRecipientFilterContext failed 0x%08X", hr);
        }
    }

    TraceFunctLeave();
    return hr;
}

//
//  These are strings defined in smtpcli.hxx that are used in smtpout.cxx
//  in calls to m_ResponseContext.m_cabResponse.Append().  These strings
//  are not in the normal protocol format of "xxx x.x.x Error string"
//
//      g_cNumExtendedStatusStrings     Number of hard-coded strings
//      g_rgszSMTPExtendedStatus        SMTP extended status
//      g_rgszSMTPUpdatedExtendedStatus Full protocol strings.
//
const DWORD g_cNumExtendedStatusStrings = 4;
const CHAR  g_rgszSMTPExtendedStatus[g_cNumExtendedStatusStrings][200] = {
    "Msg Size greater than allowed by Remote Host",
    "Body type not supported by Remote Host",
    "Failed to authenticate with Remote Host",
    "Failed to negotiate secure channel with Remote Host",
};

const CHAR  g_rgszSMTPUpdatedExtendedStatus[g_cNumExtendedStatusStrings][200] = {
    "450 5.2.3 Msg Size greater than allowed by Remote Host",
    "554 5.6.1 Body type not supported by Remote Host",
    "505 5.7.3 Failed to authenticate with Remote Host",
    "505 5.7.3 Failed to negotiate secure channel with Remote Host",
};


//
// Extended status strings for some known cases where we reach HrUpdateExtendedStatus
// without having a valid extended status string
//
const CHAR g_szSMTPStatus_BadSenderAddress  [] = "500 5.1.7 Invalid or missing sender SMTP address";
const CHAR g_szSMTPStatus_OtherError        [] = "500 5.5.6 Unknown SMTP delivery error";

//---[ CMsgRef::HrUpdateExtendedStatus ]---------------------------------------
//
//
//  Description:
//      Sometime SMTP is lazy about returning actual protocol-complient
//      strings for internal errors.  If this is not a valid status string,
//      then we should check against the strings that we know SMTP generates
//      and make it a protocol string that can be used in DSN generation.
//
//  Parameters:
//      IN  szCurrentStatus     current status
//      OUT pszNewStatus        New protcol friendly status string.  This
//                              is a const that does not need to be freed
//  Returns:
//      S_OK on succcess
//      E_FAIL when we cannot extract a protocol string from the
//          extended status string.
//  History:
//      3/20/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CMsgRef::HrUpdateExtendedStatus(DWORD cbCurrentStatus,
                                        LPSTR szCurrentStatus,
                                        LPSTR *pszNewStatus)
{
    TraceFunctEnterEx((LPARAM) this, "CMsgRef::HrUpdateExtendedStatus");
    HRESULT hr = S_OK;
    DWORD   iCurrentExtendedStatus = 0;

    _ASSERT(szCurrentStatus);
    _ASSERT(pszNewStatus);

    *pszNewStatus = szCurrentStatus;

    //
    // Check for known condition where szCurrentStatus is set to an
    // unterminated '5'
    //
    if (szCurrentStatus[0] == '5' && cbCurrentStatus == 1)
    {
        DWORD   cbProp = 0;
        CHAR    szBuffer[100];

        // Check to see if the sender is invalid
        hr = m_pIMailMsgProperties->GetProperty(IMMPID_MP_SENDER_ADDRESS_SMTP,
                    sizeof(szBuffer), &cbProp,(BYTE *) szBuffer);

        if(FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            // Failed to read sender - set status accordingly
            *pszNewStatus = (CHAR*) g_szSMTPStatus_BadSenderAddress;
        }
        else
        {
            // Succeeded reading sender or failed due to insufficient
            // buffer - which is fine, we only care if the prop exists
            *pszNewStatus = (CHAR*) g_szSMTPStatus_OtherError;
        }

        DebugTrace((LPARAM) this,
            "Updating char '5' to status \"%s\"", *pszNewStatus);

        // This isn't a failure even if we didn't get the prop.
        hr = S_OK;
        goto Exit;

    }

    //
    //  If it starts with a 2 4 or 5, then we know it is not one of the
    //  non-protocol strings
    //
    if (('2' == *szCurrentStatus) ||
        ('4' == *szCurrentStatus) ||
        ('5' == *szCurrentStatus))
    {
        DebugTrace((LPARAM) this,
            "Status %s is already in protocol format", szCurrentStatus);
        goto Exit;
    }

    //
    //  check against all well-known status
    //
    for (iCurrentExtendedStatus = 0;
         iCurrentExtendedStatus < g_cNumExtendedStatusStrings;
         iCurrentExtendedStatus++)
    {
        if (0 == lstrcmpi(szCurrentStatus, g_rgszSMTPExtendedStatus[iCurrentExtendedStatus]))
        {
            *pszNewStatus = (CHAR *) g_rgszSMTPUpdatedExtendedStatus[iCurrentExtendedStatus];
            DebugTrace((LPARAM) this, "Updating to status \"%s\" from status \"%s\"",
                szCurrentStatus, *pszNewStatus);

            //
            //  Our strings should match (modulo the new prefix)
            //
            _ASSERT(0 == lstrcmpi(szCurrentStatus, *pszNewStatus + sizeof("xxx x.x.x")));
            goto Exit;
        }
    }

    hr = E_FAIL;
  Exit:
    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\msgrefadm.h ===
//-----------------------------------------------------------------------------
//
//
//  File: 
//      msgrefadm.h
//
//  Description:
//      Header file for CAsyncAdminMsgRefQueue class.  This is a subclass
//      of the templated CAsyncAdminMsgRefQueue that implements the admin
//      functionality specific to a MsgRef (a routed msg)
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/7/2000 - MikeSwa Created 
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __MSGREFADM_H__
#define __MSGREFADM_H__

#include <asyncadm.h>

//---[ CAsyncAdminMsgRefQueue ]------------------------------------------------
//
//
//  Description: 
//      Implements QAPI queue-level functionality that is specific to the
//      CMsgRef object
//  Hungarian:
//      asyncq, pasyncq
//
//  
//-----------------------------------------------------------------------------
class CAsyncAdminMsgRefQueue :
    public CAsyncAdminQueue<CMsgRef *, ASYNC_QUEUE_MSGREF_SIG>
{
  public:
    CAsyncAdminMsgRefQueue(LPCSTR szDomain, LPCSTR szLinkName, 
        const GUID *pguid, DWORD dwID, CAQSvrInst *paqinst) : 
            CAsyncAdminQueue<CMsgRef *, ASYNC_QUEUE_MSGREF_SIG>(szDomain, 
                szLinkName, pguid, dwID, paqinst, 
                QueueAdminApplyActionToMessages) {};

  protected: // Virutal functions used to implement msg specific actions
    virtual HRESULT HrDeleteMsgFromQueueNDR(IUnknown *pIUnknownMsg);
    virtual HRESULT HrDeleteMsgFromQueueSilent(IUnknown *pIUnknownMsg);
    virtual HRESULT HrFreezeMsg(IUnknown *pIUnknownMsg);
    virtual HRESULT HrThawMsg(IUnknown *pIUnknownMsg);
    virtual HRESULT HrGetStatsForMsg(IUnknown *pIUnknownMsg, CAQStats *paqstats);
    virtual HRESULT HrInternalQuerySupportedActions(
                                DWORD  *pdwSupportedActions,
                                DWORD  *pdwSupportedFilterFlags);
};

#endif //__MSGREFADM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\propstrm.cpp ===
//----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  Module:  rwstream.cpp
//
//  Description:  Contains implementation of the read only / write only 
//                mailmsg property stream in epoxy shared memory.
//
//      10/20/98 - MaheshJ Created 
//      8/17/99 - MikeSwa Modified to use files instead of shared memory 
//----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "propstrm.h"


// Constructor.
CFilePropertyStream::CFilePropertyStream()
{
    TraceFunctEnter("CFilePropertyStream::CFilePropertyStream");

    m_dwSignature = FILE_PROPERTY_STREAM;
    m_hDestFile = NULL;

    TraceFunctLeave();
}

// Destructor.
CFilePropertyStream::~CFilePropertyStream()
{
    TraceFunctEnter("CFilePropertyStream::~CFilePropertyStream");

    _ASSERT(FILE_PROPERTY_STREAM == m_dwSignature);
    m_dwSignature = FILE_PROPERTY_STREAM_FREE;

    if (m_hDestFile && (INVALID_HANDLE_VALUE != m_hDestFile))
        _VERIFY(CloseHandle(m_hDestFile));

    TraceFunctLeave();
}

//---[ CFilePropertyStream::HrInitialize ]-------------------------------------
//
//
//  Description: 
//      Creates a file for the property stream 
//  Parameters:
//      szFileName      Name of file to create for the property stream
//  Returns:
//      S_OK on success
//      NT error from Create File
//  History:
//      8/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CFilePropertyStream::HrInitialize(LPSTR szFileName)
{
    TraceFunctEnterEx((LPARAM) this, "CFilePropertyStream::HrInitialize");
    HRESULT hr = S_OK;
    m_hDestFile = CreateFile(szFileName,
                              GENERIC_WRITE, 
                              0, 
                              NULL,
                              CREATE_ALWAYS,
                              FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);

    if (INVALID_HANDLE_VALUE == m_hDestFile)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, 
            "Unable to create badmail reason file - err 0x%08X - file %s",
            hr, szFileName);
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }
    TraceFunctLeave();
    return hr;
}

//---[ CFilePropertyStream::QueryInterface ]-----------------------------------------
//
//
//  Description: 
//      QueryInterface for CFilePropertyStream that supports:
//          - IMailMsgPropertyStream
//  Parameters:
//
//  Returns:
//
//  History:
//      8/17/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CFilePropertyStream::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<IMailMsgPropertyStream *>(this);
    }
    else if (IID_IMailMsgPropertyStream == riid)
    {
        *ppvObj = static_cast<IMailMsgPropertyStream *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

// Property stream methods.

// Start a write transaction.
HRESULT STDMETHODCALLTYPE    
CFilePropertyStream::StartWriteBlocks(IN IMailMsgProperties *pMsg,
                                              IN DWORD dwBlocksToWrite,
				                              IN DWORD dwTotalBytesToWrite)
{
    HRESULT hr = S_OK;

    TraceFunctEnter("CFilePropertyStream::StartWriteBlocks");

    // Should be writing something.
    _ASSERT(dwBlocksToWrite > 0);
    _ASSERT(dwTotalBytesToWrite > 0);

    //We actually don't case, since we will just dump this to a file
    TraceFunctLeave();
    return(hr);
}

// End a write transaction.
HRESULT STDMETHODCALLTYPE    
CFilePropertyStream::EndWriteBlocks(IN IMailMsgProperties *pMsg)
{
    TraceFunctEnter("CFilePropertyStream::EndWriteBlocks");
    HRESULT hr = S_OK;
    TraceFunctLeave();
    return(hr);
}

// Cancel a write transaction.
HRESULT STDMETHODCALLTYPE    
CFilePropertyStream::CancelWriteBlocks(IN IMailMsgProperties *pMsg)
{
    TraceFunctEnter("CFilePropertyStream::CancelWriteBlocks");
    HRESULT hr = S_OK;
    TraceFunctLeave();
    return(hr);
}

// Get the size of the stream.
HRESULT STDMETHODCALLTYPE 
CFilePropertyStream::GetSize(IN IMailMsgProperties *pMsg,
                                     IN DWORD          *  pdwSize,
				                     IN IMailMsgNotify	* pNotify)
{
    TraceFunctEnter("CFilePropertyStream::GetSize");
    HRESULT hr = E_NOTIMPL;
    TraceFunctLeave();
    return(hr);
}

// Read blocks from the stream.
HRESULT STDMETHODCALLTYPE 
CFilePropertyStream::ReadBlocks(IN IMailMsgProperties *pMsg,
                                        IN DWORD			 dwCount,
				                        IN DWORD			*pdwOffset,
				                        IN DWORD			*pdwLength,
				                        IN BYTE			   **ppbBlock,
				                        IN IMailMsgNotify	*pNotify)
{
    TraceFunctEnter("CFilePropertyStream::ReadBlocks");
    HRESULT hr       = E_NOTIMPL;
    ErrorTrace((LPARAM) this, "ReadBlocks call on CFilePropertyStream!");
    TraceFunctLeave();
    return(hr);
}

// Write blocks to the stream.	
HRESULT STDMETHODCALLTYPE 
CFilePropertyStream::WriteBlocks(IN IMailMsgProperties *pMsg,
                                         IN DWORD			dwCount,
                                         IN DWORD			*pdwOffset,
                                         IN DWORD			*pdwLength,
                                         IN BYTE			**ppbBlock,
                                         IN IMailMsgNotify	*pNotify)
{
    TraceFunctEnter("CFilePropertyStream::WriteBlocks");
    HRESULT hr       = S_OK;
    DWORD   irgCount = 0;
    DWORD   cbWritten = 0;
    OVERLAPPED ov;

    ZeroMemory(&ov, sizeof(OVERLAPPED));


    if ((0 == dwCount)||
        (NULL == pdwOffset)||
        (NULL == pdwLength)||
        (NULL == ppbBlock))
    {
        hr = E_INVALIDARG;
        DebugTrace((LPARAM)this,
                   "WriteBlocks failed with hr : 0x%x",
                   hr);
        goto Exit;
    }

    if (!m_hDestFile)
    {
        ErrorTrace((LPARAM) this,
                   "WriteBlocks called with no file handle");
        hr = E_FAIL;
        _ASSERT(0 && "WriteBlocks called with no file handle");
        goto Exit;
    }

    for (irgCount = 0; irgCount < dwCount; irgCount++)
    {
        ov.Offset = pdwOffset[irgCount];
        cbWritten = 0;
        if (!WriteFile(m_hDestFile, ppbBlock[irgCount], pdwLength[irgCount], 
            &cbWritten, &ov))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ErrorTrace((LPARAM)this,
                        "WriteFile of blob %d failed with hr : 0x%08X",
                        irgCount, hr);
            goto Exit;
        }
    }

Exit:
    TraceFunctLeave();
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\qwiklist.cpp ===
//-----------------------------------------------------------------------------
//
//
//	File: qwiklist.cpp
//
//	Description:  Implementation of CQuickList
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		6/15/98 - MikeSwa Created
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "qwiklist.h"

CPool CQuickList::s_QuickListPool;

//---[ CQuickList::CQuickList ]------------------------------------------------
//
//
//  Description:
//      Default contructor for CQuikList... initializes as head of list
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::CQuickList()
{
    m_dwSignature = QUICK_LIST_SIG;

    //ASSERT constants
    _ASSERT(!(~QUICK_LIST_INDEX_MASK & QUICK_LIST_PAGE_SIZE));
    _ASSERT((~QUICK_LIST_INDEX_MASK + 1)== QUICK_LIST_PAGE_SIZE);
    m_dwCurrentIndexStart = 0;
    InitializeListHead(&m_liListPages);
    m_cItems = 0;
    ZeroMemory(m_rgpvData, QUICK_LIST_PAGE_SIZE*sizeof(PVOID));
}


//---[ CQuickList::CQuickList ]------------------------------------------------
//
//
//  Description:
//      Constructor for QQuickList, inserts it into the tail of current list
//  Parameters:
//
//  Returns:
//
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::CQuickList(CQuickList *pqlstHead)
{
    _ASSERT(pqlstHead);
    _ASSERT(pqlstHead->m_liListPages.Blink);
    CQuickList *pqlstTail = CONTAINING_RECORD(pqlstHead->m_liListPages.Blink, CQuickList, m_liListPages);
    _ASSERT(QUICK_LIST_SIG == pqlstTail->m_dwSignature);
    m_dwSignature = QUICK_LIST_SIG;
    m_dwCurrentIndexStart = pqlstTail->m_dwCurrentIndexStart + QUICK_LIST_PAGE_SIZE;
    m_cItems = QUICK_LIST_LEAF_PAGE;
    ZeroMemory(m_rgpvData, QUICK_LIST_PAGE_SIZE*sizeof(PVOID));
    InsertTailList(&(pqlstHead->m_liListPages), &m_liListPages);
}


//---[ CQuickList::~CQuickList ]-----------------------------------------------
//
//
//  Description:
//      CQuickList destructor
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQuickList::~CQuickList()
{
    m_dwSignature = QUICK_LIST_SIG_DELETE;
    CQuickList *pqlstCurrent = NULL;
    CQuickList *pqlstNext = NULL;
    if (QUICK_LIST_LEAF_PAGE != m_cItems)
    {
        //head node... loop through every thing and delete leaf pages
        pqlstCurrent = CONTAINING_RECORD(m_liListPages.Flink,
                        CQuickList, m_liListPages);
        while (this != pqlstCurrent)
        {
            pqlstNext = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink,
                        CQuickList, m_liListPages);
            delete pqlstCurrent;
            pqlstCurrent = pqlstNext;
        }
    }
}


//---[ CQuickList::pvGetItem ]-------------------------------------------------
//
//
//  Description:
//      Looks up item at given index
//  Parameters:
//      IN     dwIndex      Index of item to lookup
//      IN OUT ppvContext   Context for speeding up lookup
//  Returns:
//      Value of item at index
//      NULL if index is out of ranges
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CQuickList::pvGetItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext)
{
    _ASSERT(ppvContext);
    PVOID pvReturn = NULL;
    BOOL  fSearchForwards = TRUE;
    DWORD dwForwardDist = 0;
    DWORD dwBackwardDist = 0;
    DWORD dwMaxStartingIndex = m_cItems & QUICK_LIST_INDEX_MASK;
    CQuickList *pqlstDirection = NULL;
    CQuickList *pqlstCurrent = (CQuickList *) *ppvContext;
    CQuickList *pqlstSentinal = NULL;
    DWORD cDbgItems = m_cItems;

    if (dwIndex >= m_cItems)
        return NULL;

    if (!pqlstCurrent)
        pqlstCurrent = this;

    pqlstSentinal = pqlstCurrent;

    //short circuit direction logic
    if (pqlstCurrent->fIsIndexOnThisPage(dwIndex))
    {
        pvReturn = pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK];
        *ppvContext = pqlstCurrent;
        _ASSERT((dwIndex < m_cItems) || (NULL == pvReturn));
        goto Exit;
    }

    //determine which direction to go in (we want to traverse the smallest # of pages
    //possible
    pqlstDirection = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, CQuickList, m_liListPages);
    if (dwIndex > pqlstDirection->m_dwCurrentIndexStart)
        dwForwardDist = dwIndex - pqlstDirection->m_dwCurrentIndexStart;
    else
        dwForwardDist = pqlstDirection->m_dwCurrentIndexStart - dwIndex;

    pqlstDirection = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Blink, CQuickList, m_liListPages);
    if (dwIndex > pqlstDirection->m_dwCurrentIndexStart)
        dwBackwardDist = dwIndex - pqlstDirection->m_dwCurrentIndexStart;
    else
        dwBackwardDist = pqlstDirection->m_dwCurrentIndexStart - dwIndex;

    //fix up distances to account for going through the 0th page
    //max distance is dwMaxStartingIndex/2
    if (dwBackwardDist > dwMaxStartingIndex/2)
        dwBackwardDist -= dwMaxStartingIndex;

    if (dwForwardDist > dwMaxStartingIndex/2)
        dwForwardDist -= dwMaxStartingIndex;

    if (dwForwardDist > dwBackwardDist)
        fSearchForwards = FALSE;

    //$$NOTE: current lookup time is O(lg base{QUICK_LIST_PAGE_BASE} (n))/2.
    //Consecutive lookups will be O(1) (because of the hints)
    do
    {
        if (fSearchForwards)
        {
            //going forward is quicker
            pqlstCurrent = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Flink, CQuickList, m_liListPages);
        }
        else
        {
            //going backwards is quicker
            pqlstCurrent = CONTAINING_RECORD(pqlstCurrent->m_liListPages.Blink, CQuickList, m_liListPages);
        }

        _ASSERT(QUICK_LIST_SIG == pqlstCurrent->m_dwSignature);
        if (pqlstCurrent->fIsIndexOnThisPage(dwIndex))
        {
            pvReturn = pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK];
            _ASSERT((dwIndex < m_cItems) || (NULL == pvReturn));
            break;
        }

    } while (pqlstSentinal != pqlstCurrent); //stop when we return to list head

    *ppvContext = pqlstCurrent;
    _ASSERT((cDbgItems == m_cItems) && "Non-threadsafe access to CQuickList");

  Exit:
    return pvReturn;
}

//---[ CQuickList::pvDeleteItem ]----------------------------------------------
//
//
//  Description:
//      Will remove item at a given index from the quick list.
//
//      If you need to determine the data at that has been moved into this
//      index, call pvGetItem with the returned context, and it will return
//      without needing to search.
//  Parameters:
//      IN     dwIndex      Index of item to lookup
//      IN OUT ppvContext   Context for speeding up lookup
//  Returns:
//      Value of item that was removed.
//      NULL if index is out of ranges
//  History:
//      9/10/98 - MikeSwa Created
//      11/5/98 - MikeSwa Fixed problem about not always marking deleted
//                entry NULL.
//
//-----------------------------------------------------------------------------
PVOID CQuickList::pvDeleteItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext)
{
    PVOID pvItem = NULL;
    PVOID pvLast = NULL; //last item in list
    CQuickList *pqlstCurrent = NULL;  //page that index is on
    CQuickList *pqlstLast = NULL;     //last page
    DWORD dwLastIndex = m_cItems - 1;

    //Check to make sure that the index is valid
    if (dwIndex >= m_cItems)
        goto Exit;

    //Use single function to look up index and find quick list page
    pvItem = pvGetItem(dwIndex, (PVOID *) &pqlstCurrent);

    _ASSERT(pvItem); //we checked the index... and we cannot insert NULL ptrs
    _ASSERT(QUICK_LIST_SIG == pqlstCurrent->m_dwSignature);
    _ASSERT(pqlstCurrent->fIsIndexOnThisPage(dwIndex));

    //Now that we know the index and the page... we can move that last
    //entry in the list to this index.
    pqlstLast = CONTAINING_RECORD(m_liListPages.Blink, CQuickList, m_liListPages);
    _ASSERT(QUICK_LIST_SIG == pqlstLast->m_dwSignature);
    _ASSERT(pqlstLast->fIsIndexOnThisPage(dwLastIndex));
    if (dwLastIndex != dwIndex)
    {
        //In general if we are not deleting the last entry... we need to move
        //the last entry to the current index
         pvLast = pqlstLast->m_rgpvData[dwLastIndex & ~QUICK_LIST_INDEX_MASK];
         _ASSERT(pvLast); //shouldn't be NULL!

         //Now that we have last item... write it!
         pqlstCurrent->m_rgpvData[dwIndex & ~QUICK_LIST_INDEX_MASK] = pvLast;

         //NULL the old last entry
        pqlstLast->m_rgpvData[dwLastIndex & ~QUICK_LIST_INDEX_MASK] = NULL;
    }
    else
    {
        //if we deleted that last entry... the current and last pages
        //should be the same
        _ASSERT(pqlstLast == pqlstCurrent);

        //Set emptied data pointer to NULL
        pqlstLast->m_rgpvData[dwLastIndex & ~QUICK_LIST_INDEX_MASK] = NULL;
    }

    //Decrement total count
    m_cItems--;
    _ASSERT(QUICK_LIST_LEAF_PAGE != m_cItems);

    //Determine if it is neccessary to delete the last page
    if (!(dwLastIndex & ~QUICK_LIST_INDEX_MASK) && m_cItems)
    {
        //dwLastIndex was the only entry on the last page & it wasn't the head page

        //Unless the above test is wrong... the last page is *not* the head page
        _ASSERT(QUICK_LIST_LEAF_PAGE == pqlstLast->m_cItems);
        _ASSERT(this != pqlstLast);

        //Remove from list
        RemoveEntryList(&(pqlstLast->m_liListPages));

        if (pqlstCurrent == pqlstLast) //we cannot return a deleted context
            pqlstCurrent = this;

        delete pqlstLast;
    }

    //Safety check to make sure another thread hasn't come along
    _ASSERT(m_cItems == dwLastIndex);

  Exit:
    if (ppvContext)
        *ppvContext = pqlstCurrent;

    return pvItem;
}

//---[ CQuickList::HrAppendItem ]-----------------------------------------------
//
//
//  Description:
//      Appends new data item to end of array
//  Parameters:
//      IN  pvData      - Data to insert
//      OUT pdwIndex    - Index data was inserted at
//  Returns:
//      E_OUTOFMEMORY if unable to allocate another page
//      E_INVALIDARG if pvData is NULL
//  History:
//      6/15/98 - MikeSwa Created
//      9/9/98 - MikeSwa - Added pdwIndex OUT param
//
//-----------------------------------------------------------------------------
HRESULT CQuickList::HrAppendItem(IN PVOID pvData, OUT DWORD *pdwIndex)
{
    HRESULT hr = S_OK;
    CQuickList *pqlstCurrent = NULL;

    _ASSERT(pvData && "Cannot insert NULL pointers");

    if (!pvData)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (m_cItems && !(m_cItems & ~QUICK_LIST_INDEX_MASK)) //on page boundary
    {
        //there is not room on the last page
        pqlstCurrent = new CQuickList(this);
        if (!pqlstCurrent)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else if (!(m_cItems & QUICK_LIST_INDEX_MASK))
    {
        pqlstCurrent = this;
    }
    else
    {
        pqlstCurrent = CONTAINING_RECORD(m_liListPages.Blink, CQuickList, m_liListPages);
    }

    _ASSERT(pqlstCurrent->fIsIndexOnThisPage(m_cItems));
    pqlstCurrent->m_rgpvData[m_cItems & ~QUICK_LIST_INDEX_MASK] = pvData;

    //Set OUT param to index (before we increment the count)
    if (pdwIndex)
        *pdwIndex = m_cItems;

    m_cItems++;
    _ASSERT(QUICK_LIST_LEAF_PAGE != m_cItems);

  Exit:
    return hr;
}

//---[ CQuickList::Clone ]-----------------------------------------------------
//
//
//  Description:
//      Copies the contents of this CQuickList into a new CQuickList - caller
//      is responsible for deleting the CQuickList we create here
//  Parameters:
//      IN / OUT  pqlClone    - pointer to destination CQuickList pointer
//  Returns:
//      S_OK - cloned successfully
//      E_OUTOFMEMORY - failed to allocate CQuickList
//  History:
//      11/9/2000 - dbraun - created
//
//-----------------------------------------------------------------------------
HRESULT CQuickList::Clone (CQuickList **ppqlClone)
{
    HRESULT     hr          = S_OK;
    DWORD       dwIndex     = 0;
    PVOID       pvItem      = NULL;
    PVOID       pvContext   = NULL;
    DWORD       dwNewIndex  = 0;
    CQuickList *pql         = NULL;

    _ASSERT(ppqlClone);

    pql = new CQuickList();
    if (!pql)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Now copy the contents of this CQuickList
    for (dwIndex = 0; dwIndex < m_cItems; dwIndex++)
    {
        pvItem = pvGetItem(dwIndex, &pvContext);
        _ASSERT(pvItem);
        hr = pql->HrAppendItem(pvItem, &dwNewIndex);
        if (FAILED(hr))
            goto Exit; // Report the failure to our caller
    }

    *ppqlClone = pql;
    pql = NULL;

Exit:
    if (pql)
        delete pql;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\ptrwinst.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: rwinst.cpp
//
//  Description:  Implementation of CShareLockInst library functions
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      5/24/99 - MikeSwa Created 
//      8/6/99 - MikeSwa  created phatq version
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <aqprecmp.h>
#include <ptrwinst.h>

//Static initialization
LIST_ENTRY      CShareLockInst::s_liLocks;
volatile DWORD  CShareLockInst::s_dwLock = 0;
DWORD           CShareLockInst::s_cLockSpins = 0; 
DWORD           CShareLockInst::s_dwSignature = SHARE_LOCK_INST_SIG_FREE;

//---[ CThreadIdBlock::cIncThreadCount ]---------------------------------------
//
//
//  Description: 
//      Increments the thread count for a given thread ID
//  Parameters:
//      dwThreadId      Thread to increment the thread count for
//  Returns:
//      New count value
//  History:
//      8/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cIncThreadCount(DWORD dwThreadId)
{
    _ASSERT(THREAD_ID_BLOCK_UNUSED != dwThreadId);
    CThreadIdBlock *ptblkCurrent = this;
    CThreadIdBlock *ptblkOld = NULL;
    CThreadIdBlock *ptblkNew = NULL;

    while (ptblkCurrent)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblkCurrent->m_dwSignature);
        if (dwThreadId == ptblkCurrent->m_dwThreadId)
            return InterlockedIncrement((PLONG) &(ptblkCurrent->m_cThreadRecursionCount));

        ptblkOld = ptblkCurrent;
        ptblkCurrent = ptblkCurrent->m_ptblkNext;
    }

    _ASSERT(ptblkOld); //we should hit loop at least once

    //See if the current block has a thread ID associated with it
    if (THREAD_ID_BLOCK_UNUSED == ptblkOld->m_dwThreadId)
    {
        //This is actually the head block... use it to avoid an extra alloc
        if (THREAD_ID_BLOCK_UNUSED == InterlockedCompareExchange(
                    (PLONG) &ptblkOld->m_dwThreadId,
                    dwThreadId, THREAD_ID_BLOCK_UNUSED))
        {
            _ASSERT(dwThreadId == ptblkOld->m_dwThreadId);
            //Now this thread block is the current one
            return InterlockedIncrement((PLONG) &ptblkOld->m_cThreadRecursionCount);
        }
    }

    //We did not find it... we must create a new CThreadIdBlock
    ptblkNew = new CThreadIdBlock();

    //if we fail to alloc 32 bytes... I should see if we have spun out of
    //control
    _ASSERT(ptblkNew); 
    if (!ptblkNew)
        return 1; //Fake success for our callers
          
    ptblkNew->m_dwThreadId = dwThreadId;
    ptblkNew->m_cThreadRecursionCount = 1;
    
    ptblkCurrent = (CThreadIdBlock *) InterlockedCompareExchangePointer(
                        (PVOID *) &ptblkOld->m_ptblkNext,
                        (PVOID) ptblkNew,
                        NULL);

    //If it is non-NULL, then our insert failed
    if (ptblkCurrent)
    {
        _ASSERT(ptblkCurrent != ptblkNew);
        //Whoops... another thread has added a block... time to try again
        //This time, start search from the block the just appeared
        delete ptblkNew;
        return ptblkCurrent->cIncThreadCount(dwThreadId);
    }

    //We inserted the block... inital count was 1
    return 1;
}

//---[ CThreadIdBlock::cDecThreadCount ]---------------------------------------
//
//
//  Description: 
//      Decrements the thread count for a given thread ID
//  Parameters:
//      dwThreadId  
//  Returns:
//      The resulting count
//  History:
//      8/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cDecThreadCount(DWORD dwThreadId)
{
    _ASSERT(THREAD_ID_BLOCK_UNUSED != dwThreadId);
    CThreadIdBlock *ptblkCurrent = this;

    while (ptblkCurrent)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblkCurrent->m_dwSignature);
        if (dwThreadId == ptblkCurrent->m_dwThreadId)
            return InterlockedDecrement((PLONG) &(ptblkCurrent->m_cThreadRecursionCount));

        ptblkCurrent = ptblkCurrent->m_ptblkNext;
    }

    //We didn't find it... we would have asserted on insertion
    //Don't assert twice
    //$$TODO - Add global counts of these failures
    return 0;
}

//---[ CThreadIdBlock::cMatchesId ]--------------------------------------------
//
//
//  Description: 
//      Checks if this thread block (or one in this thread blocks chain) 
//      matches the given thread id.  Returns the count for this thread
//  Parameters:
//      dwThreadId - Thread Id to search for
//  Returns:
//      Thread count if the thread ID is found
//      0 if not found (or count is 0)
//  History:
//      8/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
DWORD CThreadIdBlock::cMatchesId(DWORD dwThreadId)
{
    CThreadIdBlock *ptblk = this;
    while (ptblk)
    {
        _ASSERT(THREAD_ID_BLOCK_SIG == ptblk->m_dwSignature);
        if (ptblk->m_dwThreadId == dwThreadId)
            return ptblk->m_cThreadRecursionCount;

        ptblk = ptblk->m_ptblkNext;
    }
    return 0;
}

//---[ CShareLockInst::AcquireStaticSpinLock ]---------------------------------
//
//
//  Description: 
//      Acquires static spin lock... from aqueue\cat\ldapstor
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Adapted from JStamerJ's code 
//
//-----------------------------------------------------------------------------
void CShareLockInst::AcquireStaticSpinLock()
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (s_dwLock > 0) 
        {
            Sleep(0);
            InterlockedIncrement((PLONG) &s_cLockSpins);
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement((PLONG) &s_dwLock) != 1 );

    //We have the lock... make sure that s_liLocks has been initialized
    if (s_dwSignature != SHARE_LOCK_INST_SIG)
    {
        InitializeListHead(&s_liLocks);
        s_dwSignature = SHARE_LOCK_INST_SIG;
    }
}

//---[ CShareLockInst::ReleaseStaticSpinLock ]---------------------------------
//
//
//  Description: 
//      Releases previously acquired spinlock
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Adapted from JStamerJ's code 
//
//-----------------------------------------------------------------------------
void CShareLockInst::ReleaseStaticSpinLock()
{
    _ASSERT(SHARE_LOCK_INST_SIG == s_dwSignature); //static init was done
    _ASSERT(s_dwLock > 0);
    InterlockedExchange((PLONG) &s_dwLock, 0 );
}

//---[ CShareLockInst::CShareLockInst ]----------------------------------------
//
//
//  Description: 
//      Constructor for CShareLockInst
//  Parameters:
//      szDescription       Constant string passed in to describe lock
//      dwFlags             Flags describing what to track
//      cMaxTrackedSharedThreadIDs  Maximum # of threads to track
//  Returns:
//      - 
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CShareLockInst::CShareLockInst(LPCSTR szDescription,
                               DWORD dwFlags, DWORD cMaxTrackedSharedThreadIDs)
{
    DWORD cbArray = sizeof(DWORD) * cMaxTrackedSharedThreadIDs;
    m_dwSignature = SHARE_LOCK_INST_SIG;
    m_dwFlags = dwFlags;
    m_liLocks.Flink = NULL;
    m_liLocks.Blink = NULL;
    m_cShareAttempts = 0;
    m_cShareAttemptsBlocked = 0;
    m_cExclusiveAttempts = 0;
    m_cExclusiveAttemptsBlocked = 0;
    m_szDescription = szDescription;
    m_rgtblkSharedThreadIDs = NULL;
    m_dwExclusiveThread = NULL;
    m_cCurrentSharedThreads = 0;
    m_cMaxConcurrentSharedThreads = 0;
    m_cMaxTrackedSharedThreadIDs = cMaxTrackedSharedThreadIDs;

    if (SHARE_LOCK_INST_TRACK_NOTHING & m_dwFlags)
        m_dwFlags = 0;

    //Allocate memory to store thread IDs
    if (fTrackSharedThreads())
    {
        _ASSERT(cbArray);
        m_rgtblkSharedThreadIDs = new CThreadIdBlock[m_cMaxTrackedSharedThreadIDs];
        if (!m_rgtblkSharedThreadIDs)
            m_cMaxTrackedSharedThreadIDs = 0;
    }

    //Insert in list if we are tracking
    if (fTrackInGlobalList())
    {
        AcquireStaticSpinLock();
        InsertHeadList(&s_liLocks, &m_liLocks);
        ReleaseStaticSpinLock();
    }
};

//---[ CShareLockinst::~CShareLockinst ]---------------------------------------
//
//
//  Description: 
//      CShareLockInst desctructor.  Will remove this lock from the
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CShareLockInst::~CShareLockInst()
{
    m_dwSignature = SHARE_LOCK_INST_SIG_FREE;
    if (m_rgtblkSharedThreadIDs)
    {
        delete [] m_rgtblkSharedThreadIDs;
        m_rgtblkSharedThreadIDs = NULL;
    }

    if (fTrackInGlobalList())
    {
        AcquireStaticSpinLock();
        RemoveEntryList(&m_liLocks);
        ReleaseStaticSpinLock();
    }

};


//---[ CShareLockInst::LogAcquireShareLock ]-----------------------------------
//
//
//  Description: 
//      Does all the work of logging the appropriate information when a thread 
//      acquires the lock shared.
//          - Updates max concurrent shared threads
//          - Updates current shared threads
//          - Updates lists of shared thread IDs
//          - Asserts when shared deadlocks are detected
//  Parameters:
//      BOOL    fTry - TRUE if this is for a try enter (deadlock cannot happen)
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::LogAcquireShareLock(BOOL fTry)
{

    if (fTrackSharedThreads())
    {
        DWORD   cCurrentSharedThreads = 0;
        DWORD   cMaxConcurrentSharedThreads = 0;
        DWORD   dwThreadID = GetCurrentThreadId();
        DWORD   dwThreadCount = 0;
        DWORD   dwThreadHash = 0;
        
        _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero
        cCurrentSharedThreads = InterlockedIncrement((PLONG) &m_cCurrentSharedThreads);

        //Update max concurrent threads if we have set a new record
        cMaxConcurrentSharedThreads = m_cMaxConcurrentSharedThreads;
        while (cCurrentSharedThreads > cMaxConcurrentSharedThreads)
        {
            InterlockedCompareExchange((PLONG) &m_cMaxConcurrentSharedThreads,
                                       (LONG) cCurrentSharedThreads,
                                       (LONG) cMaxConcurrentSharedThreads);

            cMaxConcurrentSharedThreads = m_cMaxConcurrentSharedThreads;
        }

        //if we have a place to store our thread ID...save it
        if (m_rgtblkSharedThreadIDs)
        {
            dwThreadHash = dwHashThreadId(dwThreadID, 
                                          m_cMaxTrackedSharedThreadIDs);
            _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
            dwThreadCount = m_rgtblkSharedThreadIDs[dwThreadHash].cIncThreadCount(dwThreadID);

            if (!fTry && (dwThreadCount > 1))
            {
                //This thread already holds this lock... this is a 
                //potential deadlock situation
                if (fAssertSharedDeadlocks())
                {
                    _ASSERT(0 && "Found potential share deadlock");
                }
            }
        }
    }
}

//---[ CShareLockInst::LogReleaseShareLock ]-----------------------------------
//
//
//  Description: 
//      Called when a sharelock is released to cleanup the information stored
//      in LogAcquireShareLock.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::LogReleaseShareLock()
{
    if (fTrackSharedThreads())
    {
        DWORD dwThreadID = GetCurrentThreadId();
        DWORD dwThreadHash = 0;

        _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero

        //Search through list of thread IDs for 
        if (m_rgtblkSharedThreadIDs)
        {
            dwThreadHash = dwHashThreadId(dwThreadID, 
                                          m_cMaxTrackedSharedThreadIDs);
            _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
            m_rgtblkSharedThreadIDs[dwThreadHash].cDecThreadCount(dwThreadID);
        }
    }
}

//---[ CShareLockInst::ShareLock ]---------------------------------------------
//
//
//  Description: 
//      Implements sharelock wrapper
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvShareLock()
{

    LogAcquireShareLock(FALSE);
    //If we are tracking contention, then we will try to enter the sharelock
    //and increment the contention count if that fails.
    if (fTrackContention())
    {
        InterlockedIncrement((PLONG) &m_cShareAttempts);
        if (!CShareLockInstBase::TryShareLock())
        {
            InterlockedIncrement((PLONG) &m_cShareAttemptsBlocked);
            CShareLockInstBase::ShareLock();
        }
    }
    else
    {
        CShareLockInstBase::ShareLock();
    }

};


//---[ CShareLockInst::ShareUnlock ]-------------------------------------------
//
//
//  Description: 
//      Wrapper for ShareUnlock
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvShareUnlock()
{
    LogReleaseShareLock();
    CShareLockInstBase::ShareUnlock();
};

//---[ CShareLockInst::TryShareLock ]------------------------------------------
//
//
//  Description: 
//      Implements TryShareLock wrapper.  
//  Parameters:
//
//  Returns:
//      TRUE if the lock was acquired.
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CShareLockInst::PrvTryShareLock()
{
    BOOL fLocked = FALSE;
    
    fLocked = CShareLockInstBase::TryShareLock();

    if (fLocked)
        LogAcquireShareLock(TRUE);

    return fLocked;
};

//---[ CShareLockInst::ExclusiveLock ]-----------------------------------------
//
//
//  Description: 
//      Implements ExclusiveLock wrapper
//  Parameters:
//
//  Returns:
//
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvExclusiveLock()
{

    //If we are tracking contention, then we will try to enter the lock
    //and increment the contention count if that fails.
    if (fTrackContention())
    {
        InterlockedIncrement((PLONG) &m_cExclusiveAttempts);
        if (!CShareLockInstBase::TryExclusiveLock())
        {
            InterlockedIncrement((PLONG) &m_cExclusiveAttemptsBlocked);
            CShareLockInstBase::ExclusiveLock();
        }
    }
    else
    {
        CShareLockInstBase::ExclusiveLock();
    }

    if (fTrackExclusiveThreads())
    {
        //This should be the only thread accessing this now
        _ASSERT(!m_dwExclusiveThread);
        m_dwExclusiveThread = GetCurrentThreadId();
    }

};


//---[ CShareLockInst::ExclusiveUnlock ]---------------------------------------
//
//
//  Description: 
//      Wrapper for ExclusiveUnlock
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvExclusiveUnlock()
{
    if (fTrackExclusiveThreads())
    {
        _ASSERT(GetCurrentThreadId() == m_dwExclusiveThread);
        m_dwExclusiveThread = 0;
    }
    CShareLockInstBase::ExclusiveUnlock();
};

//---[ CShareLockInst::TryExclusiveLock ]--------------------------------------
//
//
//  Description: 
//      Implements TryExclusiveLock wrapper.  
//  Parameters:
//
//  Returns:
//      TRUE if the lock was acquired.
//  History:
//      5/21/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CShareLockInst::PrvTryExclusiveLock()
{
    BOOL fLocked = FALSE;
    
    fLocked = CShareLockInstBase::TryExclusiveLock();

    if (fLocked && fTrackExclusiveThreads())
    {
        //This should be the only thread accessing this now
        _ASSERT(!m_dwExclusiveThread);
        m_dwExclusiveThread = GetCurrentThreadId();
    }
    return fLocked;
};

//---[ CShareLockInst::PrvAssertIsLocked ]-------------------------------------
//
//
//  Description: 
//      Asserts if this threads ID is not recorded as one that acquired this
//      lock.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/24/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CShareLockInst::PrvAssertIsLocked()
{
    DWORD dwThreadID = GetCurrentThreadId();
    DWORD dwThreadHash = 0;
    BOOL  fFoundThreadID = FALSE;
    
    _ASSERT(dwThreadID); //Our algorithm requires this to be non-zero

    //Bail out if we are not configured to track this things.
    if (!fTrackSharedThreads() || !fTrackExclusiveThreads() || !m_rgtblkSharedThreadIDs)
        return;

    if (dwThreadID == m_dwExclusiveThread)
    {
        fFoundThreadID = TRUE;
    }
    else
    {
        dwThreadHash = dwHashThreadId(dwThreadID, 
                                      m_cMaxTrackedSharedThreadIDs);
        _ASSERT(dwThreadHash < m_cMaxTrackedSharedThreadIDs);
        fFoundThreadID = (0 < m_rgtblkSharedThreadIDs[dwThreadHash].cMatchesId(dwThreadID));

    }

    if (!fFoundThreadID)
        _ASSERT(0 && "Lock is not held by this thread!!!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\propstrm.h ===
//----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998, 1999
//
//  Module:  rwstream.h
//
//  Description:  Contains definition of the read only / write only 
//                mailmsg property stream in epoxy shared memory.
//
//      10/20/98 - MaheshJ Created 
//      8/17/99 - MikeSwa Modified to use files instead of shared memory 
//----------------------------------------------------------------------------

#ifndef __PROPSTRM_H__
#define __PROPSTRM_H__

#define     FILE_PROPERTY_STREAM        'mrtS'
#define     FILE_PROPERTY_STREAM_FREE   'mtS!'

//---[ CFilePropertyStream ]--------------------------------------------------
//
//
//  Description: 
//      Implementation of IMailMsgPropertyStream that saves property
//      stream to a file
//  Hungarian: 
//      fstrm, pfstrm
//  
//-----------------------------------------------------------------------------
class CFilePropertyStream :
    public CBaseObject,
	public IMailMsgPropertyStream
{
public:
    CFilePropertyStream();
    ~CFilePropertyStream();

    HRESULT HrInitialize(LPSTR szFileName);

	//
	// IUnknown
	//
	HRESULT STDMETHODCALLTYPE QueryInterface(
				REFIID		iid,
				void		**ppvObject
				);

    ULONG STDMETHODCALLTYPE AddRef() {return CBaseObject::AddRef();};

    ULONG STDMETHODCALLTYPE Release() {return CBaseObject::Release();};

	//
	// IMailMsgPropertyStream
	//
	HRESULT STDMETHODCALLTYPE GetSize(
                IMailMsgProperties *pMsg,
				DWORD			*pdwSize,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE ReadBlocks(
                IMailMsgProperties *pMsg,
				DWORD			dwCount,
				DWORD			*pdwOffset,
				DWORD			*pdwLength,
				BYTE			**ppbBlock,
				IMailMsgNotify	*pNotify
				);

	HRESULT STDMETHODCALLTYPE WriteBlocks(
                IMailMsgProperties *pMsg,
				DWORD			dwCount,
				DWORD			*pdwOffset,
				DWORD			*pdwLength,
				BYTE			**ppbBlock,
				IMailMsgNotify	*pNotify
				);

    HRESULT STDMETHODCALLTYPE StartWriteBlocks(
                IMailMsgProperties *pMsg,
                DWORD dwBlocksToWrite,
				DWORD dwTotalBytesToWrite
                );
	
	HRESULT STDMETHODCALLTYPE EndWriteBlocks(IN IMailMsgProperties *pMsg);

    HRESULT STDMETHODCALLTYPE CancelWriteBlocks(IMailMsgProperties *pMsg);

private:
    DWORD   m_dwSignature;
    HANDLE  m_hDestFile;
};

#endif //__PROPSTRM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\qwiktime.h ===
//-----------------------------------------------------------------------------
//
//
//  File: qwiktime.h
//
//  Description: Header for CAQQuickTime class... a class to handle filling
//      and comparing FILETIME by using the GetTickCount instead of using
//      GetSystemTime
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/9/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __QWIKTIME_H__
#define __QWIKTIME_H__

#define QUICK_TIME_SIG 'miTQ'

class CAQQuickTime
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_dwLastInternalTime;
    FILETIME    m_ftSystemStart;

    DWORD dwGetInternalTime();
  public:
    CAQQuickTime();

    // Get expire time using context or by getting the current time
    void GetExpireTime(
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime,
                IN OUT DWORD *pdwExpireContext); //if non-zero, will use last time

    // Overloaded version takes start time instead of using context
    void GetExpireTime(
                IN     FILETIME ftStartTime,
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime);

    BOOL fInPast(IN FILETIME *pftExpireTime, IN OUT DWORD *pdwExpireContext);
};

#endif //__QWIKTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\qwiktime.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: qwiktime.cpp
//
//  Description:  Implementation of CAQQuickTime class
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/9/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "qwiktime.h"

//The basic premise is to use GetTickCount to get a reasonable accurate
//time information in a DWORD.  GetTickCount is only valid for 50 days, and
//has an accuracy of 1 ms.  50 days is just not long enough.
//MSchofie was kind enough to prepare the following table:
//Bit shift Resolution (seconds)    Uptime(years)
//3         0.008                   1.088824217
//4         0.016                   2.177648434
//5         0.032                   4.355296868
//6         0.064                   8.710593736
//7         0.128                   17.42118747
//8         0.256                   34.84237495
//9         0.512                   69.68474989
//10        1.024                   139.3694998
//11        2.048                   278.7389996
//12        4.096                   557.4779991
//13        8.192                   1114.955998
//14        16.384                  2229.911997
//15        32.768                  4459.823993
//16        65.536                  8919.647986

//The initial implementation used 16 bits, which had an error of about 66
//seconds, which drove our poor Y2K tester nuts.  8 bits (34 years uptime)
//seems much more reasonable.

//The system tick is shifted right INTERNAL_TIME_TICK_BITS and stored in
//the least significant INTERNAL_TIME_TICK_BITS bits of the internal time.
//The upper 32-INTERNAL_TIME_TICK_BITS bits
//is used to count the number of times the count rolls over
#define INTERNAL_TIME_TICK_BITS             8
#define INTERNAL_TIME_TICK_MASK             0x00FFFFFF

//Number where tick count has wrapped
const LONGLONG INTERNAL_TIME_TICK_ROLLOVER_COUNT
                                            = (1 << (32-INTERNAL_TIME_TICK_BITS));
const LONGLONG TICKS_PER_INTERNAL_TIME      = (1 << INTERNAL_TIME_TICK_BITS);

//conversion constants
//There are 10^6 milliseconds per nanosecond (FILETIME is in 100 nanosecond counts)
const LONGLONG FILETIMES_PER_TICK           = 10000;
const LONGLONG FILETIMES_PER_INTERNAL_TIME  = (FILETIMES_PER_TICK*TICKS_PER_INTERNAL_TIME);
const LONGLONG FILETIMES_PER_MINUTE         = (FILETIMES_PER_TICK*1000*60);

//---[ CAQQuickTime::CAQQuickTime ]--------------------------------------------
//
//
//  Description:
//      Default Constructor for CAQQuickTime.  Will call GetSystemTime once to
//      get start up time... GetTickCount is used for all other calls.
//  Parameters:
//      -
//  Returns:
//
//  History:
//      7/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQQuickTime::CAQQuickTime()
{
    DWORD  dwTickCount = GetTickCount();
    LARGE_INTEGER *pLargeIntSystemStart = (LARGE_INTEGER *) &m_ftSystemStart;

    m_dwSignature = QUICK_TIME_SIG;

    //Get internal time and start file time
    GetSystemTimeAsFileTime(&m_ftSystemStart);

    //convert tick count to internal time
    m_dwLastInternalTime = dwTickCount >> INTERNAL_TIME_TICK_BITS;

    //adjust start time so that it is the time when the tick count was zero
    pLargeIntSystemStart->QuadPart -= (LONGLONG) dwTickCount * FILETIMES_PER_TICK;

    //Some asserts to validate constants
    _ASSERT(!(INTERNAL_TIME_TICK_ROLLOVER_COUNT & INTERNAL_TIME_TICK_MASK));
    _ASSERT((INTERNAL_TIME_TICK_ROLLOVER_COUNT >> 1) & INTERNAL_TIME_TICK_MASK);

}

//---[ CAQQuickTime::dwGetInternalTime ]---------------------------------------
//
//
//  Description:
//      Gets internal time using GetTickCount... and makes sure that when
//      GetTickCount wraps, the correct time is returned.
//  Parameters:
//      -
//  Returns:
//      DWORD internal time
//  History:
//      7/9/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CAQQuickTime::dwGetInternalTime()
{
    DWORD dwCurrentTick = GetTickCount();
    DWORD dwLastInternalTime = m_dwLastInternalTime;
    DWORD dwCurrentInternalTime;
    DWORD dwCheck;

    dwCurrentInternalTime = dwCurrentTick >> INTERNAL_TIME_TICK_BITS;

    _ASSERT(dwCurrentInternalTime == (INTERNAL_TIME_TICK_MASK & dwCurrentInternalTime));

    //see if rolled over our tick count
    while ((dwLastInternalTime & INTERNAL_TIME_TICK_MASK) > dwCurrentInternalTime)
    {
        dwLastInternalTime = m_dwLastInternalTime;

        //it is possible that we have rolled over the tick count
        //first make sure it is not just a thread-timing issue
        dwCurrentTick = GetTickCount();
        dwCurrentInternalTime = dwCurrentTick >> INTERNAL_TIME_TICK_BITS;

        if ((dwLastInternalTime & INTERNAL_TIME_TICK_MASK) > dwCurrentInternalTime)
        {
            dwCurrentInternalTime |= (~INTERNAL_TIME_TICK_MASK & dwLastInternalTime);
            dwCurrentInternalTime += INTERNAL_TIME_TICK_ROLLOVER_COUNT;

            //attempt interlocked exchange to update internal last internal time
            dwCheck = (DWORD) InterlockedCompareExchange((PLONG) &m_dwLastInternalTime,
                                                  (LONG) dwCurrentInternalTime,
                                                  (LONG) dwLastInternalTime);

            if (dwCheck == dwLastInternalTime)  //exchange worked
                goto Exit;
        }

    }

  _ASSERT(dwCurrentInternalTime == (INTERNAL_TIME_TICK_MASK & dwCurrentInternalTime));
  dwCurrentInternalTime |= (~INTERNAL_TIME_TICK_MASK & m_dwLastInternalTime);

  Exit:
    return dwCurrentInternalTime;
}

//---[ CAQQuickTime::GetExpireTime ]-------------------------------------------
//
//
//  Description:
//      Get the expriation time for cMinutesExpireTime from now.
//  Parameters:
//      IN     cMinutesExpireTime   # of minutes in future to set time
//      IN OUT pftExpireTime        Filetime to store new expire time
//      IN OUT pdwExpireContext     If non-zero will use the same tick count
//                                  as previous calls (saves call to GetTickCount)
//  Returns:
//
//  History:
//      7/10/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CAQQuickTime::GetExpireTime(
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime,
                IN OUT DWORD *pdwExpireContext)
{
    TraceFunctEnterEx((LPARAM) this, "CAQQuickTime::GetExpireTime");
    _ASSERT(pftExpireTime);
    DWORD dwInternalTime = 0;
    LARGE_INTEGER *pLargeIntTime = (LARGE_INTEGER *) pftExpireTime;

    if (pdwExpireContext)
        dwInternalTime = *pdwExpireContext;

    if (!dwInternalTime)
    {
        dwInternalTime = dwGetInternalTime();
        //save internal time as context
        if (pdwExpireContext)
            *pdwExpireContext = dwInternalTime;
    }

    memcpy(pftExpireTime, &m_ftSystemStart, sizeof(FILETIME));

    //set to current time
    pLargeIntTime->QuadPart += (LONGLONG) dwInternalTime * FILETIMES_PER_INTERNAL_TIME;

    //set cMinutesExpireTime into the future
    pLargeIntTime->QuadPart += (LONGLONG) cMinutesExpireTime * FILETIMES_PER_MINUTE;

    DebugTrace((LPARAM) this, "INFO: Creating file time for %d minutes of 0x%08X %08X",
        cMinutesExpireTime, pLargeIntTime->HighPart, pLargeIntTime->LowPart);
    TraceFunctLeave();

}

//---[ CAQQuickTime::GetExpireTime ]-------------------------------------------
//
//
//  Description:
//      Get the expriation time for cMinutesExpireTime from ftStartTime
//  Parameters:
//      IN     cMinutesExpireTime   # of minutes in future to set time
//      IN OUT pftExpireTime        Filetime to store new expire time
//      IN     ftStartTime          Time to add expire minutes to
//  Returns:
//
//  History:
//      5/16/2001 - dbraun created from GetExpireTime above
//
//-----------------------------------------------------------------------------
void CAQQuickTime::GetExpireTime(
                IN     FILETIME ftStartTime,
                IN     DWORD cMinutesExpireTime,
                IN OUT FILETIME *pftExpireTime)
{
    TraceFunctEnterEx((LPARAM) this, "CAQQuickTime::GetExpireTime");
    _ASSERT(pftExpireTime);

    LARGE_INTEGER *pLargeIntTime = (LARGE_INTEGER *) pftExpireTime;

    // Set to start time
    memcpy(pftExpireTime, &ftStartTime, sizeof(FILETIME));

    //set cMinutesExpireTime into the future
    pLargeIntTime->QuadPart += (LONGLONG) cMinutesExpireTime * FILETIMES_PER_MINUTE;

    DebugTrace((LPARAM) this, "INFO: Creating file time for %d minutes of 0x%08X %08X",
        cMinutesExpireTime, pLargeIntTime->HighPart, pLargeIntTime->LowPart);
    TraceFunctLeave();

}


//---[ CAQQuickTime::fInPast ]-------------------------------------------------
//
//
//  Description:
//      Determines if a given file time has already happened
//  Parameters:
//      IN     pftExpireTime        FILETIME with expiration
//      IN OUT pdwExpireContext     If non-zero will use the same tick count
//                                  as previous calls (saves call to GetTickCount)
//  Returns:
//      TRUE if expire time is in the past
//      FALSE if expire time is in the future
//  History:
//      7/11/98 - MikeSwa Created
//  Note:
//      You should NOT use the same context used to get the filetime, because
//      it will always return FALSE
//
//-----------------------------------------------------------------------------
BOOL CAQQuickTime::fInPast(IN FILETIME *pftExpireTime,
                           IN OUT DWORD *pdwExpireContext)
{
    _ASSERT(pftExpireTime);
    DWORD          dwInternalTime = 0;
    FILETIME       ftCurrentTime = m_ftSystemStart;
    LARGE_INTEGER *pLargeIntCurrentTime = (LARGE_INTEGER *) &ftCurrentTime;
    LARGE_INTEGER *pLargeIntExpireTime = (LARGE_INTEGER *) pftExpireTime;
    BOOL           fInPast = FALSE;

    if (pdwExpireContext)
        dwInternalTime = *pdwExpireContext;

    if (!dwInternalTime)
    {
        dwInternalTime = dwGetInternalTime();
        //save internal time as context
        if (pdwExpireContext)
            *pdwExpireContext = dwInternalTime;
    }

    //Get current time
    pLargeIntCurrentTime->QuadPart += (LONGLONG) dwInternalTime * FILETIMES_PER_INTERNAL_TIME;

    if (pLargeIntCurrentTime->QuadPart > pLargeIntExpireTime->QuadPart)
        fInPast =  TRUE;

    return fInPast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\qwiklist.h ===
//-----------------------------------------------------------------------------
//
//
//	File: qwiklist.h
//
//	Description: Provides a quick paged/growable list implementation.
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		6/15/98 - MikeSwa Created
//      9/9/98 - MikeSwa Modified to include functionality to delete entries
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __QWIKLIST_H__
#define __QWIKLIST_H__

#include <aqincs.h>
#include <listmacr.h>

#define QUICK_LIST_SIG  'tsLQ'
#define QUICK_LIST_SIG_DELETE 'slQ!'

const DWORD QUICK_LIST_PAGE_SIZE = 16;  //must be a power of 2

//Mask used to quickly determine if a given index is on the current page
const DWORD QUICK_LIST_INDEX_MASK = ~(QUICK_LIST_PAGE_SIZE-1);

//When m_cItems is set to this value... we know this is not the head page.
const DWORD QUICK_LIST_LEAF_PAGE = 0xFFFF7EAF;

class CQuickList
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_dwCurrentIndexStart;
    LIST_ENTRY  m_liListPages;
    DWORD       m_cItems;
    PVOID       m_rgpvData[QUICK_LIST_PAGE_SIZE];
    inline BOOL fIsIndexOnThisPage(DWORD dwIndex);
  public:
    static CPool s_QuickListPool;
    void *operator new(size_t size);
    void operator delete(void *p, size_t size);

    CQuickList(); //initialize entry as head
    CQuickList(CQuickList *pqlstHead); //initialize as new page in list
    ~CQuickList();

    DWORD dwGetCount() {return m_cItems;};
    PVOID pvGetItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext);
    PVOID pvDeleteItem(IN DWORD dwIndex, IN OUT PVOID *ppvContext);
    HRESULT HrAppendItem(IN PVOID pvData, OUT DWORD *pdwIndex);

    HRESULT Clone (CQuickList **ppqlClone);
};

//---[ CQuickList::fIsIndexOnThisPage ]----------------------------------------
//
//
//  Description:
//      Returns TRUE is the given index is on this page
//  Parameters:
//      dwIndex     - Index to check for
//  Returns:
//      TRUE if index is on this page... FALSE otherwise
//  History:
//      6/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CQuickList::fIsIndexOnThisPage(DWORD dwIndex)
{
    return ((dwIndex & QUICK_LIST_INDEX_MASK) == m_dwCurrentIndexStart);
}


inline void *CQuickList::operator new(size_t size)
{
    return s_QuickListPool.Alloc();
}

inline void CQuickList::operator delete(void *p, size_t size)
{
    s_QuickListPool.Free(p);
}

#endif //__QWIKLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\refstr.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: refstr.cpp
//
//  Description:  Implementation of CRefCountedString and helper functions.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      11/11/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "refstr.h"

//---[ CRefCountedString ]-----------------------------------------------------
//
//
//  Description: 
//      Initializes a ref-counted string to the given string.
//  Parameters:
//      szStr       String to initialize to
//      cbStrlen    Length of string to initialize to
//  Returns:
//      TRUE on success
//      FALSE if required memory could not be allocated.
//  History:
//      11/11/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CRefCountedString::fInit(LPSTR szStr, DWORD cbStrlen)
{
    _ASSERT(CREFSTR_SIG_VALID == m_dwSignature);

    //We allow init of an empty string
    if (!cbStrlen || !szStr)
    {
        m_cbStrlen = 0;
        m_szStr = NULL;
        return TRUE;
    }

    _ASSERT(szStr);
    _ASSERT(cbStrlen);

    m_cbStrlen = cbStrlen;
    m_szStr = (LPSTR) pvMalloc(sizeof(CHAR) * (cbStrlen+1));
    if (!m_szStr)
        return FALSE;


    memcpy(m_szStr, szStr, cbStrlen);
    m_szStr[cbStrlen] = '\0';
    return TRUE;
}


//---[ HrUpdateRefCountedString ]----------------------------------------------
//
//
//  Description: 
//      Function to update a ref-counted string.  Typically used to update 
//      config strings.
//  Parameters:
//      pprstrCurrent       Ptr to ptr to string.  Will be replaced with 
//                          an updated version if neccessary.
//      szNew               The new string.
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if we could not allocate the memory required to handle
//          this.
//  History:
//      11/9/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT HrUpdateRefCountedString(CRefCountedString **pprstrCurrent, LPSTR szNew)
{
    _ASSERT(pprstrCurrent);
    HRESULT hr = S_OK;
    DWORD   cbStrLen = 0;
    CRefCountedString *prstrNew = *pprstrCurrent;
    CRefCountedString *prstrCurrent = *pprstrCurrent;

    if (!szNew)
        prstrNew = NULL;  //we don't want to do a strcmp here
    else 
        cbStrLen = lstrlen(szNew);
    
    if (prstrNew)
    {
        //First free up old info... if different
        if (!prstrCurrent->szStr() ||
            lstrcmp(prstrCurrent->szStr(), szNew))
        {
            //strings are different... blow away old info
            prstrNew = NULL;
        }
    }

    //Check if either old string is different, or there was no old string
    if (!prstrNew)
    {
        //only update and allocate if changed
        prstrNew = new CRefCountedString();
        if (prstrNew)
        {
            if (!prstrNew->fInit(szNew, cbStrLen))
            {
                prstrNew->Release();
                prstrNew = NULL;
            }
        }

        if (!prstrNew)
        {
            //We ran into some failure
            hr = E_OUTOFMEMORY;
        }
        else //release old value & save New
        {
            if (prstrCurrent)
            {
                prstrCurrent->Release();
                prstrCurrent = NULL;
            }
            *pprstrCurrent = prstrNew;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\refstr.h ===
//-----------------------------------------------------------------------------
//
//
//  File: refstr.h
//
//  Description:  Definition/Implementation of refcounted string.  Used to hold
//      dynamic config data.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/8/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __REFSTR_H__
#define __REFSTR_H__

#define CREFSTR_SIG_VALID   'rtSR'
#define CREFSTR_SIG_INVALID 'rtS!'

//---[ CRefCountedString ]-----------------------------------------------------
//
//
//  Description: 
//      Implemenation of a ref-counted string.  Designed to hold config data, 
//      so that it can be passed to event sinks without holding a share lock.
//  Hungarian: 
//      rstr, prstr
//  
//-----------------------------------------------------------------------------
class CRefCountedString : public CBaseObject
{
  protected:
    DWORD       m_dwSignature;
    DWORD       m_cbStrlen;     //length of string w/o NULL
    LPSTR       m_szStr;        //string data
  public:
    CRefCountedString()
    {
        m_dwSignature = CREFSTR_SIG_VALID;
        m_cbStrlen = 0;
        m_szStr = NULL;
    };

    ~CRefCountedString()
    {
        if (m_szStr)
            FreePv(m_szStr);
        m_szStr = NULL;
        m_cbStrlen = 0;
        m_dwSignature = CREFSTR_SIG_INVALID;
    }

    //Used to allocate memory for string
    // return FALSE if allocation fails
    BOOL fInit(LPSTR szStr, DWORD cbStrlen);

    //Return strlen of string
    DWORD cbStrlen() 
    {
        _ASSERT(CREFSTR_SIG_VALID == m_dwSignature);
        return m_cbStrlen;
    };

    //Returns string
    LPSTR szStr() 
    {
        _ASSERT(CREFSTR_SIG_VALID == m_dwSignature);
        return m_szStr;
    };

};

HRESULT HrUpdateRefCountedString(CRefCountedString **pprstrCurrent, LPSTR szNewString);


#endif //__REFSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\shutdown.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: shutdown.cpp
//
//  Description:  Implementation of CSyncShutdown.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "shutdown.h"
#include "aqutil.h"

//---[ CSyncShutdown::~CSyncShutdown ]-----------------------------------------
//
//
//  Description: 
//      CSyncShutdown Destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CSyncShutdown::~CSyncShutdown()
{
    //There should not be any outstanding locks
    m_dwSignature = CSyncShutdown_SigFree;
    _ASSERT(0 == (m_cReadLocks & ~SYNC_SHUTDOWN_SIGNALED));
}

//---[ CSyncShutdown::fTryShutdownLock ]---------------------------------------
//
//
//  Description: 
//      Trys to aquire Shared lock to guard against shutdown happening.  This
//      call will *not* block, but may cause the thread calling SignalShutdown
//      to block.
//  Parameters:
//      -
//  Returns:
//      TRUE if shutdown lock can be aquired and shutdown has not started.
//      FALSE if lock cannot be aquired (thread in SignalShutdown) or if 
//          SYNC_SHUTDOWN_SIGNALED has already been set.
//
//-----------------------------------------------------------------------------
BOOL CSyncShutdown::fTryShutdownLock()
{

    if (m_cReadLocks & SYNC_SHUTDOWN_SIGNALED)
        return FALSE;
    else if (!m_slShutdownLock.TryShareLock())  //Never block for the lock..
        return FALSE;

    //Check bit again... now that we have sharelock
    if (m_cReadLocks & SYNC_SHUTDOWN_SIGNALED)
    {
        m_slShutdownLock.ShareUnlock();
        return FALSE;
    }

    //In retail, m_cReadLocks is only used for the SYNC_SHUTDOWN_SIGNALED flag
    DEBUG_DO_IT(InterlockedIncrement((PLONG) &m_cReadLocks));
    return TRUE;
}

//---[ CSyncShutdown::ShutdownUnlock ]-----------------------------------------
//
//
//  Description: 
//      Releases a perviously aquired share lock.  Must be matched with a 
//      *succeeding* call to fTryShutdownLock().
//  Parameters:
//      -
//  Returns:
//      -
//
//      Will assert if called more times than there are outstanding share locks
//
//-----------------------------------------------------------------------------
void CSyncShutdown::ShutdownUnlock()
{
    _ASSERT(0 < (m_cReadLocks & ~SYNC_SHUTDOWN_SIGNALED));

    //In retail, m_cReadLocks is only used for the SYNC_SHUTDOWN_SIGNALED flag
    DEBUG_DO_IT(InterlockedDecrement((PLONG) &m_cReadLocks));
    m_slShutdownLock.ShareUnlock();
}

//---[ CSyncShutdown::SignalShutdown ]-----------------------------------------
//
//
//  Description: 
//      Aquires the Exclusive lock & sets the shutdown flag, which will prevent
//      Any further shared locks from being aquired.  
//
//      This call *may* block, and should not be called by a thread that 
//      already owns a shared shutdown lock.  This is unlikely to happen, since
//      This should only be called by a thread that stopping the server
//      instance.
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
void CSyncShutdown::SignalShutdown()
{

    //Let everyone know that we are shutting down... once this is called, no
    //one will be able to grab the lock shared.
    SetShutdownHint();

    //Wait until all threads that have acquired the lock are done
    m_slShutdownLock.ExclusiveLock();
    m_slShutdownLock.ExclusiveUnlock();
    
    //Now all calls to fTryShutdownLock should fail
    _ASSERT(!fTryShutdownLock());
}

//---[ CSyncShutdown::SetShutdownHint ]----------------------------------------
//
//
//  Description: 
//      Sets the shutdown hint so that further calls to fTryShutdownLock
//      will fail.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/7/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CSyncShutdown::SetShutdownHint()
{
    dwInterlockedSetBits(&m_cReadLocks, SYNC_SHUTDOWN_SIGNALED);

    //Now all calls to fTryShutdownLock should fail
    _ASSERT(!fTryShutdownLock());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\shutdown.h ===
//-----------------------------------------------------------------------------
//
//
//  File: shutdown.h
//
//  Description:  An inheritable class that uses SharedLock to synchronize 
//      shutdown.
//
//  Author: mikeswa
//
//  History:
//      9/4/98 - MikeSwa Modified to have a non-blocking fTryShutdownLock.
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __SHUTDOWN_H__
#define __SHUTDOWN_H__

class CSyncShutdown;

#include <aqincs.h>
#include <rwnew.h>

#define CSyncShutdown_Sig       'tuhS'
#define CSyncShutdown_SigFree   'thS!'

//Bit in m_cReadLocks used to signal that shudown is in progress
const DWORD SYNC_SHUTDOWN_SIGNALED = 0x80000000;

//---[ CSyncShutdown ]---------------------------------------------------------
//
//
//  Synchronization object that is a base class for AQ objects.  This is 
//  designed to allow objects to know when it is OK to access member variables,
//  and is really only needed in components that have external threads calling
//  in (current CAQSvrInst and CConnMgr).
//
//  The basic usage is to call fTryShutdownLock() before access member data.  If
//  it fails, return AQUEUE_E_SHUTDOWN... otherwise you can access member data
//  until you call ShutdownUnlock().  Neither of these calls will block:
//
//      if (!fTryShutdownLock())
//      {
//          hr = AQUEUE_E_SHUTDOWN;
//          goto Exit;
//      }
//      ...
//      ShutdownUnlock();
//
//  SignalShutdown should be called during the inheriting function's
//  HrDeInitialize().  This will cause all further calls to fTryShutdownLock()
//  to fail.  This call will block until all threads that have had a successful
//  fTryShutdownLock() call ShutdownUnlock().
//
//-----------------------------------------------------------------------------
class CSyncShutdown
{
  private:
    DWORD           m_dwSignature;
    DWORD           m_cReadLocks;  //Keep track of the number of read locks
    CShareLockNH    m_slShutdownLock;
  public:
    CSyncShutdown() 
    {
        m_dwSignature = CSyncShutdown_Sig;
        m_cReadLocks = 0;
    };
    ~CSyncShutdown();
    BOOL     fTryShutdownLock();
    void     ShutdownUnlock();
    void     SignalShutdown();

    BOOL     fShutdownSignaled() {return (m_cReadLocks & SYNC_SHUTDOWN_SIGNALED);};
    //Assert that can be used to verify that the lock is held by somethread
    void     AssertShutdownLockAquired() {_ASSERT(m_cReadLocks & ~SYNC_SHUTDOWN_SIGNALED);};

    void     SetShutdownHint(); //causes future calls to fTryShutdownLock to fail
};

#endif //__SHUTDOWN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\smtpconn.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: 
//      smtpconn.cpp
//  Description:
//      Implementation of CSMTPConn
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "SMTPConn.h"
#include "connmgr.h"
#include "domcfg.h"

CPool CSMTPConn::s_SMTPConnPool;

//---[ CSMTPConn::CSMTPConn() ]------------------------------------------------
//
//
//  Description: 
//      CSMTPConn constructor
//  Parameters:
//      IN  pConnMgr                    Ptr to instance connection manager
//      IN  plmq                        Ptr to link for this connection
//      IN  cMaxMessagesPerConnection   Max messages to send per connection
//                                      0 implies unlimited
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CSMTPConn::CSMTPConn(CConnMgr *pConnMgr, CLinkMsgQueue *plmq, 
                     DWORD cMaxMessagesPerConnection)
{
    _ASSERT(pConnMgr);
    _ASSERT(plmq);

    m_dwSignature = SMTP_CONNECTION_SIG;
    m_pConnMgr = pConnMgr;
    m_pIntDomainInfo = NULL;
    m_plmq = plmq;
    m_cFailedMsgs = 0;
    m_cTriedMsgs = 0;
    m_cMaxMessagesPerConnection = cMaxMessagesPerConnection;
    m_dwConnectionStatus = CONNECTION_STATUS_OK;
    m_szDomainName = NULL;
    m_cbDomainName = 0;
    m_liConnections.Flink = NULL;
    m_liConnections.Blink = NULL;
    m_cAcks = 0;
    m_dwTickCountOfLastAck = 0;

    ZeroMemory(m_szConnectedIPAddress, sizeof(m_szConnectedIPAddress));
    if (plmq)
    {
        plmq->AddRef();
    }
}
                     
//---[ CSMTPConn::~CSMTPConn() ]-----------------------------------------------
//
//
//  Description: 
//      CSMTPConn default destructor
//  Parameters:
//      -
//  Returns:
//      -
//
//-----------------------------------------------------------------------------
CSMTPConn::~CSMTPConn()
{
    HRESULT hrConnectionStatus = S_OK;
    BOOL    fForceCheckForDSNGeneration = FALSE;
    _ASSERT(m_cAcks == m_cTriedMsgs);
    if (m_plmq != NULL)
    {
        _ASSERT(m_pConnMgr);
        m_pConnMgr->ReleaseConnection(this, &fForceCheckForDSNGeneration);

        switch(m_dwConnectionStatus)
        {
            case CONNECTION_STATUS_OK:
                hrConnectionStatus = S_OK;
                break;
            case CONNECTION_STATUS_FAILED:
                hrConnectionStatus = AQUEUE_E_HOST_NOT_RESPONDING;
                break;
            case CONNECTION_STATUS_DROPPED:
                hrConnectionStatus = AQUEUE_E_CONNECTION_DROPPED;
                break;
            case CONNECTION_STATUS_FAILED_LOOPBACK:
                hrConnectionStatus = AQUEUE_E_LOOPBACK_DETECTED;
                break;
            case CONNECTION_STATUS_FAILED_NDR_UNDELIVERED:
                hrConnectionStatus = AQUEUE_E_SMTP_GENERIC_ERROR;
                break;
            default:
                _ASSERT(0 && "Undefined Connection Status");
                hrConnectionStatus = S_OK;
        }

        m_plmq->SetLastConnectionFailure(hrConnectionStatus);
        m_plmq->RemoveConnection(this, fForceCheckForDSNGeneration);

        m_plmq->Release();

        //We should kick the connection manager, because if we were generating
        //DSNs, no connection could be made
        m_pConnMgr->KickConnections();
    }

    if (m_pIntDomainInfo)
        m_pIntDomainInfo->Release();

}

//---[ CSMTPConn::QueryInterface ]------------------------------------------
//
//
//  Description:
//      QueryInterface for IAdvQueue
//  Parameters:
//
//  Returns:
//      S_OK on success
//
//  Notes:
//      This implementation makes it possible for any server component to get
//      the IAdvQueueConfig interface.
//
//  History:
//      11/27/2001 - MikeSwa copied from CAQSvrInst
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = S_OK;

    if (!ppvObj)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (IID_IUnknown == riid)
    {
        *ppvObj = static_cast<ISMTPConnection *>(this);
    }
    else if (IID_ISMTPConnection == riid)
    {
        *ppvObj = static_cast<ISMTPConnection *>(this);
    }
    else if (IID_IConnectionPropertyManagement == riid)
    {
        *ppvObj = static_cast<IConnectionPropertyManagement *>(this);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
        goto Exit;
    }

    static_cast<IUnknown *>(*ppvObj)->AddRef();

  Exit:
    return hr;
}

//---[ CSMTPConn::GetNextMessage ]---------------------------------------------
//
//
//  Description: 
//      Implementation of ISMTPConnection::GetNextMsg.
//      Gets the next message queued for this connection and determines which 
//      recipients should be delivered for this connection.
//  Parameters:
//      OUT ppimsg          New IMsg top be delivered
//      OUT pdwMsgContext   A 32-bit Context that needs to be provided in the 
//                          message ack.
//      OUT pcIndexes       The number of index in prgdwRecipIndex
//      OUT prgdwRecipIndex Recipient indexes that the caller is responsible 
//                          for attempting delivery to.
//  Returns:
//
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::GetNextMessage(
        OUT IMailMsgProperties  **ppIMailMsgProperties, 
        OUT DWORD ** ppvMsgContext, 
        OUT DWORD *  pcIndexes, 
        OUT DWORD ** prgdwRecipIndex)
{
    TraceFunctEnterEx((LPARAM) this, "CSMTPConn::GetNextMessage");
    HRESULT hr = S_OK;

   //We get the next message only if we are under the batch limit

    if(m_cMaxMessagesPerConnection && 
       (m_cTriedMsgs >= m_cMaxMessagesPerConnection) &&
       (!m_pIntDomainInfo || 
        !((DOMAIN_INFO_TURN_ONLY | DOMAIN_INFO_ETRN_ONLY) &
          m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags)))
    {
        //SMTP does not check - but we may need a specific error for this case
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    if (m_pConnMgr && m_pConnMgr->fConnectionsStoppedByAdmin())
    {
        //Admin has requested that all outbound connections stop
        hr = AQUEUE_E_QUEUE_EMPTY;
        goto Exit;
    }

    hr = m_plmq->HrGetNextMsg(&m_dcntxtCurrentDeliveryContext, ppIMailMsgProperties, 
                              pcIndexes, prgdwRecipIndex);
    if (FAILED(hr))
        goto Exit;  
    //this will automagically catch the queue empty case...
    //If the Link has no more messages it will return AQUEUE_E_QUEUE_EMPTY, which
    //should cause the caller to Release() and query GetNextConnection again.

    *ppvMsgContext = (DWORD *) &m_dcntxtCurrentDeliveryContext;

    //increment the messages served
    InterlockedIncrement((PLONG)&m_cTriedMsgs);

  Exit:
    if (!m_cTriedMsgs)
        DebugTrace((LPARAM) this, "GetNextMessage called, but no messages tried for this connection");

    //rewrite error for SMTPSVC
    if (AQUEUE_E_QUEUE_EMPTY == hr)
        hr = HRESULT_FROM_WIN32(ERROR_EMPTY);

    TraceFunctLeave();
    return hr;
}

//---[ CSMTPConn::AckMessage ]-------------------------------------------------
//
//
//  Description: 
//      Acknowledges the delivery of a message (success/error codes are put in
//      the envelope by the transport).
//
//      Implements ISMTPConnection::AckMessage();
//  Parameters:
//      IN pIMsg        IMsg to acknowledge
//      IN dwMsgContext Context that was returned by GetNextMessage
//      IN eMsgStatus   Status of message
//  Returns:
//      S_OK on success
//      E_INVALIDARG if dwMsgContext is invalid
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::AckMessage(/*[in]*/ MessageAck *pMsgAck)
{
    HRESULT hr = S_OK;
    DWORD   dwTickCount = GetTickCount();
    _ASSERT(m_plmq);
    _ASSERT(pMsgAck);

    if (!(pMsgAck->dwMsgStatus & MESSAGE_STATUS_ALL_DELIVERED))
    {
        m_cFailedMsgs++;
    }


    InterlockedIncrement((PLONG)&m_cAcks);
    _ASSERT(m_cAcks == m_cTriedMsgs);
    hr = m_plmq->HrAckMsg(pMsgAck);

    m_dwTickCountOfLastAck = dwTickCount; //Set after assert so we can compare

    return hr;
}

//---[ CSMTPConn::GetSMTPDomain ]----------------------------------------------
//
//
//  Description: 
//      Returns the SMTPDomain of the link associated with this connections.
//
//      $$REVIEW:
//      This method does not allocate new memory for this string, but instead 
//      relies on the good intentions of the SMTP stack (or test driver) to 
//      not overwrite this memory. If we ever expose this interface externally,
//      then we should revert to allocating memory and doing a buffer copy
//
//      Implements ISMTPConnection::GetSMTPDomain
//  Parameters:
//      IN OUT  pDomainInfo     Ptr to DomainInfo struct supplied by caller
//                              and filled in here
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::GetDomainInfo(IN OUT DomainInfo *pDomainInfo)
{
    HRESULT hr = S_OK;

    _ASSERT(pDomainInfo->cbVersion >= sizeof(DomainInfo));
    _ASSERT(pDomainInfo);

    if (NULL == m_plmq)
    {
        hr = AQUEUE_E_LINK_INVALID;
        goto Exit;
    }

    if (!m_pIntDomainInfo)
    {
        //Try to get domain info
        hr = m_plmq->HrGetDomainInfo(&m_cbDomainName, &m_szDomainName,
                            &m_pIntDomainInfo);
        if (FAILED(hr))
        {
            m_pIntDomainInfo = NULL;
            _ASSERT(AQUEUE_E_INVALID_DOMAIN != hr);
            goto Exit;
        }
    }

    _ASSERT(m_pIntDomainInfo);
    _ASSERT(m_cbDomainName);
    _ASSERT(m_szDomainName);

    // Is it OK to send client side commands on this connection
    // If not, we reset those domain info flags so SMTp cannot see them
    if(!m_plmq->fCanSendCmd())
    {
         m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &= ~(DOMAIN_INFO_SEND_TURN | DOMAIN_INFO_SEND_ETRN);
    }

    // If SMTP doesn't have the DOMAIN_INFO_TURN_ON_EMPTY then it is the older,
    // broken SMTP and we shouldn't allow TURN on empty to work.
    if ((m_plmq->cGetTotalMsgCount() == 0) && 
        !(m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags & 
          DOMAIN_INFO_TURN_ON_EMPTY))
    {
         m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags &= ~DOMAIN_INFO_SEND_TURN;
    }

    //copy everything but size
    memcpy(&(pDomainInfo->dwDomainInfoFlags), 
            &(m_pIntDomainInfo->m_DomainInfo.dwDomainInfoFlags), 
            sizeof(DomainInfo) - sizeof(DWORD));

    //make sure our assumptions about the struct of DomainInfo are valid
    _ASSERT(1 == ((DWORD *) &(pDomainInfo->dwDomainInfoFlags)) - ((DWORD *) pDomainInfo));

    //we've filled pDomainInfo with the info for our Domain
    if (pDomainInfo->szDomainName[0] == '*')
    {
        //we matched a wildcard domain... substitute our domain name
        pDomainInfo->cbDomainNameLength = m_cbDomainName;
        pDomainInfo->szDomainName = m_szDomainName;
    }
    else
    {
        //if it wasn't a wildcard match... strings should match!
        _ASSERT(0 == _stricmp(m_szDomainName, pDomainInfo->szDomainName));
    }

  Exit:
    return hr;
}


//---[ CSMTPConn::SetDiagnosticInfo ]------------------------------------------
//
//
//  Description: 
//      Sets the extra diagnostic information for this connection.
//  Parameters:
//      IN      hrDiagnosticError       Error code... if SUCCESS we thow away
//                                      the rest of the information
//      IN      szDiagnosticVerb        String pointing to the protocol
//                                      verb that caused the failure.
//      IN      szDiagnosticResponse    String that contains the remote
//                                      servers response.
//  Returns:
//      S_OK always
//  History:
//      2/18/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::SetDiagnosticInfo(
                    IN  HRESULT hrDiagnosticError,
                    IN  LPCSTR szDiagnosticVerb,
                    IN  LPCSTR szDiagnosticResponse)
{

    TraceFunctEnterEx((LPARAM) this, "CSMTPConn::SetDiagnosticInfo");

    if (m_plmq && FAILED(hrDiagnosticError))
    {
        m_plmq->SetDiagnosticInfo(hrDiagnosticError, szDiagnosticVerb,
                                  szDiagnosticResponse);
    }
    TraceFunctLeave();
    return S_OK; //always return S_OK
}

//---[ CSMTPConn::CopyQueuePropertiesToSession ]-------------------------------
//
//
//  Description:
//      Copies the set of propties that queuing owns into the SMTP session
//      object.  In some cases, these properties are required for security 
//      reasons (ie - a sink wants to know who we think we are connecting to
//      instead of who the remote side says they are).
//  Parameters:
//      IN      IUnknown           SMTP Session object to copy properties to
//          NOTE: We need to resist the urge to AddRef and keep this around
//          later use.  AddRefs on this object are actually ignored as the
//          lifetime is controlled by either the SMTP connection object
//          or the stack.
//                                 
//  Returns:
//      S_OK always
//  History:
//      11/27/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::CopyQueuePropertiesToSession(IN  IUnknown *pISession)
{
    TraceFunctEnterEx((LPARAM) this, "SMTPConn::CopyQueuePropertiesToSession");
    HRESULT hr = S_OK;
    IMailMsgPropertyBag *pISessionProperties = NULL;
    LPSTR   szConnectorName = NULL;

    if (!pISession) {
        ErrorTrace((LPARAM) this, "NULL ISession - bailing");
        hr = E_POINTER;
        goto Exit;
    }

    //
    //  Get the property bag object
    //
    hr = pISession->QueryInterface(IID_IMailMsgPropertyBag, 
                                   (PVOID *) &pISessionProperties);

    if (FAILED(hr)) {
        ErrorTrace((LPARAM) this, 
            "QI for IID_IMailMsgPropertyBag failed 0x%08X", hr);
        pISessionProperties = NULL;
        goto Exit;
    }

    //
    //  Copy the next hop name into the session property bag
    //
    hr = pISessionProperties->PutStringA(ISESSION_PID_OUT_ROUTE_ADDRESS,
                               m_szDomainName);

    if (FAILED(hr)) {
        ErrorTrace((LPARAM) this,
            "Unable to write ISESSION_PID_OUT_ROUTE_ADDRESS hr - 0x%08X", hr);
    }

    if (m_plmq)
      szConnectorName = m_plmq->szGetConnectorName();

    if (szConnectorName) {
        hr = pISessionProperties->PutStringA(ISESSION_PID_OUT_CONNECTOR_NAME,
                                   szConnectorName);

        if (FAILED(hr)) {
            ErrorTrace((LPARAM) this,
                "Unable to write ISESSION_PID_OUT_CONNECTOR_NAME 0x%08X", hr);
        }

    }
    else {
        DebugTrace((LPARAM) this, 
            "szConnectorName is NULL... not writing to ISession");
    }

  Exit:
    if (pISessionProperties)
        pISessionProperties->Release();

    TraceFunctLeave();
    return S_OK;
}

//---[ CSMTPConn::CopySessionPropertiesToQueue ]-------------------------------
//
//
//  Description:
//      Copies the set of propties that the protocol owns into the queue
//      object.  In some cases, these properties are required for diagnostic 
//      reasons (ie - an admin wants to know which IP address we connected to).
//  Parameters:
//      IN      IUnknown           SMTP Session object to copy properties to
//          NOTE: We need to resist the urge to AddRef and keep this around
//          later use.  AddRefs on this object are actually ignored as the
//          lifetime is controlled by either the SMTP connection object
//          or the stack.
//                                 
//  Returns:
//      S_OK always
//  History:
//      11/27/2001 - MikeSwa Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CSMTPConn::CopySessionPropertiesToQueue(IN  IUnknown *pISession)
{
    TraceFunctEnterEx((LPARAM) this, "SMTPConn::CopySessionPropertiesToQueue");
    HRESULT hr = S_OK;
    IMailMsgPropertyBag *pISessionProperties = NULL;

    if (!pISession) {
        ErrorTrace((LPARAM) this, "NULL ISession - bailing");
        hr = E_POINTER;
        goto Exit;
    }

    //
    //  Get the property bag object
    //
    hr = pISession->QueryInterface(IID_IMailMsgPropertyBag, 
                                   (PVOID *) &pISessionProperties);

    if (FAILED(hr)) {
        ErrorTrace((LPARAM) this, 
            "QI for IID_IMailMsgPropertyBag failed 0x%08X", hr);
        pISessionProperties = NULL;
        goto Exit;
    }

    hr = pISessionProperties->GetStringA(ISESSION_PID_REMOTE_IP_ADDRESS, 
                                        sizeof(m_szConnectedIPAddress)-1,
                                        (CHAR *) &m_szConnectedIPAddress);

    if (FAILED(hr)) {
        DebugTrace((LPARAM) this,
            "Unable to read ISESSION_PID_REMOTE_IP_ADDRESS - 0x%08X", hr);
        m_szConnectedIPAddress[0] = '\0';
    }
    
  Exit:
    if (pISessionProperties)
        pISessionProperties->Release();

    TraceFunctLeave();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\smtpconn.h ===
//-----------------------------------------------------------------------------
//
//
//  File: SMTPConn.h 
//
//  Description: Declaration of the CSMTPConn class which implements the
//      ISMTPConnection interface
//
//  Author: mikeswa
//
//  Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __SMTPCONN_H_
#define __SMTPCONN_H_

#include <cpoolmac.h>
#include <baseobj.h>
#include <aqueue.h>
#include "linkmsgq.h"
#include "dcontext.h"

class CConnMgr;
class CAQSvrInst;
class CInternalDomainInfo;

#define SMTP_CONNECTION_SIG 'nocS'

//---[ CSMTPConn ]-------------------------------------------------------------
//
//
//  Hungarian: SMTPConn, pSMTPConn
//
//  
//-----------------------------------------------------------------------------
class CSMTPConn :
   public ISMTPConnection,
   public IConnectionPropertyManagement,
   public CBaseObject
{
protected:
    DWORD            m_dwSignature;
    CLinkMsgQueue   *m_plmq;
    CConnMgr        *m_pConnMgr;
    CInternalDomainInfo *m_pIntDomainInfo;
    DWORD            m_cFailedMsgs;
    DWORD            m_cTriedMsgs;
    DWORD            m_cMaxMessagesPerConnection;
    DWORD            m_dwConnectionStatus;
    LPSTR            m_szDomainName;
    DWORD            m_cbDomainName;
    CDeliveryContext m_dcntxtCurrentDeliveryContext;
    LIST_ENTRY       m_liConnections;
    DWORD            m_cAcks;
    DWORD            m_dwTickCountOfLastAck;

    //IP addrss protocol used to connect
    // enough from for IPv4 or IPv6 xxx.xxx.xxx.xxx or XX:XX:XX:XX:XX:XX:XX:XX
    CHAR             m_szConnectedIPAddress[40]; 
                
public:
    static CPool     s_SMTPConnPool;
    void *operator new(size_t size);
    void operator delete(void *p, size_t size);

    CSMTPConn(CConnMgr *pConnMgr, CLinkMsgQueue *plmq, DWORD cMaxMessagesPerConnection);
    ~CSMTPConn();
    
    DWORD   cGetFailedMsgCount() {return m_cFailedMsgs;};
    DWORD   cGetTriedMsgCount() {return m_cTriedMsgs;};
    DWORD   dwGetConnectionStatus() {return m_dwConnectionStatus;};
    inline CLinkMsgQueue *plmqGetLink();

    inline void     InsertConnectionInList(PLIST_ENTRY pliHead);
    inline void     RemoveConnectionFromList();
    LPSTR   szGetConnectedIPAddress() {return m_szConnectedIPAddress;};
// IUnknown
public:
    //CBaseObject handles addref and release
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)(void) {return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};
// ISMTPConnection
public:
    STDMETHOD(GetDomainInfo)(/*[in, out]*/ DomainInfo *pDomainInfo);
    STDMETHOD(AckConnection)(/*[in]*/ DWORD dwConnectionStatus) 
        {m_dwConnectionStatus = dwConnectionStatus;return S_OK;};
    STDMETHOD(AckMessage)(/*[in]*/ MessageAck *pMsgAck);
    STDMETHOD(GetNextMessage)(
        /*[out]*/ IMailMsgProperties **ppIMailMsgProperties, 
        /*[out]*/ DWORD **ppvMsgContext, 
        /*[out]*/ DWORD *pcIndexes, 
        /*[out, size_is(*pcIndexes)]*/ DWORD *prgdwRecipIndex[]);

    STDMETHOD(SetDiagnosticInfo)(
        IN  HRESULT hrDiagnosticError,
        IN  LPCSTR szDiagnosticVerb,
        IN  LPCSTR szDiagnosticResponse);

public: //IConnectionPropertyManagement
    STDMETHOD(CopyQueuePropertiesToSession)(
        IN  IUnknown *pISession);

    STDMETHOD(CopySessionPropertiesToQueue)(
        IN  IUnknown *pISession);
};

//---[ CSMTPConn::plmqGetLink ]-------------------------------------------------
//
//
//  Description: 
//      Returns an AddRef'd link pointer for this connection. Caller must call
//      Release.
//  Parameters:
//      -
//  Returns:
//      link pointer for this connection (if there is one)
//      NULL if no link pointer
//  History:
//      6/11/98 - MikeSwa Added check for NULL link 
//
//-----------------------------------------------------------------------------
CLinkMsgQueue *CSMTPConn::plmqGetLink() 
{
    if (m_plmq)
    {
        m_plmq->AddRef();
        return m_plmq;
    }
    else
    {
        return NULL;
    }
};

//---[ CSMTPConn::InsertConnectionInList ]---------------------------------------
//
//
//  Description: 
//      Inserts link in given linked list
//  Parameters:
//      pliHead     - Head of list to insert in
//  Returns:
//      -
//  History:
//      6/16/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CSMTPConn::InsertConnectionInList(PLIST_ENTRY pliHead)
{
    _ASSERT(pliHead);
    _ASSERT(NULL == m_liConnections.Flink);
    _ASSERT(NULL == m_liConnections.Blink);
    InsertHeadList(pliHead, &m_liConnections);
};

//---[ CSMTPConn::RemoveConnectionFromList ]-------------------------------------
//
//
//  Description: 
//      Remove link from link list
//  Parameters:
//      - 
//  Returns:
//      -
//  History:
//      6/16/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CSMTPConn::RemoveConnectionFromList()
{
    RemoveEntryList(&m_liConnections);
    m_liConnections.Flink = NULL;
    m_liConnections.Blink = NULL;
};


inline void *CSMTPConn::operator new(size_t size) 
{
    return s_SMTPConnPool.Alloc();
}

inline void CSMTPConn::operator delete(void *p, size_t size) 
{
    s_SMTPConnPool.Free(p);
}

#endif //__SMTPCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\smproute.cpp ===
//-----------------------------------------------------------------------------
//
//
//	File: smproute.cpp
//
//	Description:
//		Implementation of CSimpleMessageRouter.
//
//	Author: Mike Swafford (MikeSwa)
//
//	History:
//		5/20/98 - MikeSwa Created
//
//	Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "aqprecmp.h"
#include "smproute.h"
#include "domcfg.h"

#ifdef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
#undef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
#endif //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
//If you are interested is using the default router to test how AQ handles
//multiple message types and schedule ID's, the uncomment the following
//#define AQ_DEFAULT_MESSAGE_ROUTER_DEBUG

//---[ CAQDefaultMessageRouter::CAQDefaultMessageRouter ]----------------------
//
//
//  Description:
//      Constructor for CSimpleMessageRouter
//  Parameters:
//      pguid   - pointer to GUID to use to identify self
//  Returns:
//      -
//  History:
//      5/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQDefaultMessageRouter::CAQDefaultMessageRouter(GUID *pguid, CAQSvrInst *paqinst)
{
    _ASSERT(paqinst);
    m_dwSignature = AQ_DEFAULT_ROUTER_SIG;
    m_cPeakReferences = 1;

    ZeroMemory(&m_rgcMsgTypeReferences, NUM_MESSAGE_TYPES*sizeof(DWORD));

    if (pguid)
        memcpy(&m_guid, pguid, sizeof(GUID));
    else
        ZeroMemory(&m_guid, sizeof(GUID));

    m_dwCurrentReference = 0;

    m_paqinst = paqinst;
    m_paqinst->AddRef();

}

//---[ CAQDefaultMessageRouter::~CAQDefaultMessageRouter ]---------------------
//
//
//  Description:
//      Destructor for CAQDefaultMessageRouter.  Will assert that all message
//      types have been release correctly
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/21/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CAQDefaultMessageRouter::~CAQDefaultMessageRouter()
{
    m_paqinst->Release();
    for (int i = 0; i < NUM_MESSAGE_TYPES; i++)
        _ASSERT((0 == m_rgcMsgTypeReferences[i]) && "Message Types were not released");
}

//---[ CAQDefaultMessageRouter::GetTransportSinkID ]---------------------------
//
//
//  Description:
//      Returns GUID id for this messager router interface
//  Parameters:
//      -
//  Returns:
//      GUID for this IMessageRouter
//  History:
//      5/20/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
GUID CAQDefaultMessageRouter::GetTransportSinkID()
{
    return m_guid;
}

//---[ CAQDefaultMessageRouter::GetMessageType ]-------------------------------
//
//
//  Description:
//      Wrapper for routing get-message-type event.
//  Parameters:
//      IN  pIMailMsg   IMailMsgProperties of message to classify
//      OUT pdwMsgType  DWORD message type of message
//  Returns:
//      S_OK on success
//      failure code from routing event
//  History:
//      5/19/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQDefaultMessageRouter::GetMessageType(
            IN  IMailMsgProperties *pIMailMsg,
            OUT DWORD *pdwMessageType)
{
    HRESULT hr = S_OK;
    DWORD   dwMessageType = InterlockedIncrement((PLONG) &m_dwCurrentReference);
    _ASSERT(pdwMessageType);

#ifdef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
    //For debug versions we will autostress ourselves by generating msg types

    //simulate failures
    if (0 == (dwMessageType % NUM_MESSAGE_TYPES))
        return E_FAIL;

    dwMessageType %= NUM_MESSAGE_TYPES;
#else
    dwMessageType = 0;
#endif //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG

    InterlockedIncrement((PLONG) &m_rgcMsgTypeReferences[dwMessageType]);
    *pdwMessageType = dwMessageType;
    return hr;
}



//---[ CAQDefaultMessageRouter::ReleaseMessageType ]---------------------------
//
//
//  Description:
//      Wrapper for ReiReleaseMessageType... releases references to message
//      type returned by HrGetMessageType.
//  Parameters:
//      IN dwMessageType    Msg type (as return by HrGetNextMessage) to release
//      IN dwReleaseCount   Number of references to release
//  Returns:
//      S_OK on success
//  History:
//      5/19/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQDefaultMessageRouter::ReleaseMessageType(
            IN DWORD dwMessageType,
            IN DWORD dwReleaseCount)
{
    HRESULT hr = S_OK;

    _ASSERT(dwMessageType < NUM_MESSAGE_TYPES);
    _ASSERT(m_rgcMsgTypeReferences[dwMessageType]);
    _ASSERT(m_rgcMsgTypeReferences[dwMessageType] >= dwReleaseCount);
    _ASSERT(0 == (dwReleaseCount & 0x80000000)); //non-negative

    InterlockedExchangeAdd((PLONG) &m_rgcMsgTypeReferences[dwMessageType], -1 * (LONG) dwReleaseCount);
    return hr;
}

//---[ CAQDefaultMessageRouter::GetNextHop ]------------------------------------
//
//
//  Description:
//      Wrapper for routing ReiGetNextHop.  Returns the <domain, schedule id>
//      pair for the next hop link
//  Parameters:
//
//  Returns:
//      S_OK on success
//  History:
//      5/19/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CAQDefaultMessageRouter::GetNextHop(
            IN LPSTR szDestinationAddressType,
            IN LPSTR szDestinationAddress,
            IN DWORD dwMessageType,
            OUT LPSTR *pszRouteAddressType,
            OUT LPSTR *pszRouteAddress,
            OUT LPDWORD pdwScheduleID,
            OUT LPSTR *pszRouteAddressClass,
            OUT LPSTR *pszConnectorName,
            OUT LPDWORD pdwNextHopType)
{
    HRESULT hr = S_OK;
    CInternalDomainInfo *pIntDomainInfo = NULL;

    _ASSERT(dwMessageType < NUM_MESSAGE_TYPES);
    _ASSERT(!lstrcmpi(MTI_ROUTING_ADDRESS_TYPE_SMTP, szDestinationAddressType));
    _ASSERT(szDestinationAddress);
    _ASSERT(pdwNextHopType);
    _ASSERT(pszConnectorName);
    _ASSERT(pszRouteAddressType);
    _ASSERT(pszRouteAddress);
    _ASSERT(pszRouteAddressClass);

    //For now, we will use essentially non-routed behavior... every thing will
    //go it's own link, and will use the same schedule ID.  No address class
    //will be returned.
    *pdwNextHopType = MTI_NEXT_HOP_TYPE_EXTERNAL_SMTP;

#ifdef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
    //Use m_dwCurrentReference to randomize schedule Id
    *pdwScheduleID = m_dwCurrentReference & 0x00000002;
#else //retail build
    *pdwScheduleID = 0;
#endif //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG

    pszConnectorName = NULL;

    *pszRouteAddressType = MTI_ROUTING_ADDRESS_TYPE_SMTP;
    *pszRouteAddressClass = NULL;

#ifdef AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
    //Get smarthost for this domain if stressing routing
    hr = m_paqinst->HrGetInternalDomainInfo( strlen(szDestinationAddress),
               szDestinationAddress, &pIntDomainInfo);
    if (FAILED(hr))
        goto Exit;

    if (pIntDomainInfo->m_DomainInfo.szSmartHostDomainName)
    {
        //smart host exists... use it
        *pszRouteAddress = (LPSTR) pvMalloc(sizeof(CHAR) *
            (pIntDomainInfo->m_DomainInfo.cbSmartHostDomainNameLength+1));
        if (!*pszRouteAddress)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        lstrcpy(*pszRouteAddress, pIntDomainInfo->m_DomainInfo.szSmartHostDomainName);
    }
    else
    {
        *pszRouteAddress = szDestinationAddress;
    }
  Exit:
#else //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG
    *pszRouteAddress = szDestinationAddress;
#endif //AQ_DEFAULT_MESSAGE_ROUTER_DEBUG

    if (pIntDomainInfo)
        pIntDomainInfo->Release();

    return hr;
}

//---[ CAQDefaultMessageRouter::GetNextHopFree ]------------------------------------
//
//
//  Description:
//      Wrapper for routing ReiGetNextHopFree.
//      Free's the strings allocated in GetNextHop
//      NOTE: szDestinationAddressType/szDestinationAddress will never
//      be free'd.  They are arguments as an optimization trick (to
//      avoid alloc/freeing when szDestinationAddress=szRouteAddress)
//
//  Parameters:
//      szDestinationAddressType: DestinationAddressType passed into GetNextHopF
//      szDestinationAddress: DestinationAddress passed into GetNextHop
//
//  Returns:
//      S_OK on success
//  History:
//      jstamerj 1998/07/10 19:52:56: Created
//
//-----------------------------------------------------------------------------
STDMETHODIMP CAQDefaultMessageRouter::GetNextHopFree(
    IN LPSTR szDestinationAddressType,
    IN LPSTR szDestinationAddress,
    IN LPSTR szConnectorName,
    IN LPSTR szRouteAddressType,
    IN LPSTR szRouteAddress,
    IN LPSTR szRouteAddressClass)
{
    //
    // The only string necessary to free is szRouteAddress
    //
    if(szRouteAddress && (szRouteAddress != szDestinationAddress))
        FreePv(szRouteAddress);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\smproute.h ===
//-----------------------------------------------------------------------------
//
//
//  File: smproute.h
//
//  Description:
//      Simple routing header file.  Defines a simple/default IMessageRouter
//      as well as constants that are defined in rei.h (which currently 
//      uses the old IMsg).
//
//  Author: Mike Swafford - mikeswa
//
//  History:
//      5/19/98 - mikeswa Created 
//      1/23/99 - MikeSwa Moved important constants to smtpevent.idl
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __SMPROUTE_H__
#define __SMPROUTE_H__

#include <aqincs.h>
#include <smtpevent.h>

class CAQSvrInst;

#define AQ_DEFAULT_ROUTER_SIG 'RDQA'
#define NUM_MESSAGE_TYPES   4
class CAQDefaultMessageRouter : 
    public IMessageRouter,
    public CBaseObject
{
public:
    CAQDefaultMessageRouter(GUID *pguid, CAQSvrInst *paqinst);
    ~CAQDefaultMessageRouter();
public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) {return E_NOTIMPL;};
    STDMETHOD_(ULONG, AddRef)(void) {InterlockedIncrement((PLONG) &m_cPeakReferences);return CBaseObject::AddRef();};
    STDMETHOD_(ULONG, Release)(void) {return CBaseObject::Release();};
public: //IMessageRouter
    STDMETHOD_(GUID,GetTransportSinkID) ();
    STDMETHOD (GetMessageType) (
        IN  IMailMsgProperties *pIMailMsg,
        OUT DWORD *pdwMessageType);

    STDMETHOD (ReleaseMessageType) (
        IN DWORD dwMessageType,
        IN DWORD dwReleaseCount);

    STDMETHOD (GetNextHop) (
        IN LPSTR szDestinationAddressType, 
        IN LPSTR szDestinationAddress, 
        IN DWORD dwMessageType, 
        OUT LPSTR *pszRouteAddressType, 
        OUT LPSTR *pszRouteAddress, 
        OUT LPDWORD pdwScheduleID, 
        OUT LPSTR *pszRouteAddressClass, 
        OUT LPSTR *pszConnectorName, 
        OUT LPDWORD pdwNextHopType);

    STDMETHOD (GetNextHopFree) (
        IN LPSTR szDestinationAddressType,
        IN LPSTR szDestinationAddress,
        IN LPSTR szConnectorName,
        IN LPSTR szRouteAddressType,
        IN LPSTR szRouteAddress,
        IN LPSTR szRouteAddressClass);

    STDMETHOD (ConnectionFailed) (
            IN LPSTR pszConnectorName)
    {
        return S_OK;
    }

protected:
    DWORD   m_dwSignature;
    DWORD   m_rgcMsgTypeReferences[NUM_MESSAGE_TYPES];
    DWORD   m_dwCurrentReference;
    GUID    m_guid; //My TransportSinkID
    DWORD   m_cPeakReferences;
    CAQSvrInst *m_paqinst;
};

#endif //__SMPROUTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\statemachinebase.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: statemachinebase.cpp
//
//  Description:
//      Implementation of CStateMachineBaseClass
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/11/2000 - MikeSwa Created 
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "aqprecmp.h"
#include "statemachinebase.h"

//---[ CStateMachineBase::CStateMachineBase ]-----------------------
//
//
//  Description: 
//      CStateMachineBase constructor
//  Parameters:
//      - dwInitialState            Initial state to set state 
//                                  machine to
//        dwStateMachineSignature   Signature of the state machine 
//                                  subclass
//  Returns:
//      - 
//  History:
//      6/5/2000 - t-toddc Created 
//
//------------------------------------------------------------------
CStateMachineBase::CStateMachineBase(DWORD dwInitialState, 
                                     DWORD dwStateMachineSignature) : 
                m_dwSignature(STATE_MACHINE_BASE_SIG),
                m_dwStateMachineSignature(dwStateMachineSignature),
                m_dwCurrentState(dwInitialState)
{
};

//---[ CStateMachineBase::dwGetCurrentState ]----------------------
//
//
//  Description: 
//      returns the current state of the state machine
//  Parameters:
//      -
//  Returns:
//      - current state
//  History:
//      6/5/2000 - t-toddc Created 
//
//------------------------------------------------------------------
DWORD CStateMachineBase::dwGetCurrentState()
{
    return m_dwCurrentState;
}

//---[ CStateMachineBase::dwGetNextState ]-------------------------
//
//
//  Description: 
//      sets the next state based on current state and input action.
//      Uses InterlockedCompareExchange to make sure that the state 
//      transition is thread-safe.
//  Parameters:
//      - dwAction      the current action causing the state transition
//  Returns:
//      - the resultant state based on the current state and 
//        input action
//  History:
//      6/5/2000 - t-toddc Created 
//
//------------------------------------------------------------------
DWORD CStateMachineBase::dwGetNextState(DWORD dwAction)
{
    TraceFunctEnter("CStateMachineBase::dwGetNextState");

    DWORD dwCurrentState;
    DWORD dwNextState;

    do
    {
        dwCurrentState = m_dwCurrentState;
        dwNextState =  dwCalcStateFromStateAndAction(dwCurrentState, dwAction);
        if (dwCurrentState == dwNextState)
            break; // no work to be done
    } while (InterlockedCompareExchange((LPLONG) &m_dwCurrentState,
                                        (LONG) dwNextState,
                                        (LONG) dwCurrentState)!= (LONG) dwCurrentState);
    DebugTrace((LPARAM) this, 
               "CStateMachineBase state transition: %X->%X", 
               dwCurrentState, 
               dwNextState);
    TraceFunctLeave();
    return dwNextState;
}

//---[ CStateMachineBase::dwCalcStateFromStateAndAction ]------------
//
//
//  Description: 
//      iterates through the state transition table to find the 
//      next state associated with the current state and input action
//  Parameters:
//      - dwStartState      start state for this transition
//        dwAction          the action associated with this transition
//  Returns:
//      - the resultant state associated with current state and action
//  History:
//      6/5/2000 - t-toddc Created 
//
//
//------------------------------------------------------------------
DWORD CStateMachineBase::dwCalcStateFromStateAndAction(DWORD dwStartState, DWORD dwAction)
{
    TraceFunctEnter("CStateMachineBase::dwCalcStateFromStateAndAction");
    // if the action is unknown to state table, return start state
    DWORD dwNextState = dwStartState;
    DWORD i;
    const STATE_TRANSITION* pTransitionTable;
    DWORD dwNumTransitions;
    BOOL fFoundTransition = FALSE;
    // obtain the transition table
    getTransitionTable(&pTransitionTable, &dwNumTransitions);

    // find the new state
    for(i=0; i < dwNumTransitions; i++)
    {
        if (pTransitionTable[i].dwCurrentState == dwStartState &&
            pTransitionTable[i].dwAction == dwAction)
        {
            dwNextState = pTransitionTable[i].dwNextState;
            fFoundTransition = TRUE;
            break;
        }
    }

    ASSERT(fFoundTransition && "action unknown to state table");
    if (!fFoundTransition)
        DebugTrace((LPARAM) this,"action %X unknown to state tabe", dwAction);

    TraceFunctLeave();
    return dwNextState;
}

//---[ CStateMachineBase::fValidateStateTable ]---------------------
//
//
//  Description: 
//      loops through all transitions and checks that
//      a) all possible states are start states
//      b) for every state, every possible action yields another state
//  Parameters:
//      -
//  Returns:
//      - true/false if state table is valid/invalid
//  History:
//      6/5/2000 - t-toddc Created 
//
//------------------------------------------------------------------
BOOL CStateMachineBase::fValidateStateTable()
{
    TraceFunctEnter("CStateMachineBase::fValidateStateTable");

    DWORD i, j, k; // iterators
    DWORD dwEndState;
    DWORD dwAction;
    DWORD dwCurrentState;
    BOOL fFoundEndStateAsStartState = false;
    BOOL fActionSupportedByEveryState = false;
    const STATE_TRANSITION* pTransitionTable;
    DWORD dwNumTransitions;
    BOOL fRetVal = false;

    // obtain the transition table
    getTransitionTable(&pTransitionTable, &dwNumTransitions);

    for(i = 0; i < dwNumTransitions; i++)
    {   
        // initialize booleans within loop
        fFoundEndStateAsStartState = false;
        // grab the current action
        dwAction = pTransitionTable[i].dwAction;
        // grab the current end state
        dwEndState = pTransitionTable[i].dwNextState;

        // loop over all transitions
        for (j = 0; j < dwNumTransitions; j++)
        {
            // check that the current end state is a start state
            if (pTransitionTable[j].dwCurrentState == dwEndState)
            {
                fFoundEndStateAsStartState = true;
            }

            // check that every action is supported by every state
            fActionSupportedByEveryState = false;
            dwCurrentState = pTransitionTable[j].dwCurrentState;
            // the current action might not be in this particular transition,
            // but it must be in a transition with this dwCurrentState as the start state            
            if (pTransitionTable[j].dwAction != dwAction)
            {
                // loop over all transitions again to guarantee the above.
                for(k = 0; k < dwNumTransitions; k++)
                {
                    // there must exist a state transition with the current state
                    // from above and the given action
                    if (pTransitionTable[k].dwAction == dwAction &&
                        pTransitionTable[k].dwCurrentState == dwCurrentState)
                    {
                        fActionSupportedByEveryState = true;
                        break;
                    }
                }
            }
            else
            {
                fActionSupportedByEveryState = true;
            }

            // bail on false if the current action is not supported by every state
            ASSERT(fActionSupportedByEveryState &&
                   "Invalid state table: action not supported by every state");
            if (!fActionSupportedByEveryState)
            {
                fRetVal = false;
                DebugTrace((LPARAM) this,
                           "Invalid state table: action not supported by every state");
                goto Cleanup;
            }
            // break out of inner loop if the current end state has been found
            // as a start state
            if (fFoundEndStateAsStartState)
                break;
        }

        // bail on false if an end state is not also a start state
        ASSERT(fFoundEndStateAsStartState &&
               "Invalid state table: an end state is not also a start state");
        if (!fFoundEndStateAsStartState)
        {
            fRetVal = false;
            DebugTrace((LPARAM) this, 
                       "Invalid state table: an end state is not also a start state");
            goto Cleanup;
        }
    }

    // if it makes it this far, it is undoubtedly valid.
    fRetVal = true;

Cleanup:    
    TraceFunctLeave();    
    return fRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\advqueue\statemachinebase.h ===
//-----------------------------------------------------------------------------
//
//
//  File: statemachinebase.h
//
//  Description:  Header file for a state machine base class
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      12/11/2000 - MikeSwa Created from t-toddc's work
//
//  Copyright (C) 2000 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __STATE_MACHINE_BASE__
#define __STATE_MACHINE_BASE__

#define STATE_MACHINE_BASE_SIG ' MTS'

// A 3-tuple transition consisting of
// current state, action, and next state.
typedef struct _STATE_TRANSITION
{
    DWORD dwCurrentState;
    DWORD dwAction;
    DWORD dwNextState;
} STATE_TRANSITION;

//---[ CStateMachineBase ]-------------------------------------------------
//
//
//  Description: 
//      Base class for all state machines.  It is responsible for maintaining 
//      the current state, ensuring that the state table it is handling is in 
//      fact valid, and performing thread-safe state transitions.  
//      The pure virtual function exists because the base machine is not 
//      responsible for maintaining the state transition table, only 
//      performing operations of the state.  This is not designed to be
//      used by itself.
//
//  Author: Todd Coleman (t-toddc)
//
//  History:
//      6/5/00 - t-toddc Created 
//
//  Copyright (C) 2000 Microsoft Corporation
//  
//-----------------------------------------------------------------------------
class CStateMachineBase
{
private:
    DWORD m_dwSignature;
    DWORD m_dwStateMachineSignature;
    DWORD m_dwCurrentState;
protected:
    CStateMachineBase(DWORD dwInitialState, DWORD dwStateMachineSignature);
    DWORD dwGetCurrentState();
    DWORD dwGetNextState(DWORD dwAction);
    BOOL fValidateStateTable();
    DWORD dwCalcStateFromStateAndAction(DWORD dwStartState, DWORD dwAction);
    virtual void getTransitionTable(const STATE_TRANSITION** ppTransitionTable,
                                    DWORD* pdwNumTransitions) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqadm.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadm.cpp
//
//  Description: Implementation of CAQAdmin which implements IAQAdmin
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"
#include "aqadmin.h"
#include "aqadm.h"

CAQAdmin::CAQAdmin() {
}

CAQAdmin::~CAQAdmin() {
}

HRESULT CAQAdmin::GetVirtualServerAdminITF(LPCWSTR wszComputer,
                                           LPCWSTR wszVirtualServer,
										   IVSAQAdmin **ppIVSAQAdmin)
{
    TraceFunctEnter("CAQAdmin::GetVirtualServerAdminITF");
    
    if (ppIVSAQAdmin == NULL || wszVirtualServer == NULL) 
        return E_POINTER;

    if (((wszComputer != NULL) && (*wszComputer == NULL)) || *wszVirtualServer == NULL) 
        return E_INVALIDARG;

    CVSAQAdmin *pVSAdmin = new CVSAQAdmin;
	HRESULT hr = S_OK;

	if (pVSAdmin == NULL) return E_OUTOFMEMORY;
	hr = pVSAdmin->Initialize(wszComputer, wszVirtualServer);
	if (FAILED(hr)) {
		delete pVSAdmin;
		pVSAdmin = NULL;
	} 

	*ppIVSAQAdmin = pVSAdmin;

    TraceFunctLeave();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqadm.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadm.h
//
//  Description:  Header for CAQAdmin which implements IAQAdmin.  This is 
//      the primary (initial) interface for Queue Admin, which is used to get 
//      a pointer to a virtual server instance interface (IVSAQAdmin)
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __AQADM_H__
#define __AQADM_H__

class CAQAdmin :
	public IAQAdmin,
	public CComObjectRoot,
	public CComCoClass<CAQAdmin, &CLSID_AQAdmin>
{
	public:
		CAQAdmin();
		virtual ~CAQAdmin();

		BEGIN_COM_MAP(CAQAdmin)
			COM_INTERFACE_ENTRY(IAQAdmin)
		END_COM_MAP()

		DECLARE_REGISTRY_RESOURCEID_EX(IDR_StdAfx, 
									   L"Advanced Queue Administration API",
									   L"AQAdmin.Admin.1", 
									   L"AQAdmin.Admin"
									   );

		// IAQAdmin
        COMMETHOD GetVirtualServerAdminITF(LPCWSTR wszComputer,
                                           LPCWSTR wszVirtualServerDN,
										   IVSAQAdmin **ppivsaqadmin);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqmsg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqmsg.cpp
//
//  Description:  Implementation of CAQMessage class which implements
//          Queue Admin client interface IAQMessage
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CAQMessage::CAQMessage(CEnumMessages *pEnumMsgs, DWORD iMessage) {
    TraceFunctEnter("CAQMessage::CAQMessage");
    
    _ASSERT(pEnumMsgs);
    pEnumMsgs->AddRef();
    m_pEnumMsgs = pEnumMsgs;
    m_iMessage = iMessage;

    TraceFunctLeave();
}

CAQMessage::~CAQMessage() {
    TraceFunctEnter("CAQMessage::~CAQMessage");
    
    m_pEnumMsgs->Release();

    TraceFunctLeave();
}

HRESULT CAQMessage::GetInfo(MESSAGE_INFO *pMessageInfo) {
    TraceFunctEnter("CAQMessage::GetInfo");
    
    if (!pMessageInfo) 
    {
        TraceFunctLeave();
        return E_POINTER;
    }

    memcpy(pMessageInfo, 
           &(m_pEnumMsgs->m_rgMessages[m_iMessage]), 
           sizeof(MESSAGE_INFO));

    TraceFunctLeave();
    return S_OK;
}

//---[ CAQMessage::GetContentStream ]------------------------------------------
//
//
//  Description: 
//      Returns a stream for the content of the message
//  Parameters:
//      OUT     ppIStream       Stream for content
//      OUT     pwszContentType String containing content type (if known)
//  Returns:
//      E_NOTIMPL
//  History:
//      6/4/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CAQMessage::GetContentStream(
                OUT IStream **ppIStream,
                OUT LPWSTR  *pwszContentType)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqmsg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqmsg.h
//
//  Description:  Implementation of Queue Admin client interfae IAQMessage
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __AQMSG_H__
#define __AQMSG_H__

class CEnumMessages;

class CAQMessage :
	public CComRefCount,
	public IAQMessage
{
	public:
		CAQMessage(CEnumMessages *pEnumMsgs, DWORD iMessage);
		virtual ~CAQMessage();

		HRESULT Initialize(LPCSTR szVirtualServerDN);

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IUnknown *>(this);
			} else if (iid == IID_IAQMessage) {
				*ppv = static_cast<IAQMessage *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IAQMessage
		COMMETHOD GetInfo(MESSAGE_INFO *pMessageInfo);
        COMMETHOD GetContentStream(
                OUT IStream **ppIStream,
                OUT LPWSTR  *pwszContentType);

    private:
        CEnumMessages *m_pEnumMsgs;
        DWORD m_iMessage;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\dllmain.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dllmain.cpp
//
//  Description: DLL main for aqadmin.dll
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"
#include "resource.h"

#include "initguid.h"
#include "aqadmin.h"

HANDLE g_hTransHeap = NULL;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_AQAdmin, CAQAdmin)
END_OBJECT_MAP()

BOOL  g_fHeapInit = FALSE;
BOOL  g_fModuleInit = FALSE;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/) {

	if (dwReason == DLL_PROCESS_ATTACH) {
        if (!TrHeapCreate())
            return FALSE;
        g_fHeapInit = TRUE;

		_Module.Init(ObjectMap,hInstance);
        g_fModuleInit = TRUE;
        
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH) {

        if (g_fModuleInit)
		  _Module.Term();
        
        if (g_fHeapInit)
          TrHeapDestroy();

        g_fHeapInit = FALSE;
        g_fModuleInit = FALSE;
	}
	return (TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void) {
	HRESULT hRes = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
	HRESULT hRes = _Module.GetClassObject(rclsid,riid,ppv);
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void) {
	// registers object, typelib and all interfaces in typelib
	HRESULT hRes = _Module.RegisterServer();
	return (hRes);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void) {
	_Module.UnregisterServer();
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqrpcstb.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqrpcstb.h
//
//  Description: Header file for client-side RPC stub.  All functions are
//      client-side wrappers for the remote RPC implementation.  The naming
//      convention is that the client-side has the "Client" prefix, while the
//      remote RPC server functions do not.  The client side implementation is
//      wrapped in this manner to supply a single point to maintain exception
//      handling and any RPC overhead.
//
//      The RPC versions of these functions are defined in aqadmrpc.idl
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQRPCSTB_H__
#define __AQRPCSTB_H__

#include <inetcom.h>
#ifndef NET_API_FUNCTION
#define NET_API_FUNCTION _stdcall
#endif

NET_API_STATUS
NET_API_FUNCTION
ClientAQApplyActionToLinks(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
    LINK_ACTION		laAction);

NET_API_STATUS
NET_API_FUNCTION
ClientAQApplyActionToMessages(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
	MESSAGE_FILTER	*pmfMessageFilter,
	MESSAGE_ACTION	maMessageAction,
    DWORD           *pcMsgs);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetQueueInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueId,
	QUEUE_INFO		*pqiQueueInfo);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetLinkInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_INFO		*pliLinkInfo,
    HRESULT         *hrLinkDiagnostic);

NET_API_STATUS
NET_API_FUNCTION
ClientAQSetLinkState(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_ACTION		la);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetLinkIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	DWORD			*pcLinks,
	QUEUELINK_ID	**rgLinks);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetQueueIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	DWORD			*pcQueues,
	QUEUELINK_ID	**rgQueues);

NET_API_STATUS
NET_API_FUNCTION
ClientAQGetMessageProperties(
    LPWSTR          	wszServer,
    LPWSTR          	wszInstance,
	QUEUELINK_ID		*pqlQueueLinkId,
	MESSAGE_ENUM_FILTER	*pmfMessageEnumFilter,
	DWORD				*pcMsgs,
	MESSAGE_INFO		**rgMsgs);

NET_API_STATUS
NET_API_FUNCTION
ClientAQQuerySupportedActions(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
    DWORD           *pdwSupportedActions,
    DWORD           *pdwSupportedFilterFlags);

#endif //__AQRPCSTB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enumlink.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: enumlink.cpp
//
//  Description: Implementation of CEnumVSAQLinks which implements IEnumVSAQLinks
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CEnumVSAQLinks::CEnumVSAQLinks(CVSAQAdmin *pVS,
                               DWORD cLinks,
                               QUEUELINK_ID *rgLinks) 
{
    _ASSERT(cLinks == 0 || rgLinks);
    _ASSERT(pVS);
    m_dwSignature = CEnumVSAQLinks_SIG;
    pVS->AddRef();
    m_rgLinks = rgLinks;
    m_pVS = pVS;
    m_iLink = 0;
    m_cLinks = cLinks;

    if (m_rgLinks)
        m_prefp = new CQueueLinkIdContext(m_rgLinks, cLinks);
    else
        m_prefp = NULL;
}

CEnumVSAQLinks::~CEnumVSAQLinks() {
    if (m_prefp)
    {
        m_rgLinks = NULL;
        m_prefp->Release();
        m_prefp = NULL;
    }

    if (m_pVS) 
    {
        m_pVS->Release();
        m_pVS = NULL;
    }
}

//---[ CEnumVSAQLinks::Next ]--------------------------------------------------
//
//
//  Description: 
//      Gets the next IVSAQLink for this enumerator
//  Parameters:
//      IN      cElements   Elements to return
//      IN OUT  rgElements  Array to recieve new elements
//      OUT     pcGetched   Number of elements returned
//  Returns:
//      S_OK on success
//      S_FALSE with no more elements
//      E_POINTER on NULL args
//  History:
//      1/30/99 - MikeSwa Fixed AV on bogus args
//
//-----------------------------------------------------------------------------
HRESULT CEnumVSAQLinks::Next(ULONG cElements,
			   				 IVSAQLink **rgElements,
				  			 ULONG *pcFetched)
{
    DWORD iLinkNew = m_iLink + cElements;
    DWORD i;
    HRESULT hr = S_OK;

    if (!rgElements || !pcFetched)
    {
        hr = E_POINTER;
        goto Exit;
    }

    // make sure we don't go past the end of the array
    if (iLinkNew > m_cLinks) iLinkNew = m_cLinks;

    // make a CVSAQLink object for each element and copy it into the user's
    // array
	(*pcFetched) = 0;
    for (i = m_iLink; (i < iLinkNew); i++) {
        rgElements[(*pcFetched)] = 
            (IVSAQLink *) new CVSAQLink(m_pVS, &(m_rgLinks[i]));

        // make sure that the allocation worked
        if (rgElements[(*pcFetched)] == NULL) {
            // remember how far we were able to go.
            iLinkNew = i;
            // if it didn't work and this was the first element then we
            // return out of memory.  if its not the first element then
            // return what we've built up so far.
            if (i == 0) hr = E_OUTOFMEMORY;
            // drop out of the loop
            break;
        } else {
			(*pcFetched)++;
		}
    }
	
    _ASSERT(*pcFetched <= cElements);
        
    m_iLink = iLinkNew;

    if (SUCCEEDED(hr) && *pcFetched < cElements) hr = S_FALSE;

  Exit:
    if (FAILED(hr))
    {
        if (pcFetched)
            *pcFetched = 0;
    }
	return hr;
}

//---[ CEnumVSAQLinks::Skip ]--------------------------------------------------
//
//
//  Description: 
//      Skips forward the specified number of elements in the enumerator
//  Parameters:
//      IN  cElements       The number of elements to skip forward
//  Returns:
//      S_OK    Success, next element will be returned by Next()
//      S_FALSE Overflow, enumerator must be reset to return more elements
//  History:
//      2/2/99 - MikeSwa fixed overflow handling
//
//-----------------------------------------------------------------------------
HRESULT CEnumVSAQLinks::Skip(ULONG cElements) 
{
    m_iLink += cElements;
    if ((m_iLink >= m_cLinks) || (m_iLink < cElements)) 
    {
        m_iLink = m_cLinks;
        return S_FALSE;
    } 
    else 
    {
        return S_OK;
    }
}

HRESULT CEnumVSAQLinks::Reset() {
    m_iLink = 0;
    return S_OK;
}

//---[ CEnumLinkQueues::Clone ]------------------------------------------------
//
//
//  Description: 
//      Clones this enumerator
//  Parameters:
//      OUT ppEnum      New enumerator
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocated associated memory
//      E_POINTER if ppEnum is NULL
//  History:
//      2/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CEnumVSAQLinks::Clone(IEnumVSAQLinks **ppEnum) {
    if (!m_prefp)
        return E_OUTOFMEMORY;

    if (!ppEnum)
        return E_POINTER;

    *ppEnum = (IEnumVSAQLinks *) new CEnumVSAQLinks(m_pVS, m_cLinks, NULL);

    if (!*ppEnum)
        return E_OUTOFMEMORY;

    ((CEnumVSAQLinks *)(*ppEnum))->m_rgLinks = m_rgLinks;
    ((CEnumVSAQLinks *)(*ppEnum))->m_prefp = m_prefp;
    ((CEnumVSAQLinks *)(*ppEnum))->m_iLink = m_iLink;
    m_prefp->AddRef();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\aqrpcstb.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqrpcstb.cpp
//
//  Description:  Implmentation of client side RPC stub wrappers.
//      Also contains implementation of required RPC bind/unbind functions
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "stdinc.h"
#include "aqadmrpc.h"


//---[ AQUEUE_HANDLE_bind ]----------------------------------------------------
//
//
//  Description:
//      Implements bind for implicit AQUEUE_HANDLE
//  Parameters:
//      wszServerName       Server to bind to
//  Returns:
//      Binding handle on success
//      NULL on failure
//  History:
//      6/5/99 - MikeSwa Created  (adpated from SMTP_HANDLE_bind)
//
//-----------------------------------------------------------------------------
handle_t AQUEUE_HANDLE_bind (AQUEUE_HANDLE wszServerName)
{
    TraceFunctEnterEx((LPARAM) NULL, "AQUEUE_HANDLE_bind");
    handle_t    hBinding = NULL;
    RPC_STATUS  status = RPC_S_OK;
    RPC_STATUS  statusFree = RPC_S_OK; //status for cleanup operations
    WCHAR       wszTCPProtSeq[] = L"ncacn_ip_tcp";
    WCHAR       wszLocalProtSeq[] = L"ncalrpc";
    WCHAR      *wszProtSeq = wszTCPProtSeq;
    WCHAR      *wszNetworkAddress = wszServerName;
    WCHAR      *wszStringBinding = NULL;
    BOOL        fLocal = FALSE;

    //If no server is specified...
    if (!wszServerName || !*wszServerName)
    {
        //Change binding arguments to be local
        fLocal = TRUE;
        wszProtSeq = wszLocalProtSeq;
        wszNetworkAddress = NULL;
        DebugTrace((LPARAM) NULL, "No server name specified... binding as local");
    }

    status = RpcStringBindingComposeW(NULL, // ObjUuid
                                      wszProtSeq,
                                      wszNetworkAddress,
                                      NULL, // Endpoint
                                      NULL, // Options
                                      &wszStringBinding);

    if (RPC_S_OK != status)
    {
        ErrorTrace((LPARAM) NULL,
            "RpcStringBindingComposeW failed with error 0x%08X", status);
        goto Exit;
    }

    DebugTrace((LPARAM) NULL, "Using RPC binding string - %S", wszStringBinding);

    status = RpcBindingFromStringBindingW(wszStringBinding, &hBinding);
    if (RPC_S_OK != status)
    {
        ErrorTrace((LPARAM) NULL,
            "RpcBindingFromStringBindingW failed with error 0x%08X", status);
        goto Exit;
    }

    //Set appropriate auth level
    if (!fLocal)
    {
        status = RpcBindingSetAuthInfoW(hBinding,
                                        AQUEUE_RPC_INTERFACE,
                                        RPC_C_AUTHN_LEVEL_CONNECT,
                                        RPC_C_AUTHN_WINNT,
                                        NULL,
                                        NULL);
        if (RPC_S_OK != status)
        {
            ErrorTrace((LPARAM) NULL,
                "RpcBindingSetAuthInfoW failed with error 0x%08X", status);
            goto Exit;
        }
    }

  Exit:

    //Free binding string
    if (wszStringBinding)
    {
        statusFree = RpcStringFreeW(&wszStringBinding);
        if (RPC_S_OK != statusFree)
        {
            ErrorTrace((LPARAM) NULL,
                "RpcStringFreeW failed with 0x%08X", statusFree);
        }
    }

    //Free handle on failure (if needed)
    if ((RPC_S_OK != status) && hBinding)
    {
        statusFree = RpcBindingFree(&hBinding);
        if (RPC_S_OK != statusFree)
        {
            ErrorTrace((LPARAM) hBinding,
                "RpcBindingFree failed with 0x%08X", statusFree);
        }

        hBinding = NULL;
    }

    DebugTrace((LPARAM) hBinding,
        "AQUEUE_HANDLE_bind returning with status 0x%08X", status);
    TraceFunctLeave();
    return hBinding;
}

//---[ AQUEUE_HANDLE_unbind ]--------------------------------------------------
//
//
//  Description:
//      Implements unbind for AQUEUE_HANDLE_unbind
//  Parameters:
//      wszServerName       Server bound to (not used)
//      hBinding            Binding to free
//  Returns:
//      -
//  History:
//      6/5/99 - MikeSwa Created (adpated from SMTP_HANDLE_unbind)
//
//-----------------------------------------------------------------------------
void AQUEUE_HANDLE_unbind (AQUEUE_HANDLE wszServerName, handle_t hBinding)
{
    TraceFunctEnterEx((LPARAM) hBinding, "AQUEUE_HANDLE_unbind");
	UNREFERENCED_PARAMETER(wszServerName);
    RPC_STATUS  status = RPC_S_OK;

    status = RpcBindingFree(&hBinding);
    if (RPC_S_OK != status)
    {
        ErrorTrace((LPARAM) hBinding,
            "RpcBindingFree failed with error 0x%08X", status);
    }
    TraceFunctLeave();
}


//---[ MIDL_user_allocate ]----------------------------------------------------
//
//
//  Description:
//      MIDL memory allocation
//  Parameters:
//      size : Memory size requested.
//  Returns:
//      Pointer to the allocated memory block.
//  History:
//      6/5/99 - MikeSwa Created (taken from smtpapi rcputil.c)
//
//-----------------------------------------------------------------------------
PVOID MIDL_user_allocate(IN size_t size)
{
    PVOID pvBlob = NULL;

    pvBlob = pvMalloc(size);
    //pvBlob = LocalAlloc( LPTR, size);

    return(pvBlob);

}

//---[ MIDL_user_free ]--------------------------------------------------------
//
//
//  Description:
//    MIDL memory free .
//  Parameters:
//    IN    pvBlob    Pointer to a memory block that is freed.
//  Returns:
//      -
//  History:
//      6/5/99 - MikeSwa Created (from smtpapi rcputil.c)
//
//-----------------------------------------------------------------------------
VOID MIDL_user_free(IN PVOID pvBlob)
{
    FreePv(pvBlob);
    //LocalFree(pvBlob);
}


//---[ TraceMessageFilter ]----------------------------------------------------
//
//
//  Description:
//      Function used to trace the message filter in a safe manner
//  Parameters:
//      IN  pvParam             User param to pass to tracing
//      IN  pmfMessageFilter    Message filter
//  Returns:
//      -
//  History:
//      6/14/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void TraceMessageFilter(LPARAM pvParam, MESSAGE_FILTER *pmfMessageFilter)
{
    TraceFunctEnterEx(pvParam, "TraceMessageFilter");
    if (pmfMessageFilter)
    {
        RpcTryExcept
        {
            DebugTrace(pvParam,
                "Message Filter ID is %S",
                pmfMessageFilter->szMessageId);
            DebugTrace(pvParam,
                "Message Filter Sender is %S",
                pmfMessageFilter->szMessageSender);
            DebugTrace(pvParam,
                "Message Filter Recipient is %S",
                pmfMessageFilter->szMessageRecipient);
            DebugTrace(pvParam,
                "Message Filter version is %ld",
                pmfMessageFilter->dwVersion);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            ErrorTrace(pvParam, "Exception while tracing message filter");
        }
        RpcEndExcept
    }
    TraceFunctLeave();
}

//---[ TraceMessageEnumFilter ]------------------------------------------------
//
//
//  Description:
//      Wrapper function that can safely dump a MESSAGE_ENUM_FILTER
//  Parameters:
//      IN  pvParam                 User param to pass to tracing
//      IN  pmfMessageEnumFilter    MESSAGE_ENUM_FILTER to trace
//  Returns:
//      -
//  History:
//      6/14/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void TraceMessageEnumFilter(LPARAM pvParam,
                            MESSAGE_ENUM_FILTER *pmfMessageEnumFilter)
{
    TraceFunctEnterEx((LPARAM) pvParam, "TraceMessageEnumFilter");
    if (pmfMessageEnumFilter)
    {
        RpcTryExcept
        {
            DebugTrace(pvParam,
                "Message Enum Filter Sender is %S",
                pmfMessageEnumFilter->szMessageSender);
            DebugTrace(pvParam,
                "Message Enum Filter Recipient is %S",
                pmfMessageEnumFilter->szMessageRecipient);
            DebugTrace(pvParam,
                "Message Enum Filter version is %ld",
                pmfMessageEnumFilter->dwVersion);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            ErrorTrace(pvParam, "Exception while tracing message enum filter");
        }
        RpcEndExcept
    }
    TraceFunctLeave();
}

//The following are the the client side wrappers of the RPC calls.  These
//include tracing and exception handling.
NET_API_STATUS
NET_API_FUNCTION
ClientAQApplyActionToLinks(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
    LINK_ACTION		laAction)
{
    NET_API_STATUS apiStatus;
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQApplyActionToLinks");

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQApplyActionToLinks(wszServer,
                                              wszInstance,
                                              laAction);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQApplyActionToLinks - 0x%08X", apiStatus);
    }
    RpcEndExcept

    DebugTrace((LPARAM) NULL,
        "AQApplyActionToMessages returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}

NET_API_STATUS
NET_API_FUNCTION
ClientAQApplyActionToMessages(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
	MESSAGE_FILTER	*pmfMessageFilter,
	MESSAGE_ACTION	maMessageAction,
    DWORD           *pcMsgs)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQApplyActionToMessages");
    NET_API_STATUS apiStatus;

    TraceMessageFilter((LPARAM) pmfMessageFilter, pmfMessageFilter);

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQApplyActionToMessages(wszServer,
                                                 wszInstance,
                                                 pqlQueueLinkId,
                                                 pmfMessageFilter,
                                                 maMessageAction,
                                                 pcMsgs);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQApplyActionToMessages - 0x%08X", apiStatus);
    }
    RpcEndExcept

    DebugTrace((LPARAM) NULL,
        "AQApplyActionToMessages returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetQueueInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueId,
	QUEUE_INFO		*pqiQueueInfo)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetQueueInfo");
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetQueueInfo(wszServer,
                                        wszInstance,
                                        pqlQueueId,
                                        pqiQueueInfo);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQGetQueueInfo - 0x%08X", apiStatus);
    }
    RpcEndExcept

    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetLinkInfo(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_INFO		*pliLinkInfo,
    HRESULT         *phrLinkDiagnostic)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetLinkInfo");
    NET_API_STATUS apiStatus;
    _ASSERT(phrLinkDiagnostic);

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetLinkInfo(wszServer,
                                       wszInstance,
                                       pqlLinkId,
                                       pliLinkInfo,
                                       phrLinkDiagnostic);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQGetLinkInfo - 0x%08X", apiStatus);
    }
    RpcEndExcept

    DebugTrace((LPARAM) NULL, "AQGetLinkInfo returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQSetLinkState(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	LINK_ACTION		la)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetLinkInfo");
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQSetLinkState(wszServer,
                                       wszInstance,
                                       pqlLinkId,
                                       la);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQSetLinkState - 0x%08X", apiStatus);
    }
    RpcEndExcept

    DebugTrace((LPARAM) NULL, "AQSetLinkState returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetLinkIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	DWORD			*pcLinks,
	QUEUELINK_ID	**rgLinks)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetLinkInfo");
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetLinkIDs(wszServer,
                                      wszInstance,
                                      pcLinks,
                                      rgLinks);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQGetLinkIDs - 0x%08X", apiStatus);
    }
    RpcEndExcept

    DebugTrace((LPARAM) NULL, "AQGetLinkIDs returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetQueueIDs(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlLinkId,
	DWORD			*pcQueues,
	QUEUELINK_ID	**rgQueues)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetQueueIDs");
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetQueueIDs(wszServer,
                                       wszInstance,
                                       pqlLinkId,
                                       pcQueues,
                                       rgQueues);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQGetQueueIDs - 0x%08X", apiStatus);
    }
    RpcEndExcept

    DebugTrace((LPARAM) NULL, "AQGetQueueIDs returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


NET_API_STATUS
NET_API_FUNCTION
ClientAQGetMessageProperties(
    LPWSTR          	wszServer,
    LPWSTR          	wszInstance,
	QUEUELINK_ID		*pqlQueueLinkId,
	MESSAGE_ENUM_FILTER	*pmfMessageEnumFilter,
	DWORD				*pcMsgs,
	MESSAGE_INFO		**rgMsgs)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQGetMessageProperties");
    NET_API_STATUS apiStatus;

    TraceMessageEnumFilter((LPARAM)pmfMessageEnumFilter, pmfMessageEnumFilter);
    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQGetMessageProperties(wszServer,
                                                wszInstance,
                                                pqlQueueLinkId,
                                                pmfMessageEnumFilter,
                                                pcMsgs,
                                                rgMsgs);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQGetMessageProperties - 0x%08X", apiStatus);
    }
    RpcEndExcept

    DebugTrace((LPARAM) NULL,
        "AQGetMessageProperties returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}


//---[ ClientAQQuerySupportedActions ]-----------------------------------------
//
//
//  Description:
//      Client stub for querying supported actions
//  Parameters:
//      IN  wszServer               The server to connect to
//      IN  wszInstance             The virtual server instance to connect to
//      IN  pqlQueueLinkId          The queue/link we are interested in
//      OUT pdwSupportedActions     The MESSAGE_ACTION flags supported
//      OUT pdwSupportedFilterFlags The supported filter flags
//  Returns:
//      S_OK on success
//      Internal error from RPC or server on failure
//  History:
//      6/15/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
NET_API_STATUS
NET_API_FUNCTION
ClientAQQuerySupportedActions(
    LPWSTR          wszServer,
    LPWSTR          wszInstance,
	QUEUELINK_ID	*pqlQueueLinkId,
    DWORD           *pdwSupportedActions,
    DWORD           *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) NULL, "ClientAQQuerySupportedActions");
    NET_API_STATUS apiStatus;

    RpcTryExcept
    {
        //
        // Try RPC (local or remote) version of API.
        //
        apiStatus = AQQuerySupportedActions(wszServer,
                                                wszInstance,
                                                pqlQueueLinkId,
                                                pdwSupportedActions,
                                                pdwSupportedFilterFlags);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        apiStatus = RpcExceptionCode();
        ErrorTrace((LPARAM) NULL,
            "RPC exception on AQQuerySupportedActions - 0x%08X", apiStatus);
    }
    RpcEndExcept

    DebugTrace((LPARAM) NULL,
        "AQQuerySupportedActions returned 0x%08X", apiStatus);
    TraceFunctLeave();
    return apiStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enumlnkq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: enumlinkq.cpp
//
//  Description: Implementation of CEnumLinkQueues which implements 
//      IEnumLinkQueues
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CEnumLinkQueues::CEnumLinkQueues(CVSAQAdmin *pVS,
                                 QUEUELINK_ID *rgQueueIds,
                                 DWORD cQueueIds) 
{
    _ASSERT(rgQueueIds);
    _ASSERT(pVS);
    pVS->AddRef();
    m_rgQueueIds = rgQueueIds;
    m_pVS = pVS;
    m_iQueueId = 0;
    m_cQueueIds = cQueueIds;

    if (m_rgQueueIds)
        m_prefp = new CQueueLinkIdContext(m_rgQueueIds, cQueueIds);
    else 
        m_prefp = NULL;
}

CEnumLinkQueues::~CEnumLinkQueues() {

    if (m_prefp)
    {
        m_rgQueueIds = NULL;
        m_prefp->Release();
        m_prefp = NULL;
    }

    if (m_pVS) 
    {
        m_pVS->Release();
        m_pVS = NULL;
    }
}

//---[ CEnumLinkQueues::Next ]-------------------------------------------------
//
//
//  Description: 
//      Gets the next ILinkQueue for this enumerator
//  Parameters:
//      IN      cElements   Elements to return
//      IN OUT  rgElements  Array to recieve new elements
//      OUT     pcGetched   Number of elements returned
//  Returns:
//      S_OK on success
//      S_FALSE with no more elements
//      E_POINTER on NULL args
//  History:
//      1/30/99 - MikeSwa Fixed AV on bogus args
//
//-----------------------------------------------------------------------------
HRESULT CEnumLinkQueues::Next(ULONG cElements,
                              ILinkQueue **rgElements,
                              ULONG *pcFetched)
{
    DWORD iQueueIdNew = m_iQueueId + cElements;
    DWORD i;
    HRESULT hr = S_OK;

    if (!rgElements || !pcFetched)
    {
        hr = E_POINTER;
        goto Exit;
    }

    // make sure we don't go past the end of the array
    if (iQueueIdNew > m_cQueueIds) iQueueIdNew = m_cQueueIds;

    // make a CVSAQLink object for each element and copy it into the user's
    // array
	(*pcFetched) = 0;
    for (i = m_iQueueId; (i < iQueueIdNew); i++) {
        rgElements[(*pcFetched)] = 
            (ILinkQueue *) new CLinkQueue(m_pVS, &(m_rgQueueIds[i]));

        // make sure that the allocation worked
        if (rgElements[(*pcFetched)] == NULL) {
            // remember how far we were able to go.
            iQueueIdNew = i;
            // if it didn't work and this was the first element then we
            // return out of memory.  if its not the first element then
            // return what we've built up so far.
            if (i == 0) hr = E_OUTOFMEMORY;
            // drop out of the loop
            break;
        } else {
			(*pcFetched)++;
		}
    }
	
    _ASSERT(*pcFetched <= cElements);
        
    m_iQueueId = iQueueIdNew;

    if (SUCCEEDED(hr) && *pcFetched < cElements) hr = S_FALSE;

  Exit:
    if (FAILED(hr))
    {
        if (pcFetched)
            *pcFetched = 0;
    }

	return hr;
}

//---[ CEnumLinkQueues::Skip ]-------------------------------------------------
//
//
//  Description: 
//      Skips forward the specified number of elements in the enumerator
//  Parameters:
//      IN  cElements       The number of elements to skip forward
//  Returns:
//      S_OK    Success, next element will be returned by Next()
//      S_FALSE Overflow, enumerator must be reset to return more elements
//  History:
//      2/2/99 - MikeSwa fixed overflow handling
//
//-----------------------------------------------------------------------------
HRESULT CEnumLinkQueues::Skip(ULONG cElements) 
{
    m_iQueueId += cElements;
    if ((m_iQueueId >= m_cQueueIds) || (m_iQueueId < cElements))
    {
        m_iQueueId = m_cQueueIds;
        return S_FALSE;
    } 
    else 
    {
        return S_OK;
    }
}

HRESULT CEnumLinkQueues::Reset() {
    m_iQueueId = 0;
    return S_OK;
}

//---[ CEnumLinkQueues::Clone ]------------------------------------------------
//
//
//  Description: 
//      Clones this enumerator
//  Parameters:
//      OUT ppEnum      New enumerator
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocated associated memory
//      E_POINTER if ppEnum is NULL
//  History:
//      2/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CEnumLinkQueues::Clone(IEnumLinkQueues **ppEnum) 
{
    if (!m_prefp)
        return E_OUTOFMEMORY;

    if (!ppEnum)
        return E_POINTER;

    *ppEnum = (IEnumLinkQueues *) new CEnumLinkQueues(m_pVS, NULL, m_cQueueIds);

    if (!*ppEnum)
        return E_OUTOFMEMORY;

    ((CEnumLinkQueues *)(*ppEnum))->m_rgQueueIds = m_rgQueueIds;
    ((CEnumLinkQueues *)(*ppEnum))->m_prefp = m_prefp;
    ((CEnumLinkQueues *)(*ppEnum))->m_iQueueId = m_iQueueId;
    m_prefp->AddRef();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enumlink.h ===
//-----------------------------------------------------------------------------
//
//
//  File: enumlink.h
//
//  Description: Header for CEnumVSAQLinks which implements IEnumVSAQLinks.
//      This provides an enumerator for all links on a virtual server.
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __ENUMLINK_H__
#define __ENUMLINK_H__

class CQueueLinkIdContext;

#define CEnumVSAQLinks_SIG 'eLAQ'

class CEnumVSAQLinks :
	public CComRefCount,
	public IEnumVSAQLinks
{
	public:
        //
        // pVS - pointer to the virtual server admin.  should be AddRef'd
        //       before calling this.  will be released in destructor.
        // cLinks - the size of rgLinks
        // rgLinks - array of link IDs
        //
		CEnumVSAQLinks(CVSAQAdmin *pVS, 
                       DWORD cLinks,
                       QUEUELINK_ID *rgLinks);
		virtual ~CEnumVSAQLinks();

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IUnknown *>(this);
			} else if (iid == IID_IEnumVSAQLinks) {
				*ppv = static_cast<IEnumVSAQLinks *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IEnumVSAQLinks
		COMMETHOD Next(ULONG cElements,
					   IVSAQLink **rgElements,
					   ULONG *pcFetched);
		COMMETHOD Skip(ULONG cElements);
		COMMETHOD Reset();
		COMMETHOD Clone(IEnumVSAQLinks **ppEnum);

    private:
        DWORD               m_dwSignature;
        CVSAQAdmin         *m_pVS;              // pointer to virtual server
        QUEUELINK_ID       *m_rgLinks;          // the array of links
        DWORD               m_cLinks;           // the size of rgLinks
        DWORD               m_iLink;            // the current link
        CQueueLinkIdContext *m_prefp;
};


//QUEUELINK_ID helper routines
inline BOOL fCopyQueueLinkId(QUEUELINK_ID *pqliDest, const QUEUELINK_ID *pqliSrc)
{
    //Copies the struct and allocates memory for strings
    memcpy(pqliDest, pqliSrc, sizeof(QUEUELINK_ID));
    if (pqliSrc->szName)
    {
        pqliDest->szName = (LPWSTR) MIDL_user_allocate(
                    (wcslen(pqliSrc->szName) + 1)* sizeof(WCHAR));
        if (!pqliDest->szName)
        {
            ZeroMemory(pqliDest, sizeof(QUEUELINK_ID));
            return FALSE;
        }
        wcscpy(pqliDest->szName, pqliSrc->szName);
    }
    return TRUE;
};

inline VOID FreeQueueLinkId(QUEUELINK_ID *pli)
{
    if (pli->szName)
        MIDL_user_free(pli->szName);
    pli->szName = NULL;
};
                      
//---[ CQueueLinkIdContext ]---------------------------------------------------
//
//
//  Description: 
//      Context used to ref-count array of QUEUELINK_IDs
//  
//-----------------------------------------------------------------------------
class   CQueueLinkIdContext : public CComRefCount
{
  protected:
        QUEUELINK_ID       *m_rgLinks;          // the array of links
        DWORD               m_cLinks;           // the size of rgLinks
  public:
    CQueueLinkIdContext(QUEUELINK_ID *rgLinks, DWORD cLinks)
    {
        m_rgLinks = rgLinks;
        m_cLinks = cLinks;
    };
    ~CQueueLinkIdContext()
    {
        if (m_rgLinks)
        {
            for (DWORD i = 0; i < m_cLinks; i++)
            {
                FreeQueueLinkId(&m_rgLinks[i]);
            }
            MIDL_user_free(m_rgLinks);
        }
    };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enumlnkq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: enumlinkq.h
//
//  Description: Header for CEnumLinkQueues which implements IEnumLinkQueues
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __ENUMLNKQ_H__
#define __ENUMLNKQ_H__

class CEnumLinkQueues :
	public CComRefCount,
	public IEnumLinkQueues
{
	public:
		CEnumLinkQueues(CVSAQAdmin *pVS, 
                        QUEUELINK_ID *rgQueueIds, 
                        DWORD cQueueIds);
		virtual ~CEnumLinkQueues();

		HRESULT Initialize(LPCSTR szVirtualServerDN);

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IUnknown *>(this);
			} else if (iid == IID_IEnumLinkQueues) {
				*ppv = static_cast<IEnumLinkQueues *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IEnumLinkQueues
		COMMETHOD Next(ULONG cElements, 
					   ILinkQueue **rgElements,
					   ULONG *pcReturned);
		COMMETHOD Skip(ULONG cElements);
		COMMETHOD Reset();
		COMMETHOD Clone(IEnumLinkQueues **ppEnum);
    private:
        CVSAQAdmin     *m_pVS;
        QUEUELINK_ID   *m_rgQueueIds;
        DWORD           m_cQueueIds;
        DWORD           m_iQueueId;
        CQueueLinkIdContext *m_prefp;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enummsgs.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: enummsgs.cpp
//
//  Description:  Implementation of CEnumMessages which implements 
//      IAQEnumMessages
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CEnumMessages::CEnumMessages(MESSAGE_INFO *rgMessages, DWORD cMessages)
{
    m_rgMessages = rgMessages;
    m_cMessages = cMessages;
    m_iMessage = 0;

    if (m_rgMessages)
        m_prefp = new CMessageInfoContext(rgMessages, m_cMessages);
    else
        m_prefp = NULL;
}

CEnumMessages::~CEnumMessages() 
{
    if (m_prefp)
    {
        m_rgMessages = NULL;
        m_prefp->Release();
        m_prefp = NULL;
    }
}

//---[ CEnumMessages::Next ]---------------------------------------------------
//
//
//  Description: 
//      Gets the next IAQMessage for this enumerator
//  Parameters:
//      IN      cElements   Elements to return
//      IN OUT  rgElements  Array to recieve new elements
//      OUT     pcGetched   Number of elements returned
//  Returns:
//      S_OK on success
//      S_FALSE with no more elements
//      E_POINTER on NULL args
//  History:
//      1/30/99 - MikeSwa Fixed AV on bogus args
//
//-----------------------------------------------------------------------------
HRESULT CEnumMessages::Next(ULONG cElements,
			   				 	IAQMessage **rgElements,
				  			 	ULONG *pcFetched)
{
    DWORD iMsgNew = m_iMessage + cElements;
    DWORD i;
    HRESULT hr = S_OK;

    if (!rgElements || !pcFetched)
    {
        hr = E_POINTER;
        goto Exit;
    }

    // make sure we don't go past the end of the array
    if (iMsgNew > m_cMessages) iMsgNew = m_cMessages;

    // make a CVSAQLink object for each element and copy it into the user's
    // array
	(*pcFetched) = 0;
    for (i = m_iMessage; (i < iMsgNew); i++) {
        rgElements[(*pcFetched)] = 
            (IAQMessage *) new CAQMessage(this, i);

        // make sure that the allocation worked
        if (rgElements[(*pcFetched)] == NULL) {
            // remember how far we were able to go.
            iMsgNew = i;
            // if it didn't work and this was the first element then we
            // return out of memory.  if its not the first element then
            // return what we've built up so far.
            if (i == 0) hr = E_OUTOFMEMORY;
            // drop out of the loop
            break;
        } else {
			(*pcFetched)++;
		}
    }
	
    _ASSERT(*pcFetched <= cElements);
        
    m_iMessage = iMsgNew;

    if (SUCCEEDED(hr) && *pcFetched < cElements) hr = S_FALSE;

  Exit:
    if (FAILED(hr))
    {
        if (pcFetched)
            *pcFetched = 0;
    }
	return hr;	
}

//---[ CEnumMessages::Skip ]---------------------------------------------------
//
//
//  Description: 
//      Skips forward the specified number of elements in the enumerator
//  Parameters:
//      IN  cElements       The number of elements to skip forward
//  Returns:
//      S_OK    Success, next element will be returned by Next()
//      S_FALSE Overflow, enumerator must be reset to return more elements
//  History:
//      2/2/99 - MikeSwa fixed overflow handling
//
//-----------------------------------------------------------------------------
HRESULT CEnumMessages::Skip(ULONG cElements) 
{
    m_iMessage += cElements;
    if ((m_iMessage >= m_cMessages) || (m_iMessage < cElements))
    {
        m_iMessage = m_cMessages;
        return S_FALSE;
    } 
    else 
    {
        return S_OK;
    }	
}

HRESULT CEnumMessages::Reset() {
    m_iMessage = 0;
    return S_OK;
}

//---[ CEnumMessages::Clone ]--------------------------------------------------
//
//
//  Description: 
//      Clones this enumerator
//  Parameters:
//      OUT ppEnum      New enumerator
//  Returns:
//      S_OK on success
//      E_OUTOFMEMORY if unable to allocated associated memory
//      E_POINTER if ppEnum is NULL
//  History:
//      2/2/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CEnumMessages::Clone(IAQEnumMessages **ppEnum) 
{
    if (!m_prefp)
        return E_OUTOFMEMORY;

    if (!ppEnum)
        return E_POINTER;

    *ppEnum = (IAQEnumMessages *) new CEnumMessages(NULL, m_cMessages);

    if (!*ppEnum)
        return E_OUTOFMEMORY;

    ((CEnumMessages *)(*ppEnum))->m_rgMessages = m_rgMessages;
    ((CEnumMessages *)(*ppEnum))->m_prefp = m_prefp;
    ((CEnumMessages *)(*ppEnum))->m_iMessage = m_iMessage;
    m_prefp->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\resource.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	Resource.h

Abstract:

	This module contains the definitions for the DirDropS
	project.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	03/17/96	created

--*/


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SEO.rc
//
#define IDS_PROJNAME					100
#define IDR_StdAfx						101


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\linkq.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: linkq.cpp
//
//  Description: Implementation of CLinkQueue which implements ILinkQueue
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CLinkQueue::CLinkQueue(CVSAQAdmin *pVS,
                       QUEUELINK_ID *pqlidQueueId) 
{
    TraceFunctEnterEx((LPARAM) this, "CLinkQueue::CLinkQueue");
    _ASSERT(pVS);
    pVS->AddRef();
    m_pVS = pVS;
    m_prefp = NULL;
    
    if (!fCopyQueueLinkId(&m_qlidQueueId, pqlidQueueId))
        ErrorTrace((LPARAM) this, "Unable to copy queue ID");

    TraceFunctLeave();
}

CLinkQueue::~CLinkQueue() {
    if (m_pVS) {
        m_pVS->Release();
        m_pVS = NULL;
    }

    if (m_prefp) {
        m_prefp->Release();
        m_prefp = NULL;
    }

    FreeQueueLinkId(&m_qlidQueueId);
}

HRESULT CLinkQueue::GetInfo(QUEUE_INFO *pQueueInfo) {
    TraceFunctEnter("CLinkQueue::GetInfo");
    
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    if (!pQueueInfo)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (CURRENT_QUEUE_ADMIN_VERSION != pQueueInfo->dwVersion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //Release old info
    if (m_prefp) {
        m_prefp->Release();
        m_prefp = NULL;
    }

    rc = ClientAQGetQueueInfo(m_pVS->GetComputer(),
                            m_pVS->GetVirtualServer(),
                            &m_qlidQueueId,
                            pQueueInfo);
    if (rc) {
        hr = HRESULT_FROM_WIN32(rc);
        goto Exit;
    }

    m_prefp = new CQueueInfoContext(pQueueInfo);
    if (!m_prefp)
    {
        ErrorTrace((LPARAM) this, "Error unable to alloc queue context.");
    }
     
  Exit:
    TraceFunctLeave();
	return hr;
}

//---[ CLinkQueue::GetMessageEnum ]--------------------------------------------
//
//
//  Description: 
//      Gets a IAQEnumMessages for this link queue based on the specified 
//      filter.
//  Parameters:
//      IN  pFilter     Filter specifying messages we are interestered in
//      OUT ppEnum      IAQEnumMessages returned by search
//  Returns:
//      S_OK on success
//      E_POINTER when NULL pointer values are passed in.
//  History:
//      1/30/99 - MikeSwa Fixed AV on invalid args
//
//-----------------------------------------------------------------------------
HRESULT CLinkQueue::GetMessageEnum(MESSAGE_ENUM_FILTER *pFilter,
								   IAQEnumMessages **ppEnum)
{
    TraceFunctEnter("CVSAQLink::GetMessageEnum");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    DWORD cMessages;
    MESSAGE_INFO *rgMessages = NULL;
    CEnumMessages *pEnumMessages = NULL;

    if (!pFilter || !ppEnum)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQGetMessageProperties(m_pVS->GetComputer(), 
                                    m_pVS->GetVirtualServer(), 
                                    &m_qlidQueueId,
                                    pFilter,
                                    &cMessages,
                                    &rgMessages);
    if (rc) {
        hr = HRESULT_FROM_WIN32(rc);
    } else {
        pEnumMessages = new CEnumMessages(rgMessages, cMessages);
        if (pEnumMessages == NULL) {
            hr = E_OUTOFMEMORY;
        }
    }

    *ppEnum = pEnumMessages;

    if (FAILED(hr)) {
        if (rgMessages) MIDL_user_free(rgMessages);
        if (pEnumMessages) delete pEnumMessages;
        *ppEnum = NULL;
    } 
    
  Exit:
    TraceFunctLeave();
    return hr;	
}

HRESULT CLinkQueue::ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										  MESSAGE_ACTION Action, 
                                          DWORD *pcMsgs) {
    TraceFunctEnter("CVSAQLink::ApplyActionToMessages");
    
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    if (!pFilter  || !pcMsgs)
    {
        hr = E_POINTER;
        if (pcMsgs)
            *pcMsgs = 0;
        goto Exit;
    }
    rc = ClientAQApplyActionToMessages(m_pVS->GetComputer(),
                                     m_pVS->GetVirtualServer(),
                                     &m_qlidQueueId,
                                     pFilter,
                                     Action, pcMsgs);
    if (rc) hr = HRESULT_FROM_WIN32(rc);

  Exit:
    TraceFunctLeave();
	return hr;	
}


//---[ CLinkQueue::QuerySupportedActions ]-------------------------------------
//
//
//  Description: 
//      Function that describes which actions are supported on this interface
//  Parameters:
//      OUT     pdwSupportedActions     Supported message actions
//      OUT     pdwSupportedFilterFlags Supported filter flags
//  Returns:
//      S_OK on success
//      E_POINTER on NULL args
//  History:
//      6/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CLinkQueue::QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                          OUT DWORD *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkQueue::QuerySupportedActions");
    HRESULT hr = S_OK;
    NET_API_STATUS rc;

    if (!pdwSupportedActions || !pdwSupportedFilterFlags)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQQuerySupportedActions(m_pVS->GetComputer(),
                                       m_pVS->GetVirtualServer(),
                                       &m_qlidQueueId,
                                       pdwSupportedActions,
                                       pdwSupportedFilterFlags);
    if (rc) 
        hr = HRESULT_FROM_WIN32(rc);

    if (FAILED(hr))
    {
        if (pdwSupportedActions)
            *pdwSupportedActions = 0;

        if (pdwSupportedFilterFlags)
            *pdwSupportedFilterFlags = 0;

    }

  Exit:
    TraceFunctLeave();
    return hr;
}




//---[ CVSAQLink::GetUniqueId ]---------------------------------------------
//
//
//  Description: 
//      Returns a canonical representation of this queue.
//  Parameters:
//      OUT pqlid - pointer to QUEUELINK_ID to return
//  Returns:
//      S_OK on success
//      E_POINTER on failure
//  History:
//      12/5/2000 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CLinkQueue::GetUniqueId(OUT QUEUELINK_ID **ppqlid)
{
    TraceFunctEnterEx((LPARAM) this, "CLinkQueue::GetUniqueId");
    HRESULT hr = S_OK;

    if (!ppqlid) {
        hr = E_POINTER;
        goto Exit;
    }

    *ppqlid = &m_qlidQueueId;

  Exit:
    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\enummsgs.h ===
//-----------------------------------------------------------------------------
//
//
//  File: enummsgs.h
//
//  Description: Header file for CEnumMessages which implements IAQEnumMessages
//      Provides ability to enumerate over messages for a single queue.
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __ENUMMSGS_H__
#define __ENUMMSGS_H__

class CMessageInfoContext;

class CEnumMessages :
	public CComRefCount,
	public IAQEnumMessages
{
	public:
		CEnumMessages(MESSAGE_INFO *rgMessages, DWORD cMessages);
		virtual ~CEnumMessages();

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IUnknown *>(this);
			} else if (iid == IID_IAQEnumMessages) {
				*ppv = static_cast<IAQEnumMessages *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IAQEnumMessages
		COMMETHOD Next(ULONG cElements, 
					   IAQMessage **rgElements,
					   ULONG *pcReturned);
		COMMETHOD Skip(ULONG cElements);
		COMMETHOD Reset();
		COMMETHOD Clone(IAQEnumMessages **ppEnum);
    private:
        MESSAGE_INFO   *m_rgMessages;
        DWORD           m_cMessages; 
        DWORD           m_iMessage;
        CMessageInfoContext     *m_prefp;

        friend CAQMessage;
};

inline VOID FreeMessageInfo(PMESSAGE_INFO pMessageInfo)
{
    if (pMessageInfo->szMessageId)
        MIDL_user_free(pMessageInfo->szMessageId);

    if (pMessageInfo->szSender)
        MIDL_user_free(pMessageInfo->szSender);

    if (pMessageInfo->szSubject)
        MIDL_user_free(pMessageInfo->szSubject);

    if (pMessageInfo->szRecipients)
        MIDL_user_free(pMessageInfo->szRecipients);

    if (pMessageInfo->szCCRecipients)
        MIDL_user_free(pMessageInfo->szCCRecipients);

    if (pMessageInfo->szBCCRecipients)
        MIDL_user_free(pMessageInfo->szBCCRecipients);

    if (pMessageInfo->mszEnvRecipients)
        MIDL_user_free(pMessageInfo->mszEnvRecipients);
}

//---[ CMessageInfoContext ]---------------------------------------------------
//
//
//  Description: 
//      Context used to ref-count array of MESSAGE_INFO
//  
//-----------------------------------------------------------------------------
class   CMessageInfoContext : public CComRefCount
{
  protected:
        MESSAGE_INFO       *m_rgMessages;          // the array of messages
        DWORD               m_cMessages;           // the size of rgmessages
  public:
    CMessageInfoContext(MESSAGE_INFO *rgMessages, DWORD cMessages)
    {
        m_rgMessages = rgMessages;
        m_cMessages = cMessages;
    };
    ~CMessageInfoContext()
    {
        if (m_rgMessages)
        {
            for (DWORD i = 0; i < m_cMessages; i++)
            {
                FreeMessageInfo(&m_rgMessages[i]);
            }
            MIDL_user_free(m_rgMessages);
        }
    };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\makefile.inc ===
$(O)\aqadmin.h $(O)\aqadmin.c : $(STAXINC)\export\aqadmin.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqadmin_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqadmin.c \
    -header $@ \
    -tlb $(O)\aqadmin.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqadmrpc.h $(O)\aqadmrpc_c.c : ..\..\inc\aqadmrpc.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -server none \
    -cstub $(O)\aqadmrpc_c.c \
    -header $@ \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\aqerr.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc
    copy $(O)\msg00001.bin $(O)\aqerr.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\linkq.h ===
//-----------------------------------------------------------------------------
//
//
//  File: linkq.h
//
//  Description: Header for CLinkQueue which implements ILinkQueue
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __LINKQ_H__
#define __LINKQ_H__

class CQueueInfoContext;

class CLinkQueue :
	public CComRefCount,
	public ILinkQueue,
    public IAQMessageAction,
    public IUniqueId
{
	public:
		CLinkQueue(CVSAQAdmin *pVS,
                   QUEUELINK_ID *pqlidQueueId);
		virtual ~CLinkQueue();

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<ILinkQueue *>(this);
			} else if (iid == IID_ILinkQueue) {
				*ppv = static_cast<ILinkQueue *>(this);
			} else if (iid == IID_IAQMessageAction) {
				*ppv = static_cast<IAQMessageAction *>(this);
			} else if (iid == IID_IUniqueId) {
				*ppv = static_cast<IUniqueId *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// ILinkQueue
		COMMETHOD GetInfo(QUEUE_INFO *pQueueInfo);
		COMMETHOD GetMessageEnum(MESSAGE_ENUM_FILTER *pFilter,
								 IAQEnumMessages **ppEnum);

        //IAQMessageAction
		COMMETHOD ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										MESSAGE_ACTION Action,
                                        DWORD *pcMsgs);
        COMMETHOD QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                        OUT DWORD *pdwSupportedFilterFlags);

        // IUniqueId
        COMMETHOD GetUniqueId(QUEUELINK_ID **ppqlid);

private:
        CVSAQAdmin *m_pVS;
        QUEUELINK_ID m_qlidQueueId;
        CQueueInfoContext *m_prefp;
};

//---[ CQueueInfoContext ]------------------------------------------------------
//
//
//  Description: 
//      Context to handle memory requirement of queue info
//  
//-----------------------------------------------------------------------------
class CQueueInfoContext : public CComRefCount
{
  protected:
        QUEUE_INFO          m_QueueInfo;          // the array of links
  public:
    CQueueInfoContext(PQUEUE_INFO pQueueInfo)
    {
        if (pQueueInfo)
            memcpy(&m_QueueInfo, pQueueInfo, sizeof(QUEUE_INFO));
        else
            ZeroMemory(&m_QueueInfo, sizeof(QUEUE_INFO));
    };

    ~CQueueInfoContext()
    {
        if (m_QueueInfo.szLinkName)
            MIDL_user_free(m_QueueInfo.szLinkName);

        if (m_QueueInfo.szQueueName)
            MIDL_user_free(m_QueueInfo.szQueueName);
    };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\stdinc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.h

Abstract:

	This module contains the definitions for the base
	ATL methods.

Author:

	Don Dumitru     (dondu@microsoft.com)

Revision History:

	dondu   12/04/96        created

--*/


// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
	#define _WIN32_WINNT 0x0400
#endif


#ifdef _ATL_NO_DEBUG_CRT
	#include <nt.h>
	#include <ntrtl.h>
	#include <nturtl.h>
	#include <windows.h>
	#include "dbgtrace.h"
	#define _ASSERTE	_ASSERT
#endif


//#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


#if defined(_ATL_SINGLE_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Single"
#elif defined(_ATL_APARTMENT_THREADED)
	#define ATL_THREADING_MODEL_VALUE	L"Apartment"
#else
	#define ATL_THREADING_MODEL_VALUE	L"Both"
#endif


#define DECLARE_REGISTRY_RESOURCEID_EX(x,desc,progid,viprogid)			\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {				\
		HRESULT hrRes;													\
		_ATL_REGMAP_ENTRY *parme;										\
																		\
		hrRes = AtlAllocRegMapEx(&parme,								\
								 &GetObjectCLSID(),						\
								 &_Module,								\
								 NULL,									\
								 L"DESCRIPTION",						\
								 desc,									\
								 L"PROGID",								\
								 progid,								\
								 L"VIPROGID",							\
								 viprogid,								\
								 L"THREADINGMODEL",						\
								 ATL_THREADING_MODEL_VALUE,				\
								 NULL,									\
								 NULL);									\
		if (!SUCCEEDED(hrRes)) {										\
			return (hrRes);												\
		}																\
		hrRes = _Module.UpdateRegistryFromResource(x,bRegister,parme);	\
		CoTaskMemFree(parme);											\
		return (hrRes);													\
	}


#define DECLARE_REGISTRY_RESOURCE_EX(x,desc,progid,viprogid)				\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {					\
		HRESULT hrRes;														\
		_ATL_REGMAP_ENTRY *parme;											\
																			\
		hrRes = AtlAllocRegMapEx(&parme,									\
								 &GetObjectCLSID(),							\
								 &_Module,									\
								 NULL,										\
								 L"DESCRIPTION",							\
								 desc,										\
								 L"PROGID",									\
								 progid,									\
								 L"VIPROGID",								\
								 viprogid,									\
								 L"THREADINGMODEL",							\
								 ATL_THREADING_MODEL_VALUE,					\
								 NULL,										\
								 NULL);										\
		if (!SUCCEEDED(hrRes)) {											\
			return (hrRes);													\
		}																	\
		hrRes = _Module.UpdateRegistryFromResource(_T(#x),bRegister,parme);	\
		CoTaskMemFree(parme);												\
		return (hrRes);														\
	}


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...);

#define COMMETHOD HRESULT STDMETHODCALLTYPE 

class CComRefCount {
protected:
    LONG    m_cRefs;

public:
    CComRefCount() {
        m_cRefs = 1;
    }
    virtual ~CComRefCount() {}

    ULONG _stdcall AddRef() {
        _ASSERT(m_cRefs);
        return InterlockedIncrement(&m_cRefs);
    }
    ULONG _stdcall Release() {
        LONG r = InterlockedDecrement(&m_cRefs);
        _ASSERT(r >= 0);
        if (r == 0) delete this;
		return r;
    }
};

//---[ CComRefPtr ]------------------------------------------------------------
//
//
//  Description: 
//      Class that wraps a reference count around a data pointer.  Data must
//      have been allocated via MIDL_user_alloc.  Used to control the lifespan of 
//      allocated memory via AddRef() and Release()
//  Hungarian: 
//      refp, prefp
//  History:
//      2/2/99 - MikeSwa Created
//  
//-----------------------------------------------------------------------------
class CComRefPtr : public CComRefCount {
protected:
    PVOID   m_pvData;
public:
    CComRefPtr() {
        _ASSERT(0 && "Invalid Usage");
        m_pvData = NULL;
    };
    CComRefPtr(PVOID pvData)
    {
        m_pvData = pvData;
    };
    ~CComRefPtr()
    {
        if (m_pvData)
            MIDL_user_free(m_pvData);
    };
    PVOID pvGet() {return m_pvData;};
};

#include "aqadmtyp.h"
#include "resource.h"
#include "aqadmin.h"
#include <transmem.h>
						 
#ifdef PLATINUM
#include <aqmem.h>
#include "phatqmsg.h"
#include "exaqadm.h"
#else  //not PLATINUM
#include "aqerr.h"
#endif //PLATINUM

#include "aqrpcstb.h"
#include "aqadm.h"
#include "vsaqadm.h"
#include "enumlink.h"
#include "aqmsg.h"
#include "enummsgs.h"
#include "enumlnkq.h"
#include "vsaqlink.h"
#include "linkq.h"

extern QUEUELINK_ID g_qlidNull;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\vsaqadm.h ===
//-----------------------------------------------------------------------------
//
//
//  File: vsaqadm.h
//
//  Description: Header for CVSAQAdmin which implements IVSAQAdmin.  This is
//      the top level interface for a virtual server. It provides the ability
//      to enumerate links, stop/start all outbound connections, and apply 
//      actions to all messages based on a filter
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __VSAQADM_H__
#define __VSAQADM_H__

#define CVSAQAdmin_SIG 'SVAQ'

class CVSAQAdmin :
	public CComRefCount,
	public IVSAQAdmin,
    public IAQMessageAction
{
	public:
		CVSAQAdmin();
		virtual ~CVSAQAdmin();

		HRESULT Initialize(LPCWSTR wszComputer, LPCWSTR wszVirtualServer);
        WCHAR *GetComputer() { return m_wszComputer; }
        WCHAR *GetVirtualServer() { return m_wszVirtualServer; }

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IVSAQAdmin *>(this);
			} else if (iid == IID_IVSAQAdmin) {
				*ppv = static_cast<IVSAQAdmin *>(this);
			} else if (iid == IID_IAQMessageAction) {
				*ppv = static_cast<IAQMessageAction *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IVSAQAdmin
		COMMETHOD GetLinkEnum(IEnumVSAQLinks **ppEnum);
		COMMETHOD StopAllLinks();
		COMMETHOD StartAllLinks();
        COMMETHOD GetGlobalLinkState();

        //IAQMessageAction
		COMMETHOD ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										MESSAGE_ACTION Action,
                                        DWORD *pcMsgs);
        COMMETHOD QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                        OUT DWORD *pdwSupportedFilterFlags);

    private:
        DWORD  m_dwSignature;
        WCHAR *m_wszComputer;
        WCHAR *m_wszVirtualServer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\vsaqlink.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: vsaqlink.cpp
//
//  Description: Implementation of CVSAQLink which implements IVSAQLink
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CVSAQLink::CVSAQLink(CVSAQAdmin *pVS, QUEUELINK_ID *pqlidLink) {
    TraceFunctEnter("CVSAQLink::CVSAQLink");

    _ASSERT(pVS);
    pVS->AddRef();
    m_pVS = pVS;

    if (!fCopyQueueLinkId(&m_qlidLink, pqlidLink))
        ErrorTrace((LPARAM) this, "Unable to copy queue ID");

    TraceFunctLeave();
}

CVSAQLink::~CVSAQLink() {
    TraceFunctEnter("CVSAQLink::");

    if (m_pVS) {
        m_pVS->Release();
        m_pVS = NULL;
    }

    FreeQueueLinkId(&m_qlidLink);

    TraceFunctLeave();
}

HRESULT CVSAQLink::GetInfo(LINK_INFO *pLinkInfo) {
    TraceFunctEnter("CVSAQLink::GetInfo");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    HRESULT hrLinkDiagnostic = S_OK;
    WCHAR   szDiagnostic[1000] = L"";
    DWORD   dwFacility = 0;
#ifdef PLATINUM
    HINSTANCE   hModule = GetModuleHandle("phatqadm.dll");
#else
    HINSTANCE   hModule = GetModuleHandle("aqadmin.dll");
#endif
    DWORD   cbDiagnostic = 0;
    DWORD   dwErr;

    if (!pLinkInfo)
    {
        hr = E_POINTER;
        goto Exit;
    }

    if (CURRENT_QUEUE_ADMIN_VERSION != pLinkInfo->dwVersion)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    rc = ClientAQGetLinkInfo(m_pVS->GetComputer(),
                           m_pVS->GetVirtualServer(),
                           &m_qlidLink,
                           pLinkInfo,
                           &hrLinkDiagnostic);

    if (rc)
    {
        hr = HRESULT_FROM_WIN32(rc);
        goto Exit;
    }

    //Get extended diagnotic information from HRESULT
    if (!(pLinkInfo->fStateFlags & LI_RETRY) || SUCCEEDED(hrLinkDiagnostic))
        goto Exit; //We don't have any interesting error messages to report

    if (!hModule)
    {
        //If we don't have a module... don't return an message string
        ErrorTrace((LPARAM) this, "Unable to get module handle for aqadmin\n");
        goto Exit;
    }

    dwFacility = ((0x0FFF0000 & hrLinkDiagnostic) >> 16);

    //If it is not ours... then "un-HRESULT" it
    if (dwFacility != FACILITY_ITF)
        hrLinkDiagnostic &= 0x0000FFFF;

    dwErr = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
                   FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_HMODULE,
                   hModule,
                   hrLinkDiagnostic,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   szDiagnostic,
                   sizeof(szDiagnostic)/sizeof(szDiagnostic[0]),
                   NULL);

    //FormatMessageW returns 0 on failure
    if (!dwErr)
    {
        //We probably did not find the error in our message table
        dwErr = GetLastError();
        ErrorTrace((LPARAM) this,
            "Error formatting message for link diagnostic 0x%08X", dwErr);

        goto Exit;
    }

    DebugTrace((LPARAM) this, "Found Link Diagnostic %S", szDiagnostic);

    cbDiagnostic = (wcslen(szDiagnostic) + 1) * sizeof(WCHAR);

    pLinkInfo->szExtendedStateInfo = (LPWSTR) MIDL_user_allocate(cbDiagnostic);
    if (!pLinkInfo->szExtendedStateInfo)
    {
        ErrorTrace((LPARAM) this, "Unable to allocate szExtendedStateInfo");
        goto Exit;
    }

    wcscpy(pLinkInfo->szExtendedStateInfo, szDiagnostic);

    //If it ends with a CRLF... off with it!
    if (L'\r' == pLinkInfo->szExtendedStateInfo[cbDiagnostic/sizeof(WCHAR) - 3])
        pLinkInfo->szExtendedStateInfo[cbDiagnostic/sizeof(WCHAR) - 3] = L'\0';

  Exit:
    // X5:195608
    // I'm pretty sure the root of this has been fixed in fRPCCopyName but
    // just to be sure we are Firewalling against the problem here
    // and in aqrpcsvr.cpp
    if(SUCCEEDED(hr) && pLinkInfo && !pLinkInfo->szLinkName)
    {
        // ASSERT this so we can catch it internally
        _ASSERT(0 && "GetInfo wants to return success with a NULL szLinkName");

        // return a failure because we do not have a link name - I'm going
        // with AQUEUE_E_INVALID_DOMAIN to prevent an admin popup
        hr = AQUEUE_E_INVALID_DOMAIN;
    }

    // Set the context before we return so that it can be cleaned up
    // on the next call or on shutdown of this object
    m_Context.SetContext(pLinkInfo);

    TraceFunctLeave();
	return hr;
}

HRESULT CVSAQLink::SetLinkState(LINK_ACTION la) {
    TraceFunctEnter("CVSAQLink::SetLinkState");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    rc = ClientAQSetLinkState(m_pVS->GetComputer(),
                           m_pVS->GetVirtualServer(),
                           &m_qlidLink,
                           la);
    if (rc) hr = HRESULT_FROM_WIN32(rc);

    TraceFunctLeave();
	return hr;
}

//---[ CVSAQLink::GetQueueEnum ]-----------------------------------------------
//
//
//  Description:
//      Gets a IEnumLinkQueues for this link
//  Parameters:
//      OUT ppEnum      IEnumLinkQueues returned by search
//  Returns:
//      S_OK on success
//      S_FALSE... there are no queues
//      E_POINTER when NULL pointer values are passed in.
//  History:
//      1/30/99 - MikeSwa Fixed AV on invalid args
//      6/18/99 - MikeSwa Fixed case where there are no queues
//
//-----------------------------------------------------------------------------
HRESULT CVSAQLink::GetQueueEnum(IEnumLinkQueues **ppEnum) {
    TraceFunctEnter("CVSAQLink::GetQueueEnum");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    DWORD cQueueIds;
    QUEUELINK_ID *rgQueueIds = NULL;
    CEnumLinkQueues *pEnumQueues = NULL;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQGetQueueIDs(m_pVS->GetComputer(),
                           m_pVS->GetVirtualServer(),
                           &m_qlidLink,
                           &cQueueIds,
                           &rgQueueIds);
    if (rc)
    {
        hr = HRESULT_FROM_WIN32(rc);
    }
    else if (!rgQueueIds || !cQueueIds)
    {
        DebugTrace((LPARAM) this, "Found link with no queues");
        hr = S_FALSE;
        *ppEnum = NULL;
        goto Exit;
    }
    else
    {
        pEnumQueues = new CEnumLinkQueues(m_pVS, rgQueueIds, cQueueIds);
        if (pEnumQueues == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    *ppEnum = pEnumQueues;

    if (FAILED(hr))
    {
        if (rgQueueIds) MIDL_user_free(rgQueueIds);
        if (pEnumQueues) delete pEnumQueues;
        *ppEnum = NULL;
    }

  Exit:
    TraceFunctLeave();
    return hr;
}

HRESULT CVSAQLink::ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										MESSAGE_ACTION Action,
                                        DWORD *pcMsgs) {
    TraceFunctEnter("CVSAQLink::ApplyActionToMessages");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    if (!pFilter || !pcMsgs)
    {
        hr = E_POINTER;
        if (pcMsgs)
            *pcMsgs = 0;
    }
    else
    {
        rc = ClientAQApplyActionToMessages(m_pVS->GetComputer(),
                                         m_pVS->GetVirtualServer(),
                                         &m_qlidLink,
                                         pFilter,
                                         Action,
                                         pcMsgs);
        if (rc)
            hr = HRESULT_FROM_WIN32(rc);
    }

    TraceFunctLeave();
	return hr;
}

//---[ CVSAQLink::QuerySupportedActions ]-------------------------------------
//
//
//  Description:
//      Function that describes which actions are supported on this interface
//  Parameters:
//      OUT     pdwSupportedActions     Supported message actions
//      OUT     pdwSupportedFilterFlags Supported filter flags
//  Returns:
//      S_OK on success
//      E_POINTER on bogus pointer
//  History:
//      6/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CVSAQLink::QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                          OUT DWORD *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CVSAQLink::QuerySupportedActions");
    HRESULT hr = S_OK;
    NET_API_STATUS rc;

    if (!pdwSupportedActions || !pdwSupportedFilterFlags)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQQuerySupportedActions(m_pVS->GetComputer(),
                                       m_pVS->GetVirtualServer(),
                                       &m_qlidLink,
                                       pdwSupportedActions,
                                       pdwSupportedFilterFlags);
    if (rc)
        hr = HRESULT_FROM_WIN32(rc);

  Exit:
    if (FAILED(hr))
    {
        if (pdwSupportedActions)
            *pdwSupportedActions = 0;

        if (pdwSupportedFilterFlags)
            *pdwSupportedFilterFlags = 0;

    }

    TraceFunctLeave();
    return hr;
}


//---[ CVSAQLink::GetUniqueId ]---------------------------------------------
//
//
//  Description:
//      Returns a canonical representation of this link.
//  Parameters:
//      OUT pqlid - pointer to QUEUELINK_ID to return
//  Returns:
//      S_OK on success
//      E_POINTER on failure
//  History:
//      12/5/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CVSAQLink::GetUniqueId(OUT QUEUELINK_ID **ppqlid)
{
    TraceFunctEnterEx((LPARAM) this, "CVSAQLink::GetUniqueId");
    HRESULT hr = S_OK;

    if (!ppqlid) {
        hr = E_POINTER;
        goto Exit;
    }

    *ppqlid = &m_qlidLink;

  Exit:
    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\stdatl.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	StdAfx.cpp

Abstract:

	This module contains the implementation for the base
	ATL methods.

Author:

	Don Dumitru	(dondu@microsoft.com)

Revision History:

	dondu	12/04/96	created

--*/


// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdinc.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>


HRESULT AtlAllocRegMapEx(_ATL_REGMAP_ENTRY **pparmeResult,
						 const CLSID *pclsid,
						 CComModule *pmodule,
						 LPCOLESTR pszIndex,
						 ...) {
	LPBYTE pbAdd = NULL;		// Working pointer to the next available "scratch space" in the map.
	DWORD dwCnt = 0;			// The count of entries in the map.
	LPOLESTR pszCLSID = NULL;	// The CLSID as a string.
	LPOLESTR pszTLID = NULL;	// The TLID as a string.

	if (!pparmeResult) {
		// The caller did not give us a place to return the result.
		return (E_POINTER);
	}
	*pparmeResult = NULL;	// For the first time through the loop, the result is NULL.
	// We are going to loop through twice.  The first time through, we haven't allocate the map yet, so
	// we will count all the strings, and add up their lenghts - this will give us the size of the buffer
	// we need to allocate for the map.  Then the second time through the loop, we will store all the
	// strings in the map.
	while (1) {
		if (pclsid) {
			// If we were passed a CLSID, then we want to include that in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to convert the CLSID to a string.
				HRESULT hrRes;

				hrRes = StringFromCLSID(*pclsid,&pszCLSID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the CLSID to a string.
					CoTaskMemFree(*pparmeResult);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the CLSID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"CLSID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszCLSID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the CLSID string and the fact that we have a CLSID in the map.
			pbAdd += (wcslen(pszCLSID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszCLSID);
				pszCLSID = NULL;
			}
		}
		if (pmodule) {
			// If we were passed a module, then we want to include the TLID in the map.
			if (!*pparmeResult) {
				// If this is the first time through, then we need to load the type library, get its
				// TLID, and convert it to a string.
				USES_CONVERSION;
				HRESULT hrRes;
				TCHAR szModule[MAX_PATH];
				LPOLESTR pszModule;
				CComPtr<ITypeLib> pTypeLib;
				TLIBATTR *ptlaAttr;
				if (!GetModuleFileName(pmodule->GetTypeLibInstance(),
									   szModule,
									   sizeof(szModule)/sizeof(TCHAR))) {
					hrRes = HRESULT_FROM_WIN32(GetLastError());
					if (SUCCEEDED(hrRes)) {
						// GetModuleFileName() failed, but GetLastError() didn't report an error - so
						// fake it.
						hrRes = E_OUTOFMEMORY;
					}
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				if (pszIndex) {
					// If we were passed an index, that means that the type library desired is not the
					// first type library in the resources - so append the index to the module name.
					lstrcat(szModule,OLE2T(pszIndex));
				}
				pszModule = T2OLE(szModule);
				hrRes = LoadTypeLib(pszModule,&pTypeLib);
				if (!SUCCEEDED(hrRes)) {
					// If we couldn't load the type library from the module, let's try changing the
					// module name to a type library name (change the extension to .TLB) and try to load
					// *that*.
					LPTSTR pszExt = NULL;
					LPTSTR psz;

					for (psz=szModule;*psz;psz=CharNext(psz)) {
						if (*psz == _T('.')) {
							pszExt = psz;
						}
					}
					if (!pszExt) {
						pszExt = psz;
					}
					lstrcpy(pszExt,_T(".tlb"));
					pszModule = T2OLE(szModule);
					hrRes = LoadTypeLib(pszModule,&pTypeLib);
				}
				if (!SUCCEEDED(hrRes)) {
					// We failed to load the type library.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = pTypeLib->GetLibAttr(&ptlaAttr);
				if (!SUCCEEDED(hrRes)) {
					// We failed to get the type library attributes.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
				hrRes = StringFromCLSID(ptlaAttr->guid,&pszTLID);
				if (!SUCCEEDED(hrRes)) {
					// We failed to convert the TLID to a string.
					CoTaskMemFree(pszCLSID);
					return (hrRes);
				}
			} else {
				// If this isn't the first time through, then we already have the TLID as a string, so
				// we just need to put it in the map.
				(*pparmeResult)[dwCnt].szKey = L"LIBID";
				(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
				wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszTLID);
			}
			// Whether or not this is the first time through, we increment some stuff based on the size
			// of the TLID string and the fact that we have a TLID in the map.
			pbAdd += (wcslen(pszTLID)+1) * sizeof(OLECHAR);
			dwCnt++;
			if (*pparmeResult) {
				// If this is not the first time through, make sure we clean up after ourselves.
				CoTaskMemFree(pszTLID);
				pszTLID = NULL;
			}
		}
		{	// Now we need to go through the varargs.  All of the varargs must be LPOLESTR (i.e. they
			// must be UNICODE), and they will consist of pairs - the key name followed by the data.  If
			// either member of the pair is NULL, that signals the end of the varargs.
			va_list valArgs;

			// Set the va_list to the start of the varargs.
			va_start(valArgs,pszIndex);
			while (1) {
				LPCOLESTR pszKey;
				LPCOLESTR pszData;

				// Get the first of the pair - this is the key name.
				pszKey = va_arg(valArgs,LPCOLESTR);
				if (!pszKey) {
					break;
				}
				// Get the second of the pair - this is the data.
				pszData = va_arg(valArgs,LPCOLESTR);
				if (!pszData) {
					break;
				}
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the key name to the
					// map.
					(*pparmeResult)[dwCnt].szKey = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szKey,pszKey);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string.
				pbAdd += (wcslen(pszKey)+1) * sizeof(OLECHAR);
				if (*pparmeResult) {
					// If this isn't the first time through, then we need to store the data to the map.
					(*pparmeResult)[dwCnt].szData = (LPCOLESTR) pbAdd;
					wcscpy((LPOLESTR) (*pparmeResult)[dwCnt].szData,pszData);
				}
				// Whether or not this is the first time through, we increment some stuff based on the
				// size of the string and the fact that we have a string in the map.
				pbAdd += (wcslen(pszData)+1) * sizeof(OLECHAR);
				dwCnt++;
			}
			// Reset the va_list, for the sake of cleanliness.
			va_end(valArgs);
		}
		if (*pparmeResult) {
			// If we have allocated the map, that means that we are finishing the second time through
			// the loop - so we are done!
			break;
		}
		if (!*pparmeResult) {
			// If we havemn't allocate the map, that means that we are finishing the first time through
			// the loop - so we need to allocate the map in preparation for the second time through.
			// First we calculate the number of bytes needed for the map - this is one ATL_REGMAP_ENTRY
			// for each entry, plus one _ATL_REGMAP_ENTRY which signals the end of the map, plus enough
			// space for all of the strings to follow.
			DWORD dwBytes = (DWORD)((dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY) + (pbAdd-(LPBYTE) NULL));

			*pparmeResult = (_ATL_REGMAP_ENTRY *) CoTaskMemAlloc(dwBytes);
			if (!*pparmeResult) {
				// The memory allocation failed.
				CoTaskMemFree(pszCLSID);
				CoTaskMemFree(pszTLID);
				return (E_OUTOFMEMORY);
			}
			// The memory allocation was successful - fill the memory with zeroes in preparation for
			// loading with the values.
			memset(*pparmeResult,0,dwBytes);
			// Reset the counters to the "beginning" - so that on the second time through, they are used
			// to keep track of where each successive value gets stored in the memory block.
			pbAdd = ((LPBYTE) *pparmeResult) + (dwCnt + 1) * sizeof(_ATL_REGMAP_ENTRY);
			dwCnt = 0;
		}
	}
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\vsaqadm.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: csaqadm.cpp
//
//  Description: Implementation of CVSAQAdmin which implements IVSAQAdmin
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

CVSAQAdmin::CVSAQAdmin() {
    TraceFunctEnter("VSAQAdmin::CVSAQAdmin");
    
    m_dwSignature = CVSAQAdmin_SIG;
    m_wszComputer = NULL;
    m_wszVirtualServer = NULL;

    TraceFunctLeave();
}

CVSAQAdmin::~CVSAQAdmin() {
    TraceFunctEnter("CVSAQAdmin");
    
    if (m_wszComputer) {
        delete[] m_wszComputer;
        m_wszComputer = NULL;
    }

    if (m_wszVirtualServer) {
        delete[] m_wszVirtualServer;
        m_wszVirtualServer = NULL;
    }

    TraceFunctLeave();
}

//---[ CVSAQAdmin::Initialize ]------------------------------------------------
//
//
//  Description: 
//      Initialize the CVSAQAdmin interface. Copies ID strings
//  Parameters:
//      IN  wszComputer         The name of the computer this interface is for
//      IN  wszVirtualServer    The virtual server that this interface is for
//  Returns:
//      S_OK onsuccess
//      E_OUTOFMEMORY on memory failures
//      E_POINTER on NULL arguments
//  History:
//      6/4/99 - MikeSwa Changed to UNICODE 
//
//-----------------------------------------------------------------------------
HRESULT CVSAQAdmin::Initialize(LPCWSTR wszComputer, LPCWSTR wszVirtualServer) {
    TraceFunctEnter("CVSAQAdmin::Initialize");

    if (!wszVirtualServer) return E_POINTER;

    DWORD cComputer;
    DWORD cVirtualServer = wcslen(wszVirtualServer) + 1;

    if (wszComputer != NULL) {
        cComputer = wcslen(wszComputer) + 1;
        m_wszComputer = new WCHAR[cComputer];
        if (m_wszComputer == NULL) {
            TraceFunctLeave();
            return E_OUTOFMEMORY;
        }
        wcscpy(m_wszComputer, wszComputer);
    }

    m_wszVirtualServer = new WCHAR[cVirtualServer];
    if (m_wszVirtualServer == NULL) {
        TraceFunctLeave();
        return E_OUTOFMEMORY;
    }
    wcscpy(m_wszVirtualServer, wszVirtualServer);

    TraceFunctLeave();
	return S_OK;
}

//---[CVSAQAdmin::GetLinkEnum ]------------------------------------------------
//
//
//  Description: 
//      Gets a IEnumVSAQLinks for this virtual server
//  Parameters:
//      OUT ppEnum      IEnumVSAQLinks returned by search
//  Returns:
//      S_OK on success
//      E_POINTER when NULL pointer values are passed in.
//  History:
//      1/30/99 - MikeSwa Fixed AV on invalid args
//
//-----------------------------------------------------------------------------
HRESULT CVSAQAdmin::GetLinkEnum(IEnumVSAQLinks **ppEnum) {
    TraceFunctEnter("CVSAQAdmin::GetLinkEnum");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    DWORD cLinks = 0;
    QUEUELINK_ID *rgLinks = NULL;
    CEnumVSAQLinks *pEnumLinks = NULL;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQGetLinkIDs(m_wszComputer, m_wszVirtualServer, &cLinks, &rgLinks);
    if (rc) {
        hr = HRESULT_FROM_WIN32(rc);
    } else {
        pEnumLinks = new CEnumVSAQLinks(this, cLinks, rgLinks);
        if (pEnumLinks == NULL) {
            hr = E_OUTOFMEMORY;
        }
    }

    *ppEnum = pEnumLinks;

    if (FAILED(hr)) {
        if (rgLinks) MIDL_user_free(rgLinks);
        if (pEnumLinks) delete pEnumLinks;
        *ppEnum = NULL;
    } 
    
  Exit:
    TraceFunctLeave();
    return hr;
}

HRESULT CVSAQAdmin::StopAllLinks() {
    TraceFunctEnter("CVSAQAdmin::StopAllLinks");
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    rc = ClientAQApplyActionToLinks(m_wszComputer, m_wszVirtualServer, LA_FREEZE);
    if (rc) hr = HRESULT_FROM_WIN32(rc);
    
    TraceFunctLeave();
    return hr;
}

HRESULT CVSAQAdmin::StartAllLinks() 
{
    TraceFunctEnter("CVSAQAdmin::StartAllLinks");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    rc = ClientAQApplyActionToLinks(m_wszComputer, m_wszVirtualServer, LA_THAW);
    if (rc) hr = HRESULT_FROM_WIN32(rc);
    
    TraceFunctLeave();
    return hr;
}

HRESULT CVSAQAdmin::ApplyActionToMessages(MESSAGE_FILTER *pmfFilter,
									   	  MESSAGE_ACTION ma,
                                          DWORD *pcMsgs)
{
    TraceFunctEnter("CVSAQAdmin::ApplyActionToMessages");

    NET_API_STATUS rc;
    HRESULT hr = S_OK;
    QUEUELINK_ID qlId;
    ZeroMemory(&qlId, sizeof(QUEUELINK_ID));
    qlId.qltType = QLT_NONE;

    if (!pmfFilter  || !pcMsgs)
    {
        hr = E_POINTER;
        if (pcMsgs)
            *pcMsgs = 0;
        goto Exit;
    }

    rc = ClientAQApplyActionToMessages(m_wszComputer, m_wszVirtualServer, 
                                    &qlId, pmfFilter, ma, pcMsgs);
    if (rc) hr = HRESULT_FROM_WIN32(rc);
        
  Exit:
    if (FAILED(hr))
    {
        if (pcMsgs)
            *pcMsgs = 0;
    }

    TraceFunctLeave();
	return hr;
}


//---[ CVSAQAdmin::GetGlobalLinkState ]----------------------------------------
//
//
//  Description: 
//      Used to get global state of links (re Stop|StartAllLinks)
//  Parameters:
//      -
//  Returns:
//      S_OK if links are started
//      S_FALSE if not
//  History:
//      1/13/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CVSAQAdmin::GetGlobalLinkState()
{
    TraceFunctEnter("CVSAQAdmin::GetGlobalLinkState");
    NET_API_STATUS rc;
    HRESULT hr = S_OK;

    rc = ClientAQApplyActionToLinks(m_wszComputer, m_wszVirtualServer, LA_INTERNAL);
    if (rc && (S_FALSE != rc)) 
        hr = HRESULT_FROM_WIN32(rc);
    else if (S_FALSE == rc)
        hr = S_FALSE;
    
    TraceFunctLeave();
    return hr;
}

//---[ CVSAQAdmin::QuerySupportedActions ]-------------------------------------
//
//
//  Description: 
//      Function that describes which actions are supported on this interface
//  Parameters:
//      OUT     pdwSupportedActions     Supported message actions
//      OUT     pdwSupportedFilterFlags Supported filter flags
//  Returns:
//      S_OK on success
//      E_POINTER on bogus args
//  History:
//      6/9/99 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CVSAQAdmin::QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                          OUT DWORD *pdwSupportedFilterFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CVSAQAdmin::QuerySupportedActions");
    HRESULT hr = S_OK;
    NET_API_STATUS rc;
    QUEUELINK_ID qlId;
    ZeroMemory(&qlId, sizeof(QUEUELINK_ID));
    qlId.qltType = QLT_NONE;

    if (!pdwSupportedActions || !pdwSupportedFilterFlags)
    {
        hr = E_POINTER;
        goto Exit;
    }

    rc = ClientAQQuerySupportedActions(m_wszComputer,
                                       m_wszVirtualServer,
                                       &qlId,
                                       pdwSupportedActions,
                                       pdwSupportedFilterFlags);
    if (rc) 
        hr = HRESULT_FROM_WIN32(rc);

  Exit:
    if (FAILED(hr))
    {
        if (pdwSupportedActions)
            *pdwSupportedActions = 0;

        if (pdwSupportedFilterFlags)
            *pdwSupportedFilterFlags = 0;

    }

    TraceFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\aqadmcli.h ===
#ifndef __AQADMCLI__
#define __AQADMCLI__

const unsigned MAX_CMD_LEN = 127; // reading command with _cgets
const unsigned MAX_SERVER_NAME = 64;

class CAQAdminCli
{
public:
	enum DispFlags 
	{
		DF_NONE  = 0x00000000,
		DF_LINK  = 0x00000001,
		DF_QUEUE = 0x00000002,
		DF_MSG   = 0x00000004
	};

private:
	IAQAdmin *m_pAdmin;
	IVSAQAdmin *m_pVS;
	
public:
	DispFlags m_dwDispFlags;
	CCmdInfo *m_pFilterCmd;
	CCmdInfo *m_pActionCmd;

   	BOOL m_fUseMTA;

public:
	CAQAdminCli();
	~CAQAdminCli();
	void Help();
	
	HRESULT GetQueue(IN IEnumLinkQueues *pQueueEnum, OUT ILinkQueue **ppQueue, IN OUT QUEUE_INFO *pQueueInf);
	HRESULT PrintQueueInfo();

	HRESULT GetLink(IN IEnumVSAQLinks *pLinkEnum, OUT IVSAQLink **ppLink, IN OUT LINK_INFO *pLinkInf);
	HRESULT PrintLinkInfo();

	HRESULT GetMsg(IN IAQEnumMessages *pMsgEnum, OUT IAQMessage **ppMsg, IN OUT MESSAGE_INFO *pMsgInf);
	HRESULT PrintMsgInfo();

	BOOL IsContinue(LPSTR pszTag, LPWSTR pszVal);
	inline void PInfo(int nCrt, LINK_INFO linkInf);
	inline void PInfo(int nCrt, QUEUE_INFO queueInf);
	inline void PInfo(int nCrt, MESSAGE_INFO msgInf);
	HRESULT SetMsgEnumFilter(MESSAGE_ENUM_FILTER *pFilter, CCmdInfo *pCmd);
	HRESULT SetMsgFilter(MESSAGE_FILTER *pFilter, CCmdInfo *pCmd);
	HRESULT SetServer(LPSTR pszServerName, LPSTR pszVSNumber);
	HRESULT SetMsgAction(MESSAGE_ACTION *pAction, CCmdInfo *pCmd);
	HRESULT ExecuteCmd(CAQAdminCli& Admcli, LPSTR szCmd);
	HRESULT UseMTA(BOOL fUseMTA);


	HRESULT Init();
	HRESULT StopAllLinks();
	HRESULT StartAllLinks();
    HRESULT GetGlobalLinkState();
	HRESULT MessageAction(MESSAGE_FILTER *pFilter, MESSAGE_ACTION action);
	void Cleanup();

	void FreeStruct(MESSAGE_FILTER *pStruct);
	void FreeStruct(LINK_INFO *pStruct);
	void FreeStruct(QUEUE_INFO *pStruct);
	void FreeStruct(MESSAGE_INFO *pStruct);

	BOOL LocalTimeToUTC(SYSTEMTIME *stLocTime, SYSTEMTIME *stUTCTime);
	BOOL StringToUTCTime(LPSTR szTime, SYSTEMTIME *pstUTCTime);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\src\vsaqlink.h ===
//-----------------------------------------------------------------------------
//
//
//  File: vsaqlink.h
//
//  Description: Header for CVSAQLink which implements IVSAQLink.  This is the
//      top level interface for a single link on a virtual server.  Provides
//      functionality to:
//          - Get information about a link
//          - Set the state of a link
//          - Get an enumerator for a final destination queues associated
//              with this link.
//
//  Author: Alex Wetmore (Awetmore)
//
//  History:
//      12/10/98 - MikeSwa Updated for initial checkin
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#ifndef __VSAQLINK_H__
#define __VSAQLINK_H__

//---[ CLinkInfoContext ]------------------------------------------------------
//
//
//  Description:
//      Context to handle memory requirement of link info
//
//-----------------------------------------------------------------------------
class CLinkInfoContext
{
  protected:
        LINK_INFO          m_LinkInfo;

    void FreeContext()
    {
        if (m_LinkInfo.szLinkName)
            MIDL_user_free(m_LinkInfo.szLinkName);

        if (m_LinkInfo.szLinkDN)
            MIDL_user_free(m_LinkInfo.szLinkDN);

        if (m_LinkInfo.szExtendedStateInfo)
            MIDL_user_free(m_LinkInfo.szExtendedStateInfo);
    };

  public:
    CLinkInfoContext()
    {
            ZeroMemory(&m_LinkInfo, sizeof(LINK_INFO));
    };

    void SetContext(PLINK_INFO pLinkInfo)
    {
        FreeContext();

        if (pLinkInfo)
            memcpy(&m_LinkInfo, pLinkInfo, sizeof(LINK_INFO));
        else
            ZeroMemory(&m_LinkInfo, sizeof(LINK_INFO));
    };

    ~CLinkInfoContext()
    {
        FreeContext();
    };
};

class CVSAQLink :
	public CComRefCount,
	public IVSAQLink,
    public IAQMessageAction,
    public IUniqueId
{
	public:
		CVSAQLink(CVSAQAdmin *pVS, QUEUELINK_ID *pqlidLink);
		virtual ~CVSAQLink();

		// IUnknown
		ULONG _stdcall AddRef() { return CComRefCount::AddRef(); }
		ULONG _stdcall Release() { return CComRefCount::Release(); }
		HRESULT _stdcall QueryInterface(REFIID iid, void **ppv) {
			if (iid == IID_IUnknown) {
				*ppv = static_cast<IVSAQLink *>(this);
			} else if (iid == IID_IVSAQLink) {
				*ppv = static_cast<IVSAQLink *>(this);
			} else if (iid == IID_IAQMessageAction) {
				*ppv = static_cast<IAQMessageAction *>(this);
			} else if (iid == IID_IUniqueId) {
				*ppv = static_cast<IUniqueId *>(this);
			} else {
				*ppv = NULL;
				return E_NOINTERFACE;
			}
			reinterpret_cast<IUnknown *>(*ppv)->AddRef();
			return S_OK;
		}

		// IVSAQLink
		COMMETHOD GetInfo(LINK_INFO *pLinkInfo);
		COMMETHOD SetLinkState(LINK_ACTION la);
		COMMETHOD GetQueueEnum(IEnumLinkQueues **ppEnum);

        //IAQMessageAction
		COMMETHOD ApplyActionToMessages(MESSAGE_FILTER *pFilter,
										MESSAGE_ACTION Action,
                                        DWORD *pcMsgs);
        COMMETHOD QuerySupportedActions(OUT DWORD *pdwSupportedActions,
                                        OUT DWORD *pdwSupportedFilterFlags);

        // IUniqueId
        COMMETHOD GetUniqueId(QUEUELINK_ID **ppqlid);

    private:
        CVSAQAdmin          *m_pVS;          // pointer to virtual server
        QUEUELINK_ID         m_qlidLink;     // the array of links
        CLinkInfoContext     m_Context;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\makefile.inc ===
$(O)\aqadmin.h $(O)\aqadmin.c : $(STAXINC)\export\aqadmin.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(O)\aqadmin.c \
    -dlldata $(O)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqadmin.c \
    -header $@ \
    -tlb $(O)\aqadmin.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\aqadmcli.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqadmcli.cpp
//
//  Description:
//      Unit test for AQAdmin interface
//
//  Author: 
//      Aldrin Teganeanu (aldrint)
//      Mike Swafford (MikeSwa)
//
//  History:
//      6/5/99 - MikeSwa Updated to new AQAdmin interface
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------
#include "stdinc.h"

const CLSID CLSID_MAQAdmin = {0x0427FFA4,0xAF27,0x11d2,{0x8F,0xAF,0x00,0xC0,0x4F,0xA3,0x78,0xFF}};

//Utility for converting To UNICODE... uses LocalAlloc()
LPWSTR  wszGetUnicodeArg(LPSTR szSrc, DWORD cSrc)
{
    LPWSTR  wszDest = NULL;
    CHAR    chSave = '\0';
    if (!szSrc || !cSrc)
        return NULL;

    wszDest = (LPWSTR) LocalAlloc(LPTR, (cSrc+1)*sizeof(WCHAR));
    if (!wszDest)
        return NULL;

    chSave = szSrc[cSrc];
    szSrc[cSrc] = '\0';
    MultiByteToWideChar(CP_ACP,
                        0,
                        szSrc,
                        -1,
                        wszDest,
                        cSrc+1);
    szSrc[cSrc] = chSave;

    return wszDest;
}


//prints queue link info if it has it
void PrintQueueLinkInfo(IUnknown *pIUnknown)
{

    HRESULT hr = S_OK;
    IUniqueId *pIUniqueId = NULL;
    QUEUELINK_ID *pqlid = NULL;
    CHAR    szGuid[100] = "";

    hr = pIUnknown->QueryInterface(IID_IUniqueId, 
                                   (void **) &pIUniqueId);
    if (FAILED(hr))
        goto Exit;

    hr = pIUniqueId->GetUniqueId(&pqlid);
    if (FAILED(hr)) {
        printf ("GetQueueLinkId failied with hr 0x%08X\n", hr);
        goto Exit;
    }

    //
    //  Get string-ized form of GUID
    //
    StringFromGUID2(pqlid->uuid, (LPOLESTR) szGuid, sizeof(szGuid)-1);
    
    
    printf("QLID:: type %s : Name %S : ID 0x%08X : Guid %S\n",
        (pqlid->qltType == QLT_LINK) ? "link" : ((pqlid->qltType == QLT_QUEUE) ? "queue" : "none"),
        pqlid->szName, pqlid->dwId, szGuid);

  Exit:
    if (pIUniqueId)
        pIUniqueId->Release();

}
//Helper function qo QI and call ApplyActionToMessages
HRESULT ApplyActionToMessages(IUnknown *pIUnknown,
                              MESSAGE_FILTER *pFilter,
                              MESSAGE_ACTION Action,
                              DWORD *pcMsgs)
{
    HRESULT hr = S_OK;
    IAQMessageAction *pIAQMessageAction = NULL;
    if (!pIUnknown)
        return E_POINTER;

    hr = pIUnknown->QueryInterface(IID_IAQMessageAction, 
                                   (void **) &pIAQMessageAction);
    if (FAILED(hr))
        return hr;
    if (!pIAQMessageAction)
        return E_FAIL;

    hr = pIAQMessageAction->ApplyActionToMessages(pFilter, Action, pcMsgs);
    pIAQMessageAction->Release();
    return hr;
}

HRESULT CAQAdminCli::SetMsgAction(MESSAGE_ACTION *pAction, CCmdInfo *pCmd)
{
	char buf[64];
	HRESULT hr = S_OK;

	hr = pCmd->GetValue("ma", buf);
	if(SUCCEEDED(hr))
	{
		// set the action
		if(!lstrcmpi(buf, "DEL"))
			(*pAction) = MA_DELETE;
		else if(!lstrcmpi(buf, "DEL_S"))
			(*pAction) = MA_DELETE_SILENT;
		else if(!lstrcmpi(buf, "FREEZE"))
			(*pAction) = MA_FREEZE_GLOBAL;
		else if(!lstrcmpi(buf, "THAW"))
			(*pAction) = MA_THAW_GLOBAL;
		else if(!lstrcmpi(buf, "COUNT"))
			(*pAction) = MA_COUNT;
		else
			hr = E_FAIL;
	}

	return hr;
}


//---[ CAQAdminCli::SetServer ]------------------------------------------------
//
//
//  Description: 
//      Sets the remote server and virtual server to connect to
//  Parameters:
//      IN  szServerName        The name of the server to connect to 
//      IN  szVSNumber          The stringized version number of the virtual
//                              server to connect to.
//  Returns:
//      S_OK on success
//      Error code from GetVirtualServerAdminITF
//  History:
//      6/5/99 - MikeSwa Updated to supply UNICODE arguments
//
//-----------------------------------------------------------------------------
HRESULT CAQAdminCli::SetServer(LPSTR szServerName, LPSTR szVSNumber)
{
	IVSAQAdmin *pTmpVS = NULL;
    WCHAR   wszServerName[200];
    WCHAR   wszVSNumber[200] = L"1";
    DWORD   cServerName = 0;
    DWORD   cVSNumber = 0;
	HRESULT hr = S_OK;

    *wszServerName = L'\0';
    if (szServerName && *szServerName)
    {
        cServerName = strlen(szServerName);
        if (cServerName*sizeof(WCHAR) < sizeof(wszServerName))
        {
                MultiByteToWideChar(CP_ACP,
                            0,
                            szServerName,
                            -1,
                            wszServerName,
                            cServerName+1);
        }
    }

    if (szVSNumber && *szVSNumber)
    {
        cVSNumber = strlen(szVSNumber);
        if (cVSNumber*sizeof(WCHAR) < sizeof(wszVSNumber))
        {
                MultiByteToWideChar(CP_ACP,
                            0,
                            szVSNumber,
                            -1,
                            wszVSNumber,
                            cVSNumber+1);
        }
    }

	// not going to release the old server until I'm sure
	// that I got the new one.
	hr = m_pAdmin->GetVirtualServerAdminITF(wszServerName, wszVSNumber, &pTmpVS);
	if(FAILED(hr)) 
	{
        printf("Error: GetVirtualServerAdminITF for \"%s\" failed with 0x%x\n", szServerName, hr);
    }
	else
	{
		if(NULL != m_pVS)
			m_pVS->Release();

		m_pVS = pTmpVS;
	}

	return hr;
}


BOOL CAQAdminCli::StringToUTCTime(LPSTR szTime, SYSTEMTIME *pstUTCTime)
{
	// read the date
	WORD wMonth, wDay, wYear, wHour, wMinute, wSecond, wMilliseconds;
	BOOL res;

	int n = sscanf(szTime, "%d/%d/%d %d:%d:%d:%d", 
					&(wMonth),
					&(wDay),
					&(wYear),
					&(wHour),
					&(wMinute),
					&(wSecond),
					&(wMilliseconds));

	if(n == 7)
	{
		// check if it's GMT or UTC time
		if(NULL == strstr(szTime, "UTC") && NULL == strstr(szTime, "GMT"))
		{
			// this is local time
			SYSTEMTIME stLocTime;
			ZeroMemory(&stLocTime, sizeof(SYSTEMTIME));

			stLocTime.wMonth = wMonth;
			stLocTime.wDay = wDay;
			stLocTime.wYear = wYear;
			stLocTime.wHour = wHour;
			stLocTime.wMinute = wMinute;
			stLocTime.wSecond = wSecond;
			stLocTime.wMilliseconds = wMilliseconds;
			
			// convert from local time to UTC time
			if(!LocalTimeToUTC(&stLocTime, pstUTCTime))
			{
				printf("Cannot convert from local time to UTC\n");
				res = FALSE;
				goto Exit;
			}
		}
		else
		{
			// it's already UTC time
			pstUTCTime->wMonth = wMonth;
			pstUTCTime->wDay = wDay;
			pstUTCTime->wYear = wYear;
			pstUTCTime->wHour = wHour;
			pstUTCTime->wMinute = wMinute;
			pstUTCTime->wSecond = wSecond;
			pstUTCTime->wMilliseconds = wMilliseconds;
		}				
	}

Exit:
	return res;
}


BOOL CAQAdminCli::LocalTimeToUTC(SYSTEMTIME *pstLocTime, SYSTEMTIME *pstUTCTime)
{
	// the only way I know how to do it is:
	// - convert local system time to local file time
	// - convert local file time to UTC file time
	// - convert UTC file time to UTC system time

	FILETIME ftLocTime, ftUTCTime;
	BOOL res;

	res = SystemTimeToFileTime(pstLocTime, &ftLocTime);
	res = res && LocalFileTimeToFileTime(&ftLocTime, &ftUTCTime);
	res = res && FileTimeToSystemTime(&ftUTCTime, pstUTCTime);
	
	return res;
}

void CAQAdminCli::FreeStruct(LINK_INFO *pStruct)
{
	if(NULL != pStruct->szLinkName)
	{
		pStruct->szLinkName = NULL;
	}
}

void CAQAdminCli::FreeStruct(QUEUE_INFO *pStruct)
{
	if(NULL != pStruct->szQueueName)
	{
		pStruct->szQueueName = NULL;
	}
    if(NULL != pStruct->szLinkName)
	{
		pStruct->szLinkName = NULL;
	}
}

void CAQAdminCli::FreeStruct(MESSAGE_INFO *pStruct)
{
	if(NULL != pStruct->szMessageId)
	{
		pStruct->szMessageId = NULL;
	}
    if(NULL != pStruct->szSender)
	{
		pStruct->szSender = NULL;
	}
    if(NULL != pStruct->szSubject)
	{
		pStruct->szSubject = NULL;
	}
    if(NULL != pStruct->szRecipients)
	{
		pStruct->szRecipients = NULL;
	}
    if(NULL != pStruct->szCCRecipients)
	{
		pStruct->szCCRecipients = NULL;
	}
    if(NULL != pStruct->szBCCRecipients)
	{
		pStruct->szBCCRecipients = NULL;
	}
}


void CAQAdminCli::FreeStruct(MESSAGE_FILTER *pStruct)
{
	if(NULL != pStruct->szMessageId)
	{
		LocalFree((void*)pStruct->szMessageId);
		pStruct->szMessageId = NULL;
	}
    if(NULL != pStruct->szMessageSender)
	{
		LocalFree((void*)pStruct->szMessageSender);
		pStruct->szMessageSender = NULL;
	}
    if(NULL != pStruct->szMessageRecipient)
	{
		LocalFree((void*)pStruct->szMessageRecipient);
		pStruct->szMessageRecipient = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// Method:		SetMsgFilter()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::SetMsgFilter(MESSAGE_FILTER *pFilter, CCmdInfo *pCmd)
{
	HRESULT hr = S_OK;
	char *buf = NULL;
	int nFlagsOK = 0;

	ZeroMemory(pFilter, sizeof(MESSAGE_FILTER));
	pFilter->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
	hr = pCmd->AllocValue("flags", &buf);
	if(SUCCEEDED(hr))
	{
		// set the filter type
		char *token = strtok(buf, "|");
		while(token != NULL)
		{
			// strip the spaces
			char *st, *en;
			for(st = token; isspace(*st); st++);
			for(en = st; *en; en++);
			for(--en; en > st && isspace(*en); en--);
			
			if(en - st + 1 > 0)
			{
				// found a flag
				char flag[64];
				ZeroMemory(flag, sizeof(flag));
				CopyMemory(flag, st, en - st + 1);

				if(!lstrcmpi(flag, "MSGID"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_MESSAGEID;
				}
				else if(!lstrcmpi(flag, "SENDER"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_SENDER;
				}
				else if(!lstrcmpi(flag, "RCPT"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_RECIPIENT;
				}
				else if(!lstrcmpi(flag, "SIZE"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_SIZE;
				}
				else if(!lstrcmpi(flag, "TIME"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_TIME;
				}
				else if(!lstrcmpi(flag, "FROZEN"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_FROZEN;
				}
				else if(!lstrcmpi(flag, "NOT"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_INVERTSENSE;
				}
				else if(!lstrcmpi(flag, "ALL"))
				{
					nFlagsOK++;
					pFilter->fFlags |= MF_ALL;
				}
			}

			token = strtok(NULL, "|");	
		}
	}
	
	// if no valid flags or no flags at all fail
	if(0 == nFlagsOK)
	{
		printf("Error: no flags specified for the filter\n");
		hr = E_FAIL;
		goto Exit;
	}
	
	// set the message id
	nFlagsOK = 0;
	hr = pCmd->AllocValue("id", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
            pFilter->szMessageId = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageId)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
		    nFlagsOK++;
		}
	}

	// set the message sender
	nFlagsOK = 0;
	hr = pCmd->AllocValue("sender", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
            pFilter->szMessageSender = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageSender)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
    	    nFlagsOK++;
		}
	}

	// set the message recipient
	nFlagsOK = 0;
	hr = pCmd->AllocValue("rcpt", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
			pFilter->szMessageRecipient = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageRecipient)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
			nFlagsOK++;
		}
	}

	// set the min message size
	nFlagsOK = 0;
	hr = pCmd->AllocValue("size", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
			char aux[64];
			CopyMemory(aux, st, en - st + 1);
			int n = atoi(aux);
			pFilter->dwLargerThanSize = n;
			nFlagsOK++;
		}
	}

	// set the message date
	nFlagsOK = 0;
	hr = pCmd->AllocValue("date", &buf);
	if(SUCCEEDED(hr))
	{
		if(StringToUTCTime(buf, &(pFilter->stOlderThan)))
			nFlagsOK++;
	}

	// if no valid no. or no no. at all, set the default
	if(0 == nFlagsOK)
	{
		ZeroMemory(&(pFilter->stOlderThan), sizeof(SYSTEMTIME));
	}

	// if we came this far all is well
	hr = S_OK;
Exit:
	if(NULL != buf)
		delete [] buf;

	// TODO: validate the filter
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		SetMsgEnumFilter()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////

//1/18/99: AldrinT: updated flag parsing for SENDER and RCPT
HRESULT CAQAdminCli::SetMsgEnumFilter(MESSAGE_ENUM_FILTER *pFilter, CCmdInfo *pCmd)
{
	HRESULT hr;
	char *buf = NULL;
	int nFlagsOK = 0;

	ZeroMemory(pFilter, sizeof(MESSAGE_ENUM_FILTER));
	pFilter->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
	hr = pCmd->AllocValue("ft", &buf);
	if(SUCCEEDED(hr))
	{
		// set the filter type
		char *token = strtok(buf, "|");
		while(token != NULL)
		{
			// strip the spaces
			char *st, *en;
			for(st = token; isspace(*st); st++);
			for(en = st; *en; en++);
			for(--en; en > st && isspace(*en); en--);
			
			if(en - st + 1 > 0)
			{
				// found a flag
				char flag[64];
				ZeroMemory(flag, sizeof(flag));
				CopyMemory(flag, st, en - st + 1);

				if(!lstrcmpi(flag, "FIRST_N"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_FIRST_N_MESSAGES;
				}
				else if(!lstrcmpi(flag, "OLDER"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_OLDER_THAN;
				}
				else if(!lstrcmpi(flag, "OLDEST"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_N_OLDEST_MESSAGES;
				}
				else if(!lstrcmpi(flag, "LARGER"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_LARGER_THAN;
				}
				else if(!lstrcmpi(flag, "LARGEST"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_N_LARGEST_MESSAGES;
				}
				else if(!lstrcmpi(flag, "FROZEN"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_FROZEN;
				}
				else if(!lstrcmpi(flag, "NOT"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_INVERTSENSE;
				}
				else if(!lstrcmpi(flag, "ALL"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_ALL;
				}
				else if(!lstrcmpi(flag, "SENDER"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_SENDER;
				}
				else if(!lstrcmpi(flag, "RCPT"))
				{
					nFlagsOK++;
					pFilter->mefType |= MEF_RECIPIENT;
				}
			}

			token = strtok(NULL, "|");	
		}
	}
	

// Ifdef'd code because this is actually a valid state for skipping messages
//      12/13/98 - MikeSwa
#ifdef NEVER
	// if no valid flags or no flags at all, fail
	if(0 == nFlagsOK)
	{
		printf("Error: no flags specified for the filter\n");
		hr = E_FAIL;
		goto Exit;
	}
#endif 

	// set the message number
	nFlagsOK = 0;
	hr = pCmd->AllocValue("mn", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a flag
			char flag[64];
			ZeroMemory(flag, sizeof(flag));
			CopyMemory(flag, st, en - st + 1);
			int n = atoi(flag);
			if(0 == n)
			{
				printf("Error: message no. is 0 or not an integer. Using default.\n");
			}
			else
			{
				nFlagsOK++;
				pFilter->cMessages = n;
			}
		}
	}


	// set the message size
	nFlagsOK = 0;
	hr = pCmd->AllocValue("ms", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a flag
			char flag[64];
			ZeroMemory(flag, sizeof(flag));
			CopyMemory(flag, st, en - st + 1);
			int n = atoi(flag);
			nFlagsOK++;
			pFilter->cbSize = n;
		}
	}

	// if no valid no. or no no. at all, set the default
	if(0 == nFlagsOK)
		pFilter->cbSize = 0;

	// set the message date
	nFlagsOK = 0;
	hr = pCmd->AllocValue("md", &buf);
	if(SUCCEEDED(hr))
	{
		if(StringToUTCTime(buf, &(pFilter->stDate)))
			nFlagsOK++;
	}

	// if no valid no. or no no. at all, set the default
	if(0 == nFlagsOK)
	{
		ZeroMemory(&(pFilter->stDate), sizeof(SYSTEMTIME));
	}

	// set the skip message number
	nFlagsOK = 0;
	hr = pCmd->AllocValue("sk", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a flag
			char flag[64];
			ZeroMemory(flag, sizeof(flag));
			CopyMemory(flag, st, en - st + 1);
			int n = atoi(flag);
			nFlagsOK++;
			pFilter->cSkipMessages = n;
		}
	}

	// if no valid no. or no no. at all, set the default
	if(0 == nFlagsOK)
	{
		pFilter->cSkipMessages = 0;
	}

	// set the sender value
	nFlagsOK = 0;
	hr = pCmd->AllocValue("msndr", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
			pFilter->szMessageSender = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageSender)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
			nFlagsOK++;
		}
	}

	// set the recipient value
	nFlagsOK = 0;
	hr = pCmd->AllocValue("mrcpt", &buf);
	if(SUCCEEDED(hr))
	{
		// strip the spaces
		char *st, *en;
		for(st = buf; isspace(*st); st++);
		for(en = st; *en; en++);
		for(--en; en > st && isspace(*en); en--);
		
		if(en - st + 1 > 0)
		{
			// found a string
			pFilter->szMessageRecipient = wszGetUnicodeArg(st, (DWORD) (en-st+1));
			if(NULL == pFilter->szMessageRecipient)
			{
				printf("Error: LocalAlloc failed\n");
				hr = E_OUTOFMEMORY;
			}
			nFlagsOK++;
		}
	}

    if(!pFilter->mefType)
    {
		pFilter->cMessages = 1;
		pFilter->mefType |= MEF_FIRST_N_MESSAGES;
    }

	// if we came this far all is well
	hr = S_OK;
	// TODO: validate the filter
	if(NULL != buf)
		delete [] buf;
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		IsContinue()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
BOOL CAQAdminCli::IsContinue(LPSTR pszTag, LPWSTR wszVal)
{
	int nValidTags = 0;
    CHAR  szVal[200] = "";

	for(CCmdInfo::CArgList *p = m_pFilterCmd->pArgs; NULL != p; p = p->pNext)
	{
		// set the tag to the default value if not already set
		if(p->szTag[0] == 0 && m_pFilterCmd->szDefTag[0] != 0)
			lstrcpy(p->szTag, m_pFilterCmd->szDefTag);
		// count valid tags
		if(!lstrcmpi(p->szTag, pszTag))
			nValidTags++;
	}

	if(!nValidTags)
		return TRUE;

    //Convert in param to ASCII
    WideCharToMultiByte(CP_ACP, 0, wszVal, -1, szVal, 
                        sizeof(szVal), NULL, NULL);

	for(p = m_pFilterCmd->pArgs; NULL != p; p = p->pNext)
	{
		if(pszTag && lstrcmpi(p->szTag, pszTag))
			continue;

		if(szVal && lstrcmpi(p->szVal, szVal))
			continue;

		return TRUE;						
	}

	return FALSE;
}



////////////////////////////////////////////////////////////////////////////
// Method:		PrintMsgInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::PrintMsgInfo()
{
	HRESULT hr;
	int nCrtLink, nCrtQueue, nCrtMsg;

	IEnumVSAQLinks *pLinkEnum = NULL;
	IEnumLinkQueues *pQueueEnum = NULL;
	IAQEnumMessages *pMsgEnum = NULL;

    IVSAQLink *pLink = NULL;
	ILinkQueue *pQueue = NULL;
	IAQMessage *pMsg = NULL;

	LINK_INFO linkInf;
	QUEUE_INFO queueInf;
	MESSAGE_INFO msgInf;
	ZeroMemory(&linkInf, sizeof(LINK_INFO));
	ZeroMemory(&queueInf, sizeof(QUEUE_INFO));
	ZeroMemory(&msgInf, sizeof(MESSAGE_INFO));
		
	hr = m_pVS->GetLinkEnum(&pLinkEnum);
	if(FAILED(hr)) 
	{
		printf("GetLinkEnum failed with 0x%x\n", hr);
		goto Exit;
	}

	for(nCrtLink = 1; TRUE; nCrtLink++) 
	{
		if(NULL != pLink)
		{
			pLink->Release();
			pLink = NULL;
		}
		FreeStruct(&linkInf);
		hr = GetLink(pLinkEnum, &pLink, &linkInf);
		if(hr == S_FALSE)
		{
			if(nCrtLink == 1)
				puts("No links.");
			goto Exit;
		}
		else if(FAILED(hr))
		{
			break;
		}
		else if(hr == S_OK)
		{
			// check if we want messages for this link
			if(!IsContinue("ln", linkInf.szLinkName))
				continue;

			hr = pLink->GetQueueEnum(&pQueueEnum);
			if(FAILED(hr)) 
			{
				printf("Error: Link %d: pLink->GetQueueEnum failed with 0x%x\n", nCrtLink, hr);
				continue;
			}

			for(nCrtQueue = 1; TRUE; nCrtQueue++) 
			{
				if(NULL != pQueue)
				{
					pQueue->Release();
					pQueue = NULL;
				}
				FreeStruct(&queueInf);
				hr = GetQueue(pQueueEnum, &pQueue, &queueInf);
				if(hr == S_FALSE)
				{
					if(nCrtQueue == 1)
						puts("No queues.");
					break;
				}
				else if(FAILED(hr))
					break;
			
				// check if we want messages for this queue
				if(!IsContinue("qn", queueInf.szQueueName))
					continue;

				if(!lstrcmpi(m_pActionCmd->szCmdKey, "MSG_INFO"))
				{
					MESSAGE_ENUM_FILTER Filter;			
	
					// enum the messages
					SetMsgEnumFilter(&Filter, m_pFilterCmd);
				
					hr = pQueue->GetMessageEnum(&Filter, &pMsgEnum);
					if(FAILED(hr)) 
					{
						printf("Error: Link %d, Queue %d: pQueue->GetMessageEnum failed with 0x%x\n", nCrtLink, nCrtQueue, hr);
						continue;
					}
				
					printf("---- Messages in queue %S ----\n", queueInf.szQueueName);
					
					for(nCrtMsg = 1; TRUE; nCrtMsg++) 
					{
						FreeStruct(&msgInf);
						hr = GetMsg(pMsgEnum, &pMsg, &msgInf);
						if(NULL != pMsg)
						{
							pMsg->Release();
							pMsg = NULL;
						}
						if(hr == S_FALSE)
						{
							if(nCrtMsg == 1)
								puts("No messages.");
							break;
						}
						else if(hr == S_OK)
						{
							PInfo(nCrtMsg, msgInf);
						}
						else if(FAILED(hr))
							break;
					}
				}
				else if(!lstrcmpi(m_pActionCmd->szCmdKey, "DEL_MSG"))
				{
					MESSAGE_FILTER Filter;
                    DWORD cMsgs = 0;

					hr = SetMsgFilter(&Filter, m_pFilterCmd);
					if(SUCCEEDED(hr))
					{
						hr = ApplyActionToMessages(pQueue, &Filter, MA_DELETE_SILENT, &cMsgs);
						if(FAILED(hr))
							printf("Error: Link %d, Queue %d: pQueue->ApplyActionToMessages failed with 0x%x\n", nCrtLink, nCrtQueue, hr);
						else
							printf("Operation succeeded on %d messages\n", cMsgs);
					}

					FreeStruct(&Filter);
				}
			}
			if(NULL != pQueue)
			{
				pQueue->Release();
				pQueue = NULL;
			}
			if(NULL != pQueueEnum)
			{
				pQueueEnum->Release();
				pQueueEnum = NULL;
			}
		}
	
	}

Exit:
	FreeStruct(&linkInf);
	FreeStruct(&queueInf);
	FreeStruct(&msgInf);
	
	if(NULL != pLink)
	{
		pLink->Release();
		pLink = NULL;
	}
	if(NULL != pLinkEnum)
	{
		pLinkEnum->Release();
	}
    if(NULL != pMsgEnum)
    {
        pMsgEnum->Release();
    }
	return hr;
}



////////////////////////////////////////////////////////////////////////////
// Method:		PrintQueueInfo()
// Member of:	CAQAdminCli
// Arguments:	none
// Returns:		S_OK
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::PrintQueueInfo()
{
	HRESULT hr;
	int nCrtLink, nCrtQueue;

	IEnumVSAQLinks *pLinkEnum = NULL;
	IEnumLinkQueues *pQueueEnum = NULL;
    IVSAQLink *pLink = NULL;
	ILinkQueue *pQueue = NULL;
	
	LINK_INFO linkInf;
	QUEUE_INFO queueInf;
	ZeroMemory(&linkInf, sizeof(LINK_INFO));
	ZeroMemory(&queueInf, sizeof(QUEUE_INFO));
			
		
	hr = m_pVS->GetLinkEnum(&pLinkEnum);
	if(FAILED(hr)) 
	{
		printf("Error: GetLinkEnum failed with 0x%x\n", hr);
		goto Exit;
	}

	for(nCrtLink = 1; TRUE; nCrtLink++) 
	{
		if(NULL != pLink)
		{
			pLink->Release();
			pLink = NULL;
		}
		FreeStruct(&linkInf);
		hr = GetLink(pLinkEnum, &pLink, &linkInf);
		if(hr == S_FALSE)
		{
			if(nCrtLink == 1)
				puts("No links.");
			break;
		}
		else if(FAILED(hr))
		{
			break;
		}
		else if(hr == S_OK)
		{
			// check if we want queues for this link
			if(!IsContinue("ln", linkInf.szLinkName))
				continue;

			hr = pLink->GetQueueEnum(&pQueueEnum);
			if(FAILED(hr)) 
			{
				printf("Error: Link %d: pLink->GetQueueEnum failed with 0x%x\n", nCrtLink, hr);
				continue;
			}

            PrintQueueLinkInfo(pLink);
			printf("---- Queues for link %S ----\n", linkInf.szLinkName);
				
			for(nCrtQueue = 1; TRUE; nCrtQueue++) 
			{
				if(NULL != pQueue)
				{
					pQueue->Release();
					pQueue = NULL;
				}
				FreeStruct(&queueInf);
				hr = GetQueue(pQueueEnum, &pQueue, &queueInf);

				if(hr == S_FALSE)
				{
					if(nCrtQueue == 1)
						puts("No queues.");
					break;
				}
				else if(FAILED(hr))
				{
					break;
				}
				else if(hr == S_OK)
				{
					// check if we want this queue
					if(!IsContinue("qn", queueInf.szQueueName))
						continue;

                    PrintQueueLinkInfo(pQueue);
					if(!lstrcmpi(m_pActionCmd->szCmdKey, "QUEUE_INFO"))
						PInfo(nCrtQueue, queueInf);
					else if(!lstrcmpi(m_pActionCmd->szCmdKey, "MSGACTION"))
					{
						MESSAGE_ACTION Action;
						MESSAGE_FILTER Filter;
						char buf[64];
						ZeroMemory(buf, sizeof(buf));

						hr = SetMsgAction(&Action, m_pFilterCmd);
						if(FAILED(hr))
						{
							printf("Error: must specify a message action\n");
						}
						else
						{
							DWORD cMsgs = 0;
							// set the filter
							hr = SetMsgFilter(&Filter, m_pFilterCmd);
							if(SUCCEEDED(hr))
							{
								hr = ApplyActionToMessages(pQueue, &Filter, Action, &cMsgs);
								if(FAILED(hr))
								{
									printf("Link %S, Queue %S: pLink->ApplyActionToMessages failed with 0x%x\n", linkInf.szLinkName, queueInf.szQueueName, hr);
								}
								else
									printf("Link %S, Queue %S: pLink->ApplyActionToMessages succeeded on %d Messages\n", linkInf.szLinkName, queueInf.szQueueName, cMsgs);
							}
							FreeStruct(&Filter);
						}				
					}
				}
			}
			if(NULL != pQueueEnum)
			{
				pQueueEnum->Release();
				pQueueEnum = NULL;
			}
            if(NULL != pQueue)
			{
			    pQueue->Release();
				pQueue = NULL;
            }
		}
	
		if(NULL != pLink)
		{
			pLink->Release();
			pLink = NULL;
		}
	}

Exit:
	FreeStruct(&linkInf);
	FreeStruct(&queueInf);
	if(NULL != pLinkEnum)
	{
		pLinkEnum->Release();
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		PrintLinkInfo()
// Member of:	CAQAdminCli
// Arguments:	none
// Returns:		S_OK
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::PrintLinkInfo()
{
	HRESULT hr;
	IEnumVSAQLinks *pLinkEnum = NULL;
	int nCrt = 0;

	LINK_INFO linkInf;
	ZeroMemory(&linkInf, sizeof(LINK_INFO));
    
	hr = m_pVS->GetLinkEnum(&pLinkEnum);
	if(FAILED(hr)) 
	{
		printf("Error: GetLinkEnum failed with 0x%x\n", hr);
		goto Exit;
	}

	for(nCrt = 1; TRUE; nCrt++) 
	{
		IVSAQLink *pLink = NULL;
		FreeStruct(&linkInf);
		hr = GetLink(pLinkEnum, &pLink, &linkInf);

		if(hr == S_FALSE)
		{
			if(nCrt == 1)
				puts("No links.");
			break;
		}
		else if(FAILED(hr))
		{
			break;
		}
		else if(hr == S_OK)
		{
			// check if we want link info. for this link
			if(!IsContinue("ln", linkInf.szLinkName))
            {
			    pLink->Release();
                pLink = NULL;
				continue;
            }

			if(!lstrcmpi(m_pActionCmd->szCmdKey, "LINK_INFO"))
				PInfo(nCrt, linkInf);
			else if(!lstrcmpi(m_pActionCmd->szCmdKey, "FREEZE"))
			{
				hr = pLink->SetLinkState(LA_FREEZE);
				if(SUCCEEDED(hr))
					printf("Link %S was frozen\n", linkInf.szLinkName);
				else
					printf("Link %S: SetLinkState() failed with 0x%x\n", linkInf.szLinkName, hr);
			}
			else if(!lstrcmpi(m_pActionCmd->szCmdKey, "THAW"))
			{
				hr = pLink->SetLinkState(LA_THAW);
				if(SUCCEEDED(hr))
					printf("Link %S was un-frozen\n", linkInf.szLinkName);
				else
					printf("Link %S: SetLinkState() failed with 0x%x\n", linkInf.szLinkName, hr);
			}
			else if(!lstrcmpi(m_pActionCmd->szCmdKey, "KICK"))
			{
				hr = pLink->SetLinkState(LA_KICK);
				if(SUCCEEDED(hr))
					printf("Link %S was kicked\n", linkInf.szLinkName);
				else
					printf("Link %S: SetLinkState() failed with 0x%x\n", linkInf.szLinkName, hr);
			}
			else if(!lstrcmpi(m_pActionCmd->szCmdKey, "MSGACTION"))
			{
				MESSAGE_ACTION Action;
				MESSAGE_FILTER Filter;
				char buf[64];
				ZeroMemory(buf, sizeof(buf));

				hr = SetMsgAction(&Action, m_pFilterCmd);
				if(FAILED(hr))
				{
					printf("Error: must specify a message action\n");
				}
				else
				{
					DWORD cMsgs = 0;
					// set the filter
					hr = SetMsgFilter(&Filter, m_pFilterCmd);
					if(SUCCEEDED(hr))
					{
						hr = ApplyActionToMessages(pLink, &Filter, Action, &cMsgs);
						if(FAILED(hr))
						{
							printf("Link %S: pLink->ApplyActionToMessages failed with 0x%x\n", linkInf.szLinkName, hr);
						}
						else
							printf("Link %S: pLink->ApplyActionToMessages succeeded on %d Messages\n", linkInf.szLinkName, cMsgs);
					}
					FreeStruct(&Filter);
				}				
			}
		}
	
        if(NULL != pLink)
        {
			pLink->Release();
            pLink = NULL;
        }
	}
Exit:
	FreeStruct(&linkInf);
	if(NULL != pLinkEnum)
	{
		pLinkEnum->Release();
	}
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		PInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::PInfo(int nCrt, MESSAGE_INFO msgInf)
{
	// convert the UTC time to local time
	SYSTEMTIME stLocSubmit, stLocRecv, stLocExpire;
	BOOL res;
    CHAR szTimeSuffix[] = " UTC";
    LPWSTR wszCurrent = NULL;
   	SYSTEMTIME *pstSubmit = &msgInf.stSubmission;
	SYSTEMTIME *pstReceived = &msgInf.stReceived;
	SYSTEMTIME *pstExpire = &msgInf.stExpiry;

	res = SystemTimeToTzSpecificLocalTime(NULL, &msgInf.stSubmission, &stLocSubmit);
	res = res && SystemTimeToTzSpecificLocalTime(NULL, &msgInf.stReceived, &stLocRecv);
	res = res && SystemTimeToTzSpecificLocalTime(NULL, &msgInf.stExpiry, &stLocExpire);

	if(res)
    {
        //Use localized times 
		pstSubmit = &stLocSubmit;
		pstReceived = &stLocRecv;
		pstExpire = &stLocExpire;
        szTimeSuffix[1] = '\0'; //" \0TC"
    }

    printf("%d.Message ID: %S, Priority: %s %s, Version: %ld, Size: %ld\n"
           "  Flags 0x%08X\n"
           "  %ld EnvRecipients (%ld bytes): \n", 
			nCrt,
			msgInf.szMessageId, 
			msgInf.fMsgFlags & MP_HIGH ? "High" : (msgInf.fMsgFlags & MP_NORMAL ? "Normal" : "Low"),
            msgInf.fMsgFlags & MP_MSG_FROZEN ? "(frozen)" : "",
			msgInf.dwVersion,
			msgInf.cbMessageSize,
            msgInf.fMsgFlags,
            msgInf.cEnvRecipients,
            msgInf.cbEnvRecipients);

    //spit out recipients
    wszCurrent = msgInf.mszEnvRecipients;
    while (wszCurrent && *wszCurrent)
    {
        printf("\t%S\n", wszCurrent);
        while (*wszCurrent)
            wszCurrent++;
        wszCurrent++;
    }

    //print error if msgInf.mszEnvRecipients is malformed
    if ((1+wszCurrent-msgInf.mszEnvRecipients)*sizeof(WCHAR) != msgInf.cbEnvRecipients)
    {
        printf("\tERROR mszEnvRecipients malformatted (found %ld instead of %ld bytes)\n",
            (wszCurrent-msgInf.mszEnvRecipients)*sizeof(WCHAR),
            msgInf.cbEnvRecipients);
    }

    
    printf("  %ld Recipients: %S\n"
           "  %ld Cc recipients: %S\n"
           "  %ld Bcc recipients: %S\n"
           "  Sender: %S\n"
           "  Subject: %S\n"
           "  Submitted: %d/%d/%d at %d:%02d:%02d:%03d%s\n"
           "  Received:  %d/%d/%d at %d:%02d:%02d:%03d%s\n"
           "  Expires:   %d/%d/%d at %d:%02d:%02d:%03d%s\n"
           "  %ld Failed Delivery attempts\n",
			msgInf.cRecipients, 
			msgInf.szRecipients,
			msgInf.cCCRecipients,
			msgInf.szCCRecipients,
			msgInf.cBCCRecipients,
			msgInf.szBCCRecipients,
			msgInf.szSender,
			msgInf.szSubject,
			pstSubmit->wMonth,
			pstSubmit->wDay,
			pstSubmit->wYear,
			pstSubmit->wHour,
			pstSubmit->wMinute,
			pstSubmit->wSecond,
			pstSubmit->wMilliseconds,
            szTimeSuffix,
			pstReceived->wMonth,
			pstReceived->wDay,
			pstReceived->wYear,
			pstReceived->wHour,
			pstReceived->wMinute,
			pstReceived->wSecond,
			pstReceived->wMilliseconds,
            szTimeSuffix,
			pstExpire->wMonth,
			pstExpire->wDay,
			pstExpire->wYear,
			pstExpire->wHour,
			pstExpire->wMinute,
			pstExpire->wSecond,
			pstExpire->wMilliseconds,
            szTimeSuffix,
            msgInf.cFailures);
}

////////////////////////////////////////////////////////////////////////////
// Method:		PInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::PInfo(int nCrt, QUEUE_INFO queueInf)
{
	printf(	"%d.Name: %S, Version: %ld, No. of messages: %ld\n"
			"  Link name: %S, Volume: %ld\n",
			nCrt,
			queueInf.szQueueName, 
			queueInf.dwVersion, 
			queueInf.cMessages, 
			queueInf.szLinkName,
			queueInf.cbQueueVolume);
}

////////////////////////////////////////////////////////////////////////////
// Method:		PInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::PInfo(int nCrt, LINK_INFO linkInf)
{
	// convert the UTC time to local time
	SYSTEMTIME stLocNextConn, stLocOldest;
	BOOL res;
	char *pszFormat, *pszState;
	SYSTEMTIME *pstNext, *pstOld;
    char szSupportedLinkActions[50] = "";

    if (linkInf.fStateFlags & LI_ACTIVE )
		pszState = "Active";
    else if (linkInf.fStateFlags & LI_READY)
		pszState = "Ready";
	else if (linkInf.fStateFlags & LI_RETRY)
		pszState = "Retry";
	else if (linkInf.fStateFlags & LI_SCHEDULED)
		pszState = "Scheduled";
	else if (linkInf.fStateFlags & LI_REMOTE)
		pszState = "Remote";
	else if (linkInf.fStateFlags & LI_FROZEN)
		pszState = "Frozen";
	else
		pszState = "Unknown";

    if (linkInf.dwSupportedLinkActions & LA_FREEZE)
        strcpy(szSupportedLinkActions, "Freeze");
    if (linkInf.dwSupportedLinkActions & LA_THAW)
        strcat(szSupportedLinkActions, " Thaw");
    if (linkInf.dwSupportedLinkActions & LA_KICK)
        strcat(szSupportedLinkActions, " Kick");

    if (!szSupportedLinkActions[0])
        strcpy(szSupportedLinkActions, "Link can only be viewed.");

	res = SystemTimeToTzSpecificLocalTime(NULL, &linkInf.stNextScheduledConnection, &stLocNextConn);
	res = res && SystemTimeToTzSpecificLocalTime(NULL, &linkInf.stOldestMessage, &stLocOldest);

	if(res)
	{
		pszFormat = "%d.Name: %S, Version: %ld\n"
					"  No. of messages: %ld, State: %s [0x%08X], Volume: %ld\n"
					"  Next scheduled connection: %d/%d/%d at %d:%02d:%02d:%03d\n"
					"  Oldest message: %d/%d/%d at %d:%02d:%02d:%03d\n"
                    "  Supported Link Actions: %s\n"
                    "  Link Diagnostic: %S\n";
		pstNext = &stLocNextConn;
		pstOld = &stLocOldest;
	}
	else
	{
		pszFormat = "%d.Name: %S, Version: %ld\n"
					"  No. of messages: %ld, State: %s [0x%08X], Volume: %ld\n"
					"  Next scheduled connection: %d/%d/%d at %d:%02d:%02d:%03d UTC\n"
					"  Oldest message: %d/%d/%d at %d:%02d:%02d:%03d UTC\n"
                    "  Supported Link Actions: %s\n"
                    "  Link Diagnostic: %S\n";
		pstNext = &linkInf.stNextScheduledConnection;
		pstOld = &linkInf.stOldestMessage;
	}
	
	printf(pszFormat, 
			nCrt,
			linkInf.szLinkName, 
			linkInf.dwVersion, 
			linkInf.cMessages, 
			pszState,
            linkInf.fStateFlags,
			linkInf.cbLinkVolume.LowPart,
			pstNext->wMonth,
			pstNext->wDay,
			pstNext->wYear,
			pstNext->wHour,
			pstNext->wMinute,
			pstNext->wSecond,
			pstNext->wMilliseconds,
			pstOld->wMonth,
			pstOld->wDay,
			pstOld->wYear,
			pstOld->wHour,
			pstOld->wMinute,
			pstOld->wSecond,
			pstOld->wMilliseconds,
            szSupportedLinkActions,
            linkInf.szExtendedStateInfo);
}


////////////////////////////////////////////////////////////////////////////
// Method:		GetMsg()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::GetMsg(IN IAQEnumMessages *pMsgEnum, OUT IAQMessage **ppMsg, IN OUT MESSAGE_INFO *pMsgInf)
{
	HRESULT hr;
	DWORD cFetched;

	hr = pMsgEnum->Next(1, ppMsg, &cFetched);
	if(hr == S_FALSE)
	{
		goto Exit;
	}
	else if(FAILED(hr)) 
	{
		printf("pMsgEnum->Next failed with 0x%x\n", hr);
		goto Exit;
	}
	else if(NULL == (*ppMsg))
	{
		printf("pMsg is NULL.\n", hr);
		goto Exit;
	}
	else
	{
		ZeroMemory(pMsgInf, sizeof(MESSAGE_INFO));
        pMsgInf->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
		hr = (*ppMsg)->GetInfo(pMsgInf);
		if(FAILED(hr))
		{
			printf("pMsg->GetInfo failed with 0x%x\n", hr);
			goto Exit;
		}
	}

Exit:
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Method:		GetQueue()
// Member of:	CAQAdminCli
// Arguments:	
// Returns:		S_FALSE - no more links
//				S_OK - success
// Description:	Caller must allocate pQueueInf
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::GetQueue(IN IEnumLinkQueues *pQueueEnum, OUT ILinkQueue **ppQueue, IN OUT QUEUE_INFO *pQueueInf)
{
	HRESULT hr;
	DWORD cFetched;

    if (NULL == pQueueEnum)
         return S_FALSE;

	hr = pQueueEnum->Next(1, ppQueue, &cFetched);
	if(hr == S_FALSE)
	{
		goto Exit;
	}
	else if(FAILED(hr)) 
	{
		printf("pQueueEnum->Next failed with 0x%x\n", hr);
		goto Exit;
	}
	else if(NULL == (*ppQueue))
	{
		printf("pQueue is NULL.\n", hr);
		goto Exit;
	}
	else
	{
		ZeroMemory(pQueueInf, sizeof(QUEUE_INFO));
        pQueueInf->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
		hr = (*ppQueue)->GetInfo(pQueueInf);
		if(FAILED(hr))
		{
			printf("pQueue->GetInfo failed with 0x%x\n", hr);
			goto Exit;
		}
	}

Exit:
	return hr;
}



////////////////////////////////////////////////////////////////////////////
// Method:		GetLink()
// Member of:	CAQAdminCli
// Arguments:	
// Returns:		S_FALSE - no more links
//				S_OK - success
// Description:	Caller must allocate pLinkInf
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::GetLink(IN IEnumVSAQLinks *pLinkEnum, OUT IVSAQLink **ppLink, IN OUT LINK_INFO *pLinkInf)
{
	HRESULT hr;
	DWORD cFetched;

	hr = pLinkEnum->Next(1, ppLink, &cFetched);
	if(hr == S_FALSE)
	{
		goto Exit;
	}
	else if(FAILED(hr)) 
	{
		printf("pLinkEnum->Next failed with 0x%x\n", hr);
		goto Exit;
	}
	else if(NULL == (*ppLink))
	{
		printf("pLink is NULL.\n", hr);
		goto Exit;
	}
	else
	{
		ZeroMemory(pLinkInf, sizeof(LINK_INFO));
        pLinkInf->dwVersion = CURRENT_QUEUE_ADMIN_VERSION;
		hr = (*ppLink)->GetInfo(pLinkInf);
		if(FAILED(hr))
		{
			printf("pLink->GetInfo failed with 0x%x\n", hr);
            if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr)
                printf("RPC Server Unavailable.\n");
            else if ( hr == E_POINTER )
                printf("Null pointer.\n");
            else if ( hr == E_OUTOFMEMORY )
                printf("Out of memory.\n");
            else if ( hr == E_INVALIDARG )
                printf("Invalid argument.\n");
            else
                printf("Unknown error.\n");
			goto Exit;
		}
	}

Exit:
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Method:		~CAQAdminCli()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
CAQAdminCli::~CAQAdminCli()
{
	if(NULL != m_pFilterCmd)
		delete (CCmdInfo*) m_pFilterCmd;
	if(NULL != m_pActionCmd)
		delete (CCmdInfo*) m_pActionCmd;
}

////////////////////////////////////////////////////////////////////////////
// Method:		Cleanup()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::Cleanup()
{
    if(m_pAdmin) 
		m_pAdmin->Release();
	if(m_pVS) 
		m_pVS->Release();
}

////////////////////////////////////////////////////////////////////////////
// Method:		CAQAdminCli()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
CAQAdminCli::CAQAdminCli()
{
	m_pAdmin = NULL; 
	m_pVS = NULL;
	m_dwDispFlags = (DispFlags) (DF_LINK | DF_QUEUE | DF_MSG);
	m_pFilterCmd = NULL;
	m_pActionCmd = NULL;
	m_fUseMTA = FALSE;
}

////////////////////////////////////////////////////////////////////////////
// Method:		StopAllLinks()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::StopAllLinks()
{
	HRESULT hr;

	hr = m_pVS->StopAllLinks();
	if(FAILED(hr))
	{
		printf("m_pAdmin->StopAllLinks failed with 0x%x\n", hr);
	}
	else
		printf("StopAllLinks succeeded\n", hr);

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		StartAllLinks()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::StartAllLinks()
{
	HRESULT hr;

	hr = m_pVS->StartAllLinks();
	if(FAILED(hr))
	{
		printf("StartAllLinks failed with 0x%x\n", hr);
	}
	else
		printf("StartAllLinks succeeded\n", hr);

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Method:		GetGlobalLinkState()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::GetGlobalLinkState()
{
	HRESULT hr;

	hr = m_pVS->GetGlobalLinkState();
	if(FAILED(hr))
	{
		printf("GetGlobalLinkState failed with 0x%x\n", hr);
	}
	else if (S_OK == hr)
    {
		printf("Links UP\n");
    }
    else
    {
		printf("Links STOPPED by admin\n");
    }

	return hr;
}

HRESULT CAQAdminCli::MessageAction(MESSAGE_FILTER *pFilter, MESSAGE_ACTION action)
{
	HRESULT hr = S_OK;
    DWORD   cMsgs = 0;

	hr = ApplyActionToMessages(m_pVS, pFilter, action, &cMsgs);
	if(FAILED(hr))
	{
		printf("m_pAdmin->ApplyActionToMessages failed with 0x%x\n", hr);
	}
	else
		printf("ApplyActionToMessages succeeded on %d Messages\n", cMsgs);

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		Help()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
void CAQAdminCli::Help()
{
	puts(	"\n   Commands:\n"
			"====================\n"
			"setserver [sn] [,vs=VSnumber] - sets the server to administer. Default is localhost,\n"
			"                                first virtual server\n"
			"linkinfo [ln,ln,...]          - prints link information for specified links or\n"
			"                                for all links (no arguments)\n"
			"queueinfo [ln,ln,...]         - prints queue information for specified links or\n"
			"                                for all links (no arguments)\n"
			"msginfo [qn,qn,...,] eflt     - prints message information for specified queues or\n"
			"                                for all queues (no 'qn' arguments)\n"
			"delmsg [qn,qn,...,] flt       - deletes messages from specified queues or\n"
			"                                from all queues (no 'qn' arguments)\n"
			"msgaction mac, flt            - applies msg. action to specified messages\n"
			"linkaction ln [,ln,...], lac  - applies link action to specified links\n"
			"  [, mac, flt]                  if action is \"MSGACTION\", must specify mac and flt\n"
			"queueaction qn [,qn,...], qac - applies queue action to specified queues\n"
			"  [, mac, flt]                  if action is \"MSGACTION\", must specify mac and flt\n"
			"stopalllinks                  - stops all the links\n"
			"startalllinks                 - starts all the links\n"
			"checklinks                    - checks the global status of the links\n"
			"freezelink ln [,ln,...]       - freezes the specified links\n"
			"meltlink ln [,ln,...]         - un-freezes the specified links\n"
			"kicklink ln [,ln,...]         - kicks (forces a connect) for the specified links\n"
			"useMTA                        - uses the MTA AQ administrator\n"
			"useSMTP                       - uses the SMTP AQ administrator\n"
			"?, help                       - this help\n"
			"quit                          - exits the program\n"
			"!cmd                          - executes shell command 'cmd'\n"
			"\nwhere\n\n"
			"ln = link name\n"
			"qn = queue name\n"
			"sn = server name\n"
			"mac = \"ma=<action>\" message action. Actions are: \"DEL\"|\"DEL_S\"|\"FREEZE\"|\"THAW\"|\"COUNT\"\n"
			"lac = \"la=<action>\" link action. Actions: \"KICK\"|\"FREEZE\"|\"THAW\"|\"MSGACTION\"\n"
			"qac = \"qa=<action>\" queue action. Actions: \"MSGACTION\"\n"
			"eflt = \"token,token,...\" msg. enum. filter. Following tokens are suported:\n"
			"  \"ft=<flags>\" Flags are: \"FIRST_N\"|\"OLDER\"|\"OLDEST\"|\"LARGER\"|\"LARGEST\"|\"NOT\"|\"SENDER\"|\"RCPT\"|\"ALL\"\n"
			"       (filter type. Flags can be or'ed)\n"
			"  \"mn=<number>\" (number of messages)\n"
			"  \"ms=<number>\" (message size)\n"
			"  \"md=<date>\" (message date mm/dd/yy hh:mm:ss:mil [UTC])\n"
			"  \"sk=<number>\" (skip messages)\n"
			"  \"msndr=<string>\" (message sender)\n"
			"  \"mrcpt=<string>\" (message recipient)\n"
			"flt = \"token,token,...\" msg. filter. Following tokens are suported:\n"
			"  \"flags=<flags>\" Flags are: \"MSGID\"|\"SENDER\"|\"RCPT\"|\"SIZE\"|\"TIME\"|\"FROZEN\"|\"NOT\"|\"ALL\"\n"
			"       (filter flags. Flags can be or'ed)\n"
			"  \"id=<string>\" (message id as shown by msginfo)\n"
			"  \"sender=<string>\" (the sender of the message)\n"
			"  \"rcpt=<string>\" (the recipient of the message)\n"
			"  \"size=<number>\" (the minimum message size)\n"
			"  \"date=<date>\" (oldest message date mm/dd/yy hh:mm:ss:mil [UTC])\n"
		);
}

////////////////////////////////////////////////////////////////////////////
// Method:		Init()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::Init()
{
	HRESULT hr;

	hr = CoCreateInstance(CLSID_AQAdmin, 
                          NULL, 
                          CLSCTX_INPROC_SERVER,
                          IID_IAQAdmin, 
                          (void **) &m_pAdmin);
    if(FAILED(hr)) 
	{
        printf("CoCreateInstance failed with 0x%x\n", hr);
        goto Exit;
    }

	hr = m_pAdmin->GetVirtualServerAdminITF(NULL, L"1", &m_pVS);
	if(FAILED(hr)) 
	{
        printf("GetVirtualServerAdminITF failed with 0x%x\n", hr);
        goto Exit;
    }
Exit:
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		Init()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CAQAdminCli::UseMTA(BOOL fUseMTA)
{
	HRESULT hr;
	IAQAdmin *pAdminTmp = NULL;

	// don't release the old one unless you can create the new one.
	if(fUseMTA)
		hr = CoCreateInstance(CLSID_MAQAdmin, 
							  NULL, 
							  CLSCTX_INPROC_SERVER,
							  IID_IAQAdmin, 
							  (void **) &pAdminTmp);
	else
		hr = CoCreateInstance(CLSID_AQAdmin, 
							  NULL, 
							  CLSCTX_INPROC_SERVER,
							  IID_IAQAdmin, 
							  (void **) &pAdminTmp);
    
    if(FAILED(hr)) 
	{
        printf("CoCreateInstance failed with 0x%x\n", hr);
        goto Exit;
    }
	else
	{
		if(NULL != m_pAdmin)
		{
			m_pAdmin->Release();
			m_pAdmin = NULL;
		}

		m_pAdmin = pAdminTmp;
		m_fUseMTA = fUseMTA;

		printf("AQ Admin is %s.\n", fUseMTA ? "MTA" : "SMTP");
	}

	hr = m_pAdmin->GetVirtualServerAdminITF(NULL, L"1", &m_pVS);
	if(FAILED(hr)) 
	{
        printf("GetVirtualServerAdminITF failed with 0x%x\n", hr);
        goto Exit;
    }
Exit:
	return hr;
}

HRESULT ExecuteCmd(CAQAdminCli& Admcli, LPSTR szCmd)
{
	HRESULT hr = S_OK;
	BOOL fQuit = FALSE;

    // see if it's a system command
	if(szCmd[0] == '!')
	{
		system(szCmd + 1);
		goto Exit;
	}

	Admcli.m_pFilterCmd = new CCmdInfo(szCmd);
	if(NULL == Admcli.m_pFilterCmd)
	{
		printf("Cannot allocate command info.\n");
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "quit"))
	{
		fQuit = TRUE;
		goto Exit;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "freezelink"))
	{
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("ln", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one link name\n");
		}
		else
		{
			Admcli.m_pActionCmd = new CCmdInfo("FREEZE");
			Admcli.PrintLinkInfo();
			delete (CCmdInfo*) Admcli.m_pActionCmd;
			Admcli.m_pActionCmd = NULL;
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "meltlink"))
	{
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("ln", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one link name\n");
		}
		else
		{
			Admcli.m_pActionCmd = new CCmdInfo("THAW");
			Admcli.PrintLinkInfo();
			delete (CCmdInfo*) Admcli.m_pActionCmd;
			Admcli.m_pActionCmd = NULL;
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "kicklink"))
	{
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("ln", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one link name\n");
		}
		else
		{
			Admcli.m_pActionCmd = new CCmdInfo("KICK");
			Admcli.PrintLinkInfo();
			delete (CCmdInfo*) Admcli.m_pActionCmd;
			Admcli.m_pActionCmd = NULL;
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "linkaction"))
	{
		char buf[64];

		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("ln", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one link name\n");
		}
		else
		{
			// check there's an action
			hr = Admcli.m_pFilterCmd->GetValue("la", buf);
			if(FAILED(hr))
			{
				printf("Error: must have a link action\n");
			}
			else
			{
				Admcli.m_pActionCmd = new CCmdInfo(buf);
				Admcli.PrintLinkInfo();
				delete (CCmdInfo*) Admcli.m_pActionCmd;
				Admcli.m_pActionCmd = NULL;
			}
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "queueaction"))
	{
		char buf[64];

		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("qn");
		// check there's at least one link name
		hr = Admcli.m_pFilterCmd->GetValue("qn", NULL);
		if(FAILED(hr))
		{
			printf("Error: must have at least one queue name\n");
		}
		else
		{
			// check there's an action
			hr = Admcli.m_pFilterCmd->GetValue("qa", buf);
			if(FAILED(hr))
			{
				printf("Error: must have a queue action\n");
			}
			else
			{
				Admcli.m_pActionCmd = new CCmdInfo(buf);
				Admcli.PrintQueueInfo();
				delete (CCmdInfo*) Admcli.m_pActionCmd;
				Admcli.m_pActionCmd = NULL;
			}
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "linkinfo"))
	{
		//Admcli.m_dwDispFlags = CAQAdminCli::DF_LINK;
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		Admcli.m_pActionCmd = new CCmdInfo("LINK_INFO");
		Admcli.PrintLinkInfo();
		delete (CCmdInfo*) Admcli.m_pActionCmd;
		Admcli.m_pActionCmd = NULL;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "queueinfo"))
	{
		//Admcli.m_dwDispFlags = CAQAdminCli::DF_QUEUE;
		// set default tag to 'ln'
		Admcli.m_pFilterCmd->SetDefTag("ln");
		Admcli.m_pActionCmd = new CCmdInfo("QUEUE_INFO");
		Admcli.PrintQueueInfo();
		delete (CCmdInfo*) Admcli.m_pActionCmd;
		Admcli.m_pActionCmd = NULL;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "msginfo"))
	{
		//Admcli.m_dwDispFlags = CAQAdminCli::DF_MSG;
		//Admcli.GetLinkInfo();	
		// set default tag to 'qn'
		Admcli.m_pFilterCmd->SetDefTag("qn");
		Admcli.m_pActionCmd = new CCmdInfo("MSG_INFO");
		Admcli.PrintMsgInfo();			
		delete (CCmdInfo*) Admcli.m_pActionCmd;
		Admcli.m_pActionCmd = NULL;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "delmsg"))
	{
		// set default tag to 'qn'
		Admcli.m_pFilterCmd->SetDefTag("qn");
		Admcli.m_pActionCmd = new CCmdInfo("DEL_MSG");
		Admcli.PrintMsgInfo();			
		delete (CCmdInfo*) Admcli.m_pActionCmd;
		Admcli.m_pActionCmd = NULL;
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "useMTA"))
	{
		Admcli.UseMTA(TRUE);
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "useSMTP"))
	{
		Admcli.UseMTA(FALSE);
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "msgaction"))
	{
		MESSAGE_ACTION Action;
		MESSAGE_FILTER Filter;
		char buf[64];
		BOOL fActOK = TRUE;
		ZeroMemory(buf, sizeof(buf));

		// set default tag to 'ma'
		Admcli.m_pFilterCmd->SetDefTag("ma");
		Admcli.m_pFilterCmd->GetValue("ma", buf);

		// set the action
		hr = Admcli.SetMsgAction(&Action, Admcli.m_pFilterCmd);
		if(FAILED(hr))
		{
			printf("Error: must specify an action\n");
			fActOK = FALSE;
		}

		if(fActOK)
		{
			// set the filter
			hr = Admcli.SetMsgFilter(&Filter, Admcli.m_pFilterCmd);
			if(SUCCEEDED(hr))
			{
				Admcli.MessageAction(&Filter, Action);
			}
			Admcli.FreeStruct(&Filter);
		}
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "stopalllinks"))
	{
		Admcli.StopAllLinks();			
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "startalllinks"))
	{
		Admcli.StartAllLinks();			
	}
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "setserver"))
	{
		char buf[MAX_SERVER_NAME];
		char vsn[32];
		char *pServer = NULL;
		Admcli.m_pFilterCmd->SetDefTag("sn");
		hr = Admcli.m_pFilterCmd->GetValue("sn", buf);
		if(FAILED(hr))
			pServer = NULL;			
		else
			pServer = (LPSTR)buf;

		hr = Admcli.m_pFilterCmd->GetValue("vs", vsn);
		if(FAILED(hr))
			lstrcpy(vsn, "1");			
		
		hr = Admcli.SetServer(pServer, (LPSTR)vsn);			
		if(FAILED(hr))
			printf("setserver failed. Using the old server.\n");
		else
			printf("setserver succeeded.\n");
	}
    else if (!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "checklinks"))
    {
        Admcli.GetGlobalLinkState();
    }
	else if(!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "?") || 
			!lstrcmpi(Admcli.m_pFilterCmd->szCmdKey, "help"))
	{
		Admcli.Help();			
	}
	else
	{
		puts("Unknown command. Type '?' for on-line help");
	}
	
	if(Admcli.m_pFilterCmd)
	{
		delete Admcli.m_pFilterCmd;
		Admcli.m_pFilterCmd = NULL;
	}

Exit:
	// S_FALSE means "quit" for the main command loop. Return S_OK 
	// (or error) unless fQuit is true
	if(fQuit)
		return S_FALSE;
	else if(S_FALSE == hr)
		return S_OK;
	else
		return hr;
}

int __cdecl main(int argc, char **argv) 
{
    HRESULT hr;
	char szCmd[4096];
	char szCmdTmp[MAX_CMD_LEN];
	
	CAQAdminCli Admcli;
	
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if(FAILED(hr)) 
	{
        printf("CoInitializeEx failed w/ 0x%x\n", hr);
        return hr;
    }

	hr = Admcli.Init();
    if(FAILED(hr)) 
	{
        goto Exit;
    }

	// check if we have cmd line commands
	if(argc > 1)
	{
		for(int i = 1; i < argc; i++)
		{
			if(!lstrcmpi(argv[i], "-?") || !lstrcmpi(argv[i], "/?"))
			{
				Admcli.Help();
				goto Exit;
			}
			else
			{
				// this is a command
				ZeroMemory(szCmd, sizeof(szCmd));
					
				if(argv[i][0] == '\"' && argv[i][lstrlen(argv[i])-1] == '\"')
				{
					// strip quotes
					CopyMemory(szCmd, argv[i]+1, lstrlen(argv[i])-2);
				}
				else
					CopyMemory(szCmd, argv[i], lstrlen(argv[i]));

				ExecuteCmd(Admcli, szCmd);
			}
		}

		goto Exit;
	}

	puts("\nAQ administrator tool v 1.0\nType '?' or 'help' for list of commands.\n");
	while(TRUE)
	{
		char *cmd = NULL;
		printf(">");
		
		ZeroMemory(szCmd, sizeof(szCmd));
		if(!Admcli.m_fUseMTA)
		{
			szCmd[0] = 127;
			cmd = _cgets(szCmd);
		}
		else
		{
			// read line by line until CRLF.CRLF
			do
			{
				ZeroMemory(szCmdTmp, sizeof(szCmdTmp));
				szCmdTmp[0] = 127;
				cmd = _cgets(szCmdTmp);
				if(!lstrcmp(cmd, "."))
					break;
				lstrcat(szCmd, cmd);
			}
			while(TRUE);
			
			cmd = szCmd;
		}
		
		hr = ExecuteCmd(Admcli, cmd);
		if(S_FALSE == hr)
			break;
	}
 
Exit:
	Admcli.Cleanup();
    CoUninitialize();

    return hr;
}

#include "aqadmin.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\stdinc.h ===
//-----------------------------------------------------------------------------
//
//
//  File: stdinc.h
//
//  Description: Precompiled header file
//
//  Author: Mike Swafford (MikeSwa)
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <ole2.h>
#include "aqadmin.h"
#include "aqadmtyp.h"
#include <conio.h>
#include <stdlib.h>
#include "util.h"
#include "aqadmcli.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\util.cpp ===
// Sink.cpp : Implementation of CRoutingSinkApp and DLL registration.

#include "stdinc.h"

////////////////////////////////////////////////////////////////////////////
// Method:		CCmdInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
CCmdInfo::CCmdInfo(LPSTR szCmd)
{
	nArgNo = 0; 
	pArgs = NULL;
	ZeroMemory(szDefTag, sizeof(szDefTag));
	ZeroMemory(szCmdKey, sizeof(szCmdKey));
	ParseLine(szCmd, this);
}

////////////////////////////////////////////////////////////////////////////
// Method:		~CCmdInfo()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
CCmdInfo::~CCmdInfo()
{
	while(NULL != pArgs) 
	{
		CArgList *tmp = pArgs->pNext;
		delete pArgs;
		pArgs = tmp;
	}
}


void CCmdInfo::SetDefTag(LPSTR szTag)
{
	if(szTag && szTag[0])
		lstrcpy(szDefTag, szTag);

	for(CArgList *p = pArgs; NULL != p; p = p->pNext)
	{
		// set the tag to the default value if not already set
		if(p->szTag[0] == 0 && szDefTag[0] != 0)
			lstrcpy(p->szTag, szDefTag);
	}
}

////////////////////////////////////////////////////////////////////////////
// Method:		GetValue()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CCmdInfo::GetValue(LPSTR szTag, LPSTR szVal)
{
	HRESULT hr = E_FAIL;

	if(NULL != szTag)
	{
		// set the search parameters
		pSearchPos = pArgs;
		lstrcpy(szSearchTag, szTag);
	}

	for(CArgList *p = pSearchPos; NULL != p; p = p->pNext)
	{
		if(!lstrcmpi(p->szTag, szSearchTag))
		{
			if(NULL != szVal)
				lstrcpy(szVal, p->szVal);
			hr = S_OK;
			pSearchPos = p->pNext;
			break;
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		GetValue()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CCmdInfo::AllocValue(LPSTR szTag, LPSTR* pszVal)
{
	HRESULT hr = E_FAIL;

	if(NULL != szTag)
	{
		// set the search parameters
		pSearchPos = pArgs;
		lstrcpy(szSearchTag, szTag);
	}

	for(CArgList *p = pSearchPos; NULL != p; p = p->pNext)
	{
		if(!lstrcmpi(p->szTag, szSearchTag))
		{
			if(NULL != (*pszVal))
				delete [] (*pszVal);

			(*pszVal) = new char[lstrlen(p->szVal) + 1];
			if(NULL == (*pszVal))
			{
				hr = E_OUTOFMEMORY;
			}
			else
			{
				lstrcpy((*pszVal), p->szVal);
				hr = S_OK;
				pSearchPos = p->pNext;
			}
			break;
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Method:		ParseLine()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CCmdInfo::ParseLine(LPSTR szCmd, CCmdInfo *pCmd)
{
	HRESULT hr = E_FAIL;

	// quick hack for keeping info on quoted strings
	unsigned nQStart[64];
	unsigned nQEnd[64];
	unsigned nQIdx = 0;
	BOOL fInQ = FALSE;
	unsigned nFirstEqualPos = 0;
	char *s, *token;

	ZeroMemory(&nQStart, sizeof(nQStart));
	ZeroMemory(&nQEnd, sizeof(nQEnd));

	// find out where the arguments begin
	for(s = szCmd; !isspace(*s); s++);
	
	int nPref = (int) (s - szCmd);
	// scan the buffer for quoted strings
	for(s = szCmd; *s; s++)
	{
		if(*s == '"')
		{
			if(fInQ)
			{
				nQEnd[nQIdx++] = (unsigned) (s - szCmd - nPref);
				fInQ = FALSE;
			}
			else
			{
				nQStart[nQIdx] = (unsigned) (s - szCmd - nPref);
				fInQ = TRUE;
			}
		}
	}

	// get the position of the first equal sign
	s = strchr(szCmd, '=');
	nFirstEqualPos = (unsigned) (s - szCmd - nPref);
	
	// get the command code
	token = strtok(szCmd, " ");
	if(NULL == token)
	{	
		pCmd->szCmdKey[0] = 0;
		goto Exit;
	}
	else
		lstrcpy(pCmd->szCmdKey, token);

	// we have a partial command. return S_OK
	hr = S_OK;

	// build the argument list
	do
	{
		char *en, *mid;
		char buf[1024];
		ZeroMemory(buf, sizeof(buf));
		char *token = NULL;
		BOOL fInQ;

		do
		{
			fInQ = FALSE;
			token = strtok(NULL, ",");
	
			if(NULL == token)
				break;

			lstrcat(buf, token);

			// if ',' is in a quoted string concatenate to buf and continue
			for(unsigned i = 0; i < nQIdx; i++)
			{
				unsigned nAux = (unsigned) (token - szCmd + lstrlen(token) - nPref);
				if(nAux > nQStart[i] &&  nAux < nQEnd[i])
				{
					lstrcat(buf, ",");
					fInQ = TRUE; 
					break;
				}
			}
		}
		while(fInQ);

		
		if(buf[0] == '\0')
			break;
		else
			token = (LPSTR)buf;

		// strip spaces
		for(; isspace(*token); token++);
		
		// check if there's anything left
		if(!(*token))
			continue;

		for(en = token; *en; en++);
		for(--en; isspace(*en); en--);
		// check if there's anything left
		if(token > en)
			continue;

		// allocate a pair object
		CCmdInfo::CArgList *tmp = new CCmdInfo::CArgList;
		if(NULL == tmp)
		{
			hr = E_OUTOFMEMORY;
			goto Exit;
		}

		// insert into list
		tmp->pNext = pCmd->pArgs;
		pCmd->pArgs = tmp;

		// set the no. of pairs
		pCmd->nArgNo++;
				
		// set the values
		// if first '=' is in quoted string, treat whole expression as
		// untagged value.
		fInQ = FALSE;
		for(unsigned i = 0; i < nQIdx; i++)
		{
			if(nFirstEqualPos > nQStart[i] &&  nFirstEqualPos < nQEnd[i])
			{
				fInQ = TRUE;
				break;
			}
		}

		mid = fInQ ? NULL : strchr(token, '=');
		
		if(NULL == mid)
		{
			// this is not a pair. Treating as un-named value.
			// remove the quotes around the value
			if(token[0] == '"' && token[en - token] == '"')
			{
				token++;
				en--;
			}
			tmp->SetVal(token, (unsigned) (en - token + 1));
		}
		else
		{
			// set the tag
			for(char *t = mid - 1; isspace(*t); t--);
			// check if we have a tag (might be something like "..., = value"
			if(t - token + 1 > 0)
				CopyMemory(tmp->szTag, token, t - token + 1);

			// set the value
			for(t = mid + 1; isspace(*t) && t < en; t++);
			
			// remove the quotes around the value
			if(t[0] == '"' && t[en - t] == '"')
			{
				t++;
				en--;
			}
			tmp->SetVal(t, (unsigned) (en - t + 1));
		}

	}while(TRUE);
	

Exit:
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Method:		StringToHRES()
// Member of:	
// Arguments:	
// Returns:		
// Description:	
////////////////////////////////////////////////////////////////////////////
HRESULT CCmdInfo::StringToHRES(LPSTR szVal, HRESULT *phrRes)
{
	HRESULT hr = S_OK;

	if(isdigit(*szVal))
	{
		DWORD hr;
		int n;

		if(*szVal == '0' && tolower(*(szVal+1)) == 'x' && isxdigit(*(szVal+2)))
			// read as hex number
			n = sscanf(szVal+2, "%lx", &hr);
		else
			// read as dec number
			n = sscanf(szVal, "%lu", &hr);

		if(n == 1)
			(*phrRes) = (HRESULT)hr;
	}
	else if(isalpha(*szVal))
	{
		// see if this a HRESULT code
		if(!lstrcmp(szVal, "S_OK"))					(*phrRes) = S_OK;
		else if(!lstrcmp(szVal, "S_FALSE"))			(*phrRes) = S_FALSE;
		else if(!lstrcmp(szVal, "E_FAIL"))			(*phrRes) = E_FAIL;
		else if(!lstrcmp(szVal, "E_OUTOFMEMORY"))	(*phrRes) = E_OUTOFMEMORY;
		else
			hr = S_FALSE;
	}
	else
		hr = S_FALSE;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqadmin\utest\aqadmcli\util.h ===
#ifndef __CMD_INFO__
#define __CMD_INFO__

// defines the argument list for a command
class CCmdInfo 
{
public:
	// defines a "TAG = value" pair
	struct CArgList
	{
		char szTag[64];
		char *szVal;
		CArgList *pNext;

		CArgList() 
		{
			pNext = NULL; 
			szVal = NULL;
			//ZeroMemory(szVal, sizeof(szVal));
			ZeroMemory(szTag, sizeof(szTag));
		};

		LPSTR SetVal(LPSTR pszSrc, unsigned nSize)
		{
			if(NULL != szVal)
				delete [] szVal;

			szVal = new char[nSize + 1];
			if(NULL != szVal)
			{
				CopyMemory(szVal, pszSrc, nSize);
				szVal[nSize] = 0;
			}

			return szVal;
		}

		~CArgList()
		{
			if(NULL != szVal)
				delete [] szVal;
		}
	};

	int nArgNo;
	CArgList *pArgs;
	char szCmdKey[64];
	char szDefTag[64];
	
	CArgList *pSearchPos;
	char szSearchTag[64];
	
	CCmdInfo(LPSTR szCmd);
	~CCmdInfo();
public:
	void SetDefTag(LPSTR szTag);
	HRESULT GetValue(LPSTR szTag, LPSTR szVal);
	HRESULT AllocValue(LPSTR szTag, LPSTR* szVal);
private:
	HRESULT ParseLine(LPSTR szCmd, CCmdInfo *pCmd);
	HRESULT StringToHRES(LPSTR szVal, HRESULT *phrRes);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\aqdumps.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdumps.cpp
//
//  Description:  Definitions of AQ structure dumps for use with ptdbgext.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_

//baseobj.h is inlcluded
#define _WINSOCKAPI_

#include <atq.h>

#ifdef PLATINUM
#include "phatqdbg.h"
#include <ptrwinst.h>
#include <ptntintf.h>
#else //not PLATINUM
#include "aqdbgext.h"
#include <rwinst.h>
#endif //PLATINUM

#include <aqinst.h>
#include <connmgr.h>
#include <msgref.h>
#include <fifoq.h>
#include <dcontext.h>
#include <smtpconn.h>
#include <destmsgq.h>
#include <linkmsgq.h>
#include <qwiklist.h>
#include <dsnbuff.h>
#include <time.h>
#include <qwiktime.h>
#include <asyncq.h>
#include <retryq.h>
#include <hashentr.h>
#include <aqstats.h>
#include <aqadmsvr.h>
#include <defdlvrq.h>
#include <aqsize.h>
#include <asncwrkq.h>


PEXTLIB_INIT_ROUTINE g_pExtensionInitRoutine = NULL;

DEFINE_EXPORTED_FUNCTIONS

LPSTR ExtensionNames[] = {
    "Advanced Queuing debugger extensions",
    0
};

LPSTR Extensions[] = {
    "offsets - Lists LIST_ENTRY offsets",
    "   USAGE: offsets",
    "dumpservers - Dump pointers to the virtual server objects",
    "   USAGE: dumpservers [<virtual server id> [<virtual server list address>]]",
    "       <virtual server id> - specifies instance ID to dump in detail",
    "       <virtual server list address> - address of the head of the virtual",
    "                                       server LIST_ENTRY. No needed in CDB,",
    "                                       but can be found in windbg by typing:",
    "                         x " AQUEUE_VIRTUAL_SERVER_SYMBOL,
    "dumpdnt - Dump a given DOMAIN_NAME_TABLE (and it's entries)",
    "   USAGE: dumpdnt [<Struct Type Name>]",
    "       <Struct Type Name> - if specified, will dump all entries",
    "                            in the DNT as this type",
    "dumplist - Dump a given list of LIST_ENTRY structs",
    "   USAGE: dumplist <list head> [<entry offset> [<Struct Type Name>]]",
    "       <list head> - Address of head LIST_ENTRY",
    "       <entry offset> - The offset in each object of the LIST_ENTRY.",
    "                        This can be determined using the offses command.",
    "       <Struct Type Name> - Type of object list entries are in.",
    "dumpqueue - Dump the CMsgRefs and IMailMsgProperties for  a given queue",
    "   USAGE: dumpqueue <queue> [<search>]",
    "       <queue> -  Address of DMQ, LMQ, or FIFOQ",
    "       <search> - IMailMsgProperties ptr to search for",
    "walkcpool - Dump the currently allocted entries for a *DBG* CPool",
    "   USAGE: walkcpool <cpool> [<dumpoffset>]",
    "       <cpool> - Address of static CPool to dump",
    "       <dumpoffset> - Offset of additional information to dump",
    "   An example usages is to dump all the STMP_CONNOUT objects and",
    "   all the ISMTPConn interfaces they point to",
    "displaytickcount - Display the localized actual time of a given tick count",
    "   USAGE: displaytickcount <tickcount>",
    "       <tickcount> - DWORD tickcount to display",
    "workqueue - Display a summary of items in the async work queue",
    "   USAGE: workqueue <queue>",
    "       <queue> - Address of work queue (can be obtained from dumpservers)",
    "dumplock  - Dumps current state (included shared threads) of a CShareLockInst",
    "   USAGE: dumplock <lock>",
    "       <lock> - Address of CShareLockInst object",
    "findbytes - Searches for a given byte pattern in the process memory",
    "   USAGE: findbytes <bb> <bb>...",
    "findsig - Searchs for a given signature in memory",
    "   USAGE: findsig  <SIG >",
    "remotecmd - Starts a remote command window with the given name",
    "   USAGE: remotecmd <PIPENAME>",
    "cpoolusage - Calculates the amount of CPool memory used in the the",
    "       inetinfo process",
    "   USAGE: cpoolusage",
    "   *NOTE* - Requires symbols to work properly",
    "zombieq - Checks for DMQs that are marked as empty but not in the empty list",
    "   USAGE: zombieq  [<virtual server ID> [<virtual server list address>]]",
    "handlemgmt - Calculates some scores based on usage of handles... can be",
    "   used to correlate disk usage vs messages submitted and validate new",
    "   queuing algorthims before formal performance analysis",
    "   USAGE: handlemgmt [<virtual server ID> [<virtual server list address>]]",
    " Here is an explanation of the various scores:",
    "   Current Messsages Allocated That have been closed:",
    "       This is the number of messages currently allocated that",
    "       have been bounced (may be internally queued assocated with",
    "       connections queued remotelyetc).",
    "   Non-Weighted Score:",
    "       Useful as a baseline for internally queued messages.",
    "       Similar to Delivery score if nothing is queued",
    "   Weighted Score:",
    "       Only really useful when messages are queued internally.  ",
    "       Related (5x) delivery score if nothing is queued.",
    "   Submitted Score:",
    "       Most useful when queues have fully drained makes sense for",
    "       local and remote deliveries",
    "   Delivery Score:",
    "       Most useful when queues have fully drained only makes sense",
    "       for local deliveries.",
    " The following are good for correlating test runs the lower the ",
    "  backlog, the more the submitted score makes sense.  If there is",
    "  any backlog (and the 2nd % is high), then Weighted score makes good",
    "  sense for local delivery testing.",
    "   Messages Backlogged:",
    "       The is the % of messages submitted that have not been",
    "       delivered yet... similar numbers suggest the test runs are in",
    "       similar places.",
    "   Backlogged Messages Queued Internally:",
    "       % of messages in the backlog that will appear in the internal",
    "       queues.\n"
    "dsncontexthash - Generates the same hash used in the X-DSNContext",
    "   header. This can be used to verify which file generated an NDR",
    "   USAGE: dsncontexthash <filename>",
    "linkstate - Dumps the current routing information and link state",
    "   USAGE: linkstate [<virtual server ID> [<virtual server list address>]]",
    "       <virtual server id> - specifies instance ID to get data for",
    "       <virtual server list address> - address of the head of the virtual",
    "                                       server LIST_ENTRY. No needed in CDB,",
    "                                       but can be found in windbg by typing:",
    "                         x " AQUEUE_VIRTUAL_SERVER_SYMBOL,
    "\n",
    "***NOTE***\n",
    "   You MUST have good aqueue.dll symbols to use dumpservers and linkstate",
    0
};


//Stuctures for dumping

//Dummy class for dumping a filetime
class CFileTime
{
  public:
    FILETIME    m_ft;
};

#define MEMBER_BIT_MASK_VALUE(MyClass, x) BIT_MASK_VALUE2(MyClass::x, #x)

BEGIN_FIELD_DESCRIPTOR(CFileTimeFields)
    FIELD3(FieldTypeLocalizedFiletime, CFileTime, m_ft)
    FIELD3(FieldTypeFiletime, CFileTime, m_ft)
END_FIELD_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(CmtInitMask)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_OK)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_DMT)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_DCT)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_MSGQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_LINKQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_CONMGR)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_DSN)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_PRECATQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_PRELOCQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_POSTDSNQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_ROUTER_RESET)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_WORKQ)
    MEMBER_BIT_MASK_VALUE(CAQSvrInst, CMQ_INIT_MSGQ)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(MsgRefBitMask)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_LOCAL_RETRY)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_COUNTED_AS_REMOTE)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_REMOTE_RETRY)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_SUPERSEDED)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_INIT)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_FROZEN)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MSG_RETRY_ON_DELETE)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_ASYNC_BOUNCE_PENDING)
    MEMBER_BIT_MASK_VALUE(CMsgRef, MSGREF_MAILMSG_RELEASED)
    BIT_MASK_VALUE(eEffPriNormal)
    BIT_MASK_VALUE(eEffPriHigh)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(MsgAckBitMask)
    BIT_MASK_VALUE(MESSAGE_STATUS_ALL_DELIVERED)
    BIT_MASK_VALUE(MESSAGE_STATUS_RETRY)
    BIT_MASK_VALUE(MESSAGE_STATUS_CHECK_RECIPS)
    BIT_MASK_VALUE(MESSAGE_STATUS_NDR_ALL)
    BIT_MASK_VALUE(MESSAGE_STATUS_DSN_NOT_SUPPORTED)
    BIT_MASK_VALUE(MESSAGE_STATUS_EXTENDED_STATUS_CODES)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(LinkStateBitMask)
    BIT_MASK_VALUE(LINK_STATE_RETRY_ENABLED)
    BIT_MASK_VALUE(LINK_STATE_SCHED_ENABLED)
    BIT_MASK_VALUE(LINK_STATE_ADMIN_FORCE_CONN)
    BIT_MASK_VALUE(LINK_STATE_ADMIN_HALT)
    BIT_MASK_VALUE(LINK_STATE_CMD_ENABLED)
    BIT_MASK_VALUE(LINK_STATE_LINK_NO_LONGER_USED)
    BIT_MASK_VALUE2(LINK_STATE_PRIV_ETRN_ENABLED, "LINK_STATE_PRIV_ETRN_ENABLED")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_TURN_ENABLED, "LINK_STATE_PRIV_TURN_ENABLED")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_CONFIG_TURN_ETRN, "LINK_STATE_PRIV_CONFIG_TURN_ETRN")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_NO_NOTIFY, "LINK_STATE_PRIV_NO_NOTIFY")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_NO_CONNECTION, "LINK_STATE_PRIV_NO_CONNECTION")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_GENERATING_DSNS, "LINK_STATE_PRIV_GENERATING_DSNS")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY, "LINK_STATE_PRIV_IGNORE_DELETE_IF_EMPTY")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION, "LINK_STATE_PRIV_HAVE_SENT_NOTIFICATION")
    BIT_MASK_VALUE2(LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED, "LINK_STATE_PRIV_HAVE_SENT_NO_LONGER_USED")
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(LinkFlagsBitMask)
    BIT_MASK_VALUE(eLinkFlagsClear)
    BIT_MASK_VALUE(eLinkFlagsSentNewNotification)
    BIT_MASK_VALUE(eLinkFlagsRouteChangePending)
    BIT_MASK_VALUE(eLinkFlagsFileTimeSpinLock)
    BIT_MASK_VALUE(eLinkFlagsDiagnosticSpinLock)
    BIT_MASK_VALUE(eLinkFlagsConnectionVerifed)
    BIT_MASK_VALUE(eLinkFlagsGetInfoFailed)
    BIT_MASK_VALUE(eLinkFlagsAQSpecialLinkInfo)
    BIT_MASK_VALUE(eLinkFlagsInternalSMTPLinkInfo)
    BIT_MASK_VALUE(eLinkFlagsExternalSMTPLinkInfo)
    BIT_MASK_VALUE(eLinkFlagsMarkedAsEmpty)
    BIT_MASK_VALUE(eLinkFlagsInvalid)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(DomainInfoBitMask)
    BIT_MASK_VALUE(DOMAIN_INFO_REMOTE)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_SSL)
    BIT_MASK_VALUE(DOMAIN_INFO_SEND_TURN)
    BIT_MASK_VALUE(DOMAIN_INFO_SEND_ETRN)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_NTLM)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_PLAINTEXT)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_DPA)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_KERBEROS)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_CHUNKING)
    BIT_MASK_VALUE(DOMAIN_INFO_USE_HELO)
    BIT_MASK_VALUE(DOMAIN_INFO_TURN_ONLY)
    BIT_MASK_VALUE(DOMAIN_INFO_ETRN_ONLY)
    BIT_MASK_VALUE(DOMAIN_INFO_LOCAL_DROP)
    BIT_MASK_VALUE(DOMAIN_INFO_LOCAL_MAILBOX)
    BIT_MASK_VALUE(DOMAIN_INFO_REMOTE_SMARTHOST)
    BIT_MASK_VALUE(DOMAIN_INFO_IP_RELAY)
    BIT_MASK_VALUE(DOMAIN_INFO_AUTH_RELAY)
    BIT_MASK_VALUE(DOMAIN_INFO_DOMAIN_RELAY)
    BIT_MASK_VALUE(DOMAIN_INFO_DISABLE_CHUNKING)
    BIT_MASK_VALUE(DOMAIN_INFO_DISABLE_BMIME)
    BIT_MASK_VALUE(DOMAIN_INFO_DISABLE_DSN)
    BIT_MASK_VALUE(DOMAIN_INFO_DISABLE_PIPELINE)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(DCTFlags)
    MEMBER_BIT_MASK_VALUE(CDomainConfigTable, DOMCFG_DOMAIN_NAME_TABLE_INIT)
    MEMBER_BIT_MASK_VALUE(CDomainConfigTable, DOMCFG_FINISH_UPDATE_PENDING)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(InternalDomainInfoFlags)
    BIT_MASK_VALUE(INT_DOMAIN_INFO_INVALID)
    BIT_MASK_VALUE(INT_DOMAIN_INFO_OK)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(ConnectionAckFlags)
    BIT_MASK_VALUE(CONNECTION_STATUS_OK)
    BIT_MASK_VALUE(CONNECTION_STATUS_FAILED)
    BIT_MASK_VALUE(CONNECTION_STATUS_DROPPED)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(AsyncQueueFlags)
    BIT_MASK_VALUE2(CAsyncQueueBase::ASYNC_QUEUE_STATUS_SHUTDOWN, "ASYNC_QUEUE_STATUS_SHUTDOWN")
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(DMQBitmask)
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_INVALID, "DMQ_INVALID")
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_IN_EMPTY_QUEUE_LIST, "DMQ_IN_EMPTY_QUEUE_LIST")
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_SHUTDOWN_SIGNALED, "DMQ_SHUTDOWN_SIGNALED")
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_EMPTY, "DMQ_EMPTY")
    BIT_MASK_VALUE2(CDestMsgQueue::DMQ_EXPIRED, "DMQ_EXPIRED")
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(DSNOptions)
    BIT_MASK_VALUE(DSN_OPTIONS_DEFAULT)
    BIT_MASK_VALUE(DSN_OPTIONS_DEFAULT_RET_HEADERS)
    BIT_MASK_VALUE(DSN_OPTIONS_DEFAULT_RET_FULL)
    BIT_MASK_VALUE(DSN_OPTIONS_IGNORE_MSG_RET)
    BIT_MASK_VALUE(DSN_OPTIONS_SEND_DELAY_DEFAULT)
    BIT_MASK_VALUE(DSN_OPTIONS_SEND_DELAY_UPON_REQUEST)
    BIT_MASK_VALUE(DSN_OPTIONS_SEND_DELAY_NEVER)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(MsgEnumFilterFlags)
    BIT_MASK_VALUE(MEF_FIRST_N_MESSAGES)
    BIT_MASK_VALUE(MEF_N_LARGEST_MESSAGES)
    BIT_MASK_VALUE(MEF_N_OLDEST_MESSAGES)
    BIT_MASK_VALUE(MEF_OLDER_THAN)
    BIT_MASK_VALUE(MEF_LARGER_THAN)
    BIT_MASK_VALUE(MEF_INVERTSENSE)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(MsgFilterFlags)
    BIT_MASK_VALUE(MF_MESSAGEID)
    BIT_MASK_VALUE(MF_SENDER)
    BIT_MASK_VALUE(MF_RECIPIENT)
    BIT_MASK_VALUE(MF_SIZE)
    BIT_MASK_VALUE(MF_TIME)
    BIT_MASK_VALUE(MF_FROZEN)
    BIT_MASK_VALUE(MF_INVERTSENSE)
END_BIT_MASK_DESCRIPTOR

BEGIN_BIT_MASK_DESCRIPTOR(InternalMsgFilterFlags)
    BIT_MASK_VALUE(AQ_MSG_FILTER_MESSAGEID)
    BIT_MASK_VALUE(AQ_MSG_FILTER_SENDER)
    BIT_MASK_VALUE(AQ_MSG_FILTER_RECIPIENT)
    BIT_MASK_VALUE(AQ_MSG_FILTER_OLDER_THAN)
    BIT_MASK_VALUE(AQ_MSG_FILTER_LARGER_THAN)
    BIT_MASK_VALUE(AQ_MSG_FILTER_FROZEN)
    BIT_MASK_VALUE(AQ_MSG_FILTER_FIRST_N_MESSAGES)
    BIT_MASK_VALUE(AQ_MSG_FILTER_N_LARGEST_MESSAGES)
    BIT_MASK_VALUE(AQ_MSG_FILTER_N_OLDEST_MESSAGES)
    BIT_MASK_VALUE(AQ_MSG_FILTER_INVERTSENSE)
END_BIT_MASK_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DMTFields)
    FIELD3(FieldTypeClassSignature, CDomainMappingTable, m_dwSignature)
    FIELD3(FieldTypeDword, CDomainMappingTable, m_dwInternalVersion)
    FIELD3(FieldTypeDword, CDomainMappingTable, m_cThreadsForEmptyDMQList)
    FIELD3(FieldTypeDword, CDomainMappingTable, m_cOutstandingExternalShareLocks)
    FIELD3(FieldTypePointer, CDomainMappingTable, m_paqinst)
    FIELD3(FieldTypePointer, CDomainMappingTable, m_plmqLocal)
    FIELD3(FieldTypePointer, CDomainMappingTable, m_plmqUnreachable)
    FIELD3(FieldTypePointer, CDomainMappingTable, m_plmqCurrentlyUnreachable)
    FIELD3(FieldTypeListEntry, CDomainMappingTable, m_liEmptyDMQHead)
    FIELD3(FieldTypeStruct, CDomainMappingTable, m_dnt)
    FIELD3(FieldTypeStruct, CDomainMappingTable, m_slPrivateData)
END_FIELD_DESCRIPTOR

EMBEDDED_STRUCT(CDomainMappingTable, DMTFields, EmbeddedDMT)

BEGIN_FIELD_DESCRIPTOR(AQStatsFields)
    FIELD3(FieldTypeClassSignature, CAQStats, m_dwSignature)
    FIELD3(FieldTypeDword, CAQStats, m_dwNotifyType)
    FIELD3(FieldTypeDword, CAQStats, m_cMsgs)
    FIELD3(FieldTypeDword, CAQStats, m_dwHighestPri)
    FIELD3(FieldTypePointer, CAQStats, m_pvContext)
    FIELD3(FieldTypeDword, CAQStats, m_uliVolume.HighPart)
    FIELD3(FieldTypeDword, CAQStats, m_uliVolume.LowPart)
    FIELD3(FieldTypeDword, CAQStats, m_cRetryMsgs)
END_FIELD_DESCRIPTOR

EMBEDDED_STRUCT(CAQStats, AQStatsFields, EmbeddedAQStats)

BEGIN_FIELD_DESCRIPTOR(ConnMgrFields)
    FIELD3(FieldTypeDword, CConnMgr, m_lReferences)
    FIELD3(FieldTypeDword, CConnMgr, m_cConnections)
    FIELD3(FieldTypePointer, CConnMgr, m_paqinst)
    FIELD3(FieldTypePointer, CConnMgr, m_pqol)
    FIELD3(FieldTypePointer, CConnMgr, m_pDefaultRetryHandler)
    FIELD3(FieldTypeDword, CConnMgr, m_dwConfigVersion)
    FIELD3(FieldTypeDword, CConnMgr, m_cMinMessagesPerConnection)
    FIELD3(FieldTypeDword, CConnMgr, m_cMaxLinkConnections)
    FIELD3(FieldTypeDword, CConnMgr, m_cMaxMessagesPerConnection)
    FIELD3(FieldTypeDword, CConnMgr, m_cMaxConnections)
    FIELD3(FieldTypeDword, CConnMgr, m_cGetNextConnectionWaitTime)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RSTRFields)
    FIELD3(FieldTypeClassSignature, CRefCountedString, m_dwSignature)
    FIELD3(FieldTypeDword, CRefCountedString, m_cbStrlen)
    FIELD3(FieldTypePStr, CRefCountedString, m_szStr)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RetrySinkFields)
    FIELD3(FieldTypePointer, CSMTP_RETRY_HANDLER, m_pRetryHash)
    FIELD3(FieldTypePointer, CSMTP_RETRY_HANDLER, m_pRetryQueue)
    FIELD3(FieldTypeBool, CSMTP_RETRY_HANDLER, m_fHandlerShuttingDown)
    FIELD3(FieldTypeBool, CSMTP_RETRY_HANDLER, m_fConfigDataUpdated)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_ThreadsInRetry)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwRetryThreshold)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwGlitchRetrySeconds)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwFirstRetrySeconds)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwSecondRetrySeconds)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwThirdRetrySeconds)
    FIELD3(FieldTypeDword, CSMTP_RETRY_HANDLER, m_dwFourthRetrySeconds)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RetryQueueFields)
    FIELD3(FieldTypeListEntry, CRETRY_Q, m_QHead)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(RetryHashFields)
    FIELD3(FieldTypeClassSignature, CRETRY_HASH_ENTRY, m_Signature)
    FIELD3(FieldTypeLong, CRETRY_HASH_ENTRY, m_RefCount)
    FIELD3(FieldTypeBool, CRETRY_HASH_ENTRY, m_InQ)
    FIELD3(FieldTypeBool, CRETRY_HASH_ENTRY, m_InTable)
    FIELD3(FieldTypeLocalizedFiletime, CRETRY_HASH_ENTRY, m_ftEntryInsertedTime)
    FIELD3(FieldTypeLocalizedFiletime, CRETRY_HASH_ENTRY, m_ftRetryTime)
    FIELD3(FieldTypeDword, CRETRY_HASH_ENTRY, m_cFailureCount)
    FIELD3(FieldTypeSymbol, CRETRY_HASH_ENTRY, m_pfnCallbackFn)
    FIELD3(FieldTypePointer, CRETRY_HASH_ENTRY, m_pvCallbackContext)
    FIELD3(FieldTypeStrBuffer, CRETRY_HASH_ENTRY, m_szDomainName)
    FIELD3(FieldTypeListEntry, CRETRY_HASH_ENTRY, m_QLEntry)
    FIELD3(FieldTypeListEntry, CRETRY_HASH_ENTRY, m_HLEntry)
#ifdef DEBUG
    FIELD3(FieldTypePointer, CRETRY_HASH_ENTRY, m_hTranscriptHandle)
    FIELD3(FieldTypeStrBuffer, CRETRY_HASH_ENTRY, m_szTranscriptFile)
#endif //DEBUG
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CMQFields)
    FIELD3(FieldTypeClassSignature, CAQSvrInst, m_dwSignature)
    FIELD3(FieldTypeDword, CAQSvrInst, m_lReferences)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwFirstTierRetrySeconds)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwDelayExpireMinutes)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwNDRExpireMinutes)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwLocalDelayExpireMinutes)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwLocalNDRExpireMinutes)
    FIELD3(FieldTypeDword, CAQSvrInst, m_cLocalRetriesPending)
    FIELD3(FieldTypeDword, CAQSvrInst, m_cCatRetriesPending)
    FIELD3(FieldTypeDword, CAQSvrInst, m_cRoutingRetriesPending)
    FIELD3(FieldTypePointer, CAQSvrInst, m_pConnMgr)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_dct)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_qtTime)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPreCatQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPreLocalDeliveryQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPostDSNQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPreRoutingQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_asyncqPreSubmissionQueue)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_aqwWorkQueue)
    FIELD3(FieldTypePointer, CAQSvrInst, m_prstrDefaultDomain)
    FIELD3(FieldTypePointer, CAQSvrInst, m_prstrServerFQDN)
    FIELD3(FieldTypePointer, CAQSvrInst, m_prstrBadMailDir)
    FIELD3(FieldTypePointer, CAQSvrInst, m_prstrCopyNDRTo)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_mglSupersedeIDs)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_defq)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_fmq)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_aqwWorkQueue)
    FIELD4(FieldTypeEmbeddedStruct, CAQSvrInst, m_dmt, EmbeddedDMT)
    FIELD3(FieldTypeDword, CAQSvrInst, m_dwDSNLanguageID)
    FIELD3(FieldTypeStruct, CAQSvrInst, m_slPrivateData)
    FIELD4(FieldTypeDWordBitMask, CAQSvrInst, m_dwDSNOptions, GET_BIT_MASK_DESCRIPTOR(DSNOptions))
    FIELD4(FieldTypeDWordBitMask, CAQSvrInst, m_dwInitMask, GET_BIT_MASK_DESCRIPTOR(CmtInitMask))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(AQCounterInfoFields)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalMsgsQueued)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cMsgsAcked)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cMsgsAckedRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cMsgsAckedRetryLocal)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cMsgsDeliveredLocal)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsSubmitted)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingSubmitEvent)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingCat)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingPostCatEvent)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingRouting)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingDelivery)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingLocal)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingLocalRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentQueueMsgInstances)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteDestQueues)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHops)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHopsEnabled)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHopsPendingRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHopsPendingSchedule)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentRemoteNextHopsFrozenByAdmin)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalMsgsSubmitted)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalExternalMsgsSubmitted)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cNDRs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cDelayedDSNs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cDeliveredDSNs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cRelayedDSNs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cExpandedDSNs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cDMTRetries)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cSupersededMsgs)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingDeferredDelivery)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentResourceFailedMsgsPendingRetry)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalMsgsBadmailed)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalResetRoutes)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cTotalDSNFailures)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCatMsgCalled)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCatCompletionCalled)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsInLocalDelivery)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentPendingResetRoutes)
    FIELD3(FieldTypeLong, CAQSvrInst, m_cCurrentMsgsPendingSubmit)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgGuidListFields)
    FIELD3(FieldTypeClassSignature, CAQMsgGuidList, m_dwSignature)
    FIELD3(FieldTypeListEntry, CAQMsgGuidList, m_liMsgGuidListHead)
    FIELD3(FieldTypeStruct, CAQMsgGuidList, m_slPrivateData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgGuidListEntryFields)
    FIELD3(FieldTypeClassSignature, CAQMsgGuidListEntry, m_dwSignature)
    FIELD3(FieldTypeDword, CAQMsgGuidListEntry, m_lReferences)
    FIELD3(FieldTypePointer, CAQMsgGuidListEntry, m_pmsgref)
    FIELD3(FieldTypePointer, CAQMsgGuidListEntry, m_pmgl)
    FIELD3(FieldTypeStruct, CAQMsgGuidListEntry, m_liMsgGuidList)
    FIELD3(FieldTypeGuid, CAQMsgGuidListEntry, m_guidMsgID)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DomainInfoFields)
    FIELD3(FieldTypeDword, DomainInfo, cbVersion)
    FIELD3(FieldTypeDword, DomainInfo, dwDomainInfoFlags)
    FIELD3(FieldTypeDword, DomainInfo, cbDomainNameLength)
    FIELD3(FieldTypePStr, DomainInfo, szDomainName)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgRefFields)
    FIELD3(FieldTypeClassSignature, CMsgRef, m_dwSignature)
    FIELD3(FieldTypeDword, CMsgRef, m_lReferences)
    FIELD3(FieldTypePointer, CMsgRef, m_paqinst)
    FIELD3(FieldTypePointer, CMsgRef, m_pIMailMsgProperties)
    FIELD4(FieldTypeDWordBitMask, CMsgRef, m_dwDataFlags, GET_BIT_MASK_DESCRIPTOR(MsgRefBitMask))
    FIELD3(FieldTypeDword, CMsgRef, m_cbMsgSize)
    FIELD3(FieldTypeDword, CMsgRef, m_cDomains)
    FIELD3(FieldTypeDword, CMsgRef, m_cTimesRetried)
    FIELD3(FieldTypeStruct, CMsgRef, m_rgpdmqDomains)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftQueueEntry)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftLocalExpireDelay)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftLocalExpireNDR)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftRemoteExpireDelay)
    FIELD3(FieldTypeLocalizedFiletime, CMsgRef, m_ftRemoteExpireNDR)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgAckFields)
    FIELD3(FieldTypePointer, MessageAck, pIMailMsgProperties)
    FIELD3(FieldTypePointer, MessageAck, pvMsgContext)
    FIELD4(FieldTypeDWordBitMask, MessageAck, dwMsgStatus, GET_BIT_MASK_DESCRIPTOR(MsgAckBitMask))
    FIELD3(FieldTypeDword, MessageAck, cbExtendedStatus)
    FIELD3(FieldTypePStr, MessageAck, szExtendedStatus)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DeliveryContextFields)
    FIELD3(FieldTypeClassSignature, CDeliveryContext, m_dwSignature)
    FIELD3(FieldTypePointer, CDeliveryContext, m_pmsgref)
    FIELD3(FieldTypePointer, CDeliveryContext, m_pmbmap)
    FIELD3(FieldTypeDword, CDeliveryContext, m_cRecips)
    FIELD3(FieldTypePointer, CDeliveryContext, m_rgdwRecips)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DomainEntryFields)
    FIELD3(FieldTypeClassSignature, CDomainEntry, m_dwSignature)
    FIELD3(FieldTypeDword, CDomainEntry, m_lReferences)
    FIELD3(FieldTypePStr, CDomainEntry, m_szDomainName)
    FIELD3(FieldTypeStruct, CDomainEntry, m_dmap)
    FIELD3(FieldTypeDword, CDomainEntry, m_cQueues)
    FIELD3(FieldTypeDword, CDomainEntry, m_cLinks)
    FIELD3(FieldTypeListEntry, CDomainEntry, m_liDestQueues)
    FIELD3(FieldTypeListEntry, CDomainEntry, m_liLinks)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DomainNameTableEntryFields)
    FIELD3(FieldTypeClassSignature, DOMAIN_NAME_TABLE_ENTRY, dwEntrySig)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pParentEntry)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pNextEntry)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pPrevEntry)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pFirstChildEntry)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pSiblingEntry)
    FIELD3(FieldTypeULong, DOMAIN_NAME_TABLE_ENTRY, NoOfChildren)
    FIELD3(FieldTypeAnsiString, DOMAIN_NAME_TABLE_ENTRY, PathSegment)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pData)
    FIELD3(FieldTypePointer, DOMAIN_NAME_TABLE_ENTRY, pWildCardData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DomainConfigTableFields)
    FIELD3(FieldTypeClassSignature, CDomainConfigTable, m_dwSignature)
    FIELD3(FieldTypeDword, CDomainConfigTable, m_dwCurrentConfigVersion)
    FIELD3(FieldTypeStruct, CDomainConfigTable, m_dnt)
    FIELD3(FieldTypePointer, CDomainConfigTable, m_pDefaultDomainConfig)
    FIELD3(FieldTypeStruct, CDomainConfigTable, m_slPrivateData)
    FIELD4(FieldTypeDWordBitMask, CDomainConfigTable, m_dwFlags, GET_BIT_MASK_DESCRIPTOR(DCTFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(IntDomainInfoFields)
    FIELD3(FieldTypeClassSignature, CInternalDomainInfo, m_dwSignature)
    FIELD3(FieldTypeDword, CInternalDomainInfo, m_lReferences)
    FIELD3(FieldTypeDword, CInternalDomainInfo, m_dwVersion)
    FIELD4(FieldTypeDWordBitMask, CInternalDomainInfo, m_dwIntDomainInfoFlags, GET_BIT_MASK_DESCRIPTOR(InternalDomainInfoFlags))
    FIELD3(FieldTypeDword, CInternalDomainInfo, m_DomainInfo.cbVersion)
    FIELD3(FieldTypePStr, CInternalDomainInfo, m_DomainInfo.szDomainName)
    FIELD3(FieldTypePStr, CInternalDomainInfo, m_DomainInfo.szDropDirectory)
    FIELD3(FieldTypePStr, CInternalDomainInfo, m_DomainInfo.szSmartHostDomainName)
    FIELD4(FieldTypeDWordBitMask, CInternalDomainInfo, m_DomainInfo.dwDomainInfoFlags, GET_BIT_MASK_DESCRIPTOR(DomainInfoBitMask))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(SMTPConnFields)
    FIELD3(FieldTypeClassSignature, CSMTPConn, m_dwSignature)
    FIELD3(FieldTypeDword, CSMTPConn, m_lReferences)
    FIELD3(FieldTypePointer, CSMTPConn, m_plmq)
    FIELD3(FieldTypePointer, CSMTPConn, m_pConnMgr)
    FIELD3(FieldTypePointer, CSMTPConn, m_pIntDomainInfo)
    FIELD3(FieldTypeDword, CSMTPConn, m_cFailedMsgs)
    FIELD3(FieldTypeDword, CSMTPConn, m_cTriedMsgs)
    FIELD3(FieldTypeDword, CSMTPConn, m_cAcks)
    FIELD3(FieldTypeDWordBitMask, CSMTPConn, m_dwTickCountOfLastAck)
    FIELD3(FieldTypePStr, CSMTPConn, m_szDomainName)
    FIELD4(FieldTypeDWordBitMask, CSMTPConn, m_dwConnectionStatus, GET_BIT_MASK_DESCRIPTOR(ConnectionAckFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DestMsgQueueFields)
    FIELD3(FieldTypeClassSignature, CDestMsgQueue, m_dwSignature)
    FIELD3(FieldTypeDword, CDestMsgQueue, m_lReferences)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_plmq)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_pvLinkContext)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_paqinst)
    FIELD3(FieldTypeListEntry, CDestMsgQueue, m_liDomainEntryDMQs)
    FIELD3(FieldTypeStruct, CDestMsgQueue, m_aqmt)
    FIELD3(FieldTypeDword, CDestMsgQueue, m_cMessageTypeRefs)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_pIMessageRouter)
    FIELD3(FieldTypeListEntry, CDestMsgQueue, m_liEmptyDMQs)
    FIELD3(FieldTypeDword, CDestMsgQueue, m_cRemovedFromEmptyList)
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[0])
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[1])
    FIELD3(FieldTypePointer, CDestMsgQueue, m_rgpfqQueues[2])
    FIELD3(FieldTypeStruct, CDestMsgQueue, m_fqRetryQueue)
    FIELD3(FieldTypeStruct, CDestMsgQueue, m_dmap)
    FIELD3(FieldTypeLocalizedFiletime, CDestMsgQueue, m_ftOldest)
    FIELD3(FieldTypeDword, CDestMsgQueue, m_cCurrentThreadsEnqueuing)
    FIELD4(FieldTypeEmbeddedStruct, CDestMsgQueue, m_aqstats, EmbeddedAQStats)
    FIELD4(FieldTypeDWordBitMask, CDestMsgQueue, m_dwFlags,  GET_BIT_MASK_DESCRIPTOR(DMQBitmask))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(LinkMsgQueueFields)
    FIELD3(FieldTypeClassSignature, CLinkMsgQueue, m_dwSignature)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_lReferences)
    FIELD4(FieldTypeDWordBitMask, CLinkMsgQueue, m_dwLinkFlags, GET_BIT_MASK_DESCRIPTOR(LinkFlagsBitMask))
    FIELD3(FieldTypePointer, CLinkMsgQueue, m_paqinst)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_cQueues)
    FIELD3(FieldTypeStruct, CLinkMsgQueue, m_qlstQueues)
    FIELD3(FieldTypePointer, CLinkMsgQueue, m_pdentryLink)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_cConnections)
    FIELD3(FieldTypePStr, CLinkMsgQueue, m_szSMTPDomain)
    FIELD3(FieldTypePStr, CLinkMsgQueue, m_szConnectorName)
    FIELD3(FieldTypePointer, CLinkMsgQueue, m_pIntDomainInfo)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_lConnMgrCount)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_lConsecutiveConnectionFailureCount)
    FIELD3(FieldTypeDword, CLinkMsgQueue, m_lConsecutiveMessageFailureCount)
    FIELD3(FieldTypeDWordBitMask, CLinkMsgQueue, m_hrDiagnosticError)
    FIELD3(FieldTypeStrBuffer, CLinkMsgQueue, m_szDiagnosticVerb)
    FIELD3(FieldTypeStrBuffer, CLinkMsgQueue, m_szDiagnosticResponse)
    FIELD4(FieldTypeEmbeddedStruct, CLinkMsgQueue, m_aqstats, EmbeddedAQStats)
    FIELD4(FieldTypeDWordBitMask, CLinkMsgQueue, m_dwLinkStateFlags, GET_BIT_MASK_DESCRIPTOR(LinkStateBitMask))
    FIELD3(FieldTypeLocalizedFiletime, CLinkMsgQueue, m_ftNextScheduledCallback)
    FIELD3(FieldTypeStruct, CLinkMsgQueue, m_ftNextScheduledCallback)
    FIELD3(FieldTypeLocalizedFiletime, CLinkMsgQueue, m_ftNextRetry)
    FIELD3(FieldTypeStruct, CLinkMsgQueue, m_ftNextRetry)
    FIELD3(FieldTypeLocalizedFiletime, CLinkMsgQueue, m_ftEmptyExpireTime)
    FIELD3(FieldTypeStruct, CLinkMsgQueue, m_ftEmptyExpireTime)
    FIELD3(FieldTypeDWordBitMask, CLinkMsgQueue, m_dwSupportedActions)
    FIELD3(FieldTypeDWordBitMask, CLinkMsgQueue, m_dwLinkType)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(QuickListFields)
    FIELD3(FieldTypeClassSignature, CQuickList, m_dwSignature)
    FIELD3(FieldTypeDWordBitMask, CQuickList, m_dwCurrentIndexStart)
    FIELD3(FieldTypePointer, CQuickList, m_liListPages.Flink)
    FIELD3(FieldTypePointer, CQuickList, m_liListPages.Blink)
    FIELD3(FieldTypeDWordBitMask, CQuickList, m_cItems)
    FIELD3(FieldTypeStruct, CQuickList, m_rgpvData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(DSNBufferFields)
    FIELD3(FieldTypeClassSignature, CDSNBuffer, m_dwSignature)
    FIELD3(FieldTypeDword, CDSNBuffer, m_overlapped.Offset)
    FIELD3(FieldTypeDword, CDSNBuffer, m_overlapped.OffsetHigh)
    FIELD3(FieldTypePointer, CDSNBuffer, m_overlapped.hEvent)
    FIELD3(FieldTypeDword, CDSNBuffer, m_cbOffset)
    FIELD3(FieldTypeDword, CDSNBuffer, m_cbFileSize)
    FIELD3(FieldTypeDword, CDSNBuffer, m_cFileWrites)
    FIELD3(FieldTypePointer, CDSNBuffer, m_pDestFile)
    FIELD3(FieldTypeStruct, CDSNBuffer, m_pbFileBuffer)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(AQQuickTimeFields)
    FIELD3(FieldTypeClassSignature, CAQQuickTime, m_dwSignature)
    FIELD3(FieldTypeDWordBitMask, CAQQuickTime, m_dwLastInternalTime)
    FIELD3(FieldTypeDWordBitMask, CAQQuickTime, m_ftSystemStart.dwHighDateTime)
    FIELD3(FieldTypeDWordBitMask, CAQQuickTime, m_ftSystemStart.dwLowDateTime)
    FIELD3(FieldTypeLocalizedFiletime, CAQQuickTime, m_ftSystemStart)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(AsyncQueueBaseFields)
    FIELD3(FieldTypeClassSignature, CAsyncQueueBase, m_dwSignature)
    FIELD3(FieldTypeClassSignature, CAsyncQueueBase, m_dwTemplateSignature)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cMaxSyncThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cCurrentSyncThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cCurrentAsyncThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cItemsPending)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cItemsPerATQThread)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cItemsPerSyncThread)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cScheduledWorkItems)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cCurrentCompletionThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cTotalAsyncCompletionThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cTotalSyncCompletionThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cTotalShortCircuitThreads)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cCompletionThreadsRequested)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cPendingAsyncCompletions)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cMaxPendingAsyncCompletions)
    FIELD3(FieldTypePointer, CAsyncQueueBase, m_pvContext)
    FIELD3(FieldTypePointer, CAsyncQueueBase, m_pAtqContext)
    FIELD3(FieldTypePointer, CAsyncQueueBase, m_hAtqHandle)
    FIELD3(FieldTypeDword, CAsyncQueueBase, m_cThreadsNeeded)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CPoolFields)
    FIELD3(FieldTypeClassSignature, CPool, m_dwSignature)
    FIELD3(FieldTypeDword, CPool, m_cMaxInstances)
    FIELD3(FieldTypeDword, CPool, m_cInstanceSize)
    FIELD3(FieldTypeDword, CPool, m_cNumberCommitted)
    FIELD3(FieldTypeDword, CPool, m_cNumberInUse)
    FIELD3(FieldTypeDword, CPool, m_cNumberAvail)
    FIELD3(FieldTypeStruct, CPool, m_PoolCriticalSection)
    FIELD3(FieldTypePointer, CPool, m_pFreeList)
    FIELD3(FieldTypePointer, CPool, m_pExtraFreeLink)
    FIELD3(FieldTypeDword, CPool, m_cIncrementInstances)
    FIELD3(FieldTypeDword, CPool, m_cTotalAllocs)
    FIELD3(FieldTypeDword, CPool, m_cTotalFrees)
    FIELD3(FieldTypeDword, CPool, m_cTotalExtraAllocs)
    FIELD3(FieldTypePointer, CPool, m_pLastAlloc)
    FIELD3(FieldTypePointer, CPool, m_pLastExtraAlloc)
    FIELD3(FieldTypeDword, CPool, m_cFragmentInstances)
    FIELD3(FieldTypeDword, CPool, m_cMaxInstances)
    FIELD3(FieldTypeDword, CPool, m_cFragments)
    FIELD3(FieldTypeStruct, CPool, m_pFragments)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CShareLockNHFields)
    FIELD3(FieldTypeDword, CShareLockNH, m_lock.m_lock)
    FIELD3(FieldTypeStruct, CShareLockNH, m_lock.m_queue)
    FIELD3(FieldTypeDword, CShareLockNH, m_cReadLock)
    FIELD3(FieldTypeDword, CShareLockNH, m_cOutReaders)
    FIELD3(FieldTypeDword, CShareLockNH, m_cOutAcquiringReaders)
    FIELD3(FieldTypeDword, CShareLockNH, m_cExclusiveRefs)
    FIELD3(FieldTypePointer, CShareLockNH, m_hWaitingReaders)
    FIELD3(FieldTypePointer, CShareLockNH, m_hWaitingWriters)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgEnumFilterFields)
    FIELD3(FieldTypeDword, MESSAGE_ENUM_FILTER, dwVersion)
    FIELD3(FieldTypeDword, MESSAGE_ENUM_FILTER, cMessages)
    FIELD3(FieldTypeDword, MESSAGE_ENUM_FILTER, cbSize)
    FIELD3(FieldTypeStruct, MESSAGE_ENUM_FILTER, stDate)
    FIELD4(FieldTypeDWordBitMask, MESSAGE_ENUM_FILTER, mefType, GET_BIT_MASK_DESCRIPTOR(MsgEnumFilterFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(MsgFilterFields)
    FIELD3(FieldTypeDword, MESSAGE_FILTER, dwVersion)
    FIELD3(FieldTypeDword, MESSAGE_FILTER, dwLargerThanSize)
    FIELD3(FieldTypePStr, MESSAGE_FILTER, szMessageId)
    FIELD3(FieldTypePStr, MESSAGE_FILTER, szMessageSender)
    FIELD3(FieldTypePStr, MESSAGE_FILTER, szMessageRecipient)
    FIELD3(FieldTypeStruct, MESSAGE_FILTER, stOlderThan)
    FIELD4(FieldTypeDWordBitMask, MESSAGE_FILTER, fFlags, GET_BIT_MASK_DESCRIPTOR(MsgFilterFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(InternalMsgFilterFields)
    FIELD3(FieldTypeClassSignature, CAQAdminMessageFilter, m_dwSignature)
    FIELD3(FieldTypeDword, CAQAdminMessageFilter, m_cMessagesToFind)
    FIELD3(FieldTypeDword, CAQAdminMessageFilter, m_cMessagesFound)
    FIELD3(FieldTypeDword, CAQAdminMessageFilter, m_dwThresholdSize)
    FIELD3(FieldTypePStr, CAQAdminMessageFilter, m_szMessageId)
    FIELD3(FieldTypePStr, CAQAdminMessageFilter, m_szMessageSender)
    FIELD3(FieldTypePStr, CAQAdminMessageFilter, m_szMessageRecipient)
    FIELD3(FieldTypeLocalizedFiletime, CAQAdminMessageFilter, m_ftThresholdTime)
    FIELD3(FieldTypePointer, CAQAdminMessageFilter, m_rgMsgInfo)
    FIELD3(FieldTypePointer, CAQAdminMessageFilter, m_pCurrentMsgInfo)
    FIELD4(FieldTypeDWordBitMask, CAQAdminMessageFilter, m_dwFilterFlags, GET_BIT_MASK_DESCRIPTOR(InternalMsgFilterFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CAQDeferredDeliveryQueueFields)
    FIELD3(FieldTypeClassSignature, CAQDeferredDeliveryQueue, m_dwSignature)
    FIELD3(FieldTypeListEntry, CAQDeferredDeliveryQueue, m_liQueueHead)
    FIELD3(FieldTypeStruct, CAQDeferredDeliveryQueue, m_slPrivateData)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CAQDeferredDeliveryQueueEntryFields)
    FIELD3(FieldTypeClassSignature, CAQDeferredDeliveryQueueEntry, m_dwSignature)
    FIELD3(FieldTypeListEntry, CAQDeferredDeliveryQueueEntry, m_liQueueEntry)
    FIELD3(FieldTypePointer, CAQDeferredDeliveryQueueEntry, m_pIMailMsgProperties)
    FIELD3(FieldTypeLocalizedFiletime, CAQDeferredDeliveryQueueEntry, m_ftDeferredDeilveryTime)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(LinkInfoFields)
    FIELD3(FieldTypeDword, LINK_INFO, dwVersion)
    FIELD3(FieldTypePStr, LINK_INFO, szLinkName)
    FIELD3(FieldTypeDword, LINK_INFO, cMessages)
    FIELD3(FieldTypeStruct, LINK_INFO, stOldestMessage)
    FIELD3(FieldTypeStruct, LINK_INFO, stNextScheduledConnection)
    //FIELD4(FieldTypeDWordBitMask, CAQAdminMessageFilter, fStateFlags, GET_BIT_MASK_DESCRIPTOR(LinkInfoFlags))
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CAsyncWorkQueueItemFields)
    FIELD3(FieldTypeClassSignature, CAsyncWorkQueueItem, m_dwSignature)
    FIELD3(FieldTypeDword, CAsyncWorkQueueItem, m_lReferences)
    FIELD3(FieldTypePointer, CAsyncWorkQueueItem, m_pvData)
    FIELD3(FieldTypeSymbol, CAsyncWorkQueueItem, m_pfnCompletion)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CAsyncWorkQueueFields)
    FIELD3(FieldTypeClassSignature, CAsyncWorkQueue, m_dwSignature)
    FIELD3(FieldTypeDword, CAsyncWorkQueue, m_cWorkQueueItems)
    FIELD3(FieldTypeStruct, CAsyncWorkQueue, m_asyncq)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CShareLockInstFields)
    FIELD3(FieldTypeClassSignature, CShareLockInst, m_dwSignature)
    FIELD3(FieldTypeDWordBitMask, CShareLockInst, m_dwFlags)
    FIELD3(FieldTypeListEntry, CShareLockInst, m_liLocks)
    FIELD3(FieldTypeDword, CShareLockInst, m_cShareAttempts)
    FIELD3(FieldTypeDword, CShareLockInst, m_cShareAttemptsBlocked)
    FIELD3(FieldTypeDword, CShareLockInst, m_cExclusiveAttempts)
    FIELD3(FieldTypeDword, CShareLockInst, m_cExclusiveAttemptsBlocked)
    FIELD3(FieldTypePStr, CShareLockInst, m_szDescription)
    FIELD3(FieldTypeDWordBitMask, CShareLockInst, m_dwExclusiveThread)
    FIELD3(FieldTypePointer, CShareLockInst, m_rgtblkSharedThreadIDs)
    FIELD3(FieldTypeDword, CShareLockInst, m_cMaxTrackedSharedThreadIDs)
    FIELD3(FieldTypeDword, CShareLockInst, m_cCurrentSharedThreads)
    FIELD3(FieldTypeDword, CShareLockInst, m_cMaxConcurrentSharedThreads)
END_FIELD_DESCRIPTOR

BEGIN_FIELD_DESCRIPTOR(CSyncShutdownFields)
    FIELD3(FieldTypeClassSignature, CSyncShutdown, m_dwSignature)
    FIELD3(FieldTypeDWordBitMask, CSyncShutdown, m_cReadLocks)
    FIELD3(FieldTypeStruct, CSyncShutdown, m_slShutdownLock)
END_FIELD_DESCRIPTOR

BEGIN_STRUCT_DESCRIPTOR
    {"PerfCounters", sizeof(CAQSvrInst), AQCounterInfoFields},
    {"ft", sizeof(FILETIME), CFileTimeFields},

    //CAQSvrInst used to be called CCatMsgQueue
    {"CCatMsgQueue", sizeof(CAQSvrInst), CMQFields},

    STRUCT(CAQSvrInst, CMQFields)
    STRUCT(CConnMgr, ConnMgrFields)
    STRUCT(CDomainMappingTable, DMTFields)
    STRUCT(CDomainEntry, DomainEntryFields)
    STRUCT(CDomainConfigTable, DomainConfigTableFields)
    STRUCT(CInternalDomainInfo, IntDomainInfoFields)
    STRUCT(DomainInfo, DomainInfoFields)
    STRUCT(CMsgRef, MsgRefFields)
    STRUCT(MessageAck, MsgAckFields)
    STRUCT(CDeliveryContext, DeliveryContextFields)
    STRUCT(CSMTPConn, SMTPConnFields)
    STRUCT(DOMAIN_NAME_TABLE_ENTRY, DomainNameTableEntryFields)
    STRUCT(CDestMsgQueue, DestMsgQueueFields)
    STRUCT(CLinkMsgQueue, LinkMsgQueueFields)
    STRUCT(CQuickList, QuickListFields)
    STRUCT(CDSNBuffer, DSNBufferFields)
    STRUCT(CAQQuickTime, AQQuickTimeFields)
    STRUCT(CAsyncQueueBase, AsyncQueueBaseFields)
    STRUCT(CPool, CPoolFields)
    STRUCT(CShareLockNH, CShareLockNHFields)
    STRUCT(CRefCountedString, RSTRFields)
    STRUCT(CAQMsgGuidList, MsgGuidListFields)
    STRUCT(CAQMsgGuidListEntry, MsgGuidListEntryFields)
    STRUCT(CSMTP_RETRY_HANDLER, RetrySinkFields)
    STRUCT(CRETRY_Q, RetryQueueFields)
    STRUCT(CRETRY_HASH_ENTRY, RetryHashFields)
    STRUCT(CAQStats, AQStatsFields)
    STRUCT(CAQAdminMessageFilter, InternalMsgFilterFields)
    STRUCT(MESSAGE_FILTER, MsgFilterFields)
    STRUCT(MESSAGE_ENUM_FILTER, MsgEnumFilterFields)
    STRUCT(LINK_INFO, LinkInfoFields)
    STRUCT(CAQDeferredDeliveryQueue, CAQDeferredDeliveryQueueFields)
    STRUCT(CAQDeferredDeliveryQueueEntry, CAQDeferredDeliveryQueueEntryFields)
    STRUCT(CAsyncWorkQueueItem, CAsyncWorkQueueItemFields)
    STRUCT(CAsyncWorkQueue, CAsyncWorkQueueFields)
    STRUCT(CShareLockInst, CShareLockInstFields)
    STRUCT(CSyncShutdown, CSyncShutdownFields)
END_STRUCT_DESCRIPTOR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\aqdbgext.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdbgext.cpp
//
//  Description: Advanced Queuing Debug Extensions.
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_
#include "aqincs.h"
#ifdef PLATINUM
#include "phatqdbg.h"
#include <ptrwinst.h>
#include <ptntintf.h>
#else
#include "aqdbgext.h"
#include <rwinst.h>
#endif //PLATINUM
#include <aqinst.h>
#include <domhash.h>
#include <destmsgq.h>
#include <linkmsgq.h>
#include <hashentr.h>
#include <fifoqdbg.h>
#include <dsnevent.h>

extern DWORD g_cbClasses;
extern DWORD g_dwFlavorSignature;

BOOL    g_fVersionChecked = FALSE;

#define AQ_MIN(x, y) ((x) > (y) ? (y) : (x))
HANDLE g_hTransHeap;  //Needed for to link because of transmem.h

const DWORD MAX_DOM_PATH_SIZE = 512;

const CHAR    _LINK_STATE_UP[]       = "UP        ";
const CHAR    _LINK_STATE_DOWN[]     = "DOWN      ";
const CHAR    _LINK_STATE_ACTIVE[]   = "ACTIVE    ";
const CHAR    _LINK_STATE_TURN[]     = "TURN      ";
const CHAR    _LINK_STATE_RETRY[]    = "RETRY     ";
const CHAR    _LINK_STATE_DSN[]      = "DSN       ";
const CHAR    _LINK_STATE_SPECIAL[]  = "SPECIAL   ";

#define LINK_STATE_UP       (LPSTR) _LINK_STATE_UP
#define LINK_STATE_DOWN     (LPSTR) _LINK_STATE_DOWN
#define LINK_STATE_ACTIVE   (LPSTR) _LINK_STATE_ACTIVE
#define LINK_STATE_TURN     (LPSTR) _LINK_STATE_TURN
#define LINK_STATE_RETRY    (LPSTR) _LINK_STATE_RETRY
#define LINK_STATE_DSN      (LPSTR) _LINK_STATE_DSN
#define LINK_STATE_SPECIAL  (LPSTR) _LINK_STATE_SPECIAL

//lower case function names
AQ_DEBUG_EXTENSION_IMP(dumpservers) {DumpServers(DebugArgs);}
AQ_DEBUG_EXTENSION_IMP(offsets) {Offsets(DebugArgs);}
AQ_DEBUG_EXTENSION_IMP(dumpdnt) {DumpDNT(DebugArgs);}

AQ_DEBUG_EXTENSION_IMP(Offsets)
{
    dprintf("CDestMsgQueue m_liDomainEntryDMQs - 0x%X\n", FIELD_OFFSET(CDestMsgQueue, m_liDomainEntryDMQs));
    dprintf("CDestMsgQueue m_liEmptyDMQs - 0x%X\n", FIELD_OFFSET(CDestMsgQueue, m_liEmptyDMQs));
    dprintf("CLinkMsgQueue m_liLinks - 0x%X\n", FIELD_OFFSET(CLinkMsgQueue, m_liLinks));
    dprintf("CLinkMsgQueue m_liConnections - 0x%X\n", FIELD_OFFSET(CLinkMsgQueue, m_liConnections));
    dprintf("CAQSvrInst m_liVirtualServers - 0x%X\n", FIELD_OFFSET(CAQSvrInst, m_liVirtualServers));
    dprintf("CRETRY_HASH_ENTRY m_QLEntry - 0x%X\n", FIELD_OFFSET(CRETRY_HASH_ENTRY, m_QLEntry));
    dprintf("CRETRY_HASH_ENTRY m_HLEntry - 0x%X\n", FIELD_OFFSET(CRETRY_HASH_ENTRY, m_HLEntry));
    dprintf("CShareLockInst m_liLocks - 0x%X\n", FIELD_OFFSET(CShareLockInst, m_liLocks));
}



AQ_DEBUG_EXTENSION_IMP(dumpoffsets)
{
    _dumpoffsets(hCurrentProcess, hCurrentThread,
                 dwCurrentPc, pExtensionApis, szArg);
}

//---[ cpoolusage ]------------------------------------------------------------
//
//
//  Description:
//      Dumps the CPool usage for our known CPools.
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      5/31/2000 - Mikeswa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(cpoolusage)
{
    CHAR    rgKnownCPools[][200] = {
//                "pttrace!g_pFreePool",
                "exstrace!g_pFreePool",
//                "phatcat!CPoolBuffer__sm_PoolNHeapBuffersPool",
                "aqueue!CQuickList__s_QuickListPool",
                "aqueue!CSMTPConn__s_SMTPConnPool",
                "aqueue!CMsgRef__s_MsgRefPool",
                "aqueue!CAQMsgGuidListEntry__s_MsgGuidListEntryPool",
                "aqueue!CAsyncWorkQueueItem__s_CAsyncWorkQueueItemPool",
                "aqueue!CRETRY_HASH_ENTRY__PoolForHashEntries",
//                "drviis!CIMsgWrapper__m_CIMsgWrapperPool",
//                "drviis!CQueueItem__m_CQueueItemPool",
                "mailmsg!CBlockMemoryAccess__m_Pool",
                "mailmsg!CMsg__m_Pool",
                "mailmsg!CMailMsgRecipientsAdd__m_Pool",
                "smtpsvc!SMTP_CONNECTION__Pool",
                "smtpsvc!SMTP_CONNOUT__Pool",
                "smtpsvc!CAddr__Pool",
                "smtpsvc!CAsyncMx__Pool",
                "smtpsvc!CAsyncSmtpDns__Pool",
                "smtpsvc!CBuffer__Pool",
                "smtpsvc!CIoBuffer__Pool",
                "smtpsvc!CBlockMemoryAccess__m_Pool",
                "smtpsvc!CDropDir__m_Pool",
                ""
            };

    DWORD    rgdwPool[5];
    DWORD    cTotalBytes = 0;
    DWORD    cCurrentBytes = 0;
    DWORD    cInstanceBytes = 0;
    DWORD    cInstances = 0;
    DWORD    dwSignature = 0;
    CHAR    *pch = NULL;
    DWORD    i = 0;
    PVOID    pvPool = NULL;

    //
    //  Loop over all known pools and display data
    //
    dprintf("Total Bytes\t# Instances \tInstance Size \tSignature\tName\n");
   dprintf("=================================================================\n");
    while (rgKnownCPools[i] && rgKnownCPools[i][0]) {
        pvPool = (PVOID) GetExpression(rgKnownCPools[i]);

        if (!pvPool ||
            !ReadMemory(pvPool, rgdwPool, sizeof(rgdwPool), NULL)) {
            dprintf("Unable to read pool %s at %p\n", rgKnownCPools[i], pvPool);
        } else {
            cInstances = rgdwPool[3];
            cInstanceBytes = rgdwPool[2];
            dwSignature = rgdwPool[0];
            pch = (CHAR *) &dwSignature;
            dprintf("%d\t\t%d\t\t%d\t\t0x%08X\t%s\n",
                cInstanceBytes*cInstances, cInstances,
                cInstanceBytes, rgdwPool[0], rgKnownCPools[i]);
            cTotalBytes += cInstanceBytes*cInstances;
        }
        i++;
   }
   dprintf("=================================================================\n");
   dprintf("\tTotal Bytes = %d\n\n", cTotalBytes);

}

//---[ remotecmd ]------------------------------------------------------------
//
//
//  Description:
//      start a remote cmd window
//  Parameters:
//      name of the pipe
//  Returns:
//      -
//  History:
//      5/31/2000 - AWetmore Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(remotecmd)
{
    char szParameters[1024];
    PROCESS_INFORMATION pi;
    STARTUPINFO si;

    if (!szArg || ('\0' == szArg[0]))
        goto Usage;

    _snprintf(szParameters, 1024, "remote /s cmd %s", szArg);
    dprintf("\nRunning %s\n", szParameters);

    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));

    if (!CreateProcess(NULL,
                       szParameters,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_NEW_CONSOLE,
                       NULL,
                       NULL,
                       &si,
                       &pi))
    {
        dprintf("CreateProcess failed with %u\n", GetLastError());
    } else {
        dprintf("Started process %i\n", pi.dwProcessId);
    }


  Exit:
    dprintf("\n");
    return;

  Usage:
    //
    //  Display usage message
    //
    dprintf("\nUsage:\n");
    dprintf("\tremotecmd <pipename>\n");
    goto Exit;
}


//---[ findbytes ]-------------------------------------------------------------
//
//
//  Description:
//      Searches for a given byte-pattern in a memory address sapce
//  Parameters:
//      Pattern of bytes to search for.  Expected format is a sequence of
//      space separated hex digits.
//  Returns:
//      -
//  History:
//      5/9/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(findbytes)
{
#ifdef WIN64
    const DWORD_PTR cbVMSize = 0xFFFFFFFFFFFFFFFF;
#else //not WIN64
    const DWORD_PTR cbVMSize = 0xFFFFFFFF;
#endif //WIN64
    BYTE        rgbBytesToFind[200];
    LONG        lCurrentValue = 0;
    CHAR        rgchCurrentValue[3] = "00";
    LPSTR       szStop = NULL;
    DWORD_PTR   cBytesToFind = 0;
    DWORD_PTR   cChunksChecked = 0;
    DWORD_PTR   cChunkSize = 0;
    DWORD_PTR   iChunk = 0;
    BYTE        pbChunk[0x1000];
    PBYTE       pbStopAddr = pbChunk + sizeof(pbChunk);
    PBYTE       pbCurrent = NULL;
    DWORD_PTR   cChunks = cbVMSize/sizeof(pbChunk);
    DWORD_PTR   cChunksInPercent = 1;
    DWORD_PTR   pvEffectiveAddressOtherProc = NULL;
    DWORD       cComplaints = 0;
    DWORD       cMemchkMatches = 0;
    DWORD       cFullSigMatches = 0;
    LPCSTR      szCurrentArg = szArg;


    if (!szArg || ('\0' == szArg[0]))
        goto Usage;

    //
    //  Parse command line args
    //
    while (*szCurrentArg)
    {
        //
        //  Loop over whitespace
        //
        while (*szCurrentArg && isspace(*szCurrentArg)) szCurrentArg++;

        //
        //  Make sure we have at least pair of characters as expected
        //
        if (!*(szCurrentArg+1))
            break;

        //
        //  Convert from hex characters to binary
        //
        lCurrentValue = strtol(szCurrentArg, &szStop, 16);
        if ((lCurrentValue > 0xFF) || (lCurrentValue < 0))
            goto Usage;

        //
        //  Copy to our search buffer
        //
        rgbBytesToFind[cBytesToFind] = (BYTE) lCurrentValue;
        cBytesToFind++;

        //
        //  Make sure our search buffer is big enough for the next byte
        //
        if (cBytesToFind >= sizeof(rgbBytesToFind))
        {
            dprintf("Search for max pattern of %d bytes\n", cBytesToFind);
            break;
        }

        szCurrentArg += 2;  //Skip to next known whitespace
    }

    if (!cBytesToFind)
    {
        dprintf("\nYou must specify at least one byte to search for\n");
        goto Usage;
    }

    //
    //  Used to display progress
    //
    cChunksInPercent = cChunks/100;

    //
    //  Calculate memory size for 32-bit machines
    //
    cChunkSize = cbVMSize/cChunks;

    if (cChunkSize < 1024)
    {
        dprintf("ERROR: Chunk size of 0x%p is too small", cChunkSize);
        goto Exit;
    }

    //
    //  Make sure we are cool wrt to buffer size
    //
    if (cChunkSize > sizeof(pbChunk))
    {
        dprintf("ERROR: Chunksize of 0x%p is larger than max size of 0x%p",
                cChunkSize, sizeof(pbChunk));
        goto Exit;
    }

    //
    //  Loop over chunks --
    //      $$REVIEW -  does not find patterns that span 1K chunks...
    //      this is probably OK, since this is an unlikely scenario.  Most
    //      byte patterns will be DWORD (signatures) or pointer sized.
    //
    for (iChunk = 0; iChunk < cChunks; iChunk++)
    {

        //
        //  Check to see if the user pressed ctrl-c
        //
        if (CheckControlC())
        {
            goto Exit;
        }

        //
        //  Give some status
        //
        if ((iChunk % cChunksInPercent) == 0)
            dprintf(".");

        //
        //  Address should be page aligned
        //
        if (((iChunk*cChunkSize) & 0xFFF) && (cComplaints < 100))
        {
            cComplaints++;
            dprintf("0x%p not alligned at index %d", (iChunk*cChunkSize), iChunk);
        }

        //
        //  Do a memory search for the first byte
        //
        if (!ReadMemory(iChunk*cChunkSize, pbChunk, (DWORD)cChunkSize, NULL))
            continue; //on to the next buffer chunk

        //
        //  Now that we have a chunk... look for our sig
        //
        pbCurrent = pbChunk;
        while (pbCurrent < pbStopAddr-cBytesToFind)
        {
            pbCurrent = (PBYTE) memchr(pbCurrent,
                                       rgbBytesToFind[0],
                                       pbStopAddr-pbCurrent);

            //
            //  See if we have a match
            if (!pbCurrent)
                break;

            cMemchkMatches++;

            pvEffectiveAddressOtherProc = iChunk*cChunkSize+(pbCurrent-pbChunk);

            //
            //  See if the full pattern matches
            //
            if (!memcmp(rgbBytesToFind, pbCurrent, cBytesToFind))
            {
                cFullSigMatches++;
                dprintf("\nFound match at 0x%p\n", pvEffectiveAddressOtherProc);
            }

            if (0 != memcmp(rgbBytesToFind, pbCurrent, 1))
            {
                cComplaints++;
                if (cComplaints < 100)
                    dprintf("Messed up %02X %02X - %02X %02X\n",
                        rgbBytesToFind[0], rgbBytesToFind[1],
                        pbCurrent[0], pbCurrent[1]);
            }


            pbCurrent++;

        }

        cChunksChecked++;
    }

    //
    //  Give some summary information
    //
    dprintf("\nChecked 0x%p chunks (%d%%) searching from 0x%p to 0x%p",
            cChunksChecked,
            (DWORD)(100*cChunksChecked/cChunks), NULL,
            cChunkSize*(cChunks+1)-1);
    dprintf("\nFound %d partial matches and %d full matches",
            cMemchkMatches, cFullSigMatches);

  Exit:
    dprintf("\n");
    return;

  Usage:
    //
    //  Display usage message
    //
    if (szCurrentArg && *szCurrentArg)
        dprintf("Error at %s\n", szCurrentArg);

    dprintf("\nUsage:\n");
    dprintf("\tfindbytes <aa> [<bb> ...]\n");
    dprintf("\t\tBytes should be specifed as 2 hexadecimal characters\n");
    dprintf("\nExamples:\n");
    dprintf("\tTo search for the signature \"LMQ \"\n");
    dprintf("\t\tfindbytes %02X %02X %02X %02X\n", 'L', 'M', 'Q', ' ');
    goto Exit;

}


//---[ findsig ]---------------------------------------------------------------
//
//
//  Description:
//      Searches for a given class signature in a memory address sapce
//  Parameters:
//      The Siganature to look for.
//  Returns:
//      -
//  History:
//      5/3/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(findsig)
{
    CHAR    szNewArg[200];
    LPCSTR  szCurrentArg = szArg;
    CHAR    szSig[5] = "    ";
    DWORD   iChar = 0;

    if (!szArg || ('\0' == szArg[0]))
        goto Usage;


    //
    //  Loop over whitespace
    //
    while (*szCurrentArg && isspace(*szCurrentArg)) szCurrentArg++;

    //
    //  Grab the first 4 characters and convert them to binary
    //
    for( iChar = 0; iChar < 4; iChar++)
    {
        if (!szCurrentArg[iChar])
            break;

        szSig[iChar] = szCurrentArg[iChar];
    }

    dprintf("Searching for Signature \"%s\"...\n", szSig);

    sprintf(szNewArg, "%02X %02X %02X %02X", szSig[0], szSig[1], szSig[2], szSig[3]);

    //
    //  Just use the code in findbytes to do the actual search
    //
    dprintf("Calling findbytes %s\n", szNewArg);
    findbytes(hCurrentProcess, hCurrentThread, dwCurrentPc,
                     pExtensionApis, szNewArg);

  Exit:
    return;

  Usage:
    dprintf("\nUsage:\n");
    dprintf("\tfindsig <XXXX>\n");
    goto Exit;

}

//---[ hashthread ]------------------------------------------------------------
//
//
//  Description:
//      Uses the CThreadIdBlock hashing mechanism to return the hashed value
//      for a thread.
//  Parameters:
//      Thread Id to hash
//      Max hash value
//  Returns:
//      -
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(hashthread)
{
    //Arguement should be thread Id
    DWORD dwThreadId = GetCurrentThreadId();
    DWORD dwMax = 1000;
    DWORD dwThreadHash = 0;
    CHAR  szArgBuffer[200];
    LPSTR szCurrentArg = NULL;

    if (!szArg || ('\0' == szArg[0]))
    {
        dprintf("Warning... using default thead id and max\n");
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            dwThreadId = (DWORD)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                dwMax = (DWORD) GetExpression(szCurrentArg);
            else
                dprintf("Warning... using default max hash\n");
        }
    }

    //Try hashing the ID
    dwThreadHash = dwHashThreadId(dwThreadId, dwMax);
    dprintf("Thread Id 0x%0X hashes to index 0x%0X (%d) with max 0x%08X (%d)\n", dwThreadId,
             dwThreadHash, dwThreadHash, dwMax, dwMax);
}

//---[ dumplock ]-------------------------------------------------------------
//
//
//  Description:
//      Dumps all of the information in the CThreadIdBlocks for a given
//      CShareLockInst.
//  Parameters:
//      Address of CShareLockInst
//  Returns:
//      -
//  History:
//      8/9/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dumplock)
{
    BYTE    pbBuffer[sizeof(CShareLockInst)];
    BYTE    pbThreadBlocks[1000*sizeof(CThreadIdBlock)];
    PVOID   pvLock = NULL;
    PVOID   pvNextBlock = NULL;
    CThreadIdBlock  tblkCurrent;
    CThreadIdBlock  *ptblkCurrent = NULL;
    CThreadIdBlock  *ptblkArray = NULL;
    DWORD   cNumBlocks = 0;
    DWORD   iBlock = 0;
    DWORD   cThreads = 0;
    DWORD   cLockCount = 0;
    DWORD   cLockedThreads = 0;
    BOOL    fDisplayedHashHeader = FALSE;

    ZeroMemory(pbBuffer, sizeof(pbBuffer));
    ZeroMemory(pbThreadBlocks, sizeof(pbThreadBlocks));

    if (!szArg || ('\0' == szArg[0]) || !(pvLock = (PVOID) GetExpression(szArg)))
    {
        dprintf("You must specify a lock address\n");
        return;
    }

    //read the whole lock into our buffer
    if (!ReadMemory(pvLock, &pbBuffer, sizeof(pbBuffer), NULL))
    {
        dprintf("Error unable read memory at 0x%0X\n", pvLock);
        return;
    }

    cNumBlocks = ((CShareLockInst *)pbBuffer)->m_cMaxTrackedSharedThreadIDs;
    pvNextBlock = ((CShareLockInst *)pbBuffer)->m_rgtblkSharedThreadIDs;

    if (!cNumBlocks || !pvNextBlock)
    {
        dprintf("Thread tracking is not enabled for this lock");
        return;
    }

    if (cNumBlocks > sizeof(pbThreadBlocks)/sizeof(CThreadIdBlock))
        cNumBlocks = sizeof(pbThreadBlocks)/sizeof(CThreadIdBlock);

    if (!ReadMemory(pvNextBlock, &pbThreadBlocks,
                    cNumBlocks*sizeof(CThreadIdBlock), NULL))
    {
        dprintf("Error, unable to read %d blocks at 0x%0X", cNumBlocks, pvNextBlock);
        return;
    }

    ptblkArray = (CThreadIdBlock *) pbThreadBlocks;
    for (iBlock = 0; iBlock < cNumBlocks; iBlock++ && ptblkArray++)
    {
        ptblkCurrent = ptblkArray;
        fDisplayedHashHeader = FALSE;
        while (ptblkCurrent)
        {
            if (ptblkCurrent != ptblkArray)
            {
                //Read into this process
                if (!ReadMemory(ptblkCurrent, &tblkCurrent,
                    sizeof(CThreadIdBlock), NULL))
                {
                    dprintf("Error reading block at 0x%0X", ptblkCurrent);
                    break;
                }
                ptblkCurrent = &tblkCurrent;
            }

            if (THREAD_ID_BLOCK_SIG != ptblkCurrent->m_dwSignature)
            {
                dprintf("Warning... bad signature on block 0x%0X\n",
                    ((BYTE *)pvNextBlock) + iBlock*sizeof(CThreadIdBlock));
                break;
            }

            //See if this block has any data
            if (THREAD_ID_BLOCK_UNUSED != ptblkCurrent->m_dwThreadId)
            {

                //Only dump info if the recursion count is non-zero
                if (ptblkCurrent->m_cThreadRecursionCount)
                {
                    if (!fDisplayedHashHeader)
                    {
                        fDisplayedHashHeader = TRUE;
                        dprintf("Thread Hash 0x%0X (%d)\n", iBlock, iBlock);
                    }
                    dprintf("%s\tThread 0x%08X has count of %d - Next link of 0x%08X\n",
                        (ptblkCurrent == ptblkArray) ? "+" : "",
                        ptblkCurrent->m_dwThreadId,
                        ptblkCurrent->m_cThreadRecursionCount,
                        ptblkCurrent->m_ptblkNext);

                    cLockedThreads++;
                }

                cThreads++;
                cLockCount += ptblkCurrent->m_cThreadRecursionCount;
            }
            ptblkCurrent = ptblkCurrent->m_ptblkNext;
        }
    }

    dprintf("===================================================================\n");
    dprintf("%d threads with %d total lock count (%d threads holding locks)\n",
            cThreads, cLockCount, cLockedThreads);
}

//---[ workqueue ]-------------------------------------------------------------
//
//
//  Description:
//      Dumps a summary of items in the async work queue
//  Parameters:
//
//  Returns:
//
//  History:
//      9/13/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(workqueue)
{
    SETCALLBACKS();
    const DWORD MAX_COMPLETION_FUNCTIONS = 10;
    PVOID   rgpvFnName[MAX_COMPLETION_FUNCTIONS];
    DWORD   rgcFnCount[MAX_COMPLETION_FUNCTIONS];
    BYTE    pbWorkItem[sizeof(CAsyncWorkQueueItem)];
    PVOID   pvQueue = NULL;
    PVOID   pvWorkItem = NULL;
    PVOID   pvFn = NULL;
    DWORD   i = 0;
    DWORD   cItems = 0;
    UCHAR   SymbolName[ 200 ];
    ULONG_PTR Displacement;
    CFifoQueueDbgIterator fifoqdbg(pExtensionApis);

    ZeroMemory(&rgpvFnName, sizeof(rgpvFnName));
    ZeroMemory(&rgcFnCount, sizeof(rgcFnCount));
    ZeroMemory(&pbWorkItem, sizeof(pbWorkItem));
    ZeroMemory(&SymbolName, sizeof(SymbolName));

    if (!szArg || ('\0' == szArg[0]) ||
        !(pvQueue = (PVOID) GetExpression(szArg)))
    {
        dprintf("You must specify a queue address\n");
        return;
    }


    //Get FifoqOffset
    pvQueue = (PVOID) &(((CAsyncWorkQueue *)pvQueue)->m_asyncq.m_fqQueue);

    if (!fifoqdbg.fInit(hCurrentProcess, pvQueue))
    {
        dprintf("Error initializing queue iterator for address 0x%08X\n", pvQueue);
        return;
    }

    while (pvWorkItem = fifoqdbg.pvGetNext())
    {
        cItems++;
        if (!ReadMemory(pvWorkItem, &pbWorkItem, sizeof(pbWorkItem), NULL))
        {
            dprintf("Error reading memory at  0x%0X\n", pvWorkItem);
            continue;
        }

        pvFn = ((CAsyncWorkQueueItem *)pbWorkItem)->m_pfnCompletion;

        for (i = 0; i < MAX_COMPLETION_FUNCTIONS; i++)
        {
            if (pvFn == rgpvFnName[i])
            {
                rgcFnCount[i]++;
                break;
            }
            else if (!rgpvFnName[i])
            {
                rgpvFnName[i] = pvFn;
                rgcFnCount[i] = 1;
                break;
            }
        }
    }

    dprintf("# Calls\t| Address\t\t| Function Name\n");
    dprintf("------------------------------------------------------------\n");
    for (i = 0; i < MAX_COMPLETION_FUNCTIONS; i++)
    {
        if (!rgpvFnName[i])
            break;

        g_lpGetSymbolRoutine( rgpvFnName[i], (PCHAR)SymbolName, &Displacement );
        dprintf( "%d\t| 0x%08X\t| %s\n", rgcFnCount[i], rgpvFnName[i], SymbolName);
    }
    dprintf("------------------------------------------------------------\n");
    dprintf("Total %d pending work queue items\n", cItems);

#ifdef NEVER
    //Dump fifoqdbg
    dprintf("CFifoQueueDbgIterator: page %d, index %d, pages %d\n ",
        fifoqdbg.m_iCurrentPage, fifoqdbg.m_iCurrentIndexInPage,
        fifoqdbg.m_cPagesLoaded);
#endif
}

//---[ dumpqueue ]-------------------------------------------------------------
//
//
//  Description:
//      Dumps the *entire* contents of a queue
//  Parameters:
//      szArg
//          - String-ized address of CFifoQ to dump
//          - [optional] msg to search for
//  Returns:
//      -
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION(dumpqueue)
{
    const   DWORD   cStoppingRule = 10000;
    CQueueDbgIterator qdbg(pExtensionApis);
    BYTE    pbMsgRef[sizeof(CMsgRef)];
    PVOID   pvMsgRef = NULL;
    PVOID   pvMailMsg = NULL;
    PVOID   pvQueue = NULL;
    DWORD   cItems = 0;
    BOOL    fIsMsgRef = FALSE;
    CHAR    szArgBuffer[200];
    LPSTR   szCurrentArg = NULL;
    PVOID   pvSearch = NULL;
    DWORD   cMatchSearch = 0;

    if (!szArg || ('\0' == szArg[0]))
    {
        dprintf("You must specify a queue address\n");
        return;
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            pvQueue = (PVOID)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                pvSearch = (PVOID) GetExpression(szCurrentArg);
        }
        else
        {
            pvQueue = (PVOID) GetExpression(szArg);
        }

    }

    if (!pvQueue)
    {
        dprintf("You must specify a queue address\n");
        return;
    }

    if (!qdbg.fInit(hCurrentProcess, pvQueue))
    {
        dprintf("Unable to get the a queue for address 0x%X\n", pvQueue);
        return;
    }

    while ((pvMsgRef = qdbg.pvGetNext()) && (cItems++ < cStoppingRule))
    {
        fIsMsgRef = FALSE;
        if (cItems > qdbg.cGetCount())
        {
            cItems--;
            break;
        }


        //Try to read it as a CMsgRef
        if (ReadMemory(pvMsgRef, pbMsgRef, sizeof(pbMsgRef), NULL))
        {
            if (MSGREF_SIG == ((CMsgRef *)pbMsgRef)->m_dwSignature)
            {
                fIsMsgRef = TRUE;
                pvMailMsg = ((CMsgRef *)pbMsgRef)->m_pIMailMsgProperties;
            }
        }

        //Print it out if it matches our search (or we have no search)
        if (!pvSearch || (pvSearch == pvMsgRef) || (pvSearch == pvMailMsg))
        {
            cMatchSearch++;
            if (pvSearch)
                dprintf("\n****\n");

            if (fIsMsgRef)
                dprintf("\t0x%08X\t0x%08X\n", pvMsgRef, pvMailMsg);
            else
                dprintf("\t0x%08X\n", pvMsgRef);

            if (pvSearch)
                dprintf("****\n\n");
        }

    }

    if (pvSearch)
       dprintf("Found %d matches to search\n", cMatchSearch);
}

//---[ displaytickcount ]------------------------------------------------------
//
//
//  Description:
//      Converts a tick count to a readable time
//  Parameters:
//      szArg - String-ized tick count in hex
//  Returns:
//      -
//  History:
//      10/29/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(displaytickcount)
{
    DWORD   dwTickCountToDisplay = (DWORD)GetExpression(szArg);
    DWORD   dwCurrentTickCount = GetTickCount();
    DWORD   dwTickDifference = dwCurrentTickCount - dwTickCountToDisplay;
    FILETIME    ftCurrentUTC;
    FILETIME    ftDisplayUTC;
    FILETIME    ftDisplayLocal;
    ULARGE_INTEGER uliTimeAdjust;
    SYSTEMTIME  stDisplayLocal;

    static char  *s_rgszMonth[ 12 ] =
    {
        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
    };

    static char *s_rgszWeekDays[7] =
    {
        "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
    };

    GetSystemTimeAsFileTime(&ftCurrentUTC);

    //Adjust the current filetime to local
    memcpy(&uliTimeAdjust, &ftCurrentUTC, sizeof(FILETIME));
    uliTimeAdjust.QuadPart -= (((ULONGLONG)dwTickDifference)*((ULONGLONG)10000));
    memcpy(&ftDisplayUTC, &uliTimeAdjust, sizeof(FILETIME));

    FileTimeToLocalFileTime(&ftDisplayUTC, &ftDisplayLocal);

    ZeroMemory(&stDisplayLocal, sizeof(stDisplayLocal));
    FileTimeToSystemTime(&ftDisplayLocal, &stDisplayLocal);

    dprintf("\n%s, %d %s %04d %02d:%02d:%02d (localized)\n",
            s_rgszWeekDays[stDisplayLocal.wDayOfWeek],
            stDisplayLocal.wDay, s_rgszMonth[ stDisplayLocal.wMonth - 1 ],
            stDisplayLocal.wYear, stDisplayLocal.wHour,
            stDisplayLocal.wMinute, stDisplayLocal.wSecond);

}

//---[ queueusage ]------------------------------------------------------------
//
//
//  Description:
//      Dumps the usage count averages for a given fifoq.  If we are dumping
//      CMsgRefs, it will dump the pointers to the various MailMsg interfaces
//      as well.
//  Parameters:
//      szArg   String-ized address of CFifoQ to dump
//  Returns:
//      -
//  History:
//      10/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(queueusage)
{
    const   DWORD   cbUsageCountOffset = 0x20;
    const   DWORD   cbContentHandleOffset = 0x90+cbUsageCountOffset;
    const   DWORD   cbStreamHandleOffset = 0x8+cbContentHandleOffset;
    const   DWORD   cStoppingRule = 10000;
    const   DWORD   cMaxUsageCountToTrack = 6;
    CFifoQueueDbgIterator fifoqdbg(pExtensionApis);
    BYTE    pbMsgRef[4*sizeof(CMsgRef)]; //leave room for bitmaps
    BYTE    pbMailMsg[cbStreamHandleOffset+sizeof(PVOID)];
    PVOID   pvMsgRef = NULL;
    PVOID   pvMailMsg = NULL;
    PVOID   pvQueue = NULL;
    DWORD   cItems = 0;
    DWORD   cCurrentUsageCount = 0;
    DWORD   cTotalUsageCount = 0;
    DWORD   cMaxUsageCount = 0;
    DWORD   cMinUsageCount = 200;
    DWORD   rgcUsageCounts[cMaxUsageCountToTrack];
    PVOID   pvHandle = NULL;
    DWORD   cMsgsWithOpenContentHandles = 0;
    DWORD   cMsgsWithOpenStreamHandles = 0;
    BOOL    fVerbose = FALSE;

    ZeroMemory(rgcUsageCounts, sizeof(rgcUsageCounts));

    if (!szArg || ('\0' == szArg[0]) ||
        !(pvQueue = (PVOID) GetExpression(szArg)))
    {
        dprintf("You must specify a queue address\n");
        return;
    }

    if (!fifoqdbg.fInit(hCurrentProcess, pvQueue))
    {
        dprintf("Unable to get the a queue for address 0x%X\n", pvQueue);
        return;
    }

    while ((pvMsgRef = fifoqdbg.pvGetNext()) && (cItems++ < cStoppingRule))
    {
        if (cItems > fifoqdbg.cGetCount())
        {
            cItems--;
            break;
        }

        //Read CMsgRef into this process
        if (!ReadMemory(pvMsgRef, pbMsgRef, sizeof(pbMsgRef), NULL))
        {
            dprintf("Unable to read MsgRef at address 0x%X, index %d\n",
                    pvMsgRef, cItems);
            cItems--;
            break;
        }

        //Get inteface ptr for mailmsg from CMsgRef
        pvMailMsg = ((CMsgRef *)pbMsgRef)->m_pIMailMsgQM;

        if (!ReadMemory(pvMailMsg, pbMailMsg, sizeof(pbMailMsg), NULL))
        {
            dprintf("Unable to read MailMsg Ptr at address 0x%X for MsgRef 0x%X, index %d\n",
                    pvMailMsg, pvMsgRef, cItems);
            cItems--;
            break;
        }

        //Check and see if this message has a content (P2) handle open
        if (*(pbMailMsg + cbContentHandleOffset))
            cMsgsWithOpenContentHandles++;

        //Check and see if this message has a stream (P1) handle open
        if (*(pbMailMsg + cbStreamHandleOffset))
            cMsgsWithOpenStreamHandles++;

        if (fVerbose &&
            ((*(pbMailMsg + cbStreamHandleOffset)) ||
             (*(pbMailMsg + cbStreamHandleOffset))))
        {
            dprintf("Message at address 0x%X has open handles\n", pvMsgRef);
        }

        cCurrentUsageCount = (DWORD) *(pbMailMsg + cbUsageCountOffset);
        cTotalUsageCount += cCurrentUsageCount;

        if (cCurrentUsageCount > cMaxUsageCount)
            cMaxUsageCount = cCurrentUsageCount;

        if (cCurrentUsageCount < cMinUsageCount)
            cMinUsageCount = cCurrentUsageCount;

        if (cCurrentUsageCount >= cMaxUsageCountToTrack)
        {
            dprintf("\n****\n");
            dprintf("High usage count of %d found on MailMsg 0x%X, MsgRef 0x%X, item %d\n",
                    cCurrentUsageCount, pvMailMsg, pvMsgRef, cItems);
            dprintf("\n****\n");
            cCurrentUsageCount = cMaxUsageCountToTrack-1;
        }

        //Save count for summaries
        rgcUsageCounts[cCurrentUsageCount]++;
    }

    //Generate and display summary information
    if (!cItems)
    {
        dprintf("No Messages found in queue 0x%X\n", pvQueue);
    }
    else
    {
        dprintf("\n==================================================================\n");
        dprintf("Usage Count Summary\n");
        dprintf("------------------------------------------------------------------\n");
        dprintf("\t%d\t\tTotal Message\n", cItems);
        dprintf("\t%d\t\tTotal Messages with open content handles\n", cMsgsWithOpenContentHandles);
        dprintf("\t%d\t\tTotal Messages with open stream handles\n", cMsgsWithOpenStreamHandles);
        dprintf("\t%d\t\tTotal Usage Count\n", cTotalUsageCount);
        dprintf("\t%d\t\tMax Usage Count\n", cMaxUsageCount);
        dprintf("\t%d\t\tMin Usage Count\n", cMinUsageCount);
        dprintf("\t%f\tAverage Usage Count\n", ((float)cTotalUsageCount)/((float)cItems));
        for (DWORD i = 0; i < cMaxUsageCountToTrack-1; i++)
        {
            dprintf("\t%d\t\tMessages with Usage count of %d\n", rgcUsageCounts[i], i);
        }
        dprintf("\t%d\t\tMessages with Usage count of %d or greater\n",
            rgcUsageCounts[cMaxUsageCountToTrack-1], cMaxUsageCountToTrack-1);
        dprintf("==================================================================\n");
    }
}

//---[ dmqusage ]--------------------------------------------------------------
//
//
//  Description:
//      Debugger extension that wraps the queue usage debugger extension
//      to display the usage counts for all queues
//  Parameters:
//      szArg   String-ized address of DMQ to dump
//  Returns:
//      -
//  History:
//      10/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dmqusage)
{
    PVOID   pvQueue = NULL;
    PVOID   pvDMQ = NULL;
    BYTE    pbDMQ[sizeof(CDestMsgQueue)];
    CHAR    szQueueAddress[30];
    DWORD   iQueue = 0;

    if (!szArg || ('\0' == szArg[0]) ||
        !(pvDMQ = (PVOID) GetExpression(szArg)))
    {
        dprintf("You must specify a queue address\n");
        return;
    }

    if (!ReadMemory(pvDMQ, pbDMQ, sizeof(pbDMQ), NULL))
    {
        dprintf("Unable to read DMQ at address 0x%X\n", pvDMQ);
        return;
    }

    dprintf("\n\n******************************************************************\n");
    dprintf("Start USAGE COUNT STATS for DMQ 0x%0X\n", pvDMQ);
    dprintf("******************************************************************\n");

    for (iQueue = 0; iQueue < NUM_PRIORITIES; iQueue++)
    {
        pvQueue = ((CDestMsgQueue *)pbDMQ)->m_rgpfqQueues[iQueue];
        if (!pvQueue)
            continue;  //nothing as every been queued to this queue

        //Only display the queue if we think we have messages
        //$$TODO - We could actual read this queue into memory and check it,
        //but since we currently only support 1 priority, this will do.
        if (((CDestMsgQueue *)pbDMQ)->m_aqstats.m_cMsgs ||((CDestMsgQueue *)pbDMQ)->m_aqstats.m_cRetryMsgs)
        {
            wsprintf(szQueueAddress, "0x%X", pvQueue);
            queueusage(hCurrentProcess, hCurrentThread, dwCurrentPc,
                        pExtensionApis, szQueueAddress);
        }
    }

    //Display retry queue, if there are messages there
    if (((CDestMsgQueue *)pbDMQ)->m_fqRetryQueue.m_cQueueEntries)
    {
        pvQueue = ((PBYTE)pvDMQ) + FIELD_OFFSET(CDestMsgQueue, m_fqRetryQueue);
        wsprintf(szQueueAddress, "0x%X", pvQueue);
        queueusage(hCurrentProcess, hCurrentThread, dwCurrentPc,
                    pExtensionApis, szQueueAddress);
    }

    dprintf("\n\n******************************************************************\n");
    dprintf("End USAGE COUNT STATS for DMQ 0x%0X\n", pvDMQ);
    dprintf("******************************************************************\n");
}

//---[ dntusage ]--------------------------------------------------------------
//
//
//  Description:
//      Debugger extension that wrap dmqusage.  Call dmqusage for every DMQ
//      in the DNT.
//  Parameters:
//      szArg   string-ize address of dnt (DOMAIN_NAME_TABLE)
//  Returns:
//      -
//  History:
//      10/15/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dntusage)
{
    BYTE  pbBuffer[sizeof(DOMAIN_NAME_TABLE)];
    PDOMAIN_NAME_TABLE pdnt = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntryRealAddress = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pPathEntry = NULL;
    BYTE  pbEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)];
    CHAR  pBuffer[MAX_DOM_PATH_SIZE] = "Root Entry";
    LPSTR pEntryBuffer = NULL;
    LPSTR pEntryBufferStop = NULL;
    DWORD dwLength = 0;
    DWORD dwSig = 0;
    CHAR  szFinalDest[MAX_DOM_PATH_SIZE];
    BYTE  pbDomainEntry[sizeof(CDomainEntry)];
    CDomainEntry  *pdentry = (CDomainEntry *) pbDomainEntry;
    CHAR  szDMQAddress[30];
    DWORD cQueuesPerEntry = 0;
    DWORD cMaxQueuesPerEntry = 1000;
    PLIST_ENTRY pliHead = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    LIST_ENTRY liCurrent;


    //Define buffers for parsing addresses... the sizes are clearly overkill, and
    //I'm not too worried about overflow in a debugger extension
    CHAR                        szAddress[MAX_DOM_PATH_SIZE];
    CHAR                        szDumpArg[MAX_DOM_PATH_SIZE] = "";
    LPSTR                       szParsedArg = (LPSTR) szArg;
    LPSTR                       szCurrentDest = NULL;

    //Allow people who are used to typeing dump CFoo@Address... keep using the @ sign
    if ('@' == *szParsedArg)
        szParsedArg++;

    //Get Address of DomainNameTable
    szCurrentDest = szAddress;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szParsedArg-szArg <= MAX_DOM_PATH_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '\0';


    //Eat white space
    while (('\0' != *szParsedArg) && isspace(*szParsedArg))
        szParsedArg++;

    //Copy name of struct to dump at each node
    szCurrentDest = szDumpArg;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szCurrentDest-szDumpArg <= MAX_DOM_PATH_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '@';
    szCurrentDest++;  //szCurrentDest now points to place to copy address to

    pdnt = (PDOMAIN_NAME_TABLE) GetExpression(szAddress);

    if (!pdnt)
    {
        dprintf("ERROR: Unable to Get DOMAIN_NAME_TABLE from argument %s\n", szArg);
        return;
    }

    if (!ReadMemory(pdnt, pbBuffer, sizeof(DOMAIN_NAME_TABLE), NULL))
    {
        dprintf("ERROR: Unable to read process memory\n");
        return;
    }

    pdnt = (PDOMAIN_NAME_TABLE)pbBuffer;
    pEntry = &(pdnt->RootEntry);

    while(pEntry)
    {
        //We are not interested in wildcard data
        if (pEntry->pData)
        {
            //Display link state information
            if (!ReadMemory(pEntry->pData, pbDomainEntry, sizeof(CDomainEntry), NULL))
            {
                dprintf("ERROR: Unable to read domain entry from @0x%08X\n", pEntry->pData);
                return;
            }

            pliHead = (PLIST_ENTRY) (((BYTE *)pEntry->pData) + FIELD_OFFSET(CDomainEntry, m_liDestQueues));
            pliCurrent = pdentry->m_liDestQueues.Flink;

            //Get final destination string
            if (!ReadMemory(pdentry->m_szDomainName, szFinalDest, pdentry->m_cbDomainName, NULL))
            {
                dprintf("ERROR: Unable to read final destination name from @0x%08X\n",
                        pdentry->m_szDomainName);
                return;
            }

            szFinalDest[pdentry->m_cbDomainName] = '\0';

            //Loop and display each DMQ
            cQueuesPerEntry = 0;
            while (pliHead != pliCurrent)
            {
                cQueuesPerEntry++;

                if (cQueuesPerEntry > cMaxQueuesPerEntry)
                {
                    dprintf("ERROR: More than %d queues for this entry\n", cQueuesPerEntry);
                    return;
                }
                if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read link LIST_ENTRY @0x%08X\n", pliCurrent);
                    return;
                }

                wsprintf(szDMQAddress, "0x%X",
                  CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs));
                dmqusage(hCurrentProcess, hCurrentThread, dwCurrentPc,
                        pExtensionApis, szDMQAddress);

                pliCurrent = liCurrent.Flink;
            }
        }


        //Now determine what the "next" entry is
        if (pEntry->pFirstChildEntry != NULL)
        {
            pEntryRealAddress = pEntry->pFirstChildEntry;
        }
        else if (pEntry->pSiblingEntry != NULL)
        {
            pEntryRealAddress = pEntry->pSiblingEntry;
        }
        else
        {
            for (pEntryRealAddress = pEntry->pParentEntry;
                    pEntryRealAddress != NULL;
                        pEntryRealAddress = pEntry->pParentEntry)
            {
                //must read parent entry into our buffer
                if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory of parent domain entry 0x%08X\n", pEntryRealAddress);
                    pEntry = NULL;
                    break;
                }
                pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;

                if (pEntry->pSiblingEntry != NULL)
                    break;

            }
            if (pEntry != NULL)
            {
                pEntryRealAddress = pEntry->pSiblingEntry;
            }
        }

        if (pEntryRealAddress)
        {
            if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
            {
                dprintf("ERROR: Unable to read process memory on domain entry 0x%08X\n",
                    pEntryRealAddress);
                pEntry = NULL;
                break;
            }
            pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;
        }
        else
        {
            pEntry = NULL;
        }
    }
}

//---[ walkcpool ]-------------------------------------------------------------
//
//
//  Description:
//      Will walk a given CPool object.  Validate headers, and dump currently
//      used objects.
//
//      ***NOTE*** This version only works on DBG CPool implementations (since
//      RTL does not have the headerinfo).  I could write a more complex
//      version that checks and sees if this each pool object is in the
//      freelist, but I will leave that as an exercise to the reader.
//  Parameters:
//      szArg   - String containing arguments
//          Address of CPool object to dump
//          Offset of additional address to dump
//  Returns:
//      -
//  History:
//      9/30/1999 - MikeSwa Created
//
#define HEAD_SIGNATURE  (DWORD)'daeH'
#define TAIL_SIGNATURE  (DWORD)'liaT'

#define FREE_STATE      (DWORD)'eerF'
#define USED_STATE      (DWORD)'desU'
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(walkcpool)
{
    PVOID   pvCPool = NULL;
    DWORD   cbCPoolData = 0;
    DWORD   cCommited = 0;
    DWORD   cFragments = 0;
    DWORD   cBuffersPerFragment = 0;
    DWORD   iCurrentBufferInFragment = 0;
    DWORD   iCurrentFragment = 0;
    PVOID  *pvFragment = NULL;
    PVOID   pvCPoolData = NULL;
    BYTE    pbCPoolBuffer[sizeof(CPool)];
    BYTE    pbCPoolDataBuffer[100];
    LPSTR   szCurrentArg = NULL;
    CHAR    szArgBuffer[200];
    DWORD_PTR cbOffset = 0;
    DWORD_PTR dwptrData = 0;

    if (!szArg || ('\0' == szArg[0]))
    {
        dprintf("You must specify a Pool address\n");
        return;
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            pvCPool = (PVOID)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                cbOffset = (DWORD_PTR) GetExpression(szCurrentArg);
        }
        else
        {
            pvCPool = (PVOID) GetExpression(szArg);
        }

    }

    if (!ReadMemory(pvCPool, pbCPoolBuffer, sizeof(CPool), NULL))
    {
        dprintf("Unable to read memory at 0x%x\n", pvCPool);
        return;
    }

    dprintf("Dumping CPool at address 0x%08X\n", pvCPool);

    //Get interesting values from CPool
    cbCPoolData = *((PDWORD)(pbCPoolBuffer + 0x8));
    cCommited = *((PDWORD)(pbCPoolBuffer + 0xc));
    cFragments =  *((PDWORD)(pbCPoolBuffer + 0x54));
    cBuffersPerFragment = *((PDWORD)(pbCPoolBuffer + 0x50));

    dprintf("CPool data size is %d bytes (0x%x)\n", cbCPoolData, cbCPoolData);
    dprintf("CPool fragment count is %d\n", cFragments);
    dprintf("CPool has %d buffers per fragment\n", cBuffersPerFragment);
    dprintf("CPool has %d commited buffers\n", cCommited);

    if (!cbCPoolData)
    {
        dprintf("Invalid CPool\n");
        return;
    }

    //Loop over the fragment and dump each one
    pvFragment = (PVOID *) (pbCPoolBuffer + 0x58);
    for (iCurrentFragment = 0;
         iCurrentFragment < cFragments;
         iCurrentFragment++ || pvFragment++)
    {
        pvCPoolData = *pvFragment;

        if (!pvCPoolData)
            continue;

        dprintf("CPool Fragment #%d at 0x%08X\n", iCurrentFragment, pvCPoolData);

        for (iCurrentBufferInFragment = 0;
             iCurrentBufferInFragment < cBuffersPerFragment;
             iCurrentBufferInFragment++)
        {
            if (!ReadMemory(pvCPoolData, pbCPoolDataBuffer, 100, NULL))
            {
                dprintf("\tUnable to read CPool buffer data at 0x%x\n", pvCPoolData);
                break;
            }

            if (HEAD_SIGNATURE != ((DWORD *)pbCPoolDataBuffer)[1])
            {
                dprintf("\tHit bad signature at 0x%08X\n", pvCPoolData);
                break; //bad signature bail
            }

            if (USED_STATE == ((DWORD *)pbCPoolDataBuffer)[2])
            {
                dprintf("\tAllocated block found at offset %d (0x%08X)\n",
                        iCurrentBufferInFragment, pvCPoolData);
                if (cbOffset)
                {
                    if (ReadMemory(((PBYTE)pvCPoolData)+cbOffset, &dwptrData,
                                sizeof(DWORD_PTR), NULL))
                    {
                        dprintf("\t\tData 0x%X found at address 0x%X\n",
                            dwptrData, ((PBYTE)pvCPoolData)+cbOffset);
                    }
                }
            }
            pvCPoolData = ((BYTE *)pvCPoolData) + cbCPoolData;

            if (!(--cCommited))
            {
                dprintf("\tLast block is in fragment at offset %d (0x%08X)\n",
                    iCurrentBufferInFragment, pvCPoolData);
                break; //We're done
            }
        }
    }

}

//---[ CheckVersion ]----------------------------------------------------------
//
//
//  Description:
//      Checks the AQ version to make sure that this debugger extension will
//      work with it.
//  Parameters:
//
//  Returns:
//
//  History:
//      2/5/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(CheckVersion)
{
    DWORD   cbAQClasses = 0;
    DWORD   dwAQFlavorSignature = '    ';
    PVOID   pcbAQClasses = (PVOID) GetExpression("aqueue!g_cbClasses");
    PVOID   pdwAQFlavorSignature = (PVOID) GetExpression("aqueue!g_dwFlavorSignature");
    PCHAR   pch = NULL;

    //Read the version information stamped in AQ
    ReadMemory(pcbAQClasses, &cbAQClasses, sizeof(DWORD), NULL);
    ReadMemory(pdwAQFlavorSignature, &dwAQFlavorSignature, sizeof(DWORD), NULL);

    if (!g_fVersionChecked)
    {
        dprintf("AQueue Internal Version Info (#'s should match):\n");
        pch = (PCHAR) &g_dwFlavorSignature;
        dprintf("\taqdbgext %c%c%c%c 0x%08X\n",  *(pch), *(pch+1), *(pch+2), *(pch+3), g_cbClasses);
        pch = (PCHAR) &dwAQFlavorSignature;
        dprintf("\taqueue    %c%c%c%c 0x%08X\n\n",  *(pch), *(pch+1), *(pch+2), *(pch+3), cbAQClasses);
    }

    g_fVersionChecked = FALSE;
    if (dwAQFlavorSignature != g_dwFlavorSignature)
        dprintf("\n\nWARNING: DBG/RTL aqueue.dll & aqdbgext.dll mismatch\n\n");
    else if (g_cbClasses != cbAQClasses)
        dprintf("\n\nWARNING: aqueue.dll & aqdbgext.dll version mismatch\n\n");
    else
        g_fVersionChecked = TRUE;

}

//---[ DumpServers ]------------------------------------------------------------
//
//
//  Description:
//      Dumps pointers to the CAQSvrInst for each virtual server
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(DumpServers)
{
    PVOID pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    DWORD *pcInstances = (DWORD *) GetExpression("aqueue!g_cInstances");
    DWORD cInstances = 0;
    LIST_ENTRY liCurrent;
    BYTE  pbBuffer[sizeof(CAQSvrInst)];
    CAQSvrInst *paqinst = (CAQSvrInst *) pbBuffer;
    PVOID pCMQAddress = NULL;
    DWORD dwInstance = 0;
    CHAR  szDumpArg[40] = "";
    CHAR  szArgBuffer[200];
    LPSTR szCurrentArg = NULL;

    CheckVersion(DebugArgs);
    if (!szArg || ('\0' == szArg[0]))
    {
        dwInstance = 0;
        pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            dwInstance = (DWORD)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                pvListHead = (PVOID) GetExpression(szCurrentArg);
            else
                pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
        }
    }

    if (!pvListHead)
    {
        dprintf("ERROR: Unable to determine LIST_ENTRY for virtual servers\n");
        dprintf("  If you are using windbg, you should specify the value as the\n");
        dprintf("  2nd argument.  You can determine the address value by typeing:\n");
        dprintf("      x " AQUEUE_VIRTUAL_SERVER_SYMBOL "\n");
        dprintf("  You may also have bad symbols for aqueue.dll.\n");
        return;
    }

    if (!ReadMemory(pvListHead, &liCurrent, sizeof(LIST_ENTRY), NULL))
    {
        dprintf("ERROR: Unable to read entry @ aqueue!g_liVirtualServers 0x%08X", pvListHead);
        return;
    }

    if (!ReadMemory(pcInstances, &cInstances, sizeof(DWORD), NULL))
    {
        //For you windbg users out there
        dprintf("\n\n%Virtual Server Instance(s)\n\n");
    }
    else
    {
        dprintf("\n\n%d Virtual Server Instance(s)\n\n", cInstances);
    }

    dprintf("Class@Address              Server Instance\n");
    dprintf("==========================================\n");
    while (liCurrent.Flink != pvListHead)
    {
        pCMQAddress = CONTAINING_RECORD(liCurrent.Flink, CAQSvrInst, m_liVirtualServers);


        if (!ReadMemory(pCMQAddress, paqinst, sizeof(CAQSvrInst), NULL))
        {
            dprintf("ERROR: Unable to CAQSvrInst @0x%08X", pCMQAddress);
            return;
        }

        if (CATMSGQ_SIG != paqinst->m_dwSignature)
        {
            dprintf("@0x%08X INVALID SIGNATURE - list entry @0x%08X\n", pCMQAddress, liCurrent.Flink);
        }
        else
        {
            dprintf("CAQSvrInst@0x%08X    %d\n", pCMQAddress, paqinst->m_dwServerInstance);
            if (paqinst->m_dwServerInstance == dwInstance)
                wsprintf(szDumpArg, "CAQSvrInst@0x%08X", pCMQAddress);
        }


        if (!ReadMemory(liCurrent.Flink, &liCurrent, sizeof(LIST_ENTRY), NULL))
        {
            dprintf("ERROR: Unable to read entry @0x%08X", liCurrent.Flink);
            return;
        }


    }

    //Dump the interesting instance
    if ('\0' != szDumpArg[0])
        _dump(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szDumpArg);

}

//---[ handlemgmt ]------------------------------------------------------------
//
//
//  Description:
//      Caclulates a handle management score for a given virtual server.
//
//      Calculates score based on the number of messages closed and messages
//          delivered / pending delivery... the lower the score... the better.
//      Score = Closes /
//          (m_cCurrentMsgsPendingSubmit + m_cCurrentMsgsPendingCat*2 +
//           m_cCurrentMsgsPendingRouting*3 + m_cCurrentMsgsPendingLocal*4 +
//           m_cMsgsDeliveredLocal*5)
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(handlemgmt)
{
    #define MAILMSG_CLOSES_SYMBOL \
        "mailmsg!CMailMsg__g_cTotalExternalReleaseUsageZero"

    #define MAILMSG_CURRENT_CLOSED_SYMBOL \
        "mailmsg!CMailMsg__g_cCurrentMsgsClosedByExternalReleaseUsage"

    #define MAILMSG_CURRENT_ALLOCATED \
        "mailmsg!CMsg__m_Pool+0x10"

    #define MAILMSG_TOTAL_ALLOCATED \
        "mailmsg!CMsg__m_Pool+0x3c"

    PVOID pvCloses  = (PVOID) GetExpression(MAILMSG_CLOSES_SYMBOL);
    DWORD cCloses = 1;
    PVOID pvCurrentMsgsThatHaveBeenClosed  = (PVOID) GetExpression(MAILMSG_CURRENT_CLOSED_SYMBOL);
    DWORD cCurrentMsgsThatHaveBeenClosed = 1;
    PVOID pvCurrentMsgsAllocated  = (PVOID) GetExpression(MAILMSG_CURRENT_ALLOCATED);
    DWORD cCurrentMsgsAllocated = 1;
    PVOID pvTotalMsgsAllocated  = (PVOID) GetExpression(MAILMSG_TOTAL_ALLOCATED);
    DWORD cTotalMsgsAllocated = 1;
    DWORD dwPercentCurrentMessagesClosed = 0;
    DWORD dwPercentTotalMessagesBacklogged = 0;
    DWORD dwPercentCurrentMessagesQueueInternally = 0;
    PVOID pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    DWORD *pcInstances = (DWORD *) GetExpression("phatq!g_cInstances");
    DWORD cInstances = 0;
    LIST_ENTRY liCurrent;
    BYTE  pbBuffer[sizeof(CAQSvrInst)];
    CAQSvrInst *paqinst = (CAQSvrInst *) pbBuffer;
    PVOID pCMQAddress = NULL;
    DWORD dwInstance = 1;
    CHAR  szDumpArg[40] = "";
    CHAR  szArgBuffer[200];
    LPSTR szCurrentArg = NULL;
    DWORD dwQueueScore = 0;
    DWORD dwWeightedScore = 0;
    DWORD dwDeliveredScore = 0;
    DWORD dwSubmittedScore = 0;
    DWORD dwWeightedQueueLength = 0;
    DWORD dwTotalQueueLength = 0;
    BOOL  fFoundInstance = FALSE;


    //
    //  Read the data we need from mailmsg
    //
    if (!ReadMemory(pvCloses, &cCloses, sizeof(cCloses), NULL))
    {
        dprintf("Unable to read %s at address %p\n",
            MAILMSG_CLOSES_SYMBOL, pvCloses);
        return;
    }

    if (!ReadMemory(pvCurrentMsgsThatHaveBeenClosed,
          &cCurrentMsgsThatHaveBeenClosed, sizeof(cCloses), NULL))
    {
        dprintf("Unable to read %s at address %p\n",
            MAILMSG_CLOSES_SYMBOL, pvCloses);
        return;
    }

    if (!ReadMemory(pvCurrentMsgsAllocated, &cCurrentMsgsAllocated,
         sizeof(cCloses), NULL))
    {
        dprintf("Unable to read %s at address %p\n",
            MAILMSG_CLOSES_SYMBOL, pvCloses);
        return;
    }

    if (!ReadMemory(pvTotalMsgsAllocated, &cTotalMsgsAllocated,
         sizeof(cCloses), NULL))
    {
        dprintf("Unable to read %s at address %p\n",
            MAILMSG_CLOSES_SYMBOL, pvCloses);
        return;
    }

    if (cCurrentMsgsAllocated)
    {
        dwPercentCurrentMessagesClosed =
            (100*cCurrentMsgsThatHaveBeenClosed)/cCurrentMsgsAllocated;
    }

    if (cTotalMsgsAllocated)
    {
        dwPercentTotalMessagesBacklogged =
            (100*cCurrentMsgsAllocated)/cTotalMsgsAllocated;
    }

    //
    //  Get the instance object we want to get data from
    //
    CheckVersion(DebugArgs);
    if (!szArg || ('\0' == szArg[0]))
    {
        dwInstance = 1;
        pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            dwInstance = (DWORD)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                pvListHead = (PVOID) GetExpression(szCurrentArg);
            else
                pvListHead = (PVOID) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
        }
    }

    if (!pvListHead)
    {
        dprintf("ERROR: Unable to determine LIST_ENTRY for virtual servers\n");
        dprintf("  If you are using windbg, you should specify the value as the\n");
        dprintf("  2nd argument.  You can determine the address value by typeing:\n");
        dprintf("      x " AQUEUE_VIRTUAL_SERVER_SYMBOL "\n");
        dprintf("  You may also have bad symbols for phatq.dll.\n");
        return;
    }

    if (!ReadMemory(pvListHead, &liCurrent, sizeof(LIST_ENTRY), NULL))
    {
        dprintf("ERROR: Unable to read entry @ phatq!g_liVirtualServers 0x%08X", pvListHead);
        return;
    }

    if (!ReadMemory(pcInstances, &cInstances, sizeof(DWORD), NULL))
    {
        //For you windbg users out there
        dprintf("\n\n%Virtual Server Instance(s)\n\n");
    }
    else
    {
        dprintf("\n\n%d Virtual Server Instance(s)\n\n", cInstances);
    }

    while (liCurrent.Flink != pvListHead)
    {
        pCMQAddress = CONTAINING_RECORD(liCurrent.Flink, CAQSvrInst, m_liVirtualServers);


        if (!ReadMemory(pCMQAddress, paqinst, sizeof(CAQSvrInst), NULL))
        {
            dprintf("ERROR: Unable to CAQSvrInst @0x%08X", pCMQAddress);
            return;
        }

        if (CATMSGQ_SIG != paqinst->m_dwSignature)
        {
            dprintf("@0x%08X INVALID SIGNATURE - list entry @0x%08X\n", pCMQAddress, liCurrent.Flink);
        }
        else if (paqinst->m_dwServerInstance == dwInstance)
        {
            fFoundInstance = TRUE;
            dprintf("Using CAQSvrInst@0x%08X    %d\n", pCMQAddress, paqinst->m_dwServerInstance);
            break;
        }


        if (!ReadMemory(liCurrent.Flink, &liCurrent, sizeof(LIST_ENTRY), NULL))
        {
            dprintf("ERROR: Unable to read entry @0x%08X", liCurrent.Flink);
            return;
        }


    }

    //
    // Did we find the instance
    //
    if (!fFoundInstance)
    {
        dprintf("We did not find instance %d\n", dwInstance);
        return;
    }
    dwWeightedQueueLength = paqinst->m_cCurrentMsgsPendingSubmit +
                            paqinst->m_cCurrentMsgsPendingCat*2 +
                            paqinst->m_cCurrentMsgsPendingRouting*3 +
                            paqinst->m_cCurrentMsgsPendingLocal*4 +
                            paqinst->m_cMsgsDeliveredLocal*5;

    dwTotalQueueLength = paqinst->m_cCurrentMsgsPendingSubmit +
                         paqinst->m_cCurrentMsgsPendingCat +
                         paqinst->m_cCurrentMsgsPendingRouting +
                         paqinst->m_cCurrentMsgsPendingLocal +
                         paqinst->m_cMsgsDeliveredLocal;

    if (cTotalMsgsAllocated)
    {
        dwPercentCurrentMessagesQueueInternally =
            (100*(dwTotalQueueLength-paqinst->m_cMsgsDeliveredLocal))
                /cCurrentMsgsAllocated;
    }

    if (dwTotalQueueLength)
        dwQueueScore = (cCloses*1000)/dwTotalQueueLength;

    if (dwWeightedQueueLength)
        dwWeightedScore = (cCloses*1000)/dwWeightedQueueLength;

    if (paqinst->m_cMsgsDeliveredLocal)
        dwDeliveredScore = (cCloses*1000)/paqinst->m_cMsgsDeliveredLocal;

    if (paqinst->m_cTotalExternalMsgsSubmitted)
        dwSubmittedScore = (cCloses*1000)/paqinst->m_cTotalExternalMsgsSubmitted;

    dprintf("\n\nHandle Managment scores:\n");
    dprintf("========================\n");
    dprintf("Non-Weighted Score: %d\n", dwQueueScore);
    dprintf("Weighted Score: %d\n", dwWeightedScore);
    dprintf("Delivery Score: %d\n", dwDeliveredScore);
    dprintf("Submitted Score: %d\n", dwSubmittedScore);
    dprintf("Current Messsages Allocated That have been closed: %d%%\n",
        dwPercentCurrentMessagesClosed);
    dprintf("\nThe following are useful in correlating different test runs...\n");
    dprintf("Messages Backlogged: %d%%\n", dwPercentTotalMessagesBacklogged);
    dprintf("Backlogged Messsages Queued internally: %d%%\n",
        dwPercentCurrentMessagesQueueInternally);
    dprintf("\n%d Total message closures.. %d total deliveries\n\n",
        cCloses, paqinst->m_cMsgsDeliveredLocal);

}

//---[ DumpDNT ]------------------------------------------------------------
//
//
//  Description:
//      Dumps the contents of a DOMAIN_NAME_TABLE
//  Parameters:
//
//  Returns:
//
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(DumpDNT)
{
    BYTE  pbBuffer[sizeof(DOMAIN_NAME_TABLE)];
    PDOMAIN_NAME_TABLE pdnt = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntryRealAddress = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pPathEntry = NULL;
    BYTE  pbEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)];
    BYTE  pbPathEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)]; //buffer for putter path name entries in
    BYTE  pbPathEntryBuffer[MAX_DOM_PATH_SIZE];
    CHAR                        pBuffer[MAX_DOM_PATH_SIZE] = "Root Entry";
    LPSTR                       pPathBuffer = NULL;
    LPSTR                       pPathBufferStop = NULL;
    LPSTR                       pEntryBuffer = NULL;
    LPSTR                       pEntryBufferStop = NULL;
    DWORD                       dwLength = 0;
    DWORD dwSig = 0;

    //Define buffers for parsing addresses... the sizes are clearly overkill, and
    //I'm not too worried about overflow in a debugger extension
    CHAR                        szAddress[MAX_DOM_PATH_SIZE];
    CHAR                        szDumpArg[MAX_DOM_PATH_SIZE] = "";
    LPSTR                       szParsedArg = (LPSTR) szArg;
    LPSTR                       szCurrentDest = NULL;

    //Allow people who are used to typeing dump CFoo@Address... keep using the @ sign
    if ('@' == *szParsedArg)
        szParsedArg++;

    //Get Address of DomainNameTable
    szCurrentDest = szAddress;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szParsedArg-szArg <= MAX_DOM_PATH_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '\0';


    //Eat white space
    while (('\0' != *szParsedArg) && isspace(*szParsedArg))
        szParsedArg++;

    //Copy name of struct to dump at each node
    szCurrentDest = szDumpArg;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szCurrentDest-szDumpArg <= MAX_DOM_PATH_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '@';
    szCurrentDest++;  //szCurrentDest now points to place to copy address to

    pdnt = (PDOMAIN_NAME_TABLE) GetExpression(szAddress);

    if (!pdnt)
    {
        dprintf("ERROR: Unable to Get DOMAIN_NAME_TABLE from argument %s\n", szArg);
        return;
    }

    if (!ReadMemory(pdnt, pbBuffer, sizeof(DOMAIN_NAME_TABLE), NULL))
    {
        dprintf("ERROR: Unable to read process memory\n");
        return;
    }

    pPathBuffer = pBuffer;
    pPathBufferStop = pPathBuffer + (MAX_DOM_PATH_SIZE / sizeof(CHAR) -1 );

    pEntryRealAddress = (PDOMAIN_NAME_TABLE_ENTRY)
                ((BYTE *)pdnt + FIELD_OFFSET(DOMAIN_NAME_TABLE, RootEntry));
    pdnt = (PDOMAIN_NAME_TABLE) pbBuffer;

    pEntry = &(pdnt->RootEntry);
    dprintf("Entry ID    # Children  pData       pWildCard    Path\n");
    dprintf("===========================================================================\n");
    while(pEntry)
    {
        //only display interesting entries
        if (pEntry->pData || pEntry->pWildCardData)
        {
           //Get full path name of this domain entry
            pPathEntry = pEntry;
            pPathBuffer = pBuffer;
            while (pPathEntry && pPathEntry->pParentEntry && pPathBuffer < pPathBufferStop)
            {
                //dump current entries portion of the string
                if (pPathBuffer != pBuffer) //already made first pass -- Add delimter
                {
                    *pPathBuffer++ = '.';
                }

                //read partial path name from debuggee
                if (!ReadMemory(pPathEntry->PathSegment.Buffer, pbPathEntryBuffer,
                         AQ_MIN(MAX_DOM_PATH_SIZE, pPathEntry->PathSegment.Length), NULL))
                {
                    dprintf("ERROR: Unable to read process memory for path segment 0x%08X\n",
                        pPathEntry->PathSegment.Buffer);
                    break;
                }

                pEntryBuffer = (CHAR *) pbPathEntryBuffer;
                pEntryBufferStop = pEntryBuffer;
                pEntryBuffer += (pPathEntry->PathSegment.Length / sizeof(CHAR) -1 );

                while (pPathBuffer < pPathBufferStop && pEntryBuffer >= pEntryBufferStop)
                {
                    *pPathBuffer++ = *pEntryBuffer--;
                }
                *pPathBuffer = '\0'; //make sure we terminate
                pPathEntry = pPathEntry->pParentEntry;

                //read next part of path name from debuggee
                if (!ReadMemory(pPathEntry, pbPathEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory for path entry 0x%08x\n", pPathEntry);
                    pPathEntry = NULL;
                }
                else
                {
                    pPathEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbPathEntry;
                }
            }

            dprintf("0x%08.8X  %10.10d  0x%08.8X  0x%08.8X   %s\n", pEntryRealAddress,
                pEntry->NoOfChildren, pEntry->pData, pEntry->pWildCardData, pBuffer);

            //Dump structs if requested
            if ('@' != *szDumpArg)
            {
                if (pEntry->pData)
                {
                    //Write address string
                    wsprintf(szCurrentDest, "0x%08X", pEntry->pData);

                    //Call ptdbgext dump function
                    _dump(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szDumpArg);
                }

                if (pEntry->pWildCardData)
                {
                    //Write address string
                    wsprintf(szCurrentDest, "0x%08X", pEntry->pWildCardData);

                    //Call ptdbgext dump function
                    _dump(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szDumpArg);
                }

            }
        }

        //Get the next entry... in order of child, sibling, closest ancestor with sibling
        if (pEntry->pFirstChildEntry != NULL)
        {
            pEntryRealAddress = pEntry->pFirstChildEntry;
        }
        else if (pEntry->pSiblingEntry != NULL)
        {
            pEntryRealAddress = pEntry->pSiblingEntry;
        }
        else
        {
            for (pEntryRealAddress = pEntry->pParentEntry;
                    pEntryRealAddress != NULL;
                        pEntryRealAddress = pEntry->pParentEntry)
            {
                //must read parent entry into our buffer
                if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory of parent domain entry 0x%08X\n", pEntryRealAddress);
                    pEntry = NULL;
                    break;
                }
                pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;

                if (pEntry->pSiblingEntry != NULL)
                    break;

            }
            if (pEntry != NULL)
            {
                pEntryRealAddress = pEntry->pSiblingEntry;
            }
        }

        if (pEntryRealAddress)
        {
            if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
            {
                dprintf("ERROR: Unable to read process memory on domain entry 0x%08X\n",
                    pEntryRealAddress);
                pEntry = NULL;
                break;
            }
            pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;
        }
        else
        {
            pEntry = NULL;
        }
    }
    dprintf("===========================================================================\n");
}


//---[ DumpList ]--------------------------------------------------------------
//
//
//  Description:
//      Function to walk a set of LIST_ENTRY's and dump their contenxts
//  Parameters:
//      szArg - space separated list of the following
//          Address of head list entry
//          Offset of object address [optional]
//          Name of object to dump [optional]
//  Returns:
//      -
//  History:
//      9/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dumplist)
{
    const DWORD MAX_ARG_SIZE = 200;
    const DWORD MAX_ENTRIES = 3000;
    LIST_ENTRY  liCurrent;
    PLIST_ENTRY pliHead = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    DWORD_PTR   dwOffsetOfEntry = 0;
    CHAR        szAddress[MAX_ARG_SIZE];
    CHAR        szDumpArg[MAX_ARG_SIZE];
    LPSTR       szParsedArg = (LPSTR) szArg;
    LPSTR       szCurrentDest = NULL;
    DWORD       cEntries = 0;

    //Get Address of DomainNameTable
    szCurrentDest = szAddress;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szParsedArg-szArg <= MAX_ARG_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '\0';


    //Eat white space
    while (('\0' != *szParsedArg) && isspace(*szParsedArg))
        szParsedArg++;

    //Get offset of data
    szCurrentDest = szDumpArg;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szCurrentDest-szDumpArg <= MAX_ARG_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '\0';
    dwOffsetOfEntry = GetExpression(szDumpArg);

    //Eat white more space
    while (('\0' != *szParsedArg) && isspace(*szParsedArg))
        szParsedArg++;

    //Copy name of struct to dump at each node
    szCurrentDest = szDumpArg;
    while (('\0' != *szParsedArg) && !isspace(*szParsedArg) && (szCurrentDest-szDumpArg <= MAX_ARG_SIZE))
    {
        *szCurrentDest = *szParsedArg;
        szParsedArg++;
        szCurrentDest++;
    }
    *szCurrentDest = '@';
    szCurrentDest++;  //szCurrentDest now points to place to copy address to

    pliHead = (PLIST_ENTRY) GetExpression(szAddress);
    if (!ReadMemory(pliHead, &liCurrent, sizeof(LIST_ENTRY), NULL))
    {
        dprintf("Error reading head entry at 0x%08X\n", pliHead);
        return;
    }

    pliCurrent = pliHead;
    dprintf("LIST ENTRY       DATA OFFSET\n");
    dprintf("==============================================\n");
    dprintf(" 0x%08X       0x%08X (HEAD)\n", pliCurrent, pliCurrent-dwOffsetOfEntry);
    dprintf("----------------------------------------------\n");
    //OK... start walking list using Flink
    pliCurrent = liCurrent.Flink;
    while(pliCurrent != NULL && pliHead != pliCurrent)
    {
        // There have been some problems with this.
#ifdef NEVER
        if (pliCurrent != liCurrent.Blink)
        {
            dprintf(" %p       %p (WARNING does Flink/Blink mismatch)\n", pliCurrent,
                ((DWORD_PTR) pliCurrent)-dwOffsetOfEntry);
        }
        else
#else
        if (TRUE)
#endif //NEVER
        {
            dprintf(" %p       %p\n", pliCurrent,
                ((DWORD_PTR) pliCurrent)-dwOffsetOfEntry);
        }

        if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
        {
            dprintf("Error reading LIST_ENTRY at 0x%08X\n", pliCurrent);
            return;
        }

        //dump the struct if we were asked to
        if ('@' != *szDumpArg)
        {
            //Write address string
            wsprintf(szCurrentDest, "%p", ((DWORD_PTR) pliCurrent)-dwOffsetOfEntry);

            //Call ptdbgext dump function
            _dump(hCurrentProcess, hCurrentThread, dwCurrentPc, pExtensionApis, szDumpArg);
        }

        cEntries++;
        if (cEntries > MAX_ENTRIES)
        {
            dprintf("ERROR: Max number of entries exceeded\n");
            return;
        }
        pliCurrent = liCurrent.Flink;
    }
    dprintf("----------------------------------------------\n");
    dprintf(" %d Total Entries\n", cEntries);
    dprintf("==============================================\n");


}

//---[ linkstate ]-------------------------------------------------------------
//
//
//  Description:
//      Dumps the current link state (including routing information) of a
//      virtual server.
//  Parameters:
//      Virtual Server Instance - virtual server ID of server to dump
//      Global Server list (optional) - Head of virtual server list
//  Returns:
//      -
//  History:
//      9/30/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(linkstate)
{
    DWORD       dwInstance = 0;
    PLIST_ENTRY pliHead = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    BYTE        pBuffer[sizeof(CAQSvrInst)] = {'\0'};
    CAQSvrInst  *paqinst = (CAQSvrInst *) pBuffer;
    DOMAIN_NAME_TABLE *pdnt = NULL;
    PVOID       pvAQueue = NULL;
    LIST_ENTRY liCurrent;
    BOOL        fFound = FALSE;
    CHAR        szArgBuffer[20];
    LPSTR       szCurrentArg = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntryRealAddress = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pPathEntry = NULL;
    BYTE        pbEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)];
    CHAR        szNextHop[MAX_DOM_PATH_SIZE];
    CHAR        szFinalDest[MAX_DOM_PATH_SIZE];
    BYTE        pbLMQ[sizeof(CLinkMsgQueue)];
    BYTE        pbDomainEntry[sizeof(CDomainEntry)];
    BYTE        pbDMQ[sizeof(CDestMsgQueue)];
    CLinkMsgQueue *plmq = (CLinkMsgQueue *) pbLMQ;
    CDomainEntry  *pdentry = (CDomainEntry *) pbDomainEntry;
    CDestMsgQueue *pdmq = (CDestMsgQueue *) pbDMQ;
    DWORD         *pdwGuid = NULL;
    LPSTR       szLinkState = LINK_STATE_UP;
    CHAR        szError[100];
    HINSTANCE   hModule = GetModuleHandle("aqdbgext.dll");
    DWORD       dwMsgId = 0;
    DWORD       dwFacility = 0;

    CheckVersion(DebugArgs);

    if (!szArg || ('\0' == szArg[0]))
    {
        //Assume the first instance
        dwInstance = 1;
        pliHead = (PLIST_ENTRY) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            dwInstance = (DWORD)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                pliHead = (PLIST_ENTRY) GetExpression(szCurrentArg);
            else
                pliHead = (PLIST_ENTRY) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
        }
    }


    if (!pliHead)
    {
        dprintf("ERROR: Unable to determine LIST_ENTRY for virtual servers\n");
        dprintf("  If you are using windbg, you should specify the value as the\n");
        dprintf("  2nd argument.  You can determine the address value by typeing:\n");
        dprintf("      x " AQUEUE_VIRTUAL_SERVER_SYMBOL "\n");
        return;
    }

    if (!ReadMemory(pliHead, &liCurrent, sizeof(LIST_ENTRY), NULL))
    {
        dprintf("ERROR: Unable to read entry @0x%08X\n", pliHead);
        return;
    }

    while (liCurrent.Flink != pliHead)
    {
        pvAQueue = CONTAINING_RECORD(liCurrent.Flink, CAQSvrInst, m_liVirtualServers);

        if (!ReadMemory(pvAQueue, paqinst, sizeof(CAQSvrInst), NULL))
        {
            dprintf("ERROR: Unable to CAQSvrInst @0x%08X", pvAQueue);
            return;
        }

        //Check the signature
        if (CATMSGQ_SIG != paqinst->m_dwSignature)
        {
            dprintf("@0x%08X INVALID SIGNATURE - list entry @0x%08X\n", pvAQueue, liCurrent.Flink);
            return;
        }
        else
        {
            if (paqinst->m_dwServerInstance == dwInstance)
            {
                fFound = TRUE;
                break;
            }
        }

        pliCurrent = liCurrent.Flink;

        if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
        {
            dprintf("ERROR: Unable to read entry @0x%08X\n", pliCurrent);
            return;
        }

        if (pliCurrent == liCurrent.Flink)
        {
            dprintf("ERROR: Loop in LIST_ENTRY @0x%08X\n", pliCurrent);
            return;
        }
    }

    if (!fFound)
    {
        dprintf("Requested instance not found.\n");
        return;
    }

    dprintf("Using Server instance %d @0x%08X\n", dwInstance, pvAQueue);
    //Use our current instance to dump all of the interesting bits

    pdnt = &(paqinst->m_dmt.m_dnt);
    pEntry = &(pdnt->RootEntry);

    while(pEntry)
    {
        //We are not interested in wildcard data
        if (pEntry->pData)
        {
            //Display link state information
            if (!ReadMemory(pEntry->pData, pbDomainEntry, sizeof(CDomainEntry), NULL))
            {
                dprintf("ERROR: Unable to read domain entry from @0x%08X\n", pEntry->pData);
                return;
            }

            pliHead = (PLIST_ENTRY) (((BYTE *)pEntry->pData) + FIELD_OFFSET(CDomainEntry, m_liDestQueues));
            pliCurrent = pdentry->m_liDestQueues.Flink;

            //Get final destination string
            if (!ReadMemory(pdentry->m_szDomainName, szFinalDest, pdentry->m_cbDomainName, NULL))
            {
                dprintf("ERROR: Unable to read final destination name from @0x%08X\n",
                        pdentry->m_szDomainName);
                return;
            }

            szFinalDest[pdentry->m_cbDomainName] = '\0';

            //Loop and display each DMQ
            while (pliHead != pliCurrent)
            {
                if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read link LIST_ENTRY @0x%08X\n", pliCurrent);
                    return;
                }

                if (!ReadMemory(CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs),
                                pbDMQ, sizeof(CDestMsgQueue), NULL))
                {
                    dprintf("ERROR: Unable to read DMQ @0x%08X\n",
                            CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs));
                    return;
                }

                //Verify DMQ Signature
                if (DESTMSGQ_SIG != pdmq->m_dwSignature)
                {
                    dprintf("ERROR: Invalid DMQ signature for CDestMsgQueue@0x%08X (from LIST_ENTRY) @0x%08X\n",
                            CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs),
                            pliCurrent);
                    return;
                }

                //Read link
                if (!ReadMemory(pdmq->m_plmq, pbLMQ, sizeof(CLinkMsgQueue), NULL))
                {
                    dprintf("ERROR: Unable to read LMQ @0x%08X\n",
                            pdmq->m_plmq);
                    return;
                }

                //Now print off next hop info
                if (!ReadMemory(plmq->m_szSMTPDomain, szNextHop, plmq->m_cbSMTPDomain, NULL))
                {
                    dprintf("ERROR: Unable to read next hop name from @0x%08X\n",
                            plmq->m_szSMTPDomain);
                    return;
                }
                szNextHop[plmq->m_cbSMTPDomain] = '\0';

                pdwGuid = (DWORD *) &(plmq->m_aqsched.m_guidRouter);

                //Determine the state of the link
                if (plmq->m_dwLinkFlags & LINK_STATE_PRIV_GENERATING_DSNS)
                {
                    szLinkState = LINK_STATE_DSN;
                }
                if (CLinkMsgQueue::fFlagsAllowConnection(plmq->m_dwLinkStateFlags))
                {
                    //If we can connect... are we?
                    if (plmq->m_cConnections)
                        szLinkState = LINK_STATE_ACTIVE;
                    else
                        szLinkState = LINK_STATE_UP;
                }
                else
                {
                    //If we're down... why?
                    szLinkState = LINK_STATE_DOWN;
                    if (!(plmq->m_dwLinkStateFlags & LINK_STATE_RETRY_ENABLED))
                        szLinkState = LINK_STATE_RETRY;
                    else if (plmq->m_dwLinkStateFlags & LINK_STATE_PRIV_CONFIG_TURN_ETRN)
                        szLinkState = LINK_STATE_TURN;
                    else if (plmq->m_dwLinkStateFlags & LINK_STATE_PRIV_NO_CONNECTION)
                        szLinkState = LINK_STATE_SPECIAL;
                }

                //Print some interesting data
                dprintf("==============================================================================\n");
                dprintf("| Link State | Final Destination             | Next Hop                      |\n");
                dprintf("| %s | %-29s | %-29s |\n", szLinkState, szFinalDest, szNextHop);
                dprintf("------------------------------------------------------------------------------\n");
                dprintf("| Route Details:                                                             |\n");
                dprintf("|                 Router GUID: %08X-%08X-%08X-%08X           |\n",
                        pdwGuid[0], pdwGuid[1], pdwGuid[2], pdwGuid[3]);
                dprintf("|                 Message Type: %08X  Schedule ID:%08X               |\n",
                        pdmq->m_aqmt.m_dwMessageType, plmq->m_aqsched.m_dwScheduleID);
                dprintf("|                 Link State Flags 0x%08X                                |\n",
                        plmq->m_dwLinkStateFlags);
                dprintf("|                 Current # of connections: %-8d                         |\n",
                        plmq->m_cConnections);
                dprintf("|                 Current # of Msgs (on link): %-8d                      |\n",
                        plmq->m_aqstats.m_cMsgs);
                dprintf("|                 Current # of Msgs (on DMQ): %-8d                       |\n",
                        pdmq->m_aqstats.m_cMsgs);
                dprintf("|                 Current # of Msgs (on DMQ/retry): %-8d                 |\n",
                        pdmq->m_aqstats.m_cRetryMsgs);
                dprintf("|                 CLinkMsgQueue@0x%08X                                   |\n",
                        pdmq->m_plmq);
                dprintf("|                 CDestMsgQueue@0x%08X                                   |\n",
                       CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs));

                //print out the diagnostic information if in retry
                //or a failure has been recorded and there are no msgs.
                if ((LINK_STATE_RETRY == szLinkState) ||
                    (FAILED(plmq->m_hrDiagnosticError) && !plmq->m_aqstats.m_cMsgs))
                {
                    //Get and format the error message
                    szError[0] = '\0';
                    dwMsgId = plmq->m_hrDiagnosticError;
                    dwFacility = ((0x0FFF0000 & dwMsgId) >> 16);

                    //If it is not ours... then "un-HRESULT" it
                    if (dwFacility != FACILITY_ITF)
                        dwMsgId &= 0x0000FFFF;


                    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM |
                                  FORMAT_MESSAGE_IGNORE_INSERTS |
                                  FORMAT_MESSAGE_FROM_HMODULE,
                                  hModule,
                                  dwMsgId,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  szError,
                                  sizeof(szError),
                                  NULL );

                    dprintf("------------------------------------------------------------------------------\n");
                    dprintf("| Failure Details:                                                           |\n");
                    dprintf("|                 Diagnostic HRESULT 0x%08X                              |\n",
                                plmq->m_hrDiagnosticError);
                    if (szError && *szError)
                    {
                        dprintf("|                 Diagnostic string: %s\n",
                                    szError);
                    }
                    dprintf("|                 Protocol Verb: %-20.20s                        |\n",
                                plmq->m_szDiagnosticVerb);
                    dprintf("|                 Protocol Response: %s\n",
                                plmq->m_szDiagnosticResponse);
                }
                pliCurrent = liCurrent.Flink;
            }
        }

        //Now determine what the "next" entry is
        if (pEntry->pFirstChildEntry != NULL)
        {
            pEntryRealAddress = pEntry->pFirstChildEntry;
        }
        else if (pEntry->pSiblingEntry != NULL)
        {
            pEntryRealAddress = pEntry->pSiblingEntry;
        }
        else
        {
            for (pEntryRealAddress = pEntry->pParentEntry;
                    pEntryRealAddress != NULL;
                        pEntryRealAddress = pEntry->pParentEntry)
            {
                //must read parent entry into our buffer
                if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory of parent domain entry 0x%08X\n", pEntryRealAddress);
                    pEntry = NULL;
                    break;
                }
                pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;

                if (pEntry->pSiblingEntry != NULL)
                    break;

            }
            if (pEntry != NULL)
            {
                pEntryRealAddress = pEntry->pSiblingEntry;
            }
        }

        if (pEntryRealAddress)
        {
            if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
            {
                dprintf("ERROR: Unable to read process memory on domain entry 0x%08X\n",
                    pEntryRealAddress);
                pEntry = NULL;
                break;
            }
            pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;
        }
        else
        {
            pEntry = NULL;
        }
    }
    dprintf("==============================================================================\n");
}

//---[ zombieq ]-------------------------------------------------------------
//
//
//  Description:
//      Trolls the DNT for queues that are marked as empty, yet are not in
//      in the empty list
//  Parameters:
//      Virtual Server Instance - virtual server ID of server to dump
//      Global Server list (optional) - Head of virtual server list
//  Returns:
//      -
//  History:
//      9/30/98 - MikeSwa Created
//      3/19/2001 - MikeSwa Modified from linkstate
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(zombieq)
{
    DWORD       dwInstance = 0;
    PLIST_ENTRY pliHead = NULL;
    PLIST_ENTRY pliCurrent = NULL;
    BYTE        pBuffer[sizeof(CAQSvrInst)] = {'\0'};
    CAQSvrInst  *paqinst = (CAQSvrInst *) pBuffer;
    DOMAIN_NAME_TABLE *pdnt = NULL;
    PVOID       pvAQueue = NULL;
    LIST_ENTRY liCurrent;
    BOOL        fFound = FALSE;
    CHAR        szArgBuffer[20];
    LPSTR       szCurrentArg = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntry = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pEntryRealAddress = NULL;
    PDOMAIN_NAME_TABLE_ENTRY pPathEntry = NULL;
    BYTE        pbEntry[sizeof(DOMAIN_NAME_TABLE_ENTRY)];
    CHAR        szFinalDest[MAX_DOM_PATH_SIZE];
    BYTE        pbLMQ[sizeof(CLinkMsgQueue)];
    BYTE        pbDomainEntry[sizeof(CDomainEntry)];
    BYTE        pbDMQ[sizeof(CDestMsgQueue)];
    CLinkMsgQueue *plmq = (CLinkMsgQueue *) pbLMQ;
    CDomainEntry  *pdentry = (CDomainEntry *) pbDomainEntry;
    CDestMsgQueue *pdmq = (CDestMsgQueue *) pbDMQ;
    DWORD         *pdwGuid = NULL;
    DWORD       dwMsgId = 0;
    DWORD       dwFacility = 0;
    DWORD       cZombieQueues = 0; //Queues that are marked as empty but not in empty list
    DWORD       cPristineZombieQueues = 0; //Zombie queues that have never had a message on them
    DWORD       cZombieQueuesInUse = 0; //Zombie queues that have a refcount
    DWORD       cEntries = 0;
    DWORD       cZombieEntries = 0;
    DWORD       cQueues = 0;
    const DWORD MAX_DBG_MESSAGE_TYPES = 1000;
    DWORD       rgdwMessageTypes[MAX_DBG_MESSAGE_TYPES]; //array of message types we have found
    DWORD       cMessageTypes = 0;
    DWORD       iLastMessageType = 0;
    DWORD       iCurrentMessageType = 0;
    DWORD       iCurrentPri = 0;
    BOOL        fFoundFifoQ = FALSE;
    BOOL        fZombieQueueInUse = FALSE;
    LPSTR       szScanStatus = "FAILED";

    ZeroMemory(rgdwMessageTypes, sizeof(rgdwMessageTypes));

    CheckVersion(DebugArgs);

    if (!szArg || ('\0' == szArg[0]))
    {
        //Assume the first instance
        dwInstance = 1;
        pliHead = (PLIST_ENTRY) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
    }
    else
    {
        strcpy(szArgBuffer, szArg);

        szCurrentArg = strtok(szArgBuffer, " ");

        if (szCurrentArg)
        {
            dwInstance = (DWORD)GetExpression(szCurrentArg);

            szCurrentArg = strtok(NULL, " ");
            if (szCurrentArg)
                pliHead = (PLIST_ENTRY) GetExpression(szCurrentArg);
            else
                pliHead = (PLIST_ENTRY) GetExpression(AQUEUE_VIRTUAL_SERVER_SYMBOL);
        }
    }


    if (!pliHead)
    {
        dprintf("ERROR: Unable to determine LIST_ENTRY for virtual servers\n");
        dprintf("  If you are using windbg, you should specify the value as the\n");
        dprintf("  2nd argument.  You can determine the address value by typeing:\n");
        dprintf("      x " AQUEUE_VIRTUAL_SERVER_SYMBOL "\n");
        return;
    }

    if (!ReadMemory(pliHead, &liCurrent, sizeof(LIST_ENTRY), NULL))
    {
        dprintf("ERROR: Unable to read entry @0x%08X\n", pliHead);
        return;
    }

    while (liCurrent.Flink != pliHead)
    {
        pvAQueue = CONTAINING_RECORD(liCurrent.Flink, CAQSvrInst, m_liVirtualServers);

        if (!ReadMemory(pvAQueue, paqinst, sizeof(CAQSvrInst), NULL))
        {
            dprintf("ERROR: Unable to CAQSvrInst @0x%08X", pvAQueue);
            return;
        }

        //Check the signature
        if (CATMSGQ_SIG != paqinst->m_dwSignature)
        {
            dprintf("@0x%08X INVALID SIGNATURE - list entry @0x%08X\n", pvAQueue, liCurrent.Flink);
            return;
        }
        else
        {
            if (paqinst->m_dwServerInstance == dwInstance)
            {
                fFound = TRUE;
                break;
            }
        }

        pliCurrent = liCurrent.Flink;

        if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
        {
            dprintf("ERROR: Unable to read entry @0x%08X\n", pliCurrent);
            return;
        }

        if (pliCurrent == liCurrent.Flink)
        {
            dprintf("ERROR: Loop in LIST_ENTRY @0x%08X\n", pliCurrent);
            return;
        }
    }

    if (!fFound)
    {
        dprintf("Requested instance not found.\n");
        return;
    }

    dprintf("Using Server instance %d @0x%08X\n", dwInstance, pvAQueue);
    //Use our current instance to dump all of the interesting bits

    pdnt = &(paqinst->m_dmt.m_dnt);
    pEntry = &(pdnt->RootEntry);

    while(pEntry)
    {
        cEntries++;
        //
        //  Check to see if the user pressed ctrl-C
        //
        if (CheckControlC())
        {
            szScanStatus = "FAILED - User ctrl-c";
            goto Exit;
        }

        //We are not interested in wildcard data
        if (pEntry->pData)
        {
            //Display link state information
            if (!ReadMemory(pEntry->pData, pbDomainEntry, sizeof(CDomainEntry), NULL))
            {
                dprintf("ERROR: Unable to read domain entry from @0x%08X\n", pEntry->pData);
                return;
            }

            pliHead = (PLIST_ENTRY) (((BYTE *)pEntry->pData) + FIELD_OFFSET(CDomainEntry, m_liDestQueues));
            pliCurrent = pdentry->m_liDestQueues.Flink;

            //Get final destination string
            if (!ReadMemory(pdentry->m_szDomainName, szFinalDest, pdentry->m_cbDomainName, NULL))
            {
                dprintf("ERROR: Unable to read final destination name from @0x%08X\n",
                        pdentry->m_szDomainName);
                return;
            }

            szFinalDest[pdentry->m_cbDomainName] = '\0';

            //
            // Does this entry have any queues or links
            //
            if (!pdentry->m_cQueues && !pdentry->m_cLinks)
                cZombieEntries++;

            //Loop and display each DMQ
            while (pliHead != pliCurrent)
            {
                cQueues++;
                //
                //  Check to see if the user pressed ctrl-C
                //
                if (CheckControlC())
                {
                    szScanStatus = "FAILED - User ctrl-c";
                    goto Exit;
                }

                if (!ReadMemory(pliCurrent, &liCurrent, sizeof(LIST_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read link LIST_ENTRY @0x%08X\n", pliCurrent);
                    return;
                }

                if (!ReadMemory(CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs),
                                pbDMQ, sizeof(CDestMsgQueue), NULL))
                {
                    dprintf("ERROR: Unable to read DMQ @0x%08X\n",
                            CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs));
                    return;
                }

                //Verify DMQ Signature
                if (DESTMSGQ_SIG != pdmq->m_dwSignature)
                {
                    dprintf("ERROR: Invalid DMQ signature for CDestMsgQueue@0x%08X (from LIST_ENTRY) @0x%08X\n",
                            CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs),
                            pliCurrent);
                    return;
                }


                //
                //  It is a zombie if it is marked as empty, but not in the empty list.
                //
                if ((pdmq->m_dwFlags & CDestMsgQueue::DMQ_EMPTY) &&
                    !pdmq->m_liEmptyDMQs.Flink &&
                    !pdmq->m_liEmptyDMQs.Blink &&
                    !pdmq->m_aqstats.m_cMsgs &&
                    !pdmq->m_aqstats.m_cRetryMsgs)
                {
                    cZombieQueues++;

                    //
                    //  Look at the refcount.  If it is 1 (or 2 with an LMQ) then
                    //  it is unlikley that it is currently in use
                    //
                    fZombieQueueInUse = FALSE;
                    if (!((1 == *(((DWORD *)pdmq) + 3)) ||
                        ((2 == *(((DWORD *)pdmq) + 3)) && pdmq->m_plmq)))
                    {
                        cZombieQueuesInUse++;
                        fZombieQueueInUse = TRUE;
                    }

                    //
                    // Check and see if this has *ever* had a message queued on it.
                    //
                    fFoundFifoQ = FALSE;
                    for (iCurrentPri = 0; iCurrentPri < NUM_PRIORITIES; iCurrentPri++)
                    {
                        if (pdmq->m_rgpfqQueues[iCurrentPri])
                        {
                            fFoundFifoQ = TRUE;
                            break;
                        }
                    }

                    if (!fFoundFifoQ)
                        cPristineZombieQueues++;
                    //
                    //  Have we see this message type before?
                    //
                    if (rgdwMessageTypes[iLastMessageType] != pdmq->m_aqmt.m_dwMessageType)
                    {
                        for (iCurrentMessageType = 0;
                             iCurrentMessageType < MAX_DBG_MESSAGE_TYPES;
                             iCurrentMessageType++)
                        {
                            if (!rgdwMessageTypes[iCurrentMessageType])
                            {
                                rgdwMessageTypes[iCurrentMessageType] = pdmq->m_aqmt.m_dwMessageType;
                                cMessageTypes++;
                                break;
                            }

                            if (rgdwMessageTypes[iCurrentMessageType] == pdmq->m_aqmt.m_dwMessageType)
                                break;
                        }
                    }


                    //Print some interesting data
                    dprintf("%s%s| %-29s | CDestMsgQueue@0x%08X | 0x%08X\n",
                            fZombieQueueInUse ? "!" : "",
                            fFoundFifoQ ? "*" : "",
                            szFinalDest,
                            CONTAINING_RECORD(pliCurrent, CDestMsgQueue, m_liDomainEntryDMQs),
                            pdmq->m_aqmt.m_dwMessageType);
                }
                pliCurrent = liCurrent.Flink;
            }
        }

        //Now determine what the "next" entry is
        if (pEntry->pFirstChildEntry != NULL)
        {
            pEntryRealAddress = pEntry->pFirstChildEntry;
        }
        else if (pEntry->pSiblingEntry != NULL)
        {
            pEntryRealAddress = pEntry->pSiblingEntry;
        }
        else
        {
            for (pEntryRealAddress = pEntry->pParentEntry;
                    pEntryRealAddress != NULL;
                        pEntryRealAddress = pEntry->pParentEntry)
            {
                //must read parent entry into our buffer
                if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
                {
                    dprintf("ERROR: Unable to read process memory of parent domain entry 0x%08X\n", pEntryRealAddress);
                    pEntry = NULL;
                    break;
                }
                pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;

                if (pEntry->pSiblingEntry != NULL)
                    break;

            }
            if (pEntry != NULL)
            {
                pEntryRealAddress = pEntry->pSiblingEntry;
            }
        }

        if (pEntryRealAddress)
        {
            if (!ReadMemory(pEntryRealAddress, pbEntry, sizeof(DOMAIN_NAME_TABLE_ENTRY), NULL))
            {
                dprintf("ERROR: Unable to read process memory on domain entry 0x%08X\n",
                    pEntryRealAddress);
                pEntry = NULL;
                break;
            }
            pEntry = (PDOMAIN_NAME_TABLE_ENTRY) pbEntry;
        }
        else
        {
            pEntry = NULL;
        }
    }
    szScanStatus = "COMPLETED";
  Exit:
    dprintf("==============================================================================\n");
    dprintf("SCAN %s\n", szScanStatus);
    dprintf("==============================================================================\n");
    dprintf("%d Total Zombie Queues (%d bytes) \n", cZombieQueues,
        cZombieQueues*sizeof(CDestMsgQueue));
    dprintf("%d Total Zombie Queues that have never had a message queued\n", cPristineZombieQueues);
    dprintf("%d Total Zombie Queues that may be in use \n", cZombieQueuesInUse);
    dprintf("%d Total Zombie Message Types\n", cMessageTypes);
    dprintf("%d Total Queues\n", cQueues);
    dprintf("%d Total Domain Entires\n", cEntries);
    dprintf("%d Total Zombie Domain Entires (%d bytes) \n", cZombieEntries,
        cZombieEntries*sizeof(CDomainEntry));
}

//---[ dsncontexthash ]--------------------------------------------------------
//
//
//  Description:
//      Calculates the dsncontexthash for a given filename.  Will also dump
//      common hash names
//  Parameters:
//      filename to dump
//  Returns:
//      -
//  History:
//      9/30/98 - MikeSwa Created
//      3/19/2001 - MikeSwa Modified from linkstate
//
//-----------------------------------------------------------------------------
AQ_DEBUG_EXTENSION_IMP(dsncontexthash)
{
    DWORD dwHash = 0;
    const DWORD MAX_DSN_HASH_FILES = 10;
    CHAR  rgszWellKnown[MAX_DSN_HASH_FILES][20] =
    {
        "msgref.cpp",
        "aqinst.cpp",
        "mailadmq.cpp",
        "dsnevent.h"
        ""
    };
    DWORD i = 0;
    LPSTR szCurrentWellKnown = rgszWellKnown[0];

    if (szArg && ('\0' != szArg[0]))
    {
        dwHash = dwDSNContextHash(szArg,strlen(szArg));
        dprintf ("DSNContext has for %s is 0x%08X\n",
            szArg, dwHash);
    }

    //
    //  If no arg just dump the well known file names.
    //
    for (DWORD i = 0; i < MAX_DSN_HASH_FILES; i++)
    {
        szCurrentWellKnown = rgszWellKnown[i];
        if (!szCurrentWellKnown || !*szCurrentWellKnown)
            break;
        dwHash = dwDSNContextHash(szCurrentWellKnown,
                             strlen(szCurrentWellKnown));
        dprintf ("DSNContext has for %s is 0x%08X\n",
            szCurrentWellKnown, dwHash);
        szCurrentWellKnown++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\aqdbgext.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqdbgext.h
//
//  Description: Header file for Advanced Queuing debugger extensions
//
//  Author: mikeswa
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQDBGEXT_H__
#define __AQDBGEXT_H__

#ifdef PLATINUM
#include <ptdbgext.h>
#else
#include <dbgdumpx.h>
#endif //PLATINUM

#define AQ_DEBUG_EXTENSION(function)  TRANS_DEBUG_EXTENSION(function)
#define AQ_DEBUG_EXTENSION_IMP(function) TRANS_DEBUG_EXTENSION(function)

#define AQUEUE_VIRTUAL_SERVER_SYMBOL "aqueue!g_liVirtualServers"

AQ_DEBUG_EXTENSION(DumpServers);
AQ_DEBUG_EXTENSION(Offsets);
AQ_DEBUG_EXTENSION(DumpDNT);
AQ_DEBUG_EXTENSION(dumplist);
AQ_DEBUG_EXTENSION(linkstate);
AQ_DEBUG_EXTENSION(hashthread);
AQ_DEBUG_EXTENSION(dumplock);
AQ_DEBUG_EXTENSION(dumpoffsets);
AQ_DEBUG_EXTENSION(walkcpool);
AQ_DEBUG_EXTENSION(workqueue);
AQ_DEBUG_EXTENSION(queueusage);
AQ_DEBUG_EXTENSION(dmqusage);
AQ_DEBUG_EXTENSION(dntusage);
AQ_DEBUG_EXTENSION(dumpqueue);
AQ_DEBUG_EXTENSION(displaytickcount);
AQ_DEBUG_EXTENSION(handlemgmt);
AQ_DEBUG_EXTENSION(dsncontexthash);

//Export lower case versions of the functions because windbg forces all lower case
//This means that all *new* function names should be all lower case/
AQ_DEBUG_EXTENSION(dumpservers);
AQ_DEBUG_EXTENSION(dumpdnt);

#include "aqmem.h"

#endif __AQDBGEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\fifoqdbg.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: fifqdbg.cpp
//
//  Description:  Implementation for CFifoQueueDbgIterator class.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      9/13/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#define _ANSI_UNICODE_STRINGS_DEFINED_
#include "aqincs.h"
#ifdef PLATINUM
#include "ptrwinst.h"
#include "ptntdefs.h"
#include "ptntintf.h"
#else //PLATINUM
#include "rwinst.h"
#endif //PLATINUM
#include <fifoqdbg.h>
#include <fifoqimp.h>
#include <smtpconn.h>

#define MIN(x, y) ((x) > (y) ? (y) : (x))

//---[ GetQueueType ]----------------------------------------------------------
//
//
//  Description:
//      Determines the queue type for a given ptr
//  Parameters:
//      hCurrentProcess     Handle to the debuggee process
//      pvAddressOtherProc  Addess of the DMQ in the debugee process
//  Returns:
//      AQ_QUEUE_TYPE_UNKNOWN     Queue type cannot be determined
//      AQ_QUEUE_TYPE_FIFOQ       Queue is a CFifoQ
//      AQ_QUEUE_TYPE_DMQ         Queue is a CDestMsgQueue
//      AQ_QUEUE_TYPE_LMQ         Queue is a CLinkMsgQueue
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
AQ_QUEUE_TYPE CQueueDbgIterator::GetQueueType(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    BYTE    pbQueueBuffer[100];

    ZeroMemory(pbQueueBuffer, sizeof(pbQueueBuffer));

    if (!ReadMemory(pvAddressOtherProc, pbQueueBuffer,
         sizeof(pbQueueBuffer), NULL))
        return AQ_QUEUE_TYPE_UNKNOWN;

    if (FIFOQ_SIG == ((CFifoQueue<PVOID *> *)pbQueueBuffer)->m_dwSignature)
        return AQ_QUEUE_TYPE_FIFOQ;

    if (DESTMSGQ_SIG == ((CDestMsgQueue *)pbQueueBuffer)->m_dwSignature)
        return AQ_QUEUE_TYPE_DMQ;

    if (LINK_MSGQ_SIG == ((CLinkMsgQueue *)pbQueueBuffer)->m_dwSignature)
        return AQ_QUEUE_TYPE_LMQ;

    return AQ_QUEUE_TYPE_UNKNOWN;
}



#define pvGetNextPage(pvCurrent) ((PVOID) ((CFifoQueuePage<PVOID> *)pvCurrent)->m_pfqpNext)

CFifoQueueDbgIterator::CFifoQueueDbgIterator(PWINDBG_EXTENSION_APIS pApis)
{
    m_iCurrentPage = 0;
    m_iCurrentIndexInPage = 0;
    m_cPagesLoaded = 0;
    m_iHeadIndex = 0;
    m_iTailIndex = 0;
    pExtensionApis  = pApis;
    ZeroMemory(m_pbQueueBuffer, sizeof(m_pbQueueBuffer));
};

CFifoQueueDbgIterator::~CFifoQueueDbgIterator()
{
    PVOID pvCurrent = NULL;
    PVOID pvNext = NULL;

    pvCurrent = ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead;
    while (pvCurrent)
    {
        pvNext = pvGetNextPage(pvCurrent);
        free(pvCurrent);
        pvCurrent = pvNext;
    }
}

BOOL CFifoQueueDbgIterator::fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    DWORD cbBytes = 0;
    PVOID pvPageOtherProc = NULL;
    PVOID pvPageThisProc = NULL;
    PVOID pvPreviousPageThisProc = NULL;

    //Read the entire queue structure in memory
    if (!ReadMemory(pvAddressOtherProc, m_pbQueueBuffer,
            sizeof(m_pbQueueBuffer), NULL))
        return FALSE;

    //Iterate over the previous pointers from the head page
    pvPageOtherProc = ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead;

    ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead = NULL;
    while (pvPageOtherProc)
    {
        pvPageThisProc = malloc(sizeof(CFifoQueuePage<PVOID>));
        if (!pvPageThisProc)
            return FALSE;

        if (pvPreviousPageThisProc)
        {
            ((CFifoQueuePage<PVOID> *)pvPreviousPageThisProc)->m_pfqpNext =
                (CFifoQueuePage<PVOID> *) pvPageThisProc;
        }
        else
        {
            ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead =
                (CFifoQueuePage<PVOID> *) pvPageThisProc;
        }


        if (!ReadMemory(pvPageOtherProc,
                pvPageThisProc, sizeof(CFifoQueuePage<PVOID>), NULL))
        {
            if (pvPreviousPageThisProc)
                ((CFifoQueuePage<PVOID> *)pvPreviousPageThisProc)->m_pfqpNext = NULL;
            else
                ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead = NULL;

            free(pvPageThisProc);
            return FALSE;
        }

        if (!pvPreviousPageThisProc)
        {
            //This is the head page. save index
            m_iHeadIndex = (DWORD) ((DWORD_PTR)
                    (((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_ppqdataHead -
                    ((CFifoQueuePage<PVOID> *)pvPageOtherProc)->m_rgpqdata));

            m_iCurrentIndexInPage = m_iHeadIndex;
        }

        //save tail index... in case this is the last page
        m_iTailIndex = (DWORD) ((DWORD_PTR)
                (((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_ppqdataTail -
                ((CFifoQueuePage<PVOID> *)pvPageOtherProc)->m_rgpqdata));

        pvPreviousPageThisProc = pvPageThisProc;

        pvPageOtherProc = pvGetNextPage(pvPageThisProc);
        ((CFifoQueuePage<PVOID> *)pvPreviousPageThisProc)->m_pfqpNext = NULL;
        m_cPagesLoaded++;
    }

    return TRUE;
}

DWORD CFifoQueueDbgIterator::cGetCount()
{
    return ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_cQueueEntries;
}

PVOID CFifoQueueDbgIterator::pvGetNext()
{
    PVOID pvCurrentPage = ((CFifoQueue<PVOID> *)m_pbQueueBuffer)->m_pfqpHead;
    PVOID pvData = NULL;
    DWORD i = 0;

    if (!pvCurrentPage)
        return NULL;

    //Loop over empty entries (left by DSN generation) or until
    //we reach the end of the queue
    do
    {
        //Figure out if we are on a page boundary
        if (FIFOQ_QUEUE_PAGE_SIZE == m_iCurrentIndexInPage)
        {
            m_iCurrentIndexInPage = 0;
            m_iCurrentPage++;
        }

        //Get current page
        for (i = 0; i < m_iCurrentPage; i++)
        {
            pvCurrentPage = pvGetNextPage(pvCurrentPage);
            if (!pvCurrentPage)
                return NULL;
        }

        if (!((CFifoQueuePage<PVOID> *)pvCurrentPage)->m_rgpqdata)
            return NULL;

        //Get data from current page
        pvData = ((CFifoQueuePage<PVOID> *)pvCurrentPage)->m_rgpqdata[m_iCurrentIndexInPage];

        if ((m_iCurrentIndexInPage > m_iTailIndex) && !pvGetNextPage(pvCurrentPage))
        {
            //We at the end of data
            return NULL;
        }
        m_iCurrentIndexInPage++;
    } while (!pvData);

    return pvData;
}


//---[ CDMQDbgIterator ]-------------------------------------------------------
//
//
//  Description:
//      Constructor for CDMQDbgIterator
//  Parameters:
//      pApis       A ptr to the PWINDBG_EXTENSION_APIS struct passed in by
//                  the debugger.
//  Returns:
//      -
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDMQDbgIterator::CDMQDbgIterator(PWINDBG_EXTENSION_APIS pApis)
{
    ZeroMemory(m_pbDMQBuffer, sizeof(m_pbDMQBuffer));
    ZeroMemory(m_pvFifoQOtherProc, sizeof(m_pvFifoQOtherProc));
    ZeroMemory(m_szName, sizeof(m_szName));
    m_pdmq = (CDestMsgQueue *)m_pbDMQBuffer;
    m_iCurrentFifoQ = 0;
    m_cCount = 0;
    pExtensionApis = pApis;
    m_cItemsReturnedThisQueue = 0;
}

//---[ CDMQDbgIterator::fInit ]------------------------------------------------
//
//
//  Description:
//      Initializes the iterator (and the iterators for all its queues
//  Parameters:
//      hCurrentProcess     Handle to the debuggee process
//      pvAddressOtherProc  Addess of the DMQ in the debugee process
//  Returns:
//      TRUE on success
//      FALSE otherwise
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CDMQDbgIterator::fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    DWORD   i = 0;
    PVOID   pvQueue = NULL;
    BOOL    fVerbose = TRUE && pExtensionApis;
    BYTE    pbDomainEntry[sizeof(CDomainEntry)];
    CDomainEntry *pdentry = (CDomainEntry *)pbDomainEntry;

    if (!ReadMemory(pvAddressOtherProc, m_pbDMQBuffer,
         sizeof(m_pbDMQBuffer), NULL))
    {
        if (fVerbose) dprintf("ReadMemory failex 0x%X\n", GetLastError());
        return FALSE;
    }

    if (DESTMSGQ_SIG != m_pdmq->m_dwSignature)
    {
        if (fVerbose) dprintf("Bad signature\n");
        return FALSE;
    }

    //Get domain if possible
    if (ReadMemory(m_pdmq->m_dmap.m_pdentryDomainID,
        pbDomainEntry, sizeof(pbDomainEntry), NULL))
    {

        ReadMemory(pdentry->m_szDomainName, m_szName,
            (DWORD)MIN((sizeof(m_szName)-1), (pdentry->m_cbDomainName+1)), NULL);
    }

    for (i = 0; i < NUM_PRIORITIES; i++)
    {
        m_rgfifoqdbg[i].SetApis(pExtensionApis);
        pvQueue = m_pdmq->m_rgpfqQueues[i];
        m_pvFifoQOtherProc[i] = pvQueue;

        if (pvQueue)
        {
            if (!m_rgfifoqdbg[i].fInit(hCurrentProcess, pvQueue))
            {
                if (fVerbose) dprintf("Cannot init queue %d at 0x%X\n", i, pvQueue);
                return FALSE;
            }
            m_cCount += m_rgfifoqdbg[i].cGetCount();
        }
    }

    //Init retry queue
    m_rgfifoqdbg[NUM_PRIORITIES].SetApis(pExtensionApis);
    pvQueue = (((PBYTE)pvAddressOtherProc) + FIELD_OFFSET(CDestMsgQueue, m_fqRetryQueue));
    m_pvFifoQOtherProc[NUM_PRIORITIES] = pvQueue;

    if (pvQueue)
    {
        if (!m_rgfifoqdbg[NUM_PRIORITIES].fInit(hCurrentProcess, pvQueue))
        {
            if (fVerbose) dprintf("Cannon init retry queue at 0x%X\n", pvQueue);
            return FALSE;
        }

        m_cCount += m_rgfifoqdbg[NUM_PRIORITIES].cGetCount();
    }

    return TRUE;
}

//---[ CDMQDbgIterator::pvGetNext ]--------------------------------------------
//
//
//  Description:
//      Gets the next item from the DMQ
//  Parameters:
//      -
//  Returns:
//      An ptr to the item in the debuggee process on success
//      NULL when there are no more items
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CDMQDbgIterator::pvGetNext()
{
    PVOID pvItem = NULL;

    while (m_iCurrentFifoQ <= NUM_PRIORITIES)
    {
        if (m_pvFifoQOtherProc[m_iCurrentFifoQ])
        {
            if (m_rgfifoqdbg[m_iCurrentFifoQ].cGetCount())
            {
                pvItem = m_rgfifoqdbg[m_iCurrentFifoQ].pvGetNext();

                //If we found an item we are done
                if (pvItem)
                {
                    //If it is the first item annouce this queue
                    if (!m_cItemsReturnedThisQueue && pExtensionApis)
                    {
                        dprintf("Dumping FifoQueue at address 0x%08X:\n",
                                m_pvFifoQOtherProc[m_iCurrentFifoQ]);
                    }

                    m_cItemsReturnedThisQueue++;
                    break;
                }
            }
        }
        m_iCurrentFifoQ++;
        m_cItemsReturnedThisQueue = 0;
    }

    return pvItem;
}


//---[ CQueueDbgIterator ]-----------------------------------------------------
//
//
//  Description:
//      Constructor for CQueueDbgIterator
//  Parameters:
//      pApis       A ptr to the PWINDBG_EXTENSION_APIS struct passed in by
//                  the debugger.
//  Returns:
//      -
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CQueueDbgIterator::CQueueDbgIterator(PWINDBG_EXTENSION_APIS pApis)
{
    pExtensionApis = pApis;
    m_pqdbgi = NULL;
    m_QueueType = AQ_QUEUE_TYPE_UNKNOWN;
}

//---[ CQueueDbgIterator::fInit ]----------------------------------------------
//
//
//  Description:
//      Initialized generic queue iterator.  Will determine the type
//      of queue and initialize the correct type-specific iterator.
//  Parameters:
//      hCurrentProcess     Handle to the debuggee process
//      pvAddressOtherProc  Addess of the DMQ in the debugee process
//  Returns:
//      TRUE on success
//      FALSE otherwise
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CQueueDbgIterator::fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    LPSTR   szQueueType = "unknown";
    m_QueueType = GetQueueType(hCurrentProcess, pvAddressOtherProc);

    switch (m_QueueType)
    {
      case AQ_QUEUE_TYPE_DMQ:
        m_pqdbgi = (IQueueDbgIterator *) &m_dmqdbg;
        szQueueType = "DMQ";
        break;
      case AQ_QUEUE_TYPE_FIFOQ:
        m_pqdbgi = (IQueueDbgIterator *) &m_fifoqdbg;
        szQueueType = "CFifoQueue";
        break;
      case AQ_QUEUE_TYPE_LMQ:
        m_pqdbgi = (IQueueDbgIterator *) &m_lmqdbg;
        szQueueType = "LMQ";
        break;
      default:
        return FALSE;
    }

    if (!m_pqdbgi)
        return FALSE;

    m_pqdbgi->SetApis(pExtensionApis);
    if (!m_pqdbgi->fInit(hCurrentProcess, pvAddressOtherProc))
        return FALSE;

    if (pExtensionApis)
    {
        dprintf("Dumping %s (%s) at address 0x%08X:\n",
            szQueueType, m_pqdbgi->szGetName(), pvAddressOtherProc);
    }

    return TRUE;
}

//---[ CQueueDbgIterator::cGetCount ]------------------------------------------
//
//
//  Description:
//      Returns count of items in queue
//  Parameters:
//      -
//  Returns:
//      count of items in queue
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
DWORD CQueueDbgIterator::cGetCount()
{
    if (!m_pqdbgi)
        return 0;
    else
        return m_pqdbgi->cGetCount();
}

//---[ CQueueDbgIterator::pvGetNext ]------------------------------------------
//
//
//  Description:
//      Returns the next item pointed to by the iterator
//  Parameters:
//      -
//  Returns:
//      Pointer to next item in debugee process on success
//      NULL if no more items or failure
//  History:
//      10/21/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CQueueDbgIterator::pvGetNext()
{
    if (!m_pqdbgi)
        return NULL;
    else
        return m_pqdbgi->pvGetNext();
}

//---[ CQueueDbgIterator::szGetName ]------------------------------------------
//
//
//  Description:
//      Returns the name of the iterator
//  Parameters:
//      -
//  Returns:
//      Pointer to string for iterator
//      NULL if no name
//  History:
//      10/22/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
LPSTR CQueueDbgIterator::szGetName()
{
    if (!m_pqdbgi)
        return NULL;
    else
        return m_pqdbgi->szGetName();
}

//---[ CLMQDbgIterator::CLMQDbgIterator ]--------------------------------------
//
//
//  Description:
//
//  Parameters:
//
//  Returns:
//
//  History:
//      10/22/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CLMQDbgIterator::CLMQDbgIterator(PWINDBG_EXTENSION_APIS pApis)
{
    ZeroMemory(m_pbLMQBuffer, sizeof(m_pbLMQBuffer));
    ZeroMemory(m_rgpvDMQOtherProc, sizeof(m_rgpvDMQOtherProc));
    ZeroMemory(m_szName, sizeof(m_szName));
    ZeroMemory(m_rgpvItemsPendingDelivery, sizeof(m_rgpvItemsPendingDelivery));
    ZeroMemory(m_rgpvConnectionsOtherProc, sizeof(m_rgpvConnectionsOtherProc));
    m_plmq = (CLinkMsgQueue *)m_pbLMQBuffer;
    m_iCurrentDMQ = 0;
    m_cCount = 0;
    m_cItemsThisDMQ = 0;
    m_cPending = 0;
    pExtensionApis = pApis;
}

//---[ CLMQDbgIterator::fInit ]------------------------------------------------
//
//
//  Description:
//      Initializes iterator for CLinkMsgQueue
//  Parameters:
//      hCurrentProcess     Handle to the debuggee process
//      pvAddressOtherProc  Addess of the DMQ in the debugee process
//  Returns:
//
//  History:
//      10/22/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL CLMQDbgIterator::fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc)
{
    DWORD   i = 0;
    PLIST_ENTRY pliCurrent = NULL;
    PLIST_ENTRY pliHead = NULL;
    BYTE    pbConnection[sizeof(CSMTPConn)];
    CSMTPConn *pConn = (CSMTPConn *)pbConnection;
    PVOID   pvPending = NULL;
    PVOID   pvConnOtherProc = NULL;
    BOOL    fVerbose = TRUE && pExtensionApis;

    if (!ReadMemory(pvAddressOtherProc, m_pbLMQBuffer,
         sizeof(m_pbLMQBuffer), NULL))
    {
        if (fVerbose) dprintf("ReadMemory failex 0x%X\n", GetLastError());
        return FALSE;
    }

    if (LINK_MSGQ_SIG != m_plmq->m_dwSignature)
    {
        if (fVerbose) dprintf("Signature does not match\n");
        return FALSE;
    }

    //Read in address of all the queues for this link
    //$$TODO - Support more than 1 quick list
    memcpy(m_rgpvDMQOtherProc, m_plmq->m_qlstQueues.m_rgpvData,
           sizeof(m_rgpvDMQOtherProc));

    //Read in name of link
    ReadMemory(m_plmq->m_szSMTPDomain, m_szName,
        (DWORD)MIN((sizeof(m_szName)-1), (m_plmq->m_cbSMTPDomain+1)), NULL);

    for (i = 0; i < MAX_QUEUES_PER_LMQ; i++)
    {
        if (m_rgpvDMQOtherProc[i])
        {
            m_rgdmqdbg[i].SetApis(pExtensionApis);
            if (!m_rgdmqdbg[i].fInit(hCurrentProcess, m_rgpvDMQOtherProc[i]))
            {
                if (fVerbose)
                    dprintf("Unable to init DMQ at 0x%X\n", m_rgpvDMQOtherProc[i]);
                return FALSE;
            }
            m_cCount += m_rgdmqdbg[i].cGetCount();
        }
    }

    //Get the messages pending on a connection

    pliCurrent = m_plmq->m_liConnections.Flink;

    //Loop through connections and save those with pending messages.
    while (pliHead != pliCurrent)
    {
        pvConnOtherProc = ((PBYTE) pliCurrent)-FIELD_OFFSET(CSMTPConn, m_liConnections);
        if (!ReadMemory(pvConnOtherProc, pbConnection,
            sizeof(pbConnection), NULL))
        {
            break;
        }
        pliCurrent = pConn->m_liConnections.Flink;
        if (!pliHead)
            pliHead = pConn->m_liConnections.Blink;

        pvPending = pConn->m_dcntxtCurrentDeliveryContext.m_pmsgref;
        if (pvPending)
        {
            m_rgpvConnectionsOtherProc[m_cPending] = pvConnOtherProc;
            m_rgpvItemsPendingDelivery[m_cPending] = pvPending;
            m_cPending++;
            m_cCount++;
        }
        if (m_cPending >= MAX_CONNECTIONS_PER_LMQ)
            break;
    }
    return TRUE;
}

//---[ CLMQDbgIterator::pvGetNext ]--------------------------------------------
//
//
//  Description:
//      Gets the next item in the current DMQ.  Moves to next DMQ when that
//      is emtpy
//  Parameters:
//      -
//  Returns:
//      Next item on success
//      NULL when empty or failure
//  History:
//      10/22/1999 - MikeSwa Created
//
//-----------------------------------------------------------------------------
PVOID CLMQDbgIterator::pvGetNext()
{
    PVOID   pvItem = NULL;

    while (m_iCurrentDMQ < MAX_QUEUES_PER_LMQ)
    {
        if (m_rgpvDMQOtherProc[m_iCurrentDMQ])
        {
            if (!m_cItemsThisDMQ && m_rgdmqdbg[m_iCurrentDMQ].cGetCount())
            {
               if (pExtensionApis)
               {
                   dprintf("Dumping DMQ (%s) at address 0x%08X:\n",
                            m_rgdmqdbg[m_iCurrentDMQ].szGetName(),
                            m_rgpvDMQOtherProc[m_iCurrentDMQ]);
               }
            }
            pvItem = m_rgdmqdbg[m_iCurrentDMQ].pvGetNext();
            if (pvItem)
            {
                //Check if this is the first item for this DMQ
                m_cItemsThisDMQ++;
                break;
            }
        }
        m_iCurrentDMQ++;
        m_cItemsThisDMQ = 0;
    }

    //If the queues are empty, dump the connections
    if (!pvItem && m_cPending)
    {
        m_cPending--;
        if (pExtensionApis)
        {
            dprintf("Dumping Connection at address 0x%08X:\n",
                        m_rgpvConnectionsOtherProc[m_cPending]);
        }
        pvItem = m_rgpvItemsPendingDelivery[m_cPending];
    }
    return pvItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**


$(O)\intrnlqa.h $(O)\intrnlqa_i.c : $(STAXAQUEUE)\advqueue\intrnlqa.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\intrnlqa_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\intrnlqa_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
    
$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc + /a $(STAXINC)\export\caterr.mc + /a ..\..\server\smtpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

!ifndef INETAMSG_MC_PATH
INETAMSG_MC_PATH=..\..\..\..\inc
!endif
$(O)\smtpmsg.h $(O)\smtpmsg.rc $(O)\msg00002.bin: ..\..\server\smtpmsg.mc $(INETAMSG_MC_PATH)\inetamsg.mc
    copy /a $(INETAMSG_MC_PATH)\inetamsg.mc + /a ..\..\server\smtpmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\smtpmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\smtpmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdbgext\fifoqdbg.h ===
//-----------------------------------------------------------------------------
//
//
//  File: fifoqdbg.h
//
//  Description:    Debugger extension for base AQ queue classes
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      9/13/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __FIFOQDBG_H__
#define __FIFOQDBG_H__

#ifdef PLATINUM
#include <phatqdbg.h>
#else
#include <aqdbgext.h>
#endif // PLATINUM

#include <fifoq.h>
#include <destmsgq.h>
#include <linkmsgq.h>

enum AQ_QUEUE_TYPE {
    AQ_QUEUE_TYPE_UNKNOWN,
    AQ_QUEUE_TYPE_FIFOQ,
    AQ_QUEUE_TYPE_DMQ,
    AQ_QUEUE_TYPE_LMQ,
};


//---[ IQueueDbgIterator ]-----------------------------------------------------
//
//
//  Description:
//      Generic queue iterator for the debug extensions.  Users should
//      use CQueueDbgIterator directly
//  Hungarian:
//      qdbgi, pqdbgi
//
//-----------------------------------------------------------------------------
class IQueueDbgIterator
{
  public:
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc) = 0;
    virtual DWORD   cGetCount() = 0;
    virtual PVOID   pvGetNext() = 0;
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) = 0;
    virtual LPSTR   szGetName() = 0;
};

//---[ CFifoQueueDbgIterator ]-------------------------------------------------
//
//
//  Description:
//      Iterator class that will iterate over all the elements of a fifoq
//  Hungarian:
//      fifoqdbg, pfifoqdbg
//
//-----------------------------------------------------------------------------
class CFifoQueueDbgIterator :
    public IQueueDbgIterator
{
  protected:
    BYTE    m_pbQueueBuffer[sizeof(CFifoQueue<PVOID>)];
    DWORD   m_iCurrentPage;
    DWORD   m_iCurrentIndexInPage;
    DWORD   m_cPagesLoaded;
    DWORD   m_iHeadIndex;
    DWORD   m_iTailIndex;
    PWINDBG_EXTENSION_APIS pExtensionApis;
  public:
    CFifoQueueDbgIterator(PWINDBG_EXTENSION_APIS pApis = NULL);
    ~CFifoQueueDbgIterator();
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
    virtual DWORD   cGetCount();
    virtual PVOID   pvGetNext();
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) {pExtensionApis = pApis;};
    virtual LPSTR   szGetName() {return NULL;};
};

//---[ CDMQDbgIterator ]-------------------------------------------------------
//
//
//  Description:
//      Iterartor class for DMQ... will dump every item on all its fifo queues
//  Hungarian:
//      dmqdbg, pdmqdbg
//
//-----------------------------------------------------------------------------
class CDMQDbgIterator :
    public IQueueDbgIterator
{
  protected:
    BYTE                    m_pbDMQBuffer[sizeof(CDestMsgQueue)];
    CDestMsgQueue          *m_pdmq;
    DWORD                   m_iCurrentFifoQ;
    DWORD                   m_cCount;
    DWORD                   m_cItemsReturnedThisQueue;
    PWINDBG_EXTENSION_APIS  pExtensionApis;
    PVOID                   m_pvFifoQOtherProc[NUM_PRIORITIES+1];
    CFifoQueueDbgIterator   m_rgfifoqdbg[NUM_PRIORITIES+1];
    CHAR                    m_szName[MAX_PATH];
  public:
    CDMQDbgIterator(PWINDBG_EXTENSION_APIS pApis = NULL);
    ~CDMQDbgIterator() {};
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
    virtual DWORD   cGetCount() {return m_cCount;};
    virtual PVOID   pvGetNext();
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) {pExtensionApis = pApis;};
    virtual LPSTR   szGetName() {return m_szName;};
};

//---[ CLMQDbgIterator ]-------------------------------------------------------
//
//
//  Description:
//      Debug iterator for CLinkMsgQueue
//  Hungarian:
//      lmqdbg, plmqdbg
//
//-----------------------------------------------------------------------------
const   DWORD   MAX_QUEUES_PER_LMQ  = QUICK_LIST_PAGE_SIZE;
const   DWORD   MAX_CONNECTIONS_PER_LMQ  = QUICK_LIST_PAGE_SIZE;
class CLMQDbgIterator :
  public IQueueDbgIterator
{
  protected:
    BYTE                    m_pbLMQBuffer[sizeof(CLinkMsgQueue)];
    CLinkMsgQueue          *m_plmq;
    DWORD                   m_iCurrentDMQ;
    PVOID                   m_rgpvDMQOtherProc[MAX_QUEUES_PER_LMQ];
    CDMQDbgIterator         m_rgdmqdbg[MAX_QUEUES_PER_LMQ];
    PVOID                   m_rgpvItemsPendingDelivery[MAX_CONNECTIONS_PER_LMQ];
    PVOID                   m_rgpvConnectionsOtherProc[MAX_CONNECTIONS_PER_LMQ];
    DWORD                   m_cPending;
    DWORD                   m_cCount;
    DWORD                   m_cItemsThisDMQ;
    PWINDBG_EXTENSION_APIS  pExtensionApis;
    CHAR                    m_szName[MAX_PATH];
  public:
    CLMQDbgIterator(PWINDBG_EXTENSION_APIS pApis = NULL);
    ~CLMQDbgIterator() {};
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
    virtual DWORD   cGetCount() {return m_cCount;};
    virtual PVOID   pvGetNext();
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) {pExtensionApis = pApis;};
    virtual LPSTR   szGetName() {return m_szName;};
};

//---[ CQueueDbgIterator ]-----------------------------------------------------
//
//
//  Description:
//      "Smart" iterator that will figure out what kind of queue it is being
//      called on, and will use the correct kind of iterator for it.
//  Hungarian:
//      qdbg, pqdbg
//
//-----------------------------------------------------------------------------
class CQueueDbgIterator :
    public  IQueueDbgIterator
{
  protected:
    AQ_QUEUE_TYPE           m_QueueType;
    IQueueDbgIterator      *m_pqdbgi;
    CFifoQueueDbgIterator   m_fifoqdbg;
    CDMQDbgIterator         m_dmqdbg;
    CLMQDbgIterator         m_lmqdbg;
    PWINDBG_EXTENSION_APIS  pExtensionApis;
  public:
    CQueueDbgIterator(PWINDBG_EXTENSION_APIS pApis);
    virtual BOOL    fInit(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
    virtual DWORD   cGetCount();
    virtual PVOID   pvGetNext();
    virtual VOID    SetApis(PWINDBG_EXTENSION_APIS pApis) {pExtensionApis = pApis;};
    virtual LPSTR   szGetName();
    AQ_QUEUE_TYPE GetQueueType(HANDLE hCurrentProcess, PVOID pvAddressOtherProc);
};

#endif //__FIFOQDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc

$(O)\imsgerr.h $(O)\imsgerr.rc $(O)\msg00001.bin: $(STAXINC)\export\imsgerr.mc
    copy /a $(STAXINC)\export\imsgerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\imsgerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\imsgerr.rc
    del  $(O)\tmp.rc

$(O)\phatqmsg.h $(O)\phatqmsg.rc $(O)\msg00001.bin: $(STAXINC)\export\phatqmsg.mc
    copy /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\phatqmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\phatqmsg.rc
    del  $(O)\tmp.rc


$(O)\smtpdisp.h $(O)\smtpdisp_i.c : $(STAXINC)\export\smtpdisp.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpdisp_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpdisp_i.c \
    -header $@ \
    -tlb $(O)\smtpdisp.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**


$(O)\imsg.h $(O)\imsg_i.c : $(STAXINC)\export\imsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\imsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\imsg_i.c \
    -header $@ \
    -tlb $(O)\imsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\seo.h $(O)\seo_i.c : $(STAXINC)\export\seo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\seo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\seo_i.c \
    -header $@ \
    -tlb $(O)\seo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\cdo.h $(O)\cdo_i.c : $(STAXINC)\cdo.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\cdo_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\cdo_i.c \
    -header $@ \
    -tlb $(O)\cdo.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\catparams.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: catparams.cpp
//
// Contents: Categorizer server event parameter classes
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1998/06/23 13:13:58: Created.
//
//-------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <mailmsg.h>
#include <dbgtrace.h>
#include <cpool.h>
#include <filehc.h>
#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL
#include <seo.h>
#include <seolib.h>
#include <smtpdisp_i.c>
#include <mailmsgi.h>
#include <smtpevent.h>
#include <seomgr.h>

#define MAX_RULE_LENGTH 4096
//
// Message object
//
#define MAILMSG_PROGID          L"Exchange.MailMsg"

#define INITGUID
#include "initguid.h"
#include "smtpguid.h"
#include "wildmat.h"
#include "smtpdisp.h"
#include "seodisp.h"

#include "evntwrap.h"

//
// CMailTransportCatRegisterParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatRegisterParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatRegisterParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatRegisterParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->Register(
        m_pContext->pICatParams);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    if(FAILED(hrRes) && (hrRes != E_NOTIMPL) && SUCCEEDED(m_pContext->hrSinkStatus)) {
        //
        // Set the first failure value
        //
        m_pContext->hrSinkStatus = hrRes;
    }

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatRegisterParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    if(FAILED(hr) && (hr != E_NOTIMPL) && SUCCEEDED(m_pContext->hrSinkStatus)) {
        //
        // Set the first failure value
        //
        m_pContext->hrSinkStatus = hr;
    }
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatBeginParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBeginParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBeginParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBeginParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BeginMessageCategorization(
        m_pContext->pICatMailMsgs);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBeginParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBeginParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBeginParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//
// CMailTransportCatEndParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatEndParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatEndParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatEndParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->EndMessageCategorization(
        m_pContext->pICatMailMsgs,
        m_pContext->hrStatus);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatEndParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatEndParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatEndParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//
// CMailTransportCatBuildQueryParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueryParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BuildQuery(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault()
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueryParams::CallDefault");
    HRESULT hr;

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT);

    hr = (m_pContext->pfnDefault)(S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatBuildQueriesParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->BuildQueries(
        m_pContext->pICatParams,
        m_pContext->dwcAddresses,
        m_pContext->rgpICatItems,
        m_pContext->pICatQueries);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatBuildQueriesParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatSendQueryParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->SendQuery(
        m_Context.pICatParams,
        m_Context.pICatQueries,
        m_Context.pICatAsyncContext,
        (LPVOID)&m_Context);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);

    pSink->Release();

    //
    // SendQuery return values:
    //   MAILTRANSPORT_S_PEDING: Will call (or already called)
    //   ICategorizerAsyncContext.CompleteQuery with the result of
    //   this lookup
    //   S_OK: Will not call CompleteQuery, please continue
    //   S_FALSE: Will not call CompleteQuery, please stop calling sinks
    //   Everything else: Will not call CompleteQuery.
    //

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);

    hr = (*m_Context.pfnDefault) (S_OK, &m_Context);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion(
    HRESULT hrStatus)
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSendQueryParams::CallCompletion");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT);


    hr = (*m_Context.pfnCompletion) (hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
//
// CMailTransportCatSortQueryResultParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->SortQueryResult(
        m_pContext->pICatParams,
        m_pContext->hrResolutionStatus,
        m_pContext->dwcAddresses,
        m_pContext->rgpICatItems,
        m_pContext->dwcResults,
        m_pContext->rgpICatItemAttributes);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault()
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatSortQueryResultParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatProcessItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatProcessItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->ProcessItem(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatProcessItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// CMailTransportCatExpandItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;
    BOOL fAlreadyAsync;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    //
    // Since it is possible for this to return pending before we
    // analyze the return value, assume it will return pending
    // beforehand
    //
    fAlreadyAsync = m_fAsyncCompletion;
    m_fAsyncCompletion = TRUE;

    DebugTrace((LPARAM)this, "Calling expanditem event on this sink");

    hrRes = pSink->ExpandItem(
        m_Context.pICatParams,
        m_Context.pICatItem,
        m_pINotify,
        (PVOID)this);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);

    //
    // If it actuall returned sync, restore m_fAsyncCompletion to its
    // old value
    //
    if(hrRes != MAILTRANSPORT_S_PENDING) {

        m_fAsyncCompletion = fAlreadyAsync;
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }
    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault()
{
    HRESULT hr;
    BOOL fAlreadyAsync;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    //
    // Since it is possible for this to return pending before we
    // analyze the return value, assume it will return pending
    // beforehand
    //
    fAlreadyAsync = m_fAsyncCompletion;
    m_fAsyncCompletion = TRUE;

    hr = (*m_Context.pfnDefault) (S_OK, &m_Context);
    //
    // If it actuall returned sync, restore m_fAsyncCompletion to its
    // old value
    //
    if(hr != MAILTRANSPORT_S_PENDING)
        m_fAsyncCompletion = fAlreadyAsync;

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//   Or return value from supplied completion routine
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion(
    HRESULT hrStatus)
{
    HRESULT hr = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatExpandItemParams::CallCompletion");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT);

    //
    // The way ExpandItem works is the following:
    //  If any sinks return MAILTRANSPORT_S_PENDING (including the default), 
    //  then TriggerServerEvent returns MAILTRANSPORT_S_PENDING, and
    //  the supplied completion routine will be called. 
    //  Otherwise, TriggerServerEvent returns S_OK and no completion
    //  routine is called
    //
    if(m_fAsyncCompletion)

        hr = (*m_Context.pfnCompletion) (hrStatus, &m_Context);
        
    CStoreBaseParams::CallCompletion(hrStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}



//
// CMailTransportCatCompleteItemParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject
//
// Synopsis: Call the sink
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//  error from QI or sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportCategorize *pSink;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatCompleteItemParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT);

    hrRes = punkObject->QueryInterface(
        IID_IMailTransportCategorize,
        (PVOID *)&pSink);

    if(FAILED(hrRes)) {
        ErrorTrace((LPARAM)this, "QI failed on sink, hr %08lx", hrRes);
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->CompleteItem(
        m_pContext->pICatParams,
        m_pContext->pICatItem);

    DebugTrace((LPARAM)this, "Sink returned hr %08lx", hrRes);
    //
    // This sink is not allowed to be async...
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    pSink->Release();

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault()
{
    HRESULT hr;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportCatCompleteItemParams::CallDefault");
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT);

    hr = (*m_pContext->pfnDefault) (S_OK, m_pContext);

    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\newwild.cpp ===
#define INCL_INETSRV_INCS
#include "smtpinc.h"
#include "wildmat.h"

//---[ Description of the Wildmat standard ]-----------------------------------
//
//  Taken from:
//
//  INTERNET-DRAFT                                               S. Barber
//  Expires: September 1, 1996                  Academ Consulting Services
//                                                              April 1996
//                           Common NNTP Extensions
//                        draft-barber-nntp-imp-03.txt
//  
//      The WILDMAT format was first developed by Rich Salz to provide
//      a uniform mechanism for matching patterns in the same manner
//      that the UNIX shell matches filenames. There are five pattern
//      matching operations other than a strict one-to-one match
//      between the pattern and the source to be checked for a match.
//      The first is an asterisk (*) to match any sequence of zero or
//      more characters. The second is a question mark (?) to match any
//      single character. The third specifies a specific set of
//      characters. The set is specified as a list of characters, or as
//      a range of characters where the beginning and end of the range
//      are separated by a minus (or dash) character, or as any
//      combination of lists and ranges. The dash can also be included
//      in the range as a character it if is the beginning or end of
//      the range. This set is enclosed in square brackets. The close
//      square bracket (]) may be used in a range if it is the first
//      character in the set. The fourth operation is the same as the
//      logical not of the third operation and is specified the same
//      way as the third with the addition of a caret character (^) at
//      the beginning of the test string just inside the open square
//      bracket. The final operation uses the backslash character to
//      invalidate the special meaning of the a open square bracket ([),
//      the asterisk, or the question mark.
//  
//  3.3.1 Examples
//  
//      a. [^]-] -- matches any character other than a close square bracket
//                  or a minus sign/dash.
//  
//      b. *bdc  -- matches any string that ends with the string "bdc"
//                  including the string "bdc" (without quotes).
//  
//      c. [0-9a-zA-Z] -- matches any string containing any alphanumeric string
//                  in English.
//  
//      d. a??d  --  matches any four character string which begins
//                   with a and ends with d.
//  
//-----------------------------------------------------------------------------



//----[ NOTES ]----------------------------------------------------------------
//                                                                            
// 		This function will raise an invalid access exception if either pszText                                                     
// 		or pszPattern is invalid or not null terminated while dereferencing the                                                    
// 		string. If this is possible, surround the call in a try-except block.                                                      
//  
//-----------------------------------------------------------------------------



//---[ Defines ]---------------------------------------------------------------

#define STACK_SIZE      256



//---[ HrMatchWildmat ]--------------------------------------------------------
//
//  Description:
//
//      Provides support for the "Wildmat" wild-card matching standard. See
//      description above.
//
//  Params:
//
//      pszText         String to test
//      pszPattern      Pattern to test against
//
//  Returns:
//      
//      ERROR_SUCCESS               If function succeeded, and match was found
//      ERROR_INVALID_PARAMETER     Text or pattern string is invalid
//      
//      ERROR_CAN_NOT_COMPLETE      Some other error occurred.
//
//  
//-----------------------------------------------------------------------------


HRESULT HrMatchWildmat(const char* pszText, const char* pszPattern)
{


	_ASSERT(pszText != NULL && pszPattern != NULL);



	BOOL fCharSet = FALSE;	// TRUE if currently parsing a character set in a pattern
	BOOL fNegated = FALSE;	// TRUE if there is a '^' at the beginning of the set
	BOOL fInSet   = FALSE;  // indicates when matching of a character set has completed
				// used to short-circuit character set evaluation
	int iStackPtr = 0;	// stack pointer
    
	const char* textStack[STACK_SIZE];	// stack of text pointers
	const char* patternStack[STACK_SIZE];	// stack of pattern pointers


	// If the pattern consists solely of a * then any text will match
	if (strcmp(pszPattern, "*") == 0)
		return ERROR_SUCCESS;


	while (TRUE) 
    {
		switch (*pszPattern) 
        {
		    case '*':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
                    

				// If there is a * at the end of the pattern then at this point we are
				// sure that we got a match
				if (pszPattern[1] == '\0')
					return ERROR_SUCCESS;


				// We could write a simpler recursive wildmat function. Here we would
				// recursively call wildmat. Instead, for performance reasons this
				// solution is iterative.
				// Here we save the current values of the text pointer and stack pointer
				// on a stack and we leave the * in the pattern, with the effect of
				// matching one character with the *. The next time through the while
				// loop, the * will still be in the pattern, thus we will try to match
				// the rest of the input with this *. If it turns to fail, we go back
				// one character.
				// See the comments right before the BACK label below.
		    	if (*pszText != '\0') 
                {
		    		if (iStackPtr == STACK_SIZE) 
                        return ERROR_CAN_NOT_COMPLETE;			// stack overflow
                        
		    		textStack[iStackPtr] = pszText;			// save current text pointer
		    		patternStack[iStackPtr] = pszPattern;	// save current pattern pointer
		    		iStackPtr++;
		    		pszPattern--;	// leave * in the input pattern and match one character
		    	}
		    	break;

		    case '?':
		    	if (fCharSet) 
                    goto DEFAULT;	// according to unix solution this is not an error
		    	if (*pszText == '\0') 
                    goto BACK;
		    	break;

		    case '[':
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
                    
		    	fCharSet = TRUE;		    // beginning a character set
		    	fNegated = FALSE;			// so far we haven't seen a '^'
		    	fInSet = FALSE;				// used to short-circuit the evaluation of
		    						// membership to the character set

		    	// treat '^', '-' and ']' as special cases if they are
		    	// at the beginning of the character set (also "[^-a]" and "[^]a]")
		    	if (pszPattern[1] == '^') 
                {
		    		fNegated = TRUE;
		    		pszPattern++;
		    	}
		    	// '-' and ']' are literals if they appear at the beggining of the set
		    	if (pszPattern[1] == '-' || pszPattern[1] == ']') 
                {
		    		fInSet = (*pszText == pszPattern[1]);
		    		pszPattern++;
		    	}
		    	break;
		    		
		    case ']':
		    	if (fCharSet) 
                {
		    		if ((!fNegated && !fInSet) || (fNegated && fInSet)) 
                        goto BACK;
                        
		    		fCharSet = FALSE;		// this marks the end of a character set
		    	} 
                else 
                {
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '-':
		    	if (fCharSet) 
                {
		    		unsigned char startRange = pszPattern[-1];	// we use unsigned char
					unsigned char endRange;						// to support extended
					unsigned char ch;							// characters

		    		if (pszPattern[1] == '\0')
		    			return ERROR_INVALID_PARAMETER;
		    		else 
                    {
                        if (pszPattern[1] == ']')		// a dash at the end of the set is
		    			    fInSet = (*pszText == '-');	// treated as a literal
		    		    else 
                        {							    // we have a range
		    		    	if (pszPattern[1] == '\\')  // escape character, skip it
                            {	
		    		    		pszPattern++;
		    		    		if (pszPattern[1] == '\0') 
                                    return ERROR_INVALID_PARAMETER;
		    		    	}
							ch = *pszText;
							endRange = pszPattern[1];

							if (startRange > endRange)
								return ERROR_INVALID_PARAMETER;
							// here is where we could need unsigned characters
		    		    	fInSet = (ch >= startRange && ch <= endRange);
		    		    	pszPattern++;
		    		    	break;
		    		    }
                    }
		    	} 
                else 
                {						// outside a character set '-' has no special meaning
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	}
		    	break;

		    case '\0':					// end of the pattern
		    	if (fCharSet) 
                    return ERROR_INVALID_PARAMETER;
		    	if (*pszText == '\0')
		    		return ERROR_SUCCESS;
		    	else
		    		goto BACK;
		    	break;

		    default:				
DEFAULT:    	
                if (*pszPattern == '\\') 
                {
		    		pszPattern++;		// escape character, treat the next character as a literal
		    		if (*pszPattern == '\0') 
                        return ERROR_INVALID_PARAMETER;
		    	}
		    	if (!fCharSet) 
                {						// any other character is treated as a literal
		    		if (*pszText != *pszPattern) 
                        goto BACK;
		    	} 
                else 
                {
		    		// the following if takes care of the two "special" cases:
		    		//		[c-a]       (we don't want to accept c), and
		    		//		[c-]		(we want to accept c)
		    		if (!(pszPattern[1] == '-' && pszPattern[2] != ']'))
		    			fInSet = (*pszText == *pszPattern);
		    	}
		    	break;
		} // switch

		pszPattern++;
		
        if (!fCharSet) 
        {
			if (*pszText != '\0') 
                pszText++;
		} 
        else 
        {               			// code to short-circuit character set evaluation
			if (fInSet) 			// skip the rest of the character set
            {		
				while (*pszPattern != '\0' && *pszPattern != ']') 
                {
					if (*pszPattern == '\\')
                    {				// escape character, treat the next character as a literal
						pszPattern++;
						if (*pszPattern == '\0') 
                            return ERROR_INVALID_PARAMETER;
					}
					pszPattern++;
				}
			}
		}
		continue;	// the continue statement is to jump to the beginning of the loop,
					// we could have used used goto some label but that's what continue's
					// are for.


		// This is only reached by jumping to BACK.
		// This is equivalent to returning from a recursive solution of wildmat.
		// If the stack pointer is zero then the bottommost "recursive call" failed,
		// otherwise we "unwind one stack frame" and resume execution of the previous
		// call at the top of the while loop. Notice that since "recursive calls" are
		// only done when we find a '*' in the pattern outside a character set, the
		// value of fCharSet has to be set to false.
BACK:	
        if (iStackPtr == 0)                     	// we exhausted all possibilities
            return ERROR_FILE_NOT_FOUND;
            
		iStackPtr--;						    	// try matching no characters with the '*'
		pszText = textStack[iStackPtr];
		pszPattern = patternStack[iStackPtr] + 1;	// eat the '*' matching no input characters
		fCharSet = FALSE;				        	// this has to be the case
	} // while

    // should never get here
	_ASSERT(FALSE);						
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\seolib.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	seolib.cpp

Abstract:

	This module contains the implementations for various
	utility classes and functions of the Server	Extension
	Object system.

Author:

	Don Dumitru (dondu@microsoft.com)

Revision History:

	dondu	05/20/97	Created.

--*/


#include <stdio.h>
#include <windows.h>
#include <mailmsg.h>
#include <dbgtrace.h>
#include <cpool.h>
#include <filehc.h>
#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL
#include "seo.h"
#include "seolib.h"


CEventBaseDispatcher::CEventBaseDispatcher() {

	// nothing
}


CEventBaseDispatcher::~CEventBaseDispatcher() {

	// nothing
}


CEventBaseDispatcher::CBinding::CBinding() {

	m_bIsValid = FALSE;
}


CEventBaseDispatcher::CBinding::~CBinding() {

	// nothing
}


HRESULT CEventBaseDispatcher::CBinding::Init(IEventBinding *piBinding) {
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pProps;
	CComVariant varValue;

	if (!piBinding) {
		return (E_POINTER);
	}
	varValue.vt = VT_BOOL;
	hrRes = piBinding->get_Enabled(&varValue.boolVal);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	m_bIsValid = varValue.boolVal ? TRUE: FALSE;
	varValue.Clear();
	m_dwPriority = (DWORD) PRIO_DEFAULT;
	m_bExclusive = FALSE;
	m_piBinding = piBinding;
	hrRes = piBinding->get_SourceProperties(&pProps);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pProps->Item(&CComVariant(L"Priority"),&varValue);
	if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
		hrRes = varValue.ChangeType(VT_I4);
		if (SUCCEEDED(hrRes)) {
			if (varValue.lVal < PRIO_MIN) {
				varValue.lVal = PRIO_MIN;
			} else if (varValue.lVal > PRIO_MAX) {
				varValue.lVal = PRIO_MAX;
			}
			m_dwPriority = (DWORD) varValue.lVal;
		} else {
			hrRes = varValue.ChangeType(VT_BSTR);
			if (SUCCEEDED(hrRes)) {
				static struct {
					LPCWSTR pszString;
					DWORD dwValue;
				} sConvert[] = {{PRIO_HIGHEST_STR,PRIO_HIGHEST},
								{PRIO_HIGH_STR,PRIO_HIGH},
								{PRIO_MEDIUM_STR,PRIO_MEDIUM},
								{PRIO_LOW_STR,PRIO_LOW},
								{PRIO_LOWEST_STR,PRIO_LOWEST},
								{PRIO_DEFAULT_STR,PRIO_DEFAULT},
								{NULL,0}};
				for (DWORD dwIdx=0;sConvert[dwIdx].pszString;dwIdx++) {
					if (_wcsicmp(varValue.bstrVal,sConvert[dwIdx].pszString) == 0) {
						m_dwPriority = sConvert[dwIdx].dwValue;
						break;
					}
				}
			}
		}
	}
	varValue.Clear();
	hrRes = pProps->Item(&CComVariant(L"Exclusive"),&varValue);
	if (SUCCEEDED(hrRes) && (hrRes != S_FALSE)) {
		hrRes = varValue.ChangeType(VT_BOOL);
		if (SUCCEEDED(hrRes)) {
			m_bExclusive = (varValue.boolVal ? TRUE : FALSE);
		}
	}
	hrRes = InitRuleEngine();
	// ignore result
	return (S_OK);
}


int CEventBaseDispatcher::CBinding::Compare(const CBinding& b) const {

#if 0
	if (!m_bIsValid || !b.m_bIsValid) {
		if (m_bIsValid == b.m_bIsValid) {
			return (0);
		}
		if (!b.m_bIsValid) {
			return (-1);
		}
		return (1);
	}
#endif
	if (m_dwPriority == b.m_dwPriority) {
		return (0);
	}
	if (m_dwPriority < b.m_dwPriority) {
		return (-1);
	}
	return (1);
}


HRESULT CEventBaseDispatcher::CBinding::InitRuleEngine(IEventBinding *piBinding, REFIID iidDesired, IUnknown **ppUnkRuleEngine) {
	HRESULT hrRes;
	CComPtr<IEventPropertyBag> pProperties;
	CComVariant varValue;
	CStringGUID objGuid;

	if (ppUnkRuleEngine) {
		*ppUnkRuleEngine = NULL;
	}
	if (!piBinding || !ppUnkRuleEngine) {
		return (E_POINTER);
	}
	hrRes = piBinding->get_SourceProperties(&pProperties);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	hrRes = pProperties->Item(&CComVariant(L"RuleEngine"),&varValue);
	if (!SUCCEEDED(hrRes) || (hrRes == S_FALSE)) {
		return (hrRes);
	}
	hrRes = SEOCreateObject(&varValue,piBinding,pProperties,iidDesired,ppUnkRuleEngine);
	return (SUCCEEDED(hrRes)?S_OK:S_FALSE);
}


HRESULT CEventBaseDispatcher::CBinding::InitRuleEngine() {

	// default is to not to try to load a rule engine
	return (S_OK);
}


int CEventBaseDispatcher::CBindingList::Compare(CBinding* p1, CBinding* p2) {

	return (p1->Compare(*p2));
};


HRESULT CEventBaseDispatcher::CParams::CheckRule(CBinding& b) {

	// default behavior is to not pay attention to any "rules"
	return (S_OK);
}


HRESULT CEventBaseDispatcher::CParams::CallObject(IEventManager *piManager, CBinding& bBinding) {
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkSink;

	if (!piManager) {
		return (E_POINTER);
	}
	hrRes = piManager->CreateSink(bBinding.m_piBinding,NULL,&pUnkSink);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (CallObject(bBinding,pUnkSink));
}


HRESULT CEventBaseDispatcher::CParams::CallObject(CBinding& bBinding, IUnknown *pUnkSink) {
	HRESULT hrRes;
	CComQIPtr<IEventSinkNotify,&IID_IEventSinkNotify> pSink;
	CComQIPtr<IDispatch,&IID_IEventSinkNotifyDisp> pSinkDisp;
	DISPPARAMS dpNoArgs = {NULL,NULL,0,0};

	// Default behavior is to call IEventSinkNotify::OnEvent, or to call
	// IEventSinkNotifyDisp::Invoke passing DISPID_VALUE (which maps to OnEvent).
	//
	// This means that the base dispatcher is able to invoke simple COM objects.  If you
	// provide your own CallObject() routine, your routine call delegate this this base
	// implementation if you want to "inherit" this functionality.
	if (!pUnkSink) {
		return (E_POINTER);
	}
	pSink = pUnkSink;
	if (!pSink) {
		pSinkDisp = pUnkSink;
	}
	if (!pSink && !pSinkDisp) {
		return (E_NOINTERFACE);
	}
	if (pSink) {
		hrRes = pSink->OnEvent();
		return (S_OK);
	}
	hrRes = pSinkDisp->Invoke(DISPID_VALUE,
							  IID_NULL,
							  GetUserDefaultLCID(),
							  DISPATCH_METHOD,
							  &dpNoArgs,
							  NULL,
							  NULL,
							  NULL);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	return (S_OK);
}


HRESULT CEventBaseDispatcher::CParams::Abort() {

	return (S_FALSE);
}


HRESULT CEventBaseDispatcher::Dispatcher(REFGUID rguidEventType, CParams *pParams) {
	HRESULT hrRes;
	CETData *petdData;
	BOOL bObjectCalled = FALSE;

	petdData = m_Data.Find(rguidEventType);
	if (!petdData) {
		return (S_FALSE);
	}
	for (DWORD dwIdx=0;dwIdx<petdData->Count();dwIdx++) {
		if (!petdData->Index(dwIdx)->m_bIsValid) {
			continue;
		}
		if (bObjectCalled && petdData->Index(dwIdx)->m_bExclusive) {
			continue;
		}
		if (pParams->Abort() == S_OK) {
			break;
		}
		hrRes = pParams->CheckRule(*petdData->Index(dwIdx));
		if (hrRes == S_OK) {
			if (pParams->Abort() == S_OK) {
				break;
			}
			hrRes = pParams->CallObject(m_piEventManager,*petdData->Index(dwIdx));
			if (!SUCCEEDED(hrRes)) {
				continue;
			}
			bObjectCalled = TRUE;
			if ((hrRes == S_FALSE) || petdData->Index(dwIdx)->m_bExclusive) {
				break;
			}
		}
	}
	return (bObjectCalled?S_OK:S_FALSE);
}


HRESULT CEventBaseDispatcher::SetContext(REFGUID rguidEventType, IEventRouter *piRouter, IEventBindings *piBindings) {
	CETData* petData;
	HRESULT hrRes;
	CComPtr<IUnknown> pUnkEnum;
	CComQIPtr<IEnumVARIANT,&IID_IEnumVARIANT> pEnum;

	if (!piRouter || !piBindings) {
		return (E_POINTER);
	}
	if (!m_piEventManager) {
		hrRes = CoCreateInstance(CLSID_CEventManager,
								 NULL,
								 CLSCTX_ALL,
								 IID_IEventManager,
								 (LPVOID *) &m_piEventManager);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		m_piRouter = piRouter;
	}
	petData = m_Data.Find(rguidEventType);
	if (!petData) {
		hrRes = AllocETData(rguidEventType,piBindings,&petData);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		petData->m_guidEventType = rguidEventType;
		hrRes = m_Data.Add(petData);
		if (!SUCCEEDED(hrRes)) {
			delete petData;
			return (hrRes);
		}
	}
	petData->RemoveAll();
	hrRes = piBindings->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		return (hrRes);
	}
	pEnum = pUnkEnum;
	if (!pEnum) {
		return (E_NOINTERFACE);
	}
	while (1) {
		CComVariant varValue;
		CComQIPtr<IEventBinding,&IID_IEventBinding> pBinding;
		CBinding *pNewBinding;

		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			_ASSERTE(FALSE);
			continue;
		}
		pBinding = varValue.punkVal;
		if (!pBinding) {
			_ASSERTE(FALSE);
			continue;
		}
		hrRes = AllocBinding(rguidEventType,pBinding,&pNewBinding);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = pNewBinding->Init(pBinding);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		hrRes = petData->Add(pNewBinding);
		if (!SUCCEEDED(hrRes)) {
			delete pNewBinding;
			return (hrRes);
		}
	}
	return (S_OK);
}


CEventBaseDispatcher::CETData::CETData() {

	// nothing
}


CEventBaseDispatcher::CETData::~CETData() {

	// nothing
}


CEventBaseDispatcher::CETData* CEventBaseDispatcher::CETDataList::Find(REFGUID guidEventType) {

	// tbd - optimize
	for (DWORD dwIdx=0;dwIdx<Count();dwIdx++) {
		if (Index(dwIdx)->m_guidEventType == guidEventType) {
			return (Index(dwIdx));
		}
	}
	return (NULL);
}


HRESULT CEventBaseDispatcher::AllocBinding(REFGUID rguidEventType,
										   IEventBinding *piBinding,
										   CBinding **ppNewBinding) {

	if (ppNewBinding) {
		*ppNewBinding = NULL;
	}
	if (!piBinding || !ppNewBinding) {
		return (E_POINTER);
	}
	*ppNewBinding = new CBinding;
	if (!*ppNewBinding) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


HRESULT CEventBaseDispatcher::AllocETData(REFGUID guidEventType,
										  IEventBindings *piBindings,
										  CETData **ppNewETData) {

	if (ppNewETData) {
		*ppNewETData = NULL;
	}
	if (!piBindings || !ppNewETData) {
		return (E_POINTER);
	}
	*ppNewETData = new CETData;
	if (!*ppNewETData) {
		return (E_OUTOFMEMORY);
	}
	return (S_OK);
}


static HRESULT SEOGetSources(REFGUID rguidSourceType, IEventSources **ppSources) {
	HRESULT hrRes;
	CComPtr<IEventManager> pManager;
	CComPtr<IEventSourceTypes> pSourceTypes;
	CComPtr<IEventSourceType> pSourceType;
	CComPtr<IEventSources> pSources;

	if (ppSources) {
		*ppSources = NULL;
	}
	if (!ppSources) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = CoCreateInstance(CLSID_CEventManager,NULL,CLSCTX_ALL,IID_IEventManager,(LPVOID *) &pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pManager->get_SourceTypes(&pSourceTypes);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pSourceTypes->Item(&CComVariant((LPCOLESTR) CStringGUID(rguidSourceType)),&pSourceType);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSourceType) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSourceType->get_Sources(ppSources);
error:
	return (hrRes);
}


static HRESULT SEOGetSourcesEnum(REFGUID rguidSourceType, IEnumVARIANT **ppEnum) {
	HRESULT hrRes;
	CComPtr<IEventSources> pSources;
	CComPtr<IUnknown> pUnkEnum;

	if (ppEnum) {
		*ppEnum = NULL;
	}
	if (!ppEnum) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSources(rguidSourceType,&pSources);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSources) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSources->get__NewEnum(&pUnkEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pUnkEnum->QueryInterface(IID_IEnumVARIANT,(LPVOID *) ppEnum);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSource, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEventSources> pSources;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSources(rguidSourceType,&pSources);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSources) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = pSources->Item(&CComVariant((LPCOLESTR) CStringGUID(rguidSource)),ppSource);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,(REFGUID) CStringGUID(rguidSourceBase,dwSourceIndex),ppSource));
}


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEnumVARIANT> pEnum;
	CComVariant varValue;
	CComQIPtr<IEventSource,&IID_IEventSource> pSource;
	CComBSTR strDisplayName;
	CComBSTR strDesiredName;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource || !pszDisplayName) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSourcesEnum(rguidSourceType,&pEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pEnum) {
		hrRes = S_FALSE;
		goto error;
	}
	strDesiredName = pszDisplayName;
	while (1) {
		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		pSource = varValue.punkVal;
		if (!pSource) {
			hrRes = E_NOINTERFACE;
			goto error;
		}
		strDisplayName.Empty();
		hrRes = pSource->get_DisplayName(&strDisplayName);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (wcscmp(strDisplayName,strDesiredName) == 0) {
			*ppSource = pSource;
			(*ppSource)->AddRef();
			hrRes = S_OK;
			break;
		}
	}
error:
	return (hrRes);
}


class CValueBase {
	public:
		virtual BOOL Match(VARIANT *pValue) = 0;
};


static HRESULT SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, CValueBase *pValue, IEventSource **ppSource) {
	HRESULT hrRes;
	CComPtr<IEnumVARIANT> pEnum;
	CComVariant varValue;
	CComQIPtr<IEventSource,&IID_IEventSource> pSource;
	CComVariant varProperty;
	CComPtr<IEventPropertyBag> pProperties;

	if (ppSource) {
		*ppSource = NULL;
	}
	if (!ppSource || !pszProperty) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSourcesEnum(rguidSourceType,&pEnum);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pEnum) {
		hrRes = S_FALSE;
		goto error;
	}
	varProperty = pszProperty;
	while (1) {
		varValue.Clear();
		hrRes = pEnum->Next(1,&varValue,NULL);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			break;
		}
		hrRes = varValue.ChangeType(VT_UNKNOWN);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		pSource = varValue.punkVal;
		if (!pSource) {
			hrRes = E_NOINTERFACE;
			goto error;
		}
		pProperties.Release();
		hrRes = pSource->get_Properties(&pProperties);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		varValue.Clear();
		hrRes = pProperties->Item(&varProperty,&varValue);
		if (!SUCCEEDED(hrRes)) {
			goto error;
		}
		if (hrRes == S_FALSE) {
			continue;
		}
		if (pValue->Match(&varValue)) {
			*ppSource = pSource;
			(*ppSource)->AddRef();
			hrRes = S_OK;
			break;
		}
	}
error:
	return (hrRes);
}


class CValueDWORD : public CValueBase {
	public:
		CValueDWORD(DWORD dwValue) {
			m_dwValue = dwValue;
		};
		virtual BOOL Match(VARIANT *pValue) {
			HRESULT hrRes = VariantChangeType(pValue,pValue,0,VT_I4);
			if (!SUCCEEDED(hrRes)) {
				return (FALSE);
			}
			if ((DWORD) pValue->lVal != m_dwValue) {
				return (FALSE);
			}
			return (TRUE);
		};
	private:
		DWORD m_dwValue;
};


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,pszProperty,&CValueDWORD(dwValue),ppSource));
}


class CValueBSTR : public CValueBase {
	public:
		CValueBSTR(LPCWSTR pszValue) {
			m_strValue = SysAllocString(pszValue);
		};
		CValueBSTR(LPCSTR pszValue) {
			USES_CONVERSION;
			m_strValue = SysAllocString(A2W(pszValue));
		};
		~CValueBSTR() {
			SysFreeString(m_strValue);
		};
		virtual BOOL Match(VARIANT *pValue) {
			HRESULT hrRes = VariantChangeType(pValue,pValue,0,VT_BSTR);
			if (!SUCCEEDED(hrRes)) {
				return (FALSE);
			}
			if (wcscmp(pValue->bstrVal,m_strValue) != 0) {
				return (FALSE);
			}
			return (TRUE);
		};
	private:
		BSTR m_strValue;
};


STDMETHODIMP SEOGetSource(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventSource **ppSource) {

	return (SEOGetSource(rguidSourceType,pszProperty,&CValueBSTR(pszValue),ppSource));
}


static HRESULT SEOGetRouter(IEventSource *pSource, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventBindingManager> pManager;
	CComPtr<IEventRouter> pRouter;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!pSource || !ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = pSource->GetBindingManager(&pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = CoCreateInstance(CLSID_CEventRouter,NULL,CLSCTX_ALL,IID_IEventRouter,(LPVOID *) &pRouter);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	hrRes = pRouter->put_Database(pManager);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	*ppRouter = pRouter;
	(*ppRouter)->AddRef();
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSource, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,rguidSource,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, REFGUID rguidSourceBase, DWORD dwSourceIndex, IEventRouter **ppRouter) {

	return (SEOGetRouter(rguidSourceType,(REFGUID) CStringGUID(rguidSourceBase,dwSourceIndex),ppRouter));
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszDisplayName, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszDisplayName,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, DWORD dwValue, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszProperty,dwValue,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


STDMETHODIMP SEOGetRouter(REFGUID rguidSourceType, LPCSTR pszProperty, LPCSTR pszValue, IEventRouter **ppRouter) {
	HRESULT hrRes;
	CComPtr<IEventSource> pSource;

	if (ppRouter) {
		*ppRouter = NULL;
	}
	if (!ppRouter) {
		hrRes = E_POINTER;
		goto error;
	}
	hrRes = SEOGetSource(rguidSourceType,pszProperty,pszValue,&pSource);
	if (!SUCCEEDED(hrRes)) {
		goto error;
	}
	if (!pSource) {
		hrRes = S_FALSE;
		goto error;
	}
	hrRes = SEOGetRouter(pSource,ppRouter);
error:
	return (hrRes);
}


#include <initguid.h>

// This CLSID must match the one in SEO.DLL.
// {A4BE1350-1051-11d1-AA1E-00AA006BC80B}
DEFINE_GUID(CLSID_CEventServiceObject, 
0xa4be1350, 0x1051, 0x11d1, 0xaa, 0x1e, 0x0, 0xaa, 0x0, 0x6b, 0xc8, 0xb);


STDMETHODIMP SEOGetServiceHandle(IUnknown **ppUnkHandle) {

	return (CoCreateInstance(CLSID_CEventServiceObject,
							 NULL,
							 CLSCTX_ALL,
							 IID_IUnknown,
							 (LPVOID *) ppUnkHandle));
}


STDMETHODIMP SEOCreateObject(VARIANT *pvarClass,
							 IEventBinding *pBinding,
							 IUnknown *pInitProperties,
							 REFIID iidDesired,
							 IUnknown **ppUnkObject) {

	return (SEOCreateObjectEx(pvarClass,pBinding,pInitProperties,iidDesired,NULL,ppUnkObject));
}


STDMETHODIMP SEOCreateObjectEx(VARIANT *pvarClass,
							   IEventBinding *pBinding,
							   IUnknown *pInitProperties,
							   REFIID iidDesired,
							   IUnknown *pUnkCreateOptions,
							   IUnknown **ppUnkObject) {
	HRESULT hrRes;
	CStringGUID objGuid;
	BSTR strClass;
	CComQIPtr<IEventCreateOptions,&IID_IEventCreateOptions> pOpt;

	if (ppUnkObject) {
		*ppUnkObject = NULL;
	}
	if (!pvarClass || !ppUnkObject) {
		return (E_POINTER);
	}
	if (pUnkCreateOptions) {
		pOpt = pUnkCreateOptions;
	}
	if (pvarClass->vt == VT_BSTR) {
		strClass = pvarClass->bstrVal;
	} else if (pvarClass->vt == (VT_BYREF|VT_BSTR)) {
		strClass = *pvarClass->pbstrVal;
	} else {
		hrRes = VariantChangeType(pvarClass,pvarClass,0,VT_BSTR);
		if (!SUCCEEDED(hrRes)) {
			return (hrRes);
		}
		strClass = pvarClass->bstrVal;
	}
	objGuid.CalcFromProgID(strClass);
	if (!objGuid) {
		objGuid = strClass;
		if (!objGuid) {
			CComPtr<IBindCtx> pBindCtx;
			CComPtr<IMoniker> pMoniker;
			DWORD dwEaten;

			if (!pOpt || ((hrRes=pOpt->CreateBindCtx(0,&pBindCtx))==E_NOTIMPL)) {
				hrRes = CreateBindCtx(0,&pBindCtx);
			}
			_ASSERTE(SUCCEEDED(hrRes));
			if (SUCCEEDED(hrRes)) {
				if (!pOpt || ((hrRes=pOpt->MkParseDisplayName(pBindCtx,
															  strClass,
															  &dwEaten,
															  &pMoniker))==E_NOTIMPL)) {
					hrRes = MkParseDisplayName(pBindCtx,strClass,&dwEaten,&pMoniker);
				}
			}
			_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
			if (!SUCCEEDED(hrRes)) {
#if 0	// tbd - We try both the normal and the Ex versions of MkParseDisplayName.  Just use one.
				pBindCtx.Release();
				hrRes = CreateBindCtx(0,&pBindCtx);
				_ASSERTE(SUCCEEDED(hrRes));
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
				if (!pOpt||((hrRes=pOpt->MkParseDisplayNameEx(pBindCtx,
															  strClass,
															  &dwEaten,
															  &pMoniker))==E_NOTIMPL) {
					hrRes = MkParseDisplayNameEx(pBindCtx,strClass,&dwEaten,&pMoniker);
				}
				_ASSERTE(!SUCCEEDED(hrRes)||pMoniker);
				if (!SUCCEEDED(hrRes)) {
					return (hrRes);
				}
#else
				return (hrRes);
#endif
			}
			pBindCtx.Release();
			if (!pOpt || ((hrRes=pOpt->CreateBindCtx(0,&pBindCtx))==E_NOTIMPL)) {
				hrRes = CreateBindCtx(0,&pBindCtx);
			}
			if (!SUCCEEDED(hrRes)) {
				_ASSERTE(FALSE);
				return (hrRes);
			}
			if (!pOpt || ((hrRes=pOpt->BindToObject(pMoniker,
													pBindCtx,
													NULL,
													iidDesired,
													(LPVOID *) ppUnkObject))==E_NOTIMPL)) {
				hrRes = pMoniker->BindToObject(pBindCtx,NULL,iidDesired,(LPVOID *) ppUnkObject);
			}
			_ASSERTE(!SUCCEEDED(hrRes)||!*ppUnkObject);
			// Fall through
		}
	}
	// At this point, objGuid will only be TRUE if either CalcFromProgID or
	// operator =(LPCOLESTR) succeeded.  If both of these failed, then it will
	// be FALSE and we will have attempted to interpret the SinkClass as a
	// moniker.
	if (!!objGuid) {	// Use !! to hack-past ambiguous-conversion issues...
		if (!pOpt || ((hrRes=pOpt->CoCreateInstance(objGuid,
													NULL,
													CLSCTX_ALL,
													iidDesired,
													(LPVOID *) ppUnkObject))==E_NOTIMPL)) {
			hrRes = CoCreateInstance(objGuid,NULL,CLSCTX_ALL,iidDesired,(LPVOID *) ppUnkObject);
		}
		_ASSERTE(!SUCCEEDED(hrRes)||*ppUnkObject);
	}
	// At this point, hrRes has the result either from pMoniker->BindToObject or
	// CoCreateInstance.
	if (SUCCEEDED(hrRes)) {
		if (!pOpt || ((hrRes=pOpt->Init(iidDesired,ppUnkObject,pBinding,pInitProperties))==E_NOTIMPL)) {
			hrRes = S_OK;
			CComQIPtr<IEventPersistBinding,&IID_IEventPersistBinding> pBindingInit;

			if (pBinding) {
				pBindingInit = *ppUnkObject;
			}
			if (pBindingInit) {
				HRESULT hrResTmp;

				hrResTmp = pBindingInit->Load(pBinding);
				_ASSERTE(SUCCEEDED(hrResTmp));
			} else {
				CComQIPtr<IPersistPropertyBag,&IID_IPersistPropertyBag> pInit;

				if (pInitProperties) {
					pInit = *ppUnkObject;
				}
				if (pInit) {
					HRESULT hrResTmp;
					CComQIPtr<IPropertyBag,&IID_IPropertyBag> pProps;

					pProps = pInitProperties;
					_ASSERTE(pProps);
					if (pProps) {
						hrResTmp = pInit->InitNew();
						_ASSERTE(SUCCEEDED(hrResTmp));
						if (SUCCEEDED(hrResTmp)) {
							hrResTmp = pInit->Load(pProps,NULL);	// tbd - pass an IErrorLog object
							_ASSERTE(SUCCEEDED(hrResTmp));
						}
					}
				}
			}
		}
		if (!SUCCEEDED(hrRes)) {
			(*ppUnkObject)->Release();
			*ppUnkObject = NULL;
		}
	}
	return (hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\seodisp.cpp ===
//#define INCL_INETSRV_INCS
//#include "smtpinc.h"



#include <stdio.h>
#include <windows.h>
#include <mailmsg.h>
#include <dbgtrace.h>
#include <cpool.h>
#include <filehc.h>
#define _ATL_NO_DEBUG_CRT
#define _ATL_STATIC_REGISTRY 1
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL
#include <seo.h>
#include <seolib.h>
#include <smtpdisp_i.c>
#include <mailmsgi.h>
#include <smtpevent.h>
#include <seomgr.h>

#define MAX_RULE_LENGTH 4096
//
// Message object
//
#define MAILMSG_PROGID          L"Exchange.MailMsg"

#define INITGUID
#include "initguid.h"
#include "smtpguid.h"

#ifdef PLATINUM
#include "ptntguid.h"
#endif

#include "wildmat.h"
#include "smtpdisp.h"
#include "seodisp.h"

#include "evntwrap.h"
#include "address.hxx"
#include "mailmsgprops.h"

#include "cdosys_i.c"

// {0xCD000080,0x8B95,0x11D1,{0x82,0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D}}
DEFINE_GUID(IID_IConstructIMessageFromIMailMsg, 0xCD000080,0x8B95,0x11D1,0x82,
0xDB,0x00,0xC0,0x4F,0xB1,0x62,0x5D);
#ifdef PHATQ
// These are GUIDs which are normally defined in uuid.lib.  wrapmb.lib
// incorrectly defines many of those GUIDs, so we need to define these
// ones ourselves.  Yes, this is stupid.

// 00020400-0000-0000-C000-000000000046
DEFINE_GUID(IID_IDispatch, 0x00020400, 0x0000, 0x0000, 0xc0, 0x00, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x46);
// 00020404-0000-0000-C000-000000000046
DEFINE_GUID(IID_IEnumVARIANT, 0x00020404, 0x0000, 0x0000, 0xc0, 0x00, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x46);
// 0002E000-0000-0000-C000-000000000046
DEFINE_GUID(IID_IEnumGUID, 0x0002E000, 0x0000, 0x0000, 0xc0, 0x00, 
0x0, 0x0, 0x0, 0x0, 0x0, 0x46);
// 55272A00-42CB-11CE-8135-00AA004BB851
DEFINE_GUID(IID_IPropertyBag, 0x55272A00, 0x42CB, 0x11CE, 0x81, 0x35,
0x00, 0xaa, 0x00, 0x4b, 0xb8, 0x51);
// 1CF2B120-547D-101B-8E65-08002B2BD119
DEFINE_GUID(IID_IErrorInfo, 0x1CF2B120, 0x547D, 0x101B, 0x8E, 0x65, 
0x08, 0x00, 0x2B, 0x2B, 0xD1, 0x19);
// B196B284-BAB4-101A-B69C-00AA00341D07
DEFINE_GUID(IID_IConnectionPointContainer, 
0xB196B284, 0xBAB4, 0x101A, 0xB6, 0x9C, 0x00, 0xAA, 0x00, 0x34, 0x1D, 0x07);
// 37D84F60-42CB-11CE-8135-00AA004BB851
DEFINE_GUID(IID_IPersistPropertyBag, 0x37D84F60, 0x42CB, 0x11CE, 0x81, 0x35, 
0x00, 0xAA, 0x00, 0x4B, 0xB8, 0x51);

DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
#endif

extern VOID
ServerEventCompletion(
    PVOID        pvContext,
    DWORD        cbWritten,
    DWORD        dwCompletionStatus,
    OVERLAPPED * lpo
);

#define SKIPSINK_CALL_NO_MORE_SINKS 0xffffffff

class CStoreCreateOptions : public CEventCreateOptionsBase
{
  public:

    CStoreCreateOptions(    AQ_ALLOC_PARAMS * pContext)
    {
        _ASSERT (pContext != NULL);

        m_Context = pContext;
    }

  private:

    HRESULT STDMETHODCALLTYPE Init(REFIID iidDesired, IUnknown **ppUnkObject, IEventBinding *, IUnknown *)
    {
        ISMTPStoreDriver *pSink = NULL;
        IUnknown * ThisUnknown = NULL;
        IUnknown * NewUnknown = NULL;
        HRESULT hrRes = S_OK;

        TraceFunctEnterEx((LPARAM)this, "Calling create options");

        ThisUnknown = *ppUnkObject;

        hrRes = ThisUnknown->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
        if (hrRes == E_NOINTERFACE) {
            return (E_NOTIMPL);
        }
        if (FAILED(hrRes))
            return(hrRes);

        DebugTrace((LPARAM)this, "Calling startup events on sinks ...");
        hrRes = pSink->Init(m_Context->m_InstanceId,
                            NULL,
                            (IUnknown *) m_Context->m_EventSmtpServer,
                            m_Context->m_dwStartupType,
                            &NewUnknown);
        pSink->Release();
        if (FAILED(hrRes) && (hrRes != E_NOTIMPL)) {
            return (hrRes);
        }
        if(NewUnknown)
            {
                hrRes = NewUnknown->QueryInterface(iidDesired, (void **)ppUnkObject);
                NewUnknown->Release();
                if (!SUCCEEDED(hrRes)) {
                    return (hrRes);
                }
                ThisUnknown->Release();
            }


        return (E_NOTIMPL);
    };

  public:
    AQ_ALLOC_PARAMS *     m_Context;

};


CStoreDispatcher::CStoreAllocParams::CStoreAllocParams()
{
    m_hContent = NULL;
}

CStoreDispatcher::CStoreAllocParams::~CStoreAllocParams()
{
}

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CreateCParams
//
// Synopsis: Based on dwEventType, create the appropriate Params object
//
// Arguments:
//   dwEventType - specifies SMTP event
//   pContext - context to pass into Init function
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  or error from InitParamData
//
// History:
// jstamerj 980610 18:30:20: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CreateCParams(
    DWORD               dwEventType,
    LPVOID              pContext,
    IMailTransportNotify *pINotify,
    REFIID              rGuidEventType,
    CStoreBaseParams    **ppCParams)
{
    _ASSERT(ppCParams);
    HRESULT hr;

    switch(dwEventType) {
     case SMTP_STOREDRV_STARTUP_EVENT:
        if (!SUCCEEDED(GetData(NULL,NULL))) {
            hr = SetData(((AQ_ALLOC_PARAMS *) pContext)->m_EventSmtpServer,
                         ((AQ_ALLOC_PARAMS *) pContext)->m_InstanceId);
            _ASSERT(SUCCEEDED(hr));
        }
        // fall through
     case SMTP_MAIL_DROP_EVENT:
     case SMTP_STOREDRV_ENUMMESS_EVENT:
     case SMTP_STOREDRV_DELIVERY_EVENT:
     case SMTP_STOREDRV_ALLOC_EVENT:
     case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
     case SMTP_STOREDRV_SHUTDOWN_EVENT:
         *ppCParams = new CStoreParams();
         break;

     case SMTP_MAILTRANSPORT_SUBMISSION_EVENT:
         *ppCParams = new CMailTransportSubmissionParams();
         break;

     case SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT:
         *ppCParams = new CMailTransportPreCategorizeParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT:
         *ppCParams = new CMailTransportCatRegisterParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT:
         *ppCParams = new CMailTransportCatBeginParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT:
         *ppCParams = new CMailTransportCatEndParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT:
         *ppCParams = new CMailTransportCatBuildQueryParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT:
         *ppCParams = new CMailTransportCatBuildQueriesParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
         *ppCParams = new CMailTransportCatSendQueryParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT:
         *ppCParams = new CMailTransportCatSortQueryResultParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT:
         *ppCParams = new CMailTransportCatProcessItemParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
         *ppCParams = new CMailTransportCatExpandItemParams();
         break;

     case SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT:
         *ppCParams = new CMailTransportCatCompleteItemParams();
         break;

     case SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT:
         *ppCParams = new CMailTransportPostCategorizeParams();
         break;

     case SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT:
         *ppCParams = new CMailTransportRouterParams();
         break;

     case SMTP_MSGTRACKLOG_EVENT:
         *ppCParams = new CMsgTrackLogParams();
         break;

     case SMTP_DNSRESOLVERRECORDSINK_EVENT:
         *ppCParams = new CDnsResolverRecordParams();
         break;

     case SMTP_MAXMSGSIZE_EVENT:
         *ppCParams = new CSmtpMaxMsgSizeParams();
         break;

     case SMTP_GET_DSN_RECIPIENT_ITERATOR_EVENT:
         *ppCParams = new CDSNRecipientIteratorParams();
         break;

     case SMTP_GENERATE_DSN_EVENT:
         *ppCParams = new CDSNGenerateParams();
         break;

     case SMTP_POST_DSN_EVENT:
         *ppCParams = new CDSNPostGenerateParams();
         break;

     default:
         _ASSERT(0 && "Unknown server event");
         *ppCParams = NULL;
         break;
    }

    if(*ppCParams == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = (*ppCParams)->InitParamData(
        pContext,
        dwEventType,
        pINotify,
        rGuidEventType);

    if(FAILED(hr)) {
        (*ppCParams)->Release();
        *ppCParams = NULL;
        return hr;
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CStoreBaseParams
//
// Synopsis: Sets member data to pre-initialized values
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/23 13:58:01: Created.
//
//-------------------------------------------------------------
CStoreDispatcher::CStoreBaseParams::CStoreBaseParams() :
    m_rguidEventType(CATID_SMTP_STORE_DRIVER)
{
    m_dwSignature = SIGNATURE_VALID_CSTOREPARAMS;

    m_dwIdx_SinkSkip = 0;
    m_fDefaultProcessingCalled = FALSE;

    m_pINotify = NULL;
    m_pIUnknownSink = NULL;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::~CStoreBaseParams
//
// Synopsis: Release the IMailTransportNotify reference if held
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/23 13:58:51: Created.
//
//-------------------------------------------------------------
CStoreDispatcher::CStoreBaseParams::~CStoreBaseParams()
{
    if(m_pINotify)
        m_pINotify->Release();

    _ASSERT(m_dwSignature == SIGNATURE_VALID_CSTOREPARAMS);
    m_dwSignature = SIGNATURE_INVALID_CSTOREPARAMS;
}


//+------------------------------------------------------------
//
// Function: InitParamData
//
// Synopsis: Initializes object.  This includes calling Init() which
//           is implemented in dervied objects.
//
// Arguments:
//  pContext: Context passed in - specific for server event
//  dwEventType: Specifies which server event we are for
//  pINotify: IMailTransportNotify interface for async completion
//  rguidEventType: guid for event type binding
//
// Returns:
//  S_OK: Success
//  Error from Init()
//
// History:
// jstamerj 980615 19:16:55: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::InitParamData(
    PVOID pContext,
    DWORD dwEventType,
    IMailTransportNotify *pINotify,
    REFIID rguidEventType)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreBaseParams::InitParamData");
    HRESULT hr;

    m_dwEventType = dwEventType;
    m_dwIdx_SinkSkip = 0;
    m_fDefaultProcessingCalled = FALSE;
    m_pINotify = pINotify;
    m_pINotify->AddRef();
    m_rguidEventType = rguidEventType;


    hr = Init(pContext);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Init() failed, hr = %08lx", hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CallObject
//
// Synopsis: Called by the dispatcher when time to call a sink.  This
// implements some default functionality -- create the sink with a
// null CCreateOptions
//
// Arguments:
//   IEventManager
//   CBinding
//
// Returns:
//  S_OK: Success
//  or error from CreateSink/CallObject
//
// History:
// jstamerj 1998/06/23 13:53:57: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CallObject(
    IEventManager *pManager,
    CBinding& bBinding)
{
    HRESULT hrRes;
    CComPtr<IUnknown> pUnkSink;

    if (!pManager) {
        return (E_POINTER);
    }
    hrRes = pManager->CreateSink(bBinding.m_piBinding,NULL,&pUnkSink);
    if (!SUCCEEDED(hrRes)) {
        return (hrRes);
    }
    return (CallObject(bBinding,pUnkSink));
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule
//
// Synopsis: Determines if a mailmsg string rule passes or fails given
//           the mailmsg and the CBinding object
//
// Arguments:
//  pBinding: CBinding object for this sink
//  pMsgProps: IMailMsgProperteries of the message to check
//
// Returns:
//  S_OK: Success, call this sink
//  S_FALSE: Success, don't call this sink
//
// History:
// jstamerj 1999/01/11 17:04:01: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule(
    CBinding *pBinding,
    IMailMsgProperties *pIMsgProps)
{
    HRESULT hr;
    BOOL    fDomainLoaded = FALSE;
    BOOL    fSenderLoaded = FALSE;
    CHAR    szDomain[MAX_INTERNET_NAME + 2];
    CHAR    szSender[MAX_INTERNET_NAME + 2];
    LPSTR   szRule;
    CStoreBinding *pStoreBinding = (CStoreBinding *)pBinding;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreBaseParams::CheckMailMsgRule");

    _ASSERT(pStoreBinding);
    _ASSERT(pIMsgProps);

    // Get the cached rule from the binding
    szRule = pStoreBinding->GetRuleString();
    DebugTrace((LPARAM)this, "Rule string: %s", (szRule)?szRule:"NULL (No rule)");

    // If the rule is NULL, we will don't have a rule
    // string and we will return a match
    if (!szRule)
    {
        TraceFunctLeaveEx((LPARAM)this);
        return(S_OK);
    }

    // try each comma delimited rule in the header patterns list
    char *pszHeader = (char *) _alloca(lstrlen(szRule)+1);
    if (!pszHeader) {
        return (E_OUTOFMEMORY);
    }
    lstrcpy(pszHeader,szRule);
    while (pszHeader != NULL && *pszHeader != 0)
    {
        // find the next semicolon in the string and turn it into a 0
        // if it exists
        char *pszSemiColon = strchr(pszHeader, ';');
        if (pszSemiColon != NULL)
            *pszSemiColon = 0;

        // set pszContents to point to the text which must be matched
        // in the header.  if pszContents == NULL then just having
        // the header exist is good enough.
        char *pszPatterns = strchr(pszHeader, '=');
        if (pszPatterns != NULL)
        {
            *pszPatterns = 0;
            (pszPatterns++);
        }

        // we now have the header that we are looking for in
        // pszHeader and the list of patterns that we are interested
        // in pszPatterns.  Make the lookup into the header
        // data structure
        hr = S_FALSE;

        DebugTrace((LPARAM)this, "Processing Header <%s> with pattern <%s>",
                        pszHeader, pszPatterns);
        if (!lstrcmpi(pszHeader, "EHLO")) {

            // Process a client domain rule ...
            if (!fDomainLoaded) {
                hr = pIMsgProps->GetStringA(
                    IMMPID_MP_HELO_DOMAIN,
                    sizeof(szDomain),
                    szDomain);

                if (hr == S_OK) {

                    fDomainLoaded = TRUE;
                }
            }
            if (fDomainLoaded) {
                hr = MatchEmailOrDomainName(szDomain, pszPatterns, FALSE);
            }
        } else if (!lstrcmpi(pszHeader, "MAIL FROM")) {

            // Process a sender name rule ...
            if (!fSenderLoaded) {

                hr = pIMsgProps->GetStringA(
                    IMMPID_MP_SENDER_ADDRESS_SMTP,
                    sizeof(szSender),
                    szSender);

                if (hr == S_OK)
                {
                    fSenderLoaded = TRUE;
                }
            }
            if (fSenderLoaded) {
                hr = MatchEmailOrDomainName(szSender, pszPatterns, TRUE);
            }
        }
        else if (!lstrcmpi(pszHeader, "RCPT TO"))
        {
            hr = CheckMailMsgRecipientsRule(
                pIMsgProps,
                pszPatterns);
        }

        // We don't want to destroy the rule string so we restore all the
        // semicolons and equal signs
        if (pszSemiColon)
            *pszSemiColon = ';';
        if (pszPatterns)
            *(pszPatterns - 1) = '=';

        // Exit immediately if we found a match!
        if (hr == S_OK)
            goto Cleanup;

        // the next pattern is the one past the end of the semicolon
        pszHeader = (pszSemiColon == NULL) ? NULL : pszSemiColon + 1;
    }

Cleanup:
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return(hr);
}



//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule
//
// Synopsis: Determines if a mailmsg pattern string matches mailmsg
//           recipients or not
//
// Arguments:
//  pIMsg: An interface to a mailmsg object
//  pszPatterns: The sink rule to check
//
// Returns:
//  S_OK: Success, call this sink
//  S_FALSE: Success, don't call this sink
//  error from mailmsg
//
// History:
// jstamerj 1999/01/12 15:25:55: Copied from MCIS2 and modified for Platinum
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule(
    IUnknown *pIMsg,
    LPSTR pszPattern)
{
    HRESULT hr;
    DWORD dwNumRecips;
    IMailMsgRecipients *pIRecips = NULL;
    BOOL fMatch = FALSE;
    DWORD dwCount;
    CHAR szRecip [MAX_INTERNET_NAME + 2];

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CStoreBaseParams::CheckMailMsgRecipientsRule");

    hr = pIMsg->QueryInterface(
        IID_IMailMsgRecipients,
        (LPVOID *)&pIRecips);

    if(FAILED(hr))
        goto CLEANUP;

    hr = pIRecips->Count(&dwNumRecips);
    if(FAILED(hr))
        goto CLEANUP;

    DebugTrace((LPARAM)this, "Checking rule \"%s\" for %d recipients",
               pszPattern, pIMsg);

    for(dwCount = 0;
        (fMatch == FALSE) && (dwCount < dwNumRecips);
        dwCount++) {

        hr = pIRecips->GetStringA(
            dwCount,
            IMMPID_RP_ADDRESS_SMTP,
            sizeof(szRecip),
            szRecip);

        if(FAILED(hr) && (hr != MAILMSG_E_PROPNOTFOUND))
            goto CLEANUP;

        if(hr != MAILMSG_E_PROPNOTFOUND) {
            hr = MatchEmailOrDomainName(szRecip,pszPattern,TRUE);
            if(hr == S_OK)
                fMatch = TRUE;
            else if(FAILED(hr))
                goto CLEANUP;
        }
    }
    hr = (fMatch) ? S_OK : S_FALSE;

 CLEANUP:
    if(pIRecips)
        pIRecips->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreBaseparams::MatchEmailOrDomainName
//
// Synopsis: Given an email/domain name and a pattern, determine if
// the pattern matches or not
//
// Arguments:
//  szEmail: The email address or domain name
//  szPattern: The pattern to check
//  fIsEmail: TRUE if szEmail is an email address, FALSE if szEmail is
//  a domain
//
// Returns:
//  S_OK: Success, match
//  S_FALSE: Success, no match
//  E_INVALIDARG
//
// History:
// jstamerj 1999/01/12 15:25:36: Copied from MCIS2 and modified for Platinum
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreBaseParams::MatchEmailOrDomainName(
    LPSTR szEmail,
    LPSTR szPattern,
    BOOL fIsEmail)
{
    CAddr       *pEmailAddress = NULL;
    LPSTR       szEmailDomain = NULL;
    HRESULT     hrRes;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreBaseParams::MatchEmailOrDomainName");

    DebugTrace((LPARAM)NULL, "Matching <%s> against <%s>", szEmail, szPattern);

    if (!szEmail || !szPattern)
        return(E_INVALIDARG);

    // This validates that it is a good email name
    pEmailAddress = CAddr::CreateAddress(szEmail, fIsEmail?FROMADDR:CLEANDOMAIN);
    if (!pEmailAddress)
        return(E_INVALIDARG);

    szEmail = pEmailAddress->GetAddress();
    szEmailDomain = pEmailAddress->GetDomainOffset();

    hrRes = ::MatchEmailOrDomainName(szEmail, szEmailDomain, szPattern, fIsEmail);

    // Free the CAddr objects ...
    if (pEmailAddress)
        delete pEmailAddress;

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}



CStoreDispatcher::CStoreBinding::CStoreBinding()
{
    m_szRule = NULL;
}

CStoreDispatcher::CStoreBinding::~CStoreBinding()
{
    if(m_szRule)
        delete [] m_szRule;
}

//
// initialize a new binding.  we cache information from the binding database
// here
// jstamerj 1999/01/12 16:25:59: Copied MCIS2 code to get the rule string
//
HRESULT CStoreDispatcher::CStoreBinding::Init(IEventBinding *piBinding)
{
    HRESULT hr;
    CComPtr<IEventPropertyBag>  piEventProperties;
    CComVariant                 vRule;

    // get the parent initialized
    hr = CBinding::Init(piBinding);
    if (FAILED(hr))
        return hr;

    // get the binding database
    hr = m_piBinding->get_SourceProperties(&piEventProperties);
    if (FAILED(hr))
        return hr;

    // get the rule from the binding database
    hr = piEventProperties->Item(&CComVariant("Rule"), &vRule);
    if (FAILED(hr))
        return hr;

    // Process the rule string, the result code is not important
    // since it will NULL our the string
    if (hr == S_OK)
        hr = GetAnsiStringFromVariant(vRule, &m_szRule);

    return hr;
}

HRESULT CStoreDispatcher::CStoreBinding::GetAnsiStringFromVariant(
    CComVariant &vString, LPSTR *ppszString)
{
    HRESULT hr = S_OK;

    _ASSERT(ppszString);

    if (!ppszString)
        return(HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));

    // Default to NULL
    *ppszString = NULL;

    if (vString.vt == VT_BSTR)
        {
            DWORD dwLength = lstrlenW(vString.bstrVal) + 1;

            // Convert to an ANSI string and store it as a member
            *ppszString = new char[dwLength];
            if (!*ppszString)
                return HRESULT_FROM_WIN32(GetLastError());

            // copy the rule into an ascii string
            if (WideCharToMultiByte(CP_ACP, 0, vString.bstrVal,
                                    -1, (*ppszString), dwLength, NULL, NULL) <= 0)
                {
                    delete [] (*ppszString);
                    *ppszString = NULL;
                    return HRESULT_FROM_WIN32(GetLastError());
                }
        }
    else
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);

    return(hr);
}

#if 1
//
// create and call the child object
//
HRESULT CStoreDispatcher::CStoreParams::CallObject(IEventManager *pManager, CBinding& bBinding)
{
    CStoreCreateOptions opt (m_pContext);
    HRESULT hrRes;
    CComPtr<IUnknown> pUnkSink;

    if (!pManager) {
        return (E_POINTER);
    }
    hrRes = pManager->CreateSink(bBinding.m_piBinding,&opt,&pUnkSink);
    if (!SUCCEEDED(hrRes)) {
        return (hrRes);
    }
    return (CallObject(bBinding,pUnkSink));
}
#endif

//
// call the child object
//
HRESULT CStoreDispatcher::CStoreParams::CallObject(CBinding& bBinding, IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    HRESULT hrTmp = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CServerParams::CallObject");

    // We do this for different types of SMTP events
    switch (m_dwEventType)
        {
         case SMTP_STOREDRV_STARTUP_EVENT:
             break;
         case SMTP_STOREDRV_ALLOC_EVENT:
         {
             IMailMsgStoreDriver *pSink = NULL;
             IMailMsgProperties *   pMsg = (IMailMsgProperties *)m_pContext->IMsgPtr;
             IMailMsgBind         *pBindInterface = NULL;
             IMailMsgPropertyStream  *pStream = NULL;

             DebugTrace((LPARAM)this, "Calling bind on sinks ...");

             /*IID_ISMTPStoreDriver*/
             hrRes = punkObject->QueryInterface(IID_IMailMsgStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             // Allocate a new message
             hrRes = pSink->AllocMessage(pMsg, NULL, &pStream, &m_pContext->hContent, NULL);
             if(!FAILED(hrRes))
             {
                     pBindInterface = (IMailMsgBind *)m_pContext->BindInterfacePtr;

                     hrRes = pBindInterface->BindToStore(pStream,
                                                         pSink,
                                                         m_pContext->hContent);
                     if (pStream)
                     {
                         pStream->Release();
                         pStream = NULL;
                     }

                     if(FAILED(hrRes))
                     {
                            ErrorTrace((LPARAM)this, "pBindAtqInterface->BindToStore failed with %x", hrRes);

                            // Close the content handle
                            HRESULT myRes = pSink->CloseContentFile(
                                        pMsg,
                                        m_pContext->hContent);
                            if (FAILED(myRes))
                            {
                                FatalTrace((LPARAM)this, "Unable to close content file (%08x)", myRes);
                                _ASSERT(FALSE);
                            }

                            m_pContext->hContent = NULL;

                            hrTmp = pSink->Delete(pMsg, NULL);
                            _ASSERT(SUCCEEDED(hrTmp));

                     }
                     else
                     {
                            //Skip all sinks - temporary
                            hrRes = S_FALSE;
                     }

             }
             else
             {
                DebugTrace((LPARAM)this, "pSink->AllocMessage failed with %x", hrRes);
             }

             pSink->Release();
         }
         break;
         case SMTP_STOREDRV_DELIVERY_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling local delivery sink sink ...");
             hrRes = pSink->LocalDelivery(
                (IMailMsgProperties *) m_pContext->IMsgPtr, 
                m_pContext->m_RecipientCount, 
                m_pContext->pdwRecipIndexes, 
                (IMailMsgNotify *) m_pContext->m_pNotify);
             pSink->Release();

             //
             // jstamerj 1998/08/04 17:31:07:
             //   If the store driver sink returns this specific error
             //   code, we want to stop calling sinks and return from
             //   TriggerLocalDelivery
             //
             if(hrRes == STOREDRV_E_RETRY) {

                 DebugTrace((LPARAM)this, "Sink returned STOREDRV_E_RETRY on LocalDelivery");
                 m_pContext->hr = hrRes;
                 hrRes = S_FALSE;
             }

         }
         break;
         case SMTP_MAIL_DROP_EVENT:
             // ISMTPStoreDriver *pSink;

             // hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             // if (FAILED(hrRes))
             // return(hrRes);

             // DebugTrace((LPARAM)this, "Calling mail drop sink ...");
             // hrRes = pSink->DirectoryDrop((IMailMsgProperties *) m_pContext->IMsgPtr, m_pContext->m_RecipientCount, m_pContext->pdwRecipIndexes, m_pContext->m_DropDirectory, NULL);
             // pSink->Release();
             //}
             break;
         case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling prepare to shutdown on sinks ...");
             hrRes = pSink->PrepareForShutdown(0);
             pSink->Release();
             hrRes = S_OK;
         }
         break;
         case SMTP_STOREDRV_SHUTDOWN_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling shutdown on sinks ...");
             hrRes = pSink->Shutdown(0);
             pSink->Release();
             hrRes = S_OK;
         }
         break;

         case SMTP_STOREDRV_ENUMMESS_EVENT:
         {
             ISMTPStoreDriver *pSink;

             hrRes = punkObject->QueryInterface(IID_ISMTPStoreDriver, (void **)&pSink);
             if (FAILED(hrRes))
                 return(hrRes);

             DebugTrace((LPARAM)this, "Calling Enumerate on sinks ...");
             hrRes = pSink->EnumerateAndSubmitMessages(NULL);
             pSink->Release();
             hrRes = S_OK;
         }
         break;

         default:
             DebugTrace((LPARAM)this, "Invalid sink interface");
             hrRes = E_NOINTERFACE;
        }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CStoreParams::CallDefault
//
// Synopsis: CStoreDispatcher::Dispatcher will call this routine when
//           the default sink priority has been reached.
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980611 14:19:57: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CStoreParams::CallDefault()
{
    return S_OK;
}


//
// call the child object
//
HRESULT CStoreDispatcher::CStoreAllocParams::CallObject(CBinding& bBinding, IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

#if 0
    IMailMsgStoreDriver   *pStoreDriver = NULL;
    IMailMsgProperties    *pMsg         = NULL;
    IMailMsgPropertyStream  *pStream    = NULL;
    IMailMsgBindATQ       *pBindInterface = NULL;
    CLSID                 clsidMailMsg;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CStoreAllocParams::CallObject");

    hrRes = CLSIDFromProgID(MAILMSG_PROGID, &clsidMailMsg);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "CoCreateInstance IID_IMailMsgProperties failed, %X", hrRes);
            return(hrRes);
        }

    // Create a new MailMsg
    hrRes = CoCreateInstance(
        clsidMailMsg,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IMailMsgProperties,
        (LPVOID *)&pMsg);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "CoCreateInstance IID_IMailMsgProperties failed, %X", hrRes);
            return(hrRes);
        }

    hrRes = punkObject->QueryInterface(IID_IMailMsgStoreDriver, (void **)&pStoreDriver);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
            goto Exit;
        }

    // Allocate a new message
    hrRes = pStoreDriver->AllocMessage(
        pMsg,
        NULL,
        &pStream,
        &m_hContent,
        NULL);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "pDriver->AllocMessage failed, %X", hrRes);
            goto Exit;
        }

    hrRes = pMsg->QueryInterface(IID_IMailMsgBindATQ, (void **)&pBindInterface);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
            goto Exit;
        }

    hrRes = pBindInterface->SetATQInfo (NULL, NULL, NULL, INFINITE, NULL);
    if (FAILED(hrRes))
        {
            DebugTrace((LPARAM)this, "QueryInterface() on IID_IMailMsgStoreDriver failed, %X", hrRes);
goto Exit;
    }


Exit:

    if(pStoreDriver)
    {
        pStoreDriver->Release();
    }

    if(pMsg)
    {
        pMsg->Release();
    }

    if(pBindInterface)
    {
        pBindInterface->Release();
    }

    TraceFunctLeaveEx((LPARAM)this);
#endif

    return(hrRes);
}

#if 0
HRESULT STDMETHODCALLTYPE CStoreDispatcher::OnEvent(REFIID  iidEvent,
                                                    DWORD   dwEventType,
                                                    LPVOID  pvContext)
{
    HRESULT hr = S_OK;

    // create the params object, and pass it into the dispatcher
    CStoreParams ServerParams;
    ServerParams.Init(dwEventType, pvContext);
    hr = Dispatcher(iidEvent, &ServerParams);

    return hr;
}
#endif


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::OnEvent
//
// Synopsis: Prepares for server event
//
// Arguments:
//   iidEvent: guid for event
//   dwEventType: specifies the event
//   pvContext: context for the params object
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980616 13:27:55: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::OnEvent(
    REFIID  iidEvent,
    DWORD   dwEventType,
    LPVOID  pvContext)
{
    HRESULT hr;

    IMailTransportNotify *pINotify = NULL;
    //
    // Call into ATL internals to get the interface we need to pass out
    //
    hr = _InternalQueryInterface(
        IID_IMailTransportNotify,
        (LPVOID *)&pINotify);

    if(FAILED(hr))
        return hr;

    //
    // create the CParams object on the heap -- the object will be
    // needed after this call may be out of here (when a sink returns
    // MAILTRANSPORT_S_PENDING and there are more sinks to call)
    //
    CStoreBaseParams *pCParams;

    hr = CreateCParams(
        dwEventType,
        pvContext,
        pINotify,
        iidEvent,
        &pCParams);

    //
    // The params object should addref pINotify
    //
    pINotify->Release();

    if(FAILED(hr))
        return hr;

    //
    // Start calling sinks
    //
    hr = Dispatcher(iidEvent, pCParams);
    return hr;
}


//+------------------------------------------------------------
//
// Function: GuidForEvent
//
// Synopsis: Given dwEventType, return the appropriate GUID for the
//           event binding
//
// Arguments:
//   dwEventType: type of SMTP event
//
// Returns:
//   REFIID of GUID for the event
//
// History:
// jstamerj 980610 18:24:24: Created.
//
//-------------------------------------------------------------
REFIID GuidForEvent(DWORD dwEventType)
{
    switch(dwEventType) {
     case SMTP_MAIL_DROP_EVENT:
     case SMTP_STOREDRV_ENUMMESS_EVENT:
     case SMTP_STOREDRV_DELIVERY_EVENT:
     case SMTP_STOREDRV_ALLOC_EVENT:
     case SMTP_STOREDRV_STARTUP_EVENT:
     case SMTP_STOREDRV_PREPSHUTDOWN_EVENT:
     case SMTP_STOREDRV_SHUTDOWN_EVENT:
     default:
         return CATID_SMTP_STORE_DRIVER;

     case SMTP_MAILTRANSPORT_SUBMISSION_EVENT:
         return CATID_SMTP_TRANSPORT_SUBMISSION;

     case SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT:
         return CATID_SMTP_TRANSPORT_PRECATEGORIZE;

     case SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT:
     case SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT:
         return CATID_SMTP_TRANSPORT_CATEGORIZE;

     case SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT:
         return CATID_SMTP_TRANSPORT_POSTCATEGORIZE;

     case SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT:
         return CATID_SMTP_TRANSPORT_ROUTER;
     case SMTP_MSGTRACKLOG_EVENT:
         return CATID_SMTP_MSGTRACKLOG;
     case SMTP_DNSRESOLVERRECORDSINK_EVENT:
         return CATID_SMTP_DNSRESOLVERRECORDSINK;
     case SMTP_MAXMSGSIZE_EVENT:
         return CATID_SMTP_MAXMSGSIZE;

     case SMTP_GET_DSN_RECIPIENT_ITERATOR_EVENT:
     case SMTP_GENERATE_DSN_EVENT:
     case SMTP_POST_DSN_EVENT:
         return CATID_SMTP_DSN;

    }
}

//
// this function performs instance level server events registration
//
HRESULT RegisterPlatSEOInstance(DWORD dwInstanceID)
{
    HRESULT hr;

    //
    // find the SMTP source type in the event manager
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK)
        return hr;

    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(GUID_SMTP_SOURCE_TYPE);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    _ASSERT(hr != S_OK || pSourceType != NULL);
    if (hr != S_OK)
        return hr;

    //
    // generate a GUID for this source, which is based on GUID_SMTPSVC
    // mangled by the instance ID
    //
    CComPtr<IEventUtil> pEventUtil;
    hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
                          IID_IEventUtil, (LPVOID *) &pEventUtil);
    if (hr != S_OK)
        return hr;

    CComBSTR bstrSMTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_SMTPSVC_SOURCE);
    CComBSTR bstrSourceGUID;
    hr = pEventUtil->GetIndexedGUID(bstrSMTPSvcGUID, dwInstanceID, &bstrSourceGUID);
    if (FAILED(hr))
        return hr;

    //
    // see if this source is registered with the list of sources for the
    // SMTP source type
    //
    CComPtr<IEventSources> pEventSources;
    hr = pSourceType->get_Sources(&pEventSources);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSource> pEventSource;
    hr = pEventSources->Item(&CComVariant(bstrSourceGUID), &pEventSource);
    if (FAILED(hr))
        return hr;
    //
    // if the source guid doesn't exist then we need to register a new
    // source for the SMTP source type and add directory drop as a binding
    //
    if (hr == S_FALSE)
    {
        // register the SMTPSvc source
        hr = pEventSources->Add(bstrSourceGUID, &pEventSource);
        if (FAILED(hr))
            return hr;

        char szSourceDisplayName[50];
        _snprintf(szSourceDisplayName, 50, "smtpsvc %lu", dwInstanceID);
        CComBSTR bstrSourceDisplayName = szSourceDisplayName;
        hr = pEventSource->put_DisplayName(bstrSourceDisplayName);
        if (FAILED(hr))
            return hr;

        // create the event database for this source
        CComPtr<IEventDatabaseManager> pDatabaseManager;
        hr = CoCreateInstance(CLSID_CEventMetabaseDatabaseManager, NULL, CLSCTX_ALL,
                              IID_IEventDatabaseManager, (LPVOID *) &pDatabaseManager);
        if (hr != S_OK)
            return hr;

        CComBSTR bstrEventPath;
        CComBSTR bstrService = "smtpsvc";
        hr = pDatabaseManager->MakeVServerPath(bstrService, dwInstanceID, &bstrEventPath);
        if (FAILED(hr))
            return hr;

        CComPtr<IUnknown> pDatabaseMoniker;
        hr = pDatabaseManager->CreateDatabase(bstrEventPath, &pDatabaseMoniker);
        if (FAILED(hr))
            return hr;

        hr = pEventSource->put_BindingManagerMoniker(pDatabaseMoniker);
        if (FAILED(hr))
            return hr;

        // save everything we've done so far
        hr = pEventSource->Save();
        if (FAILED(hr))
            return hr;

        hr = pSourceType->Save();
        if (FAILED(hr))
            return hr;
    }

    return S_OK;
}

//
// this function performs instance level unregistration
//
HRESULT UnregisterPlatSEOInstance(DWORD dwInstanceID)
{
    HRESULT hr = S_OK;

    //
    // find the SMTP source type in the event manager
    //
    CComPtr<IEventManager> pEventManager;
    hr = CoCreateInstance(CLSID_CEventManager, NULL, CLSCTX_ALL,
                          IID_IEventManager, (LPVOID *) &pEventManager);
    if (hr != S_OK)
        return hr;

    CComPtr<IEventSourceTypes> pSourceTypes;
    hr = pEventManager->get_SourceTypes(&pSourceTypes);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSourceType> pSourceType;
    CComBSTR bstrSourceTypeGUID = (LPCOLESTR) CStringGUID(GUID_SMTP_SOURCE_TYPE);
    hr = pSourceTypes->Item(&CComVariant(bstrSourceTypeGUID), &pSourceType);
    _ASSERT(hr != S_OK || pSourceType != NULL);
    if (hr != S_OK)
        return hr;

    //
    // generate a GUID for this source, which is based on GUID_SMTPSVC
    // mangled by the instance ID
    //
    CComPtr<IEventUtil> pEventUtil;
    hr = CoCreateInstance(CLSID_CEventUtil, NULL, CLSCTX_ALL,
                          IID_IEventUtil, (LPVOID *) &pEventUtil);
    if (hr != S_OK)
        return hr;

    CComBSTR bstrSMTPSvcGUID = (LPCOLESTR) CStringGUID(GUID_SMTPSVC_SOURCE);
    CComBSTR bstrSourceGUID;
    hr = pEventUtil->GetIndexedGUID(bstrSMTPSvcGUID, dwInstanceID, &bstrSourceGUID);
    if (FAILED(hr))
        return hr;

    //
    // remove this source from the list of registered sources
    //
    CComPtr<IEventSources> pEventSources;
    hr = pSourceType->get_Sources(&pEventSources);
    if (FAILED(hr))
        return hr;

    CComPtr<IEventSource> pEventSource;
    hr = pEventSources->Remove(&CComVariant(bstrSourceGUID));
    if (FAILED(hr))
        return hr;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::Dispatcher
//
// Synopsis: Override the default functionality in seolib.cpp to
//           provide some extra features (default functionality
//
// Arguments:
//   rguidEventType: Guid specifying a server event
//   pParams: CStoreBaseParams -- contains async info
//
// Returns:
//  S_OK: Success, at least one sink called
//  S_FALSE: No sinks were called
//  otherwise error from CallObject
//
// History:
// jstamerj 980603 19:23:06: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::Dispatcher(
    REFIID rguidEventType,
    CStoreBaseParams *pParams)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::Dispatcher");
    _ASSERT(pParams);

    //
    // This code based on %STAXPT%\src\core\seo\lib\seolib.cpp
    //
    HRESULT hrRes = S_OK;
    CETData *petdData;
    BOOL bObjectCalled = (pParams->m_dwIdx_SinkSkip > 0);

    //
    // AddRef pParams here, release at the end of the function
    // This way, if a sink returns MAILTRANSPORT_S_PENDING and does
    // async completion before this function exits, we wont AV
    // accessing pParams
    //
    pParams->AddRef();

    petdData = m_Data.Find(rguidEventType);
    if(pParams->m_dwIdx_SinkSkip != SKIPSINK_CALL_NO_MORE_SINKS) {
        if(petdData) {
            for(DWORD dwIdx = pParams->m_dwIdx_SinkSkip;
                dwIdx < petdData->Count();
                dwIdx++) {
                if(!petdData->Index(dwIdx)->m_bIsValid) {
                    continue;
                }
                if(bObjectCalled && petdData->Index(dwIdx)->m_bExclusive) {
                    continue;
                }
                if(pParams->Abort() == S_OK) {
                    break;
                }
                //
                // Call default processing method if the priority of the sink
                // we're looking at is less than default priority
                //
                if((pParams->m_fDefaultProcessingCalled == FALSE) &&
                   (petdData->Index(dwIdx)->m_dwPriority >
                    SMTP_TRANSPORT_DEFAULT_PRIORITY)) {

                    // This is needed so we don't call the default
                    // processing again if the default processing returns
                    // MAILTRANSPORT_S_PENDING (and we reenter Dispatcher)
                    pParams->m_fDefaultProcessingCalled = TRUE;

                    //
                    // Set the correct index in our async structure -- our
                    // current index.
                    //
                    pParams->m_dwIdx_SinkSkip = dwIdx;
                    hrRes = pParams->CallDefault();

                    if((hrRes == MAILTRANSPORT_S_PENDING) ||
                       (hrRes == S_FALSE)) {
                        break;
                    }
                }

                //
                // Now proceed with calling a real sink
                //
                hrRes = pParams->CheckRule(*petdData->Index(dwIdx));
                if(hrRes == S_OK) {
                    if(pParams->Abort() == S_OK) {
                        break;
                    }
                    //
                    // jstamerj 980603 19:37:17: Set the correct index in our
                    // async structure -- this index plus one to skip the
                    // sink we are about to call
                    //
                    pParams->m_dwIdx_SinkSkip = dwIdx+1;
                    hrRes = pParams->CallObject(
                        m_piEventManager,
                        *petdData->Index(dwIdx));

                    if(!SUCCEEDED(hrRes)) {
                        continue;
                    }
                    bObjectCalled = TRUE;
                    if((hrRes == MAILTRANSPORT_S_PENDING) ||
                       (hrRes == S_FALSE) ||
                       (petdData->Index(dwIdx)->m_bExclusive)) {
                        break;
                    }
                }
            }
        }
        //
        // It is possible we haven't called our default processing sink
        // yet.  Check for this case here.  Make sure that a sink above in
        // the loop isn't indicating async completion or skip (PENDING or
        // S_FALSE)
        //
        if((pParams->m_fDefaultProcessingCalled == FALSE) &&
           (hrRes != MAILTRANSPORT_S_PENDING) &&
           (hrRes != S_FALSE)) {

            // Make sure we don't call default again on async completion...
            pParams->m_fDefaultProcessingCalled = TRUE;

            //
            // Set the index in our async structure so we don't reenter
            // the above loop on async completion
            //
            pParams->m_dwIdx_SinkSkip = (petdData ? petdData->Count() : 0);

            hrRes = pParams->CallDefault();
        }
    } else {
        // bObjectCalled should always be set if SKIPSINK_CALL_NO_MORE_SINKS
        // was set
        _ASSERT(bObjectCalled);
    }

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // It is time to call the completion processing
        //
        hrRes = pParams->CallCompletion(bObjectCalled ? S_OK : S_FALSE);
        if(FAILED(hrRes)) {
            goto CLEANUP;
        }
        hrRes = (bObjectCalled) ? S_OK : S_FALSE;
    }

 CLEANUP:
    pParams->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hrRes);
    TraceFunctLeaveEx((LPARAM)this);
    return hrRes;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::Notify
//
// Synopsis: Handles async completions of sinks
//
// Arguments: pvContext - context passed into sink
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG:
//
// History:
// jstamerj 980608 15:50:57: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::Notify(
    HRESULT hrStatus,
    PVOID pvContext)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::Notify");

    _ASSERT(pvContext);
    if((pvContext == NULL) ||
       IsBadReadPtr(
           pvContext,
           sizeof(CStoreBaseParams))) {
        ErrorTrace((LPARAM)this, "Sink called Notify with bogus pvContext");
        return E_INVALIDARG;
    }

    CStoreBaseParams *pParams = (CStoreBaseParams *)pvContext;

    if(FAILED(pParams->CheckSignature())) {
        ErrorTrace((LPARAM)this, "Sink called Notify with invalid pvContext");
        return E_INVALIDARG;
    }
    //
    // Release the sink that called us
    // m_pIUnknownSink could be NULL if default processing returned pending
    //
    if(pParams->m_pIUnknownSink) {
        pParams->m_pIUnknownSink->Release();
        pParams->m_pIUnknownSink = NULL;
    }

    if (hrStatus == S_FALSE) {
        // prevent the dispatcher from calling any more sinks.
        pParams->m_dwIdx_SinkSkip = SKIPSINK_CALL_NO_MORE_SINKS;
    }
    Dispatcher(pParams->m_rguidEventType, pParams);

    TraceFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//
// CMailTransportSubmissionParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportSubmissionParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_SUBMISSION_EVENT);

    IMailTransportSubmission *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportSubmission,
                                       (PVOID *)&pSink);

    if(hrRes == E_NOINTERFACE) {
        //
        // See if we can get the interfaces we need for a CDO sink
        //
        hrRes = CallCDOSink(punkObject);
        //
        // Success or failure, return here
        //
        TraceFunctLeaveEx((LPARAM)this);
        return hrRes;
    } else if(FAILED(hrRes)) {
        TraceFunctLeaveEx((LPARAM)this);
        return(hrRes);
    }

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->OnMessageSubmission(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink
//
// Synopsis: Call the CDO Sink
//
// Arguments:
//  pSink: IUnknown of the sink
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/02 10:31:47: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink(
    IUnknown *pSink)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportSubmissionParams::CallCDOSink");
    _ASSERT(pSink);

    HRESULT hr;
    ISMTPOnArrival *pCDOSink = NULL;
    IConstructIMessageFromIMailMsg *pIConstruct = NULL;
    CdoEventStatus eStatus = cdoRunNextSink;

    hr = pSink->QueryInterface(IID_ISMTPOnArrival,
                               (PVOID *)&pCDOSink);
    if(FAILED(hr))
        goto CLEANUP;

    if(m_pCDOMessage == NULL) {
        //
        // Yay.  Create a CDO message
        //
        hr = CoCreateInstance(
            CLSID_Message,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMessage,
            (LPVOID *)&m_pCDOMessage);
        if(FAILED(hr))
            goto CLEANUP;

        //
        // Fill in properties based on MailMsg
        //
        hr = m_pCDOMessage->QueryInterface(
            IID_IConstructIMessageFromIMailMsg,
            (LPVOID *)&pIConstruct);
        if(FAILED(hr)) {
            m_pCDOMessage->Release();
            m_pCDOMessage = NULL;
            goto CLEANUP;
        }

        hr = pIConstruct->Construct(
            cdoSMTPOnArrival,
            m_Context.pIMailMsgProperties);
        if(FAILED(hr)) {
            m_pCDOMessage->Release();
            m_pCDOMessage = NULL;
            goto CLEANUP;
        }
    }

    //
    // Call the sink
    //
    hr = pCDOSink->OnArrival(
        m_pCDOMessage,
        &eStatus);

 CLEANUP:
    //
    // Release interfaces
    //
    if(pIConstruct)
        pIConstruct->Release();
    if(pCDOSink)
        pCDOSink->Release();

    DebugTrace((LPARAM)this, "CallCDOSink returning hr %08lx eStatus %d", hr, eStatus);

    TraceFunctLeaveEx((LPARAM)this);
    return FAILED(hr) ? hr :
        ((eStatus == cdoSkipRemainingSinks) ? S_FALSE : S_OK);
}



//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportSubmissionParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_SUBMISSION_EVENT);

    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportSubmissionParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 16:55:29: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportSubmissionParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportSubmissionParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//
// CMailTransportPreCategorizeParams:
//


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportPreCategorizeParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT);

    IMailTransportOnPreCategorize *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportOnPreCategorize,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling precategorize event on this sink");

    hrRes = pSink->OnSyncMessagePreCategorize(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportPreCategorizeParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_PRECATEGORIZE_EVENT);
    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 16:59:59: Created
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportPreCategorizeParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//
// CMailTransportPostCategorizeParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportPostCategorizeParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT);

    IMailTransportOnPostCategorize *pSink;

    hrRes = punkObject->QueryInterface(IID_IMailTransportOnPostCategorize,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    //
    // Remember the sink so we can release this sink later if it
    // returns pending
    //
    _ASSERT(m_pIUnknownSink == NULL);
    m_pIUnknownSink = (IUnknown*)pSink;
    m_pIUnknownSink->AddRef();

    DebugTrace((LPARAM)this, "Calling submission event on this sink");

    hrRes = pSink->OnMessagePostCategorize(
        m_Context.pIMailMsgProperties,
        m_pINotify,
        (PVOID)this);

    //
    // We are done with pSink so release it
    // In case of async completion, we hold a reference to the sink in
    // m_pIUnknownSink
    //
    pSink->Release();

    if(hrRes != MAILTRANSPORT_S_PENDING) {
        //
        // We completed synchronously, so release the sink
        //
        m_pIUnknownSink->Release();
        m_pIUnknownSink = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//  MAILTRANSPORT_S_PENDING: Will call IMailTransportNotify::Notify
//                           when we are done.
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallDefault()
{
    //
    // No sinks need default processing yet..
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDriver::CMailTransportPostCategorizeParams::CallCompletion
//
// Synopsis: The dispatcher will call this routine after all sinks
//           have been called
//
// Arguments:
//   hrStatus: Status server event sinks have returned
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980611 14:17:51: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CallCompletion(
    HRESULT hrStatus)
{
    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_POSTCATEGORIZE_EVENT);
    (*m_Context.pfnCompletion)(hrStatus, &m_Context);

    CStoreBaseParams::CallCompletion(hrStatus);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule
//
// Synopsis: Check to see if this sink should be called or not
//
// Arguments:
//  bBinding: CBinding object for this sink
//
// Returns:
//  S_OK: Success, call the sink
//  S_FALSE: Success, do not call the sink
//  or error from mailmsg (sink will not be called)
//
// History:
// jstamerj 1999/01/12 17:01:40: Created
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule(
    CBinding &bBinding)
{
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this,
                      "CStoreDispatcher::CMailTransportPostCategorizeParams::CheckRule");

    //
    // Call the generic function to check a mailmsg rule
    //
    hr = CheckMailMsgRule(
        &bBinding,
        m_Context.pIMailMsgProperties);

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CRouterCreateOptions::Init
//
// Synopsis: This is called right after we CoCreate any routing sink
// -- so call routing's initialize function (RegisterRouterReset)
//
// Arguments:
//  iidDesired: not used
//  ppUnkObject: IUnknown of newly created sink object
//  IEventBinding: not used
//  IUnknown: not used
//
// Returns:
//  E_NOTIMPL: Success, please do the regular Init thing
//  otherwise error from QI or sink function
//
// History:
// jstamerj 1998/07/10 18:09:04: Created.
//
//-------------------------------------------------------------
HRESULT STDMETHODCALLTYPE CStoreDispatcher::CRouterCreateOptions::Init(
    REFIID iidDesired,
    IUnknown **ppUnkObject,
    IEventBinding *,
    IUnknown *)
{
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CRouterCreateOptions::Init");

    IMailTransportSetRouterReset *pSink = NULL;
    HRESULT hr;

    hr = (*ppUnkObject)->QueryInterface(
        IID_IMailTransportSetRouterReset,
        (PVOID *)&pSink);
    if(hr == E_NOINTERFACE) {
        //
        // It's okay; this sink just doesn't care about hooking
        // the router reset interface
        //
        DebugTrace((LPARAM)this, "Router sink doesn't support IMailTransportSetRouterReset");
        TraceFunctLeaveEx((LPARAM)this);
        return E_NOTIMPL;

    } else if(FAILED(hr)) {
        ErrorTrace((LPARAM)this,
                   "QI for IMailTransportSetRouterReset failed with hr %08lx", hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }

    DebugTrace((LPARAM)this, "Calling RegisterRouterReset event onSink");
    hr = pSink->RegisterResetInterface(
        m_pContext->dwVirtualServerID,
        m_pContext->pIRouterReset);

    pSink->Release();

    if(FAILED(hr) && (hr != E_NOTIMPL)) {
        //
        // A real failure occured
        //
        ErrorTrace((LPARAM)this, "RegisterResetInterface failed with hr %08lx", hr);
        return hr;
    }
    //
    // Return E_NOTIMPL so the real work of Init will be done
    //
    return E_NOTIMPL;
}

//
// CMailTransportRoutingParams:
//

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRouterParams::CallObject
//
// Synopsis: Creates (if necessary) and calls the sink object
//
// Arguments:
//  pManager: IEventManager passed in from dispatcher
//  bBinding: CBinding for this event
//
// Returns:
//  S_OK: Success
//  E_POINTER: bad pManager
//  or error from CreateSink/CallObject
//
// History:
// jstamerj 1998/07/10 18:15:09: Created.
//
//-------------------------------------------------------------
//
// create and call the child object
//
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallObject(
    IEventManager *pManager,
    CBinding& bBinding)
{
    CRouterCreateOptions opt (m_pContext);
    CComPtr<IUnknown> pUnkSink;
    HRESULT hr;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRotuerParams::CallObject");

    if (pManager == NULL) {
        ErrorTrace((LPARAM)this, "Invalid (NULL) pManager");
        TraceFunctLeaveEx((LPARAM)this);
        return (E_POINTER);
    }

    hr = pManager->CreateSink(bBinding.m_piBinding,&opt,&pUnkSink);
    if (FAILED(hr)) {
        ErrorTrace((LPARAM)this, "CreateSink returned error hr %08lx",
                   hr);
        TraceFunctLeaveEx((LPARAM)this);
        return hr;
    }
    hr = CallObject(bBinding,pUnkSink);
    DebugTrace((LPARAM)this, "CallObject child returned error %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRoutingParams::CallObject
//
// Synopsis: Create and call the child object
//
// Arguments:
//   CBinding
//   punkObject
//
// Returns:
//  Error from QI or return code from sink function
//
// History:
// jstamerj 980610 19:04:59: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject)
{
    HRESULT hrRes = S_OK;
    IMailTransportRoutingEngine *pSink;
    IMessageRouter *pIMessageRouterNew = NULL;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRouterParams::CallObject");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT);

    //
    // If they pass in a pIMailMsgProperties of NULL it means that they
    // just want to create a router object, but not actually do the
    // get message router call.
    //
    if (m_pContext->pIMailMsgProperties == NULL) {
        DebugTrace((LPARAM) this, "Skipping GetMessageRouter call");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;
    }

    hrRes = punkObject->QueryInterface(IID_IMailTransportRoutingEngine,
                                       (PVOID *)&pSink);
    if(FAILED(hrRes))
        return(hrRes);

    DebugTrace((LPARAM)this, "Calling GetMessageRouter event on this sink");

    hrRes = pSink->GetMessageRouter(
        m_pContext->pIMailMsgProperties,
        m_pContext->pIMessageRouter,
        &(pIMessageRouterNew));

    //
    // This sink is not allowed to complete async
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    //
    // We are done with pSink so release it
    //
    pSink->Release();

    //
    // If GetMessageRouter succeeded AND it returned a new
    // IMessageRouter, release the old one and save the new one.
    //
    if(SUCCEEDED(hrRes) && (pIMessageRouterNew != NULL)) {

        if(m_pContext->pIMessageRouter) {
            m_pContext->pIMessageRouter->Release();
        }
        m_pContext->pIMessageRouter = pIMessageRouterNew;
    }

    DebugTrace((LPARAM)this, "Sink GetMessageRouter returned hr %08lx", hrRes);

    TraceFunctLeaveEx((LPARAM)this);
    return(hrRes);
}


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CMailTransportRouterParams
//
// Synopsis: The dispatcher will call this routine when it the default
//           sink processing priority is reached
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continueing calling sinks
//  S_FALSE: Stop calling sinks
//
// History:
// jstamerj 980611 14:15:43: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CMailTransportRouterParams::CallDefault()
{
    HRESULT hrRes;
    IMessageRouter *pIMessageRouterNew = NULL;

    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CMailTransportRouterParams::CallDefault");

    _ASSERT(m_dwEventType == SMTP_MAILTRANSPORT_GET_ROUTER_FOR_MESSAGE_EVENT);

    if (m_pContext->pIMailMsgProperties == NULL) {
        DebugTrace((LPARAM) this, "Skipping GetMessageRouter call");
        TraceFunctLeaveEx((LPARAM)this);
        return S_OK;
    }

    //
    // Call the default IMailTransportRoutingEngine (CatMsgQueue)
    // just like any other sink except SEO didn't CoCreate it for us
    //

    DebugTrace((LPARAM)this, "Calling GetMessageRouter event on default sink");

    hrRes = m_pContext->pIRoutingEngineDefault->GetMessageRouter(
        m_pContext->pIMailMsgProperties,
        m_pContext->pIMessageRouter,
        &pIMessageRouterNew);

    //
    // This sink is not allowed to complete async
    //
    _ASSERT(hrRes != MAILTRANSPORT_S_PENDING);

    //
    // If GetMessageRouter succeeded AND it returned a new
    // IMessageRouter, release the old one.
    //
    if(SUCCEEDED(hrRes) && (pIMessageRouterNew != NULL)) {

        if(m_pContext->pIMessageRouter) {
            m_pContext->pIMessageRouter->Release();
        }
        m_pContext->pIMessageRouter = pIMessageRouterNew;
    }

    TraceFunctLeaveEx((LPARAM)this);

    DebugTrace((LPARAM)this, "Default processing returned hr %08lx", hrRes);
    TraceFunctLeaveEx((LPARAM)this);
    return hrRes;
}


//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CMsgTrackLogParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    IMsgTrackLog *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_IMsgTrackLog, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncLogMsgTrackInfo(
                    m_pContext->pIServer,
                    m_pContext->pIMailMsgProperties,
                    m_pContext->pMsgTrackInfo );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CMsgTrackLogParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

HRESULT CStoreDispatcher::CDnsResolverRecordParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    IDnsResolverRecordSink *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_IDnsResolverRecordSink, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncGetResolverRecord( m_pContext->pszHostName,
                                         m_pContext->pszFQDN,
                                         m_pContext->dwVirtualServerId,
                                         m_pContext->ppIDnsResolverRecord );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CDnsResolverRecordParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

HRESULT CStoreDispatcher::CSmtpMaxMsgSizeParams::CallObject(
    CBinding& bBinding,
    IUnknown *punkObject )
{
    ISmtpMaxMsgSize *pSink = NULL;

    HRESULT hr = punkObject->QueryInterface(IID_ISmtpMaxMsgSize, (void **)&pSink);

    if( FAILED( hr ) )
    {
        return( hr );
    }

    hr = pSink->OnSyncMaxMsgSize( m_pContext->pIUnknown, m_pContext->pIMailMsg, m_pContext->pfShouldImposeLimit );

    pSink->Release();

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CStoreDispatcher::CSmtpMaxMsgSizeParams::CallDefault()
{
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CDSNCreateOptions::Init
//
// Synopsis:
//
// Arguments:
//  iidDesired: not used
//  ppUnkObject: IUnknown of newly created sink object
//  IEventBinding: not used
//  IUnknown: not used
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/12/12 15:38:40: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CDSNCreateOptions::Init(
    REFIID iidDesired,
    IUnknown **ppUnkObject,
    IEventBinding *,
    IUnknown *)
{
    HRESULT hr = S_OK;
    IDSNGenerationSink *pSink = NULL;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CDSNCreateOptions::Init");

    hr = (*ppUnkObject)->QueryInterface(
        IID_IDSNGenerationSink,
        (PVOID *)&pSink);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this,
                   "QI for IDSNGenerationSink failed with hr %08lx", hr);
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Calling Init");
    hr = pSink->OnSyncSinkInit(
        m_dwVSID);

    if(FAILED(hr) && (hr != E_NOTIMPL)) {
        //
        // A real failure occured
        //
        ErrorTrace((LPARAM)this, "Init failed with hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    if(pSink)
        pSink->Release();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    //
    // Return E_NOTIMPL so the real work of Init will be done
    //
    return SUCCEEDED(hr) ? E_NOTIMPL : hr;
} // CStoreDispatcher::CDSNCreateOptions::Init



//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CDSNBaseParams::CallObject
//
// Synopsis: Create/call the event sink
//
// Arguments:
//  pManager: SEO's IEventManager
//  bBinding: event binding
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/12/12 15:35:35: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CDSNBaseParams::CallObject(
    IEventManager *pManager, 
    CBinding& bBinding)
{
    HRESULT hr = S_OK;
    CDSNCreateOptions opt(GetVSID());
    CComPtr<IUnknown> pUnkSink;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CDSNBaseParams::CallObject");
    if (pManager == NULL) {
        ErrorTrace((LPARAM)this, "Invalid (NULL) pManager");
        hr = E_POINTER;
        goto CLEANUP;
    }

    hr = pManager->CreateSink(bBinding.m_piBinding,&opt,&pUnkSink);
    if (FAILED(hr)) {
        ErrorTrace((LPARAM)this, "CreateSink returned error hr %08lx",
                   hr);
        goto CLEANUP;
    }
    hr = CallObject(bBinding,pUnkSink);
    DebugTrace((LPARAM)this, "CallObject child returned error %08lx", hr);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreDispatcher::CDSNBaseParams::CallObject



//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CDSNRecipientIteratorParams::CallObject
//
// Synopsis: Call the OnSyncGetDSNRecipientIterator method of a sink
//
// Arguments:
//  bBinding: event binding
//  punkObject: IUnknown of the sink
//
// Returns:
//  Return value from sink
//
// History:
// jstamerj 2000/12/11 15:14:41: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CDSNRecipientIteratorParams::CallObject(
    CBinding& bBinding, 
    IUnknown *punkObject)
{
    HRESULT hr = S_OK;
    IDSNGenerationSink *pSink = NULL;
    IDSNRecipientIterator *pIRecipIter = NULL;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CDSNRecipientIteratorParams::CallObject");

    hr = punkObject->QueryInterface(
        IID_IDSNGenerationSink,
        (LPVOID *)&pSink);
    if(FAILED(hr))
    {
        pSink = NULL;
        ErrorTrace((LPARAM)this, "QI for IDSNGenerationSink failed hr %08lx", hr);
        goto CLEANUP;
    }

    hr = pSink->OnSyncGetDSNRecipientIterator(
        m_pContext->pISMTPServer,
        m_pContext->pIMsg,
        m_pContext->pDSNProperties,
        m_pContext->dwStartDomain,
        m_pContext->dwDSNActions,
        m_pContext->pRecipIter,
        &pIRecipIter);
    _ASSERT(hr != MAILTRANSPORT_S_PENDING);
    DebugTrace((LPARAM)this, "sink returned hr %08lx", hr);
    
    if(SUCCEEDED(hr) && (pIRecipIter != NULL))
    {
        //
        // Capture the new interface
        //
        if(m_pContext->pRecipIter)
            m_pContext->pRecipIter->Release();
        //
        // Transfer refcount
        //
        m_pContext->pRecipIter = pIRecipIter;
        pIRecipIter = NULL;
    }

 CLEANUP:
    if(pSink)
        pSink->Release();
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreDispatcher::CDSNRecipientIteratorParams::CallObject


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CDSNGenerateParams::CallObject
//
// Synopsis: Call the OnSyncGenerateDSN method of a sink
//
// Arguments:
//  bBinding: event binding
//  punkObject: IUnknown of the sink
//
// Returns:
//  Return value from sink
//
// History:
// jstamerj 2000/12/11 15:15:04: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CDSNGenerateParams::CallObject(
    CBinding& bBinding, 
    IUnknown *punkObject)
{
    HRESULT hr = S_OK;
    IDSNGenerationSink *pSink = NULL;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CDSNGenerateParams::CallObject");
    hr = punkObject->QueryInterface(
        IID_IDSNGenerationSink,
        (LPVOID *)&pSink);
    if(FAILED(hr))
    {
        pSink = NULL;
        ErrorTrace((LPARAM)this, "QI for IDSNGenerationSink failed hr %08lx", hr);
        goto CLEANUP;
    }

    hr = pSink->OnSyncGenerateDSN(
        m_pContext->pISMTPServer,
        m_pContext->pIDSNSubmission,
        m_pContext->pIMsg,
        m_pContext->pDSNProperties,
        m_pContext->pRecipIter);
    _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    DebugTrace((LPARAM)this, "sink returned hr %08lx", hr);
    
 CLEANUP:
    if(pSink)
        pSink->Release();
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreDispatcher::CDSNGenerateParams::CallObject


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CDSNGenerateparams::CallDefault
//
// Synopsis: Call the OnSyncGenerateDSN method on the default sink
//
// Arguments: None
//
// Returns:
//  Return value from default sink
//
// History:
// jstamerj 2000/12/11 15:15:21: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CDSNGenerateParams::CallDefault()
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CDSNGenerateparams::CallDefault");

    if(m_pContext->pDefaultSink)
    {
        hr = m_pContext->pDefaultSink->OnSyncGenerateDSN(
            m_pContext->pISMTPServer,
            m_pContext->pIDSNSubmission,
            m_pContext->pIMsg,
            m_pContext->pDSNProperties,
            m_pContext->pRecipIter);
        _ASSERT(hr != MAILTRANSPORT_S_PENDING);
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreDispatcher::CDSNGenerateparams::CallDefault


//+------------------------------------------------------------
//
// Function: CStoreDispatcher::CDSNPostGenerateParams::CallObject
//
// Synopsis: Calls the OnSyncPostGenerateDSN method of a sink
//
// Arguments:
//  bBinding: event binding
//  punkObject: IUnknown of the sink
//
// Returns:
//  Return value from sink
//
// History:
// jstamerj 2000/12/11 15:15:40: Created.
//
//-------------------------------------------------------------
HRESULT CStoreDispatcher::CDSNPostGenerateParams::CallObject(
    CBinding& bBinding, 
    IUnknown *punkObject)
{
    HRESULT hr = S_OK;
    IDSNGenerationSink *pSink = NULL;
    TraceFunctEnterEx((LPARAM)this, "CStoreDispatcher::CDSNPostGenerateParams::CallObject");

    hr = punkObject->QueryInterface(
        IID_IDSNGenerationSink,
        (LPVOID *)&pSink);
    if(FAILED(hr))
    {
        pSink = NULL;
        ErrorTrace((LPARAM)this, "QI for IDSNGenerationSink failed hr %08lx", hr);
        goto CLEANUP;
    }

    hr = pSink->OnSyncPostGenerateDSN(
        m_pContext->pISMTPServer,
        m_pContext->pIMsgOrig,
        m_pContext->dwDSNAction,
        m_pContext->cRecipsDSNd,
        m_pContext->pIMsgDSN,
        m_pContext->pIDSNProperties);
    _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    DebugTrace((LPARAM)this, "sink returned hr %08lx", hr);
    
 CLEANUP:
    if(pSink)
        pSink->Release();
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreDispatcher::CDSNPostGenerateParams::CallObject


//////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------
//
// Function: CStoreDriver::Setprevious
//
// Synopsis: Method of IEventDispatcherChain - gets calle dy the
//           dispatcher, when binding changes happen.
//
// Arguments:
//   pUnkPrevious: [in] Pointer to the previous dispatcher
//   ppUnkPreload: [out] Receives an object which implements
//                 IEnumGUID, in order to tell the router
//                 which event types to pre-load.
//
// Returns:
//   S_OK: Success
//
// History:
//      dondu   06/22/98    Created
//
//-------------------------------------------------------------

const GUID* g_apStoreDispEventTypes[] = {&CATID_SMTP_STORE_DRIVER,&GUID_NULL};

HRESULT STDMETHODCALLTYPE CStoreDispatcher::SetPrevious(IUnknown *pUnkPrevious, IUnknown **ppUnkPreload) {
    HRESULT hrRes;

    if (ppUnkPreload) {
        *ppUnkPreload = NULL;
    }
    if (!ppUnkPreload) {
        return (E_POINTER);
    }
    _ASSERT(pUnkPrevious);
    if (pUnkPrevious) {
        CComQIPtr<CStoreDispatcherData,&__uuidof(CStoreDispatcherData)> pData;
        LPVOID pvServer;
        DWORD dwServerInstance;

        pData = pUnkPrevious;
        _ASSERT(pData);
        if (pData) {
            hrRes = pData->GetData(&pvServer,&dwServerInstance);

            // bugbug dbraun : removing this assert because it does not help us - we
            // need to put some code in to get more meaningful data when this problem
            // occurs
            //_ASSERT(SUCCEEDED(hrRes));

            if (SUCCEEDED(hrRes)) {
                hrRes = SetData(pvServer,dwServerInstance);
                _ASSERT(SUCCEEDED(hrRes));
            }
        }
    }
    hrRes = CEDEnumGUID::CreateNew(ppUnkPreload,g_apStoreDispEventTypes);
    return (hrRes);
};


HRESULT STDMETHODCALLTYPE CStoreDispatcher::SetContext(REFGUID guidEventType,
                                                       IEventRouter *piRouter,
                                                       IEventBindings *pBindings) {
    HRESULT hrRes;

    hrRes = CEventBaseDispatcher::SetContext(guidEventType,piRouter,pBindings);
    if (SUCCEEDED(hrRes) && (guidEventType == CATID_SMTP_STORE_DRIVER)) {
        HRESULT hrResTmp;
        LPVOID pvServer;
        DWORD dwServerInstance;
        AQ_ALLOC_PARAMS AllocParams;

        hrResTmp = GetData(&pvServer,&dwServerInstance);
        if (SUCCEEDED(hrResTmp)) {
            AllocParams.m_EventSmtpServer = (LPVOID *) pvServer;
            AllocParams.m_InstanceId = dwServerInstance;
            AllocParams.m_dwStartupType = SMTP_INIT_BINDING_CHANGE;

            hrResTmp = OnEvent(CATID_SMTP_STORE_DRIVER,SMTP_STOREDRV_STARTUP_EVENT,&AllocParams);
            _ASSERT(SUCCEEDED(hrResTmp));
        }
    }
    return (hrRes);
}


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::CSMTPSeoMgr
//
// Synopsis: Initialize member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:24:18: Created.
//
//-------------------------------------------------------------
CSMTPSeoMgr::CSMTPSeoMgr()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::CSMTPSeoMgr");

    m_dwSignature = SIGNATURE_CSMTPSEOMGR;
    m_pIEventRouter = NULL;
    m_pICatDispatcher = NULL;

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::CSMTPSeoMgr


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::~CSMTPSeoMgr
//
// Synopsis: Deinitialize if necessary
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:26:09: Created.
//
//-------------------------------------------------------------
CSMTPSeoMgr::~CSMTPSeoMgr()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::~CSMTPSeoMgr");

    Deinit();

    _ASSERT(m_dwSignature == SIGNATURE_CSMTPSEOMGR);
    m_dwSignature = SIGNATURE_CSMTPSEOMGR_INVALID;

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::~CSMTPSeoMgr


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::HrInit
//
// Synopsis: Initialize
//
// Arguments:
//  dwVSID: The virtual server ID
//
// Returns:
//  S_OK: Success
//  error from SEO
//
// History:
// jstamerj 1999/06/25 19:27:30: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPSeoMgr::HrInit(
    DWORD dwVSID)
{
    HRESULT hr = S_OK;
    CStoreDispatcherClassFactory cf;
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::HrInit");

    _ASSERT(m_pIEventRouter == NULL);

    hr = SEOGetRouter(
        GUID_SMTP_SOURCE_TYPE,
        (REFGUID) CStringGUID(GUID_SMTPSVC_SOURCE, dwVSID),
        &m_pIEventRouter);

    if(FAILED(hr) || (hr == S_FALSE)) {
        //
        // Map S_FALSE to file not found -- this happens when the
        // source type is not registered
        //
        if(hr == S_FALSE)
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        ErrorTrace((LPARAM)this, "SEOGetRouter failed hr %08lx", hr);
        m_pIEventRouter = NULL;
        goto CLEANUP;
    }
    //
    // Grab the dispatcher for the categorizer
    //
    _ASSERT(m_pICatDispatcher == NULL);

    hr = m_pIEventRouter->GetDispatcherByClassFactory(
        CLSID_CStoreDispatcher,
        &cf,
        CATID_SMTP_TRANSPORT_CATEGORIZE,
        IID_IServerDispatcher,
        (IUnknown **) &m_pICatDispatcher);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "GetDispatcherByClassFactory failed hr %08lx", hr);
        m_pICatDispatcher = NULL;
        goto CLEANUP;
    }

 CLEANUP:
    if(FAILED(hr))
        Deinit();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CSMTPSeoMgr::HrInit



//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::Deinit
//
// Synopsis: Deinitialize member variables
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/25 19:41:20: Created.
//
//-------------------------------------------------------------
VOID CSMTPSeoMgr::Deinit()
{
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::Deinit");

    if(m_pICatDispatcher) {
        m_pICatDispatcher->Release();
        m_pICatDispatcher = NULL;
    }

    if(m_pIEventRouter) {
        m_pIEventRouter->Release();
        m_pIEventRouter = NULL;
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CSMTPSeoMgr::Deinit


//+------------------------------------------------------------
//
// Function: CSMTPSeoMgr::HrTriggerServerEvent
//
// Synopsis: Trigger a server event
//
// Arguments:
//  dwEventType: event type to trigger
//  pvContext: structure specific to event type (see smtpseo.h)
//
// Returns:
//  S_OK: Success, called one or more sinks
//  S_FALSE: Success, no sinks called
//  MAILTRANSPORT_S_PENDING: Proccessing events async
//  E_OUTOFMEMORY
//  error from SEO
//
// History:
// jstamerj 1999/06/25 19:43:00: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPSeoMgr::HrTriggerServerEvent(
    DWORD dwEventType,
    PVOID pvContext)
{
    HRESULT hr = S_OK;
    CComPtr<IServerDispatcher> pEventDispatcher;
    CStoreDispatcherClassFactory cf;
    REFIID iidBindingPoint = GuidForEvent(dwEventType);
    TraceFunctEnterEx((LPARAM)this, "CSMTPSeoMgr::HrTriggerServerEvent");

    if(m_pIEventRouter == NULL)
        return E_POINTER;

    if(iidBindingPoint == CATID_SMTP_TRANSPORT_CATEGORIZE) {
        //
        // Use the cached Categorizer dispatcher
        //
        pEventDispatcher = m_pICatDispatcher;

    } else {
        //
        // Get the latest dispatcher with all changes
        //
        hr = m_pIEventRouter->GetDispatcherByClassFactory(
            CLSID_CStoreDispatcher,
            &cf,
            iidBindingPoint,
            IID_IServerDispatcher,
            (IUnknown **) &pEventDispatcher);

        if (FAILED(hr)) {

            ErrorTrace((LPARAM)this, "GetDispatcherByClassFactory failed hr %08lx", hr);
            goto CLEANUP;
        }
    }

    hr = pEventDispatcher->OnEvent(
        iidBindingPoint,
        dwEventType,
        pvContext);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CSMTPSeoMgr::HrTriggerServerEvent
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

// #define _ATL_STATIC_REGISTRY
#include <windows.h>
#include "stdafx.h"
#include "ole2.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\seomgr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: seomgr.h
//
// Contents: A class to manage the SEO dispatcher for a particular
//           SMTP virtual server 
//
// Classes:
//  CSMTPSeoMgr
//
// Functions:
//
// History:
// jstamerj 1999/06/25 19:11:03: Created.
//
//-------------------------------------------------------------
#include <windows.h>

interface IEventRouter;
interface IServerDispatcher;

#define ARRAY_SIZE(rg) (sizeof(rg)/sizeof(*rg))

//
// Class to manage the SEO configuration of one SMTP virtual server
//
class CSMTPSeoMgr
{
  public:
    CSMTPSeoMgr();
    ~CSMTPSeoMgr();

    HRESULT HrInit(
        DWORD dwVSID);
    VOID Deinit();

    HRESULT HrTriggerServerEvent(
        DWORD dwEventType,
        PVOID pvContext);

    IEventRouter *GetRouter()
    {
        return m_pIEventRouter;
    }

  private:
    #define SIGNATURE_CSMTPSEOMGR           (DWORD)'MSSC'
    #define SIGNATURE_CSMTPSEOMGR_INVALID   (DWORD)'MSSX'

    DWORD m_dwSignature;
    IEventRouter *m_pIEventRouter;
    IServerDispatcher *m_pICatDispatcher;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\seodisp.h ===
#ifndef __SEODISP_H__
#define __SEODISP_H__

#include "smtpseo.h"
#include <smtpevent.h>

#include "smtpguid.h"

#ifdef PLATINUM
#include <ptntintf.h>
#include "ptntguid.h"
#endif

#include <comcat.h>
#include "seolib2.h"

#ifdef PLATINUM
#include "cdosys.h"
#else
#include "cdo.h"
#endif // PLATINUM

#include "cdoconstimsg.h"
#include <baseobj.h>
#include <aqevents.h>

class __declspec(uuid("B226CEB5-0BBF-11d2-A011-00C04FA37348")) CStoreDispatcherData : public IUnknown {
	public:
		CStoreDispatcherData() {
			m_pvServer = NULL;
			m_dwServerInstance = 0;
		};
		HRESULT STDMETHODCALLTYPE GetData(LPVOID *ppvServer, DWORD *pdwServerInstance) {
			if (ppvServer) {
				*ppvServer = NULL;
			}
			if (pdwServerInstance) {
				*pdwServerInstance = 0;
			}
			if (!m_pvServer) {
				return (E_FAIL);
			}
			if (ppvServer) {
				*ppvServer = m_pvServer;
			}
			if (pdwServerInstance) {
				*pdwServerInstance = m_dwServerInstance;
			}
			return (S_OK);
		};
		HRESULT STDMETHODCALLTYPE SetData(LPVOID pvServer, DWORD dwServerInstance) {
			m_pvServer = pvServer;
			m_dwServerInstance = dwServerInstance;
			return (S_OK);
		};
	private:
		LPVOID m_pvServer;
		DWORD m_dwServerInstance;
};


class CStoreDispatcher :
        public CEventBaseDispatcher,
        public CComObjectRootEx<CComMultiThreadModelNoCS>,
        public IServerDispatcher,
        public IMailTransportNotify,
        public IClassFactory,
		public IEventDispatcherChain,
		public CStoreDispatcherData
{
    public:
        DECLARE_PROTECT_FINAL_CONSTRUCT();

        DECLARE_GET_CONTROLLING_UNKNOWN();

        DECLARE_NOT_AGGREGATABLE(CStoreDispatcher);

        BEGIN_COM_MAP(CStoreDispatcher)
            COM_INTERFACE_ENTRY(IEventDispatcher)
            COM_INTERFACE_ENTRY(IServerDispatcher)
            COM_INTERFACE_ENTRY(IMailTransportNotify)
            COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
			COM_INTERFACE_ENTRY(IClassFactory)
			COM_INTERFACE_ENTRY(IEventDispatcherChain)
			COM_INTERFACE_ENTRY_IID(__uuidof(CStoreDispatcherData),CStoreDispatcherData)
        END_COM_MAP()

        // this code gets called during initialization
        HRESULT FinalConstruct()
        {
            // we need to do this to signal that we are free threaded
            return (CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p));
        }

        // this has the global destructor code in it
        void FinalRelease() {}

        virtual HRESULT AllocBinding(REFGUID rguidEventType,
                                     IEventBinding *piBinding,
                                     CBinding **ppNewBinding)
        {
            if (ppNewBinding)
                *ppNewBinding = NULL;

            if (!piBinding || !ppNewBinding)
                return E_POINTER;

            *ppNewBinding = new CStoreBinding;
            if (*ppNewBinding == NULL)
                return E_OUTOFMEMORY;

            return S_OK;
        }

    //
    // Local binding class
    //
    class CStoreBinding : public CEventBaseDispatcher::CBinding
    {
      public:
        CStoreBinding();
        ~CStoreBinding();
        virtual HRESULT Init(IEventBinding *piBinding);

        LPSTR   GetRuleString() { return(m_szRule); }

      private:
        HRESULT GetAnsiStringFromVariant(CComVariant &vString, LPSTR *ppszString);

      public:
        LPSTR       m_szRule;
    };
    //
    // Parameter abstract base class
    //
#define SIGNATURE_VALID_CSTOREPARAMS (DWORD)'CSPa'
#define SIGNATURE_INVALID_CSTOREPARAMS (DWORD)'aPSC'
    class CStoreBaseParams :
        public CEventBaseDispatcher::CParams,
        public CBaseObject
    {
      public:
        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject) = 0;
        virtual HRESULT CallDefault() = 0;
        virtual HRESULT CallCompletion(HRESULT hrStatus)
        {
            //
            // Free this Params object (Referenced in CStoreDispatcher::OnEvent)
            //
            Release();
            return S_OK;
        }

        virtual HRESULT Init(PVOID pContext) = 0;

        HRESULT CheckMailMsgRule(
            CBinding *pBinding,
            IMailMsgProperties *pIMsgProps);

        HRESULT CheckMailMsgRecipientsRule(
            IUnknown *pIMsg,
            LPSTR pszPatterns);

        HRESULT CheckSignature()
        {
            return (m_dwSignature == SIGNATURE_VALID_CSTOREPARAMS) ? S_OK : E_FAIL;
        }

        HRESULT MatchEmailOrDomainName(
            LPSTR szEmail,
            LPSTR szPattern,
            BOOL  fIsEmail);

      public:
        CStoreBaseParams();
        ~CStoreBaseParams();
        HRESULT InitParamData(
            LPVOID pContext,
            DWORD  dwEventType,
            IMailTransportNotify *pINotify,
            REFIID rguidEventType);


      public:
        DWORD m_dwSignature;

        // This indicates which event type we are raising so that
        // the proper sink can be QI'd
        DWORD m_dwEventType;

      public:
        // Data needed for async sink operation:

        // How many sinks to skip on the next async sink completion
        DWORD m_dwIdx_SinkSkip;

        // Indicates wether or not default processing has been called
        BOOL  m_fDefaultProcessingCalled;

        // The IMailTransportNotify interface to pass to async capable sinks
        IMailTransportNotify *m_pINotify;

        // Our event type guid -- pass to dispatcher function
        GUID m_rguidEventType;

        // A pointer to the sink currently in asynchronous operation.
        // Must be NULL when no sinks are in async operation.
        IUnknown *m_pIUnknownSink;

    };

    //
    // Parameter class
    //
    class CStoreParams : public CStoreBaseParams
    {
        public:

        CStoreParams()
        {
            m_pContext = NULL;
        }

        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (AQ_ALLOC_PARAMS* )pContext;
            return S_OK;
        }
      public:
        AQ_ALLOC_PARAMS * m_pContext;

    };

    //
    // Parameter class - OnPreCategorize
    //
    class CMailTransportPreCategorizeParams : public CStoreBaseParams
    {
        public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_PRECATEGORIZE));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        EVENTPARAMS_PRECATEGORIZE m_Context;
    };

    //
    // Parameter class - OnPostCategorize
    //
    class CMailTransportPostCategorizeParams : public CStoreBaseParams
    {
        public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_POSTCATEGORIZE));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        EVENTPARAMS_POSTCATEGORIZE m_Context;
    };

    // ------------------------------------------------------------
    // Categorizer Parameter classes
    // ------------------------------------------------------------
    class CMailTransportCatRegisterParams : public CStoreBaseParams
    {
      public:
        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATREGISTER) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATREGISTER m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBeginParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBEGIN) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBEGIN m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatEndParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATEND) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATEND m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBuildQueryParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBUILDQUERY) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBUILDQUERY m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatBuildQueriesParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATBUILDQUERIES) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATBUILDQUERIES m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatSendQueryParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_CATSENDQUERY));
            //
            // Setup async params (so ICatAsyncContext can call back into dispatcher)
            //
            m_Context.pIMailTransportNotify = m_pINotify;
            m_Context.pvNotifyContext = (PVOID)this;
            return S_OK;
        }

      private:
        EVENTPARAMS_CATSENDQUERY m_Context;
    };

    //
    // Parameter class
    //
    class CMailTransportCatSortQueryResultParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATSORTQUERYRESULT) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATSORTQUERYRESULT m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatProcessItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATPROCESSITEM) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATPROCESSITEM m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportCatExpandItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            m_fAsyncCompletion = FALSE;
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_CATEXPANDITEM));
            m_Context.pIMailTransportNotify = m_pINotify;
            m_Context.pvNotifyContext = (PVOID)this;
            return S_OK;
        }

      private:
        BOOL m_fAsyncCompletion;
        EVENTPARAMS_CATEXPANDITEM m_Context;
    };

    //
    // Parameter class
    //
    class CMailTransportCatCompleteItemParams : public CStoreBaseParams
    {
      public:

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_CATCOMPLETEITEM) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_CATCOMPLETEITEM m_pContext;
    };

    //
    // Parameter class
    //
    class CMailTransportSubmissionParams : public CStoreBaseParams
    {
        public:
        CMailTransportSubmissionParams()
        {
            m_pCDOMessage = NULL;
        }
        ~CMailTransportSubmissionParams()
        {
            if(m_pCDOMessage)
                m_pCDOMessage->Release();
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT CallCompletion(HRESULT hrStatus);
        HRESULT Init(PVOID pContext)
        {
            CopyMemory(&m_Context, pContext, sizeof(EVENTPARAMS_SUBMISSION));
            return S_OK;
        }
        HRESULT CheckRule(CBinding &bBinding);

      private:
        HRESULT CallCDOSink(IUnknown *pSink);

        EVENTPARAMS_SUBMISSION m_Context;
        IMessage *m_pCDOMessage;
    };

    //
    // Create options class - Routing
    //
    class CRouterCreateOptions : public CEventCreateOptionsBase
    {
      public:

        CRouterCreateOptions(PEVENTPARAMS_ROUTER pContext)
        {
            _ASSERT (pContext != NULL);

            m_pContext = pContext;
        }

      private:
        HRESULT STDMETHODCALLTYPE Init(
            REFIID iidDesired,
            IUnknown **ppUnkObject,
            IEventBinding *,
            IUnknown *);

        PEVENTPARAMS_ROUTER m_pContext;
    };

    //
    // Parameter class - Routing
    //
    class CMailTransportRouterParams : public CStoreBaseParams
    {
      public:

        virtual HRESULT CallObject(IEventManager *pManager, CBinding&
                                   bBinding);
        virtual HRESULT CallObject(CBinding& bBinding, IUnknown
                                   *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_ROUTER) pContext;
            //
            // Make sure caller initialized pIMessageRouter to NULL
            //
            _ASSERT(m_pContext->pIMessageRouter == NULL);

            return S_OK;
        }

      private:
        PEVENTPARAMS_ROUTER m_pContext;
    };

    //
    // Parameter class
    //
    class CStoreAllocParams : public CEventBaseDispatcher::CParams
    {
    public:

        CStoreAllocParams();
        ~CStoreAllocParams();

        virtual HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);

    public:

        PFIO_CONTEXT  m_hContent;

    };

    //
    // Parameter class for msgTrackLog
    //
    class CMsgTrackLogParams : public CStoreBaseParams
    {
      public:
        CMsgTrackLogParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_MSGTRACKLOG) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_MSGTRACKLOG m_pContext;
    };

    //
    // Parameter class for mx records
    //
    class CDnsResolverRecordParams : public CStoreBaseParams
    {
      public:
        CDnsResolverRecordParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_DNSRESOLVERRECORD) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_DNSRESOLVERRECORD m_pContext;
    };

    //
    // Parameter class for max msg size exceeded event
    //
    class CSmtpMaxMsgSizeParams : public CStoreBaseParams
    {
      public:
        CSmtpMaxMsgSizeParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_MAXMSGSIZE) pContext;
            return S_OK;
        }

      private:
        PEVENTPARAMS_MAXMSGSIZE m_pContext;
    };
    //
    // Parameter classes for DSN events
    //
    // Create options class - DSN sinks
    //
    class CDSNCreateOptions : public CEventCreateOptionsBase
    {
      public:
        CDSNCreateOptions(DWORD dwVSID)
        {
            m_dwVSID = dwVSID;
        }

      private:
        HRESULT STDMETHODCALLTYPE Init(
            REFIID iidDesired,
            IUnknown **ppUnkObject,
            IEventBinding *,
            IUnknown *);

        DWORD m_dwVSID;
    };
    //
    // Parameter class for DSN params
    //
    class CDSNBaseParams : public CStoreBaseParams
    {
      public:
        HRESULT CallObject(
            IEventManager *pManager,
            CBinding& bBinding);

        virtual HRESULT CallObject(
            CBinding& bBinding,
            IUnknown *punkObject) = 0;

        virtual DWORD GetVSID() = 0;
    };
    //
    // Parameter class for OnSyncGetDNSRecipientIterator
    //
    class CDSNRecipientIteratorParams : public CDSNBaseParams
    {
      public:
        CDSNRecipientIteratorParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault()
        {
            return S_OK;
        }
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_GET_DSN_RECIPIENT_ITERATOR) pContext;
            return S_OK;
        }
        DWORD GetVSID()
        {
            return m_pContext->dwVSID;
        }
      private:
        PEVENTPARAMS_GET_DSN_RECIPIENT_ITERATOR m_pContext;
    };
    //
    // Parameter class for OnSyncGenerateDSN
    //
    class CDSNGenerateParams : public CDSNBaseParams
    {
      public:
        CDSNGenerateParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault();
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_GENERATE_DSN) pContext;
            return S_OK;
        }
        DWORD GetVSID()
        {
            return m_pContext->dwVSID;
        }

      private:
        PEVENTPARAMS_GENERATE_DSN m_pContext;
    };
    //
    // Parameter class for OnSyncPostGenerateDSN
    //
    class CDSNPostGenerateParams : public CDSNBaseParams
    {
      public:
        CDSNPostGenerateParams()
        {
            m_pContext = NULL;
        }

        HRESULT CallObject(CBinding& bBinding, IUnknown *punkObject);
        HRESULT CallDefault()
        {
            return S_OK;
        }
        HRESULT Init(PVOID pContext)
        {
            m_pContext = (PEVENTPARAMS_POST_GENERATE_DSN) pContext;
            return S_OK;
        }
        DWORD GetVSID()
        {
            return m_pContext->dwVSID;
        }

      private:
        PEVENTPARAMS_POST_GENERATE_DSN m_pContext;
    };
    HRESULT CreateCParams(
            DWORD               dwEventType,
            LPVOID              pContext,
            IMailTransportNotify *pINotify,
            REFIID              rGuidEventType,
            CStoreBaseParams    **ppCParams);

    HRESULT STDMETHODCALLTYPE OnEvent(
        REFIID  iidEvent,
        DWORD   dwEventType,
        LPVOID  pvContext);

    HRESULT STDMETHODCALLTYPE Dispatcher(
        REFIID rguidEventType,
        CStoreBaseParams *pParams);

    HRESULT STDMETHODCALLTYPE Notify(
        HRESULT hrStatus,
        PVOID pvContext);

    // IClassFactory methods
    public:
	    HRESULT STDMETHODCALLTYPE CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,  void * * ppvObj)
	    {
	        return CComObject<CStoreDispatcher>::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
	    }
	    HRESULT STDMETHODCALLTYPE LockServer (int fLock)
	    {
	        _ASSERT(FALSE);
	        return E_NOTIMPL;
	    }

	// IEventDispatcherChain methods
	public:
		HRESULT STDMETHODCALLTYPE SetPrevious(IUnknown *pUnkPrevious, IUnknown **ppUnkPreload);

	// IEventDispatcher methods
	public:
		HRESULT STDMETHODCALLTYPE SetContext(REFGUID guidEventType,
											 IEventRouter *piRouter,
											 IEventBindings *pBindings);

    private:
        CComPtr<IUnknown> m_pUnkMarshaler;
};

class CStoreDispatcherClassFactory : public IClassFactory
{
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void * * ppvObj)
    {
        _ASSERT(FALSE);
        return E_NOTIMPL;
    }
    unsigned long  STDMETHODCALLTYPE AddRef () { _ASSERT(FALSE); return 0; }
    unsigned long  STDMETHODCALLTYPE Release () { _ASSERT(FALSE); return 0; }

    // *** IClassFactory methods ***
    HRESULT STDMETHODCALLTYPE CreateInstance (LPUNKNOWN pUnkOuter, REFIID riid,  void * * ppvObj)
    {
        return CComObject<CStoreDispatcher>::_CreatorClass::CreateInstance(pUnkOuter, riid, ppvObj);
    }
    HRESULT STDMETHODCALLTYPE LockServer (int fLock)
    {
        _ASSERT(FALSE);
        return E_NOTIMPL;
    }
};


// helper functions
//
// jstamerj 980603 10:45:21: TriggerServerEvent with async callback
// support for completion
//

HRESULT TriggerServerEvent(IEventRouter             *pRouter,
                            DWORD                   dwEventType,
                            PVOID                   pvContext);


//
// register a new SEO instance.  if the instance is already registered
// this function will detect it and won't register it again.  it should
// be called for each instance at service startup and when each instance
// is created.
//
HRESULT RegisterPlatSEOInstance(DWORD dwInstanceID);
//
// unregister an SEO instance.  this should be called when an SEO
// instance is being deleted.
//
HRESULT UnregisterPlatSEOInstance(DWORD dwInstanceID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED_)
#define AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//#define _ATL_APARTMENT_THREADED

#define INCL_INETSRV_INCS
#include "dbgtrace.h"

#define _ATL_NO_DEBUG_CRT
#define _ASSERTE _ASSERT
#define _WINDLL
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#undef _WINDLL

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6D1C7805_EAEC_11D1_AA65_00C04FA35B82__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\wildmat.h ===
//---[ wildmat.h ]-------------------------------------------------------------
//
//  Description:
//      Provides support for a simple wildcard matching mechanism for 
//		matching email addresses.
//
//  Copyright (C) Microsoft Corp. 1997.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

#ifndef _WILDMAT_H_
#define _WILDMAT_H_

//---[ Prototypes ]------------------------------------------------------------

HRESULT MatchEmailOrDomainName(LPSTR szEmail, LPSTR szEmailDomain, LPSTR szPattern, BOOL fIsEmail);

#endif // _WILDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catconfig.h ===
/************************************************************
 * FILE: catconfig.h
 * PURPOSE: Store categorization config options
 * HISTORY:
 *  // jstamerj 980211 15:55:01: Created
 ************************************************************/

#ifndef _CATCONFIG_H
#define _CATCONFIG_H

#include "aqueue.h"

#define CAT_AQ_CONFIG_INFO_CAT_FLAGS ( \
    AQ_CONFIG_INFO_MSGCAT_DOMAIN | \
    AQ_CONFIG_INFO_MSGCAT_USER | \
    AQ_CONFIG_INFO_MSGCAT_PASSWORD | \
    AQ_CONFIG_INFO_MSGCAT_BINDTYPE | \
    AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE | \
    AQ_CONFIG_INFO_MSGCAT_HOST | \
    AQ_CONFIG_INFO_MSGCAT_FLAGS | \
    AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT | \
    AQ_CONFIG_INFO_MSGCAT_TYPE | \
    AQ_CONFIG_INFO_DEFAULT_DOMAIN | \
    AQ_CONFIG_INFO_MSGCAT_PORT | \
    AQ_CONFIG_INFO_MSGCAT_ENABLE \
)
                                      

#define RP_ERROR_STRING_UNKNOWN_USER "The user does not exist."
#define RP_ERROR_STRING_UNKNOWN_USER_W L"The user does not exist."

#endif //_CATCONFIG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catperf.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catperf.h
//
// Contents: Categorizer perf counter block
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1999/02/23 17:55:10: Created.
//
//-------------------------------------------------------------
#ifndef __CATPERF_H__
#define __CATPERF_H__


//
// One global perf structure for the LDAP stuff
//
extern CATLDAPPERFBLOCK g_LDAPPerfBlock;


//
// Handy macros
//
#define INCREMENT_BLOCK_COUNTER_AMOUNT(PBlock, CounterName, Amount) \
    InterlockedExchangeAdd((PLONG) (& ((PBlock)->CounterName)), (Amount))

#define INCREMENT_BLOCK_COUNTER(PBlock, CounterName) \
    InterlockedIncrement((PLONG) (& ((PBlock)->CounterName)))

#define INCREMENT_COUNTER_AMOUNT(CounterName, Amount) \
    INCREMENT_BLOCK_COUNTER_AMOUNT(GetPerfBlock(), CounterName, Amount)

#define INCREMENT_COUNTER(CounterName) \
    INCREMENT_BLOCK_COUNTER(GetPerfBlock(), CounterName)

#define DECREMENT_BLOCK_COUNTER(PBlock, CounterName) \
    InterlockedDecrement((PLONG) (& ((PBlock)->CounterName)))
    
#define DECREMENT_COUNTER(CounterName) \
    DECREMENT_BLOCK_COUNTER(GetPerfBlock(), CounterName)

#define INCREMENT_LDAP_COUNTER(CounterName) \
    INCREMENT_BLOCK_COUNTER(&g_LDAPPerfBlock, CounterName)

#define DECREMENT_LDAP_COUNTER(CounterName) \
    DECREMENT_BLOCK_COUNTER(&g_LDAPPerfBlock, CounterName)


#endif //__CATPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\aqdisp\wildmat.cpp ===
//---[ wildmat.cpp ]-------------------------------------------------------------
//
//  Description:
//      Provides support for a simple wildcard matching mechanism for
//		matching email addresses.
//
//  Copyright (C) Microsoft Corp. 1997.  All Rights Reserved.
//
// ---------------------------------------------------------------------------

//
// This stuff is isolated out to simplify unit-testing ...
//

#include "windows.h"
#include "abtype.h"
#include "dbgtrace.h"

static void pStringLower(LPSTR szString, LPSTR szLowerString)
{
	while (*szString)
		*szLowerString++ = (CHAR)tolower(*szString++);
	*szLowerString = '\0';
}

// This stuff is from address.hxx
#define MAX_EMAIL_NAME                          64
#define MAX_DOMAIN_NAME                         250
#define MAX_INTERNET_NAME                       (MAX_EMAIL_NAME + MAX_DOMAIN_NAME + 2) // 2 for @ and \0

//
// This is a quick and dirty function to do wildcard matching for email
// names. The match is case-insensitive, and the pattern can be expressed as:
//
// <email pattern>[@<domain pattern>]
//
// The email pattern is expressed as follows:
//
// <email pattern> := { * | [*]<email name>[*] }
//
// Which becomes one of the below:
// *		- Any email name
// foo		- Exact match for "foo"
// *foo		- Any email name ending with "foo", including "foo"
// foo*		- Any email name beginning with "foo", including "foo"
// *foo*	- Any email name that contains the string "foo", including "foo"
//
// If a domain is not specified, the pattern matches against any domain. Both the
// email pattern and the domain pattern (if specified) must be matched for the
// rule to fire. Domain patterns are expressed as:
//
// <domain pattern> := [*][<domain name>]
//
// Which are:
// *		- Any domain
// bar.com	- Exact match for "bar.com"
// *bar.com	- Any domain ending with "bar.com", including "bar.com"
//
// szEmail must be a string to the email alias (clean without comments, etc.)
// szEmailDomain must be a string to the email domain. NULL means no domain
// is specified. The domain must be clean without comments, etc.
//
//
typedef enum _WILDMAT_MODES
{
	WMOD_INVALID = 0,
	WMOD_WILDCARD_LEFT,		// Wildcard on the left
	WMOD_WILDCARD_RIGHT,	// Wildcard on the right
	WMOD_WILDCARD_BOTH,		// Wildcard on both sides
	WMOD_WILDCARD_MAX

} WILDMAT_MODES;

HRESULT MatchEmailOrDomainName(LPSTR szEmail, LPSTR szEmailDomain, LPSTR szPattern, BOOL fIsEmail)
{
	LPSTR		pszPatternDomain;
	BOOL		fEmailWildMat = FALSE;
	BOOL		fDomainWildMat = FALSE;
	DWORD		wmEmailWildMatMode = WMOD_INVALID;
	DWORD		dwEmailLen = 0, dwDomainLen = 0;
	DWORD		dwEmailStemLen = 0, dwDomainStemLen = 0;
	DWORD		i;
	HRESULT		hrRes = S_OK;
	CHAR		szDomainMat[MAX_INTERNET_NAME + 1];

	TraceFunctEnterEx((LPARAM)NULL, "MatchEmailOrDomainName");

	// This validates that it is a good email name
	lstrcpyn(szDomainMat, szPattern, MAX_INTERNET_NAME + 1);
	szPattern = szDomainMat;
	pszPatternDomain = strchr(szDomainMat, '@');

	// See if we have an email wildcard at the left
	if (*szPattern == '*')
	{
		DebugTrace((LPARAM)NULL, "We have a left wildcard");
		fEmailWildMat = TRUE;
		szPattern++;
		wmEmailWildMatMode = WMOD_WILDCARD_LEFT;
	}

	// Get the domain pointer
	if (szEmailDomain)
	{
		dwEmailLen = (DWORD)(szEmailDomain - szEmail);
		*szEmailDomain++ = '\0';
		dwDomainLen = lstrlen(szEmailDomain);
	}
	else
		dwEmailLen = lstrlen(szEmail);

	// Validate that the lengths of szEmail and szEmailDomain will not
	// overflow our buffers
	if (dwEmailLen > MAX_INTERNET_NAME ||
	    dwDomainLen > MAX_INTERNET_NAME)
	{
	    hrRes = E_INVALIDARG;
	    goto Cleanup;
	}

	if (pszPatternDomain)
	{
		dwEmailStemLen = (DWORD)(pszPatternDomain - szPattern);
		*pszPatternDomain++ = '\0';
		dwDomainStemLen = lstrlen(pszPatternDomain);
		if (*pszPatternDomain == '*')
		{
			fDomainWildMat = TRUE;
			dwDomainStemLen--;
			pszPatternDomain++;
		}
	}
	else
		dwEmailStemLen = lstrlen(szPattern);

	// See if we have an email wildcard at the right
	if (dwEmailStemLen &&
		*(szPattern + dwEmailStemLen - 1) == '*')
	{
		DebugTrace((LPARAM)NULL, "We have a right wildcard");

		szPattern[--dwEmailStemLen] = '\0';
		if (!fEmailWildMat)
		{
			// It has no left wildcard, so it is a right-only wildcard
			fEmailWildMat = TRUE;
			wmEmailWildMatMode = WMOD_WILDCARD_RIGHT;
		}
		else
			wmEmailWildMatMode = WMOD_WILDCARD_BOTH;
	}

	// Make sure there are no more wildcards embedded
	for (i = 0; i < dwEmailStemLen; i++)
		if (szPattern[i] == '*')
		{
			hrRes = ERROR_INVALID_PARAMETER;
			goto Cleanup;
		}
	for (i = 0; i < dwDomainStemLen; i++)
		if (pszPatternDomain[i] == '*')
		{
			hrRes = ERROR_INVALID_PARAMETER;
			goto Cleanup;
		}

	DebugTrace((LPARAM)NULL, "Email = <%s>, Domain = <%s>",
				szEmail, szEmailDomain?szEmailDomain:"none");
	DebugTrace((LPARAM)NULL, "Email = <%s>, Domain = <%s>",
				szPattern, pszPatternDomain?pszPatternDomain:"none");

	// OK, now eliminate by length
	if (dwEmailLen < dwEmailStemLen)
	{
		DebugTrace((LPARAM)NULL, "Email too short to match");
		hrRes = S_FALSE;
		goto Cleanup;
	}
	else
	{
		if (fEmailWildMat)
		{
			CHAR	szPatternLower[MAX_INTERNET_NAME + 1];
			CHAR	szEmailLower[MAX_INTERNET_NAME + 1];

			_ASSERT(wmEmailWildMatMode != WMOD_INVALID);
			_ASSERT(wmEmailWildMatMode < WMOD_WILDCARD_MAX);

			// Do the right thing based on the wildcard mode
			switch (wmEmailWildMatMode)
			{
			case WMOD_WILDCARD_LEFT:
				if (lstrcmpi(szPattern, szEmail + (dwEmailLen - dwEmailStemLen)))
				{
					DebugTrace((LPARAM)NULL, "Left email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;

			case WMOD_WILDCARD_RIGHT:
				pStringLower(szEmail, szEmailLower);
				pStringLower(szPattern, szPatternLower);
				if (strstr(szEmail, szPattern) != szEmail)
				{
					DebugTrace((LPARAM)NULL, "Right email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;

			case WMOD_WILDCARD_BOTH:
				pStringLower(szEmail, szEmailLower);
				pStringLower(szPattern, szPatternLower);
				if (strstr(szEmail, szPattern) == NULL)
				{
					DebugTrace((LPARAM)NULL, "Left and Right email wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
				break;
			}
		}
		else
		{
			if ((dwEmailLen != dwEmailStemLen) ||
				(lstrcmpi(szPattern, szEmail)))
			{
				DebugTrace((LPARAM)NULL, "Exact email match failed");
				hrRes = S_FALSE;
				goto Cleanup;
			}
		}
	}

	// We are matching the domain pattern
	if (pszPatternDomain)
	{
		if (!szEmailDomain)
		{
			DebugTrace((LPARAM)NULL, "No email domain");
			hrRes = S_FALSE;
			goto Cleanup;
		}

		if (dwDomainLen < dwDomainStemLen)
		{
			DebugTrace((LPARAM)NULL, "Domain too short to match");
			hrRes = S_FALSE;
			goto Cleanup;
		}
		else
		{
			if (fDomainWildMat)
			{
				if (lstrcmpi(pszPatternDomain,
							szEmailDomain + (dwDomainLen - dwDomainStemLen)))
				{
					DebugTrace((LPARAM)NULL, "Left domain wildcard mismatch");
					hrRes = S_FALSE;
					goto Cleanup;
				}
			}
			else
			{
				if ((dwDomainLen != dwDomainStemLen) ||
					(lstrcmpi(pszPatternDomain, szEmailDomain)))
				{
					DebugTrace((LPARAM)NULL, "Exact domain match failed");
					hrRes = S_FALSE;
					goto Cleanup;
				}
			}
		}
	}
	else
		hrRes = S_OK;

Cleanup:

	TraceFunctLeaveEx((LPARAM)NULL);
	return(hrRes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catdefs.h ===
//+---------------------------------------------------------------
//
//  File:   Catdefs.h
//
//  Synopsis:   Includes common definitions and datatypes for categorizer code
//
//  Copyright (C) 1998 Microsoft Corporation
//          All rights reserved.
//
//  History: // jstamerj 980305 14:32:17: Created
//
//----------------------------------------------------------------



#ifndef  __CATDEFS_H__
#define  __CATDEFS_H__

#include <iiscnfg.h>
#include "mailmsg.h"

#ifdef PLATINUM
#define _ICATEGORIZERITEM_ENDENUMMESS       (ICATEGORIZERITEM_FISRDNSEARCH + 1)
#else
#define _ICATEGORIZERITEM_ENDENUMMESS       ICATEGORIZERITEM_ENDENUMMESS
#endif

#define CAT_MAX_DOMAIN   (250)
#define CAT_MAX_LOGIN    (64)
#define CAT_MAX_PASSWORD CAT_MAX_LOGIN
//
//  Raid 127578
//
//  This length is inspired by the other protocols that we deal with.  The
//  default address limit is 1024, but the MTA can allow 1024 + 834  for the
//  OR address.  We'll define out default buffer size to allow this large
//  of an address.
//
#define CAT_MAX_INTERNAL_FULL_EMAIL (1860)
#define CAT_MAX_CONFIG   (512)
#define CAT_MAX_LDAP_DN  (CAT_MAX_INTERNAL_FULL_EMAIL)
#define CAT_MAX_REGVALUE_SIZE (1024)

// jstamerj 980305 16:07:47: $$TODO check these values
#define CAT_MAX_ADDRESS_TYPE_STRING (64)

// jstamerj 980319 19:55:15: SMTP/X500/X400/Custom
#define CAT_MAX_ADDRESS_TYPES 4

#define MAX_SEARCH_FILTER_SIZE  (CAT_MAX_INTERNAL_FULL_EMAIL + CAT_MAX_INTERNAL_FULL_EMAIL + sizeof("(=)"))


// jstamerj 980504 19:05:10: Define this to whatever IMsg is returning today.
#define CAT_IMSG_E_PROPNOTFOUND     MAILMSG_E_PROPNOTFOUND
#define CAT_IMSG_E_DUPLICATE        MAILMSG_E_DUPLICATE

// Metabase values
// Formerly MD_ROUTE_USER_NAME
#define CAT_MD_USERNAME             (SMTP_MD_ID_BEGIN_RESERVED+84)
// Formerly MD_ROUTE_PASSWORD
#define CAT_MD_PASSWORD             (SMTP_MD_ID_BEGIN_RESERVED+85)
// Formerly MD_SMTP_DS_HOST
#define CAT_MD_DOMAIN               (SMTP_MD_ID_BEGIN_RESERVED+91)

class CCatAddr;
class CCategorizer;
class CICategorizerListResolveIMP;

#endif //__CATDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catglobals.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catglobals.h
//
// Contents: Global varialbles and utility functions
//
// Functions: CatInitGlobals
//            CatDeinitGlobals
//
// History:
// jstamerj 1999/03/03 12:51:30: Created.
//
//-------------------------------------------------------------
#ifndef __CATGLOBALS_H__
#define __CATGLOBALS_H__

#include <windows.h>
#include <rwex.h>
#include <tran_evntlog.h>

//
// Global variables:
//
extern CExShareLock     g_InitShareLock;
extern DWORD            g_InitRefCount;
 
//
// Functions:
//
HRESULT CatInitGlobals();
VOID    CatDeinitGlobals();
 
//
// Store layer init/deinit functions
//
HRESULT CatStoreInitGlobals();
VOID    CatStoreDeinitGlobals();

    
#endif //__CATGLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\cattype.h ===
#ifndef __CATTYPE_H__
#define __CATTYPE_H__

class CCategorizer;
class CABWrapper;
class CLDWrapper;
class CCatAddr;
class CICategorizerListResolveIMP;

#include <cat.h>
#include <winldap.h>
#include "spinlock.h"

// Context used by CatMsg (top categorizer layer)
typedef struct _CATMSG_CONTEXT {
    CCategorizer *pCCat;
    LPVOID      pUserContext;
    PFNCAT_COMPLETION pfnCatCompletion;
#ifdef DEBUG
    LONG        lCompletionRoutineCalls;
#endif
} CATMSG_CONTEXT, *PCATMSG_CONTEXT;


// Context used by CatDLMsg
typedef struct _CATDLMSG_CONTEXT {
    CCategorizer *pCCat;
    LPVOID       pUserContext;
    PFNCAT_DLCOMPLETION pfnCatCompletion;
    BOOL         fMatch;
} CATDLMSG_CONTEXT, *PCATDLMSG_CONTEXT;
        

//
// RESOLVE_LIST_CONTEXT is a context associated with a list of names being
// resolved asynchronously. pUserContext points to a user provided context.
// pStoreContext is an opaque pointer used to hold async context needed by the
// underlying store (ie, FlatFile or LDAP store).
//
typedef struct {
    PVOID pUserContext;
    PVOID pStoreContext;
} RESOLVE_LIST_CONTEXT, *LPRESOLVE_LIST_CONTEXT;

#define CCAT_CONFIG_DEFAULT_VSID                   0
#define CCAT_CONFIG_DEFAULT_ENABLE                 0x00000000 //Disabled
#define CCAT_CONFIG_DEFAULT_FLAGS                  0xFFFFFFFF //Enable everything
#define CCAT_CONFIG_DEFAULT_ROUTINGTYPE            TEXT("Ldap")
#define CCAT_CONFIG_DEFAULT_BINDDOMAIN             TEXT("")
#define CCAT_CONFIG_DEFAULT_USER                   TEXT("")
#define CCAT_CONFIG_DEFAULT_PASSWORD               TEXT("")
#define CCAT_CONFIG_DEFAULT_BINDTYPE               TEXT("CurrentUser")
#define CCAT_CONFIG_DEFAULT_SCHEMATYPE             TEXT("NT5")
#define CCAT_CONFIG_DEFAULT_HOST                   TEXT("")
#define CCAT_CONFIG_DEFAULT_NAMINGCONTEXT          TEXT("")
#define CCAT_CONFIG_DEFAULT_DEFAULTDOMAIN          TEXT("")
#define CCAT_CONFIG_DEFAULT_PORT                   0


#endif //__CATTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catdebug.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catdebug.h
//
// Contents: Data/definitions used only for debugging
//
// Classes: None
//
// Functions:
//
// History:
// jstamerj 1999/07/29 17:32:34: Created.
//
//-------------------------------------------------------------
#ifndef __CATDEBUG_H__
#define __CATDEBUG_H__

//
// This #define controls wether or not the debug list checking is enabled
// Currently, enable it in RTL and DBG builds
//
#define CATDEBUGLIST

//
// A handy macro for declaring classes that use the debug list
//
#define CatDebugClass(ClassName)     class ClassName : public CCatDLO<ClassName##_didx>


//
// An alternative to calling DbgBreakPoint (since DbgBreakPoint breaks
// DogFood into the kernel debugger)
//
VOID CatDebugBreakPoint();

//
// Debug data types
//
typedef struct _tagDebugObjectList {
    DWORD      dwCount;
    LIST_ENTRY listhead;
    SPIN_LOCK  spinlock;
} DEBUGOBJECTLIST, *PDEBUGOBJECTLIST;


//
// Enumeation of all the class types that use the debug list
//
typedef enum _tagDebugObjectId {
                                                // Hex offset

    CABContext_didx = 0,                        // 0x00
    CSMTPCategorizer_didx,                      // 0x01

    CCategorizer_didx,                          // 0x02
    CCatSender_didx,                            // 0x03
    CCatRecip_didx,                             // 0x04
    CCatDLRecip_didx,                           // 0x05
    CMembersInsertionRequest_didx,              // 0x06
    CSinkInsertionRequest_didx,                 // 0x07
    CTopLevelInsertionRequest_didx,             // 0x08
    CICategorizerListResolveIMP_didx,           // 0x09
    CICategorizerDLListResolveIMP_didx,         // 0x0A
    CICategorizerParametersIMP_didx,            // 0x0B
    CICategorizerRequestedAttributesIMP_didx,   // 0x0C
    //
    // asyncctx
    //
    CSearchRequestBlock_didx,                   // 0x0D
    CStoreListResolveContext_didx,              // 0x0E
    CSingleSearchReinsertionRequest_didx,       // 0x0F
    //
    // cnfgmgr
    //
    CLdapCfgMgr_didx,                           // 0x10
    CLdapCfg_didx,                              // 0x11
    CLdapServerCfg_didx,                        // 0x12
    //
    // icatasync
    //
    CICategorizerAsyncContextIMP_didx,          // 0x13
    //
    // icatitemattr
    //
    CLdapResultWrap_didx,                       // 0x14
    CICategorizerItemAttributesIMP_didx,        // 0x15
    //
    // icatqueries
    //
    CICategorizerQueriesIMP_didx,               // 0x16
    //
    // ldapconn
    //
    CLdapConnection_didx,                       // 0x17
    //
    // ldapstor
    //
    CMembershipPageInsertionRequest_didx,       // 0x18
    CDynamicDLSearchInsertionRequest_didx,      // 0x19
    CEmailIDLdapStore_didx,                     // 0x1A
    //
    // pldapwrap
    //
    CPLDAPWrap_didx,                            // 0x1B

    //
    // The number of debug objects to support
    //
    NUM_DEBUG_LIST_OBJECTS

} DEBUGOBJECTID, *PDEBUGOBJECTID;

//
// Global array of lists
//
extern DEBUGOBJECTLIST g_rgDebugObjectList[NUM_DEBUG_LIST_OBJECTS];

//
// Debug Global init/deinit
//
VOID    CatInitDebugObjectList();
VOID    CatVrfyEmptyDebugObjectList();


//
// Class CCatDLO (Debug List Object): an object that adds and removes
// itself from a global list in its constructor/destructor (in debug
// builds) 
//
template <DEBUGOBJECTID didx> class CCatDLO
{
#ifdef CATDEBUGLIST

  public:
    CCatDLO()
    {
        _ASSERT(didx < NUM_DEBUG_LIST_OBJECTS);
        AcquireSpinLock(&(g_rgDebugObjectList[didx].spinlock));
        g_rgDebugObjectList[didx].dwCount++;
        InsertTailList(&(g_rgDebugObjectList[didx].listhead),
                       &m_le);
        ReleaseSpinLock(&(g_rgDebugObjectList[didx].spinlock));
    }
    virtual ~CCatDLO()
    {
        AcquireSpinLock(&(g_rgDebugObjectList[didx].spinlock));
        g_rgDebugObjectList[didx].dwCount--;
        RemoveEntryList(&m_le);
        ReleaseSpinLock(&(g_rgDebugObjectList[didx].spinlock));
    }        

  private:
    LIST_ENTRY m_le;
#endif // CATDEBUGLIST
};



//
// Handy Macros
// Cat Funct Entry/Exit (mirrors regtrace)
//
#define CatFunctEnterEx( lParam, sz ) \
        char *__CatFuncName = sz; \
        TraceFunctEnterEx( lParam, sz )

#define CatFunctEnter( sz ) CatFunctEnterEx( (LPARAM)0, sz)

#define CatFunctLeaveEx( lParam ) \
        TraceFunctLeaveEx( lParam );

#define CatFunctLeave() CatFunctLeaveEx( (LPARAM)0 )

//
// LOGGING macros -- 
// These should be used for failures that can result in
// NDRs/CatFailures.  It should not be used for functions that may
// fail in normal operation (for example, GetProperty() failing with
// MAILMSG_E_PROPNOTFOUND on a property that is not normally set
// should not be logged!).
//              
//
// ERROR_LOG --
//   regtrace and eventlog an error (at FILED_ENGINEERING level)
//
#define ERROR_LOG(SzFuncName) {                                      \
        ErrorTrace((LPARAM)this, SzFuncName " failed hr %08lx", hr); \
        CatLogFuncFailure(                                           \
            GetISMTPServerEx(),                                      \
            NULL,                                                    \
            __CatFuncName,                                           \
            SzFuncName,                                              \
            hr,                                                      \
            __FILE__,                                                \
            __LINE__);                                               \
        }

#define ERROR_LOG_STATIC(SzFuncName, Param, pISMTPServerEx) {        \
        ErrorTrace((LPARAM)Param, SzFuncName " failed hr %08lx", hr); \
        CatLogFuncFailure(                                           \
            pISMTPServerEx,                                          \
            NULL,                                                    \
            __CatFuncName,                                           \
            SzFuncName,                                              \
            hr,                                                      \
            __FILE__,                                                \
            __LINE__);                                               \
        }

//
// ERROR_CLEANUP_LOG --
//  if(FAILED(hr)), regtrace/eventlog an error and goto CLEANUP
//
#define ERROR_CLEANUP_LOG(SzFuncName)                                \
    if(FAILED(hr)) {                                                 \
        ErrorTrace((LPARAM)this, SzFuncName " failed hr %08lx", hr); \
        CatLogFuncFailure(                                           \
            GetISMTPServerEx(),                                      \
            NULL,                                                    \
            __CatFuncName,                                           \
            SzFuncName,                                              \
            hr,                                                      \
            __FILE__,                                                \
            __LINE__);                                               \
        goto CLEANUP;                                                \
    }

#define ERROR_CLEANUP_LOG_STATIC(SzFuncName, Param, pISMTPServerEx)  \
    if(FAILED(hr)) {                                                 \
        ErrorTrace((LPARAM)Param, SzFuncName " failed hr %08lx", hr); \
        CatLogFuncFailure(                                           \
            pISMTPServerEx,                                          \
            NULL,                                                    \
            __CatFuncName,                                           \
            SzFuncName,                                              \
            hr,                                                      \
            __FILE__,                                                \
            __LINE__);                                               \
        goto CLEANUP;                                                \
    }

//
// ERROR_LOG_ADDR
//  regtrace/eventlog an error.  In the eventlog,
//   include the email address correspoding to pItemProps if
//   available.
//
#define ERROR_LOG_ADDR(pAddr, SzFuncName) {                          \
        ErrorTrace((LPARAM)this, SzFuncName " failed hr %08lx", hr); \
        CatLogFuncFailure(                                           \
            GetISMTPServerEx(),                                      \
            pAddr,                                                   \
            __CatFuncName,                                           \
            SzFuncName,                                              \
            hr,                                                      \
            __FILE__,                                                \
            __LINE__);                                               \
        }

#define ERROR_LOG_ADDR_STATIC(pAddr, SzFuncName, Param, pISMTPServerEx) { \
        ErrorTrace((LPARAM)Param, SzFuncName " failed hr %08lx", hr); \
        CatLogFuncFailure(                                           \
            pISMTPServerEx,                                          \
            pAddr,                                                   \
            __CatFuncName,                                           \
            SzFuncName,                                              \
            hr,                                                      \
            __FILE__,                                                \
            __LINE__);                                               \
        }

//
// ERROR_CLEANUP_LOG_ADDR
//  if(FAILED(hr)), regtrace/eventlog an error and goto CLEANUP.  In
//   the eventlog, include the email address correspoding to
//   pItemProps if available.
//
#define ERROR_CLEANUP_LOG_ADDR(pAddr, SzFuncName)                    \
    if(FAILED(hr)) {                                                 \
        ErrorTrace((LPARAM)this, SzFuncName " failed hr %08lx", hr); \
        CatLogFuncFailure(                                           \
            GetISMTPServerEx(),                                      \
            pAddr,                                                   \
            __CatFuncName,                                           \
            SzFuncName,                                              \
            hr,                                                      \
            __FILE__,                                                \
            __LINE__);                                               \
        goto CLEANUP;                                                \
    }

#define ERROR_CLEANUP_LOG_ADDR_STATIC(pAddr, SzFuncName, Param, pISMTPServerEx) \
    if(FAILED(hr)) {                                                 \
        ErrorTrace((LPARAM)Param, SzFuncName " failed hr %08lx", hr); \
        CatLogFuncFailure(                                           \
            pISMTPServerEx,                                          \
            pAddr,                                                   \
            __CatFuncName,                                           \
            SzFuncName,                                              \
            hr,                                                      \
            __FILE__,                                                \
            __LINE__);                                               \
        goto CLEANUP;                                                \
    }


VOID CatLogFuncFailure(
    IN  ISMTPServerEx *pISMTPServerEx,
    IN  ICategorizerItem *pICatItem,
    IN  LPSTR pszFuncNameCaller,
    IN  LPSTR pszFuncNameCallee,
    IN  HRESULT hrFailure,
    IN  LPSTR pszFileName,
    IN  DWORD dwLineNumber);


HRESULT HrGetAddressStringFromICatItem(
    IN  ICategorizerItem *pICatItem,
    IN  DWORD dwcAddressType,
    OUT LPSTR pszAddressType,
    IN  DWORD dwcAddress,
    OUT LPSTR pszAddress);
    

#endif //__CATDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\catutil.h ===
#ifndef _CATUTIL_H
#define _CATUTIL_H

/************************************************************
 * FILE: catutil.h
 * PURPOSE: Handy utility stuff used by categorizer code
 * HISTORY:
 *  // jstamerj 980211 15:50:26: Created
 ************************************************************/

#include <abtype.h>
#include "aqueue.h"
#include "catconfig.h"
#include "cattype.h"

/************************************************************
 * MACROS
 ************************************************************/
#define ISHRESULT(hr) (((hr) == S_OK) || ((hr) & 0xFFFF0000))

/************************************************************
 * FUNCTION PROTOTYPES
 ************************************************************/
HRESULT CatMsgCompletion(HRESULT hr, PVOID pContext, IUnknown *pIMsg, IUnknown **rgpIMsg);
HRESULT CatDLMsgCompletion(HRESULT hr, PVOID pContext, IUnknown *pIMsg, IUnknown **rgpIMsg);
HRESULT CheckMessageStatus(IUnknown *pIMsg);

HRESULT GenerateCCatConfigInfo(
    PCCATCONFIGINFO pCatConfig, 
    AQConfigInfo *pAQConfig, 
    ISMTPServer *pISMTPServer,
    IAdvQueueDomainType *pIDomainInfo,
    DWORD *pdwVSID);


#endif //_CATUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccat.h ===
//
// ccat.h -- This file contains the class definations for:
//  CCategorizer
//  CAttributes
//  CCIRCULAR_DETECT
//
// Created:
//   Sep 3, 1996 -- Alex Wetmore (awetmore)
// Changes:
//// jstamerj 980227 14:13:42: Modified for Platinum categorizer


#ifndef __CCAT_H__
#define __CCAT_H__

#include <windows.h>
#include <transmem.h>
#include <listmacr.h>
#include "cat.h"
#include "cattype.h"
#include "idstore.h"
#include "catdefs.h"
#include "spinlock.h"
#include "catperf.h"

#define DEFAULT_VIRTUAL_SERVER_INSTANCES        10

#define MAX_FULL_EMAIL CAT_MAX_INTERNAL_FULL_EMAIL
#define MAX_ENUM_RESULT 100

// maximum number of times to resolve forwarding addresses on a given address
// before giving up and realizing that its a loop
#define MAX_FORWARD_ITERATIONS 25

#define AB_HASHFILENAME "route.hsh"

VOID AsyncResolveCompletion(LPVOID pContext);
VOID AsyncIMsgCatCompletion(LPVOID pContext);

#define NUM_SYSTEM_CCATADDR_PROPIDS 2


BOOL FIsHResultRetryable(IN  HRESULT hr);

//
// the address book
//
CatDebugClass(CCategorizer)
{
  public:
    CCategorizer();
    ~CCategorizer();

    //
    // Lifetime refcounting functions
    //
    LONG AddRef();
    LONG Release();
    VOID ReleaseAndWaitForDestruction();

    //
    // Initialize
    //
    HRESULT Initialize(
        PCCATCONFIGINFO pConfigInfo,
        DWORD dwICatItemPropIDs,
        DWORD dwICatListResolvePropIDs);

    //
    // Simple method to make sure the string terminates before
    // the max length, and the string points to readable memory.
    //
    BOOL VerifyStringLength(LPSTR szString, DWORD dwMaxLength);

    HRESULT AsyncResolveIMsg(IUnknown         *pImsg,
                             PFNCAT_COMPLETION pfnCatCompletion,
                             LPVOID            pContext);

    HRESULT AsyncResolveDLs( IUnknown         *pImsg,
                             PFNCAT_COMPLETION pfnCatCompletion,
                             LPVOID            pContext,
                             BOOL              fMatchOnly,
                             PBOOL             pfMatch,
                             CAT_ADDRESS_TYPE  CAType,
                             LPSTR             pszAddress);

    //
    // cancel all outstanding long running calls on other threads
    //
    void Cancel();

    //
    // Shutdown the address book
    //
    HRESULT Shutdown(void);

    //
    // Method to access EmailIDStore
    //
    CEmailIDStore<CCatAddr> *GetEmailIDStore() {
        return m_pStore;
    }

    //
    // Method to access our default SMTP domain
    //
    LPSTR GetDefaultSMTPDomain() {
        return m_ConfigInfo.pszDefaultDomain;
    }

    VOID CatCompletion(
        PFNCAT_COMPLETION pfnCatCOmpletion,
        HRESULT hr,
        LPVOID  pContext,
        IUnknown *pIMsg,
        IUnknown **rgpIMsg);

    VOID GetPerfCounters(
        PCATPERFBLOCK pCatPerfBlock)
    {
        //
        // Fill in the global LDAP perf counters on demand
        //
        CopyMemory(&(GetPerfBlock()->LDAPPerfBlock), &g_LDAPPerfBlock, sizeof(CATLDAPPERFBLOCK));
        CopyMemory(pCatPerfBlock, GetPerfBlock(), sizeof(CATPERFBLOCK));
    }

    VOID SetNextCCategorizer(
        CCategorizer *pCCat)
    {
        _ASSERT(m_pCCatNext == NULL);
        m_pCCatNext = pCCat;
        m_pCCatNext->AddRef();
    }

    VOID PrepareForShutdown()
    {
        m_fPrepareForShutdown = TRUE;
        Cancel();
    }

  private:

    //
    // make sure that an email address is valid
    //
    BOOL VerifyEmailAddress(LPSTR szEmail);
    BOOL VerifyDomainName(LPSTR szDomain);

    //
    // Do the default processing of OnCatRegister
    //
    HRESULT Register();

    //
    // Helper routine to set all schema parameters in ICatParams based
    // on a particular schema type
    //
    HRESULT RegisterSchemaParameters(LPSTR pszSchema);

    //
    // Routine to retrieve the ICatItem propID reserved for ptr to a
    // CCatAddr
    //
    DWORD GetICatItemCCatAddrPropId()
    {
        return m_dwICatParamSystemProp_CCatAddr;
    }

    //
    // PropId we use to build a list of CCatAddr prior to the first
    // resolution (we can't resolve as we go because asyncctx needs to
    // be pre-initialized with the number of top level resolves
    //
    DWORD GetICatItemChainPropId()
    {
        return m_dwICatParamSystemProp_CCatAddr + 1;
    }

    //
    // Routine to retrieve ISMTPServer for this virtual server
    //
    ISMTPServer *GetISMTPServer()
    {
        return m_ConfigInfo.pISMTPServer;
    }
    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }

    //
    // Routine to retrieve the domain config interface for this virtual server
    //
    ICategorizerDomainInfo *GetIDomainInfo()
    {
        return m_ConfigInfo.pIDomainInfo;
    }

    //
    // Retrieve the cat flags for this virtual server
    //
    DWORD GetCatFlags()
    {
        return m_ConfigInfo.dwCatFlags;
    }

public:
    //
    // A special DWORD that enables/disables cat for this VS
    //
    BOOL IsCatEnabled()
    {
        //
        // Check the enable/disable DWORD (DsUseCat) as well as
        // dwCatFlags (at least one flag must be set or we're still
        // disabled)
        //
        return ((m_ConfigInfo.dwEnable != 0) &&
                (m_ConfigInfo.dwCatFlags != 0));
    }

private:
    //
    // Copy in a config structure during initialization
    //
    HRESULT CopyCCatConfigInfo(PCCATCONFIGINFO pConfigInfo);

    //
    // Releae all memory and interfaces held by the ConfigInfo struct
    //
    VOID ReleaseConfigInfo();

    //
    // Helper routine to copy paramters
    //
    HRESULT SetICatParamsFromConfigInfo();

    //
    // Access to our config struct
    //
    PCCATCONFIGINFO GetCCatConfigInfo()
    {
        return &m_ConfigInfo;
    }

    ICategorizerParametersEx *GetICatParams()
    {
        return m_pICatParams;
    }

    DWORD GetNumCatItemProps()
    {
        return m_cICatParamProps;
    }
    DWORD GetNumCatListResolveProps()
    {
        return m_cICatListResolveProps;
    }

    //
    // Delayed initialize function
    //
    HRESULT DelayedInitialize();

    //
    // Do delayed initialize if not already done
    //
    HRESULT DelayedInitializeIfNecessary();

    PCATPERFBLOCK GetPerfBlock()
    {
        return &m_PerfBlock;
    }

    #define SIGNATURE_CCAT          ((DWORD)'tacC')
    #define SIGNATURE_CCAT_INVALID  ((DWORD)'XacC')
    DWORD m_dwSignature;
    //
    // Increment completion counters based on the list resolve status
    //
    HRESULT HrAdjustCompletionCounters(
        HRESULT hrListResolveStatus,
        IUnknown *pIMsg,
        IUnknown **rgpIMsg);


    BOOL fIsShuttingDown()
    {
        return m_fPrepareForShutdown;
    }

    //
    // ref count
    //
    LONG m_lRefCount;
    LONG m_lDestructionWaiters;
    BOOL m_fPrepareForShutdown;
    HANDLE m_hShutdownEvent;

    //
    // this is the pointer to the underlying EmailID store object.
    //
    CEmailIDStore<CCatAddr> *m_pStore;

    //
    // ICategorizerParametersEx -- configuration information for this
    // virtual server
    //
    ICategorizerParametersEx *m_pICatParams;

    //
    // Number of properties we need to allocate in each ICatParams
    //
    DWORD m_cICatParamProps;

    //
    // Number of properties we need to allocate in each ICatListResolve
    //
    DWORD m_cICatListResolveProps;

    //
    // The property ID in an ICategorizerItem used for CCatAddr *
    //
    DWORD m_dwICatParamSystemProp_CCatAddr;

    //
    // Configuration parameters passed in
    //
    CCATCONFIGINFO m_ConfigInfo;

    //
    // One of the following values:
    //   CAT_S_NOT_INITIALIED: Delayed initialize has not yet been done
    //   CAT_E_INIT_FAILED: Delayed initialize failed
    //   S_OK: Initialized okay
    //
    HRESULT m_hrDelayedInit;

    //
    // Keep track of what we have initialized
    //
    DWORD m_dwInitFlags;
    #define INITFLAG_REGISTER               0x0001
    #define INITFLAG_REGISTEREVENT          0x0002
    #define INITFLAG_STORE                  0x0004


    CRITICAL_SECTION m_csInit;

    //
    // A list to keep track of all outstanding list resolves
    //
    SPIN_LOCK m_PendingResolveListLock;
    LIST_ENTRY m_ListHeadPendingResolves;

    //
    // Refcounted pointer to a CCategorizer with a newer config
    //
    CCategorizer *m_pCCatNext;

    //
    // ISMTPServerEx interface pointer; if available
    //
    ISMTPServerEx *m_pISMTPServerEx;

    //
    // Performance counters
    //
    CATPERFBLOCK m_PerfBlock;

    VOID RemovePendingListResolve(
        CICategorizerListResolveIMP *pListResolve);

    VOID AddPendingListResolve(
        CICategorizerListResolveIMP *pListResolve);

    VOID CancelAllPendingListResolves(
        HRESULT hrReason = HRESULT_FROM_WIN32(ERROR_CANCELLED));

    friend VOID AsyncIMsgCatCompletion(LPVOID pContext);
    friend HRESULT MailTransport_Default_CatRegister(
        HRESULT hrStatus,
        PVOID   pvContext);
    friend class CICategorizerListResolveIMP;
    friend class CICategorizerDLListResolveIMP;
    friend class CCatAddr;
    friend class CABContext;
};

#endif //__CCAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccataddr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccataddr.h
//
// Contents: Definition of the CCatAddr class
//
// Classes: CCatAddr
//
// Functions:
//
// History:
// jstamerj 980324 19:08:13: Created.
//
//-------------------------------------------------------------

#ifndef __CCATADDR_H__
#define __CCATADDR_H__

#include <transmem.h>
#include <smtpinet.h>
#include "smtpevent.h"
#include "idstore.h"
#include "mailmsg.h"
#include "mailmsgprops.h"
#include "cattype.h"
#include "spinlock.h"
#include "ccat.h"
#include "icatitem.h"
#include "icatlistresolve.h"

typedef VOID (*PFN_EXPANDITEMCOMPLETION)(PVOID pContext);

// CCatAddr: abstract base class
//   The basic idea is this object which will contain the address,
//   address type, properties on this address, and the completion
//   routine to call when all properties have been looked up.  It is
//   the object that will be created by CAddressBook and passed to the
//   store for resolution.
//
class CCatAddr : 
    public CICategorizerItemIMP
{
  public:
    typedef enum _ADDROBJTYPE {
        OBJT_UNKNOWN,
        OBJT_USER,
        OBJT_DL
    } ADDROBJTYPE, *PADDROBJTYPE;

    //
    // Flags describing the locality of the orig address
    //
    #define LOCF_UNKNOWN            0x0000 // We haven't checked the locality yet
    #define LOCF_LOCALMAILBOX       0x0001 // The orig address is a local mailbox domain
    #define LOCF_LOCALDROP          0x0002 // The orig address is a local drop domain
    #define LOCF_REMOTE             0x0004 // The orig address is not local
    #define LOCF_ALIAS              0x0008 // The orig address is a local alias domain
    #define LOCF_UNKNOWNTYPE        0x0010 // Unknown due to the address type

    //
    // Flags that indicate the address should generally be treated as local
    //
    #define LOCFS_LOCAL             (LOCF_LOCALMAILBOX | LOCF_LOCALDROP | \
                                     LOCF_UNKNOWNTYPE)

    CCatAddr(CICategorizerListResolveIMP *pCICatListResolveIMP);
    virtual ~CCatAddr();

    // Send our query to the store
    virtual HRESULT HrDispatchQuery();

    // Lookup routine called by the EmailIDStore
    virtual VOID LookupCompletion();

    // ProcessItem routines
    virtual HRESULT HrProcessItem();
    virtual HRESULT HrProcessItem_Default();

    // ExpandItem routines
    virtual HRESULT HrExpandItem();
    virtual HRESULT HrExpandItem_Default(
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext) = 0;

    // CompleteItem routines
    virtual HRESULT HrCompleteItem();
    virtual HRESULT HrCompleteItem_Default() = 0;

    //
    // Storage and retreival procedures
    //
    virtual HRESULT HrGetOrigAddress(LPTSTR psz, DWORD dwcc, CAT_ADDRESS_TYPE *pType);
    virtual HRESULT GetSpecificOrigAddress(CAT_ADDRESS_TYPE CAType, LPTSTR psz, DWORD dwcc) = 0;
    virtual HRESULT HrGetLookupAddress(LPTSTR psz, DWORD dwcc, CAT_ADDRESS_TYPE *pType);
    virtual HRESULT HrAddAddresses(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPTSTR *rgpsz) = 0;

    //
    // Property setting routines to be called before completion routine
    //
    virtual HRESULT AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR szForwardingAddress) = 0;
    virtual HRESULT AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress)   = 0;
    virtual HRESULT AddDynamicDLMember(
        ICategorizerItemAttributes *pICatItemAttr) = 0;

    //
    // We will not know that a particular CCatAddr is the first in a
    // loop until after ProcessItem/ExpandItem/CompleteItem have all
    // finished -- so this function may be called after everything
    // has happened to this CCatAddr
    //
    virtual HRESULT HandleLoopHead()
    {
        return E_NOTIMPL;
    }

    //
    // The default implementation of AddNewAddress will call this if
    // HrValidateAddress fails
    //
    virtual HRESULT HrHandleInvalidAddress()
    {
        return S_OK;
    }
    
    //
    // For store assisted DL expansion (paged or dynamic), it will
    // call this function to indicate a particular attribute should be
    // expanded in an ICatItemAttributes
    //
    virtual HRESULT HrExpandAttribute(
        ICategorizerItemAttributes *pICatItemAttr,
        CAT_ADDRESS_TYPE CAType,
        LPSTR pszAttributeName,
        PDWORD pdwNumberMembers) 
    {
        return E_NOTIMPL;
    }
    //
    // Check and see if this object needs to be resolved or not (based
    // on DsUseCat flags)
    // Returns S_OK if the address should be resolved
    // Returns S_FALSE if the address should NOT be resolved
    //
    virtual HRESULT HrNeedsResolveing() = 0;
    //
    // Resolve this object if necessary (based on DsUseCat flags)
    //
    virtual HRESULT HrResolveIfNecessary();

    //
    // Build a query for this object
    //
    virtual HRESULT HrTriggerBuildQuery();

  protected:
    HRESULT HrValidateAddress(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress);
    HRESULT HrGetAddressLocFlags(LPTSTR szAddress, 
                                CAT_ADDRESS_TYPE CAType, 
                                DWORD *pdwlocflags,
                                DWORD *pdwDomainOffset);
    DWORD   DwGetOrigAddressLocFlags();
    HRESULT HrIsOrigAddressLocal(BOOL *pfLocal);
    HRESULT HrIsOrigAddressLocalMailbox(BOOL *pfLocal);
    HRESULT HrGetSMTPDomainLocFlags(LPTSTR pszDomain, 
                                    DWORD *pdwlocflags);
    HRESULT HrGetSMTPDomainFlags(LPTSTR pszDomain, PDWORD pdwFlags);
    HRESULT HrSwitchToAliasedDomain(CAT_ADDRESS_TYPE CAType, 
                                    LPTSTR szSMTPAddress, 
                                    DWORD dwcch);
    LPTSTR  GetNewAddress(CAT_ADDRESS_TYPE CAType);

    HRESULT CheckAncestorsForDuplicate(
        CAT_ADDRESS_TYPE  CAType,
        LPTSTR            pszAddress,
        BOOL              fCheckSelf,
        CCatAddr          **ppCCatAddrDup);

    HRESULT CheckAncestorsForDuplicate(
        DWORD dwNumAddresses,
        CAT_ADDRESS_TYPE *rgCAType,
        LPTSTR *rgpsz,
        BOOL fCheckSelf,
        CCatAddr **ppCCatAddrDup);

    HRESULT CheckForDuplicateCCatAddr(
        DWORD dwNumAddresses,
        CAT_ADDRESS_TYPE *rgCAType,
        LPTSTR *rgpsz);

    HRESULT HrAddNewAddressesFromICatItemAttr();

    static HRESULT HrBuildQueryDefault(
        HRESULT HrStatus,
        PVOID   pContext);

    HRESULT HrComposeLdapFilter();

    HRESULT HrComposeLdapFilterForType(
        DWORD     dwSearchAttribute,
        DWORD     dwSearchFilter,
        LPTSTR    pszAddress);

    HRESULT HrComposeLdapFilterFromPair(
        LPTSTR    pszSearchAttribute,
        LPTSTR    pszAttributeValue);

    HRESULT HrFormatAttributeValue(
        LPTSTR    pszAddress,
        DWORD     dwSearchFilter,
        LPTSTR    pszAttributeValue);

    static HRESULT HrConvertDNtoRDN(
        LPTSTR    pszDN,
        LPTSTR    pszRDNAttribute,
        LPTSTR    pszRDN);

    HRESULT HrEscapeFilterString(
        LPSTR     pszSrc,
        DWORD     dwcchDest,
        LPSTR     pszDest);

    //
    // Get the parent CCatAddr (if any)
    //
    HRESULT GetParentAddr(
        CCatAddr **ppParent)
    {
        HRESULT hr;
        ICategorizerItem *pItem;

        //
        // Get the parent ICatItem
        //
        hr = GetICategorizerItem(
            ICATEGORIZERITEM_PARENT,
            &pItem);

        if(FAILED(hr))
            return hr;

        //
        // Get CCatAddr from ICatItem
        //
        hr = pItem->GetPVoid(
            m_pCICatListResolve->GetCCategorizer()->GetICatItemCCatAddrPropId(),
            (PVOID *) ppParent);

        //
        // Addref this CCatAddr for our caller and release the ICatItem parent
        // interface
        //
        if(SUCCEEDED(hr)) {
            (*ppParent)->AddRef();
        }
        pItem->Release();

        return hr;
    }

    HRESULT SetMailMsgCatStatus(
        IMailMsgProperties *pIMailMsgProps,
        HRESULT hrStatus)
    {
        return m_pCICatListResolve->SetMailMsgCatStatus(
            pIMailMsgProps,
            hrStatus);
    }

    HRESULT SetListResolveStatus(
        HRESULT hrStatus)
    {
        return m_pCICatListResolve->SetListResolveStatus(
            hrStatus);
    }

    HRESULT GetListResolveStatus()
    {
        return m_pCICatListResolve->GetListResolveStatus();
    }

    //
    // Inline methods to retrieve ICategorizerItem Props
    //
    HRESULT GetItemStatus()
    {
        HRESULT hr;
        _VERIFY(SUCCEEDED(GetHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            &hr)));
        return hr;
    }

    HRESULT SetRecipientStatus(HRESULT hr)
    {
        return PutHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            hr);
    }

    HRESULT SetRecipientNDRCode(HRESULT hr)
    {
        return PutHRESULT(
            ICATEGORIZERITEM_HRNDRREASON,
            hr);
    }

    
    CCategorizer *GetCCategorizer()
    {
        return m_pCICatListResolve->GetCCategorizer();
    }

    ICategorizerParameters *GetICatParams()
    {
        return GetCCategorizer()->GetICatParams();
    }

    ISMTPServer *GetISMTPServer()
    {   
        return m_pCICatListResolve->GetISMTPServer();
    }
    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pCICatListResolve->GetISMTPServerEx();
    }
    LPRESOLVE_LIST_CONTEXT GetResolveListContext()
    {
        return m_pCICatListResolve->GetResolveListContext();
    }

    DWORD GetCatFlags()
    {
        return GetCCategorizer()->GetCatFlags();
    }
    VOID SetSenderResolved(BOOL fResolved)
    {
        m_pCICatListResolve->SetSenderResolved(fResolved);
    }
    VOID SetResolvingSender(BOOL fResolving)
    {
        m_pCICatListResolve->SetResolvingSender(fResolving);
    }
    BOOL IsSenderResolveFinished()
    {
        return m_pCICatListResolve->IsSenderResolveFinished();
    }
    PCATPERFBLOCK GetPerfBlock()
    {
        return m_pCICatListResolve->GetPerfBlock();
    }
    VOID IncPendingLookups()
    {
        m_pCICatListResolve->IncPendingLookups();
    }
    VOID DecrPendingLookups()
    {
        m_pCICatListResolve->DecrPendingLookups();
    }
    VOID GetStoreInsertionContext()
    {
        m_pCICatListResolve->GetStoreInsertionContext();
    }
    VOID ReleaseStoreInsertionContext()
    {
        m_pCICatListResolve->ReleaseStoreInsertionContext();
    }
    HRESULT HrInsertInsertionRequest(
        CInsertionRequest *pCInsertionRequest)
    {
        return m_pCICatListResolve->HrInsertInsertionRequest(
            pCInsertionRequest);
    }


    // Member data
    CICategorizerListResolveIMP        *m_pCICatListResolve;
    DWORD                               m_dwlocFlags;
    DWORD                               m_dwDomainOffset;
    LIST_ENTRY                          m_listentry;

    //
    // Any of these flags set indicates that the domain is local and
    // addresses in this domain should be found in the DS
    // (these are flags returned form IAdvQueueDomainType)
    //
    #define DOMAIN_LOCAL_FLAGS (DOMAIN_INFO_LOCAL_MAILBOX)

    friend HRESULT MailTransport_Default_ProcessItem(
        HRESULT hrStatus,
        PVOID pContext);
    friend HRESULT MailTransport_Default_ExpandItem(
        HRESULT hrStatus,
        PVOID pContext);
    friend VOID    MailTransport_DefaultCompletion_ExpandItem(
        PVOID pContext);
    friend HRESULT MailTransport_Completion_ExpandItem(
        HRESULT hrStatus,
        PVOID pContext);
    friend HRESULT MailTransport_Default_CompleteItem(
        HRESULT hrStatus,
        PVOID pContext);

    friend class CSinkInsertionRequest;
};


#endif // __CCATADDDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccatfn.h ===
//
// inline functions for CCategorizer and related classes
//

#ifndef __CCATFN_H__
#define __CCATFN_H__

#include <transmem.h>
#include "caterr.h"
#include "ccat.h"
#include "cpool.h"
#include "listmacr.h"

#include "icatlistresolve.h"

//
// Make sure the compiler knows about the explicit specialization before it is called
//
template<>
void
ReleaseEmailIDStore(
    CEmailIDStore<CCatAddr> *pStore);


//
// CCategorizer inline functions
//
inline
CCategorizer::CCategorizer()
{
    m_dwSignature = SIGNATURE_CCAT;
    m_pStore = NULL;
    m_pICatParams = NULL;
    m_cICatParamProps = 0L;
    m_cICatListResolveProps = 0L;
    m_dwICatParamSystemProp_CCatAddr = 0L;
    m_hShutdownEvent = INVALID_HANDLE_VALUE;
    m_lRefCount = 0;
    m_lDestructionWaiters = 0;
    m_ConfigInfo.dwCCatConfigInfoFlags = 0;
    m_hrDelayedInit = CAT_S_NOT_INITIALIZED;
    m_pCCatNext = NULL;
    m_dwInitFlags = 0;
    m_fPrepareForShutdown = FALSE;
    m_pISMTPServerEx = NULL;

    InitializeCriticalSection(&m_csInit);

    InitializeSpinLock(&m_PendingResolveListLock);
    InitializeListHead(&m_ListHeadPendingResolves);

    ZeroMemory(&m_PerfBlock, sizeof(m_PerfBlock));

}

inline
CCategorizer::~CCategorizer()
{
    _ASSERT(m_dwSignature == SIGNATURE_CCAT);
    m_dwSignature = SIGNATURE_CCAT_INVALID;

    if (m_pStore != NULL)
        ReleaseEmailIDStore( m_pStore );
    if (m_pICatParams)
        m_pICatParams->Release();
    if (m_hShutdownEvent != INVALID_HANDLE_VALUE)
        CloseHandle(m_hShutdownEvent);
    if (m_pCCatNext)
        m_pCCatNext->Release();
    if (m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    ReleaseConfigInfo();

    DeleteCriticalSection(&m_csInit);
}

//
// set the cancel flag to cancel any ongoing resolves
//
inline void CCategorizer::Cancel() 
{
    CatFunctEnter("CCategorizer::Cancel");

    CancelAllPendingListResolves();

    if(m_pStore)
        m_pStore->CancelAllLookups();

    CatFunctLeave();
}

//
// Call delayed initialize if it hasn't succeeded yet
//
inline HRESULT CCategorizer::DelayedInitializeIfNecessary()
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this, "CCategorizer::DelayedInitializeIfNecessary");

    switch(m_hrDelayedInit) {
        
     case S_OK:
         
         hr = S_FALSE;
         break;

     case CAT_E_INIT_FAILED:
     case CAT_S_NOT_INITIALIZED:

        EnterCriticalSection(&m_csInit);
        //
        // Check again, maybe we've been initialized
        //
        if((m_hrDelayedInit == CAT_S_NOT_INITIALIZED) ||
           (m_hrDelayedInit == CAT_E_INIT_FAILED)) {

            hr = DelayedInitialize();

            if(SUCCEEDED(hr))
                m_hrDelayedInit = S_OK;
            else {
                ERROR_LOG("DelayedInitialize");
                m_hrDelayedInit = CAT_E_INIT_FAILED;
            }

        } else {
            //
            // We've were initialized after we checked hr but before entering the CS
            //
            hr = (m_hrDelayedInit == S_OK) ? S_FALSE : CAT_E_INIT_FAILED;
        }

        LeaveCriticalSection(&m_csInit);
        break;

     default:
         
         _ASSERT(0 && "developer bozo error");
         hr = E_FAIL;
         break;
    }

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//
// Add a pending list resolve
//
inline VOID CCategorizer::AddPendingListResolve(
    CICategorizerListResolveIMP *pListResolve)
{
    AcquireSpinLock(&m_PendingResolveListLock);
    InsertTailList(&m_ListHeadPendingResolves, &(pListResolve->m_li));
    ReleaseSpinLock(&m_PendingResolveListLock);
}        
//
// Remove a pending list resolve
//
inline VOID CCategorizer::RemovePendingListResolve(
    CICategorizerListResolveIMP *pListResolve)
{
    AcquireSpinLock(&m_PendingResolveListLock);
    RemoveEntryList(&(pListResolve->m_li));
    ReleaseSpinLock(&m_PendingResolveListLock);
}


#endif //__CCATFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatitem.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitem.h
//
// Contents: Implementation of ICategorizerItem
//
// Classes: CCategorizerItemIMP
//
// Functions:
//
// History:
// jstamerj 980515 12:46:36: Created.
//
//-------------------------------------------------------------
#ifndef __ICATITEM_H__
#define __ICATITEM_H__

#include <windows.h>
#include <dbgtrace.h>
#include <smtpevent.h>
#include "icatprops.h"
#include <baseobj.h>

#define CICATEGORIZERITEMIMP_SIGNATURE (DWORD)'ICIM'
#define CICATEGORIZERITEMIMP_SIGNATURE_FREE (DWORD)'XCIM'


class CICategorizerItemIMP : 
    public CICategorizerPropertiesIMP,
    public CBaseObject,
    public ICategorizerItem
{
  public:
    STDMETHOD (QueryInterface) (
        REFIID iid,
        LPVOID *ppv);

    STDMETHOD_(ULONG, AddRef) ()
    { 
        return CBaseObject::AddRef();
    }
    STDMETHOD_(ULONG, Release) () 
    {
        return CBaseObject::Release();
    }

    //
    // We have multiple inheritence of GetStringA/etc happening -- the
    // pure virtual inheritence from ICategorizerItem and the
    // implemented inheritence from CICategorizerPropertiesIMP.  Solve
    // this problem by defining wrappers here
    //
  public:
    //ICategorizerItem
    STDMETHOD (GetStringA) (
        DWORD dwPropId, 
        DWORD cch, 
        LPSTR pszValue)
    {
        return CICategorizerPropertiesIMP::GetStringA(
            dwPropId,
            cch,
            pszValue);
    }

    STDMETHOD (PutStringA) (
        DWORD dwPropId,
        LPSTR pszValue)
    {
        return CICategorizerPropertiesIMP::PutStringA(
            dwPropId,
            pszValue);
    }

    STDMETHOD (GetDWORD) (
        DWORD dwPropId,
        DWORD *pdwValue)
    {
        return CICategorizerPropertiesIMP::GetDWORD(
            dwPropId,
            pdwValue);
    }

    STDMETHOD (PutDWORD) (
        DWORD dwPropId,
        DWORD dwValue)
    {
        return CICategorizerPropertiesIMP::PutDWORD(
            dwPropId,
            dwValue);
    }

    STDMETHOD (GetHRESULT) (
        DWORD dwPropId,
        HRESULT *phrValue)
    {
        return CICategorizerPropertiesIMP::GetHRESULT(
            dwPropId,
            phrValue);
    }

    STDMETHOD (PutHRESULT) (
        DWORD dwPropId,
        HRESULT hrValue)
    {
        return CICategorizerPropertiesIMP::PutHRESULT(
            dwPropId,
            hrValue);
    }

    STDMETHOD (GetBool) (
        DWORD dwPropId,
        BOOL  *pfValue)
    {
        return CICategorizerPropertiesIMP::GetBool(
            dwPropId,
            pfValue);
    }

    STDMETHOD (PutBool) (
        DWORD dwPropId,
        BOOL  fValue)
    {
        return CICategorizerPropertiesIMP::PutBool(
            dwPropId,
            fValue);
    }

    STDMETHOD (GetPVoid) (
        DWORD dwPropId,
        PVOID *ppv)
    {
        return CICategorizerPropertiesIMP::GetPVoid(
            dwPropId,
            ppv);
    }

    STDMETHOD (PutPVoid) (
        DWORD dwPropId,
        PVOID pvValue)
    {
        return CICategorizerPropertiesIMP::PutPVoid(
            dwPropId,
            pvValue);
    }

    STDMETHOD (GetIUnknown) (
        DWORD dwPropId,
        IUnknown **ppUnknown)
    {
        return CICategorizerPropertiesIMP::GetIUnknown(
            dwPropId,
            ppUnknown);
    }

    STDMETHOD (PutIUnknown) (
        DWORD dwPropId,
        IUnknown *pUnknown)
    {
        return CICategorizerPropertiesIMP::PutIUnknown(
            dwPropId,
            pUnknown);
    }

    STDMETHOD (GetIMailMsgProperties) (
        DWORD dwPropId,
        IMailMsgProperties **ppIMailMsgProperties)
    {
        return CICategorizerPropertiesIMP::GetIMailMsgProperties(
            dwPropId,
            ppIMailMsgProperties);
    }

    STDMETHOD (PutIMailMsgProperties) (
        DWORD dwPropId,
        IMailMsgProperties *ppIMailMsgProperties)
    {
        return CICategorizerPropertiesIMP::PutIMailMsgProperties(
            dwPropId,
            ppIMailMsgProperties);
    }

    STDMETHOD (GetIMailMsgRecipientsAdd) (
        DWORD dwPropId,
        IMailMsgRecipientsAdd **ppIMsgRecipientsAdd)
    {
        return CICategorizerPropertiesIMP::GetIMailMsgRecipientsAdd(
            dwPropId,
            ppIMsgRecipientsAdd);
    }

    STDMETHOD (PutIMailMsgRecipientsAdd) (
        DWORD dwPropId,
        IMailMsgRecipientsAdd *pIMsgRecipientsAdd)
    {
        return CICategorizerPropertiesIMP::PutIMailMsgRecipientsAdd(
            dwPropId,
            pIMsgRecipientsAdd);
    }

    STDMETHOD (GetICategorizerItemAttributes) (
        DWORD dwPropId,
        ICategorizerItemAttributes **ppICategorizerItemAttributes)
    {
        return CICategorizerPropertiesIMP::GetICategorizerItemAttributes(
            dwPropId,
            ppICategorizerItemAttributes);
    }

    STDMETHOD (PutICategorizerItemAttributes) (
        DWORD dwPropId,
        ICategorizerItemAttributes *pICategorizerItemAttributes)
    {
        return CICategorizerPropertiesIMP::PutICategorizerItemAttributes(
            dwPropId,
            pICategorizerItemAttributes);
    }

    STDMETHOD (GetICategorizerListResolve) (
        DWORD dwPropId,
        ICategorizerListResolve **ppICategorizerListResolve)
    {
        return CICategorizerPropertiesIMP::GetICategorizerListResolve(
            dwPropId,
            ppICategorizerListResolve);
    }

    STDMETHOD (PutICategorizerListResolve) (
        DWORD dwPropId,
        ICategorizerListResolve *pICategorizerListResolve)
    {
        return CICategorizerPropertiesIMP::PutICategorizerListResolve(
            dwPropId,
            pICategorizerListResolve);
    }

    STDMETHOD (GetICategorizerMailMsgs) (
        DWORD dwPropId,
        ICategorizerMailMsgs **ppICategorizerMailMsgs)
    {
        return CICategorizerPropertiesIMP::GetICategorizerMailMsgs(
            dwPropId,
            ppICategorizerMailMsgs);
    }

    STDMETHOD (PutICategorizerMailMsgs) (
        DWORD dwPropId,
        ICategorizerMailMsgs *pICategorizerMailMsgs)
    {
        return CICategorizerPropertiesIMP::PutICategorizerMailMsgs(
            dwPropId,
            pICategorizerMailMsgs);
    }
    
    STDMETHOD (GetICategorizerItem) (
        DWORD dwPropId,
        ICategorizerItem **ppICategorizerItem)
    {
        return CICategorizerPropertiesIMP::GetICategorizerItem(
            dwPropId,
            ppICategorizerItem);
    }
    
    STDMETHOD (PutICategorizerItem) (
        DWORD dwPropId,
        ICategorizerItem *pICategorizerItem)
    {
        return CICategorizerPropertiesIMP::PutICategorizerItem(
            dwPropId,
            pICategorizerItem);
    }

    STDMETHOD (UnSetPropId) (
        DWORD dwPropId)
    {
        return CICategorizerPropertiesIMP::UnSetPropId(
            dwPropId);
    }

  private:
    CICategorizerItemIMP();
    virtual ~CICategorizerItemIMP();

    DWORD m_dwSignature;

    friend class CCatAddr;
    friend class CIMsgRecipListAddr;
    friend class CICategorizerListResolveIMP;
    friend class CICategorizerDLListResolveIMP;
};

#endif //__ICATITEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatlistresolve.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatlistresolve.h
//
// Contents: Implementation of ICategorizerListResolve
//
// Classes: CICategorizerListResolveIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/25 17:40:39: Created.
//
//-------------------------------------------------------------
#ifndef __ICATLISTRESOLVE_H__
#define __ICATLISTRESOLVE_H__

#include <smtpevent.h>
#include <smtpinet.h>
#include <ccat.h>
#include <baseobj.h>
#include "icatmailmsgs.h"
#include "icatprops.h"

#define SIGNATURE_CICATEGORIZERLISTRESOLVEIMP (DWORD)'ICLR'
#define SIGNATURE_CICATEGORIZERLISTRESOLVEIMP_FREE (DWORD)'XCLR'

//
// Disable the warnings concerining using this in the constructor.
// Trust me, it's safe here since it's just a back pointer being
// passed into a member class (it's not used during construction in
// any other way)
//
#pragma warning (disable: 4355)

class CCatRecip;
class CICategorizerListResolveIMP;

CatDebugClass(CSinkInsertionRequest),
    public CInsertionRequest
{
  public:
    DWORD AddRef();
    DWORD Release();
    HRESULT HrInsertSearches(
        DWORD dwcSearches);

    VOID NotifyDeQueue(
        HRESULT hr);

    VOID FinalRelease() {}

  private:
    #define SIGNATURE_CSINKINSERTIONREQUEST         (DWORD)'QRIS'
    #define SIGNATURE_CSINKINSERTIONREQUEST_INVALID (DWORD)'XRIS'

    CSinkInsertionRequest(
        CICategorizerListResolveIMP *pCICatListResolve)
    {
        m_dwSignature = SIGNATURE_CSINKINSERTIONREQUEST;
        m_fInserted = FALSE;
        InitializeSpinLock(&m_spinlock);
        InitializeListHead(&m_listhead);
        m_pCICatListResolve = pCICatListResolve;
    }
    ~CSinkInsertionRequest()
    {
        _ASSERT(IsListEmpty(&m_listhead));
        _ASSERT(m_dwSignature == SIGNATURE_CSINKINSERTIONREQUEST);
        m_dwSignature = SIGNATURE_CSINKINSERTIONREQUEST_INVALID;
        //
        // Set the base object (CInsertionRequest's) refcount to zero
        // so that it does not assert in the destructor
        //
        m_dwRefCount = 0;
    }

    VOID InsertItem(
        CCatAddr *pCCatAddr);

    VOID InsertInternalInsertionRequest(BOOL fReinset = FALSE);

    ISMTPServerEx *GetISMTPServerEx();

  private:
    DWORD      m_dwSignature;
    SPIN_LOCK  m_spinlock;
    BOOL       m_fInserted;
    LIST_ENTRY m_listhead;
    CICategorizerListResolveIMP *m_pCICatListResolve;

    friend class CICategorizerListResolveIMP;
};

CatDebugClass(CTopLevelInsertionRequest),
    public CInsertionRequest
{
  public:
    DWORD AddRef();
    DWORD Release();
    HRESULT HrInsertSearches(
        DWORD dwcSearches);

    VOID NotifyDeQueue( 
        HRESULT hr);

    VOID FinalRelease() {}

  private:
    #define SIGNATURE_CTOPLEVELINSERTIONREQUEST         (DWORD)'RILT'
    #define SIGNATURE_CTOPLEVELINSERTIONREQUEST_INVALID (DWORD)'XILT'

    CTopLevelInsertionRequest(
        CICategorizerListResolveIMP *pCICatListResolve)
    {
        m_dwSignature = SIGNATURE_CTOPLEVELINSERTIONREQUEST;
        m_pCICatListResolve = pCICatListResolve;

        m_pIMailMsgProperties = NULL;
        m_pOrigRecipList = NULL;
        m_pCatRecipList = NULL;

        m_fSenderFinished = FALSE;
        m_dwcRecips = 0;
        m_dwNextRecip = 0;
        m_hr = S_OK;
    }
    ~CTopLevelInsertionRequest()
    {
        _ASSERT(m_dwSignature == SIGNATURE_CTOPLEVELINSERTIONREQUEST);
        m_dwSignature = SIGNATURE_CTOPLEVELINSERTIONREQUEST_INVALID;
        //
        // Set the base object (CInsertionRequest's) refcount to zero
        // so that it does not assert in the destructor
        //
        m_dwRefCount = 0;
    }

    VOID BeginItemResolves(
        IMailMsgProperties *pIMailMsgProperties,
        IMailMsgRecipients *pOrigRecipList,
        IMailMsgRecipientsAdd *pCatRecipList); 

    BOOL fTopLevelInsertionFinished()
    {
        return (FAILED(m_hr) || 
                ((m_fSenderFinished) && (m_dwNextRecip >= m_dwcRecips)));
    }

    PCATPERFBLOCK GetPerfBlock();

    ISMTPServerEx *GetISMTPServerEx();

  private:
    DWORD      m_dwSignature;
    CICategorizerListResolveIMP *m_pCICatListResolve;
    BOOL       m_fSenderFinished;
    DWORD      m_dwcRecips;
    DWORD      m_dwNextRecip;
    HRESULT    m_hr;
    IMailMsgProperties *m_pIMailMsgProperties;
    IMailMsgRecipients *m_pOrigRecipList;
    IMailMsgRecipientsAdd *m_pCatRecipList;

    friend class CICategorizerListResolveIMP;
};



class CICategorizerListResolveIMP :
    public CICategorizerPropertiesIMP,
    public CCatDLO<CICategorizerListResolveIMP_didx>,
    public ICategorizerListResolve
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) () 
    { 
        return InterlockedIncrement(&m_lRef);
    }
    STDMETHOD_(ULONG, Release) ()
    {
        LONG lRet;
        lRet = InterlockedDecrement(&m_lRef);
        if(lRet == 0)
            FinalRelease();
        return lRet;
    }

  public:
    //ICategorizerListResolve
    STDMETHOD(AllocICategorizerItem)(
        IN   eSourceType Sourcetype,
        OUT  ICategorizerItem **ppICatItem);

    STDMETHOD(ResolveICategorizerItem)(
        IN   ICategorizerItem *pICatItem);

    STDMETHOD(SetListResolveStatus)(
        IN   HRESULT hrStatus);

    STDMETHOD(GetListResolveStatus)(
        IN   HRESULT *phrStatus);

  protected:
    CICategorizerListResolveIMP(
        CCategorizer *pCCat,
        PFNCAT_COMPLETION pfnCatCompletion,
        PVOID pContext) : 
        m_CICategorizerMailMsgs(this),
        CICategorizerPropertiesIMP((ICategorizerListResolve *)this),
        m_CSinkInsertionRequest(this),
        m_CTopLevelInsertionRequest(this)
    {
        _ASSERT(pCCat);
        m_Signature = SIGNATURE_CICATEGORIZERLISTRESOLVEIMP;
        m_pCCat = pCCat;
        m_pCCat->AddRef();
        m_hrListResolveStatus = S_OK;
        m_pfnCatCompletion = pfnCatCompletion;
        m_pCompletionContext = pContext;
        m_fSenderResolved = FALSE;
        m_fResolvingSender = FALSE;
        InitializeSpinLock(&m_spinlock);
        InitializeListHead(&m_listhead_recipients);
        m_dwcPendingLookups = 0;
        m_lRef = 1; // 1 Reference from the creator
    }
    virtual ~CICategorizerListResolveIMP()
    {
        _ASSERT(m_Signature == SIGNATURE_CICATEGORIZERLISTRESOLVEIMP);
        m_Signature = SIGNATURE_CICATEGORIZERLISTRESOLVEIMP_FREE;
    }
    
    HRESULT Initialize(
        IUnknown *pIMsg);

    //
    // Kicks off async categorizer for all recipients&sender in the message
    //
    virtual HRESULT StartMessageCategorization();

    //
    // Handles list resolve completion
    //
    virtual HRESULT CompleteMessageCategorization();

    //
    // Helper routines to create all ICatItems and start a message
    // resolve
    //
    virtual HRESULT BeginItemResolves(
        IMailMsgProperties *pIMailMsgProperties,
        IMailMsgRecipients *pOrigRecipList,
        IMailMsgRecipientsAdd *pCatRecipList);

    //
    // Helper routines to set the cat status property of a mailmsg
    //
    HRESULT SetMailMsgCatStatus(
        IMailMsgProperties *pIMailMsgProps, 
        HRESULT hrStatus);

    HRESULT SetMailMsgCatStatus(
        IUnknown *pIMsg, 
        HRESULT hrStatus);

    // Inline Methods on accessing context members:
    CCategorizer *GetCCategorizer() {
        return m_pCCat;
    }
    CICategorizerMailMsgsIMP * GetCICategorizerMailMsgs() {
        return &m_CICategorizerMailMsgs;
    }
    HRESULT GetListResolveStatus() {
        return m_hrListResolveStatus;
    }
    CEmailIDStore<CCatAddr> * GetEmailIDStore() {
        return m_pCCat->GetEmailIDStore();
    }
    LPRESOLVE_LIST_CONTEXT GetResolveListContext() {
        return &m_rlc;
    }
    HRESULT CancelResolveList(HRESULT hrReason) {
        return GetEmailIDStore()->CancelResolveList(&m_rlc, hrReason);
    }
    HRESULT GetCCatAddrFromICategorizerItem(
        ICategorizerItem *pICatItem,
        CCatAddr **ppCCatAddr)
    {
        HRESULT hr;
        hr = pICatItem->GetPVoid(
            m_pCCat->GetICatItemCCatAddrPropId(),
            (PVOID *)ppCCatAddr);
        return hr;
    }
    ISMTPServer *GetISMTPServer()
    {
        return m_pCCat->GetISMTPServer();
    }
    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pCCat->GetISMTPServerEx();
    }
    ICategorizerDomainInfo *GetIDomainInfo()
    {
        return m_pCCat->GetIDomainInfo();
    }
    VOID AddToResolveChain(
        ICategorizerItem **ppICatItemHead,
        ICategorizerItem **ppICatItemTail,
        ICategorizerItem *pICatItemAdd)
    {
        HRESULT hr = S_OK;

        if(*ppICatItemHead == NULL) {
            _ASSERT(*ppICatItemTail == NULL);
            //
            // The new item is the new head/tail -- set and addref it
            //
            *ppICatItemHead = *ppICatItemTail = pICatItemAdd;
            pICatItemAdd->AddRef();

        } else {
            //
            // Add the new item to the tail of the list
            //
            _VERIFY(SUCCEEDED((*ppICatItemTail)->PutICategorizerItem(
                GetCCategorizer()->GetICatItemChainPropId(),
                pICatItemAdd)));
            
            //
            // Update the new tail
            //
            *ppICatItemTail = pICatItemAdd;
        }
    }

    virtual VOID CallCompletion(
        HRESULT hr,
        PVOID pContext,
        IUnknown *pMsg,
        IUnknown **rgpMsgs) {
        
        _ASSERT(m_pfnCatCompletion);
        GetCCategorizer()->CatCompletion(
            m_pfnCatCompletion,
            hr,
            pContext,
            pMsg,
            rgpMsgs);
    }
    DWORD GetNumCatItemProps()
    {
        return GetCCategorizer()->GetNumCatItemProps();
    }
    virtual DWORD GetCatFlags()
    {
        return GetCCategorizer()->GetCatFlags();
    }
    VOID SetSenderResolved(BOOL fResolved);

    VOID SetResolvingSender(BOOL fResolving)
    {
        m_fResolvingSender = fResolving;
    }
    VOID ResolveRecipientAfterSender(CCatRecip *pRecip);

    BOOL IsSenderResolveFinished()
    {
        // only return false if the sender resolve is pending
        return (m_fResolvingSender ? m_fSenderResolved : TRUE);
    }
    ICategorizerParameters *GetICatParams()
    {
        return GetCCategorizer()->GetICatParams();
    }
    VOID Cancel()
    {
        _VERIFY(SUCCEEDED(SetListResolveStatus(
            HRESULT_FROM_WIN32(ERROR_CANCELLED))));
    }
    VOID IncPendingLookups()
    {
        InterlockedIncrement((PLONG)&m_dwcPendingLookups);
    }
    VOID DecrPendingLookups()
    {
        if(InterlockedDecrement((PLONG)&m_dwcPendingLookups) == 0) {
            //
            // The list resolve is finished
            //
            CompleteMessageCategorization();
        }
    }
    VOID GetStoreInsertionContext()
    {
        GetEmailIDStore()->GetInsertionContext(GetResolveListContext());
    }
    VOID ReleaseStoreInsertionContext()
    {
        GetEmailIDStore()->ReleaseInsertionContext(GetResolveListContext());
    }
    HRESULT HrInsertInsertionRequest(
        CInsertionRequest *pCInsertionRequest)
    {
        if(FAILED(m_hrListResolveStatus))
            return m_hrListResolveStatus;
        else 
            return GetEmailIDStore()->InsertInsertionRequest(
                GetResolveListContext(),
                pCInsertionRequest);
    }

    HRESULT HrLookupEntryAsync(
        CCatAddr *pCCatAddr)
    {
        if(FAILED(m_hrListResolveStatus))
            return m_hrListResolveStatus;
        else
            return GetEmailIDStore()->LookupEntryAsync(
                pCCatAddr,
                GetResolveListContext());
    }
    PCATPERFBLOCK GetPerfBlock()
    {
        return GetCCategorizer()->GetPerfBlock();
    }
    VOID FinalRelease()
    {
        //
        // Call FinalRelease on CICategorizerMailMsgs to release all
        // mailmsg references
        //
        m_CICategorizerMailMsgs.FinalRelease();
        //
        // Release CCategorizer after releasing all mailmsg references
        //
        m_pCCat->Release();
        //
        // Delete this object
        //
        delete this;
    }

  private:
    DWORD m_Signature;
    LONG  m_lRef;
    CCategorizer *m_pCCat;
    RESOLVE_LIST_CONTEXT m_rlc;
    HRESULT m_hrListResolveStatus;
    PFNCAT_COMPLETION m_pfnCatCompletion;
    LPVOID m_pCompletionContext;
    BOOL m_fSenderResolved;
    BOOL m_fResolvingSender;
    LIST_ENTRY m_li;
    LIST_ENTRY m_listhead_recipients;
    SPIN_LOCK  m_spinlock;
    DWORD m_dwcPendingLookups;
    CICategorizerMailMsgsIMP m_CICategorizerMailMsgs;
    CSinkInsertionRequest m_CSinkInsertionRequest;
    CTopLevelInsertionRequest m_CTopLevelInsertionRequest;

    friend class CCategorizer;
    friend class CCatAddr;
    friend class CIMsgSenderAddr;
    friend class CIMsgRecipListAddr;
    friend class CCatSender;
    friend class CCatRecip;
    friend class CCatDLRecip;
    friend class CICategorizerMailMsgsIMP;
    friend class CSinkInsertionRequest;
    friend class CTopLevelInsertionRequest;
    friend VOID AsyncIMsgCatCompletion(VOID *pContext);
};

//
// class CICategorizerDLListResolveIMP
//  similar to CICategorizerListResolve with Alloc overrided to use
//  CCatDLRecip instead of CCatRecip and additional support for
//  resolving DL's included
//
class CICategorizerDLListResolveIMP :
    public CICategorizerListResolveIMP,
    public CCatDLO<CICategorizerDLListResolveIMP_didx>
{
  public:
    STDMETHOD(AllocICategorizerItem)(
        IN   eSourceType Sourcetype,
        OUT  ICategorizerItem **ppICatItem);

  private:
    CICategorizerDLListResolveIMP(
        CCategorizer *pCCat,
        PFNCAT_COMPLETION pfnCatCompletion,
        PVOID pContext);

    HRESULT Initialize(
        IUnknown *pMsg,
        BOOL fExpandAll = TRUE,
        PBOOL pfMatch = NULL,
        CAT_ADDRESS_TYPE CAType = CAT_UNKNOWNTYPE,
        LPSTR pszAddress = NULL);

    virtual ~CICategorizerDLListResolveIMP();

  private:
    //
    // Methods from CCatDLRecip
    //
    HRESULT HrContinueResolve();

    HRESULT HrNotifyAddress(
        DWORD dwNumAddresses,
        CAT_ADDRESS_TYPE *rgCAType,
        LPSTR *rgpszAddress);

    DWORD GetCatFlags()
    {
        //
        // We don't want to resolve senders, so mask off this bit
        //
        return (CICategorizerListResolveIMP::GetCatFlags() &
                ~(SMTPDSFLAG_RESOLVESENDER));
    }

  private:
    BOOL    m_fExpandAll;
    CAT_ADDRESS_TYPE m_CAType;
    LPSTR   m_pszAddress;
    LPWSTR  m_pwszUTF8DN;
    PBOOL   m_pfMatch;

    friend class CCategorizer;
    friend class CCatAddr;
    friend class CIMsgSenderAddr;
    friend class CIMsgRecipListAddr;
    friend class CCatSender;
    friend class CCatRecip;
    friend class CCatDLRecip;

};

inline DWORD CSinkInsertionRequest::AddRef()
{
    return m_pCICatListResolve->AddRef();
}
inline DWORD CSinkInsertionRequest::Release()
{
    return m_pCICatListResolve->Release();
}
inline DWORD CTopLevelInsertionRequest::AddRef()
{
    return m_pCICatListResolve->AddRef();
}
inline DWORD CTopLevelInsertionRequest::Release()
{
    return m_pCICatListResolve->Release();
}
inline PCATPERFBLOCK CTopLevelInsertionRequest::GetPerfBlock()
{
    return m_pCICatListResolve->GetPerfBlock();
}

#endif //__ICATLISTRESOLVE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccatsender.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccatsender.h
//
// Contents: Class definitions for CIMsgSenderAddr/CCatSender
//
// Classes:
//   CIMsgSenderAddr
//   CCatSender
//
// Functions:
//
// History:
// jstamerj 980324 19:24:06: Created.
//
//-------------------------------------------------------------

#ifndef __CCATSENDER_H__
#define __CCATSENDER_H__

#include "ccataddr.h"

#define CAT_NULL_SENDER_ADDRESS_SMTP  "<>"

//
// CIMsgSenderAddr, abstract class
//   class to define how a user's properties are stored and retreived
//
class CIMsgSenderAddr : public CCatAddr
{
  public:
    CIMsgSenderAddr(CICategorizerListResolveIMP *pCICatListResolve);
    virtual ~CIMsgSenderAddr() {}

    //
    // Storage and retreival procedures
    //
    HRESULT HrGetOrigAddress(LPTSTR psz, DWORD dwcc, CAT_ADDRESS_TYPE *pType);
    HRESULT GetSpecificOrigAddress(CAT_ADDRESS_TYPE CAType, LPTSTR psz, DWORD dwcc);
    HRESULT HrAddAddresses(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPTSTR *rgpsz);

  private:
    //
    // Inline methods to retrieve ICategorizerItem Props
    //
    HRESULT GetIMailMsgProperties(IMailMsgProperties **ppIMailMsgProperties)
    {
        return CICategorizerItemIMP::GetIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            ppIMailMsgProperties);
    }

    DWORD PropIdFromCAType(CAT_ADDRESS_TYPE CAType)
    {
        switch(CAType) {
         case CAT_SMTP:
             return IMMPID_MP_SENDER_ADDRESS_SMTP;
         case CAT_X500:
         case CAT_DN:
             return IMMPID_MP_SENDER_ADDRESS_X500;
         case CAT_X400:
             return IMMPID_MP_SENDER_ADDRESS_X400;
         case CAT_LEGACYEXDN:
             return IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN;
         case CAT_CUSTOMTYPE:
             return IMMPID_MP_SENDER_ADDRESS_OTHER;
             break;
         default:
             _ASSERT(0 && "Unknown address type");
             break;
        }
        return 0;
    }
};

//
// CCatSender : public CIMsgSenderAddr
//
class CCatSender :
    public CIMsgSenderAddr,
    public CCatDLO<CCatSender_didx>
{
 public:
    CCatSender(CICategorizerListResolveIMP *pCICatListResolve);
    virtual ~CCatSender() {}

    //
    // Catch the call to dispatch query to the store
    //
    HRESULT HrDispatchQuery();

    //
    // Completion routines
    //
    VOID LookupCompletion();

    HRESULT HrExpandItem_Default(
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext);

    HRESULT HrCompleteItem_Default();

    //
    // Property setting routines
    //
    HRESULT AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR szForwardingAddress);
    HRESULT AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress);
    HRESULT AddDynamicDLMember(
        ICategorizerItemAttributes *pICatItemAttr);

    HRESULT HrNeedsResolveing();

};
    


#endif // __CCATSENDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ccatrecip.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccatrecip.h
//
// Contents: Class definitions for CIMsgRecipListAddr/CCatRecip
//
// Classes:
//   CIMsgRecipListAddr
//   CCatRecip
//   CCatExpandableRecip
//   CCatDLRecip
//
// Functions:
//
// History:
// jstamerj 980324 19:17:48: Created.
//
//-------------------------------------------------------------

#ifndef __CCATRECIP_H__
#define __CCATRECIP_H__

#include "ccataddr.h"
#include "icatlistresolve.h"
#include <caterr.h>


//
// CIMsgRecipListAddr, abstract class
//   class to define methods for user property storage and retreival
//
class CIMsgRecipListAddr : public CCatAddr
{
  public:
    CIMsgRecipListAddr(CICategorizerListResolveIMP *pCICatListResolve);
    virtual ~CIMsgRecipListAddr();

    //
    // Storage and retreival procedures
    //
    HRESULT GetSpecificOrigAddress(CAT_ADDRESS_TYPE CAType, LPTSTR psz, DWORD dwcc);
    virtual HRESULT HrAddAddresses(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPTSTR *rgpsz);
    HRESULT GetICategorizerItem(ICategorizerItem **ppICatItem);
    HRESULT GetICategorizerMailMsgs(ICategorizerMailMsgs *ppICatMsgs);

  protected:
    HRESULT CreateNewCatAddr(
        CAT_ADDRESS_TYPE CAType,
        LPTSTR pszAddress,
        CCatAddr **ppCCatAddr,
        BOOL   fPrimary = FALSE);
    HRESULT SetUnresolved(HRESULT hrReason);
    HRESULT SetDontDeliver(BOOL fDontDeliver);
    HRESULT RemoveFromDuplicateRejectionScheme(BOOL fRemove);

    HRESULT HrSetDisplayNameProp(LPWSTR pwszDisplayName);

    // Helper routines for checking loops
    HRESULT CheckForLoop(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPSTR *rgpsz, BOOL fCheckSelf);
    HRESULT CheckForLoop(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress, BOOL fCheckSelf);

    // Raise an event log for NDRing this recipient
    VOID LogNDREvent(HRESULT hrNDRReason);


    HRESULT PutICategorizerItemParent(ICategorizerItem *pItemParent,
                                      ICategorizerItem *pItem)
    {
        return pItem->PutICategorizerItem(
            ICATEGORIZERITEM_PARENT,
            pItemParent);
    }

  protected:
    HRESULT GetIMailMsgProperties(IMailMsgProperties **ppIMailMsgProps)
    {
        return CICategorizerItemIMP::GetIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            ppIMailMsgProps);
    }
    HRESULT GetIMailMsgRecipientsAdd(IMailMsgRecipientsAdd **ppRecipientsAdd)
    {
        return CICategorizerItemIMP::GetIMailMsgRecipientsAdd(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADD,
            ppRecipientsAdd);
    }
    HRESULT GetIMailMsgRecipientsAddIndex(DWORD *pdwIndex)
    {
        return GetDWORD(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADDINDEX,
            pdwIndex);
    }
    HRESULT GetFPrimary(BOOL *pfPrimary)
    {
        return GetBool(
            ICATEGORIZERITEM_FPRIMARY,
            pfPrimary);
    }
    HRESULT PutIMailMsgProperties(IMailMsgProperties *pIMailMsgProps,
                                  ICategorizerItem *pItem)
    {
        return pItem->PutIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            pIMailMsgProps);
    }
    HRESULT PutIMailMsgRecipientsAdd(IMailMsgRecipientsAdd *pRecipientsAdd,
                                     ICategorizerItem *pItem)
    {
        return pItem->PutIMailMsgRecipientsAdd(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADD,
            pRecipientsAdd);
    }
    HRESULT PutIMailMsgRecipientsAddIndex(DWORD dwIndex, ICategorizerItem *pItem)
    {
        return pItem->PutDWORD(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADDINDEX,
            dwIndex);
    }
    HRESULT PutDWLevel(DWORD dwLevel, ICategorizerItem *pItem)
    {
        return pItem->PutDWORD(
            ICATEGORIZERITEM_DWLEVEL,
            dwLevel);
    }
    HRESULT PutFPrimary(BOOL fPrimary, ICategorizerItem *pItem)
    {
        return pItem->PutBool(
            ICATEGORIZERITEM_FPRIMARY,
            fPrimary);
    }
    //
    // Return the recipent level or -1 if not set
    //
    DWORD DWLevel()
    {
        HRESULT hr;
        DWORD dwLevel;
        hr = GetDWORD(
            ICATEGORIZERITEM_DWLEVEL,
            &dwLevel);

        return SUCCEEDED(hr) ? dwLevel : (DWORD)-1;
    }

    HRESULT GetIMsgRecipInfo(
        IMailMsgRecipientsAdd **ppRecipientsAdd,
        DWORD *pdwIndex,
        BOOL *pfPrimary,
        IMailMsgProperties **ppIMailMsgProps)
    {
        HRESULT hr = S_OK;

        //
        // Initialize interface pointers to NULL
        //
        if(ppRecipientsAdd)
            *ppRecipientsAdd = NULL;
        if(ppIMailMsgProps)
            *ppIMailMsgProps = NULL;

        if(pfPrimary) {
            hr = GetFPrimary(pfPrimary);
            if(FAILED(hr))
                goto CLEANUP;
        }
        if(pdwIndex) {
            hr = GetIMailMsgRecipientsAddIndex(pdwIndex);
            if(FAILED(hr))
                goto CLEANUP;
        }

        if(ppRecipientsAdd) {
            hr = GetIMailMsgRecipientsAdd(ppRecipientsAdd);
            if(FAILED(hr))
                goto CLEANUP;
        }

        if(ppIMailMsgProps) {
            hr = GetIMailMsgProperties(ppIMailMsgProps);
            if(FAILED(hr))
                goto CLEANUP;
        }

     CLEANUP:
        if(FAILED(hr)) {
            if(ppRecipientsAdd && (*ppRecipientsAdd)) {
                (*ppRecipientsAdd)->Release();
                *ppRecipientsAdd = NULL;
            }
            if(ppIMailMsgProps && (*ppIMailMsgProps)) {
                (*ppIMailMsgProps)->Release();
                *ppIMailMsgProps = NULL;
            }
        }
        return hr;
    }

    HRESULT PutIMsgRecipInfo(
        IMailMsgRecipientsAdd **ppRecipientsAdd,
        DWORD *pdwIndex,
        BOOL *pfPrimary,
        IMailMsgProperties **ppIMailMsgProps,
        DWORD *pdwLevel,
        ICategorizerItem *pItem)
    {
        HRESULT hr = S_OK;
        if(pdwIndex)
            hr = PutIMailMsgRecipientsAddIndex(*pdwIndex, pItem);
        if(SUCCEEDED(hr) && pfPrimary)
            hr = PutFPrimary(*pfPrimary, pItem);
        if(SUCCEEDED(hr) && ppRecipientsAdd)
            hr = PutIMailMsgRecipientsAdd(*ppRecipientsAdd, pItem);
        if(SUCCEEDED(hr) && ppIMailMsgProps)
            hr = PutIMailMsgProperties(*ppIMailMsgProps, pItem);
        if(SUCCEEDED(hr) && pdwLevel)
            hr = PutDWLevel(*pdwLevel, pItem);

        return hr;
    }

    DWORD PropIdFromCAType(CAT_ADDRESS_TYPE CAType)
    {
        switch(CAType) {
         case CAT_SMTP:
             return IMMPID_RP_ADDRESS_SMTP;
         case CAT_X500:
         case CAT_DN:
             return IMMPID_RP_ADDRESS_X500;
         case CAT_X400:
             return IMMPID_RP_ADDRESS_X400;
         case CAT_LEGACYEXDN:
             return IMMPID_RP_LEGACY_EX_DN;
         case CAT_CUSTOMTYPE:
             return IMMPID_RP_ADDRESS_OTHER;
             break;
         default:
             _ASSERT(0 && "Unknown address type");
             break;
        }
        return 0;
    }
};

//
// CCatExpandableRecip
//  purpose: Provide DL expansion functionality
//
class CCatExpandableRecip :
    public CIMsgRecipListAddr
{
  public:
    typedef enum _DLOBJTYPE {
        DLT_NONE,
        DLT_X500,
        DLT_SMTP,
        DLT_DYNAMIC,
    } DLOBJTYPE, *PDLOBJTYPE;

    CCatExpandableRecip(CICategorizerListResolveIMP
                        *pCICatListResolve) :
        CIMsgRecipListAddr(pCICatListResolve) {}

    // Helper routing to expand DLs and forwarding addresses
    HRESULT HrAddDlMembersAndForwardingAddresses(
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext);

    HRESULT HrAddDlMembers(
        DLOBJTYPE dlt,
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext);

    static VOID DlExpansionCompletion(
        HRESULT hrStatus,
        PVOID pContext);

    HRESULT HrExpandAttribute(
        ICategorizerItemAttributes *pICatItemAttr,
        CAT_ADDRESS_TYPE CAType,
        LPSTR pszAttributeName,
        PDWORD pdwNumberMembers);

    HRESULT HrAddForwardingAddresses();

  private:
    typedef struct _tagDlCompletionContext {
        CCatExpandableRecip *pCCatAddr;
        PFN_EXPANDITEMCOMPLETION pfnCompletion;
        PVOID pContext;
    } DLCOMPLETIONCONTEXT, *PDLCOMPLETIONCONTEXT;

    PDLCOMPLETIONCONTEXT AllocDlCompletionContext(
        CCatExpandableRecip *pCCatAddr,
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext)
    {
        PDLCOMPLETIONCONTEXT pDLContext;

        pDLContext = new DLCOMPLETIONCONTEXT;
        if(pDLContext) {
            pDLContext->pCCatAddr = pCCatAddr;
            pDLContext->pfnCompletion = pfnCompletion;
            pDLContext->pContext = pContext;
        }
        return pDLContext;
    }
    friend class CMembersInsertionRequest;
};

//
// CCatRecip
//
class CCatRecip :
    public CCatExpandableRecip,
    public CCatDLO<CCatRecip_didx>
{
  public:
    //
    // Flags that indicate a recipient should be NDR'd if not found in the DS
    //
    #define LOCFS_NDR               ( LOCF_LOCALMAILBOX )

    CCatRecip(CICategorizerListResolveIMP *pCICatListResolve);
    virtual ~CCatRecip();

    //
    // lookup completion
    //
    VOID LookupCompletion();
    //
    // lookup completion only called after sender's completion
    //
    VOID RecipLookupCompletion();

    //
    // Default event sinks
    //
    HRESULT HrProcessItem_Default();
    HRESULT HrExpandItem_Default(
        PFN_EXPANDITEMCOMPLETION pfnCompletion,
        PVOID pContext);
    HRESULT HrCompleteItem_Default();

    // Property setting routines
    HRESULT AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR szForwardingAddress);
    HRESULT AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress);
    HRESULT AddDynamicDLMember(
        ICategorizerItemAttributes *pICatItemAttr);

    // Forward loop head notification
    HRESULT HandleLoopHead();

    // Catch invalid addresses
    HRESULT HrHandleInvalidAddress();

  private:
    // Helper routine of HrCompletion
    HRESULT HandleFailure(HRESULT HrFailure);

    HRESULT HrNeedsResolveing();

    HRESULT HrSetDisplayName();

    HRESULT HrNdrUnresolvedRecip(
        BOOL *pfNDR)
    {
        DWORD dw;

        dw = DwGetOrigAddressLocFlags();
        if(dw == LOCF_UNKNOWN) {
            //
            // Assume we couldn't get locality flags because of an
            // illegal address
            //
            return CAT_E_ILLEGAL_ADDRESS;
        }
        *pfNDR = (dw & LOCFS_NDR) ? TRUE : FALSE;
        return S_OK;
    }

  private:
    //
    // List entry used for deferring recip completion processing until
    // the sender is resolved
    //
    LIST_ENTRY m_le;

    static DWORD m_dwRecips;

    friend class CICategorizerListResolveIMP;
};

//
// CCatDLRecip -- the recip used to expand DLs only (no forwarding/alt recip/events/etc)
//
class CCatDLRecip :
    public CCatRecip,
    public CCatDLO<CCatDLRecip_didx>
{
  public:
    #define EXPANDOPT_MATCHONLY     1

    CCatDLRecip(CICategorizerDLListResolveIMP *pIListResolve);
    virtual ~CCatDLRecip();

    //
    // lookup completion
    //
    VOID LookupCompletion();

    //
    // Catch adding addresses so we can notify ICatDLListResolve
    //
    HRESULT HrAddAddresses(DWORD dwNumAddresses, CAT_ADDRESS_TYPE *rgCAType, LPTSTR *rgpsz);

    // Property setting routines
    HRESULT AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR pszForwardingAddress);
    HRESULT AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress);

    // Forward loop head notification
    HRESULT HandleLoopHead()
    {
        // Who cares about loops, we're just doing DL expansion
        return S_OK;
    }

    // Catch invalid addresses
    HRESULT HrHandleInvalidAddress()
    {
        // Who cares if we forward to an invalid address?
        return S_OK;
    }

  private:
    static VOID ExpansionCompletion(PVOID pContext);

    CICategorizerDLListResolveIMP *m_pIListResolve;
};

//
// CMembersInsertionRequest
//  -- The throttled insertion reuqest for the DL members
//
CatDebugClass(CMembersInsertionRequest),
    public CInsertionRequest
{
  public:
    HRESULT HrInsertSearches(
        DWORD dwcSearches);

    VOID NotifyDeQueue(
        HRESULT hr);

  private:
    #define SIGNATURE_CMEMBERSINSERTIONREQUEST          (DWORD)'qRIM'
    #define SIGNATURE_CMEMBERSINSERTIONREQUEST_INVALID  (DWORD)'XRIM'

    CMembersInsertionRequest(
        CCatExpandableRecip *pDLRecipAddr,
        ICategorizerUTF8Attributes *pItemAttributes,
        PATTRIBUTE_ENUMERATOR penumerator,
        CAT_ADDRESS_TYPE CAType)
    {
        m_dwSignature = SIGNATURE_CMEMBERSINSERTIONREQUEST;
        m_pDLRecipAddr = pDLRecipAddr;
        m_pDLRecipAddr->AddRef();
        m_pDLRecipAddr->IncPendingLookups();
        CopyMemory(&m_enumerator, penumerator, sizeof(ATTRIBUTE_ENUMERATOR));
        m_CAType = CAType;
        m_hr = S_OK;
        m_pUTF8Attributes = pItemAttributes;
        m_pUTF8Attributes->AddRef();

    }
    ~CMembersInsertionRequest()
    {
        m_pUTF8Attributes->EndUTF8AttributeEnumeration(
            &m_enumerator);
        m_pUTF8Attributes->Release();

        m_pDLRecipAddr->DecrPendingLookups();
        m_pDLRecipAddr->Release();

        _ASSERT(m_dwSignature == SIGNATURE_CMEMBERSINSERTIONREQUEST);
        m_dwSignature = SIGNATURE_CMEMBERSINSERTIONREQUEST_INVALID;
    }

    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pDLRecipAddr->GetISMTPServerEx();
    }

  private:
    DWORD m_dwSignature;
    CCatExpandableRecip *m_pDLRecipAddr;
    ICategorizerUTF8Attributes *m_pUTF8Attributes;
    ATTRIBUTE_ENUMERATOR m_enumerator;
    CAT_ADDRESS_TYPE m_CAType;
    HRESULT m_hr;

    friend class CCatExpandableRecip;
};

#endif // __CCATRECIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatparam.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatdsparam.h
//
// Contents: NT5's implementation of ICategorizerParameters
//
// Classes:
//   CICategorizerParametersIMP
//   CICategorizerRequestedAttributesIMP
//
// Functions:
//
// History:
// jstamerj 980611 16:16:46: Created.
//
//-------------------------------------------------------------
#include "smtpevent.h"
#include "caterr.h"
#include <rwex.h>

#define SIGNATURE_CICategorizerParametersIMP  ((DWORD)'ICPI')
#define SIGNATURE_CICategorizerParametersIMP_Invalid ((DWORD)'XCPI')

#define DSPARAMETERS_DEFAULT_ATTR_ARRAY_SIZE    25

class CICategorizerRequestedAttributesIMP;

CatDebugClass(CICategorizerParametersIMP),
    public ICategorizerParametersEx
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ICategorizerParametersEx
    STDMETHOD(GetDSParameterA)(
        IN   DWORD dwDSParameter,
        OUT  LPSTR *ppszValue);

    STDMETHOD(GetDSParameterW)(
        IN   DWORD dwDSParameter,
        OUT  LPWSTR *ppszValue);

    STDMETHOD(SetDSParameterA)(
        IN   DWORD dwDSParameter,
        IN   LPCSTR pszValue);

    STDMETHOD(RequestAttributeA)(
        IN   LPCSTR pszName);

    STDMETHOD(GetAllAttributes)(
        OUT  LPSTR **prgszAllAttributes)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(ReserveICatItemPropIds)(
        IN   DWORD   dwNumPropIdsRequested,
        OUT  DWORD *pdwBeginningPropId);

    STDMETHOD(ReserveICatListResolvePropIds)(
        IN   DWORD   dwNumPropIdsRequested,
        OUT  DWORD *pdwBeginningPropId);

    STDMETHOD(GetCCatConfigInfo)(
        OUT  PCCATCONFIGINFO *ppCCatConfigInfo);

    STDMETHOD(GetRequestedAttributes)(
        OUT  ICategorizerRequestedAttributes **ppIRequestedAttributes);

    STDMETHOD(RegisterCatLdapConfigInterface)(
        IN   ICategorizerLdapConfig *pICatLdapConfigInfo);

    STDMETHOD(GetLdapConfigInterface)(
        OUT  ICategorizerLdapConfig **ppICatLdapConfigInfo);

  private:

    CICategorizerParametersIMP(
        PCCATCONFIGINFO pCCatConfigInfo,
        DWORD dwInitialICatItemProps,
        DWORD dwInitialICatListResolveProps,
        ISMTPServerEx *pISMTPServerEx);

    ~CICategorizerParametersIMP();

    VOID SetReadOnly(BOOL fReadOnly) { m_fReadOnly = fReadOnly; }

    DWORD GetNumPropIds_ICatItem() { return m_dwCurPropId_ICatItem; }
    DWORD GetNumPropIds_ICatListResolve() { return m_dwCurPropId_ICatListResolve; }

    ISMTPServerEx * GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }

  private:
    DWORD m_dwSignature;
    ULONG m_cRef;

    BOOL  m_fReadOnly;
    CICategorizerRequestedAttributesIMP *m_pCIRequestedAttributes;

    DWORD m_dwCurPropId_ICatItem;
    DWORD m_dwCurPropId_ICatListResolve;
    LPSTR m_rgszDSParameters[PHAT_DSPARAMETER_ENDENUMMESS];
    LPWSTR m_rgwszDSParameters[PHAT_DSPARAMETER_ENDENUMMESS];
    PCCATCONFIGINFO m_pCCatConfigInfo;
    CExShareLock m_sharelock;
    ICategorizerLdapConfig *m_pICatLdapConfigInfo;
    ISMTPServerEx *m_pISMTPServerEx;

    friend class CCategorizer;
};


CatDebugClass(CICategorizerRequestedAttributesIMP),
    public ICategorizerRequestedAttributes
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ()
    {
        return InterlockedIncrement((PLONG)&m_ulRef);
    }
    STDMETHOD_(ULONG, Release) ()
    {
        ULONG ulRet;
        ulRet = InterlockedDecrement((PLONG)&m_ulRef);
        if(ulRet == 0)
            delete this;
        return ulRet;
    }

  public:
    //ICategorizerRequestedAttributes
    STDMETHOD (GetAllAttributes) (
        OUT LPSTR **prgszAllAttributes);

    STDMETHOD (GetAllAttributesW) (
        OUT LPWSTR **prgszAllAttributes);

  private:
    CICategorizerRequestedAttributesIMP(ISMTPServerEx *pISMTPServerEx);
    ~CICategorizerRequestedAttributesIMP();

    HRESULT ReAllocArrayIfNecessary(LONG lNewAttributeCount);
    HRESULT AddAttribute(LPCSTR pszAttribute);
    HRESULT FindAttribute(LPCSTR pszAttribute);
    ULONG   GetReferenceCount()
    {
        return m_ulRef;
    }

    ISMTPServerEx * GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }

  private:
    #define SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP         (DWORD)'ICRA'
    #define SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP_INVALID (DWORD)'XCRA'
    DWORD m_dwSignature;
    LONG  m_ulRef;
    LONG  m_lAttributeArraySize;
    LPSTR  *m_rgszAttributeArray;
    LPWSTR *m_rgwszAttributeArray;
    LONG  m_lNumberAttributes;
    ISMTPServerEx *m_pISMTPServerEx;

    friend class CICategorizerParametersIMP;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatmailmsgs.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatmailmsgs.h
//
// Contents: Implementation of ICategorizerMailMsgs
//
// Classes: CICategorizerMailMsgsIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/30 13:21:41: Created.
//
//-------------------------------------------------------------
#ifndef _ICATMAILMSGS_H_
#define _ICATMAILMSGS_H_


#include "mailmsg.h"
#include "smtpevent.h"
#include "cattype.h"
#include <listmacr.h>
#include "mailmsgprops.h"
#include "catperf.h"

#define ICATEGORIZERMAILMSGS_DEFAULTIMSGID  0

#define SIGNATURE_CICATEGORIZERMAILMSGSIMP          (DWORD)'ICMM'
#define SIGNATURE_CICATEGORIZERMAILMSGSIMP_INVALID  (DWORD)'XCMM'


class CICategorizerMailMsgsIMP : public ICategorizerMailMsgs
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv) {
        return m_pIUnknown->QueryInterface(iid, ppv);
    }
    STDMETHOD_(ULONG, AddRef) () { return m_pIUnknown->AddRef(); }
    STDMETHOD_(ULONG, Release) () { return m_pIUnknown->Release(); }

  public:
    //ICategorizerMailMsgs
    STDMETHOD (GetMailMsg) (
        IN  DWORD dwId,
        OUT IMailMsgProperties **ppIMailMsgProperties,
        OUT IMailMsgRecipientsAdd **ppIMailMsgRecipientsAdd,
        OUT BOOL *pfCreated);

    STDMETHOD (ReBindMailMsg) (
        IN  DWORD dwFlags,
        IN  IUnknown *pStoreDriver);

    STDMETHOD (BeginMailMsgEnumeration) (
        IN  PCATMAILMSG_ENUMERATOR penumerator);

    STDMETHOD (GetNextMailMsg) (
        IN  PCATMAILMSG_ENUMERATOR penumerator,
        OUT DWORD *pdwFlags,
        OUT IMailMsgProperties **ppIMailMsgProperties,
        OUT IMailMsgRecipientsAdd **ppIMailMsgRecipientsAdd);

    STDMETHOD (EndMailMsgEnumeration) (
        IN  PCATMAILMSG_ENUMERATOR penumerator)
    {
        //
        // Nothing to do...
        //
        return S_OK;
    }

  private:
    // Internal types
    typedef struct _tagIMsgEntry {
        LIST_ENTRY              listentry;
        DWORD                   dwId;
        IUnknown                *pIUnknown;
        IMailMsgProperties      *pIMailMsgProperties;
        IMailMsgRecipients      *pIMailMsgRecipients;
        IMailMsgRecipientsAdd   *pIMailMsgRecipientsAdd;
        BOOL                    fBoundToStore;
    } IMSGENTRY, *PIMSGENTRY;

  private:
    // Internal categorizer functions
    CICategorizerMailMsgsIMP(
        CICategorizerListResolveIMP *pCICatListResolveIMP);
    ~CICategorizerMailMsgsIMP();

    HRESULT Initialize(
        IUnknown *pIMsg);

    HRESULT CreateIMsgEntry(
        PIMSGENTRY *ppIE,
        IUnknown *pIUnknown = NULL,
        IMailMsgProperties *pIMailMsgProperties = NULL,
        IMailMsgRecipients *pIMailMsgRecipients = NULL,
        IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd = NULL,
        BOOL fBoundToStore = FALSE);

    HRESULT CreateAddIMsgEntry(
        DWORD dwId,
        IUnknown *pIUnknown = NULL,
        IMailMsgProperties *pIMailMsgProperties = NULL,
        IMailMsgRecipients *pIMailMsgRecipients = NULL,
        IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd = NULL,
        BOOL fBoundToStore = FALSE);

    HRESULT GetNumIMsgs() { return m_dwNumIMsgs; }

    HRESULT WriteListAll();
    HRESULT RevertAll();
    VOID    DeleteBifurcatedMessages();
    HRESULT GetAllIUnknowns(
        IUnknown **rgpIMsgs,
        DWORD cPtrs);

    HRESULT SetMsgStatusAll(
        DWORD dwMsgStatus);

    HRESULT HrPrepareForCompletion();

    IUnknown * GetDefaultIUnknown();
    IMailMsgProperties * GetDefaultIMailMsgProperties();
    IMailMsgRecipients * GetDefaultIMailMsgRecipients();
    IMailMsgRecipientsAdd * GetDefaultIMailMsgRecipientsAdd();

    PIMSGENTRY FindIMsgEntry(
        DWORD dwId);

    PCATPERFBLOCK GetPerfBlock();

    VOID FinalRelease();

    ISMTPServerEx * GetISMTPServerEx();

  private:
    // Data
    DWORD m_dwSignature;

    // A count of the number of elements in the list
    DWORD m_dwNumIMsgs;

    // A list of IMSGENTRY structs
    LIST_ENTRY m_listhead;

    // Back pointer to use for QI/AddRef/Release
    IUnknown *m_pIUnknown;
    CICategorizerListResolveIMP *m_pCICatListResolveIMP;

    CRITICAL_SECTION m_cs;
    
    friend class CICategorizerListResolveIMP;
};

#endif // _ICATMAILMSGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\icatprops.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatprops.h
//
// Contents: Implementation of ICategorizerProperties
//
// Classes: CCategorizerItemIMP
//
// Functions:
//
// History:
// jstamerj 1998/11/11 18:50:28: Created
//
//-------------------------------------------------------------
#ifndef __ICATPROPS_H__
#define __ICATPROPS_H__

#include <windows.h>
#include <dbgtrace.h>
#include <smtpevent.h>

#define CICATEGORIZERPROPSIMP_SIGNATURE (DWORD)'ICPR'
#define CICATEGORIZERPROPSIMP_SIGNATURE_FREE (DWORD)'XCPR'


class CICategorizerPropertiesIMP : 
    public ICategorizerProperties
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv) {
        return m_pIUnknown->QueryInterface(iid, ppv);
    }
    STDMETHOD_(ULONG, AddRef) () { return m_pIUnknown->AddRef(); }
    STDMETHOD_(ULONG, Release) () { return m_pIUnknown->Release(); }

  public:
    //ICategorizerProperties
    STDMETHOD (GetStringA) (
        DWORD dwPropId, 
        DWORD cch, 
        LPSTR pszValue);
    STDMETHOD (PutStringA) (
        DWORD dwPropId,
        LPSTR pszValue);
    STDMETHOD (GetDWORD) (
        DWORD dwPropId,
        DWORD *pdwValue);
    STDMETHOD (PutDWORD) (
        DWORD dwPropId,
        DWORD dwValue);
    STDMETHOD (GetHRESULT) (
        DWORD dwPropId,
        HRESULT *phrValue);
    STDMETHOD (PutHRESULT) (
        DWORD dwPropId,
        HRESULT hrValue);
    STDMETHOD (GetBool) (
        DWORD dwPropId,
        BOOL  *pfValue);
    STDMETHOD (PutBool) (
        DWORD dwPropId,
        BOOL  fValue);
    STDMETHOD (GetPVoid) (
        DWORD dwPropId,
        PVOID *ppv);
    STDMETHOD (PutPVoid) (
        DWORD dwPropId,
        PVOID pvValue);
    STDMETHOD (GetIUnknown) (
        DWORD dwPropId,
        IUnknown **ppUnknown);
    STDMETHOD (PutIUnknown) (
        DWORD dwPropId,
        IUnknown *pUnknown);
    STDMETHOD (GetIMailMsgProperties) (
        DWORD dwPropId,
        IMailMsgProperties **ppIMailMsgProperties);
    STDMETHOD (PutIMailMsgProperties) (
        DWORD dwPropId,
        IMailMsgProperties *ppIMailMsgProperties);
    STDMETHOD (GetIMailMsgRecipientsAdd) (
        DWORD dwPropId,
        IMailMsgRecipientsAdd **ppIMsgRecipientsAdd);
    STDMETHOD (PutIMailMsgRecipientsAdd) (
        DWORD dwPropId,
        IMailMsgRecipientsAdd *pIMsgRecipientsAdd);
    STDMETHOD (GetICategorizerItemAttributes) (
        DWORD dwPropId,
        ICategorizerItemAttributes **ppICategorizerItemAttributes);
    STDMETHOD (PutICategorizerItemAttributes) (
        DWORD dwPropId,
        ICategorizerItemAttributes *pICategorizerItemAttributes);
    STDMETHOD (GetICategorizerListResolve) (
        DWORD dwPropId,
        ICategorizerListResolve **ppICategorizerListResolve);
    STDMETHOD (PutICategorizerListResolve) (
        DWORD dwPropId,
        ICategorizerListResolve *pICategorizerListResolve);
    STDMETHOD (GetICategorizerMailMsgs) (
        DWORD dwPropId,
        ICategorizerMailMsgs **ppICategorizerMailMsgs);
    STDMETHOD (PutICategorizerMailMsgs) (
        DWORD dwPropId,
        ICategorizerMailMsgs *pICategorizerMailMsgs);
    STDMETHOD (GetICategorizerItem) (
        DWORD dwPropId,
        ICategorizerItem **ppICategorizerItem);
    STDMETHOD (PutICategorizerItem) (
        DWORD dwPropId,
        ICategorizerItem *pICategorizerItem);
    STDMETHOD (UnSetPropId) (
        DWORD dwPropId);

  public:
    DWORD NumProps() {return m_dwNumPropIds;}
    HRESULT GetStringAPtr(
        DWORD dwPropId,
        LPSTR *ppsz);

  private:
    CICategorizerPropertiesIMP(IUnknown *pIUnknown);
    virtual ~CICategorizerPropertiesIMP();

    void * operator new(size_t size, DWORD dwNumProps);

    HRESULT Initialize();
    LPSTR m_strdup(LPSTR psz);

    typedef enum _PropStatus {
        PROPSTATUS_UNSET = 0,
        PROPSTATUS_SET_DWORD,
        PROPSTATUS_SET_HRESULT,
        PROPSTATUS_SET_BOOL,
        PROPSTATUS_SET_PVOID,
        PROPSTATUS_SET_STRINGA,
        PROPSTATUS_SET_IUNKNOWN,
        PROPSTATUS_SET_IMAILMSGPROPERTIES,
        PROPSTATUS_SET_IMAILMSGRECIPIENTSADD,
        PROPSTATUS_SET_ICATEGORIZERITEMATTRIBUTES,
        PROPSTATUS_SET_ICATEGORIZERLISTRESOLVE,
        PROPSTATUS_SET_ICATEGORIZERMAILMSGS,
        PROPSTATUS_SET_ICATEGORIZERITEM
    } PROPSTATUS, *PPROPSTATUS;

    typedef struct _tagProp {
        PROPSTATUS PropStatus;
        union _tag_PropValue {
            LPSTR  pszValue;
            DWORD  dwValue;
            BOOL   fValue;
            PVOID  pvValue;
            IUnknown *pIUnknownValue;
            IMailMsgProperties *pIMailMsgPropertiesValue;
            IMailMsgRecipientsAdd *pIMailMsgRecipientsAddValue;
            ICategorizerItemAttributes *pICategorizerItemAttributesValue;
            ICategorizerListResolve *pICategorizerListResolveValue;
            ICategorizerMailMsgs *pICategorizerMailMsgsValue;
            ICategorizerItem *pICategorizerItemValue;
        } PropValue;
    } PROPERTY, *PPROPERTY;

    DWORD m_dwSignature;
    IUnknown *m_pIUnknown;
    DWORD m_dwNumPropIds;
    PPROPERTY m_rgProperties;

    friend class CCategorizer;
    friend class CICategorizerItemIMP;
    friend class CICategorizerListResolveIMP;
    friend class CICategorizerDLListResolveIMP;
};

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::m_strdup
//
// Synopsis: Allocates and copies a string
//
// Arguments:
//   psz: String to copy
//
// Returns:
//   Address of allocated string buffer, or NULL if out of memory
//  
// History:
// jstamerj 1998/06/20 19:07:12: Created.
//
//-------------------------------------------------------------
inline LPSTR CICategorizerPropertiesIMP::m_strdup(
    LPSTR psz)
{
    _ASSERT(psz);

    LPSTR pszNew;
    pszNew = new CHAR[lstrlen(psz)+1];
    if(pszNew) {
        lstrcpy(pszNew, psz);
    }
    return pszNew;
}

#endif //__ICATPROPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\spinlock.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: spinlock.h
//
// Contents: Spinlock package
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 980511 17:25:05: Created.
//
//-------------------------------------------------------------
#include <windows.h>

//
// Simple spinlock package used by CLdapConnection
//

typedef LONG SPIN_LOCK;
typedef LPLONG PSPIN_LOCK;

typedef VOID (__stdcall *PFN_ACQUIRESPINLOCK)(PSPIN_LOCK);

extern PFN_ACQUIRESPINLOCK g_AcquireSpinLock;

VOID InitializeSpinLock(
    PSPIN_LOCK psl);

#define AcquireSpinLock (*g_AcquireSpinLock)

VOID AcquireSpinLockSingleProc(
    PSPIN_LOCK psl);
VOID AcquireSpinLockMultipleProc(
    PSPIN_LOCK psl);
VOID ReleaseSpinLock(
    PSPIN_LOCK psl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\ldapstr.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       ldapstr.h
//
//  Contents:   Until LDAP Schema issues can be hammered out, we store all
//              LDAP related strings in this central file.
//
//  Classes:
//
//  Functions:
//
//  History:    January 24, 1997    Milan Shah (milans)
//              August 13, 2001     Daniel Longley (dlongley)
//
//-----------------------------------------------------------------------------

#ifndef _LDAPSTR_H_
#define _LDAPSTR_H_

#include <smtpevent.h>

typedef struct _SCHEMA_CONFIG_STRING_TABLE_ENTRY {
    eDSPARAMETER DSParam;
    LPSTR        pszValue;
} SCHEMA_CONFIG_STRING_TABLE_ENTRY, * PSCHEMA_CONFIG_STRING_TABLE;

// Modified 8/13/2001 by dlongley.
//
// No setting for RDN attribute means RDN attribute name will be determined
// dynamically from DNs we process.

#define SCHEMA_CONFIG_STRING_TABLE_NT5 { \
    { DSPARAMETER_SEARCHATTRIBUTE_SMTP,   "mail"}, \
    { DSPARAMETER_SEARCHFILTER_SMTP,      "%s"}, \
    { DSPARAMETER_SEARCHFILTER_RDN,       "%s"}, \
    { DSPARAMETER_ATTRIBUTE_OBJECTCLASS,  "objectClass"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_SMTP, "mail"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_DN,   "distinguishedName"}, \
    { DSPARAMETER_ATTRIBUTE_FORWARD_SMTP, "forwardingAddress"}, \
    { DSPARAMETER_ATTRIBUTE_DL_MEMBERS,   "member"}, \
    { (eDSPARAMETER) PHAT_DSPARAMETER_ATTRIBUTE_DISPLAYNAME, "displayName"}, \
    { DSPARAMETER_OBJECTCLASS_USER,       "User"}, \
    { DSPARAMETER_OBJECTCLASS_DL_X500,    "group"}, \
    { DSPARAMETER_OBJECTCLASS_DL_SMTP,    "RFC822-Distribution-List"}, \
    { DSPARAMETER_INVALID, NULL} \
}

#define SCHEMA_REQUEST_STRINGS_NT5 { \
      "distinguishedName", \
      "forwardingAddress", \
      "objectClass", \
      "mail", \
      "member", \
      "displayName", \
      NULL \
}

#define SCHEMA_CONFIG_STRING_TABLE_EXCHANGE5 { \
    { DSPARAMETER_SEARCHATTRIBUTE_SMTP,   "mail"}, \
    { DSPARAMETER_SEARCHFILTER_SMTP,      "%s"}, \
    { DSPARAMETER_SEARCHATTRIBUTE_X400,   "textEncodedORAddress"}, \
    { DSPARAMETER_SEARCHFILTER_X400,      "%s"}, \
    { DSPARAMETER_SEARCHATTRIBUTE_RDN,    "rdn"}, \
    { DSPARAMETER_SEARCHFILTER_RDN,       "%s"}, \
    { DSPARAMETER_ATTRIBUTE_OBJECTCLASS,  "objectClass"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_SMTP, "mail"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_DN,   "distinguishedName"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_X400, "textEncodedORAddress"}, \
    { DSPARAMETER_ATTRIBUTE_FORWARD_SMTP, "ForwardingAddress"}, \
    { DSPARAMETER_ATTRIBUTE_DL_MEMBERS,   "member"}, \
    { DSPARAMETER_OBJECTCLASS_USER,       "person"}, \
    { DSPARAMETER_OBJECTCLASS_DL_X500,    "groupOfNames"}, \
    { DSPARAMETER_OBJECTCLASS_DL_SMTP,    "RFC822-Distribution-List"}, \
    { DSPARAMETER_INVALID, NULL} \
}
#define SCHEMA_REQUEST_STRINGS_EXCHANGE5 { \
      "objectClass", \
      "distinguishedName", \
      "mail", \
      "textEncodedORAddress", \
      "LegacyExchangeDN", \
      "member", \
      "ForwardingAddress", \
      NULL \
}

#define SCHEMA_CONFIG_STRING_TABLE_MCIS3 { \
    { DSPARAMETER_SEARCHATTRIBUTE_SMTP,   "mail"}, \
    { DSPARAMETER_SEARCHFILTER_SMTP,      "%s"}, \
    { DSPARAMETER_SEARCHATTRIBUTE_RDN,    "CN"}, \
    { DSPARAMETER_SEARCHFILTER_RDN,       "%s"}, \
    { DSPARAMETER_ATTRIBUTE_OBJECTCLASS,  "objectClass"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_SMTP, "mail"}, \
    { DSPARAMETER_ATTRIBUTE_DEFAULT_DN,   "distinguishedName"}, \
    { DSPARAMETER_ATTRIBUTE_FORWARD_SMTP, "ForwardingAddress"}, \
    { DSPARAMETER_ATTRIBUTE_DL_MEMBERS,   "member"}, \
    { DSPARAMETER_OBJECTCLASS_USER,       "member"}, \
    { DSPARAMETER_OBJECTCLASS_DL_X500,    "distributionList"}, \
    { DSPARAMETER_OBJECTCLASS_DL_SMTP,    "RFC822DistributionList"}, \
    { DSPARAMETER_INVALID, NULL} \
}

#define SCHEMA_REQUEST_STRINGS_MCIS3 { \
      "objectClass", \
      "distinguishedName", \
      "mail", \
      "member", \
      "ForwardingAddress", \
      NULL \
}
#endif // _LDAPSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\asyncctx.cpp ===
//
// asyncctx.cpp -- This file contains the class implementation for:
//      CAsyncLookupContext
//
// Created:
//      Mar 4, 1997 -- Milan Shah (milans)
//
// Changes:
//

#include "precomp.h"
#include "simparray.cpp"

DWORD CBatchLdapConnection::m_nMaxSearchBlockSize = 0;
DWORD CBatchLdapConnection::m_nMaxPendingSearches = 0;
DWORD CBatchLdapConnection::m_nMaxConnectionRetries = 0;

//+----------------------------------------------------------------------------
//
//  Function:   CBatchLdapConnection::InitializeFromRegistry
//
//  Synopsis:   Static function that looks at registry to determine maximum
//              number of queries that will be compressed into a single query.
//              If the registry key does not exist or there is any other
//              problem reading the key, the value defaults to
//              MAX_SEARCH_BLOCK_SIZE
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------
VOID CBatchLdapConnection::InitializeFromRegistry()
{
    HKEY hkey;
    DWORD dwErr, dwType, dwValue, cbValue;

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, MAX_SEARCH_BLOCK_SIZE_KEY, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        cbValue = sizeof(dwValue);
        dwErr = RegQueryValueEx(
                    hkey,
                    MAX_SEARCH_BLOCK_SIZE_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD &&
            dwValue > 0 && dwValue < MAX_SEARCH_BLOCK_SIZE) {

            InterlockedExchange((PLONG) &m_nMaxSearchBlockSize, (LONG)dwValue);
        }

        cbValue = sizeof(dwValue);
        dwErr = RegQueryValueEx(
                    hkey,
                    MAX_PENDING_SEARCHES_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD &&
            dwValue > 0) {

            InterlockedExchange((PLONG) &m_nMaxPendingSearches, (LONG)dwValue);
        }

        cbValue = sizeof(dwValue);
        dwErr = RegQueryValueEx(
                    hkey,
                    MAX_CONNECTION_RETRIES_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD &&
            dwValue > 0) {

            InterlockedExchange((PLONG) &m_nMaxConnectionRetries, (LONG)dwValue);
        }

        RegCloseKey( hkey );
    }
    if(m_nMaxSearchBlockSize == 0)
        m_nMaxSearchBlockSize = MAX_SEARCH_BLOCK_SIZE;
    if(m_nMaxPendingSearches == 0)
        m_nMaxPendingSearches = MAX_PENDING_SEARCHES;
    if(m_nMaxPendingSearches < m_nMaxSearchBlockSize)
        m_nMaxPendingSearches = m_nMaxSearchBlockSize;
    if(m_nMaxConnectionRetries == 0)
        m_nMaxConnectionRetries = MAX_CONNECTION_RETRIES;
}

//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::operator new
//
// Synopsis: Allocate enough memory for this and the specified number
// of SEARCH_REQUEST structurers
//
// Arguments:
//  size: Normal size of object
//  dwNumRequests: Number of props desired in this object
//
// Returns: ptr to allocated memory or NULL
//
// History:
// jstamerj 1999/03/10 16:15:43: Created
//
//-------------------------------------------------------------
void * CSearchRequestBlock::operator new(
    size_t size,
    DWORD dwNumRequests)
{
    DWORD dwSize;
    void  *pmem;
    CSearchRequestBlock *pBlock;

    //
    // Calcualte size in bytes required
    //
    dwSize = size +
             (dwNumRequests*sizeof(SEARCH_REQUEST)) +
             (dwNumRequests*sizeof(ICategorizerItem *));

    pmem = new BYTE[dwSize];

    if(pmem) {

        pBlock = (CSearchRequestBlock *)pmem;
        pBlock->m_dwSignature = SIGNATURE_CSEARCHREQUESTBLOCK;
        pBlock->m_cBlockSize = dwNumRequests;

        pBlock->m_prgSearchRequests = (PSEARCH_REQUEST)
                                      ((PBYTE)pmem + size);

        pBlock->m_rgpICatItems = (ICategorizerItem **)
                                 ((PBYTE)pmem + size +
                                  (dwNumRequests*sizeof(SEARCH_REQUEST)));

        _ASSERT( (DWORD) ((PBYTE)pBlock->m_rgpICatItems +
                          (dwNumRequests*sizeof(ICategorizerItem *)) -
                          (PBYTE)pmem)
                 == dwSize);

    }
    return pmem;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::~CSearchRequestBlock
//
// Synopsis: Release everything we have references to
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/11 18:45:59: Created
//
//-------------------------------------------------------------
CSearchRequestBlock::~CSearchRequestBlock()
{
    DWORD dwCount;
    //
    // Release all CCatAddrs
    //
    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        PSEARCH_REQUEST preq = &(m_prgSearchRequests[dwCount]);

        preq->pCCatAddr->Release();
    }
    //
    // Release all the attr interfaces
    //
    for(dwCount = 0;
        dwCount < m_csaItemAttr.Size();
        dwCount++) {

        ((ICategorizerItemAttributes **)
         m_csaItemAttr)[dwCount]->Release();
    }

    if(m_pISMTPServer)
        m_pISMTPServer->Release();

    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    if(m_pICatParams)
        m_pICatParams->Release();

    if(m_pszSearchFilter)
        delete m_pszSearchFilter;

    if(m_pConn)
        m_pConn->Release();

    _ASSERT(m_dwSignature == SIGNATURE_CSEARCHREQUESTBLOCK);
    m_dwSignature = SIGNATURE_CSEARCHREQUESTBLOCK_INVALID;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::InsertSearchRequest
//
// Synopsis: Inserts a search request in this block.  When the block
//           is full, dispatch the block to LDAP before returning
//
// Arguments:
//  pISMTPServer: ISMTPServer to use for triggering events
//  pICatParams: ICategorizerParameters to use
//  pCCatAddr: Address item for the search
//  fnSearchCompletion: Async Completion routine
//  ctxSearchCompletion: Context to pass to the async completion routine
//  pszSearchFilter: Search filter to use
//  pszDistinguishingAttribute: The distinguishing attribute for matching
//  pszDistinguishingAttributeValue: above attribute's distinguishing value
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/11 13:12:20: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::InsertSearchRequest(
    ISMTPServer *pISMTPServer,
    ICategorizerParameters *pICatParams,
    CCatAddr *pCCatAddr,
    LPSEARCHCOMPLETION fnSearchCompletion,
    CStoreListResolveContext *pslrc,
    LPSTR   pszSearchFilter,
    LPSTR   pszDistinguishingAttribute,
    LPSTR   pszDistinguishingAttributeValue)
{
    PSEARCH_REQUEST preq;
    DWORD dwIndex;
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::InsertSearchRequest");
    //
    // Unset any existing HRSTATUS -- the status will be set again in
    // the search completion
    //
    _VERIFY(SUCCEEDED(
        pCCatAddr->UnSetPropId(
            ICATEGORIZERITEM_HRSTATUS)));

    m_pConn->IncrementPendingSearches();

    preq = GetNextSearchRequest(&dwIndex);

    _ASSERT(preq);

    pCCatAddr->AddRef();
    preq->pCCatAddr = pCCatAddr;
    preq->fnSearchCompletion = fnSearchCompletion;
    preq->pslrc = pslrc;
    preq->pszSearchFilter = pszSearchFilter;
    preq->pszDistinguishingAttribute = pszDistinguishingAttribute;
    preq->pszDistinguishingAttributeValue = pszDistinguishingAttributeValue;

    m_rgpICatItems[dwIndex] = pCCatAddr;

    if(dwIndex == 0) {
        //
        // Use the first insertion's ISMTPServer
        //
        _ASSERT(m_pISMTPServer == NULL);
        m_pISMTPServer = pISMTPServer;

        if(m_pISMTPServer) {
            m_pISMTPServer->AddRef();

            hr = m_pISMTPServer->QueryInterface(
                IID_ISMTPServerEx,
                (LPVOID *) &m_pISMTPServerEx);
            if(FAILED(hr))
            {
                m_pISMTPServerEx = NULL;;
            }
            else
            {
                m_CICatQueries.SetISMTPServerEx(
                    m_pISMTPServerEx);
                m_CICatAsyncContext.SetISMTPServerEx(
                    m_pISMTPServerEx);
            }
        }

        _ASSERT(m_pICatParams == NULL);
        m_pICatParams = pICatParams;
        m_pICatParams->AddRef();
    }

    //
    // Now dispatch this block if we are the last request to finish
    //
    if( (DWORD) (InterlockedIncrement((PLONG)&m_cBlockRequestsReadyForDispatch)) == m_cBlockSize)
        DispatchBlock();

    CatFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::DispatchBlock
//
// Synopsis: Send the LDAP query for this search request block
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/11 15:00:44: Created.
// haozhang 2001/11/30 Fix for 193848
//-------------------------------------------------------------
VOID CSearchRequestBlock::DispatchBlock()
{
    HRESULT hr = S_OK;
    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::DispatchBlock");

    m_pConn->RemoveSearchRequestBlockFromList(this);

    //
    // If the block is empty, we will delete it and bail out. 
    // We will AV down the road otherwise.
    // This is an unintended result of fix of 193848.
    //
    if ( 0 == DwNumBlockRequests()) {
        DebugTrace((LPARAM)this, "DispatchBlock bailing out because the block is empty");
        delete this;
        goto CLEANUP;
    }

    //
    // Build up the query string
    //
    hr = HrTriggerBuildQueries();
    ERROR_CLEANUP_LOG("HrTriggerBuildQueryies");
    //
    // Send the query
    //
    hr = HrTriggerSendQuery();
    ERROR_CLEANUP_LOG("HrTriggerSendQuery");

 CLEANUP:
    if(FAILED(hr)) {
        CompleteBlockWithError(hr);
        delete this;
    }
    //
    // this may be deleted, but that's okay; we're just tracing a user
    // value
    //
    CatFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrTriggerBuildQueries
//
// Synopsis: Trigger the BuildQueries event
//
// Arguments:
//  pCICatQueries: CICategorizerQueriesIMP object to use
//
// Returns:
//  S_OK: Success
//  error from dispatcher
//
// History:
// jstamerj 1999/03/11 19:03:29: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrTriggerBuildQueries()
{
    HRESULT hr = S_OK;
    EVENTPARAMS_CATBUILDQUERIES Params;

    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::HrTriggerBuildQueries");

    Params.pICatParams = m_pICatParams;
    Params.dwcAddresses = DwNumBlockRequests();
    Params.rgpICatItems = m_rgpICatItems;
    Params.pICatQueries = &m_CICatQueries;
    Params.pfnDefault = HrBuildQueriesDefault;
    Params.pblk = this;

    if(m_pISMTPServer) {

        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERIES_EVENT,
            &Params);
        if(FAILED(hr) && (hr != E_NOTIMPL)) {
            ERROR_LOG("m_pISMTPServer->TriggerServerEvent(buildquery)");
        }

    } else {
        hr = E_NOTIMPL;
    }
    
    if(hr == E_NOTIMPL) {
        //
        // Events are disabled
        //
        hr = HrBuildQueriesDefault(
            S_OK,
            &Params);
        if(FAILED(hr)) {
            ERROR_LOG("HrBuildQueriesDefault");
        }
    }
    //
    // Make sure somebody really set the query string
    //
    if(SUCCEEDED(hr) &&
       (m_pszSearchFilter == NULL)) {

        hr = E_FAIL;
        ERROR_LOG("--no filter--");
    }


    DebugTrace((LPARAM)this, "returning hr %08lx",hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrBuildQueriesDefault
//
// Synopsis: Default implementation of the build queries sink
//
// Arguments:
//  hrStatus: Status of events so far
//  pContext: Event params context
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/11 19:42:53: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrBuildQueriesDefault(
    HRESULT HrStatus,
    PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATBUILDQUERIES pParams;
    DWORD cReqs, cOrTerms, idx, idxSecondToLastTerm, idxLastTerm;
    DWORD cbSearchFilter, rgcbSearchFilters[MAX_SEARCH_BLOCK_SIZE];
    LPSTR pszSearchFilterNew;
    CSearchRequestBlock *pblk;

    pParams = (PEVENTPARAMS_CATBUILDQUERIES)pContext;
    _ASSERT(pParams);
    pblk = (CSearchRequestBlock *)pParams->pblk;
    _ASSERT(pblk);

    CatFunctEnterEx((LPARAM)pblk, "CSearchRequestBlock::HrBuildQueriesDefault");

    cReqs = pblk->DwNumBlockRequests();
    _ASSERT( cReqs > 0 );

    cOrTerms = cReqs - 1;
    //
    // Figure out the size of the composite search filter
    //
    cbSearchFilter = 0;

    for (idx = 0; idx < cReqs; idx++) {

        rgcbSearchFilters[idx] =
            strlen(pblk->m_prgSearchRequests[idx].pszSearchFilter);

        cbSearchFilter += rgcbSearchFilters[idx];
    }

    cbSearchFilter += cOrTerms * (sizeof( "(|  )" ) - 1);
    cbSearchFilter++;                            // Terminating NULL.

    pszSearchFilterNew = new CHAR [cbSearchFilter];

    if (pszSearchFilterNew != NULL) {

        idxLastTerm = cReqs - 1;
        idxSecondToLastTerm = idxLastTerm - 1;
        //
        // We special case the cReqs == 1
        //
        if (cReqs == 1) {

            strcpy(
                pszSearchFilterNew,
                pblk->m_prgSearchRequests[0].pszSearchFilter);

        } else {
            //
            // The loop below builds up the block filter all the way up to the
            // last term. For each term, it adds a "(| " to start a new OR
            // term, then adds the OR term itself, then puts a space after the
            // OR term. Also, it puts a matching ")" at the end of the
            // search filter string being built up.
            //
            LPSTR szNextItem = &pszSearchFilterNew[0];
            LPSTR szTerminatingParens =
                &pszSearchFilterNew[cbSearchFilter - 1 - (cReqs-1)];

            pszSearchFilterNew[cbSearchFilter - 1] = 0;

            for (idx = 0; idx <= idxSecondToLastTerm; idx++) {

                strcpy( szNextItem, "(| " );
                szNextItem += sizeof( "(| " ) - 1;

                strcpy(
                    szNextItem,
                    pblk->m_prgSearchRequests[idx].pszSearchFilter);
                szNextItem += rgcbSearchFilters[idx];
                *szNextItem++ = ' ';
                *szTerminatingParens++ = ')';
            }

            //
            // Now, all that remains is to add in the last OR term
            //
            CopyMemory(
                szNextItem,
                pblk->m_prgSearchRequests[idxLastTerm].pszSearchFilter,
                rgcbSearchFilters[idxLastTerm]);

        }

        _ASSERT( ((DWORD) lstrlen(pszSearchFilterNew)) < cbSearchFilter );

        //
        // Save our generated filter string in ICategorizerQueries
        //
        hr = pblk->m_CICatQueries.SetQueryStringNoAlloc(pszSearchFilterNew);

        // There's no good reason for that to fail...
        _ASSERT(SUCCEEDED(hr));

    } else {

        hr = E_OUTOFMEMORY;
        ERROR_LOG_STATIC(
            "new CHAR[]",
            pblk,
            pblk->GetISMTPServerEx());
    }

    DebugTrace((LPARAM)pblk, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)pblk);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrTriggerSendQuery
//
// Synopsis: Trigger the SendQuery event
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/11 20:18:02: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrTriggerSendQuery()
{
    HRESULT hr = S_OK;
    EVENTPARAMS_CATSENDQUERY Params;

    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::HrTriggerSendQuery");

    Params.pICatParams            = m_pICatParams;
    Params.pICatQueries           = &m_CICatQueries;
    Params.pICatAsyncContext      = &m_CICatAsyncContext;
    Params.pIMailTransportNotify  = NULL; // These should be set in CStoreParams
    Params.pvNotifyContext        = NULL;
    Params.hrResolutionStatus     = S_OK;
    Params.pblk                   = this;
    Params.pfnDefault             = HrSendQueryDefault;
    Params.pfnCompletion          = HrSendQueryCompletion;

    if(m_pISMTPServer) {

        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_SENDQUERY_EVENT,
            &Params);
        if(FAILED(hr) && (hr != E_NOTIMPL)) {
            ERROR_LOG("m_pISMTPServer->TriggerServerEvent(sendquery)");
        }

    } else {
        hr = E_NOTIMPL;
    }
    if(hr == E_NOTIMPL) {
        //
        // Events are disabled
        // Heap allocation is required
        //
        PEVENTPARAMS_CATSENDQUERY pParams;
        pParams = new EVENTPARAMS_CATSENDQUERY;
        if(pParams == NULL) {

            hr = E_OUTOFMEMORY;
            ERROR_LOG("new EVENTPARAMS_CATSENDQUERY");

        } else {
            CopyMemory(pParams, &Params, sizeof(EVENTPARAMS_CATSENDQUERY));
            HrSendQueryDefault(
                S_OK,
                pParams);
            hr = S_OK;
        }
    }

    DebugTrace((LPARAM)this, "returning %08lx", (hr == MAILTRANSPORT_S_PENDING) ? S_OK : hr);
    CatFunctLeaveEx((LPARAM)this);
    return (hr == MAILTRANSPORT_S_PENDING) ? S_OK : hr;
} // CSearchRequestBlock::HrTriggerSendQuery



//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrSendQueryDefault
//
// Synopsis: The default sink function for the SendQuery event
//
// Arguments:
//  hrStatus: status of the event so far
//  pContext: Event params context
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/16 11:46:24: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrSendQueryDefault(
        HRESULT HrStatus,
        PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATSENDQUERY pParams;
    CSearchRequestBlock *pBlock;
    LPWSTR *rgpszAttributes = NULL;
    ICategorizerParametersEx *pIPhatParams = NULL;
    ICategorizerRequestedAttributes *pIRequestedAttributes = NULL;

    pParams = (PEVENTPARAMS_CATSENDQUERY) pContext;
    _ASSERT(pParams);

    pBlock = (CSearchRequestBlock *) pParams->pblk;
    _ASSERT(pBlock);
    CatFunctEnterEx((LPARAM)pBlock, "CSearchRequestBlock::HrSendQueryDefault");
    hr = pParams->pICatParams->QueryInterface(
        IID_ICategorizerParametersEx,
        (LPVOID *)&pIPhatParams);

    if(FAILED(hr)) {
        ERROR_LOG_STATIC(
            "pParams->pICatParams->QueryInterface(IID_ICategorizerParametersEx",
            pBlock,
            pBlock->GetISMTPServerEx());
        pIPhatParams = NULL;
        goto CLEANUP;
    }

    hr = pIPhatParams->GetRequestedAttributes(
        &pIRequestedAttributes);
    ERROR_CLEANUP_LOG_STATIC(
        "pIPhatParams->GetRequestedAttributes",
        pBlock,
        pBlock->GetISMTPServerEx());

    hr = pIRequestedAttributes->GetAllAttributesW(
        &rgpszAttributes);
    ERROR_CLEANUP_LOG_STATIC(
        "pIRequestedAttributes->GetAllAttributesW",
        pBlock,
        pBlock->GetISMTPServerEx());

    hr = pBlock->m_pConn->AsyncSearch(
        pBlock->m_pConn->GetNamingContextW(),
        LDAP_SCOPE_SUBTREE,
        pBlock->m_pszSearchFilter,
        (LPCWSTR *)rgpszAttributes,
        0,                      // Do not do a paged search
        LDAPCompletion,
        pParams);
    ERROR_CLEANUP_LOG_STATIC(
        "pBlock->m_pConn->AsyncSearch",
        pBlock,
        pBlock->GetISMTPServerEx());

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)pBlock, "HrSendQueryDefault failing hr %08lx", hr);
        //
        // Call the completion routine directly with the error
        //
        hr = pParams->pICatAsyncContext->CompleteQuery(
            pParams,                    // Query context
            hr,                         // Status
            0,                          // dwcResults
            NULL,                       // rgpItemAttributes,
            TRUE);                      // fFinalCompletion
        //
        // CompleteQuery should not fail
        //
        _ASSERT(SUCCEEDED(hr));
    }
    if(pIRequestedAttributes)
        pIRequestedAttributes->Release();
    if(pIPhatParams)
        pIPhatParams->Release();

    CatFunctLeaveEx((LPARAM)pBlock);
    return MAILTRANSPORT_S_PENDING;
} // CSearchRequestBlock::HrSendQueryDefault


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::LDAPCompletion
//
// Synopsis: Wrapper for the default processing completion of SendQuery
//
//  Arguments:  [ctx] -- Opaque pointer to EVENTPARAMS_SENDQUERY being
//                       completed
//              [dwNumReults] -- The number of objects found
//              [rgpICatItemAttributes] -- An array of
//              ICategorizerItemAttributes; one per object found
//              [hrStatus] -- The error code if the search request failed
//  fFinalCompletion:
//    FALSE: This is a completion for
//           pending results; there will be another completion
//           called with more results
//    TRUE: This is the final completion call
//
//
// Returns: Nothing
//
// History:
// jstamerj 1999/03/16 12:23:54: Created
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::LDAPCompletion(
    LPVOID ctx,
    DWORD dwNumResults,
    ICategorizerItemAttributes **rgpICatItemAttributes,
    HRESULT hrStatus,
    BOOL fFinalCompletion)
{
    HRESULT hr;
    PEVENTPARAMS_CATSENDQUERY pParams;
    CSearchRequestBlock *pBlock;

    pParams = (PEVENTPARAMS_CATSENDQUERY) ctx;
    _ASSERT(pParams);

    pBlock = (CSearchRequestBlock *) pParams->pblk;
    _ASSERT(pBlock);

    CatFunctEnterEx((LPARAM)pBlock, "CSearchRequestBlock::LDAPCompletion");

    if(FAILED(hrStatus))
    {
        //
        // Log async completion failure
        //
        hr = hrStatus;
        ERROR_LOG_STATIC(
            "async",
            pBlock,
            pBlock->GetISMTPServerEx());
    }

    //
    // Call the normal sink completion routine
    //
    hr = pParams->pICatAsyncContext->CompleteQuery(
        pParams,                    // Query Context
        hrStatus,                   // Status
        dwNumResults,               // dwcResults
        rgpICatItemAttributes,      // rgpItemAttributes
        fFinalCompletion);          // Is this the final completion for the query?

    _ASSERT(SUCCEEDED(hr));

    CatFunctLeaveEx((LPARAM)pBlock);
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrSendQueryCompletion
//
// Synopsis: The completion routine for the SendQuery event
//
// Arguments:
//  hrStatus: status of the event so far
//  pContext: Event params context
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/16 12:52:22: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrSendQueryCompletion(
    HRESULT HrStatus,
    PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATSENDQUERY pParams;
    CSearchRequestBlock *pBlock;

    pParams = (PEVENTPARAMS_CATSENDQUERY) pContext;
    _ASSERT(pParams);

    pBlock = (CSearchRequestBlock *) pParams->pblk;
    _ASSERT(pBlock);

    CatFunctEnterEx((LPARAM)pBlock, "CSearchRequestBlock::HrSendQueryCompletion");

    //
    // Log async failure
    //
    if(FAILED(HrStatus))
    {
        hr = HrStatus;
        ERROR_LOG_STATIC(
            "async",
            pBlock,
            pBlock->GetISMTPServerEx());
    }

    pBlock->CompleteSearchBlock(
        pParams->hrResolutionStatus);

    if(pBlock->m_pISMTPServer == NULL) {
        //
        // Events are disabled
        // We must free the eventparams
        //
        delete pParams;
    }
    //
    // The purpose of this block is complete.  Today is a good day to
    // die!
    // -- Lt. Commander Worf
    //
    delete pBlock;

    CatFunctLeaveEx((LPARAM)pBlock);
    return S_OK;
} // HrSendQueryCompletion


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::CompleteSearchBlock
//
// Synopsis: Completion routine when the SendQuery event is done
//
// Arguments:
//  hrStatus: Resolution status
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/16 13:36:33: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::CompleteSearchBlock(
    HRESULT hrStatus)
{
    HRESULT hr = S_OK;
    HRESULT hrFetch, hrResult;
    DWORD dwCount;
    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::CompleteSearchBlock");

    hr = HrTriggerSortQueryResult(hrStatus);
    ERROR_CLEANUP_LOG("HrTriggerSortQueryResult");
    //
    // Check every ICategorizerItem
    // If any one of them does not have an hrStatus set, set it to
    // HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
    //
    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        hrFetch = m_rgpICatItems[dwCount]->GetHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            &hrResult);

        if(FAILED(hrFetch)) {
            _ASSERT(hrFetch == CAT_E_PROPNOTFOUND);
            _VERIFY(SUCCEEDED(
                m_rgpICatItems[dwCount]->PutHRESULT(
                    ICATEGORIZERITEM_HRSTATUS,
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))));
        }
    }

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Failing block hr %08lx", hr);
        PutBlockHRESULT(hr);
    }
    //
    // Call all the individual completion routines
    //
    CallCompletions();

    CatFunctLeaveEx((LPARAM)this);
} // CSearchRequestBlock::CompleteSearchBlock



//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::PutBlockHRESULT
//
// Synopsis: Set the status of every ICatItem in the block to some hr
//
// Arguments:
//  hr: Status to set
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/16 14:03:30: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::PutBlockHRESULT(
    HRESULT hr)
{
    DWORD dwCount;

    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::PutBlockHRESULT");
    DebugTrace((LPARAM)this, "hr = %08lx", hr);

    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        PSEARCH_REQUEST preq = &(m_prgSearchRequests[dwCount]);
        //
        // Set the error status
        //
        _VERIFY(SUCCEEDED(preq->pCCatAddr->PutHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            hr)));
    }

    CatFunctLeaveEx((LPARAM)this);
} // CSearchRequestBlock::PutBlockHRESULT


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::CallCompletions
//
// Synopsis: Call the completion routine of every item in the block
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/16 14:05:50: Created.
// dlongley 2001/10/23: Modified.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::CallCompletions()
{
    DWORD dwCount;

    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::CallCompletions");

    //
    // Get an Insertion context before calling completions so that
    // newly inserted searches will be batched
    //
    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        PSEARCH_REQUEST preq = &(m_prgSearchRequests[dwCount]);

        preq->pslrc->AddRef();
        preq->pslrc->GetInsertionContext();

        preq->fnSearchCompletion(
            preq->pCCatAddr,
            preq->pslrc,
            m_pConn);
    }

    m_pConn->DecrementPendingSearches(
        DwNumBlockRequests());

    for(dwCount = 0;
        dwCount < DwNumBlockRequests();
        dwCount++) {

        PSEARCH_REQUEST preq = &(m_prgSearchRequests[dwCount]);

        preq->pslrc->ReleaseInsertionContext();
        preq->pslrc->Release();
    }

    CatFunctLeaveEx((LPARAM)this);
} // CSearchRequestBlock::CallCompletions



//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrTriggerSortQueryResult
//
// Synopsis: Trigger the SortQueryResult event
//
// Arguments:
//  hrStatus: Status of Resolution
//
// Returns:
//  S_OK: Success
//  error from the dispatcher
//
// History:
// jstamerj 1999/03/16 14:09:12: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrTriggerSortQueryResult(
    HRESULT hrStatus)
{
    HRESULT hr = S_OK;
    EVENTPARAMS_CATSORTQUERYRESULT Params;

    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::HrTriggerSortQueryResult");

    Params.pICatParams = m_pICatParams;
    Params.hrResolutionStatus = hrStatus;
    Params.dwcAddresses = DwNumBlockRequests();
    Params.rgpICatItems = m_rgpICatItems;
    Params.dwcResults = m_csaItemAttr.Size();
    Params.rgpICatItemAttributes = m_csaItemAttr;
    Params.pfnDefault = HrSortQueryResultDefault;
    Params.pblk = this;

    if(m_pISMTPServer) {

        hr = m_pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_SORTQUERYRESULT_EVENT,
            &Params);
        if(FAILED(hr) && (hr != E_NOTIMPL))
        {
            ERROR_LOG("m_pISMTPServer->TriggerServerEvent");
        }
    } else {
        hr = E_NOTIMPL;
    }
    if(hr == E_NOTIMPL) {
        //
        // Events are disabled, call default processing
        //
        HrSortQueryResultDefault(
            S_OK,
            &Params);
        hr = S_OK;
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CSearchRequestBlock::HrTriggerSortQueryResult


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::HrSortQueryResultDefault
//
// Synopsis: Default sink for SortQueryResult -- match the objects found
//           with the objects requested
//
// Arguments:
//  hrStatus: Status of events
//  pContext: Params context for this event
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/16 14:17:49: Created.
//
//-------------------------------------------------------------
HRESULT CSearchRequestBlock::HrSortQueryResultDefault(
    HRESULT hrStatus,
    PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATSORTQUERYRESULT pParams;
    CSearchRequestBlock *pBlock;
    DWORD dwAttrIndex, dwReqIndex;
    ATTRIBUTE_ENUMERATOR enumerator;

    pParams = (PEVENTPARAMS_CATSORTQUERYRESULT) pContext;
    _ASSERT(pParams);

    pBlock = (CSearchRequestBlock *) pParams->pblk;
    _ASSERT(pBlock);

    CatFunctEnterEx((LPARAM)pBlock, "CSearchRequestBlock::HrSortQueryResultDefault");
    DebugTrace((LPARAM)pBlock, "hrResolutionStatus %08lx, dwcResults %08lx",
               pParams->hrResolutionStatus, pParams->dwcResults);

    if(FAILED(pParams->hrResolutionStatus)) {
        //
        // Fail the entire block
        //
        pBlock->PutBlockHRESULT(pParams->hrResolutionStatus);
        goto CLEANUP;
    }
    //
    // Resolution succeeded
    // If dwcResults is not zero, then rgpICatItemAttrs can NOT be null
    //
    _ASSERT((pParams->dwcResults == 0) ||
            (pParams->rgpICatItemAttributes != NULL));

    //
    // Loop through every rgpICatItemAttrs.  For each
    // ICategorizerItemAttributes, looking for a matching SEARCH_REQUEST
    //
    for(dwAttrIndex = 0; dwAttrIndex < pParams->dwcResults; dwAttrIndex++) {
        ICategorizerItemAttributes *pICatItemAttr = NULL;
        ICategorizerUTF8Attributes *pIUTF8 = NULL;

        pICatItemAttr = pParams->rgpICatItemAttributes[dwAttrIndex];
        LPCSTR pszLastDistinguishingAttribute = NULL;
        BOOL fEnumerating = FALSE;

        hr = pICatItemAttr->QueryInterface(
            IID_ICategorizerUTF8Attributes,
            (LPVOID *) &pIUTF8);
        ERROR_CLEANUP_LOG_STATIC(
            "pICatItemAttr->QueryInterface",
            pBlock,
            pBlock->GetISMTPServerEx());

        for(dwReqIndex = 0; dwReqIndex < pBlock->DwNumBlockRequests();
            dwReqIndex++) {
            PSEARCH_REQUEST preq = &(pBlock->m_prgSearchRequests[dwReqIndex]);
//#ifdef DEBUG
//            WCHAR wszPreqDistinguishingAttributeValue[20]; 
//#else
            WCHAR wszPreqDistinguishingAttributeValue[CAT_MAX_INTERNAL_FULL_EMAIL]; 
//#endif
            LPWSTR pwszPreqDistinguishingAttributeValue = wszPreqDistinguishingAttributeValue;
            DWORD cPreqDistinguishingAttributeValue; 
            DWORD rc;

            //
            // If we don't have a distinguishing attribute and
            // distinguishing attribute value for this search
            // request, we've no hope of matching it up
            //
            if((preq->pszDistinguishingAttribute == NULL) ||
               (preq->pszDistinguishingAttributeValue == NULL))
                continue;

            // convert pszDistinguishingAttributeValue to unicode
            cPreqDistinguishingAttributeValue = 
                MultiByteToWideChar(CP_UTF8, 
                                    0, 
                                    preq->pszDistinguishingAttributeValue, 
                                    -1, 
                                    pwszPreqDistinguishingAttributeValue, 
                                    0);
            if (cPreqDistinguishingAttributeValue > 
                (sizeof(wszPreqDistinguishingAttributeValue) / sizeof(WCHAR)) ) 
            {
                pwszPreqDistinguishingAttributeValue = 
                    new WCHAR[cPreqDistinguishingAttributeValue + 1];
                if (pwszPreqDistinguishingAttributeValue == NULL) {
                    hr = E_OUTOFMEMORY;
                    ERROR_LOG_STATIC(
                        "new WCHAR[]",
                        pBlock,
                        pBlock->GetISMTPServerEx());
                    continue;
                }
            }
            rc = MultiByteToWideChar(CP_UTF8, 
                                     0, 
                                     preq->pszDistinguishingAttributeValue, 
                                     -1, 
                                     pwszPreqDistinguishingAttributeValue, 
                                     cPreqDistinguishingAttributeValue);
            if (rc == 0) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERROR_LOG_STATIC(
                    "MultiByteToWideChar",
                    pBlock,
                    pBlock->GetISMTPServerEx());
                continue;
            }

            //
            // Start an attribute value enumeration if necessary
            //
            if((pszLastDistinguishingAttribute == NULL) || 
                (lstrcmpi(pszLastDistinguishingAttribute,
                          preq->pszDistinguishingAttribute) != 0)) {
                if(fEnumerating) {
                    pIUTF8->EndUTF8AttributeEnumeration(&enumerator);
                }
                hr = pIUTF8->BeginUTF8AttributeEnumeration(
                    preq->pszDistinguishingAttribute,
                    &enumerator);
                fEnumerating = SUCCEEDED(hr);
                pszLastDistinguishingAttribute = preq->pszDistinguishingAttribute;
            } else {
                //
                // else just rewind our current enumeration
                //
                if(fEnumerating)
                    _VERIFY(SUCCEEDED(pIUTF8->RewindUTF8AttributeEnumeration(
                        &enumerator)));
            }
            //
            // If we can't enumerate through the distinguishing
            // attribute, there's no hope in matching up requests
            //
            if(!fEnumerating)
                continue;

            //
            // See if the distinguishing attribute value matches
            //
            LPSTR pszDistinguishingAttributeValue;
            hr = pIUTF8->GetNextUTF8AttributeValue(
                &enumerator,
                &pszDistinguishingAttributeValue);
            while(SUCCEEDED(hr)) {
                hr = wcsutf8cmpi(pwszPreqDistinguishingAttributeValue,
                                 pszDistinguishingAttributeValue);
                if (SUCCEEDED(hr)) {
                    if(hr == S_OK) {
                        DebugTrace((LPARAM)pBlock, "Matched dwAttrIndex %d with dwReqIndex %d", dwAttrIndex, dwReqIndex);
                        pBlock->MatchItem(
                            preq->pCCatAddr,
                            pICatItemAttr);
                    }
                    hr = pIUTF8->GetNextUTF8AttributeValue(
                        &enumerator,
                        &pszDistinguishingAttributeValue);
                } else {
                    ERROR_LOG_STATIC(
                        "wcsutf8cmpi",
                        pBlock,
                        pBlock->GetISMTPServerEx());
                }
            }

            if (pwszPreqDistinguishingAttributeValue != wszPreqDistinguishingAttributeValue) {
                delete[] pwszPreqDistinguishingAttributeValue;
            }
        }
        //
        // End any last enumeration going on
        //
        if(fEnumerating)
            pIUTF8->EndUTF8AttributeEnumeration(&enumerator);
        fEnumerating = FALSE;
        if(pIUTF8) {
            pIUTF8->Release();
            pIUTF8 = NULL;
        }
    }

 CLEANUP:
    CatFunctLeaveEx((LPARAM)pBlock);
    return S_OK;
} // CSearchRequestBlock::HrSortQueryResultDefault


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::MatchItem
//
// Synopsis: Match a particular ICategorizerItem to a particular ICategorizerItemAttributes
// If already matched with an ICategorizerItemAttributes with an
// identical ID then set item status to CAT_E_MULTIPLE_MATCHES
// If already matched with an ICategorizerItemAttributes with a
// different ID then attempt aggregation
////
// Arguments:
//  pICatItem: an ICategorizerItem
//  pICatItemAttr: the matching attribute interface for pICatItem
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/16 14:36:45: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::MatchItem(
    ICategorizerItem *pICatItem,
    ICategorizerItemAttributes *pICatItemAttr)
{
    HRESULT hr = S_OK;
    ICategorizerItemAttributes *pICatItemAttr_Current = NULL;

    CatFunctEnterEx((LPARAM)this, "CSearchRequestBlock::MatchItem");

    _ASSERT(pICatItem);
    _ASSERT(pICatItemAttr);
    //
    // Check to see if this item already has
    // ICategorizerItemAttributes set
    //
    hr = pICatItem->GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr_Current);
    if(SUCCEEDED(hr)) {
        //
        // This guy is already matched.  Is the duplicate from the
        // same resolver sink?
        //
        GUID GOriginal, GNew;
        GOriginal = pICatItemAttr_Current->GetTransportSinkID();
        GNew = pICatItemAttr->GetTransportSinkID();

        if(GOriginal == GNew) {
            //
            // Two matches from the same resolver sink indicates that
            // there are multiple matches for this object.  This is an
            // error.
            //

            //
            // This guy is already matched -- the distinguishing attribute
            // really wasn't distinguishing.  Set error hrstatus.
            //
            LogAmbiguousEvent(pICatItem);

            _VERIFY(SUCCEEDED(
                pICatItem->PutHRESULT(
                    ICATEGORIZERITEM_HRSTATUS,
                    CAT_E_MULTIPLE_MATCHES)));
        } else {

            //
            // We have multiple matches from different resolver
            // sinks.  Let's try to aggregate the new
            // ICategorizerItemAttributes
            //

            hr = pICatItemAttr_Current->AggregateAttributes(
                pICatItemAttr);

            if(FAILED(hr) && (hr != E_NOTIMPL)) {
                //
                // Fail categorization for this item
                //
                ERROR_LOG("pICatItemAttr_Current->AggregateAttributes");
                _VERIFY(SUCCEEDED(
                    pICatItem->PutHRESULT(
                        ICATEGORIZERITEM_HRSTATUS,
                        hr)));
            }
        }
    } else {
        //
        // Normal case -- set the ICategorizerItemAttribute property
        // of ICategorizerItem
        //
        _VERIFY(SUCCEEDED(
            pICatItem->PutICategorizerItemAttributes(
                ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
                pICatItemAttr)));
        //
        // Set hrStatus of this guy to success
        //
        _VERIFY(SUCCEEDED(
            pICatItem->PutHRESULT(
                ICATEGORIZERITEM_HRSTATUS,
                S_OK)));
    }

    if(pICatItemAttr_Current)
        pICatItemAttr_Current->Release();

    CatFunctLeaveEx((LPARAM)this);
} // CSearchRequestBlock::MatchItem



//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::HrInsertSearchRequest
//
// Synopsis: Insert a search request
//
// Arguments:
//  pISMTPServer: ISMTPServer interface to use for triggering events
//  pCCatAddr: Address item for the search
//  fnSearchCompletion: Async Completion routine
//  ctxSearchCompletion: Context to pass to the async completion routine
//  pszSearchFilter: Search filter to use
//  pszDistinguishingAttribute: The distinguishing attribute for matching
//  pszDistinguishingAttributeValue: above attribute's distinguishing value
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/08 19:41:37: Created.
//
//-------------------------------------------------------------
HRESULT CBatchLdapConnection::HrInsertSearchRequest(
    ISMTPServer *pISMTPServer,
    ICategorizerParameters *pICatParams,
    CCatAddr *pCCatAddr,
    LPSEARCHCOMPLETION fnSearchCompletion,
    CStoreListResolveContext *pslrc,
    LPSTR   pszSearchFilter,
    LPSTR   pszDistinguishingAttribute,
    LPSTR   pszDistinguishingAttributeValue)
{
    HRESULT hr = S_OK;
    CSearchRequestBlock *pBlock;

    CatFunctEnterEx((LPARAM)this, "CBatchLdapConnection::HrInsertSearchRequest");

    _ASSERT(m_cInsertionContext);
    _ASSERT(pCCatAddr);
    _ASSERT(fnSearchCompletion);
    _ASSERT(pszSearchFilter);
    _ASSERT(pszDistinguishingAttribute);
    _ASSERT(pszDistinguishingAttributeValue);

    pBlock = GetSearchRequestBlock();

    if(pBlock == NULL) {

        ErrorTrace((LPARAM)this, "out of memory getting a search block");
        hr = E_OUTOFMEMORY;
        ERROR_LOG_ADDR(pCCatAddr, "GetSearchRequestBlock");
        goto CLEANUP;
    }

    pBlock->InsertSearchRequest(
        pISMTPServer,
        pICatParams,
        pCCatAddr,
        fnSearchCompletion,
        pslrc,
        pszSearchFilter,
        pszDistinguishingAttribute,
        pszDistinguishingAttributeValue);

 CLEANUP:
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::GetSearchRequestBlock
//
// Synopsis: Gets the next available search block with room
//
// Arguments: NONE
//
// Returns:
//  NULL: Out of memory
//  else, a search block object
//
// History:
// jstamerj 1999/03/08 19:41:37: Created.
// haozhang 2001/11/25 updated for 193848
//
//-------------------------------------------------------------
CSearchRequestBlock * CBatchLdapConnection::GetSearchRequestBlock()
{
    HRESULT hr = E_FAIL;
    PLIST_ENTRY ple;
    CSearchRequestBlock *pBlock = NULL;

    //
    // Updated for fix of 193848
    // We do two passes. In first one, we will go through the list
    // and reserve a slot if available(then return). If we don't,
    // we will created a new block and proceed with a second pass. In
    // second pass, we will first insert the block to the list, then
    // go through the list again to reserve a slot in the first
    // avaiable block. The fix differs from previous version in that
    // we will not simply reserve a slot in the new block we just
    // created. Instead, we will go through the list again in case
    // existing block still has room. Therefore, we avoided the
    // core problem in which we reserve a slot on new block even
    // though there is room in existing block.
    //

    AcquireSpinLock(&m_spinlock);
    //
    // See if there is an insertion block with available slots
    //
    for(ple = m_listhead.Flink;
        (ple != &m_listhead) && (FAILED(hr));
        ple = ple->Flink) {

        pBlock = CONTAINING_RECORD(ple, CSearchRequestBlock, m_listentry);

        hr = pBlock->ReserveSlot();
    }

    ReleaseSpinLock(&m_spinlock);

    if(SUCCEEDED(hr))
        return pBlock;

    //
    // Create a new block
    //
    pBlock = new (m_nMaxSearchBlockSize) CSearchRequestBlock(this);
    if(pBlock) {
        
        AcquireSpinLock(&m_spinlock);

        InsertTailList(&m_listhead, &(pBlock->m_listentry));
        
        //
        // Again,see if there is an insertion block with available slots
        //
        for(ple = m_listhead.Flink;
            (ple != &m_listhead) && (FAILED(hr));
            ple = ple->Flink) {

            pBlock = CONTAINING_RECORD(ple, CSearchRequestBlock, m_listentry);

            hr = pBlock->ReserveSlot();
        }
        ReleaseSpinLock(&m_spinlock);

        _ASSERT(SUCCEEDED(hr));
    }
    return pBlock;
}


//+------------------------------------------------------------
//
// Function: CSearchRequestBlock::LogAmbiguousEvent
//
// Synopsis: Eventlogs an ambiguous address error
//
// Arguments:
//  pItem: ICatItem with ambig address
//
// Returns: Nothing
//
// History:
// jstamerj 2001/12/13 00:03:16: Created.
//
//-------------------------------------------------------------
VOID CSearchRequestBlock::LogAmbiguousEvent(
    IN  ICategorizerItem *pItem)
{
    HRESULT hr = S_OK;
    LPCSTR rgSubStrings[2];
    CHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
    CHAR szAddressType[CAT_MAX_ADDRESS_TYPE_STRING];

    CatFunctEnter("CIMstRecipListAddr::LogNDREvent");

    //
    // Get the address
    //
    hr = HrGetAddressStringFromICatItem(
        pItem,
        sizeof(szAddressType) / sizeof(szAddressType[0]),
        szAddressType,
        sizeof(szAddress) / sizeof(szAddress[0]),
        szAddress);
    
    if(FAILED(hr))
    {
        //
        // Still log an event, but use "unknown" for address type/string
        //
        lstrcpyn(szAddressType, "unknown",
                 sizeof(szAddressType) / sizeof(szAddressType[0]));
        lstrcpyn(szAddress, "unknown",
                 sizeof(szAddress) / sizeof(szAddress[0]));
        hr = S_OK;
    }

    rgSubStrings[0] = szAddressType;
    rgSubStrings[1] = szAddress;

    //
    // Can we log an event?
    //
    if(GetISMTPServerEx() == NULL)
    {
        FatalTrace((LPARAM)0, "Unable to log ambiguous address event; NULL pISMTPServerEx");
        for(DWORD dwIdx = 0; dwIdx < 2; dwIdx++)
        {
            if( rgSubStrings[dwIdx] != NULL )
            {
                FatalTrace((LPARAM)0, "Event String %d: %s",
                           dwIdx, rgSubStrings[dwIdx]);
            }
        }
    }
    else
    {
        CatLogEvent(
            GetISMTPServerEx(),
            CAT_EVENT_AMBIGUOUS_ADDRESS,
            2,
            rgSubStrings,
            S_OK,
            szAddress,
            LOGEVENT_FLAG_PERIODIC,
            LOGEVENT_LEVEL_MINIMUM);
    }
}


//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::DispatchBlocks
//
// Synopsis: Dispatch all the blocks in a list
//
// Arguments:
//  plisthead: List to dispatch
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/11 15:16:36: Created.
//
//-------------------------------------------------------------
VOID CBatchLdapConnection::DispatchBlocks(
    PLIST_ENTRY plisthead)
{
    PLIST_ENTRY ple, ple_next;
    CSearchRequestBlock *pBlock;

    for(ple = plisthead->Flink;
        ple != plisthead;
        ple = ple_next) {

        ple_next = ple->Flink;

        pBlock = CONTAINING_RECORD(ple, CSearchRequestBlock,
                                   m_listentry);

        pBlock->DispatchBlock();
    }
}


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::CStoreListResolveContext
//
// Synopsis: Construct a CStoreListResolveContext object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/22 12:16:08: Created.
//
//-------------------------------------------------------------
CStoreListResolveContext::CStoreListResolveContext(
    CEmailIDLdapStore<CCatAddr> *pStore)
{
    CatFunctEnterEx((LPARAM)this, "CStoreListResolveContext::CStoreListResolveContext");

    m_cRefs = 1;
    m_dwSignature = SIGNATURE_CSTORELISTRESOLVECONTEXT;
    m_pConn = NULL;
    m_fCanceled = FALSE;
    m_dwcRetries = 0;
    m_dwcCompletedLookups = 0;
    InitializeCriticalSectionAndSpinCount(&m_cs, 2000);
    m_pISMTPServer = NULL;
    m_pISMTPServerEx = NULL;
    m_pICatParams = NULL;
    m_dwcInsertionContext = 0;
    m_pStore = pStore;

    CatFunctLeaveEx((LPARAM)this);
} // CStoreListResolveContext::CStoreListResolveContext


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::~CStoreListResolveContext
//
// Synopsis: Destruct a list resolve context
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/22 12:18:01: Created.
//
//-------------------------------------------------------------
CStoreListResolveContext::~CStoreListResolveContext()
{
    CatFunctEnterEx((LPARAM)this, "CStoreListResolveContext::~CStoreListResolveContext");

    _ASSERT(m_dwSignature == SIGNATURE_CSTORELISTRESOLVECONTEXT);
    m_dwSignature = SIGNATURE_CSTORELISTRESOLVECONTEXT_INVALID;

    if(m_pConn)
        m_pConn->Release();

    if(m_pISMTPServer)
        m_pISMTPServer->Release();

    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    if(m_pICatParams)
        m_pICatParams->Release();

    DeleteCriticalSection(&m_cs);

    CatFunctLeaveEx((LPARAM)this);
} // CStoreListResolveContext::~CStoreListResolveContext


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::HrInitialize
//
// Synopsis: Initailize this object so that it is ready to handle lookups
//
// Arguments:
//  pISMTPServer: ISMTPServer interface to use for triggering events
//  pICatParams:  ICatParams interface to use
//
//  Note: All of these string buffers must remain valid for the
//        lifetime of this object!
//  pszAccount: LDAP account to use for binding
//  pszPassword: LDAP password to use
//  pszNamingContext: Naming context to use for searches
//  pszHost: LDAP Host to connect to
//  dwPort: LDAP TCP port to use
//  bt: Method of LDAP bind to use
//
// Returns:
//  S_OK: Success
//  error from LdapConnectionCache
//
// History:
// jstamerj 1999/03/22 12:20:31: Created.
//
//-------------------------------------------------------------
HRESULT CStoreListResolveContext::HrInitialize(
    ISMTPServer *pISMTPServer,
    ICategorizerParameters *pICatParams)
{
    HRESULT hr = S_OK;
    CatFunctEnterEx((LPARAM)this, "CStoreListResolveContext::HrInitialize");

    _ASSERT(m_pISMTPServer == NULL);
    _ASSERT(m_pICatParams == NULL);
    _ASSERT(pICatParams != NULL);

    if(pISMTPServer) {
        m_pISMTPServer = pISMTPServer;
        m_pISMTPServer->AddRef();

        hr = m_pISMTPServer->QueryInterface(
            IID_ISMTPServerEx,
            (LPVOID *) &m_pISMTPServerEx);
        if(FAILED(hr)) {
            //
            // Deal with error
            //
            m_pISMTPServerEx = NULL;
            hr = S_OK;
        }

    }
    if(pICatParams) {
        m_pICatParams = pICatParams;
        m_pICatParams->AddRef();
    }

    hr = m_pStore->HrGetConnection(
        &m_pConn);

    if(FAILED(hr)) {
        ERROR_LOG("m_pStore->HrGetConnection");
        m_pConn = NULL;
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreListResolveContext::HrInitialize



//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::HrLookupEntryAsync
//
// Synopsis: Dispatch an async LDAP lookup
//
// Arguments:
//  pCCatAddr: Address object to lookup
//
// Returns:
//  S_OK: Success
//  error from LdapConn
//
// History:
// jstamerj 1999/03/22 12:28:52: Created.
//
//-------------------------------------------------------------
HRESULT CStoreListResolveContext::HrLookupEntryAsync(
    CCatAddr *pCCatAddr)
{
    HRESULT hr = S_OK;
    LPSTR pszSearchFilter = NULL;
    LPSTR pszDistinguishingAttribute = NULL;
    LPSTR pszDistinguishingAttributeValue = NULL;
    BOOL  fTryAgain;

    CatFunctEnterEx((LPARAM)this, "CStoreListResolveContext::HrLookupEntryAsync");

    //
    // Addref the CCatAddr here, release after completion
    //
    pCCatAddr->AddRef();

    hr = pCCatAddr->HrTriggerBuildQuery();
    ERROR_CLEANUP_LOG_ADDR(pCCatAddr, "pCCatAddr->HrTriggerBuildQuery");

    //
    // Fetch the distinguishing attribute and distinguishing attribute
    // value from pCCatAddr
    //
    pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_LDAPQUERYSTRING,
        &pszSearchFilter);
    pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
        &pszDistinguishingAttribute);
    pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE,
        &pszDistinguishingAttributeValue);

    //
    // Check to see if anyone set a search filter
    //
    if(pszSearchFilter == NULL) {

        HRESULT hrStatus;
        //
        // If the status is unset, set it to CAT_E_NO_FILTER
        //
        hr = pCCatAddr->GetHRESULT(
            ICATEGORIZERITEM_HRSTATUS,
            &hrStatus);

        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "No search filter set");
            ERROR_LOG_ADDR(pCCatAddr, "pCCatAddr->GetHRESULT(hrstatus) -- no filter");

            _VERIFY(SUCCEEDED(pCCatAddr->PutHRESULT(
                ICATEGORIZERITEM_HRSTATUS,
                CAT_E_NO_FILTER)));
        }
        DebugTrace((LPARAM)this, "BuildQuery did not build a search filter");
        //
        // Call the completion directly
        //
        pCCatAddr->LookupCompletion();
        pCCatAddr->Release();
        hr = S_OK;
        goto CLEANUP;
    }
    if((pszDistinguishingAttribute == NULL) ||
       (pszDistinguishingAttributeValue == NULL)) {
        ErrorTrace((LPARAM)this, "Distinguishing attribute not set");
        ERROR_LOG_ADDR(pCCatAddr, "--no distinguishing attribute--");
        hr = E_INVALIDARG;
        goto CLEANUP;
    }
    do {

        fTryAgain = FALSE;
        CBatchLdapConnection *pConn;

        pConn = GetConnection();

        //
        // Insert the search request into the CBatchLdapConnection
        // object. We will use the email address as the distinguishing
        // attribute
        //
        if(pConn == NULL) {

            hr = CAT_E_DBCONNECTION;
            ERROR_LOG_ADDR(pCCatAddr, "GetConnection");

        } else {

            pConn->GetInsertionContext();

            hr = pConn->HrInsertSearchRequest(
                m_pISMTPServer,
                m_pICatParams,
                pCCatAddr,
                CStoreListResolveContext::AsyncLookupCompletion,
                this,
                pszSearchFilter,
                pszDistinguishingAttribute,
                pszDistinguishingAttributeValue);

            if(FAILED(hr)) {
                ERROR_LOG_ADDR(pCCatAddr, "pConn->HrInsertSearchRequest");
            }

            pConn->ReleaseInsertionContext();

        }
        //
        // If the above fails with CAT_E_TRANX_FAILED, it may be due
        // to a stale connection.  Attempt to reconnect.
        //
        if((hr == CAT_E_TRANX_FAILED) || (hr == CAT_E_DBCONNECTION)) {

            HRESULT hrTryAgain = S_OK;

            hrTryAgain = HrInvalidateConnectionAndRetrieveNewConnection(pConn);
            fTryAgain = SUCCEEDED(hrTryAgain);

            if(FAILED(hrTryAgain)) {
                //
                // Declare a new local called hr here because the
                // ERROR_LOG macro uses it
                //
                HRESULT hr = hrTryAgain;
                ERROR_LOG_ADDR(pCCatAddr, "HrInvalidateConnectionAndRetrieveNewConnection");
            }
        }
        if(pConn != NULL)
            pConn->Release();

    } while(fTryAgain);

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "failing hr %08lx", hr);
        pCCatAddr->Release();
    }

    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreListResolveContext::HrLookupEntryAsync


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::Cancel
//
// Synopsis: Cancels pending lookups
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/22 12:45:21: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::Cancel()
{
    CatFunctEnterEx((LPARAM)this, "CStoreListResolveContext::Cancel");

    EnterCriticalSection(&m_cs);

    m_fCanceled = TRUE;
    m_pConn->CancelAllSearches();

    LeaveCriticalSection(&m_cs);

    CatFunctLeaveEx((LPARAM)this);
} // CStoreListResolveContext::HrCancel


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::AsyncLookupCompletion
//
// Synopsis: Handle completion of a CCatAddr from CSearchRequestBlock
//
// Arguments:
//  pCCatAddr: the item being completed
//  pConn: Connection object used to do the search
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/22 14:37:09: Created.
// dlongley 2001/10/23: Modified.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::AsyncLookupCompletion(
    CCatAddr *pCCatAddr,
    CStoreListResolveContext *pslrc,
    CBatchLdapConnection *pConn)
{
    HRESULT hr = S_OK;
    HRESULT hrStatus;
    CSingleSearchReinsertionRequest *pCInsertionRequest = NULL;

    CatFunctEnterEx((LPARAM)pslrc,
                      "CStoreListResolveContext::AsyncLookupCompletion");

    _ASSERT(pCCatAddr);

    hr = pCCatAddr->GetHRESULT(
        ICATEGORIZERITEM_HRSTATUS,
        &hrStatus);
    _ASSERT(SUCCEEDED(hr));

    if( SUCCEEDED(hrStatus) )
        InterlockedIncrement((LPLONG) &(pslrc->m_dwcCompletedLookups));

    if( (hrStatus == CAT_E_DBCONNECTION) &&
        SUCCEEDED(pslrc->HrInvalidateConnectionAndRetrieveNewConnection(pConn))) {
        //
        // Retry the search with the new connection
        //
        pCInsertionRequest = new CSingleSearchReinsertionRequest(
            pslrc,
            pCCatAddr);

        if(!pCInsertionRequest) {
            
            hr = E_OUTOFMEMORY;
            ERROR_LOG_ADDR_STATIC(
                pCCatAddr,
                "new CSingleSearchReinsertionRequest",
                pslrc,
                pslrc->GetISMTPServerEx());
            pCCatAddr->LookupCompletion();

        } else {

            hr = pslrc->HrInsertInsertionRequest(pCInsertionRequest);
            if(FAILED(hr))
            {
                ERROR_LOG_ADDR_STATIC(
                    pCCatAddr,
                    "pslrc->HrInsertInsertionRequest",
                    pslrc,
                    pslrc->GetISMTPServerEx());
            }
            //
            // The insertion request destructor should call the lookup
            // completion
            //
            pCInsertionRequest->Release();
        }

    } else {

        pCCatAddr->LookupCompletion();
    }
    pCCatAddr->Release(); // Release reference count addref'd in LookupEntryAsync

    CatFunctLeaveEx((LPARAM)pslrc);
} // CStoreListResolveContext::AsyncLookupCompletion



//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::HrInvalidateConnectionAndRetrieveNewConnection
//
// Synopsis: Invalidate our current connection and get a new connection
//
// Arguments:
//  pConn: The old LDAP connection
//  fCountAsRetry: Whether or not to increment the retry counter. We don't want to
//    increment the retry counter in the case of a failed insertion request
//    insertion, because that means that 
//
// Returns:
//  S_OK: Success
//  CAT_E_MAX_RETRIES: Too many retries already
//  or error from ldapconn
//
// History:
// jstamerj 1999/03/22 14:50:07: Created.
//
//-------------------------------------------------------------
HRESULT CStoreListResolveContext::HrInvalidateConnectionAndRetrieveNewConnection(
    CBatchLdapConnection *pConn,
    BOOL fIncrementRetryCount)
{
    HRESULT hr = S_OK;
    CCfgConnection *pNewConn = NULL;
    CCfgConnection *pOldConn = NULL;
    DWORD dwCount;
    DWORD dwcInsertionContext;
    DWORD dwcCompletedLookups;
    DWORD dwcRetries;

    CatFunctEnterEx((LPARAM)this, "CStoreListResolveContext::HrInvalidateConnectionAndRetrieveNewConnection");

    DebugTrace((LPARAM)this, "pConn: %08lx", pConn);

    EnterCriticalSection(&m_cs);

    DebugTrace((LPARAM)this, "m_pConn: %08lx", (CBatchLdapConnection *)m_pConn);

    if(pConn != m_pConn) {

        DebugTrace((LPARAM)this, "Connection already invalidated");
        //
        // We have already invalidated this connection
        //
        LeaveCriticalSection(&m_cs);
        hr = S_OK;
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Invalidating conn %08lx",
               (CBatchLdapConnection *)m_pConn);

    pOldConn = m_pConn;
    pOldConn->Invalidate();

    dwcCompletedLookups = (DWORD) InterlockedExchange((LPLONG) &m_dwcCompletedLookups, 0);
    
    if( fIncrementRetryCount ) {

        if( dwcCompletedLookups > 0 ) {

            InterlockedExchange((LPLONG) &m_dwcRetries, 0);
            dwcRetries = 0;

        } else {

            dwcRetries = (DWORD) InterlockedIncrement((LPLONG) &m_dwcRetries);
        }

    } else {

        dwcRetries = 0;

    }

    if( dwcRetries > CBatchLdapConnection::m_nMaxConnectionRetries ) {

        LogSLRCFailure(CBatchLdapConnection::m_nMaxConnectionRetries, pOldConn->GetHostName());

        ErrorTrace((LPARAM)this, "Over max retry limit");

        LeaveCriticalSection(&m_cs);

        pOldConn->CancelAllSearches();

        hr = CAT_E_MAX_RETRIES;
        goto CLEANUP;

    } else {

        hr = m_pStore->HrGetConnection(
            &pNewConn);

        if(FAILED(hr)) {
            LeaveCriticalSection(&m_cs);
            ERROR_LOG("m_pStore->HrGetConnection");

            pOldConn->CancelAllSearches();

            goto CLEANUP;
        }

        LogSLRCFailover(dwcRetries, pOldConn->GetHostName(), pNewConn->GetHostName());

        DebugTrace((LPARAM)this, "pNewConn: %08lx", pNewConn);

        //
        // Switch-a-roo
        //
        m_pConn = pNewConn;

        DebugTrace((LPARAM)this, "m_dwcInsertionContext: %08lx",
                   m_dwcInsertionContext);
        //
        // Get insertion contexts on the new connection
        //
        dwcInsertionContext = m_dwcInsertionContext;

        for(dwCount = 0;
            dwCount < dwcInsertionContext;
            dwCount++) {

            pNewConn->GetInsertionContext();
        }
        LeaveCriticalSection(&m_cs);

        pOldConn->CancelAllSearches();

        //
        // Release insertion contexts on the old connection
        //
        for(dwCount = 0;
            dwCount < dwcInsertionContext;
            dwCount++) {

            pOldConn->ReleaseInsertionContext();
        }

        pOldConn->Release();
    }
 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreListResolveContext::HrInvalidateConnectionAndRetrieveNewConnection



//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::HrInsertInsertionRequest
//
// Synopsis: Queues an insertion request
//
// Arguments: pCInsertionRequest: the insertion context to queue up
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/24 16:51:10: Created.
//
//-------------------------------------------------------------
HRESULT CBatchLdapConnection::HrInsertInsertionRequest(
    CInsertionRequest *pCInsertionRequest)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CBatchLdapConnection::HrInsertInsertionRequest");

    //
    // Add this thing to the queue and then call
    // DecrementPendingSearches to dispatch available requests
    //
    pCInsertionRequest->AddRef();
    
    if ( pCInsertionRequest->IsBatchable() )
        GetInsertionContext();

    AcquireSpinLock(&m_spinlock_insertionrequests);

    if( IsValid() ) {
        
        InsertTailList(&m_listhead_insertionrequests,
                    &(pCInsertionRequest->m_listentry_insertionrequest));
    } else {

        hr = CAT_E_DBCONNECTION;
    }

    ReleaseSpinLock(&m_spinlock_insertionrequests);

    if(hr == CAT_E_DBCONNECTION) {

        ERROR_LOG("IsValid");
    }

    if( hr == S_OK ) {

        DecrementPendingSearches(0); // Decrement zero searches
    } else {

        if ( pCInsertionRequest->IsBatchable() )
            ReleaseInsertionContext();
            
        pCInsertionRequest->Release();
    }

    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CBatchLdapConnection::HrInsertInsertionRequest


//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::DecrementPendingSearches
//
// Synopsis: Decrement the pending LDAP search count and issue
//           searches if we are below MAX_PENDING_SEARCHES and items
//           are left in the InsertionRequestQueue
//
// Arguments:
//  dwcSearches: Amount to decrement by
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/24 17:09:38: Created.
//
//-------------------------------------------------------------
VOID CBatchLdapConnection::DecrementPendingSearches(
    DWORD dwcSearches)
{
    HRESULT hr;
    DWORD dwcSearchesToDecrement = dwcSearches;
    DWORD dwcSearchesReserved;
    CInsertionRequest *pCInsertionRequest = NULL;
    BOOL fLoop = TRUE;
    CANCELNOTIFY cn;
    BOOL fDispatchBlocks = FALSE;
    DWORD dwMinimumRequiredSearches = 1;

    CatFunctEnterEx((LPARAM)this, "CBatchLdapConnection::DecrementPendingSearches");

    //
    // The module that calls us (CStoreListResolve) has a reference to
    // us (obviously).  However, it may release us when a search
    // fails, for example inside of
    // pCInsertionRequest->HrInsertSearches().  Since we need to
    // continue to access member data in this situation, AddRef() here
    // and Release() at the end of this function.
    //
    AddRef();

    //
    // Decrement the count first
    //
    AcquireSpinLock(&m_spinlock_insertionrequests);
    
    m_dwcPendingSearches -= dwcSearchesToDecrement;
    
    if (m_fDPS_Was_Here) {
        fLoop = FALSE;
    } else {
        m_fDPS_Was_Here = TRUE;
    }
    
    ReleaseSpinLock(&m_spinlock_insertionrequests);
    //
    // Now dispatch any insertion requests we can dispatch
    //
    while(fLoop) {

        pCInsertionRequest = NULL;
        AcquireSpinLock(&m_spinlock_insertionrequests);

        if( IsValid() &&
            (m_dwcPendingSearches < m_nMaxPendingSearches) &&
            (!IsListEmpty(&m_listhead_insertionrequests)) ) {

            dwcSearchesReserved = m_nMaxPendingSearches - m_dwcPendingSearches;

            pCInsertionRequest = CONTAINING_RECORD(
                m_listhead_insertionrequests.Flink,
                CInsertionRequest,
                m_listentry_insertionrequest);
                
            _ASSERT(pCInsertionRequest);
            
            dwMinimumRequiredSearches = pCInsertionRequest->GetMinimumRequiredSearches();
            _ASSERT(dwMinimumRequiredSearches > 0);
            
            if(dwMinimumRequiredSearches > m_nMaxPendingSearches) {
                dwMinimumRequiredSearches = m_nMaxPendingSearches;
            }
            
            if(m_dwcPendingSearches + dwMinimumRequiredSearches > m_nMaxPendingSearches) {
            
                pCInsertionRequest = NULL;
                fDispatchBlocks = TRUE;
                
            } else {

                RemoveEntryList(m_listhead_insertionrequests.Flink);
                //
                // Insert a cancel-Notify structure so that we know if we
                // should cancel this insertion request (ie. not reinsert)
                //
                cn.hrCancel = S_OK;
                InsertTailList(&m_listhead_cancelnotifies, &(cn.le));
            }
        }
        
        if(!pCInsertionRequest) {
            //
            // There are no requests or no room to insert
            // requests...Break out of the loop
            //
            fLoop = FALSE;
            m_fDPS_Was_Here = FALSE;
        }
        
        ReleaseSpinLock(&m_spinlock_insertionrequests);

        if(pCInsertionRequest) {
            //
            // Dispatch up to dwcSearchesReserved searches
            //
            hr = pCInsertionRequest->HrInsertSearches(dwcSearchesReserved);

            if(FAILED(hr)) {
            
                if(FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))) {

                    ERROR_LOG("pCInsertionRequest->HrInsertSearches");
                }
 
                pCInsertionRequest->NotifyDeQueue(hr);

                if ( pCInsertionRequest->IsBatchable() )
                    ReleaseInsertionContext();

                pCInsertionRequest->Release();
                
                AcquireSpinLock(&m_spinlock_insertionrequests);
                //
                // Remove the cancel notify
                //
                RemoveEntryList(&(cn.le));
                ReleaseSpinLock(&m_spinlock_insertionrequests);

            } else {
                //
                // There is more work to be done in this block; insert it
                // back into the queue
                //
                AcquireSpinLock(&m_spinlock_insertionrequests);
                //
                // Remove the cancel notify
                //
                RemoveEntryList(&(cn.le));

                //
                // If we are NOT cancelling, then insert back into the queue
                //
                if(cn.hrCancel == S_OK) {

                    InsertHeadList(&m_listhead_insertionrequests,
                                   &(pCInsertionRequest->m_listentry_insertionrequest));
                }
                ReleaseSpinLock(&m_spinlock_insertionrequests);

                //
                // If we are cancelling, then release this insertion request
                //
                if(cn.hrCancel != S_OK) {
                    pCInsertionRequest->NotifyDeQueue(cn.hrCancel);
                    
                    if ( pCInsertionRequest->IsBatchable() )
                        ReleaseInsertionContext();
                        
                    pCInsertionRequest->Release();
                    
                }
            }
        }
    }
    
    if(fDispatchBlocks) {
        //
        // X5:197905. We call DispatchBlocks now to avoid a deadlock where
        // there is a partially filled batch and there are batchable insertion
        // requests in the queue that prevent it from being dispatched, but
        // the next insertion request in the queue is not batchable and
        // requires a minimum number of searches that is greater than the max
        // pending will allow, given that some of the available searches are
        // (dormantly) consumed by the partially filled batch.
        //
        LIST_ENTRY listhead_dispatch;
        
        AcquireSpinLock(&m_spinlock);
        //
        // Remove all blocks from the insertion list and put them in the dispatch list
        //
        if(IsListEmpty(&m_listhead)) {
            //
            // No blocks
            //
            ReleaseSpinLock(&m_spinlock);
        } else {
            
            InsertTailList(&m_listhead, &listhead_dispatch);
            RemoveEntryList(&m_listhead);
            InitializeListHead(&m_listhead);

            ReleaseSpinLock(&m_spinlock);
            //
            // Dispatch all the blocks
            //
            DispatchBlocks(&listhead_dispatch);
        }
    }
    
    Release();
    CatFunctLeaveEx((LPARAM)this);
} // CBatchLdapConnection::DecrementPendingSearches



//+------------------------------------------------------------
//
// Function: CBatchLdapConnection::CancelAllSearches
//
// Synopsis: Cancels all outstanding searches
//
// Arguments:
//  hr: optinal reason for cancelling the searches
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/25 11:44:30: Created.
//
//-------------------------------------------------------------
VOID CBatchLdapConnection::CancelAllSearches(
    HRESULT hr)
{
    LIST_ENTRY listhead;
    PLIST_ENTRY ple;
    CInsertionRequest *pCInsertionRequest;

    CatFunctEnterEx((LPARAM)this, "CBatchLdapConnection::CancelAllSearches");

    _ASSERT(hr != S_OK);

    AcquireSpinLock(&m_spinlock_insertionrequests);
    //
    // Grab the list
    //
    if(!IsListEmpty(&m_listhead_insertionrequests)) {

        CopyMemory(&listhead, &m_listhead_insertionrequests, sizeof(LIST_ENTRY));
        listhead.Flink->Blink = &listhead;
        listhead.Blink->Flink = &listhead;
        InitializeListHead(&m_listhead_insertionrequests);

    } else {

        InitializeListHead(&listhead);
    }
    //
    // Traverse the cancel notify list and set each hresult
    //
    for(ple = m_listhead_cancelnotifies.Flink;
        ple != &m_listhead_cancelnotifies;
        ple = ple->Flink) {

        PCANCELNOTIFY pcn;
        pcn = CONTAINING_RECORD(ple, CANCELNOTIFY, le);
        pcn->hrCancel = hr;
    }

    ReleaseSpinLock(&m_spinlock_insertionrequests);

    CCachedLdapConnection::CancelAllSearches(hr);

    for(ple = listhead.Flink;
        ple != &listhead;
        ple = listhead.Flink) {

        pCInsertionRequest = CONTAINING_RECORD(
            ple,
            CInsertionRequest,
            m_listentry_insertionrequest);

        RemoveEntryList(&(pCInsertionRequest->m_listentry_insertionrequest));
        pCInsertionRequest->NotifyDeQueue(hr);
        
        if (pCInsertionRequest->IsBatchable() )
            ReleaseInsertionContext();
        
        pCInsertionRequest->Release();
    }

    CatFunctLeaveEx((LPARAM)this);
} // CBatchLdapConnection::CancelAllSearches


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::GetConnection
//
// Synopsis: AddRef/return the current connection
//
// Arguments: NONE
//
// Returns: Connection pointer
//
// History:
// jstamerj 1999/06/21 12:14:50: Created.
//
//-------------------------------------------------------------
CCfgConnection * CStoreListResolveContext::GetConnection()
{
    CCfgConnection *ret;
    EnterCriticalSection(&m_cs);
    ret = m_pConn;
    if(ret)
        ret->AddRef();
    LeaveCriticalSection(&m_cs);
    return ret;
} // CStoreListResolveContext::GetConnection


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::GetInsertionContext
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/21 12:16:38: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::GetInsertionContext()
{
    EnterCriticalSection(&m_cs);
    InterlockedIncrement((PLONG) &m_dwcInsertionContext);
    m_pConn->GetInsertionContext();
    LeaveCriticalSection(&m_cs);
} // CStoreListResolveContext::GetInsertionContext

//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::ReleaseInsertionContext
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/21 12:16:48: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::ReleaseInsertionContext()
{
    EnterCriticalSection(&m_cs);
    InterlockedDecrement((PLONG) &m_dwcInsertionContext);
    m_pConn->ReleaseInsertionContext();
    LeaveCriticalSection(&m_cs);

} // CStoreListResolveContext::ReleaseInsertionContext


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::HrInsertInsertionRequest
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/21 12:20:19: Created.
//
//-------------------------------------------------------------
HRESULT CStoreListResolveContext::HrInsertInsertionRequest(
    CInsertionRequest *pCInsertionRequest)
{
    HRESULT hr = S_OK;
    BOOL fTryAgain;
    CatFunctEnterEx((LPARAM)this,
                    "CStoreListResolveContext::HrInsertInsertionRequest");

    do {

        fTryAgain = FALSE;
        CBatchLdapConnection *pConn;

        pConn = GetConnection();

        //
        // Insert the search request into the CBatchLdapConnection
        // object. We will use the email address as the distinguishing
        // attribute
        //
        if( pConn == NULL ) {

            hr = CAT_E_DBCONNECTION;
            if(FAILED(hr)) {
                ERROR_LOG("GetConnection");
            }

        } else {

            hr = m_pConn->HrInsertInsertionRequest(pCInsertionRequest);
            if(FAILED(hr)) {
                ERROR_LOG("m_pConn->HrInsertInsertionRequest");
            }
        }
        //
        // Attempt to reconnect.
        //
        if( hr == CAT_E_DBCONNECTION ) {

            HRESULT hrTryAgain = S_OK;

            hrTryAgain =
                HrInvalidateConnectionAndRetrieveNewConnection(pConn, FALSE);
            fTryAgain = SUCCEEDED(hrTryAgain);

            if(FAILED(hrTryAgain)) {
                //
                // Declare a new local called hr here because the
                // ERROR_LOG macro uses it
                //
                HRESULT hr = hrTryAgain;
                ERROR_LOG("HrInvalidateConnectionAndRetrieveNewConnection");
            }
        }

        if(pConn != NULL)
            pConn->Release();

    } while(fTryAgain);

    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CStoreListResolveContext::HrInsertInsertionRequest



//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::LogSLRCFailure
//
// Synopsis: Log a failure for the SLRC (over max retry limit)
//
// Arguments:
//  dwcRetries: Number of times we've retried
//  pszHost: The last host that failed
//
// Returns: nothing
//
// History:
// jstamerj 2001/12/13 00:24:07: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::LogSLRCFailure(
    IN  DWORD dwcRetries,
    IN  LPSTR pszHost)
{
    LPCSTR rgSubStrings[2];
    CHAR szRetries[32];

    _snprintf(szRetries, sizeof(szRetries), "%d", dwcRetries);

    rgSubStrings[0] = szRetries;
    rgSubStrings[1] = pszHost;

    CatLogEvent(
        GetISMTPServerEx(),
        CAT_EVENT_SLRC_FAILURE,
        2,
        rgSubStrings,
        S_OK,
        pszHost,
        LOGEVENT_FLAG_ALWAYS,
        LOGEVENT_LEVEL_FIELD_ENGINEERING);
}


//+------------------------------------------------------------
//
// Function: CStoreListResolveContext::LogSLRCFailover
//
// Synopsis: Log a failover event
//
// Arguments:
//  dwcRetries: Number of retires so far
//  pszOldHost: Old LDAP host
//  pszNewHost: New LDAP host
//
// Returns: nothing
//
// History:
// jstamerj 2001/12/13 00:24:18: Created.
//
//-------------------------------------------------------------
VOID CStoreListResolveContext::LogSLRCFailover(
    IN  DWORD dwcRetries,
    IN  LPSTR pszOldHost,
    IN  LPSTR pszNewHost)
{
    LPCSTR rgSubStrings[3];
    CHAR szRetries[32];

    _snprintf(szRetries, sizeof(szRetries), "%d", dwcRetries);

    rgSubStrings[0] = pszOldHost;
    rgSubStrings[1] = pszNewHost;
    rgSubStrings[2] = szRetries;

    CatLogEvent(
        GetISMTPServerEx(),
        CAT_EVENT_SLRC_FAILOVER,
        3,
        rgSubStrings,
        S_OK,
        pszOldHost,
        LOGEVENT_FLAG_ALWAYS,
        LOGEVENT_LEVEL_FIELD_ENGINEERING);
}
//+------------------------------------------------------------
//
// Function: CSingleSearchReinsertionRequest::HrInsertSearches
//
// Synopsis: reinsert a request for a single search
//
// Arguments:
//  dwcSearches: Number of searches we may insert
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
//  dlongley 2001/10/22: Created.
//
//-------------------------------------------------------------
HRESULT CSingleSearchReinsertionRequest::HrInsertSearches(
    DWORD dwcSearches)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CSingleSearchReinsertionRequest::HrInsertSearches");

    if( (m_dwcSearches == 0) && (dwcSearches > 0) ) {

        hr = m_pslrc->HrLookupEntryAsync(m_pCCatAddr);

        if(FAILED(hr)) {
            ERROR_LOG_ADDR(m_pCCatAddr, "m_pslrc->HrLookupEntryAsync");
            m_hr = hr;
        } else {
            m_dwcSearches = 1;
        }

    }
    
    if(SUCCEEDED(hr))
        hr = (m_dwcSearches == 1 ? HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) : S_OK);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    
    return hr;
} // CSingleSearchReinsertionRequest::HrInsertSearches


//+------------------------------------------------------------
//
// Function: CSingleSearchReinsertionRequest::NotifyDeQueue
//
// Synopsis: Callback to notify us that our request is being removed
//           from the store's queue
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
//  dlongley 2001/10/22: Created.
//
//-------------------------------------------------------------
VOID CSingleSearchReinsertionRequest::NotifyDeQueue(
    HRESULT hrReason)
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this, "CSingleSearchReinsertionRequest::NotifyDeQueue");
    //
    // If we still have things left to resolve, reinsert this
    // insertion request
    //
    hr = hrReason;
    if( SUCCEEDED(m_hr) && (m_dwcSearches == 0) && !(m_pslrc->Canceled()) ) {

        if( (hr == CAT_E_DBCONNECTION) ||
            (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED)) ) {

            hr = m_pslrc->HrInsertInsertionRequest(this);
            if(FAILED(hr)) {
                ERROR_LOG_ADDR(m_pCCatAddr, "m_pslrc->HrInsertInsertionRequest");
            }
        }
    }

    CatFunctLeaveEx((LPARAM)this);
} // CSingleSearchReinsertionRequest::NotifyDeQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\asyncctx.h ===
//
// asyncctx.h -- This file contains the class definitions for:
//   CSearchRequestBlock
//   CBatchLdapConnection
//   CBatchLdapConnectionCache
//   CStoreListResolveContext
//   CSingleSearchReinsertionRequest
//
// Created:
//      Feb 19, 1997 -- Milan Shah (milans)
//
// Changes:
// jstamerj 1999/03/16 15:29:20: Heavily modified to batch requests
//                               togethor across multiple message
//                               categorizations
// jstamerj 1999/03/22 12:44:01: Modified to support throttling via a
//                               queue of CInsertionRequest objects
//
// dlongley 2001/10/22: Added CSingleSearchReinsertionRequest to force
//                      abandoned and reissued searches to be throttled
//                      via the CInsertionRequest object queue
//

#ifndef _ASYNCCTX_H_
#define _ASYNCCTX_H_

#include "ldapconn.h"
#include "ccataddr.h"
#include "simparray.h"
#include "icatqueries.h"
#include "icatasync.h"

class CBatchLdapConnectionCache;
class CCfgConnection;
template <class T> class CEmailIDLdapStore;

//
// The MCIS3 LDAP server beta 1 does not correctly handle queries with more
// than 4 legs in an OR clause. Because of this, we need to limit our search
// query compression on a configurable basis. The global value,
// nMaxSearchBlockSize constrains how many searches will be compressed into
// a single search. The value is read from the registry key
// szMaxSearchBlockSize. If it is not present, it defaults to
// MAX_SEARCH_BLOCK_SIZE.
//

#define MAX_SEARCH_BLOCK_SIZE_KEY "System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"

#define MAX_SEARCH_BLOCK_SIZE_VALUE "MaxSearchBlockSize"
#define MAX_SEARCH_BLOCK_SIZE   20

#define MAX_PENDING_SEARCHES_VALUE  "MaxPendingSearches"
#define MAX_PENDING_SEARCHES    60

#define MAX_CONNECTION_RETRIES_VALUE "MaxConnectionRetries"
#define MAX_CONNECTION_RETRIES  20

class CBatchLdapConnectionCache;
class CBatchLdapConnection;
class CStoreListResolveContext;

typedef VOID (*LPFNLIST_COMPLETION)(VOID *lpContext);

typedef VOID (*LPSEARCHCOMPLETION)(
    CCatAddr *pCCatAddr,
    CStoreListResolveContext *pslrc,
    CBatchLdapConnection *pConn);


//------------------------------------------------------------
//
// Class CSearchRequestBlock
//
//------------------------------------------------------------
CatDebugClass(CSearchRequestBlock) 
{
  private:
    typedef struct _SearchRequest {
        CCatAddr *pCCatAddr;
        LPSEARCHCOMPLETION fnSearchCompletion;
        CStoreListResolveContext *pslrc;
        LPSTR   pszSearchFilter;
        LPSTR   pszDistinguishingAttribute;
        LPSTR   pszDistinguishingAttributeValue;
    } SEARCH_REQUEST, *PSEARCH_REQUEST;

    #define SIGNATURE_CSEARCHREQUESTBLOCK           (DWORD)'lBRS'
    #define SIGNATURE_CSEARCHREQUESTBLOCK_INVALID   (DWORD)'lBRX'

  public:
    void * operator new(size_t size, DWORD dwNumRequests);
        
    CSearchRequestBlock(
        CBatchLdapConnection *pConn);

    ~CSearchRequestBlock();

    VOID InsertSearchRequest(
        ISMTPServer *pISMTPServer,
        ICategorizerParameters *pICatParams,
        CCatAddr *pCCatAddr,
        LPSEARCHCOMPLETION fnSearchCompletion,
        CStoreListResolveContext *pslrc,
        LPSTR   pszSearchFilter,
        LPSTR   pszDistinguishingAttribute,
        LPSTR   pszDistinguishingAttributeValue);

    VOID DispatchBlock();
    
    HRESULT ReserveSlot()
    {
        if( ((DWORD)InterlockedIncrement((PLONG)&m_cBlockRequestsReserved)) > m_cBlockSize)
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        else
            return S_OK;
    }

    HRESULT AddResults(
        DWORD dwNumResults,
        ICategorizerItemAttributes **rgpItemAttributes)
    {
        HRESULT hr;
        hr = m_csaItemAttr.AddArray(
            dwNumResults,
            rgpItemAttributes);

        if(SUCCEEDED(hr)) {
            //
            // AddRef all the interfaces we hold
            //
            for(DWORD dwCount = 0; dwCount < dwNumResults; dwCount++) {
                
                rgpItemAttributes[dwCount]->AddRef();
            }
        }
        return hr;
    }

  private:
    PSEARCH_REQUEST GetNextSearchRequest(DWORD *pdwIndex)
    {
        *pdwIndex = InterlockedIncrement((PLONG)&m_cBlockRequestsAllocated) - 1;
        _ASSERT(*pdwIndex < m_cBlockSize);
        
        return &(m_prgSearchRequests[*pdwIndex]);
    }

    VOID CompleteBlockWithError(HRESULT hr)
    {
        PutBlockHRESULT(hr);
        CallCompletions();
    }

    static VOID LDAPCompletion(
        LPVOID ctx,
        DWORD dwNumResults,
        ICategorizerItemAttributes **rgpICatItemAttributes,
        HRESULT hrStatus,
        BOOL fFinalCompletion);

    HRESULT HrTriggerBuildQueries();
    HRESULT HrTriggerSendQuery();

    static HRESULT HrBuildQueriesDefault(
        HRESULT HrStatus,
        PVOID   pContext);

    static HRESULT HrSendQueryDefault(
        HRESULT HrStatus,
        PVOID   pContext);

    static HRESULT HrSendQueryCompletion(
        HRESULT HrStatus,
        PVOID   pContext);

    VOID CompleteSearchBlock(
        HRESULT hrStatus);

    HRESULT HrTriggerSortQueryResult(
        HRESULT hrStatus);

    static HRESULT HrSortQueryResultDefault(
        HRESULT hrStatus,
        PVOID   pContext);

    VOID PutBlockHRESULT(
        HRESULT hr);

    VOID CallCompletions();

    VOID MatchItem(
        ICategorizerItem *pICatItem,
        ICategorizerItemAttributes *pICatItemAttr);

    DWORD DwNumBlockRequests()
    {
        return m_cBlockRequestsReadyForDispatch;
    }

    ISMTPServerEx * GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }
    VOID LogAmbiguousEvent(ICategorizerItem *pItem);

    DWORD m_dwSignature;
    ISMTPServer *m_pISMTPServer;
    ISMTPServerEx *m_pISMTPServerEx;
    ICategorizerParameters *m_pICatParams;
    DWORD m_cBlockRequestsReserved;
    DWORD m_cBlockRequestsAllocated;
    DWORD m_cBlockRequestsReadyForDispatch;
    DWORD m_cBlockSize;
    LIST_ENTRY m_listentry;
    PSEARCH_REQUEST m_prgSearchRequests;
    ICategorizerItem **m_rgpICatItems;
    CBatchLdapConnection *m_pConn;
    LPSTR m_pszSearchFilter;
    CICategorizerQueriesIMP m_CICatQueries;
    CICategorizerAsyncContextIMP m_CICatAsyncContext;
    CSimpArray<ICategorizerItemAttributes *> m_csaItemAttr;

    friend class CBatchLdapConnection;
    friend class CICategorizerAsyncContextIMP;
};
     
//------------------------------------------------------------
//
// Class CBatchLdapConnection
//
//------------------------------------------------------------
class CBatchLdapConnection : 
    public CLdapConnectionCache::CCachedLdapConnection
{
  private:
    #define SIGNATURE_CBATCHLDAPCONN            (DWORD)'oCLB'
    #define SIGNATURE_CBATCHLDAPCONN_INVALID    (DWORD)'oCLX'

  public:
    CBatchLdapConnection(
        LPSTR szHost,
        DWORD dwPort,
        LPSTR szNamingContext,
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        CLdapConnectionCache *pCache) :
        CCachedLdapConnection(
            szHost,
            dwPort,
            szNamingContext,
            szAccount,
            szPassword,
            bt,
            pCache)
    {
        m_dwSignature = SIGNATURE_CBATCHLDAPCONN;
        m_pInsertionBlock = NULL;
        InitializeListHead(&m_listhead);
        InitializeSpinLock(&m_spinlock);
        m_cInsertionContext = 0;
        if(m_nMaxSearchBlockSize == 0)
            InitializeFromRegistry();
        InitializeSpinLock(&m_spinlock_insertionrequests);
        m_dwcPendingSearches = 0;
        m_fDPS_Was_Here = FALSE;
        InitializeListHead(&m_listhead_insertionrequests);
        InitializeListHead(&m_listhead_cancelnotifies);
    }

    ~CBatchLdapConnection()
    {
        _ASSERT(m_dwSignature == SIGNATURE_CBATCHLDAPCONN);
        m_dwSignature = SIGNATURE_CBATCHLDAPCONN_INVALID;
        _ASSERT(m_dwcPendingSearches == 0);
    }
            
    CLdapConnection *GetConnection()
    {
        return( this );
    }

    VOID GetInsertionContext()
    {
        AcquireSpinLock(&m_spinlock);
        m_cInsertionContext++;
        ReleaseSpinLock(&m_spinlock);
    }
    
    VOID ReleaseInsertionContext()
    {
        AcquireSpinLock(&m_spinlock);
        if((--m_cInsertionContext) == 0) {

            LIST_ENTRY listhead_dispatch;
            //
            // Remove all blocks from the insertion list and put them in the dispatch list
            //
            if(IsListEmpty(&m_listhead)) {
                // No blocks
                ReleaseSpinLock(&m_spinlock);

                InitializeListHead(&listhead_dispatch);

            } else {
                
                CopyMemory(&listhead_dispatch, &m_listhead, sizeof(LIST_ENTRY));
                listhead_dispatch.Blink->Flink = &listhead_dispatch;
                listhead_dispatch.Flink->Blink = &listhead_dispatch;
                InitializeListHead(&m_listhead);

                ReleaseSpinLock(&m_spinlock);
                //
                // Dispatch all the blocks
                //
                DispatchBlocks(&listhead_dispatch);
            }

        } else {
            
            ReleaseSpinLock(&m_spinlock);
        }
    }

    HRESULT HrInsertSearchRequest(
        ISMTPServer *pISMTPServer,
        ICategorizerParameters *pICatParams,
        CCatAddr *pCCatAddr,
        LPSEARCHCOMPLETION fnSearchCompletion,
        CStoreListResolveContext *pslrc,
        LPSTR   pszSearchFilter,
        LPSTR   pszDistinguishingAttribute,
        LPSTR   pszDistinguishingAttributeValue);

    static VOID InitializeFromRegistry();

    VOID IncrementPendingSearches(DWORD dw = 1)
    {
        AcquireSpinLock(&m_spinlock_insertionrequests);
        m_dwcPendingSearches += dw;
        ReleaseSpinLock(&m_spinlock_insertionrequests);
    }
    VOID DecrementPendingSearches(DWORD dwcSearches = 1);

    HRESULT HrInsertInsertionRequest(
        CInsertionRequest *pCInsertionRequest);

    VOID CancelAllSearches(
        HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED));

  private:
    CSearchRequestBlock *GetSearchRequestBlock();

    VOID RemoveSearchRequestBlockFromList(
        CSearchRequestBlock *pBlock)
    {
        AcquireSpinLock(&m_spinlock);
        RemoveEntryList(&(pBlock->m_listentry));
        ReleaseSpinLock(&m_spinlock);
    }

    VOID DispatchBlocks(PLIST_ENTRY listhead);

  public:
    static DWORD m_nMaxConnectionRetries;

  private:
    static DWORD m_nMaxSearchBlockSize;
    static DWORD m_nMaxPendingSearches;

    DWORD m_dwSignature;
    LIST_ENTRY m_listhead;
    SPIN_LOCK m_spinlock;
    LONG m_cInsertionContext;
    CSearchRequestBlock *m_pInsertionBlock;

    SPIN_LOCK m_spinlock_insertionrequests;
    DWORD m_dwcPendingSearches;
    DWORD m_dwcReservedSearches;
    LIST_ENTRY m_listhead_insertionrequests;

    typedef struct _tagCancelNotify {
        LIST_ENTRY le;
        HRESULT hrCancel;
    } CANCELNOTIFY, *PCANCELNOTIFY;
    // This list is also protected by m_spinlock_insertionrequests
    LIST_ENTRY m_listhead_cancelnotifies;

    CExShareLock m_cancellock;
    BOOL m_fDPS_Was_Here;

    friend class CSearchRequestBlock;
};

//------------------------------------------------------------
//
// class CBatchLdapConnectionCache
//
//------------------------------------------------------------
class CBatchLdapConnectionCache : 
    public CLdapConnectionCache
{
  public:
    CBatchLdapConnectionCache(
        ISMTPServerEx *pISMTPServerEx) :
        CLdapConnectionCache(pISMTPServerEx)
    {
    }
    HRESULT GetConnection(
        CBatchLdapConnection **ppConn,
        LPSTR szHost,                 
        DWORD dwPort,
        LPSTR szNamingContext,        
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        PVOID pCreateContext = NULL)
    {
        return CLdapConnectionCache::GetConnection(
            (CLdapConnection **)ppConn,
            szHost,
            dwPort,
            szNamingContext,
            szAccount,
            szPassword,
            bt,
            pCreateContext);
    }

    CCachedLdapConnection *CreateCachedLdapConnection(
        LPSTR szHost,
        DWORD dwPort,
        LPSTR szNamingContext,
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        PVOID pCreateContext)
    {
        CCachedLdapConnection *pret;
        pret = new CBatchLdapConnection(
            szHost,
            dwPort,
            szNamingContext,
            szAccount,
            szPassword,
            bt,
            this);

        if(pret)
            if(FAILED(pret->HrInitialize())) {
                pret->Release();
                pret = NULL;
            }
        return pret;
    }
};

//------------------------------------------------------------
//
// class CStoreListResolveContext
//
//------------------------------------------------------------
CatDebugClass(CStoreListResolveContext)
{
  public:
    CStoreListResolveContext(CEmailIDLdapStore<CCatAddr> *pStore);    
    ~CStoreListResolveContext();

    VOID AddRef()
    {
        InterlockedIncrement((PLONG) &m_cRefs);
    }

    VOID Release()
    {
        if( InterlockedDecrement((PLONG) &m_cRefs) == 0 )
            delete this;
    }

    HRESULT HrInitialize(
        ISMTPServer *pISMTPServer,
        ICategorizerParameters *pICatParams);
        
    HRESULT HrLookupEntryAsync(
        CCatAddr *pCCatAddr);
    VOID Cancel();

    CCfgConnection *GetConnection();

    VOID GetInsertionContext();
    VOID ReleaseInsertionContext();
    HRESULT HrInsertInsertionRequest(
        CInsertionRequest *pCInsertionRequest);

    ISMTPServerEx * GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }
        
    BOOL Canceled() {
        return m_fCanceled;
    }
    
    HRESULT HrInvalidateConnectionAndRetrieveNewConnection(
        CBatchLdapConnection *pConn,
        BOOL fIncrementRetryCount = TRUE);
    
  private:
    static VOID AsyncLookupCompletion(
        CCatAddr *pCCatAddr,
        CStoreListResolveContext *pslrc,
        CBatchLdapConnection *pConn);

    VOID LogSLRCFailover(
        IN  DWORD dwcRetries,
        IN  LPSTR pszOldHost,
        IN  LPSTR pszNewHost);

    VOID LogSLRCFailure(
        IN  DWORD dwcRetries,
        IN  LPSTR pszHost);

  private:
    #define SIGNATURE_CSTORELISTRESOLVECONTEXT          (DWORD)'CRLS'
    #define SIGNATURE_CSTORELISTRESOLVECONTEXT_INVALID  (DWORD)'XRLS'

    DWORD m_cRefs;
    DWORD m_dwSignature;
    CCfgConnection *m_pConn;
    
    CRITICAL_SECTION m_cs;
    DWORD m_dwcInsertionContext;
    BOOL  m_fCanceled;
    DWORD m_dwcRetries;
    DWORD m_dwcCompletedLookups;
    ISMTPServer *m_pISMTPServer;
    ISMTPServerEx *m_pISMTPServerEx;
    ICategorizerParameters *m_pICatParams;
    CEmailIDLdapStore<CCatAddr> *m_pStore;
};
    

inline CSearchRequestBlock::CSearchRequestBlock(
    CBatchLdapConnection *pConn) :
    m_CICatQueries( &m_pszSearchFilter )
{
    _ASSERT(m_dwSignature == SIGNATURE_CSEARCHREQUESTBLOCK);
    m_pISMTPServer = NULL;
    m_pISMTPServerEx = NULL;
    m_pICatParams = NULL;
    m_pszSearchFilter = NULL;
    m_cBlockRequestsReserved = 0;
    m_cBlockRequestsAllocated = 0;
    m_cBlockRequestsReadyForDispatch = 0;
    m_pConn = pConn;
    m_pConn->AddRef();
}            

//------------------------------------------------------------
//
// class CSingleSearchReinsertionRequest
//
//------------------------------------------------------------
CatDebugClass(CSingleSearchReinsertionRequest),
    public CInsertionRequest
{
  public:
    HRESULT HrInsertSearches(
        DWORD dwcSearches);

    VOID NotifyDeQueue(
        HRESULT hr);

    #define SIGNATURE_CSingleSearchReinsertionRequest          (DWORD)'qRIS'
    #define SIGNATURE_CSingleSearchReinsertionRequest_INVALID  (DWORD)'XRIS'

    CSingleSearchReinsertionRequest(
        CStoreListResolveContext *pslrc,
        CCatAddr *pCCatAddr)
    {
        m_dwSignature = SIGNATURE_CSingleSearchReinsertionRequest;
        m_hr = S_OK;
        m_dwcSearches = 0;

        m_pslrc = pslrc;

        m_pCCatAddr = pCCatAddr;
        m_pCCatAddr->AddRef();
    }
    ~CSingleSearchReinsertionRequest()
    {
        if(!m_dwcSearches)
            m_pCCatAddr->LookupCompletion();

        m_pCCatAddr->Release();

        _ASSERT(m_dwSignature == SIGNATURE_CSingleSearchReinsertionRequest);
        m_dwSignature = SIGNATURE_CSingleSearchReinsertionRequest_INVALID;
    }
    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pslrc->GetISMTPServerEx();
    }

  private:
    DWORD m_dwSignature;
    HRESULT m_hr;
    DWORD m_dwcSearches;
    CStoreListResolveContext *m_pslrc;
    CCatAddr *m_pCCatAddr;
};

#endif _ASYNCCTX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\cnfgmgr.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: cnfgmgr.cpp
//
// Contents: Implementation of the classes defined in cnfgmgr.h
//
// Classes:
//  CLdapCfgMgr
//  CLdapCfg
//  CLdapHost
//  CCfgConnectionCache
//  CCfgConnection
//
// Functions:
//
// History:
// jstamerj 1999/06/16 14:41:45: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "cnfgmgr.h"

//
// Globals
//
CExShareLock CLdapServerCfg::m_listlock;
LIST_ENTRY   CLdapServerCfg::m_listhead;

DWORD CLdapServerCfg::m_dwCostConnectedLocal = DEFAULT_COST_CONNECTED_LOCAL;
DWORD CLdapServerCfg::m_dwCostConnectedRemote = DEFAULT_COST_CONNECTED_REMOTE;
DWORD CLdapServerCfg::m_dwCostInitialLocal = DEFAULT_COST_INITIAL_LOCAL;
DWORD CLdapServerCfg::m_dwCostInitialRemote = DEFAULT_COST_INITIAL_REMOTE;
DWORD CLdapServerCfg::m_dwCostRetryLocal = DEFAULT_COST_RETRY_LOCAL;
DWORD CLdapServerCfg::m_dwCostRetryRemote = DEFAULT_COST_RETRY_REMOTE;


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::CLdapCfgMgr
//
// Synopsis: Initialize member data
//
// Arguments: Optional:
//  fAutomaticConfigUpdate: TRUE indicates that the object is to
//                          periodicly automaticly update the list of
//                          GCs.
//                          FALSE disables this functionality
//
//  bt: Default bindtype to use
//  pszAccount: Default account for LDAP bind
//  pszPassword: Password of above account
//  pszNamingContext: Naming context to use for all LDAP searches
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/16 14:42:39: Created.
//
//-------------------------------------------------------------
CLdapCfgMgr::CLdapCfgMgr(
    ISMTPServerEx           *pISMTPServerEx,
    BOOL                    fAutomaticConfigUpdate,
    ICategorizerParameters  *pICatParams,
    LDAP_BIND_TYPE          bt,
    LPSTR                   pszAccount,
    LPSTR                   pszPassword,
    LPSTR                   pszNamingContext) : m_LdapConnectionCache(pISMTPServerEx)
{
    CatFunctEnterEx((LPARAM)this, "CLdapCfgMgr::CLdapCfgMgr");

    m_dwSignature = SIGNATURE_CLDAPCFGMGR;
    m_pCLdapCfg = NULL;
    ZeroMemory(&m_ulLastUpdateTime, sizeof(m_ulLastUpdateTime));
    m_dwUpdateInProgress = FALSE;
    m_fAutomaticConfigUpdate = fAutomaticConfigUpdate;
    m_pISMTPServerEx = pISMTPServerEx;
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->AddRef();

    //
    // Copy default
    //
    m_bt = bt;
    if(pszAccount)
        lstrcpyn(m_szAccount, pszAccount, sizeof(m_szAccount));
    else
        m_szAccount[0] = '\0';

    if(pszPassword)
        lstrcpyn(m_szPassword, pszPassword, sizeof(m_szPassword));
    else
        m_szPassword[0] = '\0';

    if(pszNamingContext)
        lstrcpyn(m_szNamingContext, pszNamingContext, sizeof(m_szNamingContext));
    else
        m_szNamingContext[0] = '\0';

    m_pICatParams = pICatParams;
    m_pICatParams->AddRef();

    m_LdapConnectionCache.AddRef();

    m_dwRebuildGCListMaxInterval = DEFAULT_REBUILD_GC_LIST_MAX_INTERVAL;
    m_dwRebuildGCListMaxFailures = DEFAULT_REBUILD_GC_LIST_MAX_FAILURES;
    m_dwRebuildGCListMinInterval = DEFAULT_REBUILD_GC_LIST_MIN_INTERVAL;

    InitializeFromRegistry();

    CatFunctLeaveEx((LPARAM)this);
} // CLdapCfgMgr::CLdapCfgMgr

//+----------------------------------------------------------------------------
//
//  Function:   CLdapCfgMgr::InitializeFromRegistry
//
//  Synopsis:   Helper function that looks up parameters from the registry.
//              Configurable parameters are:
//                  REBUILD_GC_LIST_MAX_INTERVAL_VALUE
//                  REBUILD_GC_LIST_MAX_FAILURES_VALUE
//                  REBUILD_GC_LIST_MIN_INTERVAL_VALUE
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------
VOID CLdapCfgMgr::InitializeFromRegistry()
{
    HKEY hkey;
    DWORD dwErr, dwType, dwValue, cbValue;

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, REBUILD_GC_LIST_PARAMETERS_KEY, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    REBUILD_GC_LIST_MAX_INTERVAL_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD && dwValue > 0) {
            m_dwRebuildGCListMaxInterval = dwValue;
        }

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    REBUILD_GC_LIST_MAX_FAILURES_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD && dwValue > 0) {
            m_dwRebuildGCListMaxFailures = dwValue;
        }

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    REBUILD_GC_LIST_MIN_INTERVAL_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD && dwValue > 0) {
            m_dwRebuildGCListMinInterval = dwValue;
        }

        RegCloseKey( hkey );

    }

}


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::~CLdapCfgMgr
//
// Synopsis: Release member data/pointers
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/16 14:44:28: Created.
//
//-------------------------------------------------------------
CLdapCfgMgr::~CLdapCfgMgr()
{
    CatFunctEnterEx((LPARAM)this, "CLdapCfgMgr::~CLdapCfgMgr");

    if(m_pCLdapCfg) {
        //
        // Release it
        //
        m_pCLdapCfg->Release();
        m_pCLdapCfg = NULL;
    }

    if(m_pICatParams) {

        m_pICatParams->Release();
        m_pICatParams = NULL;
    }
    //
    // This will not return until all ldap connections have been released/destroyed
    //
    m_LdapConnectionCache.Release();

    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    _ASSERT(m_dwSignature == SIGNATURE_CLDAPCFGMGR);
    m_dwSignature = SIGNATURE_CLDAPCFGMGR_INVALID;

    CatFunctLeaveEx((LPARAM)this);
} // CLdapCfgMgr::~CLdapCfgMgr



//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrInit
//
// Synopsis: Initialize with a list of available GCs
//
// Arguments:
//  fRediscoverGCs: TRUE: pass in the force rediscovery flag to DsGetDcName
//                  FALSE: Attempt to call DsGetDcName first without
//                         passing in the force rediscovery flag.
//
// Returns:
//  S_OK: Success
//  error from NT5 (DsGetDcName)
//  CAT_E_NO_GC_SERVERS: THere are no GC servers available to build
//                       the list of GCs
//
// History:
// jstamerj 1999/06/16 14:48:11: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrInit(
    BOOL fRediscoverGCs)
{
    HRESULT hr = S_OK;
    DWORD dwcServerConfig = 0;
    DWORD dwCount = 0;
    PLDAPSERVERCONFIG prgServerConfig = NULL;
    ICategorizerLdapConfig *pICatLdapConfigInterface = NULL;
    ICategorizerParametersEx *pIPhatCatParams = NULL;

    CatFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrInit");

    if(m_pICatParams)
    {
        hr = m_pICatParams->QueryInterface(IID_ICategorizerParametersEx, (LPVOID *)&pIPhatCatParams);
        _ASSERT(SUCCEEDED(hr) && "Unable to get phatcatparams interface");

        pIPhatCatParams->GetLdapConfigInterface(&pICatLdapConfigInterface);
    }

    if(pICatLdapConfigInterface)
    {
        DebugTrace((LPARAM)this, "Getting GC list from sink supplied interface");
        //
        // Get GC servers from sink supplied interface
        //
        hr = HrGetGCServers(
            pICatLdapConfigInterface,
            m_bt,
            m_szAccount,
            m_szPassword,
            m_szNamingContext,
            &dwcServerConfig,
            &prgServerConfig);
        if(FAILED(hr))
        {
            ERROR_LOG("HrGetGCServers");
            hr = CAT_E_NO_GC_SERVERS;
            goto CLEANUP;
        }
    } 
    else 
    {
        DebugTrace((LPARAM)this, "Getting internal GC list");
        //
        // Build an array of server configs consisting of available GCs
        //
        hr = HrBuildGCServerArray(
            m_bt,
            m_szAccount,
            m_szPassword,
            m_szNamingContext,
            fRediscoverGCs,
            &dwcServerConfig,
            &prgServerConfig);

        if(FAILED(hr)) 
        {
            ERROR_LOG("HrBuildGCServerArray");
            if(fRediscoverGCs == FALSE) 
            {
                //
                // Attempt to build the array again.  This time, force
                // rediscovery of available GCs.  This is expensive which is
                // why we initially try to find all available GCs without
                // forcing rediscovery.
                //
                hr = HrBuildGCServerArray(
                    m_bt,
                    m_szAccount,
                    m_szPassword,
                    m_szNamingContext,
                    TRUE,              // fRediscoverGCs
                    &dwcServerConfig,
                    &prgServerConfig);

                if(FAILED(hr)) 
                {
                    ERROR_LOG("HrBuildGCServerArray - 2nd time");
                    hr = CAT_E_NO_GC_SERVERS;
                    goto CLEANUP;
                }
            } 
            else 
            {
                //
                // We already forced rediscovery and failed
                //
                hr = CAT_E_NO_GC_SERVERS;
                goto CLEANUP;
            }
        }
    }

    LogCnfgInit();
    for(dwCount = 0; dwCount < dwcServerConfig; dwCount++)
    {
        LogCnfgEntry(& (prgServerConfig[dwCount]));
    }

    if(dwcServerConfig == 0) 
    {
        ErrorTrace((LPARAM)this, "No GC servers found.");
        ERROR_LOG("--dwcServerConfig == 0 --");
        hr = CAT_E_NO_GC_SERVERS;
        goto CLEANUP;
    }
    //
    // Call the other init function with the array
    //
    hr = HrInit(
        dwcServerConfig,
        prgServerConfig);
    ERROR_CLEANUP_LOG("HrInit");

 CLEANUP:
    if(pIPhatCatParams)
        pIPhatCatParams->Release();

    if(prgServerConfig != NULL)
        delete prgServerConfig;

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrInit


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrGetGCServers
//
// Synopsis: Get the list of GCs from dsaccess.dll
//
// Arguments:
//  bt: Bind type to use for each server
//  pszAccount: Account to use for each server
//  pszPassword: password of above account
//  pszNamingContext: naming context to use for each server
//  fRediscoverGCs: Attempt to rediscover GCs -- this is expensive and should
//                  only be TRUE after the function has failed once
//  pdwcServerConfig: Out parameter for the size of the array
//  pprgServerConfig: Out parameter for the array pointer -- this
//                    should be free'd with the delete operator
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_NO_GC_SERVERS: There are no available GC servers to build
//                       the list of GCs
//  error from ntdsapi
//
// History:
// jstamerj 1999/07/01 17:53:02: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrGetGCServers(
    IN  ICategorizerLdapConfig *pICatLdapConfigInterface,
    IN  LDAP_BIND_TYPE bt,
    IN  LPSTR pszAccount,
    IN  LPSTR pszPassword,
    IN  LPSTR pszNamingContext,
    OUT DWORD *pdwcServerConfig,
    OUT PLDAPSERVERCONFIG *pprgServerConfig)
{
    HRESULT hr = S_OK;
    DWORD dwNumGCs = 0;
    DWORD dwIdx = 0;
    IServersListInfo *pIServersList = NULL;

    CatFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrBuildArrayFromDCInfo");

    _ASSERT(pdwcServerConfig);
    _ASSERT(pprgServerConfig);
    _ASSERT(m_pICatParams);

    *pdwcServerConfig = 0;

    hr = pICatLdapConfigInterface->GetGCServers(&pIServersList);
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Unable to get the list of GC servers");
        //$$BUGBUG: Why are we asserting here?
        _ASSERT(0 && "Failed to get GC servers!");
        ERROR_LOG("pICatLdapConfigInterface->GetGCServers");
        goto CLEANUP;
    }

    hr = pIServersList->GetNumGC(&dwNumGCs);
    _ASSERT(SUCCEEDED(hr) && "GetNumGC should always succeed!");

    DebugTrace((LPARAM)this, "Got %d GCs", dwNumGCs);
    if(dwNumGCs == 0) {

        DebugTrace((LPARAM)this, "There are no GC servers");
        hr = CAT_E_NO_GC_SERVERS;
        ERROR_LOG("--dwNumGCs == 0 --");
        goto CLEANUP;
    }
    //
    // Allocate array
    //
    *pprgServerConfig = new LDAPSERVERCONFIG[dwNumGCs];

    if(*pprgServerConfig == NULL) {

        ErrorTrace((LPARAM)this, "Out of memory allocating array of %d LDAPSERVERCONFIGs", dwNumGCs);
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new LDAPSERVERCONFIG[]");
        goto CLEANUP;
    }
    //
    // Fill in LDAPSERVERCONFIG structures
    //
    for(dwIdx = 0; dwIdx < dwNumGCs; dwIdx++) {

        PLDAPSERVERCONFIG pServerConfig;
        LPSTR pszName = NULL;

        pServerConfig = &((*pprgServerConfig)[dwIdx]);
        //
        // Copy bindtype, account, password, naming context
        //
        pServerConfig->bt = bt;

        if(pszNamingContext)
            lstrcpyn(pServerConfig->szNamingContext, pszNamingContext,
                     sizeof(pServerConfig->szNamingContext));
        else
            pServerConfig->szNamingContext[0] = '\0';

        if(pszAccount)
            lstrcpyn(pServerConfig->szAccount, pszAccount,
                     sizeof(pServerConfig->szAccount));
        else
            pServerConfig->szAccount[0] = '\0';

        if(pszPassword)
            lstrcpyn(pServerConfig->szPassword, pszPassword,
                     sizeof(pServerConfig->szPassword));
        else
            pServerConfig->szPassword[0] = '\0';

        //
        // Initialize priority and TCP port
        //
        pServerConfig->pri = 0;

        hr = pIServersList->GetItem(
                    dwIdx,
                    &pServerConfig->dwPort,
                    &pszName);
        //
        //$$BUGBUG: Why should this always succeed?  It is a sink
        // supplied interface, isn't it?  If the last call fails, we
        // will set *pdwcServerConfig below, but free the array.
        //
        _ASSERT(SUCCEEDED(hr) && "GetItem should always succeed");

        //
        // Copy the name
        //
        lstrcpyn(pServerConfig->szHost, pszName,
                sizeof(pServerConfig->szHost));

        DebugTrace((LPARAM)this, "GC: %s on Port: %d", pServerConfig->szHost, pServerConfig->dwPort);
    }
    //
    // Set the out parameter for the array size
    //
    *pdwcServerConfig = dwNumGCs;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Free the allocated array if we're failing
        //
        if(*pprgServerConfig) {
            delete *pprgServerConfig;
            *pprgServerConfig = NULL;
        }
    }

    if(pIServersList)
        pIServersList->Release();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrBuildArrayFromDCInfo

//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrBuildGCServerArray
//
// Synopsis: Allocate/build an array of LDAPSERVERCONFIG structures --
//           one for each available GC
//
// Arguments:
//  bt: Bind type to use for each server
//  pszAccount: Account to use for each server
//  pszPassword: password of above account
//  pszNamingContext: naming context to use for each server
//  fRediscoverGCs: Attempt to rediscover GCs -- this is expensive and should
//                  only be TRUE after the function has failed once
//  pdwcServerConfig: Out parameter for the size of the array
//  pprgServerConfig: Out parameter for the array pointer -- this
//                    should be free'd with the delete operator
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_NO_GC_SERVERS: There are no available GC servers to build
//                       the list of GCs
//  error from ntdsapi
//
// History:
// jstamerj 1999/07/01 17:53:02: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrBuildGCServerArray(
    IN  LDAP_BIND_TYPE bt,
    IN  LPSTR pszAccount,
    IN  LPSTR pszPassword,
    IN  LPSTR pszNamingContext,
    IN  BOOL  fRediscoverGCs,
    OUT DWORD *pdwcServerConfig,
    OUT PLDAPSERVERCONFIG *pprgServerConfig)
{
    HRESULT                         hr = S_OK;
    DWORD                           dwErr;
    ULONG                           ulFlags;
    PDOMAIN_CONTROLLER_INFO         pDCInfo = NULL;
    HANDLE                          hDS = INVALID_HANDLE_VALUE;
    DWORD                           cDSDCInfo;
    PDS_DOMAIN_CONTROLLER_INFO_2    prgDSDCInfo = NULL;

    CatFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrBuildGCServerArray");
    //
    // Find one GC using DsGetDcName()
    //
    ulFlags = DS_DIRECTORY_SERVICE_REQUIRED | DS_GC_SERVER_REQUIRED;
    if(fRediscoverGCs)
        ulFlags |= DS_FORCE_REDISCOVERY;

    dwErr = DsGetDcName(
        NULL,    // Computername to process this function -- local computer
        NULL,    // Domainname -- primary domain of this computer
        NULL,    // Domain GUID
        NULL,    // Sitename -- site of this computer
        ulFlags, // Flags; we want a GC
        &pDCInfo); // Out parameter for the returned info

    hr = HRESULT_FROM_WIN32(dwErr);

    if(FAILED(hr)) {

        ERROR_LOG("DGetDcName");
        //
        // Map one error code
        //
        if(hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN))
            hr = CAT_E_NO_GC_SERVERS;

        pDCInfo = NULL;
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Binding to DC %s",
               pDCInfo->DomainControllerName);

    //
    // Bind to the DC
    //
    dwErr = DsBind(
        pDCInfo->DomainControllerName,    // DomainControllerAddress
        NULL,                             // DnsDomainName
        &hDS);                           // Out param -- handle to DS

    hr = HRESULT_FROM_WIN32(dwErr);

    if(FAILED(hr)) {

        ERROR_LOG("DsBind");
        hDS = INVALID_HANDLE_VALUE;
        goto CLEANUP;
    }

    //
    //  Prefix says we need to check this case too
    //
    if ((NULL == hDS) || (INVALID_HANDLE_VALUE == hDS)) {
        FatalTrace((LPARAM)this, "DsBind returned invalid handle");
        hDS = INVALID_HANDLE_VALUE;
        hr = E_FAIL;
        ERROR_LOG("--DsBind returned invalid handle--");
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Finding all domain controllers for %s", pDCInfo->DomainName);
    //
    // Get information about all the domain controllers
    //
    dwErr = DsGetDomainControllerInfo(
        hDS,                    // Handle to the DS
        pDCInfo->DomainName,    // Domain name -- use the same domain
                                // as the GC found above
        2,                      // Retrive struct version 2
        &cDSDCInfo,             // Out param for array size
        (PVOID *) &prgDSDCInfo); // Out param for array ptr

    hr = HRESULT_FROM_WIN32(dwErr);

    if(FAILED(hr)) {

        ERROR_LOG("DsGetDomainControllerInfo");
        prgDSDCInfo = NULL;
        goto CLEANUP;
    }

    hr = HrBuildArrayFromDCInfo(
        bt,
        pszAccount,
        pszPassword,
        pszNamingContext,
        cDSDCInfo,
        prgDSDCInfo,
        pdwcServerConfig,
        pprgServerConfig);
    ERROR_CLEANUP_LOG("HrBuildArrayFromDCInfo");

 CLEANUP:
    if(prgDSDCInfo != NULL)
        DsFreeDomainControllerInfo(
            2,              // Free struct version 2
            cDSDCInfo,      // size of array
            prgDSDCInfo);   // array ptr

    if(hDS != INVALID_HANDLE_VALUE)
        DsUnBind(&hDS);

    if(pDCInfo != NULL)
        NetApiBufferFree(pDCInfo);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrBuildGCServerArray


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrBuildArrayFromDCInfo
//
// Synopsis: Allocate/build an array of LDAPSERVERCONFIG structures --
//           one for each available GC in the array
//
// Arguments:
//  bt: Bind type to use for each server
//  pszAccount: Account to use for each server
//  pszPassword: password of above account
//  pszNamingContext: naming context to use for each server
//  dwDSDCInfo: size of the prgDSDCInfo array
//  prgDSDCInfo: array of domain controller info structures
//  pdwcServerConfig: Out parameter for the size of the array
//  pprgServerConfig: Out parameter for the array pointer -- this
//                    should be free'd with the delete operator
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_NO_GC_SERVERS: There were no GCs in the array
//
// History:
// jstamerj 1999/06/17 10:40:46: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrBuildArrayFromDCInfo(
        IN  LDAP_BIND_TYPE bt,
        IN  LPSTR pszAccount,
        IN  LPSTR pszPassword,
        IN  LPSTR pszNamingContext,
        IN  DWORD dwcDSDCInfo,
        IN  PDS_DOMAIN_CONTROLLER_INFO_2 prgDSDCInfo,
        OUT DWORD *pdwcServerConfig,
        OUT PLDAPSERVERCONFIG *pprgServerConfig)
{
    HRESULT hr = S_OK;
    DWORD dwNumGCs = 0;
    DWORD dwSrcIdx;
    DWORD dwDestIdx;
    CatFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrBuildArrayFromDCInfo");

    _ASSERT(pdwcServerConfig);
    _ASSERT(pprgServerConfig);

    for(dwSrcIdx = 0; dwSrcIdx < dwcDSDCInfo; dwSrcIdx++) {

        LPSTR pszName;

        pszName = SzConnectNameFromDomainControllerInfo(
            &(prgDSDCInfo[dwSrcIdx]));

        if(pszName == NULL) {

            ErrorTrace((LPARAM)this, "DC \"%s\" has no dns/netbios names",
                       prgDSDCInfo[dwSrcIdx].ServerObjectName ?
                       prgDSDCInfo[dwSrcIdx].ServerObjectName :
                       "unknown");

        } else if(prgDSDCInfo[dwSrcIdx].fIsGc) {

            dwNumGCs++;
            DebugTrace((LPARAM)this, "Discovered GC #%d: %s",
                       dwNumGCs, pszName);

        } else {

            DebugTrace((LPARAM)this, "Discarding non-GC: %s",
                       pszName);
        }
    }
    //
    // Allocate array
    //
    *pprgServerConfig = new LDAPSERVERCONFIG[dwNumGCs];

    if(*pprgServerConfig == NULL) {

        ErrorTrace((LPARAM)this, "Out of memory alloacting array of %d LDAPSERVERCONFIGs", dwNumGCs);
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new LDAPSERVERCONFIG[]");
        goto CLEANUP;
    }
    //
    // Fill in LDAPSERVERCONFIG structures
    //
    for(dwSrcIdx = 0, dwDestIdx = 0; dwSrcIdx < dwcDSDCInfo; dwSrcIdx++) {

        LPSTR pszName;

        pszName = SzConnectNameFromDomainControllerInfo(
            &(prgDSDCInfo[dwSrcIdx]));

        if((pszName != NULL) && (prgDSDCInfo[dwSrcIdx].fIsGc)) {

            PLDAPSERVERCONFIG pServerConfig;

            _ASSERT(dwDestIdx < dwNumGCs);

            pServerConfig = &((*pprgServerConfig)[dwDestIdx]);
            //
            // Copy bindtype, account, password, naming context
            //
            pServerConfig->bt = bt;

            if(pszNamingContext)
                lstrcpyn(pServerConfig->szNamingContext, pszNamingContext,
                         sizeof(pServerConfig->szNamingContext));
            else
                pServerConfig->szNamingContext[0] = '\0';

            if(pszAccount)
                lstrcpyn(pServerConfig->szAccount, pszAccount,
                         sizeof(pServerConfig->szAccount));
            else
                pServerConfig->szAccount[0] = '\0';

            if(pszPassword)
                lstrcpyn(pServerConfig->szPassword, pszPassword,
                         sizeof(pServerConfig->szPassword));
            else
                pServerConfig->szPassword[0] = '\0';

            //
            // Initialize priority and TCP port
            //
            pServerConfig->pri = 0;
            pServerConfig->dwPort = LDAP_GC_PORT;

            //
            // Copy the name
            //
            lstrcpyn(pServerConfig->szHost, pszName,
                    sizeof(pServerConfig->szHost));

            dwDestIdx++;
        }
    }
    //
    // Assert check -- we should have filled in the entire array
    //
    _ASSERT(dwDestIdx == dwNumGCs);
    //
    // Set the out parameter for the array size
    //
    *pdwcServerConfig = dwNumGCs;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Free the allocated array if we're failing
        //
        if(*pprgServerConfig) {
            delete *pprgServerConfig;
            *pprgServerConfig = NULL;
        }
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrBuildArrayFromDCInfo


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrInit
//
// Synopsis: Initialize given an array of LDAPSERVERCONFIG structs
//
// Arguments:
//  dwcServers: Size of the array
//  prgServerConfig: Array of LDAPSERVERCONFIG structs
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1999/06/17 12:32:11: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrInit(
    DWORD dwcServers,
    PLDAPSERVERCONFIG prgServerConfig)
{
    HRESULT hr = S_OK;
    CLdapCfg *pCLdapCfgOld = NULL;
    CLdapCfg *pCLdapCfg = NULL;
    BOOL fHaveLock = FALSE;
    CatFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrInit");

    pCLdapCfg = new (dwcServers) CLdapCfg(GetISMTPServerEx());

    if(pCLdapCfg == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CLdapCfg");
        goto CLEANUP;
    }
    //
    // Allow only one config change at a time
    //
    m_sharelock.ExclusiveLock();
    fHaveLock = TRUE;

    //
    // Grab the current m_pCLdapCfg into pCLdapCfgOld
    //
    pCLdapCfgOld = m_pCLdapCfg;

    hr = pCLdapCfg->HrInit(
        dwcServers,
        prgServerConfig,
        pCLdapCfgOld);
    ERROR_CLEANUP_LOG("pCLdapCfg->HrInit");

    //
    // Put the new configuration in place
    // Swap pointers
    //
    m_pCLdapCfg = pCLdapCfg;

    //
    // Set the last update time
    //
    GetSystemTimeAsFileTime((LPFILETIME)&m_ulLastUpdateTime);

 CLEANUP:
 
    if(fHaveLock)
        m_sharelock.ExclusiveUnlock();
 
    if(pCLdapCfgOld)
        pCLdapCfgOld->Release();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrInit



//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrGetConnection
//
// Synopsis: Select/return a connection
//
// Arguments:
//  ppConn: Out parameter to receive ptr to connection
//
// Returns:
//  S_OK: Success
//  E_FAIL: not initialized
//  error from CLdapConnectionCache
//
// History:
// jstamerj 1999/06/17 15:25:51: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfgMgr::HrGetConnection(
    CCfgConnection **ppConn)
{
    HRESULT hr = S_OK;
    CatFunctEnterEx((LPARAM)this, "CLdapCfgMgr::HrGetConnection");

    hr = HrUpdateConfigurationIfNecessary();
    ERROR_CLEANUP_LOG("HrUpdateConfigurationIfNecessary");

    m_sharelock.ShareLock();

    if(m_pCLdapCfg) {

        DWORD dwcAttempts = 0;
        do {
            dwcAttempts++;
            hr = m_pCLdapCfg->HrGetConnection(ppConn, &m_LdapConnectionCache);

        } while((hr == HRESULT_FROM_WIN32(ERROR_RETRY)) &&
                (dwcAttempts <= m_pCLdapCfg->DwNumServers()));
        //
        // If we retried DwNumServers() times and still couldn't get a
        // connection, fail with E_DBCONNECTION.
        //
        if(FAILED(hr))
        {
            ERROR_LOG("m_pCLdapCfg->HrGetConnection");
            if(hr == HRESULT_FROM_WIN32(ERROR_RETRY))
                hr = CAT_E_DBCONNECTION;
        }

    } else {
        hr = E_FAIL;
        _ASSERT(0 && "HrInit not called or did not succeed");
    }

    m_sharelock.ShareUnlock();

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfgMgr::HrGetConnection



//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::LogCnfgInit
//
// Synopsis: Log cnfgmgr init event
//
// Arguments: none
//
// Returns: Nothing
//
// History:
// jstamerj 2001/12/13 00:57:18: Created.
//
//-------------------------------------------------------------
VOID CLdapCfgMgr::LogCnfgInit()
{
    CatLogEvent(
        GetISMTPServerEx(),
        CAT_EVENT_CNFGMGR_INIT,
        0,
        NULL,
        S_OK,
        "",
        LOGEVENT_FLAG_ALWAYS,
        LOGEVENT_LEVEL_MEDIUM);
}



//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::LogCnfgEntry
//
// Synopsis: Log cnfgmgr entry event
//
// Arguments: pConfig: entry to log
//
// Returns: Nothing
//
// History:
// jstamerj 2001/12/13 00:57:30: Created.
//
//-------------------------------------------------------------
VOID CLdapCfgMgr::LogCnfgEntry(
    PLDAPSERVERCONFIG pConfig)
{
    LPCSTR rgSubStrings[6];
    CHAR szPort[16], szPri[16], szBindType[16];

    _snprintf(szPort, sizeof(szPort), "%d", pConfig->dwPort);
    _snprintf(szPri, sizeof(szPri), "%d", pConfig->pri);
    _snprintf(szBindType, sizeof(szBindType), "%d", pConfig->bt);

    rgSubStrings[0] = pConfig->szHost;
    rgSubStrings[1] = szPort;
    rgSubStrings[2] = szPri;
    rgSubStrings[3] = szBindType;
    rgSubStrings[4] = pConfig->szNamingContext;
    rgSubStrings[5] = pConfig->szAccount;

    CatLogEvent(
        GetISMTPServerEx(),
        CAT_EVENT_CNFGMGR_ENTRY,
        6,
        rgSubStrings,
        S_OK,
        pConfig->szHost,
        LOGEVENT_FLAG_ALWAYS,
        LOGEVENT_LEVEL_MEDIUM);
}



//+------------------------------------------------------------
//
// Function: CLdapCfg::operator new
//
// Synopsis: Allocate memory for a CLdapCfg object
//
// Arguments:
//  size: size of C++ object
//  dwcServers: Number of servers in this configuration
//
// Returns:
//  void pointer to the new object
//
// History:
// jstamerj 1999/06/17 13:40:56: Created.
//
//-------------------------------------------------------------
void * CLdapCfg::operator new(
    size_t size,
    DWORD dwcServers)
{
    CLdapCfg *pCLdapCfg;
    DWORD dwAllocatedSize;
    CatFunctEnterEx((LPARAM)0, "CLdapCfg::operator new");

    _ASSERT(size == sizeof(CLdapCfg));

    //
    // Allocate space fo the CLdapServerCfg * array contigously after
    // the memory for the C++ object
    //
    dwAllocatedSize = sizeof(CLdapCfg) + (dwcServers *
                                          sizeof(CLdapServerCfg));

    pCLdapCfg = (CLdapCfg *) new BYTE[dwAllocatedSize];

    if(pCLdapCfg) {
        pCLdapCfg->m_dwSignature = SIGNATURE_CLDAPCFG;
        pCLdapCfg->m_dwcServers = dwcServers;
        pCLdapCfg->m_prgpCLdapServerCfg = (CLdapServerCfg **) (pCLdapCfg + 1);
    }

    CatFunctLeaveEx((LPARAM)pCLdapCfg);
    return pCLdapCfg;
} // CLdapCfg::operator new


//+------------------------------------------------------------
//
// Function: CLdapCfg::CLdapCfg
//
// Synopsis: Initialize member data
//
// Arguments:
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 13:46:50: Created.
//
//-------------------------------------------------------------
CLdapCfg::CLdapCfg(
    ISMTPServerEx *pISMTPServerEx)
{
    CatFunctEnterEx((LPARAM)this, "CLdapCfg::CLdapCfg");
    //
    // signature and number of servers should be set by the new operator
    //
    _ASSERT(m_dwSignature == SIGNATURE_CLDAPCFG);

    //
    // Zero out the array of pointers to CLdapServerCfg objects
    //
    ZeroMemory(m_prgpCLdapServerCfg, m_dwcServers * sizeof(CLdapServerCfg *));

    m_dwInc = 0;
    m_dwcConnectionFailures = 0;
    m_pISMTPServerEx = pISMTPServerEx;
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->AddRef();

    CatFunctLeaveEx((LPARAM)this);
} // CLdapCfg::CLdapCfg


//+------------------------------------------------------------
//
// Function: CLdapCfg::~CLdapCfg
//
// Synopsis: Clean up
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 14:47:25: Created.
//
//-------------------------------------------------------------
CLdapCfg::~CLdapCfg()
{
    DWORD dwCount;

    CatFunctEnterEx((LPARAM)this, "CLdapCfg::~CLdapCfg");

    //
    // Release all connections configurations
    //
    for(dwCount = 0; dwCount < m_dwcServers; dwCount++) {
        CLdapServerCfg *pCLdapServerCfg;

        pCLdapServerCfg = m_prgpCLdapServerCfg[dwCount];
        m_prgpCLdapServerCfg[dwCount] = NULL;

        if(pCLdapServerCfg)
            pCLdapServerCfg->Release();
    }
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    _ASSERT(m_dwSignature == SIGNATURE_CLDAPCFG);
    m_dwSignature = SIGNATURE_CLDAPCFG_INVALID;

    CatFunctLeaveEx((LPARAM)this);
} // CLdapCfg::~CLdapCfg



//+------------------------------------------------------------
//
// Function: CLdapCfg::HrInit
//
// Synopsis: Initialize the configuration
//
// Arguments:
//  dwcServers: Size of config array
//  prgSeverConfig: LDAPSERVERCONFIG array
//  pCLdapCfgOld: The previous configuration
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1999/06/17 13:52:20: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfg::HrInit(
    DWORD dwcServers,
    PLDAPSERVERCONFIG prgServerConfig,
    CLdapCfg *pCLdapCfgOld)
{
    HRESULT hr = S_OK;
    DWORD dwCount;
    CatFunctEnterEx((LPARAM)this, "CLdapCfg::HrInit");
    //
    // m_dwcServers should be initialized by the new operator
    //
    _ASSERT(dwcServers == m_dwcServers);

    m_sharelock.ExclusiveLock();
    //
    // Zero out the array of pointers to CLdapServerCfg objects
    //
    ZeroMemory(m_prgpCLdapServerCfg, m_dwcServers * sizeof(CLdapServerCfg *));

    for(dwCount = 0; dwCount < m_dwcServers; dwCount++) {

        DebugTrace((LPARAM)this, "GC list entry: %s (%u)", prgServerConfig[dwCount].szHost, prgServerConfig[dwCount].dwPort);

        CLdapServerCfg *pServerCfg = NULL;

        hr = CLdapServerCfg::GetServerCfg(
            GetISMTPServerEx(),
            &(prgServerConfig[dwCount]),
            &pServerCfg);
        ERROR_CLEANUP_LOG("CLdapServerCfg::GetServerCfg");

        m_prgpCLdapServerCfg[dwCount] = pServerCfg;
    }

    ShuffleArray();

 CLEANUP:
    m_sharelock.ExclusiveUnlock();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfg::HrInit


//+------------------------------------------------------------
//
// Function: CLdapCfg::HrGetConnection
//
// Synopsis: Select a connection and return it
//
// Arguments:
//  ppConn: Set to a pointer to the selected connection
//  pLdapConnectionCache: Cache to get connection from
//
// Returns:
//  S_OK: Success
//  E_FAIL: We are shutting down
//  error from ldapconn
//
// History:
// jstamerj 1999/06/17 14:49:37: Created.
//
//-------------------------------------------------------------
HRESULT CLdapCfg::HrGetConnection(
    CCfgConnection **ppConn,
    CCfgConnectionCache *pLdapConnectionCache)
{
    HRESULT hr = S_OK;
    LDAPSERVERCOST Cost, BestCost;
    DWORD dwCount;
    CLdapServerCfg *pCLdapServerCfg = NULL;
    BOOL fFirstServer = TRUE;
    DWORD dwStart, dwCurrent;

    CatFunctEnterEx((LPARAM)this, "CLdapCfg::HrGetConnection");
    //
    // Get the cost of the first connection
    //
    m_sharelock.ShareLock();

    //
    // Round robin where we start searching the array
    // Do this so we will use connections with the same cost
    // approximately the same amount of time.
    //
    dwStart = InterlockedIncrement((PLONG) &m_dwInc) % m_dwcServers;

    for(dwCount = 0; dwCount < m_dwcServers; dwCount++) {

        dwCurrent = (dwStart + dwCount) % m_dwcServers;

        if(m_prgpCLdapServerCfg[dwCurrent]) {

            m_prgpCLdapServerCfg[dwCurrent]->Cost(GetISMTPServerEx(), &Cost);
            if(fFirstServer) {
                pCLdapServerCfg = m_prgpCLdapServerCfg[dwCurrent];
                fFirstServer = FALSE;
                BestCost = Cost;

            } else if(Cost < BestCost) {
                pCLdapServerCfg = m_prgpCLdapServerCfg[dwCurrent];
                BestCost = Cost;
            }
        }
    }
    if(pCLdapServerCfg == NULL) {
        ErrorTrace((LPARAM)this, "HrGetConnection can not find any connections");
        hr = E_FAIL;
        _ASSERT(0 && "HrInit not called or did not succeed");
        ERROR_LOG("--pCLdapServerCfg == NULL--");
        goto CLEANUP;
    }

    if(BestCost >= COST_TOO_HIGH_TO_CONNECT) {
        DebugTrace((LPARAM)this, "BestCost is too high to attempt connection");
        hr = CAT_E_DBCONNECTION;
        ERROR_LOG("-- BestCost >= COST_TOO_HIGH_TO_CONNECT --");
        goto CLEANUP;
    }

    hr = pCLdapServerCfg->HrGetConnection(GetISMTPServerEx(), ppConn, pLdapConnectionCache);

    //  If we fail to connect to a GC --- there may be other GCs which
    //  are still up. Therefore we should try to connect to them (till
    //  we run out of GCs (BestCost >= COST_TOO_HIGH_TO_CONNECT)

    if(FAILED(hr)) {
        DebugTrace((LPARAM)this, "Failed to connect. hr = 0x%08x", hr);
        ERROR_LOG("pCLdapServerCfg->HrGetConnection");
        hr = HRESULT_FROM_WIN32(ERROR_RETRY);
    }

 CLEANUP:
    m_sharelock.ShareUnlock();

    if(FAILED(hr))
        InterlockedIncrement((PLONG)&m_dwcConnectionFailures);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapCfg::HrGetConnection


//+------------------------------------------------------------
//
// Function: CLdapCfg::ShuffleArray
//
// Synopsis: Randomize the order of the CLdapServerCfg array
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 19:10:06: Created.
//
//-------------------------------------------------------------
VOID CLdapCfg::ShuffleArray()
{
    DWORD dwCount;
    DWORD dwSwap;
    CLdapServerCfg *pTmp;
    CatFunctEnterEx((LPARAM)this, "CLdapCfg::ShuffleArray");

    srand((int)(GetCurrentThreadId() * time(NULL)));

    for(dwCount = 0; dwCount < (m_dwcServers - 1); dwCount++) {
        //
        // Choose an integer between dwCount and m_dwcServers - 1
        //
        dwSwap = dwCount + (rand() % (m_dwcServers - dwCount));
        //
        // Swap pointers
        //
        pTmp = m_prgpCLdapServerCfg[dwCount];
        m_prgpCLdapServerCfg[dwCount] = m_prgpCLdapServerCfg[dwSwap];
        m_prgpCLdapServerCfg[dwSwap] = pTmp;
    }

    CatFunctLeaveEx((LPARAM)this);
} // CLdapCfg::ShuffleArray



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::CLdapServerCfg
//
// Synopsis: Initialize member variables
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 15:30:32: Created.
//
//-------------------------------------------------------------
CLdapServerCfg::CLdapServerCfg()
{
    CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::CLdapServerCfg");

    m_dwSignature = SIGNATURE_CLDAPSERVERCFG;

    m_ServerConfig.dwPort = 0;
    m_ServerConfig.pri = 0;
    m_ServerConfig.bt = BIND_TYPE_NONE;
    m_ServerConfig.szHost[0] = '\0';
    m_ServerConfig.szNamingContext[0] = '\0';
    m_ServerConfig.szAccount[0] = '\0';
    m_ServerConfig.szPassword[0] = '\0';

    m_connstate = CONN_STATE_INITIAL;
    ZeroMemory(&m_ftLastStateUpdate, sizeof(m_ftLastStateUpdate));
    m_dwcPendingSearches = 0;
    m_lRefCount = 1;
    m_fLocalServer = FALSE;
    m_dwcCurrentConnectAttempts = 0;
    m_dwcFailedConnectAttempts = 0;

    CatFunctLeaveEx((LPARAM)this);
} // CLdapServerCfg::CLdapServerCfg

//+----------------------------------------------------------------------------
//
//  Function:   CLdapServerCfg::InitializeFromRegistry
//
//  Synopsis:   Helper function that looks up parameters from the registry.
//              Configurable parameters are:
//                  GC_COST_CONNECTED_LOCAL
//                  GC_COST_CONNECTED_REMOTE
//                  GC_COST_INITIAL_LOCAL
//                  GC_COST_INITIAL_REMOTE
//                  GC_COST_RETRY_LOCAL
//                  GC_COST_RETRY_REMOTE
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------
VOID CLdapServerCfg::InitializeFromRegistry()
{
    HKEY hkey;
    DWORD dwErr, dwType, dwValue, cbValue;

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, GC_COST_PARAMETERS_KEY, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    GC_COST_CONNECTED_LOCAL_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
            m_dwCostConnectedLocal = dwValue;
        }

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    GC_COST_CONNECTED_REMOTE_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
            m_dwCostConnectedRemote = dwValue;
        }

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    GC_COST_INITIAL_LOCAL_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
            m_dwCostInitialLocal = dwValue;
        }

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    GC_COST_INITIAL_REMOTE_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
            m_dwCostInitialRemote = dwValue;
        }

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    GC_COST_RETRY_LOCAL_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
            m_dwCostRetryLocal = dwValue;
        }

        cbValue = sizeof(dwValue);

        dwErr = RegQueryValueEx(
                    hkey,
                    GC_COST_RETRY_REMOTE_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
            m_dwCostRetryRemote = dwValue;
        }

        RegCloseKey( hkey );

    }

}


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::~CLdapServerCfg
//
// Synopsis: object destructor.  Check and invalidate signature
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/22 11:09:03: Created.
//
//-------------------------------------------------------------
CLdapServerCfg::~CLdapServerCfg()
{
    CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::~CLdapServerCfg");

    _ASSERT(m_dwSignature == SIGNATURE_CLDAPSERVERCFG);
    m_dwSignature = SIGNATURE_CLDAPSERVERCFG_INVALID;

    CatFunctLeaveEx((LPARAM)this);
} // CLdapServerCfg::~CLdapServerCfg


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::HrInit
//
// Synopsis: Initialize with the passed in config
//
// Arguments:
//  pCLdapCfg: the cfg object to notify when servers go down
//  pServerConfig: The server config struct to use
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/17 15:43:25: Created.
//
//-------------------------------------------------------------
HRESULT CLdapServerCfg::HrInit(
    PLDAPSERVERCONFIG pServerConfig)
{
    HRESULT hr = S_OK;
    CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::HrInit");

    CopyMemory(&m_ServerConfig, pServerConfig, sizeof(m_ServerConfig));
    //
    // Check if this is the local computer
    //
    if(fIsLocalComputer(pServerConfig))
        m_fLocalServer = TRUE;

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapServerCfg::HrInit



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::fIsLocalComputer
//
// Synopsis: Determine if pServerConfig is the local computer or not
//
// Arguments:
//  pServerConfig: the server config info structure
//
// Returns:
//  TRUE: Server is the local computer
//  FALSE: Sevrver is a remote computer
//
// History:
// jstamerj 1999/06/22 15:26:53: Created.
//
//-------------------------------------------------------------
BOOL CLdapServerCfg::fIsLocalComputer(
    PLDAPSERVERCONFIG pServerConfig)
{
    BOOL fLocal = FALSE;
    DWORD dwSize;
    CHAR szHost[CAT_MAX_DOMAIN];
    CatFunctEnterEx((LPARAM)NULL, "CLdapServerCfg::fIsLocalComputer");

    //
    // Check the FQ name
    //
    dwSize = sizeof(szHost);
    if(GetComputerNameEx(
        ComputerNameDnsFullyQualified,
        szHost,
        &dwSize) &&
       (lstrcmpi(szHost, pServerConfig->szHost) == 0)) {

        fLocal = TRUE;
        goto CLEANUP;
    }

    //
    // Check the DNS name
    //
    dwSize = sizeof(szHost);
    if(GetComputerNameEx(
        ComputerNameDnsHostname,
        szHost,
        &dwSize) &&
       (lstrcmpi(szHost, pServerConfig->szHost) == 0)) {

        fLocal = TRUE;
        goto CLEANUP;
    }
    //
    // Check the netbios name
    //
    dwSize = sizeof(szHost);
    if(GetComputerNameEx(
        ComputerNameNetBIOS,
        szHost,
        &dwSize) &&
       (lstrcmpi(szHost, pServerConfig->szHost) == 0)) {

        fLocal = TRUE;
        goto CLEANUP;

    }

 CLEANUP:
    DebugTrace((LPARAM)NULL, "returning %08lx", fLocal);
    CatFunctLeaveEx((LPARAM)NULL);
    return fLocal;
} // CLdapServerCfg::fIsLocalComputer


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::Cost
//
// Synopsis: Return the cost of choosing this connection
//
// Arguments:
//  pCost: Cost sturcture to fill in
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/17 16:08:23: Created.
//
//-------------------------------------------------------------
VOID CLdapServerCfg::Cost(
    IN  ISMTPServerEx *pISMTPServerEx,
    OUT PLDAPSERVERCOST pCost)
{
    BOOL fShareLock = FALSE;
    CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::Cost");
    //
    // The smallest unit of cost is the number of pending searches.
    // The next factor of cost is the connection state.
    // States:
    //   Connected = + COST_CONNECTED
    //   Initially state (unconnected) = + COST_INITIAL
    //   Connection down = + COST_RETRY
    //   Connection recently went down = + COST_DOWN
    //
    // A configurable priority is always added to the cost.
    // Also, COST_REMOTE is added to the cost of all non-local servers.
    //
    *pCost = m_ServerConfig.pri + m_dwcPendingSearches;
    //
    // Protect the connection state variables with a spinlock
    //
    m_sharelock.ShareLock();
    fShareLock = TRUE;

    switch(m_connstate) {

     case CONN_STATE_INITIAL:
         (*pCost) += (m_fLocalServer) ? m_dwCostInitialLocal : m_dwCostInitialRemote;
         break;

     case CONN_STATE_RETRY:
         if(m_dwcCurrentConnectAttempts >= MAX_CONNECT_THREADS)
             (*pCost) += COST_TOO_HIGH_TO_CONNECT;
         else
             (*pCost) += (m_fLocalServer) ? m_dwCostRetryLocal : m_dwCostRetryRemote;
         break;

     case CONN_STATE_DOWN:
         //
         // Check if the state should be changed to CONN_STATE_RETRY
         //
         if(fReadyForRetry()) {
             (*pCost) += (m_fLocalServer) ? m_dwCostRetryLocal : m_dwCostRetryRemote;
             //
             // Change state
             //
             fShareLock = FALSE;
             m_sharelock.ShareUnlock();
             m_sharelock.ExclusiveLock();
             //
             // Double check in the exclusive lock
             //
             if((m_connstate == CONN_STATE_DOWN) &&
                fReadyForRetry()) {

                 LogStateChangeEvent(
                     pISMTPServerEx,
                     CONN_STATE_RETRY,
                     m_ServerConfig.szHost,
                     m_ServerConfig.dwPort);

                 m_connstate = CONN_STATE_RETRY;
             }
             m_sharelock.ExclusiveUnlock();

         } else {
             //
             // Server is probably still down (don't retry yet)
             //
             (*pCost) += (m_fLocalServer) ? COST_DOWN_LOCAL : COST_DOWN_REMOTE;

         }
         break;

     case CONN_STATE_CONNECTED:
         (*pCost) += (m_fLocalServer) ? m_dwCostConnectedLocal : m_dwCostConnectedRemote;
         break;

     default:
         // Nothing to add
         break;
    }
    if(fShareLock)
        m_sharelock.ShareUnlock();

    CatFunctLeaveEx((LPARAM)this);
} // CLdapServerCfg::Cost


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::HrGetConnection
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/18 10:49:04: Created.
//
//-------------------------------------------------------------
HRESULT CLdapServerCfg::HrGetConnection(
    ISMTPServerEx *pISMTPServerEx,
    CCfgConnection **ppConn,
    CCfgConnectionCache *pLdapConnectionCache)
{
    HRESULT hr = S_OK;
    DWORD dwcConnectAttempts = 0;
    CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::HrGetConnection");

    dwcConnectAttempts = (DWORD) InterlockedIncrement((PLONG) &m_dwcCurrentConnectAttempts);

    m_sharelock.ShareLock();
    if((m_connstate == CONN_STATE_RETRY) &&
       (dwcConnectAttempts > MAX_CONNECT_THREADS)) {

        m_sharelock.ShareUnlock();

        ErrorTrace((LPARAM)this, "Over max connect thread limit");
        hr = HRESULT_FROM_WIN32(ERROR_RETRY);
        ERROR_LOG_STATIC(
            "--over max connect thread limit--",
            this,
            pISMTPServerEx);
        goto CLEANUP;
    }
    m_sharelock.ShareUnlock();

    DebugTrace((LPARAM)this, "Attempting to connect to %s:%d",
               m_ServerConfig.szHost,
               m_ServerConfig.dwPort);

    hr = pLdapConnectionCache->GetConnection(
        ppConn,
        &m_ServerConfig,
        this);
    ERROR_CLEANUP_LOG_STATIC(
        "pLdapConnectionCache->GetConnection",
        this,
        pISMTPServerEx);
        
    //
    // CCfgConnection::Connect will update the connection state
    //
 CLEANUP:
    InterlockedDecrement((PLONG) &m_dwcCurrentConnectAttempts);
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapServerCfg::HrGetConnection


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::UpdateConnectionState
//
// Synopsis: Update the connection state.
//
// Arguments:
//  pft: Time of update -- if this time is before the last update done,
//       then this update will be ignored.
//       If NULL, the function will assume the current time.
//  connstate: The new connection state.
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/18 13:22:25: Created.
//
//-------------------------------------------------------------
VOID CLdapServerCfg::UpdateConnectionState(
    ISMTPServerEx *pISMTPServerEx,
    ULARGE_INTEGER *pft_IN,
    CONN_STATE connstate)
{
    ULARGE_INTEGER ft, *pft;
    CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::UpdateConnectionState");

    if(pft_IN != NULL) {
        pft = pft_IN;
    } else {
        ft = GetCurrentTime();
        pft = &ft;
    }

    //
    // Protect connection state variables with a sharelock
    //
    m_sharelock.ShareLock();
    //
    // If we have the latest information about the connection state,
    // then update the state if the connection state changed.
    // Also update m_ftLastStateUpdate to the latest ft when the
    // connection state is down -- m_ftLastStateUpdate is assumed to
    // be the last connection attempt time when connstate is down.
    //
    if( (pft->QuadPart > m_ftLastStateUpdate.QuadPart) &&
        ((m_connstate != connstate) ||
         (connstate == CONN_STATE_DOWN))) {
        //
        // We'd like to update the connection state
        //
        m_sharelock.ShareUnlock();
        m_sharelock.ExclusiveLock();
        //
        // Double check
        //
        if( (pft->QuadPart > m_ftLastStateUpdate.QuadPart) &&
            ((m_connstate != connstate) ||
             (connstate == CONN_STATE_DOWN))) {
            //
            // Update
            //
            if(m_connstate != connstate) {
                LogStateChangeEvent(
                    pISMTPServerEx,
                    connstate,
                    m_ServerConfig.szHost,
                    m_ServerConfig.dwPort);
            }

            m_ftLastStateUpdate = *pft;
            m_connstate = connstate;

            DebugTrace((LPARAM)this, "Updating state %d, conn %s:%d",
                       connstate,
                       m_ServerConfig.szHost,
                       m_ServerConfig.dwPort);
                
        } else {

            DebugTrace((LPARAM)this, "Ignoring state update %d, conn %s:%d",
                       connstate,
                       m_ServerConfig.szHost,
                       m_ServerConfig.dwPort);
        }
        m_sharelock.ExclusiveUnlock();

    } else {

        DebugTrace((LPARAM)this, "Ignoring state update %d, conn %s:%d",
                   connstate,
                   m_ServerConfig.szHost,
                   m_ServerConfig.dwPort);

        m_sharelock.ShareUnlock();
    }

    CatFunctLeaveEx((LPARAM)this);
} // CLdapServerCfg::UpdateConnectionState


//+------------------------------------------------------------
//
// Function: CLdapServerCfg::GetServerCfg
//
// Synopsis: Find or Create a CLdapServerCfg object with the specified
//           configuration.
//
// Arguments:
//  pServerConfig: desired configuration
//  pCLdapServerCfg: return pointer for the CLdapServerCfg object
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1999/06/21 11:26:49: Created.
//
//-------------------------------------------------------------
HRESULT CLdapServerCfg::GetServerCfg(
    IN  ISMTPServerEx *pISMTPServerEx,
    IN  PLDAPSERVERCONFIG pServerConfig,
    OUT CLdapServerCfg **ppCLdapServerCfg)
{
    HRESULT hr = S_OK;
    CLdapServerCfg *pCCfg;
    CatFunctEnterEx((LPARAM)NULL, "CLdapServerCfg::GetServerCfg");

    m_listlock.ShareLock();

    pCCfg = FindServerCfg(pServerConfig);
    if(pCCfg)
        pCCfg->AddRef();

    m_listlock.ShareUnlock();

    if(pCCfg == NULL) {
        //
        // Check again for a server cfg object inside an exclusive
        // lock
        //
        m_listlock.ExclusiveLock();

        pCCfg = FindServerCfg(pServerConfig);
        if(pCCfg) {
            pCCfg->AddRef();
        } else {
            //
            // Create a new object
            //
            pCCfg = new CLdapServerCfg();
            if(pCCfg == NULL) {

                hr = E_OUTOFMEMORY;
                ERROR_LOG_STATIC(
                    "new CLdapServerCfg",
                    0,
                    pISMTPServerEx);

            } else {

                hr = pCCfg->HrInit(pServerConfig);
                if(FAILED(hr)) {
                    ERROR_LOG_STATIC(
                        "pCCfg->HrInit",
                        pCCfg,
                        pISMTPServerEx);
                    delete pCCfg;
                    pCCfg = NULL;
                } else {
                    //
                    // Add to global list
                    //
                    InsertTailList(&m_listhead, &(pCCfg->m_le));
                }
            }
        }
        m_listlock.ExclusiveUnlock();
    }
    //
    // Set out parameter
    //
    *ppCLdapServerCfg = pCCfg;

    DebugTrace((LPARAM)NULL, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)NULL);
    return hr;

} // CLdapServerCfg::GetServerCfg



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::FindServerCfg
//
// Synopsis: Find a server cfg object that matches the
//           LDAPSERVERCONFIG structure.  Note, m_listlock must be
//           locked when calling this function.
//
// Arguments:
//  pServerConfig: pointer to the LDAPSERVERCONFIG struct
//
// Returns:
//  NULL: there is no such server cfg object
//  else, ptr to the found CLdapServerCfg object
//
// History:
// jstamerj 1999/06/21 10:43:23: Created.
//
//-------------------------------------------------------------
CLdapServerCfg * CLdapServerCfg::FindServerCfg(
    PLDAPSERVERCONFIG pServerConfig)
{
    CLdapServerCfg *pMatch = NULL;
    PLIST_ENTRY ple;
    CatFunctEnterEx((LPARAM)NULL, "CLdapServerCfg::FindServerCfg");

    for(ple = m_listhead.Flink;
        (ple != &m_listhead) && (pMatch == NULL);
        ple = ple->Flink) {

        CLdapServerCfg *pCandidate = NULL;

        pCandidate = CONTAINING_RECORD(ple, CLdapServerCfg, m_le);

        if(pCandidate->fMatch(
            pServerConfig)) {

            pMatch = pCandidate;
        }
    }

    CatFunctLeaveEx((LPARAM)NULL);
    return pMatch;
} // CLdapServerCfg::FindServerCfg



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::fMatch
//
// Synopsis: Determine if this object matches the passed in config
//
// Arguments:
//  pServerConfig: config to check against
//
// Returns:
//  TRUE: match
//  FALSE: no match
//
// History:
// jstamerj 1999/06/21 12:45:10: Created.
//
//-------------------------------------------------------------
BOOL CLdapServerCfg::fMatch(
    PLDAPSERVERCONFIG pServerConfig)
{
    BOOL fRet;
    CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::fMatch");

    if((pServerConfig->dwPort != m_ServerConfig.dwPort) ||
       (pServerConfig->bt     != m_ServerConfig.bt) ||
       (lstrcmpi(pServerConfig->szHost,
                 m_ServerConfig.szHost) != 0) ||
       (lstrcmpi(pServerConfig->szNamingContext,
                 m_ServerConfig.szNamingContext) != 0) ||
       (lstrcmpi(pServerConfig->szAccount,
                 m_ServerConfig.szAccount) != 0) ||
       (lstrcmpi(pServerConfig->szPassword,
                 m_ServerConfig.szPassword) != 0)) {

        fRet = FALSE;

    } else {

        fRet = TRUE;
    }

    DebugTrace((LPARAM)this, "returning %08lx", fRet);
    CatFunctLeaveEx((LPARAM)this);
    return fRet;
} // CLdapServerCfg::fMatch



//+------------------------------------------------------------
//
// Function: CLdapServerCfg::LogStateChangeEvent
//
// Synopsis: Log an eventlog for a state change event
//
// Arguments:
//  pISMTPServerEx: interface for logging
//  connstate: new connstate
//  pszHost: host for connection
//  dwPort: port of connection
//
// Returns: Nothing
//
// History:
// jstamerj 2001/12/13 01:43:13: Created.
//
//-------------------------------------------------------------
VOID CLdapServerCfg::LogStateChangeEvent(
    IN  ISMTPServerEx *pISMTPServerEx,
    IN  CONN_STATE connstate,
    IN  LPSTR pszHost,
    IN  DWORD dwPort)
{
    DWORD idEvent = 0;
    LPCSTR rgSubStrings[2];
    CHAR szPort[16];

    _snprintf(szPort, sizeof(szPort), "%d", dwPort);

    rgSubStrings[0] = pszHost;
    rgSubStrings[1] = szPort;

    switch(connstate)
    {
     case CONN_STATE_CONNECTED:
        idEvent = CAT_EVENT_CNFGMGR_CONNECTED;
        break;

     case CONN_STATE_DOWN:
        idEvent = CAT_EVENT_CNFGMGR_DOWN;
        break;

     case CONN_STATE_RETRY:
        idEvent = CAT_EVENT_CNFGMGR_RETRY;
        break;
        
     default:
         break;
    }
    
    if(idEvent)
    {
        CatLogEvent(
            pISMTPServerEx,
            idEvent,
            2,
            rgSubStrings,
            S_OK,
            pszHost,
            LOGEVENT_FLAG_ALWAYS,
            LOGEVENT_LEVEL_MEDIUM);
    }
}
    




//+------------------------------------------------------------
//
// Function: CCfgConnection::Connect
//
// Synopsis: Cfg wrapper for the Connect call.
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//  CAT_E_DBCONNECTION (or whatever CBatchLdapConnection::Connect returns)
//
// History:
// jstamerj 2000/04/13 17:44:43: Created.
//
//-------------------------------------------------------------
HRESULT CCfgConnection::Connect()
{
    HRESULT hr = S_OK;
    ULARGE_INTEGER ft;
    CONN_STATE connstate;
    CatFunctEnterEx((LPARAM)this, "CCfgConnection::Connect");

    connstate = m_pCLdapServerCfg->CurrentState();
    if(connstate == CONN_STATE_DOWN) {

        DebugTrace((LPARAM)this, "Not connecting because %s:%d is down",
                   m_szHost, m_dwPort);
        hr = CAT_E_DBCONNECTION;
        ERROR_LOG("m_pCLdapServerCfg->CurrentState");
        goto CLEANUP;
    }

    ft = m_pCLdapServerCfg->GetCurrentTime();

    hr = CBatchLdapConnection::Connect();
    if(FAILED(hr)) {
        connstate = CONN_STATE_DOWN;
        m_pCLdapServerCfg->IncrementFailedCount();
        ERROR_LOG("CBatchLdapConnection::Connect");
    } else {
        connstate = CONN_STATE_CONNECTED;
        m_pCLdapServerCfg->ResetFailedCount();
    }
    //
    // Update the connection state while inside CLdapConnectionCache's
    // lock.  This will prevent a succeeding thread from attempting
    // another connection to the GC right after CLdapConnectionCache
    // releases its lock.  Contact msanna for more details.
    //
    m_pCLdapServerCfg->UpdateConnectionState(
        GetISMTPServerEx(), &ft, connstate);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCfgConnection::Connect


//+------------------------------------------------------------
//
// Function: CCfgConnection::AsyncSearch
//
// Synopsis: Wrapper around AsyncSearch -- keep track of the # of
//           pending searches and connection state.
//
// Arguments: See CLdapConnection::AsyncSearch
//
// Returns:
//  Value returned from CLdapConnection::AsyncSearch
//
// History:
// jstamerj 1999/06/18 13:49:45: Created.
//
//-------------------------------------------------------------
HRESULT CCfgConnection::AsyncSearch(
    LPCWSTR szBaseDN,
    int nScope,
    LPCWSTR szFilter,
    LPCWSTR szAttributes[],
    DWORD dwPageSize,
    LPLDAPCOMPLETION fnCompletion,
    LPVOID ctxCompletion)
{
    HRESULT hr = S_OK;
    CatFunctEnterEx((LPARAM)this, "CCfgConnection::AsyncSearch");

    m_pCLdapServerCfg->IncrementPendingSearches();

    hr = CBatchLdapConnection::AsyncSearch(
        szBaseDN,
        nScope,
        szFilter,
        szAttributes,
        dwPageSize,
        fnCompletion,
        ctxCompletion);

    if(FAILED(hr)) {
        ERROR_LOG("CBatchLdapConnection::AsyncSearch");
        m_pCLdapServerCfg->DecrementPendingSearches();
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCfgConnection::AsyncSearch


//+------------------------------------------------------------
//
// Function: CCfgConnection::CallCompletion
//
// Synopsis: Wrapper around CLdapConnection::CallCompletion.  Checks
//           for server down errors and keeps track of pending searches.
//
// Arguments: See CLdapConnection::CallCompletion
//
// Returns: See CLdapConnection::CallCompletion
//
// History:
// jstamerj 1999/06/18 13:58:28: Created.
//
//-------------------------------------------------------------
VOID CCfgConnection::CallCompletion(
    PPENDING_REQUEST preq,
    PLDAPMessage pres,
    HRESULT hrStatus,
    BOOL fFinalCompletion)
{
    CatFunctEnterEx((LPARAM)this, "CCfgConnection::CallCompletion");

    //
    // The user(s) of CLdapConnection normally try to get a new
    // connection and reissue their search when AsyncSearch
    // fails.  When opening a new connection fails, CLdapServerCfg
    // will be notified that the LDAP server is down.  We do not
    // want to call NotifyServerDown() here because the LDAP
    // server may have just closed this connection due to idle
    // time (the server may not actually be down).
    //
    if(fFinalCompletion) {

        m_pCLdapServerCfg->DecrementPendingSearches();
    }

    CBatchLdapConnection::CallCompletion(
        preq,
        pres,
        hrStatus,
        fFinalCompletion);

    CatFunctLeaveEx((LPARAM)this);
} // CCfgConnection::CallCompletion


//+------------------------------------------------------------
//
// Function: CCfgConnection::NotifyServerDown
//
// Synopsis: Notify the server config that this connection is down.
//           If we already notified it, don't do so again.
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/18 14:07:48: Created.
//
//-------------------------------------------------------------
VOID CCfgConnection::NotifyServerDown()
{
    BOOL fNotify;
    CatFunctEnterEx((LPARAM)this, "CCfgConnection::NotifyServerDown");

    m_sharelock.ShareLock();
    if(m_connstate == CONN_STATE_DOWN) {
        //
        // We already notified m_pCLdapServerCfg the server went
        // down.  Don't repeteadly call it
        //
        fNotify = FALSE;

        m_sharelock.ShareUnlock();

    } else {

        m_sharelock.ShareUnlock();
        m_sharelock.ExclusiveLock();
        //
        // Double check
        //
        if(m_connstate == CONN_STATE_DOWN) {

            fNotify = FALSE;

        } else {
            m_connstate = CONN_STATE_DOWN;
            fNotify = TRUE;
        }
        m_sharelock.ExclusiveUnlock();
    }
    if(fNotify)
        m_pCLdapServerCfg->UpdateConnectionState(
            GetISMTPServerEx(),
            NULL,               // Current time
            CONN_STATE_DOWN);

    CatFunctLeaveEx((LPARAM)this);
} // CCfgConnection::NotifyServerDown


//+------------------------------------------------------------
//
// Function: CatStoreInitGlobals
//
// Synopsis: This is called to initialize global variables in the
//           store layer.
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/06/22 11:03:53: Created.
//
//-------------------------------------------------------------
HRESULT CatStoreInitGlobals()
{
    CatFunctEnterEx((LPARAM)NULL, "CatStoreInitGlobals");

    CLdapServerCfg::GlobalInit();
    CLdapConnection::GlobalInit();

    CatFunctLeaveEx((LPARAM)NULL);
    return S_OK;
} // CatStoreInitGlobals


//+------------------------------------------------------------
//
// Function: CatStoreDeinitGlobals
//
// Synopsis: Called to deinitialize store layer globals -- called once
//           only when CatStoreInitGlobals succeeds
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/06/22 11:05:44: Created.
//
//-------------------------------------------------------------
VOID CatStoreDeinitGlobals()
{
    CatFunctEnterEx((LPARAM)NULL, "CatStoreDeinitGlobals");
    //
    // Nothing to do
    //
    CatFunctLeaveEx((LPARAM)NULL);
} // CatStoreDeinitGlobals


//+------------------------------------------------------------
//
// Function: CCfgConnectionCache::GetConnection
//
// Synopsis: Same as CLdapConnectionCache::GetConnection, except
//           retrieves a CCfgConnection instead of a CLdapConnection.
//
// Arguments:
//  ppConn: out parameter for new connection
//  pServerConfig: desired configuration
//  pCLdapServerConfig: Pointer to config object
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/12/20 16:49:12: Created.
//
//-------------------------------------------------------------
HRESULT CCfgConnectionCache::GetConnection(
    CCfgConnection **ppConn,
    PLDAPSERVERCONFIG pServerConfig,
    CLdapServerCfg *pCLdapServerConfig)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CCfgConnectionCache::GetConnection");

    hr = CBatchLdapConnectionCache::GetConnection(
        (CBatchLdapConnection **)ppConn,
        pServerConfig->szHost,
        pServerConfig->dwPort,
        pServerConfig->szNamingContext,
        pServerConfig->szAccount,
        pServerConfig->szPassword,
        pServerConfig->bt,
        (PVOID) pCLdapServerConfig); // pCreateContext
    
    if(FAILED(hr))
    {
        ERROR_LOG("CBatchldapConnection::GetConnection");
    }

    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCfgConnectionCache::GetConnection


//+------------------------------------------------------------
//
// Function: CCfgConnectionCache::CreateCachedLdapConnection
//
// Synopsis: Create a CCfgConnection (Called by GetConnection only)
//
// Arguments: See CLdapConnectionCache::CreateCachedLdapConnection
//
// Returns:
//  Connection ptr if successfull.
//  NULL if unsuccessfull.
//
// History:
// jstamerj 1999/12/20 16:57:49: Created.
//
//-------------------------------------------------------------
CCfgConnectionCache::CCachedLdapConnection * CCfgConnectionCache::CreateCachedLdapConnection(
    LPSTR szHost,
    DWORD dwPort,
    LPSTR szNamingContext,
    LPSTR szAccount,
    LPSTR szPassword,
    LDAP_BIND_TYPE bt,
    PVOID pCreateContext)
{
    HRESULT hr = S_OK;
    CCfgConnection *pret;
    
    CatFunctEnterEx((LPARAM)this, "CCfgConnectionCache::CreateCachedLdapConnection");

    pret = new CCfgConnection(
        szHost,
        dwPort,
        szNamingContext,
        szAccount,
        szPassword,
        bt,
        this,
        (CLdapServerCfg *)pCreateContext);

    if(pret) {
        hr = pret->HrInitialize();
        if(FAILED(hr)) {
            ERROR_LOG("pret->HrInitialize");
            pret->Release();
            pret = NULL;
        }
    } else {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CCfgConnection");
    }

    CatFunctLeaveEx((LPARAM)this);
    return pret;
} // CCfgConnectionCache::CreateCachedLdapConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\inc\idstore.h ===
//
// idstore.h -- This file contains class and function definitions for
//
//      CEmailIDStore -- A pure virtual class that is used by the common
//          router code to store and retrieve email ID information. By making
//          this a pure virtual class, we facilitate multiple implementations
//          of this class.
//
//      GetEmailIDStore -- Each implementation must provide this routine to
//          return a pointer to an uninitialized instance of a CEmailIDStore.
//
//      ReleaseEmailIDStore -- Each implementation must provide this routine
//          to free up resources used by the instance of CEmailIDStore being
//          released.
//
// Created:
//      Dec 17, 1996 -- Milan Shah (milans)
//
// Changes:
//

#ifndef __IDSTORE_H__
#define __IDSTORE_H__

#include <windows.h>
#include <transmem.h>
#include "catdefs.h"
#include "cattype.h"
#include "smtpevent.h"

//
// A FNLIST_COMPLETION routine is called when all email ids in a list being
// resolve asynchronously have been resolved.
//
typedef VOID (*LPFNLIST_COMPLETION)(VOID *pContext);

typedef VOID (*LPSEARCHCOMPLETIONCOMPLETION)(
    LPVOID lpContext);

typedef VOID (*PFN_DLEXPANSIONCOMPLETION)(
    HRESULT hrStatus,
    PVOID pContext);

class CInsertionRequest;

template <class T> class CEmailIDStore {
  public:

    //
    // Initialize the store.
    // If this fails, SMTPSVC will not start
    //
    virtual HRESULT Initialize(
        ICategorizerParametersEx *pICatParams,
        ISMTPServer *pISMTPServer) = 0;

    //
    // Create a new context for looking up a list of entries
    // asynchronously
    //
    virtual HRESULT InitializeResolveListContext(
        VOID *pUserContext,
        LPRESOLVE_LIST_CONTEXT pResolveListContext) = 0;

    //
    // Free the context allocated witht InitializeResolveListContext
    //
    virtual VOID FreeResolveListContext(
        LPRESOLVE_LIST_CONTEXT pResolveListContext) = 0;

    virtual HRESULT InsertInsertionRequest(
        LPRESOLVE_LIST_CONTEXT pResolveListContext,
        CInsertionRequest *pCRequest) = 0;

    //
    // Fetch an entry asynchronously. This function returns as soon as
    // the Lookup request has been queued.
    // Lookup the address contained in the CCatAddr object.
    // Upon completion, SetProperty routines will be called in the
    // CCatAddr object for returned properties followed by a call
    // to CCatAddr::HrCompletion
    //
    virtual HRESULT LookupEntryAsync(
        T *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pResolveListContext) = 0;

    //
    // Multi-Thread-UNSAFE cancel of pending resolves in the resolve list
    // context that have not yet been dispatched
    //
    virtual HRESULT CancelResolveList(
        LPRESOLVE_LIST_CONTEXT pResolveListContext,
        HRESULT hr) = 0;

    //
    // Cancel all outstanding lookup requests
    //
    virtual VOID CancelAllLookups() = 0;

    //
    // Paged DL's require repeated lookups with a "special" attribute
    // list (ie. "members;range=1000-*").  Because of this special
    // behavior, we have an interface function for it.
    //
    virtual HRESULT HrExpandPagedDlMembers(
        CCatAddr *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext,
        CAT_ADDRESS_TYPE CAType,
        PFN_DLEXPANSIONCOMPLETION pfnCompletion,
        PVOID pContext) = 0;

    //
    // Similar to paged DLs, dynamic DLs require a special lookup
    // where every result found is a DL member.  Rather than pass a
    // query string dirctly to ldapstor we have a special interface
    // function for Dynamic DLs
    //
    virtual HRESULT HrExpandDynamicDlMembers(
        CCatAddr *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext,
        PFN_DLEXPANSIONCOMPLETION pfnCompletion,
        PVOID pContext) = 0;

    //
    // Users of this object should call GetInsertionContext before
    // calling LookupEntryAsync.  ReleaseInsertionContext should be
    // called once for every GetInsertionContext.
    //
    virtual VOID GetInsertionContext(
        LPRESOLVE_LIST_CONTEXT pListContext) = 0;

    virtual VOID ReleaseInsertionContext(
        LPRESOLVE_LIST_CONTEXT pListContext) = 0;
};

//
// Function to instantiate a new CEmailIDStore object.
//
template <class T> HRESULT GetEmailIDStore(
    CEmailIDStore<T> **ppStore);

//
// Function to release an instance of CEmailIDStore object.
//
template <class T> VOID ReleaseEmailIDStore(
    CEmailIDStore<T> *pStore);

class CInsertionRequest
{
  public:
    CInsertionRequest()
    {
        m_dwRefCount = 1;
    }
    virtual ~CInsertionRequest()
    {
        _ASSERT(m_dwRefCount == 0);
    }
    virtual DWORD AddRef()
    {
        return InterlockedIncrement((PLONG)&m_dwRefCount);
    }
    virtual DWORD Release()
    {
        DWORD dwRet;
        dwRet = InterlockedDecrement((PLONG)&m_dwRefCount);
        if(dwRet == 0)
            FinalRelease();
        return dwRet;
    }
    virtual HRESULT HrInsertSearches(
        DWORD dwcSearches) = 0;
        
    virtual DWORD GetMinimumRequiredSearches()
    {
        return 1;
    }
    virtual VOID NotifyDeQueue(
        HRESULT hr) = 0;
        
    virtual BOOL IsBatchable()
    {
        return TRUE;
    }

    LIST_ENTRY m_listentry_insertionrequest;

  protected:
    virtual VOID FinalRelease()
    {
        delete this;
    }

    LONG m_dwRefCount;
};



#endif // __IDSTORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\cnfgmgr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: cnfgmgr.h
//
// Contents: Declaration of classes related to the handling on
//           different LDAP host configurations.
//           This includes LDAP failover and load balancing.
//
// Classes:
//  CLdapCfgMgr
//  CLdapCfg
//  CLdapHost
//  CCfgConnectionCache
//  CCfgConnection
//
// Functions:
//
// History:
// jstamerj 1999/06/15 14:49:52: Created.
//
//-------------------------------------------------------------
#ifndef __CNFGMGR_H__
#define __CNFGMGR_H__


#include <windows.h>
#include "asyncctx.h"
#include <baseobj.h>
#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <baseobj.h>
#include "asyncctx.h"

class CLdapCfg;
class CLdapServerCfg;
class CCfgConectionCache;
class CCfgConnection;

#define CONN_RETRY_TIME         (5*60)      // 5 Minutes
typedef DWORD CONN_PRIORITY;

enum CONN_STATE {
    CONN_STATE_INITIAL,
    CONN_STATE_CONNECTED,
    CONN_STATE_DOWN,
    CONN_STATE_RETRY,
};

typedef struct _tagLdapServerConfig {
    DWORD dwPort;
    CONN_PRIORITY pri;
    LDAP_BIND_TYPE bt;
    CHAR  szHost[CAT_MAX_DOMAIN];
    CHAR  szNamingContext[CAT_MAX_DOMAIN];
    CHAR  szAccount[CAT_MAX_LOGIN];
    CHAR  szPassword[CAT_MAX_PASSWORD];
} LDAPSERVERCONFIG, *PLDAPSERVERCONFIG;

typedef DWORD LDAPSERVERCOST, *PLDAPSERVERCOST;

//
// Connection costs:
//
// The smallest unit of cost is the number of pending searches.
// The next factor of cost is the connection state.
// States:
//   Connected = + COST_CONNECTED
//   Initially state (unconnected) = + COST_INITIAL
//   Connection down = + COST_RETRY
//   Connection recently went down = + COST_DOWN
//
// A configurable priority is always added to the cost.
//
#define DEFAULT_COST_CONNECTED_LOCAL    0
#define DEFAULT_COST_CONNECTED_REMOTE   2
#define DEFAULT_COST_INITIAL_LOCAL      4
#define DEFAULT_COST_INITIAL_REMOTE     8
#define DEFAULT_COST_RETRY_LOCAL        6
#define DEFAULT_COST_RETRY_REMOTE       10
#define COST_DOWN_LOCAL         0x80000000
#define COST_DOWN_REMOTE        0x80000000
#define COST_TOO_HIGH_TO_CONNECT 0x80000000

//
// Registry key and value names for initializing GC cost values from the registry
//
#define GC_COST_PARAMETERS_KEY "System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"
#define GC_COST_CONNECTED_LOCAL_VALUE       "GCCostConnectedLocal"
#define GC_COST_CONNECTED_REMOTE_VALUE      "GCCostConnectedRemote"
#define GC_COST_INITIAL_LOCAL_VALUE         "GCCostInitialLocal"
#define GC_COST_INITIAL_REMOTE_VALUE        "GCCostInitialRemote"
#define GC_COST_RETRY_LOCAL_VALUE           "GCCostRetryLocal"
#define GC_COST_RETRY_REMOTE_VALUE          "GCCostRetryRemote"

//
// The maximum number of threads that will try to connect to a
// connection in CONN_STATE_RETRY:
//
#define MAX_CONNECT_THREADS     1

//
// Requerying of available GC control:
// The code will rebuild the list of available GCs at a hard coded
// time interval.  The code will also requery for available GCs after
// a hard coded number of connection failures and a minimum time interval.
//
#define DEFAULT_REBUILD_GC_LIST_MAX_INTERVAL    (60*60)     // 1 hour
#define DEFAULT_REBUILD_GC_LIST_MAX_FAILURES    (100)       // 100 connection failures
#define DEFAULT_REBUILD_GC_LIST_MIN_INTERVAL    (60*5)      // 5 minutes

//
// Registry key and value names for initializing values from the registry
//
#define REBUILD_GC_LIST_PARAMETERS_KEY "System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"
#define REBUILD_GC_LIST_MAX_INTERVAL_VALUE      "RebuildGCListMaxInterval"
#define REBUILD_GC_LIST_MAX_FAILURES_VALUE      "RebuildGCListMaxFailures"
#define REBUILD_GC_LIST_MIN_INTERVAL_VALUE      "RebuildGCListMinInterval"

//
// An LDAP connection cache object that creates CCfgConnection objects
//
class CCfgConnectionCache :
    public CBatchLdapConnectionCache
{
  public:
    CCfgConnectionCache(
        ISMTPServerEx *pISMTPServerEx) :
        CBatchLdapConnectionCache(pISMTPServerEx)
    {
    }
    HRESULT GetConnection(
        CCfgConnection **ppConn,
        PLDAPSERVERCONFIG pServerConfig,
        CLdapServerCfg *pCLdapServerConfig);

    CCachedLdapConnection *CreateCachedLdapConnection(
        LPSTR szHost,
        DWORD dwPort,
        LPSTR szNamingContext,
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        PVOID pCreateContext);
    
  private:
    #define SIGNATURE_CCFGCONNECTIONCACHE           (DWORD)'CCCC'
    #define SIGNATURE_CCFGCONNECTIONCACHE_INVALID   (DWORD)'CCCX'
    DWORD m_dwSignature;
};

//
// CLdapCfgMgr is a wrapper around CLdapCfg.  It contains thread save
// code to build a new CLdapCfg object with a new list of available
// LDAP servers
//
CatDebugClass(CLdapCfgMgr),
    public CBaseObject
{
  public:
    CLdapCfgMgr(
        ISMTPServerEx *pISMTPServerEx,
        BOOL fAutomaticConfigUpdate,
        ICategorizerParameters *pICatParams,
        LDAP_BIND_TYPE bt = BIND_TYPE_NONE,
        LPSTR pszAccount = NULL,
        LPSTR pszPassword = NULL,
        LPSTR pszNamingContext = NULL);

    //
    // Reads parameters from the registry, setting member variables
    // when configuration data is available
    //
    VOID InitializeFromRegistry();

    //
    // Build a list of all available GCs and initialize
    // This function may be called multiple times (necessary if the
    // available GCs change)
    //
    HRESULT HrInit(
        BOOL fRediscoverGCs = FALSE);

    //
    // Initialize using a specified list of avialable LDAP servers
    // THis function may be called more than once
    //
    HRESULT HrInit(
        DWORD dwcServers, 
        PLDAPSERVERCONFIG prgServerConfig);

    //
    // Get a connection
    //
    HRESULT HrGetConnection(
        CCfgConnection **ppConn);

    //
    // Called very often to update the GC configuration if warranted.
    //
    HRESULT HrUpdateConfigurationIfNecessary();

    //
    // Wrapper to cancel all searches on all connections
    //
    VOID CancelAllConnectionSearches(
        ISMTPServer *pIServer)
    {
        m_LdapConnectionCache.CancelAllConnectionSearches(
            pIServer);
    }

    ISMTPServerEx * GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }

  private:
    ~CLdapCfgMgr();

    HRESULT HrGetGCServers(
        IN  ICategorizerLdapConfig *pICatLdapConfigInterface,
        IN  LDAP_BIND_TYPE bt,
        IN  LPSTR pszAccount,
        IN  LPSTR pszPassword,
        IN  LPSTR pszNamingContext,
        OUT DWORD *pdwcServerConfig,
        OUT PLDAPSERVERCONFIG *pprgServerConfig);

    HRESULT HrBuildGCServerArray(
        IN  LDAP_BIND_TYPE bt,
        IN  LPSTR pszAccount,
        IN  LPSTR pszPassword,
        IN  LPSTR pszNamingContext,
        IN  BOOL  fRediscoverGCs,
        OUT DWORD *pdwcServerConfig,
        OUT PLDAPSERVERCONFIG *pprgServerConfig);

    HRESULT HrBuildArrayFromDCInfo(
        IN  LDAP_BIND_TYPE bt,
        IN  LPSTR pszAccount,
        IN  LPSTR pszPassword,
        IN  LPSTR pszNamingContext,
        IN  DWORD dwcDSDCInfo,
        IN  PDS_DOMAIN_CONTROLLER_INFO_2 prgDSDCInfo,
        OUT DWORD *pdwcServerConfig,
        OUT PLDAPSERVERCONFIG *pprgServerConfig);

    BOOL fReadyForUpdate();

    LPSTR SzConnectNameFromDomainControllerInfo(
        PDS_DOMAIN_CONTROLLER_INFO_2 pDCInfo)
    {
        if(pDCInfo->DnsHostName)
            return pDCInfo->DnsHostName;
        else if(pDCInfo->NetbiosName)
            return pDCInfo->NetbiosName;
        else
            return NULL;
    }

    VOID LogCnfgInit();
    VOID LogCnfgEntry(PLDAPSERVERCONFIG pConfig);
        
  private:
    #define SIGNATURE_CLDAPCFGMGR           (DWORD)'MCLC'
    #define SIGNATURE_CLDAPCFGMGR_INVALID   (DWORD)'MCLX'
    DWORD m_dwSignature;
    BOOL  m_fAutomaticConfigUpdate;
    DWORD m_dwUpdateInProgress;
    ULARGE_INTEGER m_ulLastUpdateTime;
    CExShareLock m_sharelock;
    CLdapCfg *m_pCLdapCfg;
    DWORD m_dwRebuildGCListMaxInterval;
    DWORD m_dwRebuildGCListMaxFailures;
    DWORD m_dwRebuildGCListMinInterval;

    //
    // Default configuration to use with automatic host selection
    //
    LDAP_BIND_TYPE      m_bt;
    CHAR                m_szNamingContext[CAT_MAX_DOMAIN];
    CHAR                m_szAccount[CAT_MAX_LOGIN];
    CHAR                m_szPassword[CAT_MAX_PASSWORD];

    ICategorizerParameters  *m_pICatParams;
    ISMTPServerEx       *m_pISMTPServerEx;

    CCfgConnectionCache m_LdapConnectionCache;
};

//
// CLdapCfg contains the configuration of a group of LDAP servers at
// one point in time.  The group of LDAP servers may not be changed
// (without creating a new CLdapCfg object)
//
CatDebugClass(CLdapCfg), 
    public CBaseObject
{
  public:
    CLdapCfg(
        ISMTPServerEx *pISMTPServerEx);

    void * operator new(size_t size, DWORD dwcServers);
    //
    // HrInit should only be called once per object
    //
    HRESULT HrInit(
        DWORD dwcServers,
        PLDAPSERVERCONFIG prgServerConfig,
        CLdapCfg *pCLdapCfgOld);

    //
    // Get a connection
    //
    HRESULT HrGetConnection(
        CCfgConnection **ppConn,
        CCfgConnectionCache *pLdapConnectionCache);

    DWORD DwNumConnectionFailures()
    {
        return m_dwcConnectionFailures;
    }
    DWORD DwNumServers()
    {
        return m_dwcServers;
    }
    ISMTPServerEx * GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }

  private:
    ~CLdapCfg();

    VOID ShuffleArray();

  private:
    #define SIGNATURE_CLDAPCFG              (DWORD)'fCLC'
    #define SIGNATURE_CLDAPCFG_INVALID      (DWORD)'fCLX'

    DWORD m_dwSignature;
    DWORD m_dwInc;
    CExShareLock m_sharelock;    // Protects m_prgpCLdapServerCfg
    DWORD m_dwcServers;
    DWORD m_dwcConnectionFailures;
    CLdapServerCfg **m_prgpCLdapServerCfg;
    ISMTPServerEx *m_pISMTPServerEx;
};

//
// CLdapServerCfg maintains information on the state of one LDAP
// server/port
//
CatDebugClass(CLdapServerCfg)
{
  public:
    static VOID GlobalInit()
    {
        InitializeListHead(&m_listhead);
        InitializeFromRegistry();
    }
    
    static VOID InitializeFromRegistry();

    static HRESULT GetServerCfg(
        IN  ISMTPServerEx *pISMTPServerEx,
        IN  PLDAPSERVERCONFIG pServerConfig,
        OUT CLdapServerCfg **ppCLdapServerCfg);

    LONG AddRef()
    {
        return InterlockedIncrement(&m_lRefCount);
    }
    LONG Release()
    {
        LONG lRet;
        lRet = InterlockedDecrement(&m_lRefCount);
        if(lRet == 0) {
            //
            // Remove object from global list and destroy
            //
            m_listlock.ExclusiveLock();

            if(m_lRefCount > 0) {
                //
                // Somebody grabbed this object out of the global list
                // and AddRef'd it.  Abort deletion.
                //
            } else {
                
                RemoveEntryList(&m_le);
                delete this;
            }
            m_listlock.ExclusiveUnlock();
        }
        return lRet;
    }

    //
    // Get a connection
    //
    HRESULT HrGetConnection(
        ISMTPServerEx *pISMTPServerEx,
        CCfgConnection **ppConn,
        CCfgConnectionCache *pLdapConnectionCache);

    VOID Cost(
        IN  ISMTPServerEx *pISMTPServerEx,
        OUT PLDAPSERVERCOST pCost);
        
    VOID IncrementPendingSearches()
    {
        DWORD dwcSearches;
        CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::IncrementPendingSearches");
        dwcSearches = (LONG) InterlockedIncrement((PLONG)&m_dwcPendingSearches);
        DebugTrace((LPARAM)this, "%ld pending searches on connection [%s:%d]",
                   dwcSearches, m_ServerConfig.szHost, m_ServerConfig.dwPort);
        CatFunctLeaveEx((LPARAM)this);
    }
    VOID DecrementPendingSearches()
    {
        DWORD dwcSearches;
        CatFunctEnterEx((LPARAM)this, "CLdapServerCfg::IncrementPendingSearches");
        dwcSearches = (DWORD) InterlockedDecrement((PLONG)&m_dwcPendingSearches);
        DebugTrace((LPARAM)this, "%ld pending searches on connection [%s:%d]",
                   dwcSearches, m_ServerConfig.szHost, m_ServerConfig.dwPort);
        CatFunctLeaveEx((LPARAM)this);
    }

    VOID UpdateConnectionState(
        ISMTPServerEx *pISMTPServerEx,
        ULARGE_INTEGER *pft,
        CONN_STATE connstate);

    VOID IncrementFailedCount()
    {
        InterlockedIncrement((PLONG) &m_dwcFailedConnectAttempts);
    }        
    VOID ResetFailedCount()
    {
        InterlockedExchange((PLONG) &m_dwcFailedConnectAttempts, 0);
    }        
    CONN_STATE CurrentState()
    {
        return m_connstate;
    }
    ULARGE_INTEGER GetCurrentTime()
    {
        ULARGE_INTEGER FileTime;

        _ASSERT(sizeof(ULARGE_INTEGER) == sizeof(FILETIME));
        GetSystemTimeAsFileTime((LPFILETIME)&FileTime);
        return FileTime;
    }
  private:
    CLdapServerCfg();
    ~CLdapServerCfg();

    HRESULT HrInit(
        PLDAPSERVERCONFIG pServerConfig);

    BOOL fReadyForRetry()
    {
        // 100 nanoseconds * 10^7 == 1 second
        return ((GetCurrentTime().QuadPart - m_ftLastStateUpdate.QuadPart) >=
                ((LONGLONG)CONN_RETRY_TIME * 10000000));
    }

    BOOL fMatch(
        PLDAPSERVERCONFIG pServerConfig);

    VOID LogStateChangeEvent(
        IN  ISMTPServerEx *pISMTPServerEx,
        IN  CONN_STATE connstate,
        IN  LPSTR pszHost,
        IN  DWORD dwPort);

    static CLdapServerCfg *FindServerCfg(
        PLDAPSERVERCONFIG pServerConfig);

    static BOOL fIsLocalComputer(
        PLDAPSERVERCONFIG pServerConfig);

  private:
    #define SIGNATURE_CLDAPSERVERCFG         (DWORD)'CSLC'
    #define SIGNATURE_CLDAPSERVERCFG_INVALID (DWORD)'CSLX'

    static DWORD m_dwCostConnectedLocal;
    static DWORD m_dwCostConnectedRemote;
    static DWORD m_dwCostInitialLocal;
    static DWORD m_dwCostInitialRemote;
    static DWORD m_dwCostRetryLocal;
    static DWORD m_dwCostRetryRemote;

    DWORD m_dwSignature;
    LONG m_lRefCount;
    LDAPSERVERCONFIG m_ServerConfig;
    CExShareLock m_sharelock;
    CONN_STATE m_connstate;
    ULARGE_INTEGER m_ftLastStateUpdate;
    DWORD m_dwcPendingSearches;
    DWORD m_dwcCurrentConnectAttempts;
    DWORD m_dwcFailedConnectAttempts;

    //
    // Member variables to keep/protect a list of CLdapServer objects
    //
    static CExShareLock m_listlock;
    static LIST_ENTRY m_listhead;
    LIST_ENTRY m_le;

    BOOL m_fLocalServer;
};

//
// An LDAP connection that notifies CLdapServerCfg about state changes
//
class CCfgConnection :
    public CBatchLdapConnection
{
    #define SIGNATURE_CCFGCONNECTION           (DWORD)'oCCC'
    #define SIGNATURE_CCFGCONNECTION_INVALID   (DWORD)'oCCX'
  public:
    CCfgConnection(
        LPSTR szHost,
        DWORD dwPort,
        LPSTR szNamingContext,
        LPSTR szAccount,
        LPSTR szPassword,
        LDAP_BIND_TYPE bt,
        CLdapConnectionCache *pCache,
        CLdapServerCfg *pCLdapServerCfg) :
        CBatchLdapConnection(
            szHost,
            dwPort,
            szNamingContext,
            szAccount,
            szPassword,
            bt,
            pCache)
    {
        m_dwSignature = SIGNATURE_CCFGCONNECTION;
        m_pCLdapServerCfg = pCLdapServerCfg;
        pCLdapServerCfg->AddRef();

        m_connstate = CONN_STATE_INITIAL;
    }

    ~CCfgConnection()
    {
        _ASSERT(m_pCLdapServerCfg);
        m_pCLdapServerCfg->Release();

        _ASSERT(m_dwSignature == SIGNATURE_CCFGCONNECTION);
        m_dwSignature = SIGNATURE_CCFGCONNECTION_INVALID;
    }

    virtual HRESULT Connect();

    virtual HRESULT AsyncSearch(             // Asynchronously look up
        LPCWSTR szBaseDN,                    // objects matching specified
        int nScope,                          // criteria in the DS. The
        LPCWSTR szFilter,                    // results are passed to
        LPCWSTR szAttributes[],              // fnCompletion when they
        DWORD dwPageSize,                    // Optinal page size
        LPLDAPCOMPLETION fnCompletion,       // become available.
        LPVOID ctxCompletion);

  private:
    virtual VOID CallCompletion(
        PPENDING_REQUEST preq,
        PLDAPMessage pres,
        HRESULT hrStatus,
        BOOL fFinalCompletion);

    VOID NotifyServerDown();

  private:
    DWORD m_dwSignature;
    CLdapServerCfg *m_pCLdapServerCfg;
    CExShareLock m_sharelock;
    CONN_STATE m_connstate;
};


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::HrUpdateConfigurationIfNecessary
//
// Synopsis: Check to see if the CLdapCfg should be updated.
//           If it should be, do the update. 
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from HrInit
//
// History:
// jstamerj 1999/06/29 20:51:23: Created.
//
//-------------------------------------------------------------
inline HRESULT CLdapCfgMgr::HrUpdateConfigurationIfNecessary()
{
    HRESULT hr = S_OK;
    DWORD dw;
    BOOL fUpdate;

    if(m_fAutomaticConfigUpdate == FALSE)
        //
        // Update is disabled
        return S_OK;

    //
    // See if some other thread is already updating the configuration
    // (try to enter the lock)
    //
    dw = InterlockedExchange((PLONG)&m_dwUpdateInProgress, TRUE);

    if(dw == FALSE) {
        //
        // No other thread is updating
        //
        fUpdate = fReadyForUpdate();

        if(fUpdate) {
            //
            // Call HrInit to generate a new CLdapCfg
            //
            hr = HrInit(TRUE);
            if(SUCCEEDED(hr)) {
                //
                // Set the last update time
                //
                GetSystemTimeAsFileTime((LPFILETIME)&m_ulLastUpdateTime);
            }
        }
        //
        // Release the lock
        //
        InterlockedExchange((PLONG)&m_dwUpdateInProgress, FALSE);
    }
    return hr;
} // CLdapCfgMgr::HrUpdateConfigurationIfNecessary


//+------------------------------------------------------------
//
// Function: CLdapCfgMgr::fReadyForUpdate
//
// Synopsis: Calculates wether or not this object is due for an
//           automatic cfg update
//
// Arguments: NONE
//
// Returns:
//  TRUE: Yes, it is time for an update
//  FALSE: No, an update is not required at this time
//
// History:
// jstamerj 1999/06/30 12:08:35: Created.
//
//-------------------------------------------------------------
inline BOOL CLdapCfgMgr::fReadyForUpdate()
{
    DWORD dwNumConnectionFailures;
    ULARGE_INTEGER ulCurrentTime;

    //
    // We need an update when:
    // 1) A periodic time interval has ellapsed
    // 100 ns * 10^7 == 1 second
    //
    GetSystemTimeAsFileTime((LPFILETIME)&ulCurrentTime);

    if((ulCurrentTime.QuadPart - m_ulLastUpdateTime.QuadPart) >=
       (ULONGLONG) Int32x32To64((LONG)m_dwRebuildGCListMaxInterval, 10000000))
        
        return TRUE;

    //
    // We also need an update when:
    // 2) We have received more than a set number of connection
    // failures on the current configuration and at least a minimum
    // time interval has passed 
    //
    // Check for the mimimum time interval
    //
    if( (ulCurrentTime.QuadPart - m_ulLastUpdateTime.QuadPart) >=
        (ULONGLONG) Int32x32To64((LONG)m_dwRebuildGCListMinInterval, 10000000)) {
        //
        // Get the number of connection failures
        //
        m_sharelock.ShareLock();
    
        if(m_pCLdapCfg) {
            dwNumConnectionFailures = m_pCLdapCfg->DwNumConnectionFailures();
        } else {
            dwNumConnectionFailures = 0;
            _ASSERT(0 && "HrInit was not called or failed");
        }

        m_sharelock.ShareUnlock();

        if(dwNumConnectionFailures >= m_dwRebuildGCListMaxFailures)
            return TRUE;
    }

    return FALSE;
} // CLdapCfgMgr::fReadyForUpdate

#endif //__CNFGMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatasync.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatasync.h
//
// Contents: Implementation of ICategorizerAsyncContext
//
// Classes: CICategorizerAyncContext
//
// Functions:
//
// History:
// jstamerj 1998/07/16 11:13:50: Created.
//
//-------------------------------------------------------------
#ifndef _ICATASYNC_H_
#define _ICATASYNC_H_


#include <windows.h>
#include <smtpevent.h>
#include <dbgtrace.h>

CatDebugClass(CICategorizerAsyncContextIMP),
    public ICategorizerAsyncContext
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ICategorizerAsyncContext
    STDMETHOD (CompleteQuery) (
        IN  PVOID   pvQueryContext,
        IN  HRESULT hrResolutionStatus,
        IN  DWORD   dwcResults,
        IN  ICategorizerItemAttributes **rgpItemAttributes,
        IN  BOOL    fFinalCompletion);

 public:
    VOID SetISMTPServerEx(ISMTPServerEx *pISMTPServerEx)
    {
        _ASSERT(m_pISMTPServerEx == NULL);
        m_pISMTPServerEx = pISMTPServerEx;
        if(m_pISMTPServerEx)
            m_pISMTPServerEx->AddRef();
    }
    ISMTPServerEx * GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }

  private:
    CICategorizerAsyncContextIMP();
    ~CICategorizerAsyncContextIMP();

  private:
    #define SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP          (DWORD)'ICAC'
    #define SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP_INVALID  (DWORD)'XCAC'

    DWORD m_dwSignature;
    ULONG m_cRef;
    ISMTPServerEx *m_pISMTPServerEx;

    friend class CAsyncLookupContext;
    friend class CSearchRequestBlock;
};



//+------------------------------------------------------------
//
// Function: CICategorizerAsyncContext::CICategorizerAsyncContext
//
// Synopsis: Initialize signature/refcount
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/16 11:21:36: Created.
//
//-------------------------------------------------------------
inline CICategorizerAsyncContextIMP::CICategorizerAsyncContextIMP()
{
    m_dwSignature = SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP;
    m_cRef = 0;
    m_pISMTPServerEx = NULL;
}


//+------------------------------------------------------------
//
// Function: CICategorizerAsyncContext::~CICategorizerAsyncContext
//
// Synopsis: Assert check member variables before destruction
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/16 11:23:26: Created.
//
//-------------------------------------------------------------
inline CICategorizerAsyncContextIMP::~CICategorizerAsyncContextIMP()
{
    _ASSERT(m_cRef == 0);

    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    _ASSERT(m_dwSignature == SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP);
    m_dwSignature = SIGNATURE_CICATEGORIZERASYNCCONTEXTIMP_INVALID;
}
    
#endif //_ICATASYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\globals.h ===
//
// ldapdata.h -- This file contains the global data structures used by the
//  LDAP Email ID store implementation
//
// Created:
//  Jan 12, 1996    Milan Shah (milans)
//
// Changes:
//

#include "winldap.h"
#include "ldapstr.h"
#include "ldapstor.h"
#include "ldapconn.h"
#include "asyncctx.h"
#include "cnfgmgr.h"

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

//
// Defines used for debugging
//

#define LDAP_STORE_DBG      0x100
#define LDAP_CONN_DBG       0x101
#define LDAP_CCACHE_DBG     0x102
#define LDAP_DCACHE_DBG     0x103

#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatitemattr.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitemattr.cpp
//
// Contents: Implementation of CICategorizerItemAttributesIMP
//
// Classes:
//   CLdapResultWrap
//   CICategorizerItemAttributesIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/01 13:48:15: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatitemattr.h"



//+------------------------------------------------------------
//
// Function: CLdapResultWrap::CLdapResultWrap
//
// Synopsis: Refcount an LDAP Message, call ldap_msg_free when all
//           references have been released
//
// Arguments:
//  pCPLDAPWrap: PLDAP to refcount
//  pMessage: the LDAPMessage to refcount
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/10/05 13:12:15: Created.
//
//-------------------------------------------------------------
CLdapResultWrap::CLdapResultWrap(
    ISMTPServerEx *pISMTPServerEx,
    CPLDAPWrap *pCPLDAPWrap,
    PLDAPMessage pMessage)
{
    _ASSERT(pCPLDAPWrap);
    _ASSERT(pMessage);

    m_pCPLDAPWrap = pCPLDAPWrap;
    m_pCPLDAPWrap->AddRef();
    m_pLDAPMessage = pMessage;
    m_lRefCount = 0;
    m_pISMTPServerEx = pISMTPServerEx;
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->AddRef();
}


//+------------------------------------------------------------
//
// Function: CLdapResultWrap::AddRef
//
// Synopsis: Increment the ref count of this object
//
// Arguments: NONE
//
// Returns: new refcount
//
// History:
// jstamerj 1998/10/05 13:14:59: Created.
//
//-------------------------------------------------------------
LONG CLdapResultWrap::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}


//+------------------------------------------------------------
//
// Function: CLdapResultWrap::Release
//
// Synopsis: Decrement the ref count.  Free the object when the
//           refcount hits zero
//
// Arguments: NONE
//
// Returns: New refcount
//
// History:
// jstamerj 1998/10/05 13:26:47: Created.
//
//-------------------------------------------------------------
LONG CLdapResultWrap::Release()
{
    LONG lNewRefCount;

    lNewRefCount = InterlockedDecrement(&m_lRefCount);

    if(lNewRefCount == 0) {
        //
        // Release this ldapmessage
        //
        delete this;
        return 0;

    } else {

        return lNewRefCount;
    }
}


//+------------------------------------------------------------
//
// Function: CLdapResultWrap::~CLdapResultWrap
//
// Synopsis: Release the ldap message result
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/10/05 13:31:39: Created.
//
//-------------------------------------------------------------
CLdapResultWrap::~CLdapResultWrap()
{
    m_pCPLDAPWrap->Release();
    ldap_msgfree(m_pLDAPMessage);
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();
}



//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::CICategorizerItemAttributesIMP
//
// Synopsis: Initializes member data
//
// Arguments:
//  pldap: PLDAP to use
//  pldapmessage: PLDAPMessage to serve out
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/02 12:35:15: Created.
//
//-------------------------------------------------------------
CICategorizerItemAttributesIMP::CICategorizerItemAttributesIMP(
    PLDAP pldap,
    PLDAPMessage pldapmessage,
    CLdapResultWrap *pResultWrap)
{
    m_dwSignature = CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE;

    _ASSERT(pldap);
    _ASSERT(pldapmessage);
    _ASSERT(pResultWrap);

    m_pldap = pldap;
    m_pldapmessage = pldapmessage;
    m_cRef = 0;
    m_pResultWrap = pResultWrap;
    m_pResultWrap->AddRef();
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::~CICategorizerItemAttributesIMP
//
// Synopsis: Checks to make sure signature is valid and then resets signature
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/02 12:39:45: Created.
//
//-------------------------------------------------------------
CICategorizerItemAttributesIMP::~CICategorizerItemAttributesIMP()
{
    m_pResultWrap->Release();

    _ASSERT(m_dwSignature == CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE);
    m_dwSignature = CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE_INVALID;
}


//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerItemAttributes
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerItemAttributes) {
        *ppv = (LPVOID) ((ICategorizerItemAttributes *) this);
    } else if (iid == IID_ICategorizerItemRawAttributes) {
        *ppv = (LPVOID) ((ICategorizerItemRawAttributes *) this);
    } else if (iid == IID_ICategorizerUTF8Attributes) {
        *ppv = (LPVOID) ((ICategorizerUTF8Attributes *) this);
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerItemAttributesIMP::AddRef()
{
    return InterlockedIncrement((PLONG)&m_cRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero.
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerItemAttributesIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((PLONG)&m_cRef);
    if(lNewRefCount == 0) {
        delete this;
        return 0;
    } else {
        return lNewRefCount;
    }
}


//+------------------------------------------------------------
//
// Function: BeginAttributeEnumeration
//
// Synopsis: Prepare to enumerate through attribute values for a specific attribute
//
// Arguments:
//  pszAttributeName: Name of attribute to enumerate through
//  penumerator: Uninitialized Enumerator structure to use
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: No attributes values exist
//
// History:
// jstamerj 1998/07/02 10:54:00: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::BeginAttributeEnumeration(
    IN  LPCSTR pszAttributeName,
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::BeginAttributeEnumeration");
    _ASSERT(pszAttributeName);
    _ASSERT(penumerator);

    penumerator->pvBase =
 penumerator->pvCurrent = ldap_get_values(
     m_pldap,
     m_pldapmessage,
     (LPSTR)pszAttributeName);

    if(penumerator->pvBase == NULL) {
        ErrorTrace((LPARAM)this, "Requested attribute %s not found", pszAttributeName);
        CatFunctLeaveEx((LPARAM)this);
        return CAT_E_PROPNOTFOUND;
    }

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: GetNextAttributeValue
//
// Synopsis: Get the next attribute in an enumeration
//
// Arguments:
//  penumerator: enumerator sturcture initialized in BeginAttributeEnumeration
//  ppszAttributeValue: Ptr to Ptr to recieve Ptr to string of attribute value
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/07/02 11:14:54: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::GetNextAttributeValue(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT LPSTR *ppszAttributeValue)
{
    _ASSERT(penumerator);
    _ASSERT(ppszAttributeValue);

    *ppszAttributeValue = *((LPSTR *)penumerator->pvCurrent);

    if(*ppszAttributeValue) {
        //
        // Advance enumerator to next value
        //
        penumerator->pvCurrent = (PVOID) (((LPSTR *)penumerator->pvCurrent)+1);
        return S_OK;
    } else {
        //
        // This is the last value
        //
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }
}



//+------------------------------------------------------------
//
// Function: RewindAttributeEnumeration
//
// Synopsis: Rewind enumerator to beginning of attribute value list
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/06 11:22:23: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::RewindAttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    penumerator->pvCurrent = penumerator->pvBase;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: EndAttributeEnumeration
//
// Synopsis: Free memory associated with an attribute enumeration
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/02 12:24:44: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::EndAttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    _ASSERT(penumerator);

    ldap_value_free((LPSTR *)penumerator->pvBase);

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::BeginAttributeNameEnumeration
//
// Synopsis: Enumerate through the attributes returned from LDAP
//
// Arguments:
//  penumerator: Caller allocated enumerator structure to be
//  initialized by this call
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/18 10:49:56: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::BeginAttributeNameEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    _ASSERT(penumerator);

    penumerator->pvBase =
    penumerator->pvCurrent = NULL;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::GetNextAttributeName
//
// Synopsis: enumerate through the attribute names returned
//
// Arguments:
//  penumerator: enumerator strucutre initialized in BeginAttributeNameEnumeration
//  ppszAttributeValue: out parameter for an attribute name
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/09/18 10:53:15: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::GetNextAttributeName(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT LPSTR *ppszAttributeName)
{
    _ASSERT(penumerator);
    _ASSERT(ppszAttributeName);

    if(penumerator->pvCurrent == NULL) {

        *ppszAttributeName = ldap_first_attribute(
            m_pldap,
            m_pldapmessage,
            (BerElement **) &(penumerator->pvCurrent));

    } else {

        *ppszAttributeName = ldap_next_attribute(
            m_pldap,
            m_pldapmessage,
            (BerElement *) (penumerator->pvCurrent));
    }

    if(*ppszAttributeName == NULL) {
        //
        // Assume we've reached the end of the attribute name
        // enumeration
        //
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    } else {

        return S_OK;
    }
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributeIMP::EndAttributeNameEnumeration
//
// Synopsis: Free all data held for this enumeration
//
// Arguments:
//  penumerator: enumerator strucutre initialized in BeginAttributeNameEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/18 11:04:37: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::EndAttributeNameEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    //
    // Ldap uses only buffers in the connection block for this, so we
    // don't need to explicitly free anything
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::AggregateAttributes
//
// Synopsis: Normally, accept and ICategorizerItemAttributes for aggregation
//
// Arguments:
//  pICatItemAttributes: attributes to aggregate
//
// Returns:
//  E_NOTIMPL
//
// History:
// jstamerj 1998/07/16 14:42:16: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::AggregateAttributes(
    IN  ICategorizerItemAttributes *pICatItemAttributes)
{
    return E_NOTIMPL;
}


//+------------------------------------------------------------
//
// Function: BeginRawAttributeEnumeration
//
// Synopsis: Prepare to enumerate through attribute values for a specific attribute
//
// Arguments:
//  pszAttributeName: Name of attribute to enumerate through
//  penumerator: Uninitialized Enumerator structure to use
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: No attributes values exist
//
// History:
// jstamerj 1998/12/09 12:44:15: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::BeginRawAttributeEnumeration(
    IN  LPCSTR pszAttributeName,
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::BeginRawAttributeEnumeration");
    _ASSERT(pszAttributeName);
    _ASSERT(penumerator);

    penumerator->pvBase =
 penumerator->pvCurrent = ldap_get_values_len(
     m_pldap,
     m_pldapmessage,
     (LPSTR)pszAttributeName);

    if(penumerator->pvBase == NULL) {
        ErrorTrace((LPARAM)this, "Requested attribute %s not found", pszAttributeName);
        CatFunctLeaveEx((LPARAM)this);
        return CAT_E_PROPNOTFOUND;
    }

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: GetNextRawAttributeValue
//
// Synopsis: Get the next attribute in an enumeration
//
// Arguments:
//  penumerator: enumerator sturcture initialized in BeginAttributeEnumeration
//  pdwcb: dword to set to the # of bytes in the pvValue buffer
//  pvValue: Ptr to recieve Ptr to raw attribute value
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/12/09 12:49:27: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::GetNextRawAttributeValue(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT PDWORD pdwcb,
    OUT LPVOID *pvValue)
{
    _ASSERT(penumerator);
    _ASSERT(pdwcb);
    _ASSERT(pvValue);

    if( (*((PLDAP_BERVAL *)penumerator->pvCurrent)) != NULL) {

        *pdwcb   = (* ((PLDAP_BERVAL *)penumerator->pvCurrent))->bv_len;
        *pvValue = (* ((PLDAP_BERVAL *)penumerator->pvCurrent))->bv_val;
        //
        // Advance enumerator to next value
        //
        penumerator->pvCurrent = (PVOID)
                                 (((PLDAP_BERVAL *)penumerator->pvCurrent)+1);
        return S_OK;

    } else {
        //
        // This is the last value
        //
        *pdwcb = 0;
        *pvValue = NULL;
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
    }
}

//+------------------------------------------------------------
//
// Function: RewindRawAttributeEnumeration
//
// Synopsis: Rewind enumerator to beginning of attribute value list
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/09 12:49:23: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::RewindRawAttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    return RewindAttributeEnumeration(penumerator);
}


//+------------------------------------------------------------
//
// Function: EndRawAttributeEnumeration
//
// Synopsis: Free memory associated with an attribute enumeration
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/09 12:50:02: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::EndRawAttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    _ASSERT(penumerator);

    ldap_value_free_len((struct berval **)penumerator->pvBase);

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::GetAllAttributeValues
//
// Synopsis: Retrieve all values for a particular attribute at once.
// This may not be optimal for attributes with a large number of
// values (enumerating through the values may be better performace wise).
//
// Arguments:
//  pszAttributeName: The name of the attribute you want
//  penumerator: A user allocated ATTRIBUTE_ENUMERATOR structure for
//               use by the ICategorizerItemAttributes implementor
//  prgpszAttributeValues: Where to return the pointer to the
//  attribute string array.  This will be a NULL terminated array of
//  pointers to strings.
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: None of those attributes exist
//
// History:
// jstamerj 1998/12/10 18:55:38: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::GetAllAttributeValues(
    LPCSTR pszAttributeName,
    PATTRIBUTE_ENUMERATOR penumerator,
    LPSTR **prgpszAttributeValues)
{
    HRESULT hr;

    CatFunctEnter("CICategorizerItemAttributesIMP::GetAllAttributeValues");
    //
    // piggy back on BeginAttributeEnumeration
    //
    hr = BeginAttributeEnumeration(
        pszAttributeName,
        penumerator);

    if(SUCCEEDED(hr)) {
        //
        // return the array
        //
        *prgpszAttributeValues = (LPSTR *) penumerator->pvBase;
    }

    DebugTrace(NULL, "returning hr %08lx", hr);
    CatFunctLeave();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::ReleaseAllAttributes
//
// Synopsis: Release the attributes allocated from GetAllAttributeValues
//
// Arguments:
//  penumerator: the enumerator passed into GetAllAttributeValues
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/10 19:38:57: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::ReleaseAllAttributeValues(
    PATTRIBUTE_ENUMERATOR penumerator)
{
    HRESULT hr;
    CatFunctEnter("CICategorizerItemAttributesIMP::ReleaseAllAttributes");

    //
    // piggy back off of endattributeenumeration
    //
    hr = EndAttributeEnumeration(
        penumerator);

    DebugTrace(NULL, "returning hr %08lx", hr);
    CatFunctLeave();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::CountAttributeValues
//
// Synopsis: Return a count of the number of attribute values associated
//           with this enumerator
//
// Arguments:
//  penumerator: describes the attribute in question
//  pdwCount: Out parameter for the count
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/25 14:36:58: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::CountAttributeValues(
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::CountAttributeValues");
    _ASSERT(pdwCount);
    *pdwCount = ldap_count_values((PCHAR *) penumerator->pvBase);

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
} // CICategorizerItemAttributesIMP::CountAttributeValues


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::CountRawAttributeValues
//
// Synopsis: Return a count of the number of attribute values associated
//           with this enumerator
//
// Arguments:
//  penumerator: describes the attribute in question
//  pdwCount: Out parameter for the count
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/25 14:39:54: Created
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::CountRawAttributeValues(
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::CountRawAttributeValues");
    _ASSERT(pdwCount);
    *pdwCount = ldap_count_values_len((struct berval **) penumerator->pvBase);

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
} // CICategorizerItemAttributesIMP::CountRawAttributeValues


//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::BeginUTF8AttributeEnumeration
//
// Synopsis: Begin UTF8 attribute enumeration
//
// Arguments:
//  pszAttributeName: Name of attribute to enumerate through
//  penumerator: Uninitialized Enumerator structure to use
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: No attributes values exist
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/12/10 11:14:35: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::BeginUTF8AttributeEnumeration(
    IN  LPCSTR pszAttributeName,
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::BeginUTF8AttributeEnumeration");
    //
    // Piggy back raw attribute enumeration and use the pvContext
    // member of penumerator.
    //
    hr = BeginRawAttributeEnumeration(
        pszAttributeName,
        penumerator);

    penumerator->pvContext = NULL;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: GetNextAttributeValue
//
// Synopsis: Get the next attribute in an enumeration
//
// Arguments:
//  penumerator: enumerator sturcture initialized in BeginAttributeEnumeration
//  ppszAttributeValue: Ptr to Ptr to recieve Ptr to string of attribute value
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/07/02 11:14:54: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::GetNextUTF8AttributeValue(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT LPSTR *ppszAttributeValue)
{
    HRESULT hr = S_OK;
    DWORD dwcb = 0;
    LPVOID pvAttributeValue = NULL;
    LPSTR psz = NULL;

    CatFunctEnterEx((LPARAM)this, "CICategorizerItemAttributesIMP::GetNextUTF8AttributeValue");

    if(penumerator->pvContext) {
        delete [] (LPSTR) penumerator->pvContext;
        penumerator->pvContext = NULL;
    }
    hr = GetNextRawAttributeValue(
        penumerator,
        &dwcb,
        &pvAttributeValue);

    if(FAILED(hr))
        return hr;

    //
    // Convert to termianted UTF8 string
    //
    psz = new CHAR[dwcb + 1];
    if(psz == NULL)
    {
        ERROR_LOG("new CHAR[]");
        return E_OUTOFMEMORY;
    }

    CopyMemory(psz, pvAttributeValue, dwcb);
    psz[dwcb] = '\0';
    *ppszAttributeValue = psz;
    penumerator->pvContext = psz;

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}



//+------------------------------------------------------------
//
// Function: RewindAttributeEnumeration
//
// Synopsis: Rewind enumerator to beginning of attribute value list
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/06 11:22:23: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::RewindUTF8AttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    return RewindRawAttributeEnumeration(
        penumerator);
}


//+------------------------------------------------------------
//
// Function: EndAttributeEnumeration
//
// Synopsis: Free memory associated with an attribute enumeration
//
// Arguments:
//  penumerator: attribute enumerator initialized by BeginAttributeEnumeration
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/02 12:24:44: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemAttributesIMP::EndUTF8AttributeEnumeration(
    IN  PATTRIBUTE_ENUMERATOR penumerator)
{
    if(penumerator->pvContext) {
        delete [] (LPSTR) penumerator->pvContext;
        penumerator->pvContext = NULL;
    }
    return EndRawAttributeEnumeration(penumerator);
}

//+------------------------------------------------------------
//
// Function: CICategorizerItemAttributesIMP::CountUTF8AttributeValues
//
// Synopsis: Return a count of the number of attribute values associated
//           with this enumerator
//
// Arguments:
//  penumerator: describes the attribute in question
//  pdwCount: Out parameter for the count
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/25 14:39:54: Created
//
//-------------------------------------------------------------
HRESULT CICategorizerItemAttributesIMP::CountUTF8AttributeValues(
    IN  PATTRIBUTE_ENUMERATOR penumerator,
    OUT DWORD *pdwCount)
{
    return CountRawAttributeValues(
        penumerator,
        pdwCount);

} // CICategorizerItemAttributesIMP::CountRawAttributeValues
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatasync.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatasync.cpp
//
// Contents: Implementation of CICategorizerAsyncContextIMP
//
// Classes: CICategorizerAsyncContextIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/16 11:25:20: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "simparray.cpp"

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerAsyncContext
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerAsyncContextIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerAsyncContext) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerAsyncContextIMP::AddRef()
{
    return InterlockedIncrement((PLONG)&m_cRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero. 
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerAsyncContextIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((PLONG)&m_cRef);
    return lNewRefCount;
}



//+------------------------------------------------------------
//
// Function: CICategorizerAsyncContext::CompleteQuery
//
// Synopsis: Accept async completion from a sink
//
// Arguments:
//  pvQueryContext: pvoid query context (really a PEVENTPARAMS_SENDQUERY)
//  hrResolutionStatus: S_OK unless there was an error talking to DS
//  dwcResults: The number of ICategorizerItemAttributes returned
//  rgpItemAttributes: Array of pointers to the ICategorizerItemAttributes
//  fFinalCompletion:
//    FALSE: This is a completion for
//           pending results; there will be another completion
//           called with more results
//    TRUE: This is the final completion call
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/16 11:27:47: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerAsyncContextIMP::CompleteQuery(
    IN  PVOID   pvQueryContext,
    IN  HRESULT hrResolutionStatus,
    IN  DWORD   dwcResults,
    IN  ICategorizerItemAttributes **rgpItemAttributes,
    IN  BOOL    fFinalCompletion)
{
    HRESULT hr;
    PEVENTPARAMS_CATSENDQUERY pParams;
    CSearchRequestBlock *pBlock;

    CatFunctEnterEx((LPARAM)this,
                      "CICategorizerAsyncContextIMP::CompleteQuery");

    DebugTrace((LPARAM)this, "hrResolutionStatus is %08lx", hrResolutionStatus);
    DebugTrace((LPARAM)this, "dwcResults for this sink is %ld", dwcResults);
    DebugTrace((LPARAM)this, "fFinalCompletion is %d", fFinalCompletion);

    pParams = (PEVENTPARAMS_CATSENDQUERY)pvQueryContext;
    pBlock = (CSearchRequestBlock *) pParams->pblk;

    //
    // If the old hrResolutionStatus (saved in pParams) indicates failure, don't do any more work
    //
    if(SUCCEEDED(pParams->hrResolutionStatus)) {

        hr = hrResolutionStatus;

        if(SUCCEEDED(hr) && (dwcResults > 0) && (rgpItemAttributes)) {
            //
            // Add the new array of ICatItemAttrs to the existing array
            //
            hr = pBlock->AddResults(
                dwcResults,
                rgpItemAttributes);
            if(FAILED(hr))
            {
                ERROR_LOG("pBlock->AddResults");
            }
        }
        

        if(FAILED(hr)) {
            //
            // Remember something failed in pParams
            //
            pParams->hrResolutionStatus = hr;
            ERROR_LOG("--async--");
        }
    }

    if(fFinalCompletion) {

        if((pParams->pIMailTransportNotify) &&
           FAILED(pParams->hrResolutionStatus)) {

            ErrorTrace((LPARAM)this, "Stoping resoltion, error encountered: %08ld", 
                       pParams->hrResolutionStatus);
            //
            // If the resolution sink is indicating an error, set the error
            // and return S_FALSE to the SEO dispatcher so that it will stop
            // calling resolve sinks (we're going to fail now anyway, after
            // all)
            //
            hr = pParams->pIMailTransportNotify->Notify(
                S_FALSE,
                pParams->pvNotifyContext);

            _ASSERT(SUCCEEDED(hr));

        } else {

            if(pParams->pIMailTransportNotify) {
                //
                // Call the SEO dispatcher completion routine
                //
                hr = pParams->pIMailTransportNotify->Notify(
                    S_OK,
                    pParams->pvNotifyContext);

            } else {
                //
                // Events are disabled; call completion directly
                //
                hr = CSearchRequestBlock::HrSendQueryCompletion(
                    S_OK,
                    pParams);
            }
            _ASSERT(SUCCEEDED(hr));
        }
    }
    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatqueries.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatqueries.h
//
// Contents: Implementation of ICategorizerQueries
//
// Classes: CICategorizerQueriesIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/15 14:11:54: Created.
//
//-------------------------------------------------------------
#ifndef __ICATQUERIES_H__
#define __ICATQUERIES_H__

CatDebugClass(CICategorizerQueriesIMP),
    public ICategorizerQueries
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ICategorizerQueries
    STDMETHOD (SetQueryString) (
        IN  LPSTR  pszQueryString);
    STDMETHOD (GetQueryString) (
        OUT LPSTR *ppszQueryString);

  public:
    CICategorizerQueriesIMP(
        IN  LPSTR  *ppsz);
    ~CICategorizerQueriesIMP();

    VOID SetISMTPServerEx(ISMTPServerEx *pISMTPServerEx)
    {
        _ASSERT(m_pISMTPServerEx == NULL);
        m_pISMTPServerEx = pISMTPServerEx;
        if(m_pISMTPServerEx)
            m_pISMTPServerEx->AddRef();
    }
    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }
  private:
    // Internal method for setting the query string to a buffer
    // without reallocating/copying
    HRESULT SetQueryStringNoAlloc(
        IN  LPSTR  pszQueryString);

  private:

    #define SIGNATURE_CICATEGORIZERQUERIESIMP           (DWORD) 'ICaQ'
    #define SIGNATURE_CICATEGORIZERQUERIESIMP_INVALID   (DWORD) 'XCaQ'

    DWORD m_dwSignature;
    ULONG m_cRef;
    LPSTR *m_ppsz;
    ISMTPServerEx *m_pISMTPServerEx;

    friend class CSearchRequestBlock;
};


//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::CICategorizerQueriesIMP
//
// Synopsis: Constructor, initialize member data
//
// Arguments:
//  ppsz: Pointer to psz to set
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/15 14:18:00: Created.
//
//-------------------------------------------------------------
inline CICategorizerQueriesIMP::CICategorizerQueriesIMP(
    IN  LPSTR *ppsz)
{
    m_dwSignature = SIGNATURE_CICATEGORIZERQUERIESIMP;
    
    _ASSERT(ppsz);
    m_ppsz = ppsz;
    m_cRef = 0;
    m_pISMTPServerEx = NULL;
}


//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::~CICategorizerQueriesIMP
//
// Synopsis: Check signature before destroying object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/15 14:22:33: Created.
//
//-------------------------------------------------------------
inline CICategorizerQueriesIMP::~CICategorizerQueriesIMP()
{
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    _ASSERT(m_cRef == 0);
    _ASSERT(m_dwSignature == SIGNATURE_CICATEGORIZERQUERIESIMP);
    m_dwSignature = SIGNATURE_CICATEGORIZERQUERIESIMP_INVALID;
}

#endif //__ICATQUERIES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatqueries.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatqueries.cpp
//
// Contents: CICategorizerQueriesIMP implementation
//
// Classes:
//  CICategorizerQueriesIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/15 14:25:18: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerQueries
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerQueriesIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerQueries) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerQueriesIMP::AddRef()
{
    return InterlockedIncrement((PLONG)&m_cRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerQueriesIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((PLONG)&m_cRef);

    // We are allocated on the stack
    
    return lNewRefCount;
}


//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::SetQueryString
//
// Synopsis: Set the query string for a batch of ICategorizerItems
//
// Arguments:
//  pszQueryString: QueryString to set or NULL to unset any query string
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/15 14:28:18: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerQueriesIMP::SetQueryString(
    IN  LPSTR  pszQueryString)
{
    HRESULT hr = S_OK;
    DWORD dwOldLength;
    DWORD dwNewLength;

    CatFunctEnterEx((LPARAM)this, "CICategorizerQueriesIMP::SetQueryString");
    //
    // If pszQueryString is NULL, release any existing buffer and set
    // ptr to NULL
    //
    if(pszQueryString == NULL) {
        if(*m_ppsz != NULL)
            delete *m_ppsz;
        *m_ppsz = NULL;
        return S_OK;
    }

    //
    // Get the lengths of new and old strings
    //
    dwNewLength = lstrlen(pszQueryString);

    if(*m_ppsz) {

        dwOldLength = lstrlen(*m_ppsz);

        if(dwNewLength <= dwOldLength) {
            //
            // Re-use the same buffer
            //
            lstrcpy(*m_ppsz, pszQueryString);
            return S_OK;

        } else {
            //
            // Free the existing buffer and realloc below
            //
            delete *m_ppsz;
        }
    }
    *m_ppsz = new CHAR[ dwNewLength + 1 ];

    if(*m_ppsz == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CHAR[]");
        return hr;
    }

    lstrcpy(*m_ppsz, pszQueryString);

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::SetQueryStringNoAlloc
//
// Synopsis: Internal method to set the query string without
//           ReAllocing the buffer
//
// Arguments:
//  pszQueryString: QueryString to set
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/15 16:08:45: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerQueriesIMP::SetQueryStringNoAlloc(
    IN  LPSTR  pszQueryString)
{
    //
    // Free the old buffer, if any
    //
    if(*m_ppsz)
        delete *m_ppsz;
    
    //
    // Set the new string to the caller's pointer
    //
    *m_ppsz = pszQueryString;

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICategorizerQueriesIMP::GetQueryString
//
// Synopsis: Retrieve pointer to the current query string.  Note that
//           this pointer will become bogus of SetQueryString is called again
//
// Arguments:
//  ppszQueryString: ptr to set to the query string ptr.
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/20 15:06:34: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerQueriesIMP::GetQueryString(
    LPSTR   *ppszQueryString)
{
    _ASSERT(ppszQueryString);
    //
    // Give out our string pointer
    //
    *ppszQueryString = *m_ppsz;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\icatitemattr.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitemattr.h
//
// Contents: EMailIDLdapStore implementation of ICategorizerItemAttributes
//
// Classes:
//  CLdapResultWrap
//  CICategorizerItemAttributesIMP
//
// Functions:
//
// History:
// jstamerj 1998/07/01 13:20:21: Created.
//
//-------------------------------------------------------------
#ifndef _ICATITEMATTR_H_
#define _ICATITEMATTR_H_

#include <windows.h>
#include <winldap.h>
#include "smtpevent.h"
#include <catdefs.h>
#include <ldapconn.h>

//
// The guid indicating this ICategorizerItemAttributes was generated
// by the one true categorizer (not some sink)
//
CatDebugClass(CLdapResultWrap)
{
  public:
    CLdapResultWrap(
        ISMTPServerEx *pISMTPServerEx,
        CPLDAPWrap  *pLDAPWrap,
        PLDAPMessage pMessage);

    LONG AddRef();
    LONG Release();

    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }

  private:
    ~CLdapResultWrap();

    LONG m_lRefCount;
    CPLDAPWrap  *m_pCPLDAPWrap;
    PLDAPMessage m_pLDAPMessage;
    ISMTPServerEx *m_pISMTPServerEx;
};




// {283430CA-1850-11d2-9E03-00C04FA322BA}
static const GUID GUID_NT5CAT =
{ 0x283430ca, 0x1850, 0x11d2, { 0x9e, 0x3, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba } };



#define CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE (DWORD)'ICIA'
#define CICATEGORIZERITEMATTRIBUTESIMP_SIGNATURE_INVALID (DWORD)'XCIA'

CatDebugClass(CICategorizerItemAttributesIMP),
    public ICategorizerItemAttributes,
    public ICategorizerItemRawAttributes,
    public ICategorizerUTF8Attributes
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (REFIID iid, LPVOID *ppv);
    STDMETHOD_(ULONG, AddRef) ();
    STDMETHOD_(ULONG, Release) ();

  public:
    //ICategorizerItemAttributes
    STDMETHOD (BeginAttributeEnumeration) (
        IN  LPCSTR pszAttributeName,
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (GetNextAttributeValue) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT LPSTR *ppszAttributeValue);

    STDMETHOD (RewindAttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (EndAttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (BeginAttributeNameEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (GetNextAttributeName) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT LPSTR *ppszAttributeName);

    STDMETHOD (EndAttributeNameEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);


    STDMETHOD_(GUID, GetTransportSinkID) ()
    {
        return GUID_NT5CAT;
    }

    STDMETHOD (AggregateAttributes) (
        IN  ICategorizerItemAttributes *pICatItemAttributes);

    STDMETHOD (GetAllAttributeValues) (
        IN  LPCSTR pszAttributeName,
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        IN  LPSTR **prgpszAttributeValues);

    STDMETHOD (ReleaseAllAttributeValues) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (CountAttributeValues) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount);

  public:
    //ICategorizerItemRawAttributes
    STDMETHOD (BeginRawAttributeEnumeration) (
        IN  LPCSTR pszAttributeName,
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (GetNextRawAttributeValue) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT PDWORD pdwcb,
        OUT LPVOID *pvAttributeValue);

    STDMETHOD (RewindRawAttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (EndRawAttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (CountRawAttributeValues) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount);

 public:
    //ICategorizerUTF8Attributes
    STDMETHOD (BeginUTF8AttributeEnumeration) (
        IN  LPCSTR pszAttributeName,
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (GetNextUTF8AttributeValue) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT LPSTR *ppszAttributeValue);

    STDMETHOD (RewindUTF8AttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (EndUTF8AttributeEnumeration) (
        IN  PATTRIBUTE_ENUMERATOR penumerator);

    STDMETHOD (CountUTF8AttributeValues) (
        IN  PATTRIBUTE_ENUMERATOR penumerator,
        OUT DWORD *pdwCount);

  public:
    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pResultWrap->GetISMTPServerEx();
    }

  private:
    CICategorizerItemAttributesIMP(
        PLDAP pldap,
        PLDAPMessage pldapmessage,
        CLdapResultWrap *pResultWrap);
    ~CICategorizerItemAttributesIMP();

    DWORD m_dwSignature;
    ULONG m_cRef;
    PLDAP m_pldap;
    PLDAPMessage m_pldapmessage;
    CLdapResultWrap * m_pResultWrap;

    friend class CLdapConnection;
};

#endif //_ICATITEMATTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapstor.cpp ===
//
// ldapstor.cpp -- This file contains implementations for
//      GetEmailIDStore
//      ReleaseEmailIDStore
//
// Created:
//      December 18, 1996   -- Milan Shah (milans)
//
// Changes:
//

#include "precomp.h"
#include "ldapstor.h"
#include "propstr.h"
#include "ccataddr.h"
#include "icatparam.h"
#include "cnfgmgr.h"

const DWORD CEmailIDLdapStore<CCatAddr>::Signature = (DWORD) 'IMAB';

DWORD CEmailIDLdapStore<CCatAddr>::m_dwDynamicDlPageSize = CAT_DEFAULT_DYNAMICDL_PAGE_SIZE;

//+----------------------------------------------------------------------------
//
//  Function:   GetEmailIDStore
//
//  Synopsis:   Instantiates an object of class
//              CEmailIDStore
//
//  Arguments:  [ppStore] -- On successful return, contains pointer to
//                  newly allocated object. Free this object using
//                  ReleaseEmailIDStore.
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//-----------------------------------------------------------------------------

template <>
HRESULT
GetEmailIDStore(
    CEmailIDStore<CCatAddr> **ppStore)
{
    HRESULT hr;
    CEmailIDLdapStore<CCatAddr> *pLdapStore;

    pLdapStore = new CEmailIDLdapStore<CCatAddr>;
    if (pLdapStore != NULL) {
        hr = S_OK;
    } else {
        hr = E_OUTOFMEMORY;
    }

    *ppStore = (CEmailIDStore<CCatAddr> *) pLdapStore;

    return( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseEmailIDStore
//
//  Synopsis:   Frees up instance of CEmailIDStore allocated by
//              GetEmailIDStore
//
//  Arguments:  [pStore] -- Pointer to CEmailIDStore to free.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

template <>
VOID
ReleaseEmailIDStore(
    CEmailIDStore<CCatAddr> *pStore)
{
    delete (CEmailIDLdapStore<CCatAddr> *)pStore;
}

//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::Initialize
//
//  Synopsis:   Initializes a CEmailIDLdapStore object.
//
//  Arguments:  [pICatParams] -- ICategorizerParams to set default
//                  parameters (based on szLdapInfo), and to save and
//                  query for config info
//              [pISMTPServer] -- Interface to hold onto for
//                  triggering server events
//
//  Returns:    TRUE if successfully initialized, FALSE otherwise
//
//-----------------------------------------------------------------------------

template <class T> HRESULT CEmailIDLdapStore<T>::Initialize(
    ICategorizerParametersEx *pICatParams,
    ISMTPServer *pISMTPServer)
{
    CatFunctEnterEx((LPARAM)this, "CEmailIDLdapStore<T>::Initialize");
    HRESULT hr;

    _ASSERT(pICatParams);

    LPSTR pszUser;
    LPSTR pszDomain;
    ULARGE_INTEGER ulCurrentTime;

    //
    // Do not try to reinitialize more than once/5 minutes
    //
    GetSystemTimeAsFileTime((LPFILETIME)&ulCurrentTime);

    if( (ulCurrentTime.QuadPart - m_ulLastInitTime.QuadPart) <
        ((LONGLONG)CAT_LDAPSTORE_MIN_INIT_INTERVAL * 10000000)) {

        DebugTrace((LPARAM)this, "Not reinitializing for 5 minutes");
        hr = CAT_E_INIT_FAILED;
        ERROR_LOG("--Insufficient time--");
        goto CLEANUP;
    }


    //
    // Save and addref the interface pointers
    //
    if(m_pICatParams)
        m_pICatParams->Release();
    if(m_pISMTPServer)
        m_pISMTPServer->Release();
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    m_pICatParams = pICatParams;
    m_pISMTPServer = pISMTPServer;

    // QI for ISMTPServerEx for event logging
    if (m_pISMTPServer)
    {
        hr = m_pISMTPServer->QueryInterface(
                IID_ISMTPServerEx,
                (LPVOID *)&m_pISMTPServerEx);
        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) m_pISMTPServer,
                "Unable to QI for ISMTPServerEx 0x%08X",hr);
    
            m_pISMTPServerEx = NULL;
            hr = S_OK; //Don't treat as a fatal error
        }
    }

    m_pICatParams->AddRef();

    if(m_pISMTPServer)
        m_pISMTPServer->AddRef();

    //
    // Retrieve Host, NamingContext, Account, and Password from ICategorizerParameters
    // Initialize our domain cache.
    //

    hr = RetrieveICatParamsInfo(
        &m_pszHost,
        &m_dwPort,
        &m_pszNamingContext,
        &pszUser,
        &pszDomain,
        &m_pszPassword,
        &m_bt);

    if(FAILED(hr)) {

        ERROR_LOG("RetrieveICatParamsInfo");
        hr = CAT_E_INVALID_ARG;
        goto CLEANUP;
    }

    //
    // Note that NamingContext is an optional configuration.
    //
    if (((pszUser) && (pszUser[0] != 0) ||
         m_bt == BIND_TYPE_NONE ||
         m_bt == BIND_TYPE_CURRENTUSER)) {

        hr = AccountFromUserDomain(
            m_szAccount,
            sizeof(m_szAccount),
            pszUser,
            pszDomain);
        ERROR_CLEANUP_LOG("AccountFromUserDomain");
    }
    //
    // We are a new emailIdStore initializing with a possibly
    // different config, so reset the event log stuff
    //
    ResetPeriodicEventLogs();
    //
    // Create/Initialize the connection configuration manager
    //
    // Initialize the ldap configuration manager
    // Use the automatic init if we have no specified host/port
    //
    if( ((m_pszHost == NULL) || (*m_pszHost == '\0')) &&
        (m_dwPort == 0)) {

        if(m_pCLdapCfgMgr == NULL)
            m_pCLdapCfgMgr = new CLdapCfgMgr(
                m_pISMTPServerEx,
                TRUE,           // fAutomaticConfigUpdate
                m_pICatParams,
                m_bt,
                m_szAccount,
                m_pszPassword,
                m_pszNamingContext);

        if(m_pCLdapCfgMgr == NULL) {
            hr = E_OUTOFMEMORY;
            ERROR_LOG("new CLdapCfgMgr");
            goto CLEANUP;
        }
        hr = m_pCLdapCfgMgr->HrInit();
        if(FAILED(hr)) {
            ERROR_LOG("m_pCLdapCfgMgr->HrInit");
        }

    } else {
        //
        // Initialize using the one configuration specified
        //
        LDAPSERVERCONFIG ServerConfig;
        ServerConfig.dwPort = m_dwPort;
        ServerConfig.pri = 0;
        ServerConfig.bt = m_bt;
        if(m_pszHost)
            lstrcpyn(ServerConfig.szHost, m_pszHost, sizeof(ServerConfig.szHost));
        else
            ServerConfig.szHost[0] = '\0';

        if(m_pszNamingContext)
            lstrcpyn(ServerConfig.szNamingContext, m_pszNamingContext, sizeof(ServerConfig.szNamingContext));
        else
            ServerConfig.szNamingContext[0] = '\0';

        lstrcpyn(ServerConfig.szAccount, m_szAccount, sizeof(ServerConfig.szAccount));

        if(m_pszPassword)
            lstrcpyn(ServerConfig.szPassword, m_pszPassword, sizeof(ServerConfig.szPassword));
        else
            ServerConfig.szPassword[0] = '\0';

        //
        // Create CLdapCfgMgr without the automatic config update
        // option (since one host is specified)
        //
        if(m_pCLdapCfgMgr == NULL)
            m_pCLdapCfgMgr = new CLdapCfgMgr(
                m_pISMTPServerEx,
                FALSE,          // fAutomaticConfigUpdate
                m_pICatParams);

        if(m_pCLdapCfgMgr == NULL) {
            hr = E_OUTOFMEMORY;
            ERROR_LOG("new CLdapCfgMgr");
            goto CLEANUP;
        }

        hr = m_pCLdapCfgMgr->HrInit(
            1,
            &ServerConfig);
        if(FAILED(hr)) {
            ERROR_LOG("m_pCLdapCfgMgr->HrInit");
        }
    }

    if(FAILED(hr)) {

        FatalTrace((LPARAM)this, "CLdapCfgMgr->HrInit failed hr %08lx", hr);
        m_pCLdapCfgMgr->Release();
        m_pCLdapCfgMgr = NULL;
        goto CLEANUP;
    }
    
    InitializeFromRegistry();

 CLEANUP:
    if(FAILED(hr) &&
       (hr != CAT_E_INIT_FAILED)) {
        //
        // Update the last init attempt time
        //
        GetSystemTimeAsFileTime((LPFILETIME)&m_ulLastInitTime);
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::InitializeFromRegistry
//
//  Synopsis:   Initializes registry configurable parameters.
//
//  Arguments:  None.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

template <>
VOID CEmailIDLdapStore<CCatAddr>::InitializeFromRegistry()
{
    HKEY hkey;
    DWORD dwErr, dwType, dwValue, cbValue;

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, DYNAMICDL_PAGE_SIZE_KEY, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        cbValue = sizeof(dwValue);
        dwErr = RegQueryValueEx(
                    hkey,
                    DYNAMICDL_PAGE_SIZE_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD && dwValue > 0) {

            InterlockedExchange(
                (PLONG) &m_dwDynamicDlPageSize,
                (LONG)dwValue);
                
        } else {
        
            InterlockedExchange(
                (PLONG) &m_dwDynamicDlPageSize,
                CAT_DEFAULT_DYNAMICDL_PAGE_SIZE);
        }

        RegCloseKey( hkey );
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::InitializeResolveListContext
//
//  Synopsis:   Creates a new async context for resolving a list of email ids.
//
//  Arguments:  [puserContext] -- As each name is completed, a completion
//                      routine is called with this context parameter.
//              [pResolveListContext] -- The LPRESOLVE_LIST_CONTEXT
//                      to initialize.
//
//  Returns:    S_OK if successfully allocated context
//              E_OUTOFMEMORY if out of memory.
//
//-----------------------------------------------------------------------------

template <class T> HRESULT CEmailIDLdapStore<T>::InitializeResolveListContext(
    VOID  *pUserContext,
    LPRESOLVE_LIST_CONTEXT pResolveListContext)
{
    CStoreListResolveContext *pCStoreContext = NULL;
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CEmailIDLdapStore::InitializeResolveListContext");

    pResolveListContext->pUserContext = pUserContext;

    pCStoreContext = new CStoreListResolveContext(this);
    if(pCStoreContext == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CStoreListResolveContext");
        goto CLEANUP;
    }

    hr = pCStoreContext->HrInitialize(
        m_pISMTPServer,
        m_pICatParams);

    if (FAILED(hr)) {

        ERROR_LOG("pCStoreContext->HrInitialize");

        if(hr == HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE)) {

            LPCSTR pszAccount = m_szAccount;

            CatLogEvent(
                m_pISMTPServerEx,
                CAT_EVENT_LOGON_FAILURE,
                1,
                &pszAccount,
                hr,
                m_szAccount,
                LOGEVENT_FLAG_PERIODIC,
                LOGEVENT_LEVEL_MINIMUM);

        } else {

            // Use new logging interface so that
            // we can log system generic format messages
            // rgszString[1] here will be set inside LogEvent(..)
            // as it use FormatMessageA to generate it
            const char *rgszStrings[1] = { NULL };

            CatLogEvent(
                m_pISMTPServerEx,
                CAT_EVENT_LDAP_CONNECTION_FAILURE,
                1,
                rgszStrings,
                hr,
                NULL,
                LOGEVENT_FLAG_PERIODIC,
                LOGEVENT_LEVEL_MEDIUM);
        }

        goto CLEANUP;

    } else {

        ResetPeriodicEventLogs();
    }

    pResolveListContext->pStoreContext = (LPVOID) pCStoreContext;

 CLEANUP:
    if(FAILED(hr))
        if(pCStoreContext)
            pCStoreContext->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::FreeResolveListContext
//
//  Synopsis:   Frees async context used for resolving list of email ids.
//
//  Arguments:  [pResolveListContext] -- The context to free.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

template <class T> VOID CEmailIDLdapStore<T>::FreeResolveListContext(
    LPRESOLVE_LIST_CONTEXT pResolveListContext)
{
    CStoreListResolveContext *pCStoreContext;

    pCStoreContext = (CStoreListResolveContext *) pResolveListContext->pStoreContext;

    pCStoreContext->Release();
}

//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::LookupEntryAsync
//
//  Synopsis:   Issues a lookup request asynchronously. The callback function
//              is called once the result is available. This function is
//              used when a group of lookups are to be issued successively,
//              for example when looking up all recipients of a mail message.
//              By doing an asynchronous lookup, an opportunity to perform
//              group-wide optimizations (like batching a sequence of lookups
//              together) is created.
//
//  Arguments:  [pCCatAddr] -- Contains email ID to lookup and
//              HrCompletion routine to be called when lookup is complete.
//              [pListContext] -- Context associated with the group of lookups
//                  of which this lookup is a part.
//
//  Returns:    S_OK if lookup was successfully queued.
//              The callback function gets passed the result of the actual
//              lookup
//
//-----------------------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::LookupEntryAsync(
    T *pCCatAddr,
    LPRESOLVE_LIST_CONTEXT pListContext)
{
    HRESULT hr = S_OK;
    CStoreListResolveContext *pCStoreContext = NULL;

    CatFunctEnterEx((LPARAM)this, "CEmailIDLdapStore::LookupEntryAsync");
    //
    // Pick up CStoreListResolveContext object from pListContext.
    // Pass it through.
    //
    pCStoreContext = (CStoreListResolveContext *) pListContext->pStoreContext;

    hr = pCStoreContext->HrLookupEntryAsync(
        pCCatAddr);
    if(FAILED(hr))
    {
        ERROR_LOG("pCStoreContext->HrLookupEntryAsync");
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore<T>::InsertInsertionRequest
//
// Synopsis:
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/25 15:13:55: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::InsertInsertionRequest(
        LPRESOLVE_LIST_CONTEXT pListContext,
        CInsertionRequest *pCRequest)
{
    HRESULT hr = S_OK;
    CStoreListResolveContext *pCStoreContext = NULL;

    CatFunctEnterEx((LPARAM)this, "CEmailIDLdapStore::InsertInsertionRequest");
    //
    // Pick up CStoreListResolveContext object from pListContext.
    // Pass it through.
    //
    pCStoreContext = (CStoreListResolveContext *) pListContext->pStoreContext;

    hr = pCStoreContext->HrInsertInsertionRequest(
        pCRequest);
    if(FAILED(hr))
    {
        ERROR_LOG("pCStoreContext->HrInsertInsertionRequest");
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CEmailIDLdapStore<T>::InsertInsertionRequest



//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::CancelResolveList
//
// Synopsis: Cancel outstanding lookups in a list resolve
//
// Arguments:
//  pResolveListContext: list context
//  hr: Optional hresult reason to pass to completion routines
//
// Returns:
//  return value of CAsyncLookupContext::CancelPendingRequests
//
// History:
// jstamerj 1998/09/29 14:51:30: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::CancelResolveList(
    LPRESOLVE_LIST_CONTEXT pResolveListContext,
    HRESULT hr)
{
    CStoreListResolveContext *pCStoreContext;
    //
    // Cancel lookups on this resolve list context (will call their
    // lookup's completion routine with error)
    //
    pCStoreContext = (CStoreListResolveContext *) pResolveListContext->pStoreContext;
    pCStoreContext->Cancel();

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::CancelAllLookups
//
//  Synopsis:   Cancels all async lookups that are pending
//
//  Arguments:  NONE
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

template <class T> VOID CEmailIDLdapStore<T>::CancelAllLookups()
{
    if(m_pCLdapCfgMgr)
        m_pCLdapCfgMgr->CancelAllConnectionSearches(
            m_pISMTPServer);
}


//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::AsyncLookupCompletion
//
//  Synopsis:   Completion routine for
//
//  Arguments:  pCCatAddr: the address lookup being completed
//              lpContext: context passed to LdapConn
//
//  Returns:    NOTHING
//
//
//-----------------------------------------------------------------------------
template <class T> VOID CEmailIDLdapStore<T>::AsyncLookupCompletion(
    CCatAddr *pCCatAddr,
    LPVOID lpContext)
{
    CatFunctEnter("CEmailIDLdapStore::AsyncLookupCompletion");

    _ASSERT(pCCatAddr);
    pCCatAddr->LookupCompletion();

    pCCatAddr->Release(); // Release reference count addref'd in LookupEntryAsync

    CatFunctLeave();
}

//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::HrExpandPagedDlMembers
//
// Synopsis: Start issueing async queries to retrieve all the DL members
//
// Arguments:
//  pCCatAddr: The DL item to be expanded
//  pListContext: List context initialized in
//                InitializeResolveListContext
//  CAType: The type of address of the DL members
//  pfnCompletion: Completion that will be called after returning
//                 MAILTRANSPORT_S_PENDING
//  pContext: Paramter passed to the completion routine
//
// Returns:
//  S_OK: Success, this is not a paged DL
//  MAILTRANSPORT_S_PENDING: Will call pfnCompletion with context when
//                           finished expanding the DL
//  E_OUTOFMEMORY
//  CAT_E_DBCONNECTION: palc->GetConnection returned NULL (meaning it
//                      is having problems obtaining/maintaing a connection)
//  error from HrExpandDlPage
//
// History:
// jstamerj 1998/09/23 15:57:37: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::HrExpandPagedDlMembers(
    CCatAddr *pCCatAddr,
    LPRESOLVE_LIST_CONTEXT pListContext,
    CAT_ADDRESS_TYPE CAType,
    PFN_DLEXPANSIONCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    PMEMBERRESOLVECONTEXT pMemCtx = NULL;
    CStoreListResolveContext *pCStoreContext = NULL;
    CBatchLdapConnection *pConn = NULL;

    CatFunctEnterEx((LPARAM)this,
                      "CEmailIDLdapStore::HrExpandPagedDlMembers");

    //
    // Use the same CLdapConnection that the rest of the list is using
    // -- this way the same thread will be servicing all the list
    // resolve requests and we don't have to worry about thread unsafe
    // problems in CAsyncLookupContext
    //
    pCStoreContext = (CStoreListResolveContext *) pListContext->pStoreContext;
    pConn = pCStoreContext->GetConnection();
    if(pConn == NULL) {
        ErrorTrace((LPARAM)this, "Failed to get a connection to resolve paged DL");
        hr = CAT_E_DBCONNECTION;
        ERROR_LOG_ADDR(pCCatAddr, "pCStoreContext->GetConnection");
        goto CLEANUP;
    }

    //
    // Get the attributes interface
    //
    hr = pCCatAddr->GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);

    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        ErrorTrace((LPARAM)this, "Failed to get ICatItemAttr in HrExpandPagedDlMembers");
        ERROR_LOG_ADDR(pCCatAddr, "pCCatAddr->GetICategorizerItemAttributes");
        goto CLEANUP;
    }

    //
    // Allocate/initialize a member resolution context and
    // kick things off
    //
    pMemCtx = new MEMBERRESOLVECONTEXT;
    if(pMemCtx == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG_ADDR(pCCatAddr, "new MEMBERRESOLVECONTEXT");
        goto CLEANUP;
    }

    //
    // First, get an ldapconn on which to issue searches
    //
    pMemCtx->pConn = pConn;

    //
    // AddRef here, release when we're done
    //
    pCCatAddr->AddRef();

    pMemCtx->pStore = this;
    pMemCtx->pCCatAddr = pCCatAddr;
    pMemCtx->CAType = CAType;
    pMemCtx->dwNextBlockIndex = 0;
    pMemCtx->pICatItemAttr = NULL;
    pMemCtx->hrResolveStatus = S_OK;
    pMemCtx->pfnCompletion = pfnCompletion;
    pMemCtx->pCompletionContext = pContext;

    hr = HrExpandDlPage(pMemCtx, pICatItemAttr);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(pCCatAddr, "HrExpandDlPage");
    }

 CLEANUP:
    if(hr != MAILTRANSPORT_S_PENDING) {

        if(pMemCtx) {
            if(pConn)
                pConn->Release();
            if(pMemCtx->pCCatAddr)
                pMemCtx->pCCatAddr->Release();
            delete pMemCtx;
        }
    }

    if(pICatItemAttr)
        pICatItemAttr->Release();

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CEmailIdLdapStore::HrExpandDlPage
//
// Synopsis: Expand one block of DL members
//
// Arguments:
//  pMemCtx: one (initialized) member resolve context
//  pICatItemAttr: The ICatItemAttributes to get the members from
//
// Returns:
//  S_OK: Success
//  MAILTRANSPORT_S_PENDING: Issued another search
//
// History:
// jstamerj 1998/09/23 17:02:05: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::HrExpandDlPage(
    PMEMBERRESOLVECONTEXT pMemCtx,
    ICategorizerItemAttributes *pICatItemAttr)
{
    HRESULT hr;
    LPSTR pszMembersAttribute;
    LPSTR pszAttributeName;
    DWORD dwMembersAttributeLength;
    BOOL fEnumerating = FALSE;
    ATTRIBUTE_ENUMERATOR enumerator;

    CatFunctEnterEx((LPARAM)this,
                      "CEmailIDLdapStore::HrExpandDlPage");

    hr = m_pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DL_MEMBERS,
        &pszMembersAttribute);
    ERROR_CLEANUP_LOG("m_pICatParams->GetDSParameterA");

    dwMembersAttributeLength = lstrlen(pszMembersAttribute);

    //
    // Is the members attribute being paged at all?
    //
    hr = pICatItemAttr->BeginAttributeNameEnumeration(&enumerator);
    ERROR_CLEANUP_LOG_ADDR(pMemCtx->pCCatAddr, "pICatItemAttr->BeginAttributeNameEnumeration");

    fEnumerating = TRUE;

    hr = pICatItemAttr->GetNextAttributeName(
        &enumerator,
        &pszAttributeName);

    while(SUCCEEDED(hr)) {
        //
        // We'll know it's paged DL when we see an attribue named
        // "member;range=0-high"
        //
        if( (_strnicmp(pszAttributeName,
                       pszMembersAttribute,
                       dwMembersAttributeLength) == 0) &&
            (_strnicmp(pszAttributeName + dwMembersAttributeLength,
                       SZ_PAGEDMEMBERS_INDICATOR,
                       sizeof(SZ_PAGEDMEMBERS_INDICATOR) -1 ) == 0)) {
            //
            // Parse out the range numbers
            //
            CHAR  szTempBuffer[MAX_PAGEDMEMBERS_DIGITS+1];
            LPSTR pszSrc, pszDest;
            DWORD dwLow, dwHigh;

            pszSrc = pszAttributeName +
                     dwMembersAttributeLength +
                     sizeof(SZ_PAGEDMEMBERS_INDICATOR) - 1;

            pszDest = szTempBuffer;

            while((*pszSrc != '-') && (*pszSrc != '\0') &&
                  (pszDest - szTempBuffer) < (sizeof(szTempBuffer) - 1)) {
                //
                // Copy the digits into the temporary buffer
                //
                *pszDest = *pszSrc;
                pszSrc++;
                pszDest++;
            }

            if(*pszSrc != '-') {
                //
                // Error parsing this thing (no hyphen?)
                //
                ErrorTrace((LPARAM)this, "Error parsing LDAP attribute \"%s\"",
                           pszAttributeName);
                hr = E_INVALIDARG;
                ERROR_LOG_ADDR(pMemCtx->pCCatAddr, "--no hyphen--");
                goto CLEANUP;
            }
            //
            // Null terminate the temporary buffer
            //
            *pszDest = '\0';
            //
            // Convert to a dword
            //
            dwLow = atol(szTempBuffer);

            //
            // Is this the range we're looking for?
            //
            if(dwLow == pMemCtx->dwNextBlockIndex) {
                //
                // Copy the high number into the buffer
                //
                pszDest = szTempBuffer;
                pszSrc++; // Past -

                while((*pszSrc != '\0') &&
                      (pszDest - szTempBuffer) < (sizeof(szTempBuffer) - 1)) {

                    *pszDest = *pszSrc;
                    pszSrc++;
                    pszDest++;
                }
                *pszDest = '\0';

                if(szTempBuffer[0] == '*') {

                    dwHigh = 0; // we're done expanding

                } else {

                    dwHigh = atol(szTempBuffer);
                }

                hr = pMemCtx->pCCatAddr->HrExpandAttribute(
                    pICatItemAttr,
                    pMemCtx->CAType,
                    pszAttributeName,
                    NULL);

                if(SUCCEEDED(hr) && dwHigh > 0) {

                    pMemCtx->dwNextBlockIndex = dwHigh + 1;

                    hr = HrExpandNextDlPage( pMemCtx );
                } else if(FAILED(hr)) {
                    ERROR_LOG_ADDR(pMemCtx->pCCatAddr, "pMemCtx->pCCatAddr->HrExpandAttribute");
                }
                //
                // The job of this function is done
                //
                goto CLEANUP;
            }
        }
        hr = pICatItemAttr->GetNextAttributeName(
            &enumerator,
            &pszAttributeName);
    }
    //
    // If we did not find any members;range= attribute, assume there
    // are no more members
    //
    hr = S_OK;

 CLEANUP:
    if(fEnumerating)
        pICatItemAttr->EndAttributeNameEnumeration(&enumerator);

    return hr;
}

//+------------------------------------------------------------
//
// Function: CEmailIdLdapStore::HrExpandNextDlPage
//
// Synopsis: Issue an LDAP search to fetch the next block of members
//
// Arguments:
//  pMemCtx: The initialized MEMBERRESOLVECONTEXT
//
// Returns:
//  MAILTRANSPORT_S_PENDING: Issued the search
//  E_INVALIDARG: One of the parameters was too large to fit in the
//                  fixed size attribute buffer
//  or error from LdapConn
//
// History:
// jstamerj 1998/09/23 18:01:51: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::HrExpandNextDlPage(
    PMEMBERRESOLVECONTEXT pMemCtx)
{
    HRESULT hr;
    CMembershipPageInsertionRequest *pCInsertion = NULL;

    CatFunctEnterEx((LPARAM)this,
                      "CEmailIDLdapStore::HrExpandNextDlPage");

    _ASSERT(pMemCtx);
    _ASSERT(pMemCtx->pCCatAddr);

    pCInsertion = new CMembershipPageInsertionRequest(
        pMemCtx);

    if(pCInsertion == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG_ADDR(pMemCtx->pCCatAddr, "new CMembershipPageInsertionRequest");
        goto CLEANUP;
    }

    hr = pMemCtx->pConn->HrInsertInsertionRequest(
        pCInsertion);
    ERROR_CLEANUP_LOG_ADDR(pMemCtx->pCCatAddr, "pMemCtx->pConn->HrInsertInsertionRequest");
        
    //
    // If AsyncSearch succeeded, it is always pending
    //
    hr = MAILTRANSPORT_S_PENDING;

 CLEANUP:
    if(pCInsertion)
        pCInsertion->Release();

    DebugTrace((LPARAM)this, "HrExpandDlPage returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::AsyncExpandDlCompletion
//
// Synopsis: Handle completion of an async lookup for DL members
//
// Arguments:
//  ctx: pMemCtx passed to AsyncSearch
//  dwNumResults: Number of objects matching search filter
//  rgpICatItemAttrs: Array of ICatItemAttributes
//  hr: Resolution status
//  fFinalCompletion: Indicates wether this is a partial completion or
//                    the last completion call
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/24 09:28:18: Created.
//
//-------------------------------------------------------------
template <class T> VOID CEmailIDLdapStore<T>::AsyncExpandDlCompletion(
    LPVOID ctx,
    DWORD  dwNumResults,
    ICategorizerItemAttributes **rgpICatItemAttrs,
    HRESULT hrResolveStatus,
    BOOL fFinalCompletion)
{
    HRESULT hr = S_OK;
    PMEMBERRESOLVECONTEXT pMemCtx = NULL;
    CBatchLdapConnection *pConn = NULL;

    CatFunctEnter("CEmailIDLdapStore::AsyncExpandDlCompleton");

    pMemCtx = (PMEMBERRESOLVECONTEXT) ctx;
    _ASSERT(pMemCtx);

    pConn = pMemCtx->pConn;
    pConn->AddRef();

    //
    // Get/Release insertion context so that inserted queries will be batched
    //
    pConn->GetInsertionContext();

    //
    // If we had a previous failure for this resolution, do nothing
    //
    if(FAILED(pMemCtx->hrResolveStatus)) {

        hr = pMemCtx->hrResolveStatus;
        goto CLEANUP;
    }

    if(FAILED(hrResolveStatus)) {
        //
        // Handle failures in the cleanup code
        //
        hr = hrResolveStatus;
        ERROR_LOG_ADDR_STATIC(
            pMemCtx->pCCatAddr, 
            "async",
            pMemCtx,
            pMemCtx->pStore->GetISMTPServerEx());
        goto CLEANUP;
    }

    //
    // If we haven't yet found our search result, look for it
    //
    if(pMemCtx->pICatItemAttr == NULL) {
        //
        // Which result is ours?
        //  We need to find the result that matches the
        //  distinguishingattribute/value.  We do not need to worry
        //  about multiple matches (the first search and match in
        //  asyncctx would have caught that)
        //
        LPSTR pszDistinguishingAttribute;
        LPSTR pszDistinguishingAttributeValue;
        DWORD dwCount;
        BOOL  fFound;
        ICategorizerItemAttributes *pICatItemAttr;

        hr = pMemCtx->pCCatAddr->GetStringAPtr(
            ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
            &pszDistinguishingAttribute);
        ERROR_CLEANUP_LOG_ADDR_STATIC(
            pMemCtx->pCCatAddr, 
            "pMemCtx->pCCatAddr->GetSTringAPtr(distinguishingattribute)",
            pMemCtx,
            pMemCtx->pStore->GetISMTPServerEx());

        hr = pMemCtx->pCCatAddr->GetStringAPtr(
            ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE,
            &pszDistinguishingAttributeValue);
        ERROR_CLEANUP_LOG_ADDR_STATIC(
            pMemCtx->pCCatAddr, 
            "pMemCtx->pCCatAddr->GetStringAPtr(distinguishingattributevalue",
            pMemCtx,
            pMemCtx->pStore->GetISMTPServerEx());

        //
        // Find the result matching the search request
        //
        for(fFound = FALSE, dwCount = 0;
            (fFound == FALSE) && (dwCount < dwNumResults);
            dwCount++) {

            ATTRIBUTE_ENUMERATOR enumerator;
            LPSTR pszObjectAttributeValue;
            pICatItemAttr = rgpICatItemAttrs[dwCount];

            hr = pICatItemAttr->BeginAttributeEnumeration(
                pszDistinguishingAttribute,
                &enumerator);

            if(SUCCEEDED(hr)) {

                hr = pICatItemAttr->GetNextAttributeValue(
                    &enumerator,
                    &pszObjectAttributeValue);

                while(SUCCEEDED(hr) && (fFound == FALSE)) {
                    if(lstrcmpi(
                        pszObjectAttributeValue,
                        pszDistinguishingAttributeValue) == 0) {

                        fFound = TRUE;
                    }

                    hr = pICatItemAttr->GetNextAttributeValue(
                        &enumerator,
                        &pszObjectAttributeValue);
                }
                hr = pICatItemAttr->EndAttributeEnumeration(
                    &enumerator);
            }
        }

        if(fFound) {
            //
            // Save the found result
            //
            pMemCtx->pICatItemAttr = pICatItemAttr;
            pMemCtx->pICatItemAttr->AddRef();
        }
    }
    //
    // Only process the members when this search is done
    //
    if(fFinalCompletion) {

        ICategorizerItemAttributes *pICatItemAttr;

        pICatItemAttr = pMemCtx->pICatItemAttr;

        if(pICatItemAttr == NULL) {

            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            ERROR_LOG_ADDR_STATIC(
                pMemCtx->pCCatAddr, 
                "--no result--",
                pMemCtx,
                pMemCtx->pStore->GetISMTPServerEx());
            goto CLEANUP;
        }
        //
        // Null the ICatItemAttr pointer in the context and reset
        // hrResolutionStatus before starting a new search
        //
        pMemCtx->pICatItemAttr = NULL;
        pMemCtx->hrResolveStatus = S_OK;

        //
        // Process the new members
        //
        hr = pMemCtx->pStore->HrExpandDlPage(
            pMemCtx,
            pICatItemAttr);
        //
        // If this returns MAILTRANSPORT_S_PENDING, then this
        // completion routine will be called to free pMemCtx.
        // Therefore, we can NOT use pMemCtx below here when hr ==
        // MAILTRANSPORT_S_PENDING!
        //

        //
        // Release the Attributes interface (it was Addref'd when put into pMemCtx)
        //
        pICatItemAttr->Release();

        ERROR_CLEANUP_LOG_ADDR_STATIC(
            pMemCtx->pCCatAddr, 
            "pMemCtx->pStore->HrExpandDlPage",
            pMemCtx,
            pMemCtx->pStore->GetISMTPServerEx());
    }

 CLEANUP:
    //
    // Decrement the pending lookup added from
    // CMembershipPageInsertionRequest::HrInsertSearches
    //
    if(fFinalCompletion)
        pConn->DecrementPendingSearches(1);

    if(FAILED(hr)) {
        //
        // Save the error
        //
        pMemCtx->hrResolveStatus = hr;

    }
    if((fFinalCompletion) && (hr != MAILTRANSPORT_S_PENDING)) {
        //
        // THe final completion routine of the final search, so clean up
        //

        //
        // Call the sink completion routine
        //
        pMemCtx->pfnCompletion(
            pMemCtx->hrResolveStatus,
            pMemCtx->pCompletionContext);

        //
        // Get/Release insertion context so that inserted queries will be batched
        //
        pMemCtx->pConn->ReleaseInsertionContext();

        //
        // First release the connection
        //
        pMemCtx->pConn->Release();

        //
        // Release the CCatAddr object
        //
        pMemCtx->pCCatAddr->Release();

        //
        // Free the context that has served us thus far
        //
        if(pMemCtx->pICatItemAttr)
            pMemCtx->pICatItemAttr->Release();
        delete pMemCtx;

    } else {
        //
        // Get/Release insertion context so that inserted queries will be batched
        //
        pConn->ReleaseInsertionContext();
    }
    if(pConn)
        pConn->Release();
}

//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::HrExpandDynamicDlMembers
//
// Synopsis: Handle the expansion of a dynamicDL
//
// Arguments:
//  pCCatAddr: The item to expand
//  pListContext: List context initialized in
//                InitializeResolveListContext
//  pfnCompletion: A function to call upon async completion
//  pContext: Context to pass to the completion function
//
// Returns:
//  S_OK: Success, completed synchronously
//  MAILTRANSPORT_S_PENDING: Will complete async calling pfnCompletion
//  E_OUTOFMEMORY
//  CAT_E_DBCONNECTION: palc->GetConnection returned NULL (meaning it
//                      is having problems obtaining/maintaing a connection)
//
// History:
// jstamerj 1998/09/24 14:19:43: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::HrExpandDynamicDlMembers(
    CCatAddr *pCCatAddr,
    LPRESOLVE_LIST_CONTEXT pListContext,
    PFN_DLEXPANSIONCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    LPSTR pszFilterAttribute;
    CStoreListResolveContext *pCStoreContext;
    CDynamicDLSearchInsertionRequest *pCInsertionRequest = NULL;

    CatFunctEnterEx((LPARAM)this,
                      "CEmailIDLdapStore::HrExpandDynamicDlMembers");

    pCStoreContext = (CStoreListResolveContext *) pListContext->pStoreContext;

    hr = m_pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DL_DYNAMICFILTER,
        &pszFilterAttribute);

    if(FAILED(hr)) {
        //
        // Dynamic DLs simply aren't supported in this case
        //
        hr = S_OK;
        goto CLEANUP;
    }

    //
    // Allocate an insertion request
    //
    pCInsertionRequest = new CDynamicDLSearchInsertionRequest(
        AsyncDynamicDlCompletion,
        pCCatAddr,
        pCStoreContext,
        m_pICatParams,
        pfnCompletion,
        pContext);
    
    if(pCInsertionRequest == NULL) {
    
        hr = E_OUTOFMEMORY;
        ERROR_CLEANUP_LOG_ADDR(pCCatAddr, "new CDynamicDLSearchInsertionRequest");
        goto CLEANUP;
    }

    //
    // Now issue the search for the dynamic DL members
    //
    hr = pCStoreContext->HrInsertInsertionRequest(
        pCInsertionRequest);
        
    if(SUCCEEDED(hr)) {
        //
        // The search is async, so return pending
        //
        hr = MAILTRANSPORT_S_PENDING;
        //
        // We don't release pCInsertionRequest here because it
        // will be released on a future call to AsyncDynamicDlCompletion.
        //
    } else {
        //
        // We failed to insert the insertion request, so the completion will never
        // be called, so we need to call Release here.
        //
        ERROR_LOG_ADDR(pCCatAddr, "pCStoreContext->HrInsertInsertionRequest");
        pCInsertionRequest->Release();
    }
    
 CLEANUP:
    
    DebugTrace((LPARAM)this, "HrExpandDynamicDl returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);

    return hr;
}


//+------------------------------------------------------------
//
// Function: CEmailIDLdapStore::AsyncDynamicDlCompletion
//
// Synopsis: Handle completion of an async lookup for DL members
//
// Arguments:
//  ctx: pMemCtx passed to AsyncSearch
//  dwNumResults: Number of objects matching search filter
//  rgpICatItemAttrs: Array of ICatItemAttributes
//  hr: Resolution status
//  fFinalCompletion: Indicates wether this is a partial result or not
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/24 09:28:18: Created.
//
//-------------------------------------------------------------
template <class T> VOID CEmailIDLdapStore<T>::AsyncDynamicDlCompletion(
    LPVOID ctx,
    DWORD  dwNumResults,
    ICategorizerItemAttributes **rgpICatItemAttrs,
    HRESULT hrResolveStatus,
    BOOL fFinalCompletion)
{
    HRESULT hr = S_OK;
    DWORD dwCount;
    CDynamicDLSearchInsertionRequest *pCtx = NULL;
    BOOL fReissued = FALSE;

    CatFunctEnter("CEmailIDLdapStore::AsyncDynamicDlCompleton");

    pCtx = (CDynamicDLSearchInsertionRequest *) ctx;
    _ASSERT(pCtx);

    pCtx->m_ResolveCtx.pSLRC->GetInsertionContext();
    
    if( ((hrResolveStatus == CAT_E_DBCONNECTION) ||
        (hrResolveStatus == HRESULT_FROM_WIN32(ERROR_CANCELLED))) &&
        pCtx->m_ResolveCtx.fFirstPage &&
        !(pCtx->m_ResolveCtx.pSLRC->Canceled()) ) {
        //
        // fFinalCompletion should always be true if there was
        // an error
        //
        _ASSERT(fFinalCompletion);
        
        CDynamicDLSearchInsertionRequest *pCInsertionRequest;
        
        if(pCtx->m_ResolveCtx.pConn) {
            hr = pCtx->m_ResolveCtx.pSLRC->HrInvalidateConnectionAndRetrieveNewConnection(
                pCtx->m_ResolveCtx.pConn);
                
            ERROR_CLEANUP_LOG_ADDR_STATIC(
                pCtx->m_ResolveCtx.pCCatAddr, 
                "pCtx->m_ResolveCtx.pSLRC->HrInvalidateConnectionAndRetrieveNewConnection",
                pCtx,
                pCtx->GetISMTPServerEx());
        }

        pCInsertionRequest = new CDynamicDLSearchInsertionRequest(
            AsyncDynamicDlCompletion,
            pCtx->m_ResolveCtx.pCCatAddr,
            pCtx->m_ResolveCtx.pSLRC,
            pCtx->m_ResolveCtx.pICatParams,
            pCtx->m_ResolveCtx.pfnCompletion,
            pCtx->m_ResolveCtx.pCompletionContext);
            
        if(!pCInsertionRequest) {
            hr = E_OUTOFMEMORY;
            ERROR_LOG_ADDR_STATIC(
                pCtx->m_ResolveCtx.pCCatAddr, 
                "new CDynamicDLSearchInsertionRequest",
                pCtx,
                pCtx->GetISMTPServerEx());
            goto CLEANUP;
        }

        //
        // clean up pConn in the resolve context before reinsertion
        //
        hr = pCtx->m_ResolveCtx.pSLRC->HrInsertInsertionRequest(
            pCInsertionRequest);
        
        if (SUCCEEDED(hr)) {
            fReissued = TRUE;
            //
            // We don't release pCInsertionRequest here because it
            // will be released on a subsequent call to
            // AsyncDynamicDlCompletion.
            //
        } else {
            ERROR_LOG_ADDR_STATIC(
                pCtx->m_ResolveCtx.pCCatAddr, 
                "pCtx->m_ResolveCtx.pSLRC->HrInsertInsertionRequest",
                pCtx,
                pCtx->GetISMTPServerEx());
            pCInsertionRequest->Release();
        }
        
    } else {
    
        pCtx->m_ResolveCtx.fFirstPage = FALSE;
    
        if(FAILED(hrResolveStatus)) {
            //
            // Handle failures in the cleanup code
            //
            hr = hrResolveStatus;
            ERROR_LOG_ADDR_STATIC(
                pCtx->m_ResolveCtx.pCCatAddr, 
                "--async--",
                pCtx,
                pCtx->GetISMTPServerEx());

            goto CLEANUP;
        }

        for(dwCount = 0; dwCount < dwNumResults; dwCount++) {
            //
            // Loop through each ICatItemAttr; each one is a DL member.
            // Add it as a dynamic DL member
            //
            hr = pCtx->m_ResolveCtx.pCCatAddr->AddDynamicDLMember(
                rgpICatItemAttrs[dwCount]);

            _ASSERT(hr != MAILTRANSPORT_S_PENDING);

            ERROR_CLEANUP_LOG_ADDR_STATIC(
                pCtx->m_ResolveCtx.pCCatAddr,
                "pCtx->m_ResolveCtx.pCCatAddr->AddDynamicDLMember",
                pCtx,
                pCtx->GetISMTPServerEx());
        }
        
    }

 CLEANUP:
 
    if(FAILED(hr))
        pCtx->m_ResolveCtx.hrResolveStatus = hr;

    if(fFinalCompletion) {
    
        if (!fReissued) {
            //
            // Call the sink completion routine
            //
            pCtx->m_ResolveCtx.pfnCompletion(
                pCtx->m_ResolveCtx.hrResolveStatus,
                pCtx->m_ResolveCtx.pCompletionContext);
        }

        //
        // Get/Release insertion context so that inserted queries will be batched
        //
        pCtx->m_ResolveCtx.pSLRC->ReleaseInsertionContext();
        
        pCtx->Release();

    } else {

        //
        // There are no more async completions pending, BUT the
        // emailidldapstore has more members to tell us about
        //

        //
        // Get/Release insertion context so that inserted queries will be batched
        //
        pCtx->m_ResolveCtx.pSLRC->ReleaseInsertionContext();
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   CEmailIDLdapStore::RetrieveICatParamsInfo
//
//  Synopsis:   Helper routine to retrieve the info we need from
//              ICategorizerParams.  Pointers to strings in ICatParams
//              are retrieved; the strings themselves are not copied.
//              Since ICatParams is read only at this point, the
//              strings will be good as long as we have a reference to
//              ICatParams.
//
//  Arguments:  [pszHost] -- The Host parameter is returned here
//              [pdwPort] -- The remote tcp Port# is returned here
//                        (*pdwPort is set to zero if the DSPARAMTER wasn't set)
//
//              [pszNamingContext] -- The NamingContext parameter is returned
//                  here.
//              [pszAccount] -- The LDAP account parameter is returned here.
//              [pszPassword] -- The LDAP password parameter is returned here.
//              [pbt] -- The bind type to use to connect to ldap hosts.
//
//  Returns:    S_OK always -- parameters that couldn't be retrieved
//              will be set to NULL (or simple bind for bind type)
//
//-----------------------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::RetrieveICatParamsInfo(
    LPSTR *ppszHost,
    DWORD *pdwPort,
    LPSTR *ppszNamingContext,
    LPSTR *ppszAccount,
    LPSTR *ppszDomain,
    LPSTR *ppszPassword,
    LDAP_BIND_TYPE *pbt)
{
    CatFunctEnter("CEmailIDLdapStore::RetrieveICatParamsInfo");

    LPSTR pszBindType = NULL;
    LPSTR pszPort = NULL;

    *ppszHost = NULL;
    *pdwPort = 0;
    *ppszNamingContext = NULL;
    *ppszAccount = NULL;
    *ppszDomain = NULL;
    *ppszPassword = NULL;
    *pbt = BIND_TYPE_SIMPLE;

    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPHOST,
        ppszHost);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPNAMINGCONTEXT,
        ppszNamingContext);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPACCOUNT,
        ppszAccount);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPDOMAIN,
        ppszDomain);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPPASSWORD,
        ppszPassword);
    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPPORT,
        &pszPort);

    if(pszPort) {
        //
        // Convert from a string to a dword
        //
        *pdwPort = atol(pszPort);
    }


    m_pICatParams->GetDSParameterA(
        DSPARAMETER_LDAPBINDTYPE,
        &pszBindType);

    if(pszBindType) {
        if (lstrcmpi(pszBindType, "None") == 0) {
            *pbt = BIND_TYPE_NONE;
        }
        else if(lstrcmpi(pszBindType, "CurrentUser") == 0) {
            *pbt = BIND_TYPE_CURRENTUSER;
        }
        else if (lstrcmpi(pszBindType, "Simple") == 0) {
            *pbt = BIND_TYPE_SIMPLE;
        }
        else if (lstrcmpi(pszBindType, "Generic") == 0) {
            *pbt = BIND_TYPE_GENERIC;
        }
    }

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: AccountFromUserDomain
//
// Synopsis: Helper function.  Given a username and netbios domain
//           name, form the account name to use.
//
// Arguments:
//  pszAccount: Buffer to fill in
//  dwccAccount: Size of that buffer
//  pszUser: Username.  If NULL, pszAccount will be set to ""
//  pszDomain: Domainname.  If NULL, pszUser will be copied to pszAccount
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): dwccAccount is not
//  sufficiently large
//
// History:
// jstamerj 1998/06/25 12:06:02: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CEmailIDLdapStore<T>::AccountFromUserDomain(
    LPTSTR pszAccount,
    DWORD  dwccAccount,
    LPTSTR pszUser,
    LPTSTR pszDomain)
{
    CatFunctEnterEx((LPARAM)this,"CEmailIDLdapStore::AccountFromUserDomainSchema");
    _ASSERT(pszAccount != NULL);
    _ASSERT(dwccAccount >= 1);

    pszAccount[0] = '\0';

    if(pszUser) {
        if((pszDomain == NULL) || (pszDomain[0] == '\0')) {
            //
            // If Domain is NULL, just copy user to account
            //
            if((DWORD)lstrlen(pszUser) >= dwccAccount) {
                return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            lstrcpy(pszAccount, pszUser);

        } else {
            if((DWORD)lstrlen(pszUser) + (DWORD)lstrlen(pszAccount) + 1 >=
               dwccAccount) {
                return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            lstrcpy(pszAccount, pszDomain);
            lstrcat(pszAccount, "\\");
            lstrcat(pszAccount, pszUser);
        }
    }
    DebugTrace(NULL, "Returning pszAccount = \"%s\"", pszAccount);
    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CMembershipPageInsertionRequest::HrInsertSearches
//
// Synopsis: Insert the search for the next page of members
//
// Arguments:
//  dwcSearches: Number of searches we may insert
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1999/03/26 11:58:26: Created.
//
//-------------------------------------------------------------
HRESULT CMembershipPageInsertionRequest::HrInsertSearches(
    DWORD dwcSearches)
{
    HRESULT hr = S_OK;
    LPSTR pszSearchFilter;
    LPWSTR pszMemberAttr;
    LPSTR pszDistinguishingAttribute;
    LPWSTR pwszDistinguishingAttribute;
    LPCWSTR rgpszAttributes[3];
    int i;

    WCHAR szMemberAttribute[MAX_MEMBER_ATTRIBUTE_SIZE +
                            (sizeof(WSZ_PAGEDMEMBERS_INDICATOR)/sizeof(WCHAR)) +
                            MAX_PAGEDMEMBERS_DIGITS +
                            sizeof("-*")];

    CatFunctEnterEx((LPARAM)this, "CMembershipPageInsertionRequest::HrInsertSearches");

    _ASSERT(m_pMemCtx);
    _ASSERT(m_pMemCtx->pCCatAddr);

    if((dwcSearches == 0) ||
       (m_fInsertedRequest == TRUE))
        goto CLEANUP;

    //
    // Now we will either insert the request or call our completion
    // with a failure
    //
    m_fInsertedRequest = TRUE;
    //
    // Use the original search filter that found this object in the
    // first place
    //
    hr = m_pMemCtx->pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_LDAPQUERYSTRING,
        &pszSearchFilter);

    if(FAILED(hr)) {
        //
        // It is possible that we have an item where BuildQuery was
        // never triggered (in the case of a 1000+ member DL that is a
        // member of a dynamic DL).  For this case, TriggerBuildQuery
        // and try to retrieve a query string again
        //
        DebugTrace((LPARAM)this, "No query string found on a paged DL; triggering buildquery");
        hr = m_pMemCtx->pCCatAddr->HrTriggerBuildQuery();
        ERROR_CLEANUP_LOG_ADDR(m_pMemCtx->pCCatAddr, "m_pMemCtx->pCCatAddr->HrTriggerBuildQuery");

        //
        // Try to get the query string again
        //
        hr = m_pMemCtx->pCCatAddr->GetStringAPtr(
            ICATEGORIZERITEM_LDAPQUERYSTRING,
            &pszSearchFilter);
        ERROR_CLEANUP_LOG_ADDR(m_pMemCtx->pCCatAddr, "m_pMemCtx->pCCatAddr->GetSTringAPtr(ldapquerystring)");
    }

    hr = m_pMemCtx->pCCatAddr->GetStringAPtr(
        ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
        &pszDistinguishingAttribute);
    ERROR_CLEANUP_LOG_ADDR(m_pMemCtx->pCCatAddr, "m_pMemCtx->pCCatAddr->GetStringAPtr");
    //
    // Convert distinguishing attribute to unicode
    //
    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        pszDistinguishingAttribute,
        -1,
        NULL,
        0);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG_ADDR(m_pMemCtx->pCCatAddr, "MultiByteToWideChar - 0");
        goto CLEANUP;
    }
    pwszDistinguishingAttribute = (LPWSTR) alloca(i * sizeof(WCHAR));
    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        pszDistinguishingAttribute,
        -1,
        pwszDistinguishingAttribute,
        i);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG_ADDR(m_pMemCtx->pCCatAddr, "MultiByteToWideChar - 1");
        goto CLEANUP;
    }

    hr = m_pMemCtx->pStore->m_pICatParams->GetDSParameterW(
        DSPARAMETER_ATTRIBUTE_DL_MEMBERS,
        &pszMemberAttr);
    ERROR_CLEANUP_LOG_ADDR(m_pMemCtx->pCCatAddr, "m_pMemCtx->m_pStore->m_pICatParams->GetDSParamterW(dlmembers)");

    //
    // Form the member attribute name we want
    //
    if( _snwprintf(szMemberAttribute,
                   sizeof(szMemberAttribute)/sizeof(WCHAR),
                   L"%s" WSZ_PAGEDMEMBERS_INDICATOR L"%d-*",
                   pszMemberAttr,
                   m_pMemCtx->dwNextBlockIndex) < 0) {
        //
        // There was insufficient space in the buffer
        //
        ErrorTrace((LPARAM)this, "Insufficient space to form paged member attribute name");
        hr = E_INVALIDARG;
        ERROR_LOG_ADDR(m_pMemCtx->pCCatAddr, "_snwprintf -- insufficient buffer");
        goto CLEANUP;
    }

    //
    // Form the attribute array
    //
    rgpszAttributes[0] = szMemberAttribute;
    rgpszAttributes[1] = pwszDistinguishingAttribute;
    rgpszAttributes[2] = NULL;

    //
    // Increment here, decrement in AsyncExpandDlCompletion
    //
    m_pMemCtx->pConn->IncrementPendingSearches();

    hr = m_pMemCtx->pConn->AsyncSearch(
        m_pMemCtx->pConn->GetNamingContextW(),
        LDAP_SCOPE_SUBTREE,
        pszSearchFilter,
        rgpszAttributes,
        0, // Not a paged search (as in dynamic DLs)
        CEmailIDLdapStore<CCatAddr>::AsyncExpandDlCompletion,
        m_pMemCtx);

    if(FAILED(hr)) {
        m_pMemCtx->pConn->DecrementPendingSearches(1);
        ERROR_LOG_ADDR(m_pMemCtx->pCCatAddr, "m_pMemCtx->pConn->AsyncSearch");
        goto CLEANUP;
    }

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Call completion now instead of later when we are dequeued
        //
        _ASSERT(m_fInsertedRequest);
        //
        // AsyncExpandDlCompletion will always decrement the pending searches
        //
        m_pMemCtx->pConn->IncrementPendingSearches();

        CEmailIDLdapStore<CCatAddr>::AsyncExpandDlCompletion(
            m_pMemCtx,      // ctx
            0,              // dwNumResults
            NULL,           // rgpICatItemAttrs
            hr,             // hrResolveStatus
            TRUE);          // fFinalCompletion
    }
    
    if(SUCCEEDED(hr))
        hr = (m_fInsertedRequest ? HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) : S_OK);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
        
    return hr;
} // CMembershipPageInsertionRequest::HrInsertSearches


//+------------------------------------------------------------
//
// Function: CMembershipPageInsertionRequest::NotifyDeQueue
//
// Synopsis: Notification that this insertion request is being dequeued
//
// Arguments:
//  hr: Reason why we are dequeueing
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/04/03 17:15:17: Created.
//
//-------------------------------------------------------------
VOID CMembershipPageInsertionRequest::NotifyDeQueue(
    HRESULT hr)
{
    CatFunctEnterEx((LPARAM)this, "CMembershipPageInsertionRequest::NotifyDeQueue");
    //
    // If our request is being dequeue'd and we have not inserted our
    // request to ldapconn, then we are being cancelled
    // Notify our master of this
    //
    if(!m_fInsertedRequest) {
        //
        // AsyncExpandDlCompletion will always decrement the pending searches
        //
        m_pMemCtx->pConn->IncrementPendingSearches();

        CEmailIDLdapStore<CCatAddr>::AsyncExpandDlCompletion(
            m_pMemCtx,      // ctx
            0,              // dwNumResults
            NULL,           // rgpICatItemAttrs
            (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) ? S_OK : hr),
            TRUE);          // fFinalCompletion
    }

    CatFunctLeaveEx((LPARAM)this);
} // CMembershipPageInsertionRequest::NotifyDeQueue

//+------------------------------------------------------------
//
// Function: CDynamicDLSearchInsertionRequest::CDynamicDLSearchInsertionRequest
//
// Synopsis: Constructor
//
// Arguments:
//
// Returns: NOTHING
//
// History:
// dlongley 2001/12/07: Created.
//
//-------------------------------------------------------------
CDynamicDLSearchInsertionRequest::CDynamicDLSearchInsertionRequest(
    LPLDAPCOMPLETION pfnLdapCompletion,
    CCatAddr *pCCatAddr,
    CStoreListResolveContext *pSLRC,
    ICategorizerParametersEx *pICatParams,
    PFN_DLEXPANSIONCOMPLETION pfnExpansionCompletion,
    PVOID pCompletionContext)
{
    _ASSERT(pfnLdapCompletion);
    
    m_pfnCompletion = pfnLdapCompletion;
    
    pCCatAddr->AddRef();
    m_ResolveCtx.pCCatAddr = pCCatAddr;
    
    pSLRC->AddRef();
    m_ResolveCtx.pSLRC = pSLRC;
    
    pICatParams->AddRef();
    m_ResolveCtx.pICatParams = pICatParams;
    
    m_ResolveCtx.pfnCompletion = pfnExpansionCompletion;
    m_ResolveCtx.pCompletionContext = pCompletionContext;
    m_ResolveCtx.fFirstPage = TRUE;
    m_ResolveCtx.pConn = NULL;
    m_ResolveCtx.hrResolveStatus = S_OK;
    
    m_fInsertedRequest = FALSE;
    
    m_dwPageSize = CEmailIDLdapStore<CCatAddr>::m_dwDynamicDlPageSize;
    
    m_dwSignature = SIGNATURE_CDynamicDLSearchInsertionRequest;
} // CDynamicDLSearchInsertionRequest::CDynamicDLSearchInsertionRequest

//+------------------------------------------------------------
//
// Function: CDynamicDLSearchInsertionRequest::~CDynamicDLSearchInsertionRequest
//
// Synopsis: Destructor
//
// Arguments: None
//
// Returns: NOTHING
//
// History:
// dlongley 2001/12/07: Created.
//
//-------------------------------------------------------------
CDynamicDLSearchInsertionRequest::~CDynamicDLSearchInsertionRequest()
{
    _ASSERT(m_dwSignature == SIGNATURE_CDynamicDLSearchInsertionRequest);
    
    m_ResolveCtx.pCCatAddr->Release();
    m_ResolveCtx.pSLRC->Release();
    m_ResolveCtx.pICatParams->Release();
    
    if(m_ResolveCtx.pConn) {
        m_ResolveCtx.pConn->DecrementPendingSearches(m_dwPageSize);
        m_ResolveCtx.pConn->Release();
    }
    
    m_dwSignature = SIGNATURE_CDynamicDLSearchInsertionRequest_INVALID;
} // CDynamicDLSearchInsertionRequest::~CDynamicDLSearchInsertionRequest

//+------------------------------------------------------------
//
// Function: CDynamicDLSearchInsertionRequest::HrInsertSearches
//
// Synopsis: Insert the search for the dynamic DL's members
//
// Arguments:
//  dwcSearches: Number of searches we may insert
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
//  dlongley 2001/12/07: Created.
//
//-------------------------------------------------------------
HRESULT CDynamicDLSearchInsertionRequest::HrInsertSearches(
    DWORD dwcSearches)
{
    HRESULT hr = S_OK;
    LPSTR pszFilterAttribute, pszFilter;
    LPSTR pszBaseDNAttribute, pszBaseDN;
    BOOL fEnumeratingFilter = FALSE;
    BOOL fEnumeratingBaseDN = FALSE;
    ATTRIBUTE_ENUMERATOR enumerator_filter;
    ATTRIBUTE_ENUMERATOR enumerator_basedn;
    LPWSTR *rgpszAllAttributes;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ICategorizerUTF8Attributes *pICatItemUTF8 = NULL;
    ICategorizerRequestedAttributes *pIRequestedAttributes = NULL;
    CBatchLdapConnection *pConn = NULL;

    CatFunctEnterEx((LPARAM)this,
                      "CDynamicDLSearchInsertionRequest::HrInsertSearches");

    if ( (dwcSearches == 0) || m_fInsertedRequest )
        goto CLEANUP;

    //
    // Get the attributes interface
    //
    hr = m_ResolveCtx.pCCatAddr->GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);

    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        ErrorTrace((LPARAM)this, "failed to get ICatItemAttr");
        ERROR_LOG_ADDR(m_ResolveCtx.pCCatAddr, "pCCatAddr->GetICategorizerItemAttributes");
        goto CLEANUP;
    }

    //
    // Get the UTF8 version of the attributes interface
    //
    hr = pICatItemAttr->QueryInterface(
        IID_ICategorizerUTF8Attributes,
        (LPVOID *)&pICatItemUTF8);

    if(FAILED(hr)) {
        pICatItemUTF8 = NULL;
        ErrorTrace((LPARAM)this, "Failed to get UTF8 attribute enumeration interface");
        ERROR_LOG_ADDR(m_ResolveCtx.pCCatAddr, "pICatItemAttr->QueryInterface(utf8attributes)");
        goto CLEANUP;
    }
    
    hr = m_ResolveCtx.pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DL_DYNAMICFILTER,
        &pszFilterAttribute);

    //
    // We checked this case in CEmailIDLdapStore<T>::HrExpandDynamicDlMembers
    // and it must have succeeded there in order for this insertion request
    // ever to have been queued.
    //
    _ASSERT( SUCCEEDED(hr) );

    hr = m_ResolveCtx.pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DL_DYNAMICBASEDN,
        &pszBaseDNAttribute);

    if(FAILED(hr)) {
        //
        // Use the default baseDN
        //
        ERROR_LOG_ADDR(m_ResolveCtx.pCCatAddr, "m_pICatParams->GetDSParameterA");
        pszBaseDNAttribute = NULL;
        pszBaseDN = NULL;
    }

    //
    // Find the query filter string
    //
    hr = pICatItemUTF8->BeginUTF8AttributeEnumeration(
        pszFilterAttribute,
        &enumerator_filter);

    if(SUCCEEDED(hr)) {

        fEnumeratingFilter = TRUE;

        hr = pICatItemUTF8->GetNextUTF8AttributeValue(
            &enumerator_filter,
            &pszFilter);
    }

    if(FAILED(hr)) {
        //
        // No such attribute?  No members.
        //
        ERROR_LOG_ADDR(
            m_ResolveCtx.pCCatAddr,
            "pICatItemUTF8->GetNextUTF8AttributeValue(filter) or "
            "pICatItemUTF8->BeginUTF8AttributeEnumeration(pszFilterAttribute)");
        hr = S_OK;
        
        m_fInsertedRequest = TRUE;
        
        m_pfnCompletion(
            this,
            0,
            NULL,
            hr,
            TRUE);
        
        goto CLEANUP;
    }
    //
    // Find the base DN
    //
    if(pszBaseDNAttribute) {

        hr = pICatItemUTF8->BeginUTF8AttributeEnumeration(
            pszBaseDNAttribute,
            &enumerator_basedn);

        if(SUCCEEDED(hr)) {

            fEnumeratingBaseDN = TRUE;

            hr = pICatItemUTF8->GetNextUTF8AttributeValue(
                &enumerator_basedn,
                &pszBaseDN);

        }
        if(FAILED(hr)) {
            //
            // Use the default base DN
            //
            pszBaseDN = NULL;
        }
    }

    //
    // Fetch all the requested attributes
    //
    hr = m_ResolveCtx.pICatParams->GetRequestedAttributes(
        &pIRequestedAttributes);
    ERROR_CLEANUP_LOG_ADDR(m_ResolveCtx.pCCatAddr, "pICatParams->GetRequestedAttributes");

    hr = pIRequestedAttributes->GetAllAttributesW(
        &rgpszAllAttributes);
    ERROR_CLEANUP_LOG_ADDR(m_ResolveCtx.pCCatAddr, "pIRequestedAttributes->GetAllAttributesW");
    
    //
    // Get the LDAP connection from the CStoreListResolveContext
    //
    pConn = m_ResolveCtx.pSLRC->GetConnection();
    
    DebugTrace((LPARAM)this, "GetConnection returned %08lx", hr);
    
    if(pConn == NULL) {
    
        hr = CAT_E_DBCONNECTION;
        ERROR_LOG_ADDR(m_ResolveCtx.pCCatAddr,"m_ResolveCtx.pSLRC->GetConnection");
        
    } else {
        //
        // Now issue the search for the dynamic DL members
        //
        _ASSERT(m_ResolveCtx.pConn == NULL);
        
        m_ResolveCtx.pConn = pConn;
        pConn->AddRef();
        
        pConn->IncrementPendingSearches(m_dwPageSize);
        
        hr = pConn->AsyncSearch(
            (LPCSTR) (pszBaseDN ? pszBaseDN : pConn->GetNamingContext()),
            LDAP_SCOPE_SUBTREE,
            pszFilter,
            (LPCWSTR *)rgpszAllAttributes,
            m_dwPageSize,
            m_pfnCompletion,
            this);
            
        DebugTrace((LPARAM)this, "AsyncSearch returned %08lx", hr);
            
        if(SUCCEEDED(hr)) {
            //
            // It is safe to set a member after calling AsyncSearch
            // SUCCEEDED because:
            // 1) Our caller
            // (CBatchLdapConnection::DecrementPendingSearches) has a
            // reference to us, so we will not be deleted.
            // 2) Out caller ensures that NotifyDequeue will not be
            // called while we are inside HrInsertSearches
            //
            m_fInsertedRequest = TRUE;
        } else {
            ERROR_LOG_ADDR(m_ResolveCtx.pCCatAddr,"pConn->AsyncSearch");
        }
    }
    
    if(pConn)
        pConn->Release();
  
 CLEANUP:
 
    if(fEnumeratingFilter) {

        pICatItemUTF8->EndUTF8AttributeEnumeration(
            &enumerator_filter);
    }
    if(fEnumeratingBaseDN) {

        pICatItemUTF8->EndUTF8AttributeEnumeration(
            &enumerator_basedn);
    }
    
    if(pICatItemAttr)
        pICatItemAttr->Release();

    if(pICatItemUTF8)
        pICatItemUTF8->Release();

    if(pIRequestedAttributes)
        pIRequestedAttributes->Release();
        
    if(SUCCEEDED(hr))
        hr = (m_fInsertedRequest ? HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) : S_OK);
    
    DebugTrace((LPARAM)this, "HrInsertSearches returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    
    return hr;
} // CDynamicDLSearchInsertionRequest::HrInsertSearches

//+------------------------------------------------------------
//
// Function: CDynamicDLSearchInsertionRequest::NotifyDeQueue
//
// Synopsis: Notification that this insertion request is being dequeued
//
// Arguments:
//  hr: Reason why we are dequeueing
//
// Returns: NOTHING
//
// History:
//  dlongley 2001/12/07: Created.
//
//-------------------------------------------------------------
VOID CDynamicDLSearchInsertionRequest::NotifyDeQueue(
    HRESULT hrReason)
{
    TraceFunctEnterEx((LPARAM)this, "CDynamicDLSearchInsertionRequest::NotifyDeQueue");
    
    if(!m_fInsertedRequest) {
        //
        // AsyncSearch was not called so we need to call the completion directly
        //
        m_pfnCompletion(
            this,
            0,
            NULL,
            (hrReason == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) ? S_OK : hrReason),
            TRUE);
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CDynamicDLSearchInsertionRequest::NotifyDeQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapconn.cpp ===
//
// ldapconn.cpp -- This file contains the class implementation for:
//      CLdapConnection
//      CLdapConnectionCache
//
// Created:
//      Dec 31, 1996 -- Milan Shah (milans)
//
// Changes:
//

#include "precomp.h"
#include "ldapconn.h"
#include "icatitemattr.h"
#define SECURITY_WIN32
#include "security.h"

LDAP_TIMEVAL CLdapConnection::m_ldaptimeout = { LDAPCONN_DEFAULT_RESULT_TIMEOUT, 0 };
DWORD CLdapConnection::m_dwLdapRequestTimeLimit = DEFAULT_LDAP_REQUEST_TIME_LIMIT;

//
// LDAP counter block
//
CATLDAPPERFBLOCK g_LDAPPerfBlock;

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::CLdapConnection
//
//  Synopsis:   Constructor for a CLdapConnection object.
//
//  Arguments:  [szHost] -- The actual name of the LDAP host to connect to.
//                  If it is NULL, and we are running on an NT5 machine, we'll
//                  use the default DC
//
//              [dwPort] -- The remote tcp port to connect to.  If
//                          zero, LDAP_PORT is assumed
//
//              [szNamingContext] -- The naming context to use within the
//                  LDAP DS. If NULL, the naming context will be determined
//                  by using the default naming context of the LDAP DS.
//
//                  By allowing a naming context to be associated with an
//                  ldap connection, we can have multiple "logical" ldap
//                  connections served by the same LDAP DS. This is useful
//                  if folks want to setup mutliple virtual SMTP/POP3 servers
//                  all served by the same LDAP DS. The naming context in
//                  that case would be the name of the OU to restrict the
//                  DS operations to.
//
//              [szAccount] -- The DN of the account to log in as.
//
//              [szPassword] -- The password to use to log in.
//
//              [bt] -- The bind method to use. (none, simple, or generic)
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdapConnection::CLdapConnection(
    IN LPSTR szHost,
    IN DWORD dwPort,
    IN LPSTR szNamingContext,
    IN LPSTR szAccount,
    IN LPSTR szPassword,
    IN LDAP_BIND_TYPE bt)
{
    int i;

    CatFunctEnter( "CLdapConnection::CLdapConnection" );

    m_dwSignature = SIGNATURE_LDAPCONN;

    m_pCPLDAPWrap = NULL;
    m_fValid = TRUE;
    m_fTerminating = FALSE;

    if (szNamingContext != NULL && szNamingContext[0] != 0) {

        _ASSERT(strlen(szNamingContext) < sizeof(m_szNamingContext) );

        strcpy(m_szNamingContext, szNamingContext);

        m_fDefaultNamingContext = FALSE;

        i = MultiByteToWideChar(
            CP_UTF8,
            0,
            m_szNamingContext,
            -1,
            m_wszNamingContext,
            sizeof(m_wszNamingContext) / sizeof(m_wszNamingContext[0]));

        _ASSERT(i > 0);

    } else {

        m_szNamingContext[0] = 0;
        m_wszNamingContext[0] = 0;

        m_fDefaultNamingContext = TRUE;
    }

    _ASSERT( (szHost != NULL) &&
             (strlen(szHost) < sizeof(m_szHost)) );

    _ASSERT( (bt == BIND_TYPE_NONE) ||
             (bt == BIND_TYPE_CURRENTUSER) ||
             ((szAccount != NULL) &&
                (szAccount[0] != 0) &&
                    (strlen(szAccount) < sizeof(m_szAccount)))
           );

    _ASSERT( (bt == BIND_TYPE_NONE) ||
             (bt == BIND_TYPE_CURRENTUSER) ||
             ((szPassword != NULL) &&
                (strlen(szPassword) < sizeof(m_szPassword))) );

    strcpy(m_szHost, szHost);

    SetPort(dwPort);

    if ((bt != BIND_TYPE_NONE) &&
        (bt != BIND_TYPE_CURRENTUSER)) {

        strcpy(m_szAccount, szAccount);

        strcpy(m_szPassword, szPassword);

    } else {

        m_szAccount[0] = 0;

        m_szPassword[0] = 0;

    }

    m_bt = bt;

    //
    // Initialize the async search completion structures
    //

    InitializeSpinLock( &m_spinlockCompletion );

    // InitializeCriticalSection( &m_cs );

    m_hCompletionThread = INVALID_HANDLE_VALUE;

    m_hOutstandingRequests = INVALID_HANDLE_VALUE;

    m_pfTerminateCompletionThreadIndicator = NULL;

    InitializeListHead( &m_listPendingRequests );

    m_fCancel = FALSE;

    m_dwRefCount = 1;
    m_dwDestructionWaiters = 0;
    m_hShutdownEvent = INVALID_HANDLE_VALUE;

    CatFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::~CLdapConnection
//
//  Synopsis:   Destructor for a CLdapConnection object
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

CLdapConnection::~CLdapConnection()
{
    CatFunctEnter( "CLdapConnection::~CLdapConnection" );

    _ASSERT(m_dwSignature == SIGNATURE_LDAPCONN);

    //
    // Disconnect
    //
    if (m_pCPLDAPWrap != NULL) {
        Disconnect();
    }

    if (m_hOutstandingRequests != INVALID_HANDLE_VALUE)
        CloseHandle( m_hOutstandingRequests );

    if (m_hShutdownEvent != INVALID_HANDLE_VALUE)
        CloseHandle( m_hShutdownEvent );

    // DeleteCriticalSection( &m_cs );

    m_dwSignature = SIGNATURE_LDAPCONN_INVALID;

    CatFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::~CLdapConnection
//
//  Synopsis:   Called on the last release
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::FinalRelease()
{
    CancelAllSearches();

    //
    // If there was an async completion thread, we need to indicate to it that
    // it should exit. That thread could be stuck at one of two points -
    // either it is waiting on the m_hOutstandingRequests semaphore to be
    // fired, or it is blocked on ldap_result(). So, we set the event and
    // close out m_pldap, then we wait for the async completion thread to
    // quit.
    //
    SetTerminateIndicatorTrue();

    if (m_hOutstandingRequests != INVALID_HANDLE_VALUE) {

        LONG nUnused;

        ReleaseSemaphore(m_hOutstandingRequests, 1, &nUnused);

    }

    //
    // We do not wait for the LdapCompletionThread to die if it is the
    // LdapCompletionThread itself that is deleting us. If we did, it would
    // cause a deadlock.
    //
    if (m_hCompletionThread != INVALID_HANDLE_VALUE) {

        if (m_idCompletionThread != GetCurrentThreadId()) {

            WaitForSingleObject( m_hCompletionThread, INFINITE );

        }

        CloseHandle( m_hCompletionThread );

    }

    delete this;
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::InitializeFromRegistry
//
//  Synopsis:   Reads registry-configurable parameters to initialize
//              LDAP connection parameters.
//
//              LDAPCONN_RESULT_TIMEOUT_VALUE is used as the timeout value
//              passed into ldap_result.
//
//              LDAP_REQUEST_TIME_LIMIT_VALUE is used to set the search time
//              limit option on the connection and also for the expiration time
//              on pending search requests.
//
//  Arguments:  None
//
//  Returns:    TRUE if successfully connected, FALSE otherwise.
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::InitializeFromRegistry()
{
    HKEY hkey;
    DWORD dwErr, dwType, dwValue, cbValue;

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, LDAPCONN_RESULT_TIMEOUT_KEY, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        cbValue = sizeof(dwValue);
        dwErr = RegQueryValueEx(
                    hkey,
                    LDAPCONN_RESULT_TIMEOUT_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);
        if ((dwErr == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwValue > 0))
            m_ldaptimeout.tv_sec = dwValue;

        cbValue = sizeof(dwValue);
        dwErr = RegQueryValueEx(
                    hkey,
                    LDAP_REQUEST_TIME_LIMIT_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);
        if ((dwErr == ERROR_SUCCESS) && (dwType == REG_DWORD) && (dwValue > 0))
            m_dwLdapRequestTimeLimit = dwValue;

        RegCloseKey( hkey );
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::Connect
//
//  Synopsis:   Establishes a connection to the LDAP host and, if a naming
//              context has not been established, asks the host for the
//              default naming context.
//
//  Arguments:  None
//
//  Returns:    TRUE if successfully connected, FALSE otherwise.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::Connect()
{
    CatFunctEnter( "CLdapConnection::Connect" );

    DWORD ldapErr = LDAP_SUCCESS;                // innocent until proven...
    LPSTR pszHost = (m_szHost[0] == '\0' ? NULL : m_szHost);

    if (m_pCPLDAPWrap == NULL) {

        DebugTrace(LDAP_CONN_DBG, "Connecting to [%s:%d]",
                   pszHost ? pszHost : "NULL",
                   m_dwPort);

        m_pCPLDAPWrap = new CPLDAPWrap( GetISMTPServerEx(), pszHost, m_dwPort);
        if(m_pCPLDAPWrap == NULL) {
            HRESULT hr = E_OUTOFMEMORY;
            ERROR_LOG("new CPLDAPWrap");
        }

        if((m_pCPLDAPWrap != NULL) &&
           (m_pCPLDAPWrap->GetPLDAP() == NULL)) {
            //
            // Failure to connect; release
            //
            m_pCPLDAPWrap->Release();
            m_pCPLDAPWrap = NULL;
        }


        DebugTrace(LDAP_CONN_DBG, "ldap_open returned 0x%x", m_pCPLDAPWrap);

        if (m_pCPLDAPWrap != NULL) {

            INCREMENT_LDAP_COUNTER(Connections);
            INCREMENT_LDAP_COUNTER(OpenConnections);
            //
            // First, set some options - no autoreconnect, and no chasing of
            // referrals
            //

            ULONG ulLdapOff = (ULONG)((ULONG_PTR)LDAP_OPT_OFF);
            ULONG ulLdapRequestTimeLimit = m_dwLdapRequestTimeLimit;
            ULONG ulLdapVersion = LDAP_VERSION3;

            ldap_set_option(
                GetPLDAP(), LDAP_OPT_REFERRALS, (LPVOID) &ulLdapOff);

            ldap_set_option(
                GetPLDAP(), LDAP_OPT_AUTO_RECONNECT, (LPVOID) &ulLdapOff);

            ldap_set_option(
                GetPLDAP(), LDAP_OPT_TIMELIMIT, (LPVOID) &ulLdapRequestTimeLimit);

            ldap_set_option(
                GetPLDAP(), LDAP_OPT_PROTOCOL_VERSION, (LPVOID) &ulLdapVersion);

            ldapErr = BindToHost( GetPLDAP(), m_szAccount, m_szPassword);
            DebugTrace(LDAP_CONN_DBG, "BindToHost returned 0x%x", ldapErr);

        } else {
            INCREMENT_LDAP_COUNTER(ConnectFailures);
            ldapErr = LDAP_SERVER_DOWN;

        }
        //
        // Figure out the naming context for this connection if none was
        // initially specified and we are using the default LDAP_PORT
        // (a baseDN of "" is acceptable on other LDAP ports such as
        // a GC)
        //
        if ((m_dwPort == LDAP_PORT) &&
            (ldapErr == LDAP_SUCCESS) &&
            (m_szNamingContext[0] == 0)) {

            ldapErr = GetDefaultNamingContext();

            if (ldapErr != LDAP_SUCCESS)
                Disconnect();

        } // end if port 389, successful bind and no naming context

    } else { // end if we didn't have a connection already

        DebugTrace(
            LDAP_CONN_DBG,
            "Already connected to %s:%d, pldap = 0x%x",
            m_szHost, m_dwPort, GetPLDAP());

    }

    DebugTrace(LDAP_CONN_DBG, "Connect status = 0x%x", ldapErr);

    if (ldapErr != LDAP_SUCCESS) {

        m_fValid = FALSE;

        CatFunctLeave();

        return( LdapErrorToHr( ldapErr) );

    } else {

        CatFunctLeave();

        return( S_OK );

    }

}


//+------------------------------------------------------------
//
// Function: CLdapConnection::GetDefaultNamingContext
//
// Synopsis: Gets the default naming context from the LDAP server that
// we are connected to.  Note: this should only be called from
// Connect.  It is not gaurenteed to be multi-thread safe, and it may
// not work when there is an LdapCompletionThread for this connection.
//
// Arguments: None
//
// Returns:
//   LDAP_SUCCESS: fetched m_szNamingContext successfully
//   else, an LDAP error describing why we couldn't get a naming context
//
// History:
// jstamerj 2002/04/16 14:36:28: Created.
//
//-------------------------------------------------------------
ULONG CLdapConnection::GetDefaultNamingContext()
{
    ULONG ldapErr = LDAP_SUCCESS;
    PLDAPMessage pmsg = NULL;
    PLDAPMessage pentry = NULL;
    LPWSTR rgszAttributes[2] = { L"defaultNamingContext", NULL };
    LPWSTR *rgszValues = NULL;
    int i = 0;

    CatFunctEnterEx((LPARAM)this, "CLdapConnection::GetDefaultNamingContext");


    ldapErr = ldap_search_sW(
        GetPLDAP(),      // ldap binding
        L"",                 // base DN
        LDAP_SCOPE_BASE,     // scope of search
        L"(objectClass=*)",  // filter,
        rgszAttributes,      // attributes required
        FALSE,               // attributes-only is false
        &pmsg);

    DebugTrace(
        LDAP_CONN_DBG,
        "Search for namingContexts returned 0x%x",
        ldapErr);

    // If the search succeeded
    if ((ldapErr == LDAP_SUCCESS) &&
        // and there is at least one entry
        ((pentry = ldap_first_entry(GetPLDAP(), pmsg)) != NULL) &&
        // and there are values
        ((rgszValues = ldap_get_valuesW(GetPLDAP(), pentry,
                                       rgszAttributes[0])) != NULL) &&
        // and there is at least one value
        (ldap_count_valuesW(rgszValues) != 0) &&
        // and the length of that value is within limits
        (wcslen(rgszValues[0]) <
         sizeof(m_wszNamingContext)/sizeof(WCHAR)) &&
        // and the UTF8 conversion succeeds
        (WideCharToMultiByte(
            CP_UTF8,
            0,
            rgszValues[0],
            -1,
            m_szNamingContext,
            sizeof(m_szNamingContext),
            NULL,
            NULL) > 0))
    {

        //
        // Use the first value for our naming context.
        //
        wcscpy(m_wszNamingContext, rgszValues[0]);

        DebugTrace(
            LDAP_CONN_DBG,
            "NamingContext is [%s]",
            m_szNamingContext);

    } else {
        HRESULT hr = ldapErr; // Used by ERROR_LOG
        ERROR_LOG("ldap_search_sW");
        ldapErr = LDAP_OPERATIONS_ERROR;
    }

    if (rgszValues != NULL)
        ldap_value_freeW( rgszValues );

    if (pmsg != NULL)
        ldap_msgfree( pmsg );

    CatFunctLeaveEx((LPARAM)this);

    return ldapErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::Disconnect
//
//  Synopsis:   Disconnects from the ldap host
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::Disconnect()
{
    BOOL fValid;

    CatFunctEnter("CLdapConnection::Disconnect");

    if (m_pCPLDAPWrap != NULL) {

        SetTerminateIndicatorTrue();

        fValid = InterlockedExchange((PLONG) &m_fValid, FALSE);

        m_pCPLDAPWrap->Release();
        m_pCPLDAPWrap = NULL;

        if( fValid ) {
            DECREMENT_LDAP_COUNTER(OpenConnections);
        }

    }

    CatFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::Invalidate
//
//  Synopsis:   Marks this connection invalid. Once this is done, it will
//              return FALSE from all calls to IsEqual, thus effectively
//              removing itself from all searches for cached connections.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::Invalidate()
{
    BOOL fValid;

    fValid = InterlockedExchange((PLONG) &m_fValid, FALSE);

    if( fValid ) {
        DECREMENT_LDAP_COUNTER(OpenConnections);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::IsValid
//
//  Synopsis:   Returns whether the connection is valid or not.
//
//  Arguments:  None
//
//  Returns:    TRUE if valid, FALSE if a call to Invalidate has been made.
//
//-----------------------------------------------------------------------------

BOOL CLdapConnection::IsValid()
{
    return( m_fValid );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::BindToHost
//
//  Synopsis:   Creates a binding to the LDAP host using the given account
//              and password.
//
//  Arguments:  [pldap] -- The ldap connection to bind.
//              [szAccount] -- The account to use. Of the form "account-name"
//                  or "domain\account-name".
//              [szPassword] -- The password to use.
//
//  Returns:    LDAP result of bind.
//
//-----------------------------------------------------------------------------

DWORD CLdapConnection::BindToHost(
    PLDAP pldap,
    LPSTR szAccount,
    LPSTR szPassword)
{
    CatFunctEnter( "CLdapConnection::BindToHost" );

    DWORD ldapErr;
    char szDomain[ DNLEN + 1];
    LPSTR pszDomain, pszUser;
    HANDLE hToken;                               // LogonUser modifies hToken
    BOOL fLogon = FALSE;                         // even if it fails! So, we
                                                 // have to look at the result
                                                 // of LogonUser!

    //
    // If this connection was created with anonymous access rights, there is
    // no bind action to do.
    //
    if (m_bt == BIND_TYPE_NONE) {

        ldapErr = ERROR_SUCCESS;

        goto Cleanup;

    }

    //
    // If we are supposed to use simple bind, do it now
    //
    if (m_bt == BIND_TYPE_SIMPLE) {

        ldapErr = ldap_simple_bind_s(pldap,szAccount, szPassword);

        DebugTrace(0, "ldap_simple_bind returned 0x%x", ldapErr);

        if(ldapErr != LDAP_SUCCESS)
            LogLdapError(ldapErr, "ldap_simple_bind_s(pldap,\"%s\",szPassword), PLDAP = 0x%08lx", szAccount, pldap);

        goto Cleanup;

    }

    //
    // If we are supposed to logon with current credetials, do it now.
    //
    if (m_bt == BIND_TYPE_CURRENTUSER) {
        //-------------------------------------------------------------------
        // X5: TBD
        // This is the normal case for Exchange services.  We are connecting
        // as LocalSystem, so we must use Kerberos (this is true for the LDAP
        // server as of Win2000 SP1).
        // If we cannot bind as Kerberos, LDAP_AUTH_NEGOTIATE may negotiate
        // down to NTLM, at which point we become anonymous, and the bind
        // succeeds.  Anonymous binding is useless to Exchange, so we would
        // rather force Kerberos and fail if Kerberos has a problem.  Use a
        // SEC_WINNT_AUTH_IDENTITY_EX to specify that only Kerberos auth
        // should be tried.
        //-------------------------------------------------------------------
        SEC_WINNT_AUTH_IDENTITY_EX authstructex;
        ZeroMemory (&authstructex, sizeof(authstructex));

        authstructex.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        authstructex.Length = sizeof (authstructex);
        authstructex.PackageList = (PUCHAR) MICROSOFT_KERBEROS_NAME_A;
        authstructex.PackageListLength = strlen ((PCHAR) authstructex.PackageList);
        authstructex.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

        ldapErr = ldap_bind_s(pldap,
                              NULL,
                              (PCHAR) &authstructex,
                              LDAP_AUTH_NEGOTIATE);

        DebugTrace(0, "ldap_bind returned 0x%x", ldapErr);

        if(ldapErr != LDAP_SUCCESS)
            LogLdapError(ldapErr, "ldap_bind_s(pldap, NULL, &authstructex, LDAP_AUTH_NEGOTIATE), PLDAP = 0x%08lx", pldap);

        goto Cleanup;
    }
    //
    // Parse out the domain and user names from the szAccount parameter.
    //

    if ((pszUser = strchr(szAccount, '\\')) == NULL) {

        pszUser = szAccount;

        pszDomain = NULL;

    } else {

        ULONG cbDomain = (ULONG)(((ULONG_PTR) pszUser) - ((ULONG_PTR) szAccount));

        if(cbDomain < sizeof(szDomain)) {

            strncpy( szDomain, szAccount, cbDomain);
            szDomain[cbDomain] = '\0';

        } else {

            ldapErr = LDAP_INVALID_CREDENTIALS;
            goto Cleanup;
        }

        pszDomain = cbDomain > 0 ? szDomain : NULL;

        pszUser++;                               // Go past the backslash

    }

    //
    // Logon as the given user, impersonate, and attempt the LDAP bind.
    //
    fLogon = LogonUser(pszUser, pszDomain, szPassword, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &hToken);
    if(!fLogon) {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG("LogonUser");
    } else {
        fLogon = ImpersonateLoggedOnUser(hToken);
        if(!fLogon) {
            HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
            ERROR_LOG("ImpersonateLoggedOnUser");
        }
    }


    if (fLogon) {

        ldapErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_SSPI);

        DebugTrace(0, "ldap_bind returned 0x%x", ldapErr);

        if(ldapErr != LDAP_SUCCESS)
            LogLdapError(ldapErr, "ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_SSPI), PLDAP = 0x%08lx", pldap);

        RevertToSelf();

    } else {

        if (GetLastError() == ERROR_PRIVILEGE_NOT_HELD)
            ldapErr = LDAP_INSUFFICIENT_RIGHTS;
        else
            ldapErr = LDAP_INVALID_CREDENTIALS;

    }

Cleanup:

    if (fLogon)
        CloseHandle( hToken );

    //
    // Increment counters
    //
    if(m_bt != BIND_TYPE_NONE) {

        if(ldapErr == ERROR_SUCCESS) {

            INCREMENT_LDAP_COUNTER(Binds);

        } else {

            INCREMENT_LDAP_COUNTER(BindFailures);
        }
    }

    CatFunctLeave();

    return( ldapErr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::IsEqual
//
//  Synopsis:   Figures out if this connection represents a connection to the
//              given Host,NamingContext,Account, and Password parameters.
//
//  Arguments:  [szHost] -- The name of the LDAP host
//              [dwPort] -- The remote tcp port # of the LDAP connection
//              [szNamingContext] -- The naming context within the DS
//              [szAccount] -- The account used to bind to the LDAP DS.
//              [szPassword] -- The password used with szAccount.
//              [BindType] -- The bind type used to connect to host.
//
//  Returns:    TRUE if this connection represents the connection to the
//              given LDAP context, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOL CLdapConnection::IsEqual(
    LPSTR szHost,
    DWORD dwPort,
    LPSTR szNamingContext,
    LPSTR szAccount,
    LPSTR szPassword,
    LDAP_BIND_TYPE BindType)
{
    CatFunctEnter("CLdapConnection::IsEqual");

    BOOL fResult = FALSE;

    _ASSERT( szHost != NULL );
    _ASSERT( szAccount != NULL );
    _ASSERT( szPassword != NULL );

    if (!m_fValid)
        return( FALSE );


    DebugTrace(
        LDAP_CONN_DBG,
        "Comparing %s:%d;%s;%s",
        szHost, dwPort, szNamingContext, szAccount);

    DebugTrace(
        LDAP_CONN_DBG,
        "With %s:%d;%s;%s; Def NC = %s",
        m_szHost, m_dwPort, m_szNamingContext, m_szAccount,
        m_fDefaultNamingContext ? "TRUE" : "FALSE");

    //
    // See if the host/port match.
    //
    fResult = (BOOL) ((lstrcmpi( szHost, m_szHost) == 0) &&
                      fIsPortEqual(dwPort));

    //
    // If the host matches, see if the bind info matches.
    //
    if (fResult) {

        switch (BindType) {
        case BIND_TYPE_NONE:
        case BIND_TYPE_CURRENTUSER:
            fResult = (BindType == m_bt);
            break;

        case BIND_TYPE_SIMPLE:
        case BIND_TYPE_GENERIC:
            fResult = (BindType == m_bt) &&
                        (lstrcmpi(szAccount, m_szAccount) == 0) &&
                            (lstrcmpi(szPassword, m_szPassword) == 0);
            break;

        default:
            _ASSERT( FALSE && "Invalid Bind Type in CLdapConnection::IsEqual");
            break;
        }

    }

    if (fResult) {
        //
        // If caller specified a naming context, see if it matches. Otherwise,
        // see if we are using the Default Naming Context.
        //

        if (szNamingContext && szNamingContext[0] != 0)
            fResult = (lstrcmpi(szNamingContext, m_szNamingContext) == 0);
        else
            fResult = m_fDefaultNamingContext;

    }

    CatFunctLeave();

    return( fResult );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::Search
//
//  Synopsis:   Issues a synchronous search request. Returns the result as an
//              opaque pointer that can be passed to GetFirstEntry /
//              GetNextEntry
//
//  Arguments:  [szBaseDN] -- The DN of the container object within which to
//                  search.
//              [nScope] -- One of LDAP_SCOPE_BASE, LDAP_SCOPE_ONELEVEL, or
//                  LDAP_SCOPE_SUBTREE.
//              [szFilter] -- The search filter to use. If NULL, a default
//                  filter is used.
//              [rgszAttributes] -- The list of attributes to retrieve.
//              [ppResult] -- The result is passed back in here.
//
//  Returns:    TRUE if success, FALSE otherwise
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::Search(
    LPCSTR szBaseDN,
    int nScope,
    LPCSTR szFilter,
    LPCSTR *rgszAttributes,
    PLDAPRESULT *ppResult)
{
    //$$BUGBUG: Obsolete code
    CatFunctEnter("CLdapConnection::Search");

    DWORD ldapErr = LDAP_SUCCESS;
    LPCSTR szFilterToUse = szFilter != NULL ? szFilter : "(objectClass=*)";

    if (m_pCPLDAPWrap != NULL) {

        ldapErr = ldap_search_s(
                        GetPLDAP(),          // ldap binding
                        (LPSTR) szBaseDN,        // container DN to search
                        nScope,                  // Base, 1 or multi level
                        (LPSTR) szFilterToUse,   // search filter
                        (LPSTR *)rgszAttributes, // attributes to retrieve
                        FALSE,                   // attributes-only is false
                        (PLDAPMessage *) ppResult); // return result here

    } else {

        ldapErr = LDAP_UNAVAILABLE;

    }

    if (ldapErr != LDAP_SUCCESS) {

        CatFunctLeave();

        return( LdapErrorToHr( ldapErr) );

    } else {

        CatFunctLeave();

        return( S_OK );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::AsyncSearch
//
//  Synopsis:   Issues an asynchronous search request. Inserts a pending
//              request item into the m_pPendingHead queue, so that the
//              given completion routine may be called when the results are
//              available.
//
//              As a side effect, if this is the first time an async request
//              is being issued on this connection, a thread to handle search
//              completions is created.
//
//  Arguments:  [szBaseDN] -- The DN of the container object within which to
//                  search.
//              [nScope] -- One of LDAP_SCOPE_BASE, LDAP_SCOPE_ONELEVEL, or
//                  LDAP_SCOPE_SUBTREE.
//              [szFilter] -- The search filter to use. If NULL, a default
//                  filter is used.
//              [rgszAttributes] -- The list of attributes to retrieve.
//              [dwPageSize] -- The desired page size for results.  If
//                              zero, a non-paged ldap search is performed.
//              [fnCompletion] -- The LPLDAPCOMPLETION routine to call when
//                  results are available.
//              [ctxCompletion] -- The context to pass to fnCompletion.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully issued the search request.
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate working data strucs
//
//              Win32 Error from ldap_search() call if something went wrong.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::AsyncSearch(
    LPCWSTR szBaseDN,
    int nScope,
    LPCWSTR szFilter,
    LPCWSTR *rgszAttributes,
    DWORD dwPageSize,
    LPLDAPCOMPLETION fnCompletion,
    LPVOID ctxCompletion)
{
    CatFunctEnter("CLdapConnectio::AsyncSearch");

    HRESULT hr;
    DWORD dwLdapErr;
    PPENDING_REQUEST preq;
    ULONG msgid;
    //
    // First, see if we need to create the completion thread.
    //
    hr = CreateCompletionThreadIfNeeded();
    if(FAILED(hr)) {
        ERROR_LOG("CreateCompletionThreadIfNeeded");
        return hr;
    }

    //
    // Next, allocate a new PENDING_REQUEST record to represent this async
    // request.
    //

    preq = new PENDING_REQUEST;

    if (preq == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new PENIDNG_REQUEST");
        return( HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY) );
    }

    preq->fnCompletion = fnCompletion;
    preq->ctxCompletion = ctxCompletion;
    preq->dwPageSize = dwPageSize;

    //
    // Initialize msgid to -1 so it can't possibly match any valid msgid that
    // the completion thread might be looking for in the pending request list.
    //

    preq->msgid = -1;

    //
    //
    if(dwPageSize) {
        //
        // Init the paged search if that is what we will be doing
        //
        preq->pldap_search = ldap_search_init_pageW(
            GetPLDAP(),                     // LDAP connection to use
            (LPWSTR) szBaseDN,                  // Starting container DN
            nScope,                             // depth of search
            (LPWSTR) szFilter,                  // Search filter
            (LPWSTR *) rgszAttributes,          // Attributes array
            FALSE,                              // Attributes only?
            NULL,                               // Server controls
            NULL,                               // Client controls
            0,                                  // PageTimeLimit
            0,                                  // TotalSizeLimit
            NULL);                              // Sorting keys

        if(preq->pldap_search == NULL) {

            ULONG ulLdapErr = LdapGetLastError();
            LogLdapError(ulLdapErr, "ldap_search_init_pageW(GetPLDAP(), \"%S\", %d, \"%S\", rgszAttributes, ...), PLDAP = 0x%08lx",
                        szBaseDN, nScope, szFilter, GetPLDAP());

            dwLdapErr = LdapErrorToHr(ulLdapErr);
            ErrorTrace((LPARAM)this, "ldap_search_init_page failed with err %d (0x%x)", dwLdapErr, dwLdapErr);
            delete preq;
            //$$BUGBUG: We call LdapErrorToHr twice?
            return ( LdapErrorToHr(dwLdapErr));
        }

    } else {

        preq->pldap_search = NULL; // Not doing a paged search
    }
    //
    // We might want to abandon all of our outstanding requests at
    // some point.  Because of this, we use this sharelock to prevent
    // abandoning requests with msgid still set to -1
    //
    m_ShareLock.ShareLock();

    //
    // Link the request into the queue of pending requests so that the
    // completion thread can pick it up when a result is available.
    //

    InsertPendingRequest( preq );

    if(dwPageSize) {
        //
        // Issue an async request for the next page of matches
        //
        dwLdapErr = ldap_get_next_page(
            GetPLDAP(),                     // LDAP connection to use
            preq->pldap_search,                 // LDAP page search context
            dwPageSize,                         // page size desired
            &msgid);
        if(dwLdapErr != LDAP_SUCCESS) {
            LogLdapError(dwLdapErr, "ldap_get_next_page(GetPLDAP(),preq->pldap_search,%d,&msgid), PDLAP = 0x%08lx",
                         dwPageSize, GetPLDAP());
        }

    } else {
        //
        // Now, attempt to issue the async search request.
        //
        dwLdapErr = ldap_search_extW(
            GetPLDAP(),          // LDAP connection to use
            (LPWSTR) szBaseDN,       // Starting container DN
            nScope,                  // depth of search
            (LPWSTR) szFilter,       // Search filter
            (LPWSTR *)rgszAttributes, // List of attributes to get
            FALSE,                   // Attributes only?
            NULL,                    // Server controls
            NULL,                    // Client controls
            0,                       // Time limit
            0,                       // Size limit
            &msgid);
        if(dwLdapErr != LDAP_SUCCESS) {
            LogLdapError(dwLdapErr, "ldap_search_extW(GetPLDAP(), \"%S\", %d, \"%S\", rgszAttributes, ...), PLDAP = 0x%08lx",
                         szBaseDN, nScope, szFilter, GetPLDAP());
        }
    }

    //
    // One last thing - ldap_search could fail, in which case we need to
    // remove the PENDING_REQUEST item we just inserted.
    //

    if (dwLdapErr != LDAP_SUCCESS) {             // ldap_search failed!

        DebugTrace((LPARAM)this, "DispError %d 0x%08lx conn %08lx", dwLdapErr, dwLdapErr, (PLDAP)(GetPLDAP()));

        RemovePendingRequest( preq );

        m_ShareLock.ShareUnlock();

        INCREMENT_LDAP_COUNTER(SearchFailures);

        if(preq->pldap_search) {

            INCREMENT_LDAP_COUNTER(PagedSearchFailures);
            //
            // Free the ldap page search context
            //
            ldap_search_abandon_page(
                GetPLDAP(),
                preq->pldap_search);
        }

        delete preq;

        return( LdapErrorToHr(dwLdapErr) );

    } else {

        preq->msgid = (int) msgid;

        INCREMENT_LDAP_COUNTER(Searches);
        INCREMENT_LDAP_COUNTER(PendingSearches);

        if(dwPageSize)
            INCREMENT_LDAP_COUNTER(PagedSearches);

        //
        // WARNING: preq could have been processed and free'd in the
        // completion routine at this point so it is not advisable to view
        // it!
        //
        DebugTrace((LPARAM)msgid, "Dispatched ldap search request %ld 0x%08lx conn %08lx", msgid, msgid, (PLDAP)(GetPLDAP()));

        m_ShareLock.ShareUnlock();

        ReleaseSemaphore( m_hOutstandingRequests, 1, NULL );
    }

    CatFunctLeave();

    return( S_OK );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::CancelAllSearches
//
//  Synopsis:   Cancels all pending requests to the LDAP server.
//
//  Arguments:  [hr] -- The error code to complete pending requests with.
//                  Defaults to HRESULT_FROM_WIN32(ERROR_CANCELLED)
//              [pISMTPServer] -- Interface on which to call StopHint after
//                  every cancelled search. Defaults to NULL, in which case no
//                  StopHint is called.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::CancelAllSearches(
    HRESULT hr,
    ISMTPServer *pISMTPServer)
{
    CatFunctEnter("CLdapConnection::CancelAllSearches");

    PLIST_ENTRY pli;
    PPENDING_REQUEST preq = NULL;
    LIST_ENTRY listCancel;

    //
    // We need to visit every node of m_listPendingRequests and call the
    // completion routine with the error. But, we want to call the
    // completion routine outside the critical section, so that calls to
    // AsyncSearch (from other threads or this thread!) won't block. So,
    // we simply transfer m_listPendingRequests to a temporary list under
    // the critical section, and then complete the temporary list outside
    // the critical section.
    //

    //
    // Transfer m_listPendingRequests to listCancel under the critical
    // section
    //

    InitializeListHead( &listCancel );

    //
    // We need exclusive access to the list (no half completed
    // searches are welcome), so get the exclusive lock
    //
    m_ShareLock.ExclusiveLock();

    AcquireSpinLock( &m_spinlockCompletion );

    //
    // swipe the contents of the pending request list
    //
    InsertTailList( &m_listPendingRequests, &listCancel);
    RemoveEntryList( &m_listPendingRequests );
    InitializeListHead( &m_listPendingRequests );

    //
    // Inform ProcessAyncResult that we've cancelled everything
    //
    NotifyCancel();

    ReleaseSpinLock( &m_spinlockCompletion );

    m_ShareLock.ExclusiveUnlock();

    //
    // Cancel all pending requests outside the critical section
    //

    for (pli = listCancel.Flink;
            pli != & listCancel;
                pli = listCancel.Flink) {

        preq = CONTAINING_RECORD(pli, PENDING_REQUEST, li);

        RemoveEntryList( &preq->li );

        ErrorTrace(0, "Calling ldap_abandon for msgid %ld",
                   preq->msgid);

        AbandonRequest(preq);

        CallCompletion(
            preq,
            NULL,
            hr,
            TRUE);

        if (pISMTPServer) {
            pISMTPServer->ServerStopHintFunction();
        }

        delete preq;

    }
    CatFunctLeave();
    return;

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::ProcessAsyncResult
//
//  Synopsis:   Routine that LdapCompletionThread calls to process any
//              results for async searches it receives.
//
//  Arguments:  [pres] -- The PLDAPMessage to process. This routine will free
//                      this result when its done with it.
//
//              [dwLdapError] -- The status of the received message.
//
//              [pfTerminateIndicator] -- Ptr to boolean that is set
//                                        to true when we want to
//                                        shutdown
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::ProcessAsyncResult(
    PLDAPMessage presIN,
    DWORD dwLdapError,
    BOOL *pfTerminateIndicator)
{
    CatFunctEnterEx((LPARAM)this, "CLdapConnection::ProcessAsyncResult");

    //
    // balanced by a release at the end of ProcessAsyncResult
    //

    int msgid;
    PLIST_ENTRY pli;
    PPENDING_REQUEST preq = NULL;
    LONG lOops = 0;     // It's possible we've recieved a result for a
                        // query that's was sent by ldap_search_ext
                        // currently in another thread and the msgid
                        // hasn't been stamped yet.  If this happens,
                        // we've consumed someone other request's
                        // semaphore count..keep track of these here
                        // and release them when we're done.
    BOOL fNoMsgID = FALSE;  // Set this to true if we see one or more
                            // messages with ID = -1

    BOOL fFinalCompletion = TRUE; // TRUE unless this is a partial
                                  // completion of a paged search
    BOOL fPagedSearch = FALSE;
    PLDAPMessage pres = presIN;
    CPLDAPWrap *pCLDAPWrap = NULL;
    ISMTPServerEx *pISMTPServerEx = GetISMTPServerEx();

    _ASSERT(m_pCPLDAPWrap);
    _ASSERT(pfTerminateIndicator);

    if( pISMTPServerEx )
        pISMTPServerEx->AddRef();

    pCLDAPWrap = m_pCPLDAPWrap;
    pCLDAPWrap->AddRef();

    //
    // If dwLdapError is LDAP_SERVER_DOWN, pres will be NULL and we simply
    // have to complete all outstanding requests with that error
    //
    if ((pres == NULL) || (dwLdapError == LDAP_SERVER_DOWN)) {

        _ASSERT(dwLdapError != 0);

        INCREMENT_LDAP_COUNTER(GeneralCompletionFailures);

        ErrorTrace(0, "Generic LDAP error %d 0x%08lx", dwLdapError, dwLdapError);

        CancelAllSearches( LdapErrorToHr( dwLdapError ) );

        goto CLEANUP;
    }

    //
    // We have a search specific result, find the search request and complete
    // it.
    //

    _ASSERT( pres != NULL );

    msgid = pres->lm_msgid;

    DebugTrace(msgid, "Processing message %d 0x%08lx conn %08lx", pres->lm_msgid, pres->lm_msgid, (PLDAP)(pCLDAPWrap->GetPLDAP()));


    while(preq == NULL) {
        //
        // Lookup the msgid in the list of pending requests.
        //

        AcquireSpinLock( &m_spinlockCompletion );

        // EnterCriticalSection( &m_cs );

        for (pli = m_listPendingRequests.Flink;
             pli != &m_listPendingRequests && preq == NULL;
             pli = pli->Flink) {

            PPENDING_REQUEST preqCandidate;

            preqCandidate = CONTAINING_RECORD(pli, PENDING_REQUEST, li);

            if (preqCandidate->msgid == msgid) {

                preq = preqCandidate;

                RemoveEntryList( &preq->li );

                //
                // Clear the cancel bit here so we'll know if Cancel
                // was recently requested later in this function
                //
                ClearCancel();

            } else if (preqCandidate->msgid == -1) {

                fNoMsgID = TRUE;

            }
        }

        ReleaseSpinLock( &m_spinlockCompletion );

        // LeaveCriticalSection( &m_cs );


        if (preq == NULL) {

            LPCSTR rgSubStrings[2];
            CHAR szMsgId[11];

            _snprintf(szMsgId, sizeof(szMsgId), "0x%08lx", msgid);
            rgSubStrings[0] = szMsgId;
            rgSubStrings[1] = m_szHost;


            if(!fNoMsgID) {

                ErrorTrace((LPARAM)this, "Couldn't find message ID %d in list of pending requests.  Ignoring it", msgid);
                //
                // If we don't find the message in our list of pending requests,
                // and we see no messages with ID == -1, it means
                // some other thread came in and cancelled the search before we could
                // process it. This is ok - just return.
                //
                CatLogEvent(
                    GetISMTPServerEx(),
                    CAT_EVENT_LDAP_UNEXPECTED_MSG,
                    2,
                    rgSubStrings,
                    S_OK,
                    szMsgId,
                    LOGEVENT_FLAG_ALWAYS,
                    LOGEVENT_LEVEL_FIELD_ENGINEERING);
                //
                // It is also possible wldap32 is giving us a msgid we
                // never dispatched.  We need to re-release the
                // semaphore count we consumed if this is the case
                //
                lOops++; // For the msgid we did not find
                goto CLEANUP;
            } else {
                //
                // So this(these) messages with id==-1 could possibly be
                // the one we're looking for.  If this is so, we just
                // consumed a semaphore count of a different request.
                // Block for our semaphore and keep track of the extra
                // semaphore counts we are consuming (lOops)
                //
                CatLogEvent(
                    GetISMTPServerEx(),
                    CAT_EVENT_LDAP_PREMATURE_MSG,
                    2,
                    rgSubStrings,
                    S_OK,
                    szMsgId,
                    LOGEVENT_FLAG_ALWAYS,
                    LOGEVENT_LEVEL_FIELD_ENGINEERING);

                lOops++;
                DebugTrace((LPARAM)this, "Couldn't find message ID %d in list of pending requests.  Waiting retry #%d", msgid, lOops);
                // Oops, we consumed a semaphore count not meant for us
                _VERIFY(WaitForSingleObject(m_hOutstandingRequests, INFINITE) ==
                        WAIT_OBJECT_0);
                if(*pfTerminateIndicator)
                    goto CLEANUP;
                // Try again to find our request
                fNoMsgID = FALSE;
            }
        }
    }

    _ASSERT(preq);

    INCREMENT_LDAP_COUNTER(SearchesCompleted);
    DECREMENT_LDAP_COUNTER(PendingSearches);

    //
    // Determine wether or not this is the final completion call (by
    // default fFinalCompletion is TRUE)
    //
    fPagedSearch = (preq->pldap_search != NULL);

    if(fPagedSearch) {

        INCREMENT_LDAP_COUNTER(PagedSearchesCompleted);

        if (dwLdapError == ERROR_SUCCESS) {

            ULONG ulTotalCount;

            //
            // The result is one page of the search.  Dispatch a request
            // for the next page
            //
            // First, call ldap_get_paged_count (required so wldap32 can
            // "save off the cookie that the server sent to resumt the
            // search")
            //
            dwLdapError = ldap_get_paged_count(
                pCLDAPWrap->GetPLDAP(),
                preq->pldap_search,
                &ulTotalCount,
                pres);
            if(dwLdapError == ERROR_SUCCESS) {
                //
                // Dispatch a search for the next page
                //
                dwLdapError = ldap_get_next_page(
                    pCLDAPWrap->GetPLDAP(),
                    preq->pldap_search,
                    preq->dwPageSize,
                    (PULONG) &(preq->msgid));

                if(dwLdapError == ERROR_SUCCESS) {
                    //
                    // Another request has been dispatched, so this was
                    // not the final search
                    //
                    INCREMENT_LDAP_COUNTER(Searches);
                    INCREMENT_LDAP_COUNTER(PagedSearches);
                    INCREMENT_LDAP_COUNTER(PendingSearches);

                    fFinalCompletion = FALSE;

                    ReleaseSemaphore( m_hOutstandingRequests, 1, NULL );

                } else if(dwLdapError == LDAP_NO_RESULTS_RETURNED) {
                    //
                    // We have the last page now. The paged search will be
                    // freed in cleanup code below.
                    //
                    DebugTrace(
                        (LPARAM)this,
                        "ldap_get_next_page returned LDAP_NO_RESULTS_RETURNED.  Paged search completed.");

                } else {

                    LogLdapError(dwLdapError, "ldap_get_next_page(GetPLDAP(),preq->pldap_search,%d,&(preq->msgid), PLDAP = 0x%08lx",
                                 preq->dwPageSize,
                                 pCLDAPWrap->GetPLDAP());
                    INCREMENT_LDAP_COUNTER(SearchFailures);
                    INCREMENT_LDAP_COUNTER(PagedSearchFailures);
                }
            } else {
                LogLdapError(dwLdapError, "ldap_get_paged_count, PLDAP = 0x%08lx",
                             pCLDAPWrap->GetPLDAP());

            }

        }
    }


    //
    // Call the completion routine of the Request.
    //
    if ( (dwLdapError == ERROR_SUCCESS)
        || ((dwLdapError == LDAP_NO_RESULTS_RETURNED) && fPagedSearch) ) {

        CallCompletion(
            preq,
            pres,
            S_OK,
            fFinalCompletion);
        //
        // CallCompletion will handle the freeing of pres
        //
        pres = NULL;

    } else {

        DebugTrace(0, "Search request %d completed with LDAP error 0x%x",
            msgid, dwLdapError);

        ErrorTrace(msgid, "ProcError %d 0x%08lx msgid %d 0x%08lx conn %08lx", dwLdapError, dwLdapError, pres->lm_msgid, pres->lm_msgid, (PLDAP)(pCLDAPWrap->GetPLDAP()));

        INCREMENT_LDAP_COUNTER(SearchCompletionFailures);
        if(preq->pldap_search != NULL)
            INCREMENT_LDAP_COUNTER(PagedSearchCompletionFailures);

        CallCompletion(
            preq,
            NULL,
            LdapErrorToHr( dwLdapError ),
            fFinalCompletion);
        //
        // CallCompletion will handle the freeing of pres
        // BUGBUG ??? No it won't; we passed in NULL, not pres. It has nothing to clean up,
        // so leave it at its present value so that cleanup code below can take a crack at it.
        //
//        pres = NULL;
        //
        // It is unsafe to touch CLdapConnection past here -- it may
        // be deleted (or waiting in the destructor)
        //
    }

    if (!fFinalCompletion) {
        //
        // If we were asked to cancel all searches between the time we
        // got the preq pointer out of the list and now, abandon the
        // pending search, and notify our caller we're cancelled
        //
        AcquireSpinLock(&m_spinlockCompletion);
        if(CancelOccured()) {

            ReleaseSpinLock(&m_spinlockCompletion);

            AbandonRequest(preq);

            CallCompletion(
                preq,
                NULL,
                HRESULT_FROM_WIN32(ERROR_CANCELLED),
                TRUE);

            delete preq;

        } else {
            //
            // we're doing another async wldap32 operation for the
            // next page.  Put preq back in the pending request list,
            // updating the tick count first
            //
            preq->dwTickCount = GetTickCount();

            InsertTailList(&m_listPendingRequests, &(preq->li));

            ReleaseSpinLock(&m_spinlockCompletion);
        }
    }

 CLEANUP:
    //
    // Release the extra semaphore counts we might have consumed
    //
    if((*pfTerminateIndicator == FALSE) && (lOops > 0)) {
        ReleaseSemaphore(m_hOutstandingRequests, lOops, NULL);
    }

    if(fFinalCompletion)
    {
        if (fPagedSearch) {
            //
            // Free the paged search
            //
            dwLdapError = ldap_search_abandon_page(
                pCLDAPWrap->GetPLDAP(),
                preq->pldap_search);
            if(dwLdapError != LDAP_SUCCESS)
            {
                ErrorTrace((LPARAM)this, "ldap_search_abandon_page failed %08lx", dwLdapError);
                //
                // Nothing we can do if we can't free the search
                //
                LogLdapError(
                    pISMTPServerEx,
                    dwLdapError,
                    "ldap_search_abandon_page, PLDAP = 0x%08lx",
                    pCLDAPWrap->GetPLDAP());
            }
        }

        delete preq;
    }
    if(pres) {
        FreeResult(pres);
    }
    if(pCLDAPWrap)
        pCLDAPWrap->Release();

    if(pISMTPServerEx)
        pISMTPServerEx->Release();

    CatFunctLeaveEx((LPARAM)this);
}

//+----------------------------------------------------------------------------
//
//  Function:   LdapCompletionThread
//
//  Synopsis:   Friend function of CLdapConnection that handles results
//              received for requests sent via CLdapConnection::AsyncSearch.
//
//  Arguments:  [ctx] -- Opaque pointer to the CLdapConnection instance which
//                  we will service.
//
//  Returns:    Always ERROR_SUCCESS.
//
//-----------------------------------------------------------------------------

DWORD WINAPI LdapCompletionThread(
    LPVOID ctx)
{
    CatFunctEnterEx((LPARAM)ctx, "LdapCompletionThread");

    CLdapConnection *pConn = (CLdapConnection *) ctx;
    int nResultCode = LDAP_RES_SEARCH_RESULT;
    DWORD dwError;
    PLDAPMessage pres;
    BOOL fTerminate = FALSE;

    //
    // Make sure we have a friend CLdapConnection object!
    //

    _ASSERT( pConn != NULL );

    //
    // Tell our friend to set fTerminate to true when it wants us to return.
    //

    pConn->SetTerminateCompletionThreadIndicator( &fTerminate );

    //
    // Sit in a loop waiting on results for AsyncSearch requests issued by
    // our pConn friend. Do so until our pConn friend terminates the
    // LDAP connection we are servicing.
    //
    do {

        pConn->CancelExpiredSearches(
            pConn->LdapErrorToHr( LDAP_TIMELIMIT_EXCEEDED ));

        dwError = WaitForSingleObject(
            pConn->m_hOutstandingRequests, INFINITE );

        if (dwError != WAIT_OBJECT_0 || fTerminate)
            break;

        DebugTrace((LPARAM)pConn, "Calling ldap_result now");

        nResultCode = ldap_result(
            pConn->GetPLDAP(),                 // LDAP connection to use
            (ULONG) LDAP_RES_ANY,              // Search msgid
            LDAP_MSG_ALL,                      // Get all results
            &(CLdapConnection::m_ldaptimeout), // Timeout
            &pres);

        if (fTerminate)
            break;

        if (nResultCode != 0) {
            //
            // We are supposed to call ldap_result2error to find out what the
            // result specific error code is.
            //

            dwError = ldap_result2error( pConn->GetPLDAP(), pres, FALSE );

            if ((dwError == LDAP_SUCCESS) ||
                (dwError == LDAP_RES_SEARCH_RESULT) ||
                (dwError == LDAP_REFERRAL_V2)) {
                //
                // Good, we have a search result. Tell our friend pConn to handle
                // it.
                //
                pConn->ProcessAsyncResult( pres, ERROR_SUCCESS, &fTerminate);

            } else {


                if (pres != NULL) {

                    pConn->LogLdapError(dwError, "ldap_result2error, PLDAP = 0x%08lx, msgid = %d",
                                        pConn->GetPLDAP(), pres->lm_msgid);

                    ErrorTrace(
                        (LPARAM)pConn,
                        "LdapCompletionThread - error from ldap_result() for non NULL pres -  0x%x (%d)",
                        dwError, dwError);

                    pConn->ProcessAsyncResult( pres, dwError, &fTerminate);

                } else {

                    pConn->LogLdapError(dwError, "ldap_result2error, PLDAP = 0x%08lx, pres = NULL",
                                 pConn->GetPLDAP());

                    ErrorTrace(
                        (LPARAM)pConn,
                        "LdapCompletionThread - generic error from ldap_result() 0x%x (%d)",
                        dwError, dwError);
                    ErrorTrace(
                        (LPARAM)pConn,
                        "nResultCode = %d", nResultCode);

                    dwError = LDAP_SERVER_DOWN;

                    pConn->ProcessAsyncResult( NULL, dwError, &fTerminate);

                }

            }

        } else {

            pConn->LogLdapError(nResultCode, "ldap_result (timeout), PLDAP = 0x%08lx",
                                pConn->GetPLDAP());

            pConn->ProcessAsyncResult( NULL, LDAP_SERVER_DOWN, &fTerminate);
        }

    } while ( !fTerminate );

    CatFunctLeaveEx((LPARAM)pConn);
    return( 0 );

}


//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::CancelExpiredSearches
//
//  Synopsis:   Cancels searches in the pending request queue that have msgids
//              other than -1 that have been there for more than
//              m_dwLdapRequestTimeLimit seconds. Completions are called
//              on each of these pending requests with hr as the failure code.
//
//  Arguments:  [hr] -- completion status code.
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::CancelExpiredSearches(HRESULT hr)
{
    PLIST_ENTRY ple;
    PPENDING_REQUEST preq;
    BOOL fDone = FALSE;
    DWORD dwTickCount;
    LPCSTR rgSubStrings[2];
    CHAR szMsgId[11];


    //
    // check for expired pending requests. We will start at the head of the
    // pending request queue because the ones at the front are the oldest.
    // We will ignore all pending requests that have a msgid of -1, because
    // they may be removed from the list in AsyncSearch if the search issue
    // failed, in which case we don't want to remove the pending request here.
    //
    dwTickCount = GetTickCount();

    while (!fDone) {

        AcquireSpinLock(&m_spinlockCompletion);

        ple = m_listPendingRequests.Flink;

        if (ple == &m_listPendingRequests) {
            //
            // no pending requests
            //
            preq = NULL;

        } else {

            preq = CONTAINING_RECORD(ple, PENDING_REQUEST, li);

            if ((preq->msgid != -1) &&
                (dwTickCount - preq->dwTickCount > m_dwLdapRequestTimeLimit * 1000)) {
                //
                // this request has expired
                //
                RemoveEntryList( &preq->li );

            } else {
                //
                // request has not expired or has msgid == -1
                //
                preq = NULL;

            }

        }

        ReleaseSpinLock(&m_spinlockCompletion);

        if (preq) {

            _snprintf(szMsgId, sizeof(szMsgId), "0x%08lx", preq->msgid);
            rgSubStrings[0] = szMsgId;
            rgSubStrings[1] = m_szHost;

            CatLogEvent(
                GetISMTPServerEx(),
                CAT_EVENT_LDAP_CAT_TIME_LIMIT,
                2,
                rgSubStrings,
                S_OK,
                szMsgId,
                LOGEVENT_FLAG_ALWAYS,
                LOGEVENT_LEVEL_FIELD_ENGINEERING);

            //
            // we have an expired request that has been removed from the queue
            //
            AbandonRequest(preq);

            CallCompletion(
                preq,
                NULL,
                hr,
                TRUE);

            delete preq;

            //
            // We need to down the semaphore count since it was upped in AsyncSearch.
            // It is possible that the semaphore hasn't been upped yet due to timing,
            // but the thread that queued the request is about to up the semaphore,
            // so we have to wait for it. This should be *extremely* rare, as
            // the thread issuing the request would have to go unscheduled for the
            // entire duration of the request time limit (m_dwLdapRequestTimeLimit).
            //
            _VERIFY(WaitForSingleObject(m_hOutstandingRequests, INFINITE) ==
                WAIT_OBJECT_0);

        } else {

            fDone = TRUE;

        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::GetFirstEntry
//
//  Synopsis:   Retrieves the first entry from a search result. The result is
//              returned as a pointer to an opaque type; all one can do is
//              query the attribute-values of the entry using
//              GetAttributeValues
//
//  Arguments:  [pResult] -- The result set returned by Search.
//              [ppEntry] -- On successful return, pointer to first entry in
//                  result is returned here.
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::GetFirstEntry(
    PLDAPRESULT pResult,
    PLDAPENTRY *ppEntry)
{
    CatFunctEnter("CLdapConnection::GetFirstEntry");

    PLDAPMessage pres = (PLDAPMessage) pResult;

    _ASSERT( m_pCPLDAPWrap != NULL );
    _ASSERT( pResult != NULL );
    _ASSERT( ppEntry != NULL );

    *ppEntry = (PLDAPENTRY) ldap_first_entry(GetPLDAP(), pres);

    if (*ppEntry == NULL) {

        DebugTrace(0, "GetFirstEntry failed!");

        CatFunctLeave();

        return( HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) );

    } else {

        CatFunctLeave();

        return( S_OK );
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::GetNextEntry
//
//  Synopsis:   Retrieves the next entry from a result set.
//
//  Arguments:  [pLastEntry] -- The last entry returned.
//              [ppEntry] -- The next entry in the result set.
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::GetNextEntry(
    PLDAPENTRY pLastEntry,
    PLDAPENTRY *ppEntry)
{
    CatFunctEnter("CLdapConnection::GetNextEntry");

    PLDAPMessage plastentry = (PLDAPMessage) pLastEntry;

    _ASSERT( m_pCPLDAPWrap != NULL );
    _ASSERT( pLastEntry != NULL );
    _ASSERT( ppEntry != NULL );

    *ppEntry = (PLDAPENTRY) ldap_next_entry( GetPLDAP(), plastentry );

    if (*ppEntry == NULL) {

        CatFunctLeave();

        return( HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) );

    } else {

        CatFunctLeave();

        return( S_OK );
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::GetAttributeValues
//
//  Synopsis:   Retrieves the values of a specified attribute of the given
//              entry.
//
//  Arguments:  [pEntry] -- The entry whose attribute value is desired.
//              [szAttribute] -- The attribute whose value is desired.
//              [prgszValues] -- On return, contains pointer to array of
//                  string values
//
//  Returns:    TRUE if successful, FALSE otherwise
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::GetAttributeValues(
    PLDAPENTRY pEntry,
    LPCSTR szAttribute,
    LPSTR *prgszValues[])
{
    CatFunctEnter("CLdapConnection::GetAttributeValues");

    _ASSERT(m_pCPLDAPWrap != NULL);
    _ASSERT(pEntry != NULL);
    _ASSERT(szAttribute != NULL);
    _ASSERT(prgszValues != NULL);

    *prgszValues = ldap_get_values(
        GetPLDAP(),
        (PLDAPMessage) pEntry,
        (LPSTR) szAttribute);

    if ((*prgszValues) == NULL) {

        CatFunctLeave();

        return( HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) );

    } else {

        CatFunctLeave();

        return( S_OK );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::FreeResult
//
//  Synopsis:   Frees a search result and all its entries.
//
//  Arguments:  [pResult] -- Result retrieved via Search.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::FreeResult(
    PLDAPRESULT pResult)
{
    CatFunctEnter("CLdapConnection::FreeResult");

    _ASSERT( pResult != NULL );

    ldap_msgfree( (PLDAPMessage) pResult );

    CatFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::FreeValues
//
//  Synopsis:   Frees the attribute values retrieved from GetAttributeValues
//
//  Arguments:  [rgszValues] -- The array of values to free.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::FreeValues(
    LPSTR rgszValues[])
{
    CatFunctEnter("CLdapConnection::FreeValues");

    _ASSERT( rgszValues != NULL );

    ldap_value_free( rgszValues );

    CatFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::ModifyAttributes
//
//  Synopsis:   Adds, deletes, or modifies attributes on a DS object.
//
//  Arguments:  [nOperation] -- One of LDAP_MOD_ADD, LDAP_MOD_DELETE, or
//                  LDAP_MOD_REPLACE.
//              [szDN] -- DN of the DS object.
//              [rgszAttributes] -- The list of attributes
//              [rgrgszValues] -- The list of values associated with each
//                  attribute. rgrgszValues[0] points to an array of values
//                  associated with rgszAttribute[0]; rgrgszValues[1] points
//                  to an array of values associated with rgszAttribute[1];
//                  and so on.
//
//  Returns:    TRUE if success, FALSE otherwise.
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::ModifyAttributes(
    int   nOperation,
    LPCSTR szDN,
    LPCSTR *rgszAttributes,
    LPCSTR *rgrgszValues[])
{
    //$$BUGBUG: Legacy code
    CatFunctEnter("CLdapConnection::ModifyAttributes");

    int i, cAttr;
    PLDAPMod *prgMods = NULL, rgMods;
    DWORD ldapErr;

    _ASSERT( m_pCPLDAPWrap != NULL );
    _ASSERT( nOperation == LDAP_MOD_ADD ||
                nOperation == LDAP_MOD_DELETE ||
                    nOperation == LDAP_MOD_REPLACE );
    _ASSERT( szDN != NULL );
    _ASSERT( rgszAttributes != NULL );
    _ASSERT( rgrgszValues != NULL || nOperation == LDAP_MOD_DELETE );

    for (cAttr = 0; rgszAttributes[ cAttr ] != NULL; cAttr++) {

        // NOTHING TO DO.

    }

    //
    // Below, we allocate a single chunk of memory that contains an array
    // of pointers to LDAPMod structures. Immediately following that array is
    // the space for the LDAPMod structures themselves.
    //

    prgMods = (PLDAPMod *) new BYTE[ (cAttr+1) *
                                     (sizeof(PLDAPMod) + sizeof(LDAPMod)) ];

    if (prgMods != NULL) {

        rgMods = (PLDAPMod) &prgMods[cAttr+1];

        for (i = 0; i < cAttr; i++) {

            rgMods[i].mod_op = nOperation;
            rgMods[i].mod_type = (LPSTR) rgszAttributes[i];

            if (rgrgszValues != NULL) {
                rgMods[i].mod_vals.modv_strvals = (LPSTR *)rgrgszValues[i];
            } else {
                rgMods[i].mod_vals.modv_strvals = NULL;
            }

            prgMods[i] = &rgMods[i];

        }

        prgMods[i] = NULL;                       // Null terminate the array

        ldapErr = ldap_modify_s( GetPLDAP(), (LPSTR) szDN, prgMods );

        delete [] prgMods;

    } else {

        ldapErr = LDAP_NO_MEMORY;

    }

    if (ldapErr != LDAP_SUCCESS) {

        DebugTrace(LDAP_CONN_DBG, "Status = 0x%x", ldapErr);

        CatFunctLeave();

        return( LdapErrorToHr( ldapErr) );

    } else {

        CatFunctLeave();

        return( S_OK );

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::LdapErrorToWin32
//
//  Synopsis:   Converts LDAP errors to Win32
//
//  Arguments:  [dwLdapError] -- The LDAP error to convert
//
//  Returns:    Equivalent Win32 error
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::LdapErrorToHr(
    DWORD dwLdapError)
{
    DWORD dwErr;

    CatFunctEnter("LdapErrorToWin32");

    switch (dwLdapError) {
    case LDAP_SUCCESS:
        dwErr = NO_ERROR;
        break;
    case LDAP_OPERATIONS_ERROR:
    case LDAP_PROTOCOL_ERROR:
        dwErr = CAT_E_DBFAIL;
        break;
    case LDAP_TIMELIMIT_EXCEEDED:
        dwErr = ERROR_TIMEOUT;
        break;
    case LDAP_SIZELIMIT_EXCEEDED:
        dwErr = ERROR_DISK_FULL;
        break;
    case LDAP_AUTH_METHOD_NOT_SUPPORTED:
        dwErr = ERROR_NOT_SUPPORTED;
        break;
    case LDAP_STRONG_AUTH_REQUIRED:
        dwErr = ERROR_ACCESS_DENIED;
        break;
    case LDAP_ADMIN_LIMIT_EXCEEDED:
        dwErr = CAT_E_DBFAIL;
        break;
    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
        dwErr = ERROR_FILE_EXISTS;
        break;
    case LDAP_NO_SUCH_OBJECT:
        dwErr = ERROR_FILE_NOT_FOUND;
        break;
    case LDAP_INAPPROPRIATE_AUTH:
        dwErr = ERROR_ACCESS_DENIED;
        break;
    case LDAP_INVALID_CREDENTIALS:
        dwErr = ERROR_LOGON_FAILURE;
        break;
    case LDAP_INSUFFICIENT_RIGHTS:
        dwErr = ERROR_ACCESS_DENIED;
        break;
    case LDAP_BUSY:
        dwErr = ERROR_BUSY;
        break;
    case LDAP_UNAVAILABLE:
        dwErr = CAT_E_DBCONNECTION;
        break;
    case LDAP_UNWILLING_TO_PERFORM:
        dwErr = CAT_E_TRANX_FAILED;
        break;
    case LDAP_ALREADY_EXISTS:
        dwErr = ERROR_FILE_EXISTS;
        break;
    case LDAP_OTHER:
        dwErr = CAT_E_TRANX_FAILED;
        break;
    case LDAP_SERVER_DOWN:
        dwErr = CAT_E_DBCONNECTION;
        break;
    case LDAP_LOCAL_ERROR:
        dwErr = CAT_E_TRANX_FAILED;
        break;
    case LDAP_NO_MEMORY:
        dwErr = ERROR_OUTOFMEMORY;
        break;
    case LDAP_TIMEOUT:
        dwErr = ERROR_TIMEOUT;
        break;
    case LDAP_CONNECT_ERROR:
        dwErr = CAT_E_DBCONNECTION;
        break;
    case LDAP_NOT_SUPPORTED:
        dwErr = ERROR_NOT_SUPPORTED;
        break;
    default:
        DebugTrace(
            0,
            "LdapErrorToWin32: No equivalent for ldap error 0x%x",
            dwLdapError);
        dwErr = dwLdapError;
        break;
    }

    DebugTrace(
        LDAP_CONN_DBG,
        "LdapErrorToWin32: Ldap Error 0x%x == Win32 error %d (0x%x) == HResult %d (0x%x)",
        dwLdapError, dwErr, dwErr, HRESULT_FROM_WIN32(dwErr), HRESULT_FROM_WIN32(dwErr));

    CatFunctLeave();

    return( HRESULT_FROM_WIN32(dwErr) );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::CreateCompletionThreadIfNeeded
//
//  Synopsis:   Helper function to create a completion thread that will
//              watch for results of async ldap searches.
//
//  Arguments:  None
//
//  Returns:    TRUE if success, FALSE otherwise
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnection::CreateCompletionThreadIfNeeded()
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    CatFunctEnterEx((LPARAM)this, "CLdapConnection::CreateCompletionThreadIfNeeded");
    //
    // Test to see if we already have a completion thread...
    //

    if (m_hCompletionThread != INVALID_HANDLE_VALUE) {
        hr = S_OK;
        goto CLEANUP;
    }

    //
    // Looks like we'll have to create a completion thread. Lets acquire
    // m_spinlockCompletion so only one of us tries to do this...
    //

    AcquireSpinLock( &m_spinlockCompletion );

    // EnterCriticalSection( &m_cs );
    fLocked = TRUE;

    //
    // Check one more time inside the lock - someone might have beaten us to
    // it.
    //
    if (m_hOutstandingRequests == INVALID_HANDLE_VALUE) {

        m_hOutstandingRequests = CreateSemaphore(NULL, 0, LONG_MAX, NULL);

        if (m_hOutstandingRequests == NULL) {
            m_hOutstandingRequests = INVALID_HANDLE_VALUE;
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERROR_LOG("CreateSemaphore");
            goto CLEANUP;
        }
    }

    if (m_hCompletionThread == INVALID_HANDLE_VALUE) {
        //
        // Create the completion thread
        //
        m_hCompletionThread =
            CreateThread(
                NULL,                // Security Attributes
                0,                   // Initial stack - default
                LdapCompletionThread,// Starting address
                (LPVOID) this,       // Param to LdapCompletionRtn
                0,                   // Create Flags
                &m_idCompletionThread);// Receives thread id

        if (m_hCompletionThread == NULL) {
            m_hCompletionThread = INVALID_HANDLE_VALUE;
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERROR_LOG("CreateThread");
            goto CLEANUP;
        }
    }

 CLEANUP:
    if(fLocked) {
        ReleaseSpinLock( &m_spinlockCompletion );
        // LeaveCriticalSection( &m_cs );
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::SetTerminateCompletionThreadIndicator
//
//  Synopsis:   Callback for our LdapCompletionThread to set a pointer to a
//              boolean that will be set to TRUE when the LdapCompletionThread
//              needs to terminate.
//
//  Arguments:  [pfTerminateCompletionThreadIndicator] -- Pointer to boolean
//              which will be set to true when the completion thread should
//              terminate.
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::SetTerminateCompletionThreadIndicator(
    BOOL *pfTerminateCompletionThreadIndicator)
{
    _ASSERT(pfTerminateCompletionThreadIndicator);

    InterlockedExchangePointer(
        (PVOID *) &m_pfTerminateCompletionThreadIndicator,
        (PVOID) pfTerminateCompletionThreadIndicator);

    if(m_fTerminating) {
        //
        // We may have decided to terminate before the
        // LdapCompletionThread had the chance to call this function.
        // If this is the case, we still need to set the thread's
        // terminate indicator to true.  We call
        // SetTerminateIndicatorTrue() to accomplish this.  It uses
        // interlocked functions to ensure that the terminate
        // indicator pointer is not set to true more than once.
        //
        SetTerminateIndicatorTrue();
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::InsertPendingRequest
//
//  Synopsis:   Inserts a new PENDING_REQUEST record in the m_pPendingHead
//              list so that the completion thread will find it when the
//              search result is available.
//
//  Arguments:  [preq] -- The PENDING_REQUEST record to insert.
//
//  Returns:    Nothing, this always succeeds.
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::InsertPendingRequest(
    PPENDING_REQUEST preq)
{
    AcquireSpinLock( &m_spinlockCompletion );

    preq->dwTickCount = GetTickCount();

    InsertTailList( &m_listPendingRequests, &preq->li );

    ReleaseSpinLock( &m_spinlockCompletion );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnection::RemovePendingRequest
//
//  Synopsis:   Removes a PENDING_REQUEST record from the
//              m_listPendingRequests list.
//
//  Arguments:  [preq] -- The PENDING_REQUEST record to remove
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnection::RemovePendingRequest(
    PPENDING_REQUEST preq)
{
    AcquireSpinLock( &m_spinlockCompletion );

    RemoveEntryList( &preq->li );

    ReleaseSpinLock( &m_spinlockCompletion );
}


//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::CLdapConnectionCache
//
//  Synopsis:   Constructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

#define MAX_HOST_CONNECTIONS        100
#define DEFAULT_HOST_CONNECTIONS    8

CLdapConnectionCache::CLdapConnectionCache(
    ISMTPServerEx *pISMTPServerEx)
{
    CatFunctEnter("CLdapConnectionCache::CLdapConnectionCache");

    m_cRef = 0;

    for (DWORD i = 0; i < LDAP_CONNECTION_CACHE_TABLE_SIZE; i++) {
        InitializeListHead( &m_rgCache[i] );
    }

    m_nNextConnectionSkipCount = 0;
    m_cMaxHostConnections = DEFAULT_HOST_CONNECTIONS;
    m_cCachedConnections = 0;
    ZeroMemory(&m_rgcCachedConnections, sizeof(m_rgcCachedConnections));
    m_pISMTPServerEx = pISMTPServerEx;
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->AddRef();

    InitializeFromRegistry();

    CatFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::InitializeFromRegistry
//
//  Synopsis:   Helper function that looks up parameters from the registry.
//              The only configurable parameter is
//              MAX_LDAP_CONNECTIONS_PER_HOST_KEY, which is read into
//              m_cMaxHostConnections.
//
//  Arguments:  None
//
//  Returns:    Nothing.
//
//-----------------------------------------------------------------------------

VOID CLdapConnectionCache::InitializeFromRegistry()
{
    HKEY hkey;
    DWORD dwErr, dwType, dwValue, cbValue;

    cbValue = sizeof(dwValue);

    dwErr = RegOpenKey(HKEY_LOCAL_MACHINE, MAX_LDAP_CONNECTIONS_PER_HOST_KEY, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        dwErr = RegQueryValueEx(
                    hkey,
                    MAX_LDAP_CONNECTIONS_PER_HOST_VALUE,
                    NULL,
                    &dwType,
                    (LPBYTE) &dwValue,
                    &cbValue);

        RegCloseKey( hkey );

    }

    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD &&
                dwValue > 0 && dwValue < MAX_HOST_CONNECTIONS) {

        InterlockedExchange((PLONG) &m_cMaxHostConnections, (LONG)dwValue);

    } else {

        InterlockedExchange(
            (PLONG) &m_cMaxHostConnections, (LONG) DEFAULT_HOST_CONNECTIONS);

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::~CLdapConnectionCache
//
//  Synopsis:   Destructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdapConnectionCache::~CLdapConnectionCache()
{
    CatFunctEnter("CLdapConnectionCache::~CLdapConnectionCache");

    unsigned short i;

    for (i = 0; i < LDAP_CONNECTION_CACHE_TABLE_SIZE; i++) {
        _ASSERT( IsListEmpty( &m_rgCache[i] ) );
    }

    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    CatFunctLeave();
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::AddRef
//
//  Synopsis:   Increment the refcount on this Connection Cache object.
//              Indicates that there is one more CEmailIDLdapStore object that
//              wants to avail of our services.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnectionCache::AddRef()
{
    InterlockedIncrement( &m_cRef );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::Release
//
//  Synopsis:   Decrements the refcount on this connection cache object.
//              Indicates that there is one less CEmailIDLdapStore object that
//              wants to use our services.
//
//              If the refcount drops to 0, all outstanding LDAP connections
//              are destroyed!
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID CLdapConnectionCache::Release()
{
    unsigned short i;
    CCachedLdapConnection *pcc;
    LIST_ENTRY *pli;

    _ASSERT( m_cRef > 0 );

    if (InterlockedDecrement( &m_cRef ) == 0) {

        for (i = 0; i < LDAP_CONNECTION_CACHE_TABLE_SIZE; i++) {

            m_rgListLocks[i].ExclusiveLock();

            for (pli = m_rgCache[i].Flink;
                    pli != &m_rgCache[i];
                        pli = m_rgCache[i].Flink) {

                pcc = CONTAINING_RECORD(pli, CCachedLdapConnection, li);

                RemoveEntryList( &pcc->li );
                //
                // Initialize li just in case someone attempts another
                // removal
                //
                InitializeListHead( &pcc->li );

                pcc->Disconnect();

                pcc->ReleaseAndWaitForDestruction();

            }
            m_rgListLocks[i].ExclusiveUnlock();
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::GetConnection
//
//  Synopsis:   Gets a connection to a given LDAP host
//
//  Arguments:  [szNamingContext] -- The container within the DS. Could be
//                  null to indicate root of the DS.
//              [szHost] -- the LDAP Host
//              [dwPort] -- the remote LDAP tcp port (if zero, LDAP_PORT is assumed)
//              [szAccount] -- The account to be used to log in
//              [szPassword] -- The password to be used to log in
//              [bt] -- The bind method to use to log in
//              [pCreateContext] -- a pointer to pass to
//                                  CreateCachedLdapConnection when
//                                  we need to create a new connection.
//
//  Returns:    Pointer to Connected LDAP connection or NULL
//
//-----------------------------------------------------------------------------

HRESULT CLdapConnectionCache::GetConnection(
    CLdapConnection **ppConn,
    LPSTR szHost,
    DWORD dwPort,
    LPSTR szNamingContext,
    LPSTR szAccount,
    LPSTR szPassword,
    LDAP_BIND_TYPE bt,
    PVOID pCreateContext)
{
    CatFunctEnter("CLdapConnectionCache::GetConnection");

    LPSTR szConnectionName = szHost;
    unsigned short n;
    LIST_ENTRY *pli;
    CCachedLdapConnection *pcc;
    LONG nSkipCount, nTargetSkipCount;
    HRESULT hr = S_OK;

    _ASSERT( szHost != NULL );
    _ASSERT( szAccount != NULL );
    _ASSERT( szPassword != NULL );

    //
    // See if we have a cached connection already.
    //

    n = Hash( szConnectionName );

    m_rgListLocks[n].ShareLock();

    nTargetSkipCount = m_nNextConnectionSkipCount % m_cMaxHostConnections;

    for (nSkipCount = 0, pcc= NULL, pli = m_rgCache[n].Flink;
            pli != &m_rgCache[n];
                pli = pli->Flink) {

         pcc = CONTAINING_RECORD(pli, CCachedLdapConnection, li);

         if (pcc->IsEqual(szHost, dwPort, szNamingContext, szAccount, szPassword, bt)
                && ((nSkipCount++ == nTargetSkipCount)
                    || (pcc->GetRefCount() == 1)))
             break;
         else
             pcc = NULL;

    }

    if (pcc)
        pcc->AddRef(); // Add the caller's reference

    m_rgListLocks[n].ShareUnlock();

    DebugTrace( LDAP_CCACHE_DBG, "Cached connection is 0x%x", pcc);

    DebugTrace( LDAP_CCACHE_DBG,
        "nTargetSkipCount = %d, nSkipCount = %d",
        nTargetSkipCount, nSkipCount);

    //
    // If we don't have a cached connection, we need to create a new one.
    //

    if (pcc == NULL) {

        m_rgListLocks[n].ExclusiveLock();

        for (nSkipCount = 0, pcc = NULL, pli = m_rgCache[n].Flink;
                pli != &m_rgCache[n];
                    pli = pli->Flink) {

             pcc = CONTAINING_RECORD(pli, CCachedLdapConnection, li);

             if (pcc->IsEqual(szHost, dwPort, szNamingContext, szAccount, szPassword, bt)
                    && (++nSkipCount == m_cMaxHostConnections ||
                            pcc->GetRefCount() == 1))
                 break;
             else
                 pcc = NULL;

        }

        if (pcc) {

            pcc->AddRef(); // Add the caller's reference

        } else {

            pcc = CreateCachedLdapConnection(
                szHost, dwPort, szNamingContext,
                szAccount, szPassword, bt, pCreateContext);

            if (pcc != NULL) {

                hr = pcc->Connect();

                if (FAILED(hr)) {

                    ERROR_LOG("pcc->Connect");
                    ErrorTrace(LDAP_CCACHE_DBG, "Failed to connect 0x%x, hr = 0x%x", pcc, hr);
                    pcc->Release();

                    pcc = NULL;

                } else {

                    pcc->AddRef(); // Reference for the connection in
                                   // the cache
                    InsertTailList( &m_rgCache[n], &pcc->li );

                    m_cCachedConnections++;
                    m_rgcCachedConnections[n]++;

                }

            } else {

                hr = E_OUTOFMEMORY;
                ERROR_LOG("CreateCachedLdapConnection");

            }

        }

        m_rgListLocks[n].ExclusiveUnlock();

        DebugTrace(LDAP_CCACHE_DBG, "New connection is 0x%x", pcc);

    }

    //
    // If we are returning a connection, then bump up the skip count so we
    // round-robin through valid connections
    //

    if (pcc != NULL) {

        InterlockedIncrement( &m_nNextConnectionSkipCount );

    }

    //
    // Done.
    //

    *ppConn = pcc;
    CatFunctLeave();
    return( hr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::CancelAllConnectionSearches
//
//  Synopsis:   Walks through all connections and cancels any pending searches
//              on them.
//
//  Arguments:  [None]
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID CLdapConnectionCache::CancelAllConnectionSearches(
    ISMTPServer *pISMTPServer)
{
    CatFunctEnterEx((LPARAM)this, "CLdapConnectionCache::CancelAllConnectionSearches");

    PLIST_ENTRY pli;
    DWORD i;

    DWORD dwcArraySize = 0;
    DWORD dwcArrayElements = 0;
    CCachedLdapConnection **rgpcc = NULL;
    CCachedLdapConnection *pcc = NULL;

    for (i = 0; i < LDAP_CONNECTION_CACHE_TABLE_SIZE; i++) {

        m_rgListLocks[i].ExclusiveLock();
        //
        // Do we have enough space?  Realloc if necessary
        //
        if( ((DWORD) m_rgcCachedConnections[i]) > dwcArraySize) {

            dwcArraySize = m_rgcCachedConnections[i];
            //
            // Alloc array
            //
            rgpcc = (CCachedLdapConnection **)
                    alloca( dwcArraySize * sizeof(CCachedLdapConnection *));
        }

        for (pli = m_rgCache[i].Flink, dwcArrayElements = 0;
                pli != &m_rgCache[i];
                    pli = pli->Flink, dwcArrayElements++) {

            //
            // If this assert fires, it means m_rgcCachedConnections[n] is
            // somehow less than the number of connections in the list.
            //
            _ASSERT(dwcArrayElements < dwcArraySize);

            pcc = CONTAINING_RECORD(pli, CCachedLdapConnection, li);

            //
            // Grab the connection (copy and addref the conn ptr)
            //
            rgpcc[dwcArrayElements] = pcc;
            pcc->AddRef();
        }

        m_rgListLocks[i].ExclusiveUnlock();
        //
        // Cancel all searches outside the lock
        //
        for(DWORD dwCount = 0;
            dwCount < dwcArrayElements;
            dwCount++) {

            rgpcc[dwCount]->CancelAllSearches(
                HRESULT_FROM_WIN32(ERROR_CANCELLED),
                pISMTPServer);
            rgpcc[dwCount]->Release();
        }
    }
    CatFunctLeaveEx((LPARAM)this);
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapConnectionCache::Hash
//
//  Synopsis:   Computes a hash given a connection name. Here, we use a simple
//              xor of all the chars in the name.
//
//  Arguments:  [szConnectionName] -- Name to compute the hash of
//
//  Returns:    A value between 0 and LDAP_CONNECTION_CACHE_TABLE_SIZE-1,
//              inclusive.
//
//-----------------------------------------------------------------------------

unsigned short CLdapConnectionCache::Hash(
    LPSTR szConnectionName)
{
    CatFunctEnter("CLdapConnectionCache::Hash");

    int i;
    unsigned short n = 0;

    _ASSERT( szConnectionName != NULL );

    for (i = 0, n = szConnectionName[i];
            szConnectionName[i] != 0;
                n ^= szConnectionName[i], i++) {

        // NOTHING TO DO

    }

    CatFunctLeave();

    return( n & (LDAP_CONNECTION_CACHE_TABLE_SIZE-1));
}



//+------------------------------------------------------------
//
// Function: CLdapConnection::CallCompletion
//
// Synopsis: Create all the ICategorizerItemAttributes and call the
// completion routine
//
// Arguments:
//  preq: PENDING_REQUEST
//  pres: LdapMessage
//  hrStatus: Status of lookup
//  fFinalCompletion:
//    FALSE: This is a completion for
//           pending results; there will be another completion
//           called with more results
//    TRUE: This is the final completion call
//
// Returns: NOTHING; calls completion routine with any error
//
// History:
// jstamerj 1998/07/02 13:57:20: Created.
//
//-------------------------------------------------------------
VOID CLdapConnection::CallCompletion(
    PPENDING_REQUEST preq,
    PLDAPMessage pres,
    HRESULT hrStatus,
    BOOL fFinalCompletion)
{
    HRESULT hr = S_OK;
    ICategorizerItemAttributes **rgpIAttributes = NULL;
    BOOL fAllocatedArray = FALSE;
    int nEntries;
    PLDAPMessage pMessage;
    CLdapResultWrap *pResultWrap = NULL;

    CatFunctEnterEx((LPARAM)this, "CLdapConnection::CallCompletion");

    if(pres) {
        //
        // Wrap the result so that pres can be refcounted
        //
        nEntries = ldap_count_entries(GetPLDAP(), pres);

        pResultWrap = new CLdapResultWrap(GetISMTPServerEx(), m_pCPLDAPWrap, pres);

        if(pResultWrap == NULL) {
            hr = E_OUTOFMEMORY;
            ErrorTrace((LPARAM)this, "Out of memory Allocing CLdapResultWrap");
            ERROR_LOG("new CLdapResultWrap");
            goto CALLCOMPLETION;
        }
        //
        // AddRef here, release at the end of this function
        //
        pResultWrap->AddRef();

    } else {
        nEntries = 0;
    }

    if(nEntries > 0) {
        //
        // Allocate array for all these ICategorizerItemAttributes
        //
        rgpIAttributes = new ICategorizerItemAttributes * [nEntries];
        if(rgpIAttributes == NULL) {
            hr = E_OUTOFMEMORY;
            ErrorTrace((LPARAM)this, "Out of memory Allocing ICategorizerItemAttribute array failed");
            ERROR_LOG("new ICategorizerItemAttributes *[]");
            goto CALLCOMPLETION;
        }
        ZeroMemory(rgpIAttributes, nEntries * sizeof(ICategorizerItemAttributes *));

        //
        // Iterage through all the DS Objectes returned and create an
        // ICategorizerItemAttributes implementation for each of them
        //
        pMessage = ldap_first_entry(GetPLDAP(), pres);

        for(int nCount = 0; nCount < nEntries; nCount++) {
            _ASSERT(pMessage);
            rgpIAttributes[nCount] = new CICategorizerItemAttributesIMP(
                GetPLDAP(),
                pMessage,
                pResultWrap);
            if(rgpIAttributes[nCount] == NULL) {
                hr = E_OUTOFMEMORY;
                ErrorTrace((LPARAM)this, "Out of memory Allocing ICategorizerItemAttributesIMP class");
                ERROR_LOG("new CICategorizerItemAttributesIMP");
                goto CALLCOMPLETION;
            }
            rgpIAttributes[nCount]->AddRef();
            pMessage = ldap_next_entry(GetPLDAP(), pMessage);
        }
        // That should have been the last entry
        _ASSERT(pMessage == NULL);
    } else {
        //
        // nEntries is zero
        //
        rgpIAttributes = NULL;
    }

 CALLCOMPLETION:

    if(FAILED(hr)) {
        //
        // Something failed creating the above array
        // Call completion routine with error
        //
        preq->fnCompletion(
            preq->ctxCompletion,
            0,
            NULL,
            hr,
            fFinalCompletion);

    } else {
        //
        // Nothing failed in this function; call completion with
        // passed in hrStatus
        //
        preq->fnCompletion(
            preq->ctxCompletion,
            nEntries,
            rgpIAttributes,
            hrStatus,
            fFinalCompletion);
    }

    //
    // Clean up
    //
    if(rgpIAttributes) {
        for(int nCount = 0; nCount < nEntries; nCount++) {
            if(rgpIAttributes[nCount])
                rgpIAttributes[nCount]->Release();
        }
        delete rgpIAttributes;
    }

    if(pResultWrap != NULL) {

        pResultWrap->Release();

    } else if(pres) {
        //
        // We were unable to create pResultWrap, so we have to free
        // the LDAP result ourself (normally CLdapResultWrap free's
        // the ldap result when all references have been released)
        //
        FreeResult(pres);
    }
}


//+------------------------------------------------------------
//
// Function: CLdapConnection::Release
//
// Synopsis: Release a refcount to this object.  Delete this object
//           when the refcout hits zero
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/04/01 00:09:36: Created.
//
//-------------------------------------------------------------
DWORD CLdapConnection::Release()
{
    DWORD dwNewRefCount;

    dwNewRefCount = InterlockedDecrement((PLONG) &m_dwRefCount);
    if(dwNewRefCount == 0) {

        if(m_dwDestructionWaiters) {
            //
            // Threads are waiting on the destruction event, so let
            // the last thread to wakeup delete this object
            //
            _ASSERT(m_hShutdownEvent != INVALID_HANDLE_VALUE);
            _VERIFY(SetEvent(m_hShutdownEvent));

        } else {
            //
            // Nobody is waiting, so delete this object
            //
            FinalRelease();
        }
    }
    return dwNewRefCount;
} // CLdapConnection::Release


//+------------------------------------------------------------
//
// Function: CLdapConnection::ReleaseAndWaitForDestruction
//
// Synopsis: Release a refcount and block this thread until the object
//           is destroyed
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/04/01 00:12:13: Created.
//
//-------------------------------------------------------------
VOID CLdapConnection::ReleaseAndWaitForDestruction()
{
    DWORD dw;

    CatFunctEnterEx((LPARAM)this, "CLdapConnection::ReleaseAndWaitForDestruction");

    _ASSERT(m_hShutdownEvent != INVALID_HANDLE_VALUE);
    //
    // Increment the count of threads waiting for destruction
    //
    InterlockedIncrement((PLONG)&m_dwDestructionWaiters);

    //
    // Release our refcount; if the new refcount is zero, this object
    // will NOT be deleted; instead m_hShutdownEvent will be set
    //
    Release();

    //
    // Wait for all refcounts to be released
    //
    dw = WaitForSingleObject(
        m_hShutdownEvent,
        INFINITE);

    _ASSERT(WAIT_OBJECT_0 == dw);

    //
    // Decrement the number of threads waiting for termination; if we
    // are the last thread to leave here, we need to delete this
    // object
    //
    if( InterlockedDecrement((PLONG)&m_dwDestructionWaiters) == 0)
        FinalRelease();

    CatFunctLeaveEx((LPARAM)this);
} // CLdapConnection::ReleaseAndWaitForDestruction


//+------------------------------------------------------------
//
// Function: CLdapConnection::HrInitialize
//
// Synopsis: Initialize error prone members
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/04/01 00:17:56: Created.
//
//-------------------------------------------------------------
HRESULT CLdapConnection::HrInitialize()
{
    HRESULT hr = S_OK;
    CatFunctEnterEx((LPARAM)this, "CLdapConnection::HrInitialize");

    m_hShutdownEvent = CreateEvent(
        NULL,       // Security attributes
        TRUE,       // fManualReset
        FALSE,      // Initial state is NOT signaled
        NULL);      // No name

    if(NULL == m_hShutdownEvent) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG("CreateEvent");

        //
        // Remember that m_hShutdownEvent is invalid
        //
        m_hShutdownEvent = INVALID_HANDLE_VALUE;

        FatalTrace((LPARAM)this, "Error creating event hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapConnection::HrInitialize


//+------------------------------------------------------------
//
// Function: CLdapConnectionCache::CCachedLdapConnection::Release
//
// Synopsis: Override Release for the cached LDAP connection
//
// Arguments: NONE
//
// Returns: New refcount
//
// History:
// jstamerj 1999/04/01 00:30:55: Created.
//
//-------------------------------------------------------------
DWORD CLdapConnectionCache::CCachedLdapConnection::Release()
{
    DWORD dw;

    CatFunctEnterEx((LPARAM)this, "CLdapConnectionCache::CCachedLdapConnection::Release");

    dw = CLdapConnection::Release();
    if((dw == 1) && (!IsValid())) {
        //
        // The ldap connection cache is the only entity that has a
        // reference to this and this is invalid -- it should be
        // removed from the cache
        //
        m_pCache->RemoveFromCache(this);
    }

    CatFunctLeaveEx((LPARAM)this);
    return dw;
} // CLdapConnectionCache::CCachedLdapConnection::Release


//+------------------------------------------------------------
//
// Function: CLdapConnectionCache::RemoveFromCache
//
// Synopsis: Removes an LDAP connection object from the cache
//
// Arguments:
//  pConn: the connection to remove
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/04/01 00:38:43: Created.
//
//-------------------------------------------------------------
VOID CLdapConnectionCache::RemoveFromCache(
    CCachedLdapConnection *pConn)
{
    BOOL fRemoved = FALSE;
    CatFunctEnterEx((LPARAM)this, "CLdapConnectionCache::RemoveFromCache");
    DWORD dwHash = 0;

    DebugTrace((LPARAM)this, "pConn = %08lx", pConn);

    dwHash = Hash(pConn->SzHost());
    //
    // Before locking, check to see if the connection has already been removed
    //
    if(!IsListEmpty( &(pConn->li))) {

        m_rgListLocks[dwHash].ExclusiveLock();
        //
        // Check again in case the connection was removed from the
        // cache before we got the lock
        //
        if(!IsListEmpty( &(pConn->li))) {

            RemoveEntryList( &(pConn->li) );
            //
            // Initialize li just in case someone attempts another removal
            //
            InitializeListHead( &(pConn->li) );
            fRemoved = TRUE;
            m_cCachedConnections--;
            m_rgcCachedConnections[dwHash]--;

        }

        m_rgListLocks[dwHash].ExclusiveUnlock();

        if(fRemoved)
            pConn->Release();
    }
    CatFunctLeaveEx((LPARAM)this);
} // CLdapConnectionCache::RemoveFromCache


//+------------------------------------------------------------
//
// Function: CLdapConnection::AsyncSearch (UTF8)
//
// Synopsis: Same as AsyncSearch, accept this accepts a UTF8 search
//           filter.
//
// Arguments: See AsyncSearch
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/12/09 18:22:41: Created.
//
//-------------------------------------------------------------
HRESULT CLdapConnection::AsyncSearch(
    LPCWSTR szBaseDN,                    // objects matching specified
    int nScope,                          // criteria in the DS. The
    LPCSTR szFilterUTF8,                 // results are passed to
    LPCWSTR szAttributes[],              // fnCompletion when they
    DWORD dwPageSize,                    // Optinal page size
    LPLDAPCOMPLETION fnCompletion,       // become available.
    LPVOID ctxCompletion)
{

#define FILTER_STRING_CHOOSE_HEAP   (10 * 1024) // filter strings 10K or larger will go on the heap

    HRESULT hr = S_OK;
    LPWSTR wszFilter = NULL;
    int    cchFilter = 0;
    BOOL fUseHeapBuffer = FALSE;
    int    i = 0;
    CatFunctEnterEx((LPARAM)this, "CLdapConnection::AsyncSearch");
    //
    // Convert BaseDN and Filter to unicode (from UTF8)
    //
    // calculate lengths
    //
    cchFilter = MultiByteToWideChar(
        CP_UTF8,
        0,
        szFilterUTF8,
        -1,
        NULL,
        0);
    if(cchFilter == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG("MultiByteToWideChar - 0");
        goto CLEANUP;
    }
    //
    // allocate space
    //
    if(cchFilter * sizeof(WCHAR) < FILTER_STRING_CHOOSE_HEAP) {

        wszFilter = (LPWSTR) alloca(cchFilter * sizeof(WCHAR));

    } else {

        fUseHeapBuffer = TRUE;
        wszFilter = new WCHAR[cchFilter];

    }

    if(wszFilter == NULL) {
        //$$BUGBUG: alloca does not return NULL.  It throws exceptions on error
        // This will catch heap alloc failures though.
        hr = E_OUTOFMEMORY;
        ERROR_LOG("alloca");
        goto CLEANUP;
    }

    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        szFilterUTF8,
        -1,
        wszFilter,
        cchFilter);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG("MultiByteToWideChar - 1");
        goto CLEANUP;
    }
    //
    // Call unicode based AsyncSearch
    //
    hr = AsyncSearch(
        szBaseDN,
        nScope,
        wszFilter,
        szAttributes,
        dwPageSize,
        fnCompletion,
        ctxCompletion);
    if(FAILED(hr)) {
        ERROR_LOG("AsyncSearch");
    }

 CLEANUP:

    if(wszFilter && fUseHeapBuffer) {
        delete [] wszFilter;
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapConnection::AsyncSearch


//+------------------------------------------------------------
//
// Function: CLdapConnection::AsyncSearch
//
// Synopsis: same as above with UTF8 search filter and base DN
//
// Arguments: see above
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/12/09 20:50:53: Created.
//
//-------------------------------------------------------------
HRESULT CLdapConnection::AsyncSearch(
    LPCSTR szBaseDN,                     // objects matching specified
    int nScope,                          // criteria in the DS. The
    LPCSTR szFilterUTF8,                 // results are passed to
    LPCWSTR szAttributes[],              // fnCompletion when they
    DWORD dwPageSize,                    // Optinal page size
    LPLDAPCOMPLETION fnCompletion,       // become available.
    LPVOID ctxCompletion)
{
    HRESULT hr = S_OK;
    LPWSTR wszBaseDN = NULL;
    int    cchBaseDN = 0;
    int    i = 0;
    CatFunctEnterEx((LPARAM)this, "CLdapConnection::AsyncSearch");
    //
    // Convert BaseDN and Filter to unicode (from UTF8)
    //
    // calculate lengths
    //
    cchBaseDN = MultiByteToWideChar(
        CP_UTF8,
        0,
        szBaseDN,
        -1,
        NULL,
        0);
    if(cchBaseDN == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG("MultiByteToWideChar - 0");
        goto CLEANUP;
    }
    //
    // allocate space
    //
    wszBaseDN = (LPWSTR) alloca(cchBaseDN * sizeof(WCHAR));
    if(wszBaseDN == NULL) {
        //$$BUGBUG: alloca does not return NULL.  It throws exceptions on error.
        hr = E_OUTOFMEMORY;
        ERROR_LOG("alloca");
        goto CLEANUP;
    }

    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        szBaseDN,
        -1,
        wszBaseDN,
        cchBaseDN);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG("MultiByteToWideChar - 1");
        goto CLEANUP;
    }
    //
    // Call unicode based AsyncSearch
    //
    hr = AsyncSearch(
        wszBaseDN,
        nScope,
        szFilterUTF8,
        szAttributes,
        dwPageSize,
        fnCompletion,
        ctxCompletion);
    if(FAILED(hr)) {
        ERROR_LOG("AsyncSearch");
    }


 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CLdapConnection::AsyncSearch



//+------------------------------------------------------------
//
// Function: CLdapConnection::LogLdapError
//
// Synopsis: Logs an eventlog for a wldap32 error
//
// Arguments:
//  ulLdapErr: LDAP error to log
//  pszFormatString: _snprintf Format string for function name
//  ...: variable list of args for format string
//
// Returns: Nothing
//
// History:
// jstamerj 2001/12/12 20:45:09: Created.
//
//-------------------------------------------------------------
VOID CLdapConnection::LogLdapError(
    IN  ULONG ulLdapErr,
    IN  LPSTR pszFormatString,
    ...)
{
    int nRet = 0;
    CHAR szArgBuffer[1024 + 1]; // MSDN says wvsprintf never uses more than 1024 bytes
                                // ...but wvsprintf really needs an extra byte to store
                                // a null terminator in some cases (see X5:198202).
    va_list ap;

    va_start(ap, pszFormatString);

    nRet = wvsprintf(szArgBuffer, pszFormatString, ap);
    _ASSERT(nRet < 1024 + 1);

    ::LogLdapError(
        GetISMTPServerEx(),
        ulLdapErr,
        m_szHost,
        szArgBuffer);
}

//+------------------------------------------------------------
//
// Function: CLdapConnection::LogLdapError
//
// Synopsis: Logs an eventlog for a wldap32 error
//
// Arguments:
//  pISMTPServerEx: SMTP server instance
//  ulLdapErr: LDAP error to log
//  pszFormatString: _snprintf Format string for function name
//  ...: variable list of args for format string
//
// Returns: Nothing
//
// History:
// dlongley 2002/1/31: Created.
//
//-------------------------------------------------------------
VOID CLdapConnection::LogLdapError(
    IN  ISMTPServerEx *pISMTPServerEx,
    IN  ULONG ulLdapErr,
    IN  LPSTR pszFormatString,
    ...)
{
    int nRet = 0;
    CHAR szArgBuffer[1024 + 1]; // MSDN says wvsprintf never uses more than 1024 bytes
                                // ...but wvsprintf really needs an extra byte to store
                                // a null terminator in some cases (see X5:198202).
    va_list ap;

    if( !pISMTPServerEx )
        return;

    va_start(ap, pszFormatString);

    nRet = wvsprintf(szArgBuffer, pszFormatString, ap);
    _ASSERT(nRet < 1024 + 1);

    ::LogLdapError(
        pISMTPServerEx,
        ulLdapErr,
        "",
        szArgBuffer);
}

VOID LogLdapError(
    IN  ISMTPServerEx *pISMTPServerEx,
    IN  ULONG ulLdapErr,
    IN  LPSTR pszHost,
    IN  LPSTR pszCall)
{
    int nRet = 0;
    LPCSTR rgSubStrings[3];
    CHAR szErrNo[11];

    nRet = _snprintf(szErrNo, sizeof(szErrNo), "0x%08lx", ulLdapErr);
    _ASSERT(nRet == 10);

    rgSubStrings[0] = szErrNo;
    rgSubStrings[1] = pszCall;
    rgSubStrings[2] = pszHost;

    CatLogEvent(
        pISMTPServerEx,
        CAT_EVENT_LDAP_ERROR,
        3,
        rgSubStrings,
        ulLdapErr,
        szErrNo,
        LOGEVENT_FLAG_ALWAYS,
        LOGEVENT_LEVEL_FIELD_ENGINEERING);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapconn.h ===
//
// ldapconn.h -- This file contains the class definitions for:
//      CLdapConnection
//      CLdapConnectionCache
//
// Created:
//      Dec 31, 1996 -- Milan Shah (milans)
//
// Changes:
//

#ifndef _LDAPCONN_H_
#define _LDAPCONN_H_

#include <transmem.h>
#include "winldap.h"
#include "rwex.h"
#include "spinlock.h"
#include "catperf.h"
#include "catdefs.h"

//
// Timeout value (in seconds) to pass into ldap_result
//
#define LDAPCONN_DEFAULT_RESULT_TIMEOUT     (2*60)     // 2 Minutes
#define DEFAULT_LDAP_REQUEST_TIME_LIMIT     (10*60)    // 10 minutes

#define LDAPCONN_RESULT_TIMEOUT_KEY "System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"
#define LDAPCONN_RESULT_TIMEOUT_VALUE "LdapResultTimeout"
#define LDAP_REQUEST_TIME_LIMIT_VALUE "LdapRequestTimeLimit"

typedef VOID LDAPRESULT;
typedef PVOID PLDAPRESULT;
typedef VOID LDAPENTRY;
typedef PVOID PLDAPENTRY;

enum LDAP_BIND_TYPE {
    BIND_TYPE_NONE,
    BIND_TYPE_SIMPLE,
    BIND_TYPE_GENERIC,
    BIND_TYPE_CURRENTUSER
};

class CLdapConnection;

typedef VOID (*LPLDAPCOMPLETION)(
    LPVOID ctx,
    DWORD dwNumResults,
    ICategorizerItemAttributes **rgpICatItemAttrs,
    HRESULT hr,
    BOOL fFinalCompletion);

DWORD WINAPI LdapCompletionThread(LPVOID ctx);

VOID LogLdapError(
    IN  ISMTPServerEx *pISMTPServerEx,
    IN  ULONG ulLdapErr,
    IN  LPSTR pszHost,
    IN  LPSTR pszCall);

CatDebugClass(CLdapConnection)
{
    public:
        virtual HRESULT HrInitialize();

        virtual DWORD AddRef()
        {
            return InterlockedIncrement((PLONG)&m_dwRefCount);
        }
        virtual DWORD Release();
        virtual VOID ReleaseAndWaitForDestruction();
        virtual VOID FinalRelease();
        
        virtual DWORD GetRefCount()
        {
            return m_dwRefCount;
        }
            
        virtual LPSTR GetNamingContext() {       // Return the naming context
            return( m_szNamingContext );         // of the connection
        }

        virtual LPWSTR GetNamingContextW() {
            return( m_wszNamingContext );
        }

        virtual LPSTR GetHostName() {
            return( m_szHost );
        }
    
        virtual DWORD GetPort() {
            return( m_dwPort );
        }

        virtual LPSTR GetAccount() {
            return( m_szAccount );
        }

        virtual LPSTR GetPassword() {
            return( m_szPassword );
        }

        virtual LDAP_BIND_TYPE GetBindType() {
            return( m_bt );
        }

        virtual HRESULT Search(                  // Look up objects matching
            LPCSTR szBaseDN,                     // specified criteria in the
            int nScope,                          // DS
            LPCSTR szFilter,
            LPCSTR *rgszAttributes,
            PLDAPRESULT *ppResult);

        virtual HRESULT AsyncSearch(             // Asynchronously look up
            LPCWSTR szBaseDN,                    // objects matching specified
            int nScope,                          // criteria in the DS. The
            LPCWSTR szFilter,                    // results are passed to
            LPCWSTR szAttributes[],              // fnCompletion when they
            DWORD dwPageSize,                    // Optinal page size
            LPLDAPCOMPLETION fnCompletion,       // become available.
            LPVOID ctxCompletion);
        //
        // Same as above with UTF8 search filter
        //
        virtual HRESULT AsyncSearch(
            LPCWSTR szBaseDN,                    // objects matching specified
            int nScope,                          // criteria in the DS. The
            LPCSTR szFilterUTF8,                 // results are passed to
            LPCWSTR szAttributes[],              // fnCompletion when they
            DWORD dwPageSize,                    // Optinal page size
            LPLDAPCOMPLETION fnCompletion,       // become available.
            LPVOID ctxCompletion);
        //
        // Same as above with UTF8 search filter and base DN
        //
        virtual HRESULT AsyncSearch(
            LPCSTR szBaseDN,                     // objects matching specified
            int nScope,                          // criteria in the DS. The
            LPCSTR szFilterUTF8,                 // results are passed to
            LPCWSTR szAttributes[],              // fnCompletion when they
            DWORD dwPageSize,                    // Optinal page size
            LPLDAPCOMPLETION fnCompletion,       // become available.
            LPVOID ctxCompletion);

        virtual VOID CancelAllSearches(          // Cancels all pending searches
            HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANCELLED),
            ISMTPServer *pISMTPServer = NULL);

        VOID ProcessAsyncResult(                 // Method to process results
            PLDAPMessage pres,                   // of AsyncSearch requests
            DWORD dwLdapError,
            BOOL *pfTerminateIndicator);        

        friend DWORD WINAPI LdapCompletionThread(// Friend function to
            LPVOID ctx);                         // handle AsyncSearch
                                                 // completions.

        virtual HRESULT GetFirstEntry(           // Get first entry from the
            PLDAPRESULT pResult,                 // search result returned
            PLDAPENTRY *ppEntry);                // by ::Search

        virtual HRESULT GetNextEntry(            // Get the next entry from
            PLDAPRESULT pResult,                 // the search result
            PLDAPENTRY *ppEntry);

        virtual HRESULT GetAttributeValues(      // Get an entry's attribute
            PLDAPENTRY pEntry,                   // values
            LPCSTR szAttribute,
            LPSTR *prgszValues[]);

        static VOID FreeResult(                  // Free a search result
            PLDAPRESULT pResult);

        virtual VOID FreeValues(                 // Free values returned by
            LPSTR rgszValues[]);                 // ::GetAttributeValues

        virtual HRESULT Add(                     // Add a set of new
            LPCSTR szDN,                         // attributes to an existing
            LPCSTR *rgszAttributes,              // object in the DS
            LPCSTR *rgrgszValues[]) {

            return ( ModifyAttributes(
                        LDAP_MOD_ADD,
                        szDN,
                        rgszAttributes,
                        rgrgszValues) );

        }

        virtual HRESULT Delete(                  // Delete attributes from
            LPCSTR szDN,                         // an existing object in the
            LPCSTR *rgszAttributes) {            // DS

            return ( ModifyAttributes(
                        LDAP_MOD_DELETE,
                        szDN,
                        rgszAttributes,
                        NULL) );
        }

        virtual HRESULT Update(                  // Update attributes on an
            LPCSTR szDN,                         // existing object in the DS
            LPCSTR rgszAttributes[],
            LPCSTR *rgrgszValues[]) {

            return ( ModifyAttributes(
                        LDAP_MOD_REPLACE,
                        szDN,
                        rgszAttributes,
                        rgrgszValues) );

        }
        //
        // Returns an ISMTPServerEx interface for logging events or
        // NULL if none are available
        //
        virtual ISMTPServerEx * GetISMTPServerEx() = 0;

        LPSTR SzHost()
        {
            return m_szHost;
        }

        static VOID GlobalInit()
        {
            //
            // initialize LDAP perf block
            //
            ZeroMemory(&g_LDAPPerfBlock, sizeof(g_LDAPPerfBlock));

            m_ldaptimeout.tv_sec = LDAPCONN_DEFAULT_RESULT_TIMEOUT;
            m_ldaptimeout.tv_usec = 0;

            m_dwLdapRequestTimeLimit = DEFAULT_LDAP_REQUEST_TIME_LIMIT;

            //
            // read configurable static members from the registry
            //
            InitializeFromRegistry();
        }

        static VOID InitializeFromRegistry();

    protected:

        CLdapConnection(                         // The constructor and
            LPSTR szHost,                        // destructor are protected
            DWORD dwPort,
            LPSTR szNamingContext,               // since only derived classes
            LPSTR szAccount,                     // can create/delete these
            LPSTR szPassword,
            LDAP_BIND_TYPE BindType);

        virtual ~CLdapConnection();

        virtual HRESULT Connect();               // Create/Delete connection
                                                 // to LDAP host
        virtual VOID Disconnect();

        virtual VOID Invalidate();

        virtual BOOL IsValid();

        virtual DWORD BindToHost(
            PLDAP pldap,
            LPSTR szAccount,
            LPSTR szPassword);

        virtual BOOL IsEqual(                    // Return true if the
            LPSTR szHost,                        // object member variables
            DWORD dwPort,
            LPSTR szNamingContext,               // match the passed in
            LPSTR szAccount,                     // values
            LPSTR szPassword,
            LDAP_BIND_TYPE BindType);

        virtual HRESULT ModifyAttributes(        // Helper function for
            int nOperation,                      // ::Add, ::Delete, and
            LPCSTR szDN,                         // ::Update public functions
            LPCSTR rgszAttributes[],
            LPCSTR *rgrgszValues[]);

        virtual HRESULT LdapErrorToHr(
            DWORD dwLdapError);

        VOID SetTerminateIndicatorTrue()
        {
            BOOL *pfTerminate;

            m_fTerminating = TRUE;

            pfTerminate = (BOOL *) InterlockedExchangePointer(
                (PVOID *) &m_pfTerminateCompletionThreadIndicator,
                NULL);

            if(pfTerminate)
                *pfTerminate = TRUE;
        }

        VOID CancelExpiredSearches(HRESULT hr);

        ULONG GetDefaultNamingContext();        // Helper function to
                                                // get the default
                                                // naming context from
                                                // the server we are
                                                // connected to.

        static LDAP_TIMEVAL m_ldaptimeout;
        static DWORD m_dwLdapRequestTimeLimit;
        DWORD m_dwPort;
        char m_szHost[CAT_MAX_DOMAIN];
        char m_szNamingContext[CAT_MAX_DOMAIN];
        WCHAR m_wszNamingContext[CAT_MAX_DOMAIN];
        char m_szAccount[CAT_MAX_LOGIN];
        char m_szPassword[CAT_MAX_PASSWORD];

        #define SIGNATURE_LDAPCONN              ((DWORD) 'CadL')
        #define SIGNATURE_LDAPCONN_INVALID      ((DWORD) 'XadL')
        DWORD m_dwSignature;
        DWORD m_dwRefCount;
        DWORD m_dwDestructionWaiters;
        HANDLE m_hShutdownEvent;
        LDAP_BIND_TYPE m_bt;

        PLDAP GetPLDAP()
        {
            if(m_pCPLDAPWrap)
                return m_pCPLDAPWrap->GetPLDAP();
            else
                return NULL;
        }
        CPLDAPWrap *m_pCPLDAPWrap;

        BOOL m_fDefaultNamingContext;

        //
        // Unfortunately, our RFC1823 LDAP API provides no access to the
        // socket handle which we can register with a completion port. So,
        // if one or more async search request is issued, we have to burn a
        // thread to await its completion.
        //

        //
        // This spin lock protects access to the pending request list as
        // well as m_dwStatusFlags 
        //
        SPIN_LOCK m_spinlockCompletion;

        // CRITICAL_SECTION m_cs;

        //
        // jstamerj 980501 15:56:27: 
        // Reader/writer lock so that we wait for all calls in
        // ldap_search_ext before cancelling all pending searches 
        //
        CExShareLock m_ShareLock;

        DWORD  m_idCompletionThread;

        HANDLE m_hCompletionThread;

        HANDLE m_hOutstandingRequests;

        BOOL *m_pfTerminateCompletionThreadIndicator;
        BOOL m_fTerminating;

        BOOL m_fValid;

        typedef struct _PendingRequest {
            int msgid;
            LPLDAPCOMPLETION fnCompletion;
            LPVOID ctxCompletion;
            LIST_ENTRY li;
            //
            // Parameters for paged searches
            //
            DWORD dwPageSize;
            PLDAPSearch pldap_search;
            DWORD dwTickCount;

        } PENDING_REQUEST, *PPENDING_REQUEST;

        LIST_ENTRY m_listPendingRequests;

        BOOL m_fCancel;

        //
        // The following three functions must be called inside an external
        // lock (m_spinlockcompletion)
        //
        VOID NotifyCancel()
        {
            m_fCancel = TRUE;
        }
        VOID ClearCancel()
        {
            m_fCancel = FALSE;
        }
        BOOL CancelOccured()
        {
            return m_fCancel;
        }
        VOID SetPort(DWORD dwPort)
        {
            m_dwPort = (dwPort != 0) ? dwPort : LDAP_PORT;
        }
        BOOL fIsPortEqual(DWORD dwPort)
        {
            return (m_dwPort == ((dwPort != 0) ? dwPort : LDAP_PORT));
        }
        virtual HRESULT CreateCompletionThreadIfNeeded();

        virtual VOID SetTerminateCompletionThreadIndicator(
            BOOL *pfTerminateCompletionThreadIndicator);

        virtual VOID InsertPendingRequest(
            PPENDING_REQUEST preq);

        virtual VOID RemovePendingRequest(
            PPENDING_REQUEST preq);

        virtual VOID CallCompletion(
            PPENDING_REQUEST preq,
            PLDAPMessage pres,
            HRESULT hrStatus,
            BOOL fFinalCompletion);

        VOID AbandonRequest(
            PPENDING_REQUEST preq)
        {
            ldap_abandon(
                GetPLDAP(),
                preq->msgid);
            if(preq->pldap_search)
                ldap_search_abandon_page(
                    GetPLDAP(),
                    preq->pldap_search);

            INCREMENT_LDAP_COUNTER(AbandonedSearches);
            DECREMENT_LDAP_COUNTER(PendingSearches);
        }

        VOID LogLdapError(
            IN  ULONG ulLdapErr,
            IN  LPSTR pszFormatString,
            ...);
            
        static VOID LogLdapError(
            IN  ISMTPServerEx *pISMTPServerEx,
            IN  ULONG ulLdapErr,
            IN  LPSTR pszFormatString,
            ...);
            
};

//
// For the hash function to work correctly, the table size must be a power of
// two. This is just an efficiency trick; there is nothing fundamentally
// wrong with using some other size, except that the hash function would have
// to use an expensive MODULO operator instead of a cheap AND.
//

#define LDAP_CONNECTION_CACHE_TABLE_SIZE    256

#define MAX_LDAP_CONNECTIONS_PER_HOST_KEY "System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"
#define MAX_LDAP_CONNECTIONS_PER_HOST_VALUE "MaxLdapConnections"

class CLdapConnectionCache
{

  public:

        CLdapConnectionCache(
            ISMTPServerEx *pISMTPServerEx);      // Constructor

        ~CLdapConnectionCache();                 // Destructor

        HRESULT GetConnection(                   // Given LDAP config info,
            CLdapConnection **ppConn,
            LPSTR szHost,                        // retrieve a connection to
            DWORD dwPort,
            LPSTR szNamingContext,               // the LDAP host.
            LPSTR szAccount,
            LPSTR szPassword,
            LDAP_BIND_TYPE bt,
            PVOID pCreateContext = NULL);

        VOID CancelAllConnectionSearches(
            ISMTPServer *pISMTPServer = NULL);

        //
        // It is intended for there to be a single, global, instance of
        // a CLdapConnectionCache object, serving multiple instances of
        // CEmailIDLdapStore. Each instance of CEmailIDLdapStore needs to
        // call AddRef() and Release() in its constructor/destructor, so that
        // the connection cache knows to clean up connections in the cache
        // when the ref count goes to 0.
        //

        VOID AddRef();

        VOID Release();

  private:

        //
        // An internally utility function to release a connection
        //
        VOID ReleaseConnectionInternal(
            CLdapConnection *pConnection,
            BOOL fLockRequired);

        LONG m_cRef;

  protected:
        class CCachedLdapConnection : public CLdapConnection {
            public:
                CCachedLdapConnection(
                    LPSTR szHost,
                    DWORD dwPort,
                    LPSTR szNamingContext,
                    LPSTR szAccount,
                    LPSTR szPassword,
                    LDAP_BIND_TYPE bt,
                    CLdapConnectionCache *pCache) :
                        CLdapConnection(
                            szHost,
                            dwPort,
                            szNamingContext,
                            szAccount,
                            szPassword,
                            bt)
                {
                    m_pCache = pCache;
                }

                HRESULT Connect() {
                    return( CLdapConnection::Connect() );
                }

                VOID Disconnect() {
                    CLdapConnection::Disconnect();
                }

                VOID Invalidate() {
                    CLdapConnection::Invalidate();
                }

                BOOL IsValid() {
                    return( CLdapConnection::IsValid() );
                }

                BOOL IsEqual(
                    LPSTR szHost,
                    DWORD dwPort,
                    LPSTR szNamingContext,
                    LPSTR szAccount,
                    LPSTR szPassword,
                    LDAP_BIND_TYPE BindType) {

                    return( CLdapConnection::IsEqual(
                        szHost, dwPort, szNamingContext, szAccount,
                        szPassword, BindType) );
                }

                ISMTPServerEx *GetISMTPServerEx()
                {
                    return (m_pCache) ? m_pCache->GetISMTPServerEx() : NULL;
                }

                DWORD Release();

                LIST_ENTRY li;
                CLdapConnectionCache *m_pCache;

        };

        virtual VOID RemoveFromCache(
            CCachedLdapConnection *pConn);

        virtual CCachedLdapConnection *CreateCachedLdapConnection(
            LPSTR szHost,
            DWORD dwPort,
            LPSTR szNamingContext,
            LPSTR szAccount,
            LPSTR szPassword,
            LDAP_BIND_TYPE bt,
            PVOID pCreateContext)
        {
            CCachedLdapConnection *pret;
            pret = new CCachedLdapConnection(
                szHost,
                dwPort,
                szNamingContext,
                szAccount,
                szPassword,
                bt, 
                this);

            if(pret)
                if(FAILED(pret->HrInitialize())) {
                    pret->Release();
                    pret = NULL;
                }
            return pret;
        }

        ISMTPServerEx *GetISMTPServerEx()
        {
            return m_pISMTPServerEx;
        }
  private:

        //
        // We want to support multiple connections per host, up to a maximum
        // of m_cMaxHostConnections. We achieve this in a simple way by
        // keeping a per-cache m_nConnectionSkipCount. Every time we are
        // searching for a cached connection to a host in, we skip
        // m_nNextConnectionSkipCount cached connections. Every time we
        // find a cached connection, we bump up
        // m_nNextCachedConnectionSkipCount by 1 modulo m_cMaxHostConnections.
        // This means we'll round robin through m_cMaxHostConnections
        // connections per host.
        //

        ISMTPServerEx *m_pISMTPServerEx;

        LONG m_nNextConnectionSkipCount;

        LONG m_cMaxHostConnections;

        LONG m_cCachedConnections;

        LIST_ENTRY m_rgCache[ LDAP_CONNECTION_CACHE_TABLE_SIZE ];
        CExShareLock m_rgListLocks[ LDAP_CONNECTION_CACHE_TABLE_SIZE ];
        LONG m_rgcCachedConnections[ LDAP_CONNECTION_CACHE_TABLE_SIZE ];

        VOID InitializeFromRegistry();

        unsigned short Hash(
            LPSTR szConnectionName);

    friend class CLdapConnectionCache::CCachedLdapConnection;
    friend class CBatchLdapConnection;
};

#endif // _LDAPCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ntpch.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ntpch.cpp
//
//  Description:  NT PCH File - Includes the real .cpp file.  This lets us
//                 generate a seperate obj file to satisfy the NT build env.
//
//
//-----------------------------------------------------------------------------

#include <precomp.h>

#include "precomp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc

$(O)\phatqmsg.h $(O)\phatqmsg.rc $(O)\msg00001.bin: $(STAXINC)\export\phatqmsg.mc
    copy /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\phatqmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\phatqmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\ldapstor.h ===
//
// ldapstor.h -- This file contains the class definitions for:
//  CEmailIDLdapStore
//
// Created:
//   Dec 31, 1996 -- Milan Shah (milans)
//
// Changes:
//

#ifndef __LDAPSTOR_H__
#define __LDAPSTOR_H__

#include <transmem.h>
#include "idstore.h"
#include "ldapconn.h"
#include "phatqmsg.h"
#include "ccataddr.h"
#include "smtpevent.h"
#include "catglobals.h"
#include "cnfgmgr.h"

//
// CEmailIDLdapStore is a class that stores and retrieves mail information
// from an LDAP DS.
//

//
// Ideally, this should be the optimal size for wldap32 to be
// returning the search results of dynamic DL members
//
#define CAT_DEFAULT_DYNAMICDL_PAGE_SIZE             20

#define DYNAMICDL_PAGE_SIZE_KEY "System\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"
#define DYNAMICDL_PAGE_SIZE_VALUE "DynamicDlPageSize"

//
// Do not try to initialize the store more often than this specified time
//
#define CAT_LDAPSTORE_MIN_INIT_INTERVAL             (5*60)  // 5 minutes

template <class T> class CEmailIDLdapStore;

typedef struct _tagMemberResolveContext {
    CEmailIDLdapStore<CCatAddr> *pStore;
    CCatAddr *pCCatAddr;
    CAT_ADDRESS_TYPE CAType;
    DWORD dwNextBlockIndex;
    CBatchLdapConnection *pConn;
    ICategorizerItemAttributes *pICatItemAttr;
    HRESULT hrResolveStatus;
    PFN_DLEXPANSIONCOMPLETION pfnCompletion;
    PVOID pCompletionContext;
    BOOL fFinalCompletion;
} MEMBERRESOLVECONTEXT, *PMEMBERRESOLVECONTEXT;


CatDebugClass(CMembershipPageInsertionRequest),
    public CInsertionRequest
{
  public:
    CMembershipPageInsertionRequest(
        PMEMBERRESOLVECONTEXT pMemCtx)
    {
        m_pMemCtx = pMemCtx;
        m_fInsertedRequest = FALSE;
    }

    HRESULT HrInsertSearches(
        DWORD dwcSearches);

    VOID NotifyDeQueue(
        HRESULT hr);
        
    BOOL IsBatchable()
    {
        return FALSE;
    }

    ISMTPServerEx *GetISMTPServerEx();

  private:
    PMEMBERRESOLVECONTEXT m_pMemCtx;
    BOOL m_fInsertedRequest;
};


typedef struct _tagDynamicDLResolveContext {
    CCatAddr *pCCatAddr;
    CStoreListResolveContext *pSLRC;
    ICategorizerParametersEx *pICatParams;
    PFN_DLEXPANSIONCOMPLETION pfnCompletion;
    PVOID pCompletionContext;
    BOOL fFirstPage;
    CBatchLdapConnection *pConn;
    HRESULT hrResolveStatus;
} DYNAMICDLRESOLVECONTEXT, *PDYNAMICDLRESOLVECONTEXT;

CatDebugClass(CDynamicDLSearchInsertionRequest),
    public CInsertionRequest
{
  public:
    CDynamicDLSearchInsertionRequest(
        LPLDAPCOMPLETION pfnLdapCompletion,
        CCatAddr *pCCatAddr,
        CStoreListResolveContext *pSLRC,
        ICategorizerParametersEx *pICatParams,
        PFN_DLEXPANSIONCOMPLETION pfnExpansionCompletion,
        PVOID pCompletionContext);

    ~CDynamicDLSearchInsertionRequest();

    HRESULT HrInsertSearches(
        DWORD dwcSearches);
        
    DWORD GetMinimumRequiredSearches()
    {
        return m_dwPageSize;
    }

    VOID NotifyDeQueue(
        HRESULT hrReason);
        
    BOOL IsBatchable()
    {
        return FALSE;
    }
    
    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_ResolveCtx.pSLRC->GetISMTPServerEx();
    }
        
  public:
    DYNAMICDLRESOLVECONTEXT m_ResolveCtx;

  private:
    #define SIGNATURE_CDynamicDLSearchInsertionRequest          (DWORD)'qIDD'
    #define SIGNATURE_CDynamicDLSearchInsertionRequest_INVALID  (DWORD)'XIDD'
    
    DWORD m_dwSignature;
    LPLDAPCOMPLETION m_pfnCompletion;
    BOOL m_fInsertedRequest;
    DWORD m_dwPageSize;
};


template <class T> CatDebugClass(CEmailIDLdapStore),
    public CEmailIDStore<T>
{
  public:
    CEmailIDLdapStore()
    {
        m_pICatParams = NULL;
        m_pISMTPServer = NULL;
        m_pISMTPServerEx = NULL;
        m_szAccount[0] = '\0';
        m_pCLdapCfgMgr = NULL;
        ZeroMemory(&m_ulLastInitTime, sizeof(m_ulLastInitTime));
    }

    ~CEmailIDLdapStore()
    {
        if(m_pICatParams)
            m_pICatParams->Release();
        if(m_pISMTPServer)
            m_pISMTPServer->Release();
        if(m_pISMTPServerEx)
            m_pISMTPServerEx->Release();
        if(m_pCLdapCfgMgr)
            m_pCLdapCfgMgr->Release();

    }
    ISMTPServerEx *GetISMTPServerEx()
    {
        return m_pISMTPServerEx;
    }
    //
    // Initialize the store.
    //
    virtual HRESULT Initialize(
        ICategorizerParametersEx *pICatParams,
        ISMTPServer *pISMTPServer);
        
    //
    // Initialize registry configurable parameters
    //
    static VOID InitializeFromRegistry();

    //
    // get an entry asynchronously
    //
    HRESULT InitializeResolveListContext(
        VOID *pUserContext,
        LPRESOLVE_LIST_CONTEXT pResolveListContext);

    VOID FreeResolveListContext(
        LPRESOLVE_LIST_CONTEXT pResolveListContext);

    HRESULT LookupEntryAsync(
        T *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext);

    virtual HRESULT CancelResolveList(
        LPRESOLVE_LIST_CONTEXT pResolveListContext,
        HRESULT hr);

    VOID CancelAllLookups();

    static VOID AsyncLookupCompletion(
        CCatAddr *pCCatAddr,
        LPVOID lpContext);

    HRESULT HrExpandPagedDlMembers(
        CCatAddr *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext,
        CAT_ADDRESS_TYPE CAType,
        PFN_DLEXPANSIONCOMPLETION pfnCompletion,
        PVOID pContext);

    HRESULT HrExpandDynamicDlMembers(
        CCatAddr *pCCatAddr,
        LPRESOLVE_LIST_CONTEXT pListContext,
        PFN_DLEXPANSIONCOMPLETION pfnCompletion,
        PVOID pContext);

    VOID GetInsertionContext(
        LPRESOLVE_LIST_CONTEXT pListContext)
    {
        ((CStoreListResolveContext *)pListContext->pStoreContext)->GetInsertionContext();
    }
    VOID ReleaseInsertionContext(
        LPRESOLVE_LIST_CONTEXT pListContext)
    {
        ((CStoreListResolveContext *)pListContext->pStoreContext)->ReleaseInsertionContext();
    }

    HRESULT InsertInsertionRequest(
        LPRESOLVE_LIST_CONTEXT pListContext,
        CInsertionRequest *pCRequest);

    HRESULT HrGetConnection(
        CCfgConnection **ppConn)
    {
        return m_pCLdapCfgMgr->HrGetConnection(ppConn);
    }

    // this will have to be defined per template instance
    static const DWORD Signature;

  private:
    char m_szAccount[CAT_MAX_DOMAIN];
    LPSTR m_pszHost;
    DWORD m_dwPort;
    LPSTR m_pszNamingContext;
    LPSTR m_pszPassword;
    LDAP_BIND_TYPE m_bt;

    HRESULT RetrieveICatParamsInfo(
        LPSTR *ppszHost,
        DWORD *pdwPort,
        LPSTR *ppszNamingContext,
        LPSTR *ppszAccount,
        LPSTR *ppszDomain,
        LPSTR *ppszPassword,
        LDAP_BIND_TYPE *pbt);

    HRESULT AccountFromUserDomain(
        LPTSTR pszAccount,
        DWORD  dwccAccount,
        LPTSTR pszUser,
        LPTSTR pszDomain);

    HRESULT HrExpandDlPage(
        PMEMBERRESOLVECONTEXT pMemCtx,
        ICategorizerItemAttributes *pICatItemAttr);

    HRESULT HrExpandAttribute(
        CCatAddr *pCCatAddr,
        ICategorizerItemAttributes *pICatItemAttr,
        CAT_ADDRESS_TYPE CAType,
        LPSTR pszAttributeName,
        PDWORD pdwNumberMembers);

    HRESULT HrExpandNextDlPage(
        PMEMBERRESOLVECONTEXT pMemCtx);

    static VOID AsyncExpandDlCompletion(
        LPVOID ctx,
        DWORD  dwNumResults,
        ICategorizerItemAttributes **rgpICatItemAttrs,
        HRESULT hr,
        BOOL fFinalCompletion);

    static VOID FinishExpandItem(
        CCatAddr *pCCatAddr,
        HRESULT hrStatus);

    static VOID AsyncDynamicDlCompletion(
        LPVOID ctx,
        DWORD  dwNumResults,
        ICategorizerItemAttributes **rgpICatItemAttrs,
        HRESULT hr,
        BOOL fFinalCompletion);

    static HRESULT HrAddItemAttrMember(
        CCatAddr *pCCatAddr,
        ICategorizerItemAttributes *pICatItemAttr,
        CAT_ADDRESS_TYPE CAType,
        LPSTR pszAttr);

    VOID ResetPeriodicEventLogs()
    {
        if (m_pISMTPServerEx)
        {
            m_pISMTPServerEx->ResetLogEvent(
                CAT_EVENT_LOGON_FAILURE,
                m_szAccount);

            m_pISMTPServerEx->ResetLogEvent(
                CAT_EVENT_LDAP_CONNECTION_FAILURE,
                "");
        }
    }


    ICategorizerParametersEx *m_pICatParams;
    ISMTPServer *m_pISMTPServer;
    ISMTPServerEx *m_pISMTPServerEx;
    CLdapCfgMgr *m_pCLdapCfgMgr;
    ULARGE_INTEGER m_ulLastInitTime;
    static DWORD m_dwDynamicDlPageSize;

    friend class CMembershipPageInsertionRequest;
    friend class CDynamicDLSearchInsertionRequest;
};

#define SZ_PAGEDMEMBERS_INDICATOR ";range=" // String appened to
                                            // members attribute
                                            // indicating this is a
                                            // partial list
#define WSZ_PAGEDMEMBERS_INDICATOR L";range="
#define MAX_PAGEDMEMBERS_DIGITS     32 // Maximum # of digits for
                                       // range specifier values
#define MAX_MEMBER_ATTRIBUTE_SIZE   64 // Maximum size of the member
                                       // attribute name

inline ISMTPServerEx * CMembershipPageInsertionRequest::GetISMTPServerEx()
{
    return (m_pMemCtx) ? m_pMemCtx->pStore->GetISMTPServerEx() : NULL;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\pldapwrap.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 2001, Microsoft Corporation
//
// File: pldapwrap.cpp
//
// Contents: CPLDAPWrap methods
//
// Classes: CPLDAPWrap
//
// Functions:
//  CPLDAPWrap::CPLDAPWrap
//
// History:
// jstamerj 2001/11/28 15:10:11: Created.
//
//-------------------------------------------------------------
#include "precomp.h"


//+------------------------------------------------------------
//
// Function: CPLDAPWrap::CPLDAPWrap
//
// Synopsis: Opens a wldap32 connection to a server
//
// Arguments:
//  pszHost: FQDN matching the DNS A Record of an LDAP server
//  dwPort:  Server LDAP TCP port #
//
// Returns: Nothing.  m_pldap will be NULL if there is an error.
//
// History:
// jstamerj 2001/11/28 15:10:51: Created.
//
//-------------------------------------------------------------
CPLDAPWrap::CPLDAPWrap(
    ISMTPServerEx *pISMTPServerEx,
    LPSTR pszHost,
    DWORD dwPort)
{
    PLDAP pldap = NULL;
    ULONG ulLdapOn = (ULONG)((ULONG_PTR)LDAP_OPT_ON);
    ULONG ulLdapRet = LDAP_SUCCESS;

    CatFunctEnterEx((LPARAM)this, "CPLDAPWrap::CPLDAPWrap");

    m_dwSig = SIGNATURE_CPLDAPWRAP;

    m_pldap = NULL;
    //
    // Use ldap_init so that we can set ldap options before connecting
    //
    pldap = ldap_init(
        pszHost,
        dwPort);
    
    if(pldap == NULL)
    {
        ulLdapRet = LdapGetLastError();
        ErrorTrace((LPARAM)this,
                   "ldap_init returned NULL, gle=0x%08lx, lgle=0x%08lx",
                   GetLastError(),
                   LdapGetLastError());
        
        LogLdapError(
            pISMTPServerEx,
            ulLdapRet,
            pszHost,
            "ldap_init");
        
        goto CLEANUP;
    }
    //
    // Tell wldap32 to lookup A records only.  By default, wldap32
    // supports domain names, so it looksup DNS SRV records.  Since we
    // always have a FQDN of a server, this is wasteful.  Set the
    // AREC_EXCLUSIVE option so that we only do A record lookups.
    //
    ulLdapRet = ldap_set_option(
        pldap,
        LDAP_OPT_AREC_EXCLUSIVE,
        (PVOID) &ulLdapOn);

    if(ulLdapRet != LDAP_SUCCESS)
    {
        //
        // Trace the error, but continue anyway
        //
        ErrorTrace((LPARAM)this,
                   "ldap_set_option(AREC_EXCLUSIVE, ON) failed 0x%08lx",
                   ulLdapRet);

        LogLdapError(
            pISMTPServerEx,
            ulLdapRet,
            pszHost,
            "ldap_set_option(LDAP_OPT_AREC_EXCLUSIVE)");
    }
    //
    // Now that the options are setup, connect.
    //
    ulLdapRet = ldap_connect(pldap, NULL);
    if(ulLdapRet != LDAP_SUCCESS)
    {
        ErrorTrace((LPARAM)this,
                   "ldap_connect to server %s failed, error 0x%08lx",
                   pszHost,
                   ulLdapRet);

        LogLdapError(
            pISMTPServerEx,
            ulLdapRet,
            pszHost,
            "ldap_connect");

        goto CLEANUP;
    }
    //
    // Success!  Set m_pldap
    //
    m_pldap = pldap;
    pldap = NULL;

 CLEANUP:
    if(pldap)
        ldap_unbind(pldap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\precomp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: precomp.h
//
//  Description:  Precompiled header for phatq\cat\ldapstor
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Moved to transmt
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQ_PRECOMP_H__
#define __AQ_PRECOMP_H__

//Includes from external directories
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <windows.h>
#include <dbgtrace.h>
#include <listmacr.h>
#include "spinlock.h"
#include <lmcons.h>
#include <dsgetdc.h>
#include <lmapibuf.h>
#include <time.h>
#include "caterr.h"
#include "smtpevent.h"
#include <transmem.h>
#include <winldap.h>
#include <perfcat.h>
#include <catperf.h>
#include <codepageconvert.h>

//Local includes
#ifdef PLATINUM
#include <ptntintf.h>
#include <ptntdefs.h>
#define AQ_MODULE_NAME "phatq"
#else //not PLATINUM
#define AQ_MODULE_NAME "aqueue"
#endif //PLATINUM
#include "catdebug.h"
#include "idstore.h"
#include "pldapwrap.h"
#include "ccat.h"
#include "ccatfn.h"
#include "globals.h"
#include "asyncctx.h"
#include "ccataddr.h"
#include "icatasync.h"
#include <smtpseo.h>
#include "catglobals.h"
#include "catdebug.h"


#endif //__AQ_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\pldapwrap.h ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: pldapwrap.h
//
// Contents: Class to refcount a PLDAP handle
//
// Classes: 
//  CRefcountWrap: generic refcounting wrap class
//  CPLDAPWrap
//
// Functions: 
//
// History:
// jstamerj 2000/02/25 15:18:15: Created.
//
//-------------------------------------------------------------
class CRefcountWrap
{
  public:
    CRefcountWrap()
    {
        m_lRefCount = 1;
    }
    LONG AddRef()
    {
        return InterlockedIncrement(&m_lRefCount);
    }
    LONG Release()
    {
        LONG lRet;
        lRet = InterlockedDecrement(&m_lRefCount);
        if(lRet == 0)
            FinalRelease();
        return lRet;
    }
    virtual VOID FinalRelease() = 0;
  private:
    LONG m_lRefCount;
};



CatDebugClass(CPLDAPWrap),
    public CRefcountWrap
{
  public:
    CPLDAPWrap(
        ISMTPServerEx *pISMTPServerEx,
        LPSTR pszHost,
        DWORD dwPort);

    VOID SetPLDAP(PLDAP pldap)
    {
        m_pldap = pldap;
    }
    VOID FinalRelease()
    {
        delete this;
    }
    operator PLDAP()
    {
        return PLDAP();
    }
    PLDAP GetPLDAP()
    {
        return m_pldap;
    }
  private:
    #define SIGNATURE_CPLDAPWRAP         (DWORD)'ADLP'
    #define SIGNATURE_CPLDAPWRAP_INVALID (DWORD)'XDLP'

    ~CPLDAPWrap()
    {
        if(m_pldap)
            ldap_unbind(m_pldap);
        
        _ASSERT(m_dwSig == SIGNATURE_CPLDAPWRAP);
        m_dwSig = SIGNATURE_CPLDAPWRAP_INVALID;
    }

 private:
    DWORD m_dwSig;
    PLDAP m_pldap;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\precomp.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: precomp.cpp
//
//  Description:  Precompiled CPP for phatq\cat\ldapstor
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\simparray.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: simparray.cpp
//
// Contents: Simple growable array class
//
// Classes: CSimpArray
//
// Functions:
//
// History:
// jstamerj 1998/07/14 11:37:25: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "simparray.h"


//+------------------------------------------------------------
//
// Function: CSimpArray::Initialize
//
// Synopsis: Initializes array to a specified size.  Only necessary to
// call if you wish to optimize usage by starting with a specified
// array size.
//
// Arguments:
//  dwSize: Initial array size
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 12:22:01: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::Initialize(
    DWORD dwSize)
{
    _ASSERT(m_dwArrayAllocSize == 0);
    _ASSERT(m_dwArrayClaimedSize == 0);
    _ASSERT(m_dwArrayValidSize == 0);

    _ASSERT(m_rgData == NULL);

    m_rgData = new T [dwSize];

    if(m_rgData == NULL) {

        return E_OUTOFMEMORY;

    } else {

        m_dwArrayAllocSize = dwSize;
        return S_OK;
    }
}


//+------------------------------------------------------------
//
// Function: CSimpArray::Add
//
// Synopsis: Adds one element to the array
//
// Arguments:
//  Data: Value to add to the array
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 15:50:00: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::Add(
    T Data)
{
    //
    // Same functionality as AddArray except this is an array with
    // only one element
    //
    return AddArray(1, &Data);
}


//+------------------------------------------------------------
//
// Function: CSimpArray::AddArray
//
// Synopsis: Adds an array of T's to our array
//
// Arguments:
//  dwSize: size of passed in array
//  pData:  pointer to array data
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 12:27:18: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::AddArray(
    DWORD dwSize,
    T * pData)
{
    HRESULT hr;
    DWORD dwCopyIndex;

    _ASSERT(dwSize);
    _ASSERT(pData);

    hr = AllocArrayRange(dwSize, &dwCopyIndex);
    if(FAILED(hr))
        return hr;

    //
    // Copy the memory from one array to another
    //
    CopyMemory(&(m_rgData[dwCopyIndex]), pData, sizeof(T) * dwSize);

    //
    // Increment array element counter
    //NOTE: This really isn't thread safe in the sense that if
    //we're in this call and someone is reading the array,
    //m_dwArrayValidSize could be invalid.
    //
    InterlockedExchangeAdd((PLONG) &m_dwArrayValidSize, dwSize);

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: AllocArrayRange
//
// Synopsis: Allocates a range on the array for the caller (of unused T's)
//
// Arguments:
//  dwSize: Size of the range you'd like
//  pdwIndex: On success, starting index of your allocated range
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 12:37:54: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::AllocArrayRange(
    DWORD dwSize,
    PDWORD pdwIndex)
{
    HRESULT hr;

    _ASSERT(dwSize);
    _ASSERT(pdwIndex);

    AcquireSpinLock(&m_slAllocate);
 
    hr = ReAllocArrayIfNecessary(m_dwArrayClaimedSize + dwSize);

    if(SUCCEEDED(hr)) {
        *pdwIndex = m_dwArrayClaimedSize;
        m_dwArrayClaimedSize += dwSize;
    }

    ReleaseSpinLock(&m_slAllocate);

    return hr;
}


//+------------------------------------------------------------
//
// Function: CSimpArray::ReAllocArrayIfNecessary
//
// Synopsis: Grow the array size if necessary
//           Not thread safe; locking must be done outside
//
// Arguments:
//  dwSize: New size desired
//
// Returns:
//  S_OK: Success, array grown
//  S_FALSE: Success, not necessary to grow array
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/07/14 13:56:16: Created.
//
//-------------------------------------------------------------
template <class T> HRESULT CSimpArray<T>::ReAllocArrayIfNecessary(
    DWORD dwSize)
{
    DWORD dwNewSize;
    T *pNewArray;
    T *pOldArray;

    if(dwSize <= m_dwArrayAllocSize)
        return S_FALSE;

    //
    // Calculate new size desired
    //
#ifdef CSIMPARRAY_DOUBLE

    if(m_dwArrayAllocSize == 0) {

        dwNewSize = CSIMPARRAY_DEFAULT_INITIAL_SIZE;

    } else {

        dwNewSize = m_dwArrayAllocSize;

    }

    while(dwNewSize < dwSize)
        dwNewSize *= 2;

#else

    dwNewSize = dwSize;

#endif

    _ASSERT(dwNewSize >= dwSize);

    pNewArray = new T [dwNewSize];

    if(pNewArray == NULL)
        return E_OUTOFMEMORY;

    CopyMemory(pNewArray, m_rgData, sizeof(T) * m_dwArrayAllocSize);

    //
    // pNewArray is valid.  Make the switch now.
    //
    pOldArray = m_rgData;
    m_rgData = pNewArray;
    m_dwArrayAllocSize = dwNewSize;

    //
    // Release old array memory
    //
    delete pOldArray;

    return S_OK;
}


#ifdef NEVER
//+------------------------------------------------------------
//
// Function: Cat_NeverCalled_SimpArrayTemplateDummy
//
// Synopsis: Dummy function that is never called but forces compiler
// to generate code for desired types
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/16 15:28:37: Created.
//
//-------------------------------------------------------------
#include "smtpevent.h"

VOID Cat_NeverCalled_SimpArrayTemplateDummy()
{
    _ASSERT(0 && "Never call this function!");
    CSimpArray<ICategorizerItem *> csaItem;
    CSimpArray<ICategorizerItemAttributes *> csaItemAttributes;

    csaItem.Initialize(0);
    csaItemAttributes.Initialize(0);
    csaItem.Add(NULL);
    csaItemAttributes.Add(NULL);
    csaItem.AddArray(0, NULL);
    csaItemAttributes.AddArray(0, NULL);
}
#endif //NEVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\spinlock.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: spinlock.cpp
//
// Contents: Simple Spinlock package used by CLdapConnection
//
// Classes:
//
// Functions:
//   AcquireSpinLockSingleProc
//   AcquireSpinLockMultiProc
//   InitializeSpinLock
//   ReleaseSpinLock
//
// History:
// jstamerj 980511 17:26:26: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

PFN_ACQUIRESPINLOCK g_AcquireSpinLock;

//+----------------------------------------------------------------------------
//
//  Function:   InitializeSpinLock
//
//  Synopsis:   Initializes a SPIN_LOCK
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to initialize
//
//  Returns:    Nothing. *psl is in released state when this functionr returns
//
//-----------------------------------------------------------------------------

VOID InitializeSpinLock(
    PSPIN_LOCK psl)
{
    *psl = 0;

    if(g_AcquireSpinLock == NULL) {
        // Determine multi or single proc
        SYSTEM_INFO si;
        GetSystemInfo(&si);
    
        if(si.dwNumberOfProcessors > 1) {
            g_AcquireSpinLock = AcquireSpinLockMultipleProc;
        } else {
            g_AcquireSpinLock = AcquireSpinLockSingleProc;
        }
    }

}

//+----------------------------------------------------------------------------
//
//  Function:   AcquireSpinLockMultiProc
//
//  Synopsis:   Acquire a lock, spinning while it is unavailable.
//              Optimized for multi proc machines
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to acquire
//
//  Returns:    Nothing. *psl is in acquired state when this function returns
//
//-----------------------------------------------------------------------------

VOID AcquireSpinLockMultipleProc(
    volatile PSPIN_LOCK psl)
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (*psl > 0) {
            ;
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement(psl) != 1 );

}

//+----------------------------------------------------------------------------
//
//  Function:   AcquireSpinLockSingleProc
//
//  Synopsis:   Acquire a lock, spinning while it is unavailable.
//              Optimized for single proc machines
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to acquire
//
//  Returns:    Nothing. *psl is in acquired state when this function returns
//
//-----------------------------------------------------------------------------

VOID AcquireSpinLockSingleProc(
    volatile PSPIN_LOCK psl)
{
    do {

        //
        // Spin while the lock is unavailable
        //

        while (*psl > 0) {
            Sleep(0);
        }

        //
        // Lock just became available, try to grab it
        //

    } while ( InterlockedIncrement(psl) != 1 );

}

//+----------------------------------------------------------------------------
//
//  Function:   ReleaseSpinLock
//
//  Synopsis:   Releases an acquired spin lock
//
//  Arguments:  [psl] -- Pointer to SPIN_LOCK to release.
//
//  Returns:    Nothing. *psl is in released state when this function returns
//
//-----------------------------------------------------------------------------

VOID ReleaseSpinLock(
    PSPIN_LOCK psl)
{
    _ASSERT( *psl > 0 );

    InterlockedExchange( psl, 0 );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\address.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: address.cpp
//
// Contents: CABContext
//
// Classes:
//   CABContext
//
// Functions:
//   DllMain
//   CABContext::ChangeConfig
//
// History:
//
//-------------------------------------------------------------

#include "precomp.h"
#include "abtype.h"
#include "ccat.h"
#include "ccatfn.h"

//+------------------------------------------------------------
//
// Function: CABContext::ChangeConfig
//
// Synopsis: Changes a context's CCategorizer configuration by
//           constructing a new CCategorizer with the new config
//
// Arguments:
//  pConfigInfo: the new config parameters.  The struct may be changed
//               -- parameters not specfied will be copied from the
//               old CCat
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  Error from CCategorizer::Init
//
// History:
// jstamerj 1998/09/02 12:13:29: Created.
//
//-------------------------------------------------------------
HRESULT CABContext::ChangeConfig(
    PCCATCONFIGINFO pConfigInfo)
{
    HRESULT hr = S_OK;
    CCategorizer *pCCatNew = NULL;
    CCategorizer *pCCatOld = NULL;
    DWORD dwItemProps, dwLRProps;
    
    _ASSERT(pConfigInfo);

    //
    // Create a new CCategorizer object for the new config
    //
    pCCatNew = new CCategorizer();
    if(pCCatNew == NULL) {

        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    //
    // The context should hold one refcount of the
    // CCategorizer
    //
    pCCatNew->AddRef();

    //
    // Swap the old CCat with the new one
    // Since we need to get old paramters from pCCatOld and pCCatNew
    // isn't ready until it's been initizled, we need to call
    // Initialize inside the lock
    //
    m_CCatLock.ExclusiveLock();

    pCCatOld = m_pCCat;
    if(pCCatOld) {
        //
        // Merge in old parameters
        //
        PCCATCONFIGINFO pConfigInfoOld;
        
        pConfigInfoOld = pCCatOld->GetCCatConfigInfo();
        _ASSERT(pConfigInfoOld);

        MergeConfigInfo(pConfigInfo, pConfigInfoOld);

        dwItemProps = pCCatOld->GetNumCatItemProps();
        dwLRProps = pCCatOld->GetNumCatListResolveProps();

    } else {
        //
        // Default parameters
        //
        dwItemProps = _ICATEGORIZERITEM_ENDENUMMESS + NUM_SYSTEM_CCATADDR_PROPIDS;
        dwLRProps = 0;
    }
    //
    // Do not allow config changes if we are shutting down
    //
    if(pCCatOld && (pCCatOld->fIsShuttingDown())) {

        hr = CAT_E_SHUTDOWN;

    } else {
        //
        // Initialize the new ccategorizer
        //
        hr = pCCatNew->Initialize(
            pConfigInfo,
            dwItemProps,
            dwLRProps);
        
        if(SUCCEEDED(hr)) {

            m_pCCat = pCCatNew;
        }
    }
    m_CCatLock.ExclusiveUnlock();

    if(SUCCEEDED(hr) && pCCatOld) {
        //
        // Release the old CCat outside the lock
        //
        pCCatOld->Release();
    }

 CLEANUP:
    if(FAILED(hr) && pCCatNew) {

        pCCatNew->Release();
    }
    return hr;
}

//+------------------------------------------------------------
//
// Function: CABContext::MergeConfigInfo
//
// Synopsis: Any parameters not already specified in pConfigInfoDest
//  will be copied over if they exist in pConfigInfoSrc
//
// Arguments:
//  pConfigInfoDest: config info to add to
//  pConfigInfoSrc:  config info to add from
//
// Returns: NOTHING
//
// History:
//  jstamerj 1998/09/15 16:43:20: Created.
//
//-------------------------------------------------------------
VOID CABContext::MergeConfigInfo(
    PCCATCONFIGINFO pConfigInfoDest,
    PCCATCONFIGINFO pConfigInfoSrc)
{
    _ASSERT(pConfigInfoDest);
    _ASSERT(pConfigInfoSrc);

    //
    // Do the same thing for each struct member...copy it if it
    // doesn't already exist
    //
    
    #define MERGEMEMBER(flag, member) \
        if( (!(pConfigInfoDest->dwCCatConfigInfoFlags & flag)) && \
            (pConfigInfoSrc->dwCCatConfigInfoFlags & flag)) { \
            pConfigInfoDest->member = pConfigInfoSrc->member; \
            pConfigInfoDest->dwCCatConfigInfoFlags |= flag; \
        }

    //
    // If CCAT_CONFIG_INFO_ALLCATVALUES is set, do NOT merge values
    // set in SMTP_SERVER_INSTANCE::GetCatInfo -- ALLCATVALUES
    // indicates all cat values have been attempted to be read...if
    // the flag is not there, it means use default values, NOT merge
    // in exsiting values
    //
    if((pConfigInfoDest->dwCCatConfigInfoFlags &
        CCAT_CONFIG_INFO_DEFAULT) == 0) {

        MERGEMEMBER( CCAT_CONFIG_INFO_ENABLE, dwEnable );
        MERGEMEMBER( CCAT_CONFIG_INFO_FLAGS, dwCatFlags );
        MERGEMEMBER( CCAT_CONFIG_INFO_PORT, dwPort );
        MERGEMEMBER( CCAT_CONFIG_INFO_ROUTINGTYPE, pszRoutingType );
        MERGEMEMBER( CCAT_CONFIG_INFO_BINDDOMAIN, pszBindDomain );
        MERGEMEMBER( CCAT_CONFIG_INFO_USER, pszUser );
        MERGEMEMBER( CCAT_CONFIG_INFO_PASSWORD, pszPassword );
        MERGEMEMBER( CCAT_CONFIG_INFO_BINDTYPE, pszBindType );
        MERGEMEMBER( CCAT_CONFIG_INFO_SCHEMATYPE, pszSchemaType );
        MERGEMEMBER( CCAT_CONFIG_INFO_HOST, pszHost );
        MERGEMEMBER( CCAT_CONFIG_INFO_NAMINGCONTEXT, pszNamingContext );
    }
    //
    // The following paramaters are not official "msgcat" parameters,
    // so we merge them in on every config change.
    //
    MERGEMEMBER( CCAT_CONFIG_INFO_DEFAULTDOMAIN, pszDefaultDomain );
    MERGEMEMBER( CCAT_CONFIG_INFO_ISMTPSERVER, pISMTPServer );
    MERGEMEMBER( CCAT_CONFIG_INFO_IDOMAININFO, pIDomainInfo );
    MERGEMEMBER( CCAT_CONFIG_INFO_VSID, dwVirtualServerID );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\ldapstor\simparray.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: simparray.h
//
// Contents: Simple growable array class
//
// Classes: CSimpArray
//
// Functions:
//
// History:
// jstamerj 1998/07/14 11:30:13: Created.
//
//-------------------------------------------------------------

#ifndef __SIMPARRAY_H__
#define __SIMPARRAY_H__
#include <windows.h>
#include "spinlock.h"
#include <dbgtrace.h>


//
// If you want this array to behave as follows:
//   When Inserting an array element and the allocated array size is
//   not sufficient, 
//     Alloc an array size of CSIMPARRAY_DEFAULT_INITIAL_SIZE the
//     first time
//     Double the current array size until sufficient thereafter
// Then define CSIMPARRAY_DOUBLE and CSIMPARRAY_DEFAULT_INITIAL_SIZE
//
// Otherwise, it will allocate only as much space as needed when
// needed.
//

// Define this to attempt to double the array size when reallocing is necessary
//#undef CSIMPARRAY_DOUBLE

// Default initial allocation
//#undef CSIMPARRAY_DEFAULT_INITIAL_SIZE     20



//+------------------------------------------------------------
//
// Class: CSimpArray
//
// Synopsis: Simple array class with usefull msgcat utility functions
//
// Hungarian: csa, pcsa
//
// History:
// jstamerj 1998/07/15 12:15:50: Created.
//
//-------------------------------------------------------------
template <class T> class CSimpArray
{
  public:
    CSimpArray();
    ~CSimpArray();

    // Optinal Initialize function - reserves array memory for a
    // specified array size
    HRESULT Initialize(DWORD dwSize);

    // Add one element to the array
    HRESULT Add(T Data);

    // Add a real array to this array
    HRESULT AddArray(DWORD dwSize, T *pData);

    // Number of valid elements added to the array
    DWORD Size();

    // Direct access to the array
    operator T * ();

  private:
    HRESULT AllocArrayRange(DWORD dwSize, PDWORD pdwIndex);
    HRESULT ReAllocArrayIfNecessary(DWORD dwSize);

    #define SIGNATURE_CSIMPARRAY (DWORD)'SArr'
    #define SIGNATURE_CSIMPARRAY_INVALID (DWORD) 'XArr'

    DWORD m_dwSignature;
    DWORD m_dwArrayAllocSize;
    DWORD m_dwArrayClaimedSize;
    DWORD m_dwArrayValidSize;
    T * m_rgData;

    SPIN_LOCK m_slAllocate;
};


//+------------------------------------------------------------
//
// Function: CSimpArray::CSimpArary (constructor)
//
// Synopsis: Initialize member data
//
// Arguments: NONE
//
// Returns: NOTHIGN
//
// History:
// jstamerj 1998/07/14 11:39:08: Created.
//
//-------------------------------------------------------------
template <class T> inline CSimpArray<T>::CSimpArray()
{
    m_dwSignature = SIGNATURE_CSIMPARRAY;
    m_dwArrayAllocSize = m_dwArrayClaimedSize = m_dwArrayValidSize = 0;
    m_rgData = NULL;
    InitializeSpinLock(&m_slAllocate);
}


//+------------------------------------------------------------
//
// Function: CSimpArray::~CSimpArray (destructor)
//
// Synopsis: Free's memory
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/07/14 12:19:10: Created.
//
//-------------------------------------------------------------
template <class T> inline CSimpArray<T>::~CSimpArray()
{
    _ASSERT(m_dwSignature == SIGNATURE_CSIMPARRAY);
    m_dwSignature = SIGNATURE_CSIMPARRAY_INVALID;

    delete m_rgData;
}

    

//+------------------------------------------------------------
//
// Function: CSimpArray::operator T*
//
// Synopsis: Returns pointer to the array
//
// Arguments: NONE
//
// Returns: pointer to array of T's or NULL (if nothing is allocated)
//
// History:
// jstamerj 1998/07/14 14:15:21: Created.
//
//-------------------------------------------------------------
template <class T> inline CSimpArray<T>::operator T*()
{
    return m_rgData;
}


//+------------------------------------------------------------
//
// Function: CSimpArray::Size
//
// Synopsis: Returns the count of (valid) array elements.
//
// Arguments: NONE
//
// Returns: DWORD size
//
// History:
// jstamerj 1998/07/14 14:16:36: Created.
//
//-------------------------------------------------------------
template <class T> inline DWORD CSimpArray<T>::Size()
{
    return m_dwArrayValidSize;
}
#endif //__SIMPARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\catglobals.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catglobals.cpp
//
// Contents: Utility functions for global variable init/deinit
//
// Functions: CatInitGlobals
//            CatDeinitGlobals
//
// History:
// jstamerj 1999/03/03 12:58:05: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

//
// Global variables:
//
CExShareLock     g_InitShareLock;
DWORD            g_InitRefCount = 0;


//+------------------------------------------------------------
//
// Function: CatInitGlobals
//
// Synopsis: Initialize the global variables
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/03 12:59:21: Created.
//
//-------------------------------------------------------------
HRESULT CatInitGlobals()
{
    HRESULT hr = S_OK;
    BOOL fGlobalInit = FALSE;
    BOOL fStoreInit = FALSE;

    g_InitShareLock.ExclusiveLock();

    if(g_InitRefCount == 0) {

        fGlobalInit = TRUE;
     
        hr = CatStoreInitGlobals();
        if(FAILED(hr))
            goto CLEANUP;
        
        fStoreInit = TRUE;
    }

 CLEANUP:
    if(SUCCEEDED(hr)) {
        g_InitRefCount++;
    } else if(FAILED(hr) && fGlobalInit) {
        //
        // Deinitialize everything we initialized
        //
        if(fStoreInit) {
            CatStoreDeinitGlobals();
        }
      
        //
        // Verify that there are no lingering objects
        //
        CatVrfyEmptyDebugObjectList();
    }
    g_InitShareLock.ExclusiveUnlock();

    return hr;
}


//+------------------------------------------------------------
//
// Function: CatDeinitGlobals
//
// Synopsis: Deinitialize the global variables
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/03 13:02:00: Created.
//
//-------------------------------------------------------------
VOID CatDeinitGlobals()
{
    g_InitShareLock.ExclusiveLock();

    if(g_InitRefCount == 1) {
        //
        // Deinit stuff
        //
        CatStoreDeinitGlobals();

       
        //
        // Verify there are no categorizer objects left in memory
        //
        CatVrfyEmptyDebugObjectList();
    }

    g_InitRefCount--;
    
    g_InitShareLock.ExclusiveUnlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\cat.cpp ===
/************************************************************
 * FILE: cat.cpp
 * PURPOSE: Here lies the code for the exported function calls
 *          of the message categorizer
 * HISTORY:
 *  // jstamerj 980211 13:52:50: Created
 ************************************************************/
#include "precomp.h"
#include "catutil.h"
#include "address.h"

/************************************************************
 * FUNCTION: CatInit
 * DESCRIPTION: Initialzies a virtual Categorizer.
 * PARAMETERS:
 *   pszConfig: Indicates where to find configuration defaults
 *              Config info found in key
 *              HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
 *              \PlatinumIMC\CatSources\szConfig
 *
 *   phCat:    Pointer to a handle.  Upon successfull initializtion,
 *             handle to use in subsequent Categorizer calls will be
 *             plcaed there.
 *
 *   pAQConfig: pointer to an AQConfigInfo structure containing
 *              per virtual server message cat parameters
 *
 *   pfn: Service routine for periodic callbakcs if any time consuming
 *        operations are performed
 *
 *   pServiceContext: Context for the pfn function.
 *
 *   pISMTPServer: ISMTPServer interface to use for triggering server
 *                 events for this virtual server
 *
 *   pIDomainInfo: pointer to an interface that contains domain info
 *
 *   dwVirtualServerInstance: Virtual Server ID
 *
 * Return value: S_OK if everything is initialized okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:26: Created
 *   // jstamerj 1998/06/25 12:25:34: Added AQConfig/IMSTPServer.
 *
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatInit(
    IN  AQConfigInfo *pAQConfig,
    IN  PCATSRVFN_CALLBACK pfn,
    IN  PVOID pvServiceContext,
    IN  ISMTPServer *pISMTPServer,
    IN  IAdvQueueDomainType *pIDomainInfo,
    IN  DWORD dwVirtualServerInstance,
    OUT HANDLE *phCat)
{
    HRESULT hr;
    CCATCONFIGINFO ConfigInfo;
    CABContext *pABContext = NULL;
    BOOL fGlobalsInitialized = FALSE;

    CatFunctEnter("CatInit");

    _ASSERT(phCat);

    hr = CatInitGlobals();
    if(FAILED(hr)) {

        FatalTrace(NULL, "CatInitGlobals failed hr %08lx", hr);
        goto CLEANUP;
    }

    fGlobalsInitialized = TRUE;

    //
    // Fill in the config info struct based on AQConfigInfo only
    //
    hr = GenerateCCatConfigInfo(
        &ConfigInfo,
        pAQConfig,
        pISMTPServer,
        pIDomainInfo,
        &dwVirtualServerInstance);

    pABContext = new CABContext;
    if(pABContext == NULL) {
        FatalTrace(NULL, "Out of memory allocating CABContext");
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    hr = pABContext->ChangeConfig(&ConfigInfo);
    if(FAILED(hr)) {
        FatalTrace(NULL, "ChangeConfig failed hr %08lx", hr);
        goto CLEANUP;
    }

    *phCat = (HANDLE) pABContext;

 CLEANUP:
    if(FAILED(hr)) {

        if(pABContext)
            delete pABContext;

        if(fGlobalsInitialized) {

            if (ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ISMTPSERVER) {

                CatLogEvent(
                    ConfigInfo.pISMTPServer,
                    CAT_EVENT_CANNOT_START,     // Event ID
                    0,                          // cSubStrings
                    NULL,                       // rgszSubstrings,
                    hr,                         // error code
                    "",                         // szKey
                    LOGEVENT_FLAG_ALWAYS,       // dwOptions
                    LOGEVENT_LEVEL_MINIMUM      // iDebugLevel
                    );
            }

            CatDeinitGlobals();
        }
    }

    DebugTrace(NULL, "CatInit returning hr %08lx", hr);
    CatFunctLeave();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CatChangeConfig
//
// Synopsis: Changes the configuration of a virtual categorizer
//
// Arguments:
//   hCat: handle of virtual categorizer
//   pAQConfig: AQConfigInfo pointer
//   pISMTPServer: ISMTPServer to use
//   pIDomainInfo: interface that contains domain information
//
//   Flags for dwMsgCatFlags in AQConfigInfo
//     MSGCATFLAG_RESOLVELOCAL             0x00000001
//     MSGCATFLAG_RESOLVEREMOTE            0x00000002
//     MSGCATFLAG_RESOLVESENDER            0x00000004
//     MSGCATFLAG_RESOLVERECIPIENTS        0x00000008
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: Invalid hCat or pAQConfig
//
// History:
// jstamerj 980521 15:47:42: Created.
//
//-------------------------------------------------------------
CATEXPDLLCPP HRESULT CATCALLCONV CatChangeConfig(
    IN HANDLE hCat,
    IN AQConfigInfo *pAQConfig,
    IN ISMTPServer *pISMTPServer,
    IN IAdvQueueDomainType *pIDomainInfo)
{
    HRESULT hr;
    CCATCONFIGINFO ConfigInfo;

    CatFunctEnterEx((LPARAM)hCat, "CatChangeConfig");

    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE) ||
       (pAQConfig == NULL)) {
        DebugTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        return E_INVALIDARG;
    }

    // Check to see if any cat flags are even set here...
    if(pAQConfig->dwAQConfigInfoFlags & CAT_AQ_CONFIG_INFO_CAT_FLAGS) {

        //
        // Fill in the config info struct based on AQConfigInfo only
        //
        hr = GenerateCCatConfigInfo(
            &ConfigInfo,
            pAQConfig,
            pISMTPServer,
            pIDomainInfo,
            NULL);

        if(FAILED(hr)) {
            ErrorTrace(NULL, "GenerateCCatConfigInfo returned hr %08lx", hr);
            CatFunctLeave();
            return hr;
        }

        CABContext *pABCtx = (CABContext *) hCat;

        CatFunctLeaveEx((LPARAM)hCat);
        return pABCtx->ChangeConfig(&ConfigInfo);

    } else {
        //
        // No revelant categorizer changes detected
        //
        return S_OK;
    }
}

/************************************************************
 * FUNCTION: CatTerm
 * DESCRIPTION: Called when user wishes to terminate categorizer
 *              opertions with this handle
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 980217 15:47:20: Created
 ************************************************************/
CATEXPDLLCPP VOID CATCALLCONV CatTerm(HANDLE hCat)
{
    CatFunctEnterEx((LPARAM)hCat, "CatTerm");
    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        DebugTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
    } else {
        CABContext *pABContext = (CABContext *) hCat;
        delete pABContext;
    }
    CatDeinitGlobals();
    CatFunctLeave();
}

/************************************************************
 * FUNCTION: CatMsg
 * DESCRIPTION: Accepts an IMsg object for async categorization
 * PARAMETERS:
 *   hCat:     Handle returned from CatInit
 *   pImsg:    IMsg interface for message to categorize
 *   pfn:      Completion routine to call when finished
 *   pContext: User value passed to completion routine
 *
 * Return value:
 *  S_OK: Success, will call async completion
 *  Other error: Unable to asynchronously complete the categorization
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:15: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatMsg(HANDLE hCat, /* IN */ IUnknown *pIMsg, PFNCAT_COMPLETION pfn, LPVOID pContext)
{
    HRESULT hr;

    CABContext *pABCtx = (CABContext *) hCat;
    CCategorizer *pCCat = NULL;
    PCATMSG_CONTEXT pCatContext = NULL;
    BOOL fAsync = FALSE;

    CatFunctEnterEx((LPARAM)hCat, "CatMsg");

    _ASSERT(pIMsg);
    _ASSERT(pfn);

    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        ErrorTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    pCCat = pABCtx->AcquireCCategorizer();
    _ASSERT(pCCat);

    if(pCCat == NULL || !pCCat->IsCatEnabled()) {

#ifdef PLATINUM
        //
        // Return retry code for benefit of store driver so that message
        // is put in the precat queue instead of being routed to the  MTA
        // that would happen if we returned hr = S_OK. This should only
        // happen in Platinum's phatq.dll and not in aqueue.dll.
        //
        hr = CAT_E_RETRY;
#else
        //
        // Categorization is disabled on this virtual server.  Just call
        // the completion routine inline.
        //
       _VERIFY( SUCCEEDED( pfn(
           S_OK,
           pContext,
           pIMsg,
           NULL)));
        hr = S_OK;
#endif

        goto CLEANUP;
    }

    //
    // Check and see if we really need to categorize this message
    //
    // Has categorization already been done?
    //
    hr = CheckMessageStatus(pIMsg);

    if(hr == S_FALSE) {

        DebugTrace((LPARAM)hCat, "This message has already been categorized.");
        //
        // Call completion routine directly
        //
        _VERIFY( SUCCEEDED( pfn(
            S_OK,
            pContext,
            pIMsg,
            NULL)));

        hr = S_OK;
        goto CLEANUP;

    } else if(FAILED(hr)) {

        ErrorTrace((LPARAM)hCat, "CheckMessageStatus failed hr %08lx", hr);
        goto CLEANUP;
    }


    pCatContext = new CATMSG_CONTEXT;
    if(pCatContext == NULL) {

        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

#ifdef DEBUG
    pCatContext->lCompletionRoutineCalls = 0;
#endif

    pCatContext->pCCat = pCCat;
    pCatContext->pUserContext = pContext;
    pCatContext->pfnCatCompletion = pfn;

    hr = pCCat->AsyncResolveIMsg(
        pIMsg,
        CatMsgCompletion,
        pCatContext);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)hCat, "AsyncResolveIMsg failed, hr %08lx", hr);
        goto CLEANUP;
    }
    fAsync = TRUE;
    _ASSERT(hr == S_OK);

 CLEANUP:
    //
    // If we're not async, cleanup.  Else, the CatMsgCompletion will
    // clean this stuff up
    //
    if(fAsync == FALSE) {
        //
        // Release the CCategorizer object
        //
        if(pCCat)
            pCCat->Release();
        if(pCatContext)
            delete pCatContext;
    }
    DebugTrace((LPARAM)hCat, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)hCat);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CatMsgCompletion
//
// Synopsis: This is a wrapper function for AQueue's CatCompletion.
//
// Arguments:
//
// Returns:
//  Result of completion routine
//
// History:
// jstamerj 1998/08/03 19:28:32: Created.
//
//-------------------------------------------------------------
HRESULT CatMsgCompletion(
    HRESULT hr,
    PVOID pContext,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
  HRESULT hrResult;
  PCATMSG_CONTEXT pCatContext = (PCATMSG_CONTEXT)pContext;
#ifdef DEBUG
  _ASSERT((InterlockedIncrement(&(pCatContext->lCompletionRoutineCalls)) == 1) &&
          "Possible out of style wldap32.dll detected");
#endif
  _ASSERT(ISHRESULT(hr));

  CatFunctEnter("CatMsgCompletion");

  hrResult = pCatContext->pfnCatCompletion(
      hr,
      pCatContext->pUserContext,
      pIMsg,
      rgpIMsg);

  //
  // Release the reference to CCategorizer added in CatMsg
  //
  pCatContext->pCCat->Release();

  delete pCatContext;

  CatFunctLeave();
  return hrResult;
}


/************************************************************
 * FUNCTION: CatDLMsg
 * DESCRIPTION: Accepts an IMsg object for async categorization
 * PARAMETERS:
 *   hCat:     Handle returned from CatInit
 *   pImsg:    IMsg interface to categorize -- each DL should be a recip
 *   pfn:      Completion routine to call when finished
 *   pContext: User value passed to completion routine
 *   fMatchOnly: Stop resolving when a match is found?
 *   CAType:   The address type of pszAddress
 *   pszAddress: THe address you are looking for
 *
 * Return value: S_OK if everything is okay.
 *
 * HISTORY:
 *   // jstamerj 980217 15:46:15: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatDLMsg (
    /* IN  */ HANDLE hCat,
    /* IN  */ IUnknown *pImsg,
    /* IN  */ PFNCAT_DLCOMPLETION pfn,
    /* IN  */ LPVOID pUserContext,
    /* IN  */ BOOL fMatchOnly,
    /* IN  */ CAT_ADDRESS_TYPE CAType,
    /* IN  */ LPSTR pszAddress)
{
    HRESULT hr = S_OK;
    PCATDLMSG_CONTEXT pContext = NULL;
    CABContext *pABCtx = (CABContext *) hCat;

    CatFunctEnterEx((LPARAM)hCat, "CatDLMsg");

    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        ErrorTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        return E_INVALIDARG;
    }

    pContext = new CATDLMSG_CONTEXT;
    if(pContext == NULL) {

        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }

    pContext->pCCat = pABCtx->AcquireCCategorizer();
    _ASSERT(pContext->pCCat);

    pContext->pUserContext = pUserContext;
    pContext->pfnCatCompletion = pfn;
    pContext->fMatch = FALSE;

    _VERIFY(SUCCEEDED(
        pContext->pCCat->AsyncResolveDLs(
            pImsg,
            CatDLMsgCompletion,
            pContext,
            fMatchOnly,
            &(pContext->fMatch),
            CAType,
            pszAddress)));

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)hCat, "calling completion with hr %08lx", hr);
        //
        // Call completion routine directly
        //
        _VERIFY( SUCCEEDED( pfn(
            hr,
            pUserContext,
            pImsg,
            FALSE)));

        if(pContext) {
            if(pContext->pCCat)
                pContext->pCCat->Release();

            delete pContext;
        }
    }
    CatFunctLeaveEx((LPARAM)hCat);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CatDLMsgCompletion
//
// Synopsis: handle completion of a DL expansion
//
// Arguments:
//  hrStatus: resolution status
//  pContext: context passed to CatDLMsg
//  pIMsg: the categorized mailmsg
//  rgpIMsg: should always be NULL
//
// Returns:
//  the return value of the user completion routine
//
// History:
// jstamerj 1998/12/07 17:46:46: Created.
//
//-------------------------------------------------------------
HRESULT CatDLMsgCompletion(
    HRESULT hrStatus,
    PVOID pContext,
    IUnknown *pIMsg,
    IUnknown **prgpIMsg)
{
    HRESULT hr;
    PCATDLMSG_CONTEXT pCatContext;

    CatFunctEnter("CatDLMsgCompletion");

    pCatContext = (PCATDLMSG_CONTEXT) pContext;

    _ASSERT(pCatContext);
    _ASSERT(prgpIMsg == NULL);

    hr = pCatContext->pfnCatCompletion(
        hrStatus,
        pCatContext->pUserContext,
        pIMsg,
        pCatContext->fMatch);

    pCatContext->pCCat->Release();

    delete pCatContext;

    DebugTrace(NULL, "returning hr %08lx", hr);
    CatFunctLeave();
    return hr;
}


/************************************************************
 * FUNCTION: CatCancel
 * DESCRIPTION: Cancels pending searches for this hCat.  User's
 *              completion routine will be called with an error for
 *              each pending message.
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 980217 15:52:10: Created
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatCancel(/* IN  */ HANDLE hCat)
{
    CatFunctEnterEx((LPARAM)hCat, "CatCancel");
    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        DebugTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        return E_INVALIDARG;
    }

    CCategorizer *pCCat;
    CABContext *pABCtx = (CABContext *) hCat;

    pCCat = pABCtx->AcquireCCategorizer();

    if(pCCat) {

      pCCat->Cancel();

      pCCat->Release();
    }
    CatFunctLeave();
    return S_OK;
}

/************************************************************
 * FUNCTION: CatPrepareForShutdown
 * DESCRIPTION: Begin shutdown for this virtual categorizer (hCat).
 *              Stop accepting messages for categorization and cancel
 *              pending categorizations.
 * PARAMETERS:
 *   hCat:      Categorizer handle received from CatInit
 *
 * HISTORY:
 *   // jstamerj 1999/07/19 22:35:17: Created
 ************************************************************/
CATEXPDLLCPP VOID CATCALLCONV CatPrepareForShutdown(/* IN  */ HANDLE hCat)
{
    CatFunctEnterEx((LPARAM)hCat, "CatPrepareForShutdown");
    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE)) {
        DebugTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");

    } else {

        CCategorizer *pCCat;
        CABContext *pABCtx = (CABContext *) hCat;

        pCCat = pABCtx->AcquireCCategorizer();

        if(pCCat) {

            pCCat->PrepareForShutdown();
            pCCat->Release();
        }
    }
    CatFunctLeaveEx((LPARAM)hCat);
}

/************************************************************
 * FUNCTION: CatVerifySMTPAddress
 * DESCRIPTION: Verifies a the address corresponds to a valid user or DL
 * PARAMETERS:
 *  hCat:       Categorizer handle received from CatInit
 *  szSMTPAddr  SMTP Address to lookup (ex: "user@domain")
 *
 * Return Values:
 *  S_OK            User exists
 *  CAT_I_DL        This is a distribution list
 *  CAT_I_FWD       This user has a forwarding address
 *  CAT_E_NORESULT  There is no such user/distribution list in the DS.
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatVerifySMTPAddress(
  /* IN  */ HANDLE hCat,
  /* IN  */ LPTSTR szSMTPAddr)
{
    //$$TODO: Implement this function.
    // Pretend this is a valid user for now.
    return S_OK;
}

/************************************************************
 * FUNCTION: CatGetForwaringSMTPAddress
 * DESCRIPTION: Retreive a user's forwarding address.
 * PARAMETERS:
 *  hCat:           Categorizer handle received from CatInit
 *  szSMTPAddr:     SMTP Address to lookup (ex: "user@domain")
 *  pdwcc:          Size of forwarding address buffer in Chars
 *                  (This is set to actuall size of forwarding address
 *                   string (including NULL terminator) on exit)
 *  szSMTPForward:  Buffer where retreived forwarding SMTP address
 *                  will be copied. (can be NULL if *pdwcc is zero)
 *
 * Return Values:
 *  S_OK            Success
 *  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
 *                  *pdwcc was not large enough to hold the forwarding
 *                  address string.
 * CAT_E_DL         This is a distribution list.
 * CAT_E_NOFWD      This user does not have a forwarding address.
 * CAT_E_NORESULT   There is no such user/distribution list in the DS.
 ************************************************************/
CATEXPDLLCPP HRESULT CATCALLCONV CatGetForwardingSMTPAddress(
  /* IN  */    HANDLE  hCat,
  /* IN  */    LPCTSTR szSMTPAddr,
  /* IN,OUT */ PDWORD  pdwcc,
  /* OUT */    LPTSTR  szSMTPForward)
{
    //$$TODO: Implement this function
    // Pretend this is a valid user with no forwarding address for now.
    return CAT_E_NOFWD;
}


//+------------------------------------------------------------
//
// Function: CheckMessageStatus
//
// Synopsis: Check to see if this message has already been categorized
//
// Arguments: pIMsg: IUnknown to the mailmsg
//
// Returns:
//  S_OK: Success, not categorized yet
//  S_FALSE: Succes, already categorized
//  or error from MailMsg
//
// History:
// jstamerj 1998/08/03 19:15:49: Created.
//
//-------------------------------------------------------------
HRESULT CheckMessageStatus(
    IUnknown *pIMsg)
{
    HRESULT hr;
    IMailMsgProperties *pIProps = NULL;
    DWORD dwMsgStatus;

    _ASSERT(pIMsg);

    hr = pIMsg->QueryInterface(
        IID_IMailMsgProperties,
        (PVOID *) &pIProps);

    if(FAILED(hr))
        return hr;

    hr = pIProps->GetDWORD(
        IMMPID_MP_MESSAGE_STATUS,
        &dwMsgStatus);

    if(hr == CAT_IMSG_E_PROPNOTFOUND) {
        //
        // Assume the message has not been categorized
        //
        hr = S_OK;

    } else if(SUCCEEDED(hr)) {
        //
        // If status is >= CATEGORIZED, this message has already been categorized
        //
        if(dwMsgStatus >= MP_STATUS_CATEGORIZED) {

            hr = S_FALSE;

        } else {

            hr = S_OK;
        }
    }
    pIProps->Release();

    return hr;
}


//+------------------------------------------------------------
//
// Function: GenerateCCatConfigInfo
//
// Synopsis: Translate an AQConfigInfo and interface parameters into a
//           CCatConfigInfo.  No memory allocations are done and no
//           interfaces are AddRef'd.
//
// Arguments:
//  pCatConfig: CCATCONFIGINFO struct to fill in
//  pAQConfig: AQConfigInfo struct to get paramters from (can be NULL)
//  pISMTPServer: ISMTPServer to use (can be NULL)
//  pIDomainInfo: IAdvQueueDomainInfo to use (can be NULL)
//  pdwVSID: Pointer to DWORD containing the virtual server ID or NULL if not specified
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/14 19:14:52: Created.
//
//-------------------------------------------------------------
HRESULT GenerateCCatConfigInfo(
    PCCATCONFIGINFO pCatConfig,
    AQConfigInfo *pAQConfig,
    ISMTPServer *pISMTPServer,
    IAdvQueueDomainType *pIDomainInfo,
    DWORD *pdwVSID)
{
    HRESULT     hr      =   S_OK;

    CatFunctEnter("GenerateCCatConfigInfo");

    _ASSERT(pCatConfig);

    ZeroMemory(pCatConfig, sizeof(CCATCONFIGINFO));

    //
    // Copy the interface pointers first
    //
    if(pISMTPServer) {

        pCatConfig->dwCCatConfigInfoFlags |= CCAT_CONFIG_INFO_ISMTPSERVER;
        pCatConfig->pISMTPServer = pISMTPServer;
    }

    if(pIDomainInfo) {

        pCatConfig->dwCCatConfigInfoFlags |= CCAT_CONFIG_INFO_IDOMAININFO;
        pCatConfig->pIDomainInfo = pIDomainInfo;
    }

    if(pdwVSID) {

        pCatConfig->dwCCatConfigInfoFlags |= CCAT_CONFIG_INFO_VSID;
        pCatConfig->dwVirtualServerID = *pdwVSID;
    }

    if(pAQConfig) {
        //
        // Copy over flags without struct members
        //
        if(pAQConfig->dwAQConfigInfoFlags & AQ_CONFIG_INFO_MSGCAT_DEFAULT) {
            pCatConfig->dwCCatConfigInfoFlags |= CCAT_CONFIG_INFO_DEFAULT;
        }

        //
        // Copy over the struct members if specified
        //
        #define COPYMEMBER( AQFlag, AQMember, CatFlag, CatMember ) \
            if(pAQConfig->dwAQConfigInfoFlags & AQFlag) { \
                pCatConfig->dwCCatConfigInfoFlags |= CatFlag; \
                pCatConfig->CatMember = pAQConfig->AQMember; \
            }

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_DOMAIN, szMsgCatDomain,
                    CCAT_CONFIG_INFO_BINDDOMAIN, pszBindDomain );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_USER, szMsgCatUser,
                    CCAT_CONFIG_INFO_USER, pszUser );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_PASSWORD, szMsgCatPassword,
                    CCAT_CONFIG_INFO_PASSWORD, pszPassword );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_BINDTYPE, szMsgCatBindType,
                    CCAT_CONFIG_INFO_BINDTYPE, pszBindType );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_SCHEMATYPE, szMsgCatSchemaType,
                    CCAT_CONFIG_INFO_SCHEMATYPE, pszSchemaType );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_HOST, szMsgCatHost,
                    CCAT_CONFIG_INFO_HOST, pszHost );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_PORT, dwMsgCatPort,
                    CCAT_CONFIG_INFO_PORT, dwPort);

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_FLAGS, dwMsgCatFlags,
                    CCAT_CONFIG_INFO_FLAGS, dwCatFlags );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_ENABLE, dwMsgCatEnable,
                    CCAT_CONFIG_INFO_ENABLE, dwEnable );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_NAMING_CONTEXT, szMsgCatNamingContext,
                    CCAT_CONFIG_INFO_NAMINGCONTEXT, pszNamingContext );

        COPYMEMBER( AQ_CONFIG_INFO_MSGCAT_TYPE, szMsgCatType,
                    CCAT_CONFIG_INFO_ROUTINGTYPE, pszRoutingType );

        COPYMEMBER( AQ_CONFIG_INFO_DEFAULT_DOMAIN, szDefaultLocalDomain,
                    CCAT_CONFIG_INFO_DEFAULTDOMAIN, pszDefaultDomain );

    }

    return hr;
}


//+------------------------------------------------------------
//
// Function: CatGetPerfCounters
//
// Synopsis: Retrieve the categorizer performance counter block
//
// Arguments:
//  pCatPerfBlock: struct to fill in with counter values
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1999/02/26 14:53:21: Created.
//
//-------------------------------------------------------------
HRESULT CatGetPerfCounters(
    HANDLE hCat,
    PCATPERFBLOCK pCatPerfBlock)
{
    CABContext *pABCtx = (CABContext *) hCat;
    CCategorizer *pCCat = NULL;

    CatFunctEnterEx((LPARAM)hCat, "CatGetPerfBlock");

    if((hCat == NULL) ||
       (hCat == INVALID_HANDLE_VALUE) ||
       (pCatPerfBlock == NULL)) {
        ErrorTrace((LPARAM)hCat, "Invalid hCat - returning E_INVALIDARG");
        return E_INVALIDARG;
    }

    pCCat = pABCtx->AcquireCCategorizer();

    if(pCCat == NULL) {

        ZeroMemory(pCatPerfBlock, sizeof(CATPERFBLOCK));

    } else {

        pCCat->GetPerfCounters(
            pCatPerfBlock);
        pCCat->Release();
    }
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CatLogEvent
//
// Synopsis: Log an event to the event log
//
// Arguments:
//  pISMTPServer: ISMTPServer interface to use for logging
//
// Returns:
//  S_OK: Success
//
// History:
// dbraun 2000/09/13 : Created.
//
//-------------------------------------------------------------
HRESULT CatLogEvent(
    ISMTPServer              *pISMTPServer,
    DWORD                    idMessage,
    WORD                     cSubstrings,
    LPCSTR                   *rgszSubstrings,
    DWORD                    errCode,
    LPCSTR                   szKey,
    DWORD                    dwOptions,
    WORD                     iDebugLevel,
    DWORD                    iMessageString)
{
    HRESULT         hr              = S_OK;
    ISMTPServerEx   *pISMTPServerEx = NULL;

    CatFunctEnter("CatLogEvent");

    if(NULL == pISMTPServer)
    {
        //
        // No events today...
        //
        ErrorTrace((LPARAM)0, "Unable to log event 0x%08lx; pISMTPServerEx is NULL",
                   idMessage);
        goto CLEANUP;
    }

    // Get the ISMTPServerEx interface for triggering log events
    hr = pISMTPServer->QueryInterface(
        IID_ISMTPServerEx,
        (LPVOID *)&pISMTPServerEx);

    if (FAILED(hr)) {

        ErrorTrace((LPARAM)pISMTPServer, "Unable to QI for ISMTPServerEx 0x%08X",hr);
        //
        //  Don't bubble up this error.  A failure to log is not what the 
        //  caller cares about
        //
        hr = S_OK; 
        pISMTPServerEx = NULL;
        goto CLEANUP;
    }

    if(pISMTPServerEx)
    {
        hr = CatLogEvent(
            pISMTPServerEx,
            idMessage,
            cSubstrings,
            rgszSubstrings,
            errCode,
            szKey,
            dwOptions,
            iDebugLevel,
            iMessageString);

        pISMTPServerEx->Release();
    }

 CLEANUP:
    CatFunctLeave();
    return hr;
}


HRESULT CatLogEvent(
    IN  ISMTPServerEx            *pISMTPServerEx,
    IN  DWORD                    idMessage,
    IN  WORD                     cSubStrings,
    IN  LPCSTR                   *rgpszSubStrings,
    IN  DWORD                    errCode,
    IN  LPCSTR                   pszKey,
    IN  DWORD                    dwOptions,
    IN  WORD                     wLogLevel,
    IN  DWORD                    iMessageString)
{
    HRESULT hr = S_OK;
    WORD wType = 0;

    CatFunctEnter("CatLogEvent - 2");

    if(NULL == pISMTPServerEx)
    {
        //
        // No events today...
        //
        ErrorTrace((LPARAM)0, "Unable to log event 0x%08lx; pISMTPServerEx is NULL",
                   idMessage);
        goto CLEANUP;
    }
    //
    // Map the severity of idMessage to an eventlog type
    //
    switch( (idMessage >> 30) & 0x3)
    {
     case 1:
         wType = EVENTLOG_INFORMATION_TYPE;
         break;
     case 2:
         wType = EVENTLOG_WARNING_TYPE;
         break;
     default:
         wType = EVENTLOG_ERROR_TYPE;
    }

    hr = pISMTPServerEx->TriggerLogEvent(
        idMessage,
        TRAN_CAT_CATEGORIZER,
        cSubStrings,
        rgpszSubStrings,
        wType,
        errCode,
        wLogLevel,
        pszKey,
        dwOptions,
        iMessageString,
        GetModuleHandle(AQ_MODULE_NAME));

    if(FAILED(hr))
    {
        FatalTrace((LPARAM)0, "Failed to log event # 0x%08lx, hr 0x%08lx",
                   idMessage, hr);
    }

 CLEANUP:
    CatFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ccat.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1988, Microsoft Corporation
//
// FILE: ccat.cpp
//
// CONTENTS: This file contains the class members for:
//
// Classes: CCategorizer (Common categorizer code)
//
// Functions:
//
// History:
// jstamerj 980305 14:26:27: Created
//
//------------------------------------------------------------

#include "precomp.h"
#include "icatparam.h"
#include "ldapstr.h"
#include "catglobals.h"
#include <aqerr.h>

//+------------------------------------------------------------
//
// Function: CCategorizer::AddRef
//
// Synopsis: Increase the internal refcount
//
// Arguments: None
//
// Returns: New refcount
//
// History:
// jstamerj 1998/09/08 14:58:23: Created.
//
//-------------------------------------------------------------
LONG CCategorizer::AddRef()
{
    return InterlockedIncrement(&m_lRefCount);
}


//+------------------------------------------------------------
//
// Function: CCategorizer::Release()
//
// Synopsis: Decreases the internal refcount.  Delete's this object
// when refcount hits zero
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/08 14:59:11: Created.
//
//-------------------------------------------------------------
LONG CCategorizer::Release()
{
    LONG lNewRefCount;

    lNewRefCount = InterlockedDecrement(&m_lRefCount);

    if(lNewRefCount == 0) {

        if(m_lDestructionWaiters) {
            //
            // Threads are waiting on the destruction event, so let
            // the last thread to wakeup delete this object
            //
            _ASSERT(m_hShutdownEvent != INVALID_HANDLE_VALUE);
            _VERIFY(SetEvent(m_hShutdownEvent));

        } else {
            //
            // Nobody is waiting, so delete this object
            //
            delete this;
        }
    }

    return lNewRefCount;
}



//+------------------------------------------------------------
//
// Function: ReleaseAndWaitForDestruction
//
// Synopsis: Release a callers refcount and wait for the object's
// refcount to drop to zero before returning
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 1998/09/09 16:44:46: Created.
//
//-------------------------------------------------------------
VOID CCategorizer::ReleaseAndWaitForDestruction()
{
    DWORD dw;

    CatFunctEnterEx((LPARAM)this,
                      "CCategorizer::ReleaseAndWaitForDestruction");

    _ASSERT(m_hShutdownEvent != INVALID_HANDLE_VALUE);

    //
    // Increment the count of threads waiting for destruction
    //
    InterlockedIncrement(&m_lDestructionWaiters);

    //
    // Release our refcount; if the new refcount is zero, this object
    // will NOT be deleted; instead m_hShutdownEvent will be set
    //
    Release();

    //
    // Wait for all refcounts to be released. Update hints every 10 seconds
    //

    do {

        dw = WaitForSingleObject(
                m_hShutdownEvent,
                10000);

        if (m_ConfigInfo.pISMTPServer != NULL) {

            m_ConfigInfo.pISMTPServer->ServerStopHintFunction();

        }

    } while ( dw == WAIT_TIMEOUT );

    _ASSERT(WAIT_OBJECT_0 == dw);

    //
    // Decrement the number of threads waiting for termination; if we
    // are the last thread to leave here, we need to delete this
    // object
    //
    if( InterlockedDecrement(&m_lDestructionWaiters) == 0) {

        delete this;
    }
}

//+------------------------------------------------------------
//
// Function: CCategorizer::Initialize
//
// Synopsis: Initialize data structures for the Categoirzer.  This is
//           done during SMTPSVC startup
//
// Arguments:
//  pConfigInfo: Cat config info structure.
//  dwICatItemPropIDs: Initial number of props/ICatItem
//  dwICatListResolvePropIDs: Initial number of props/ICatListResolve
//
// Returns:
//  S_OK: Successfully initialized
//  E_INVALIDARG: Not all required arguments specified
//  otherwise, returns error from store.
//
//-------------------------------------------------------------
HRESULT CCategorizer::Initialize(
    PCCATCONFIGINFO pConfigInfo,
    DWORD dwICatItemPropIDs,
    DWORD dwICatListResolvePropIDs)
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this, "CCategorizer::Initialize");

    m_cICatParamProps = dwICatItemPropIDs;
    m_cICatListResolveProps = dwICatListResolvePropIDs;

    m_hShutdownEvent = CreateEvent(
        NULL,       // Security attributes
        TRUE,       // fManualReset
        FALSE,      // Initial state is NOT signaled
        NULL);      // No name

    if(NULL == m_hShutdownEvent) {

        hr = HRESULT_FROM_WIN32(GetLastError());

        //
        // Remember that m_hShutdownEvent is invalid
        //
        m_hShutdownEvent = INVALID_HANDLE_VALUE;

        ERROR_LOG("CreateEvent");
        goto CLEANUP;
    }

    //
    // Create an EmailIDStore
    //
    hr = ::GetEmailIDStore( &m_pStore );
    ERROR_CLEANUP_LOG("GetEmailIDStore");
    _ASSERT(m_pStore);
    //
    // Copy the config info structure to class structure.  Use default
    // values for anything not specified
    //
    hr = CopyCCatConfigInfo(pConfigInfo);
    ERROR_CLEANUP_LOG("CopyCCatConfigInfo");

 CLEANUP:
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: DelayedInitialize
//
// Synopsis: This function will get called on the first regular
//           operation on this virtual server (ie. CatMsg).  Anything
//           that we don't want to run while SMTPSVC is starting but
//           DO want to run before any categorizations goes here
//           (ie. Triggering the Register server event).
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  CAT_E_INIT_FAILED
//
// History:
// jstamerj 1998/09/16 10:52:20: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::DelayedInitialize()
{
    HRESULT hr = S_OK;
    CICategorizerParametersIMP *pICatParamsIMP = NULL;

    CatFunctEnterEx((LPARAM)this, "CCategorizer::DelayedInitialize");

    if(m_pICatParams == NULL) {
        //
        // Create ICategorizerParams using our implementation, the fast way,
        // and add a refcount to it (us)
        //
        pICatParamsIMP = new CICategorizerParametersIMP(
            GetCCatConfigInfo(),
            m_cICatParamProps,
            m_cICatListResolveProps,
            GetISMTPServerEx());

        if(pICatParamsIMP == NULL) {
            ErrorTrace((LPARAM)this, "Out of memory created ICatParams");
            hr = E_OUTOFMEMORY;
            ERROR_LOG("new CICategorizerParametersIMP");
            goto CLEANUP;
        }

        _ASSERT(m_pICatParams == NULL);
        m_pICatParams = pICatParamsIMP;
        m_pICatParams->AddRef();

        // Use the next property after those defined in smtpevent.idl
        m_dwICatParamSystemProp_CCatAddr = _ICATEGORIZERITEM_ENDENUMMESS;
    }

    if((m_dwInitFlags & INITFLAG_REGISTER) == 0) {
        //
        // Set all the ICatParams before triggereing the event so that all
        // sinks will have access to the parameters
        //
        hr = Register();
        ERROR_CLEANUP_LOG("Register");
        m_dwInitFlags |= INITFLAG_REGISTER;
    }

    if((m_dwInitFlags & INITFLAG_REGISTEREVENT) == 0) {
        //
        // Trigger OnCategorizeRegisterEvent
        //
        EVENTPARAMS_CATREGISTER Params;
        Params.pICatParams = m_pICatParams;
        Params.pfnDefault = MailTransport_Default_CatRegister;
        Params.pszSourceLine = NULL;
        Params.pvCCategorizer = (PVOID)this;
        Params.hrSinkStatus = S_OK;

        if(m_ConfigInfo.pISMTPServer) {

            hr = m_ConfigInfo.pISMTPServer->TriggerServerEvent(
                SMTP_MAILTRANSPORT_CATEGORIZE_REGISTER_EVENT,
                &Params);

        } else {
            hr = E_NOTIMPL;
        }

        if(hr == E_NOTIMPL) {
            //
            // No events, call default processing directly
            //
            MailTransport_Default_CatRegister(
                S_OK,
                &Params);
            hr = S_OK;
        }
        ERROR_CLEANUP_LOG("TriggerServerEvent(Register)");

        if(FAILED(Params.hrSinkStatus)) {
            LPCSTR psz;
            CHAR szErrorCode[32];

            ErrorTrace((LPARAM)this, "A sink failed to initialize hr %08lx", hr);
            hr = Params.hrSinkStatus;


            _snprintf(szErrorCode, sizeof(szErrorCode),
                      "0x%08lx",
                      hr);

            psz = szErrorCode;
            //
            // Event log
            //
            if (m_ConfigInfo.pISMTPServer) {

                CatLogEvent(
                    m_ConfigInfo.pISMTPServer,
                    CAT_EVENT_SINK_INIT_FAILED, // Event ID
                    1,                          // cSubString
                    &psz,                       // rgszSubstrings,
                    hr,
                    szErrorCode,                // szKey
                    LOGEVENT_FLAG_PERIODIC,     // dwOptions
                    LOGEVENT_LEVEL_MINIMUM      // iDebugLevel
                );
            }
            goto CLEANUP;
        }
        //
        // Change ICategorizerParams to be read only
        //
        pICatParamsIMP = (CICategorizerParametersIMP *)m_pICatParams;
        pICatParamsIMP->SetReadOnly(TRUE);

        //
        // Retrieve the number of props registered and remember it
        //
        m_cICatParamProps = pICatParamsIMP->GetNumPropIds_ICatItem();

        m_cICatListResolveProps = pICatParamsIMP->GetNumPropIds_ICatListResolve();

        m_dwInitFlags |= INITFLAG_REGISTEREVENT;
    }

    if((m_dwInitFlags & INITFLAG_STORE) == 0) {
        //
        // initialize the email ID store
        //
        hr = m_pStore->Initialize(
            m_pICatParams,
            m_ConfigInfo.pISMTPServer);
        ERROR_CLEANUP_LOG("m_pStore->Initialize");
        m_dwInitFlags |= INITFLAG_STORE;
    }

 CLEANUP:
    if(FAILED(hr)) {
        LPCSTR psz;
        CHAR szErrorCode[32];

        _snprintf(szErrorCode, sizeof(szErrorCode),
                  "0x%08lx : 0x%08lx",
                  hr,
                  m_dwInitFlags);

        psz = szErrorCode;

        //
        // Event log
        //
        if (m_ConfigInfo.pISMTPServer) {

            CatLogEvent(
                m_ConfigInfo.pISMTPServer,
                CAT_EVENT_INIT_FAILED,      // Event ID
                1,                          // cSubString
                &psz,                       // rgszSubstrings,
                hr,
                szErrorCode,                // szKey
                LOGEVENT_FLAG_PERIODIC,     // dwOptions
                LOGEVENT_LEVEL_MINIMUM      // iDebugLevel
                );
        }

        hr = CAT_E_INIT_FAILED;
    }


    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//
// any error-prone shutdown that we might need to do will go here
//
HRESULT CCategorizer::Shutdown() {
    CatFunctEnter("CCategorizer::Shutdown");
    CatFunctLeave();
    return S_OK;
}

//
// -------------------------------------------------------------------------
// --- user functions                                                    ---
// -------------------------------------------------------------------------
//

BOOL CCategorizer::VerifyStringLength(LPSTR szString, DWORD dwMaxLength)
{
    if (IsBadStringPtr(szString, dwMaxLength))
        return(FALSE);
    while (dwMaxLength--)
        if (!*szString++)
            return(TRUE);
    return(FALSE);

}

//
// -------------------------------------------------------------------------
// --- resolution functions                                              ---
// -------------------------------------------------------------------------
//


//+------------------------------------------------------------
//
// Function: CCategorizer::AsyncResolveIMsg
//
// Synopsis: Accepts an IMsg for asynchronous categorization.
//
// Arguments:
//   PIMsg: IMsg to categorize
//   pfnCatCompletion: Completion routine to call when done categorizing
//   pContext: Context to call completion routine with
//
// Returns:
//  S_OK: Asyncronously categorizing message
//  error: Unable to categorize message async
//
// History:
// jstamerj 980325 17:43:48: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::AsyncResolveIMsg(
    IUnknown *pIMsg,
    PFNCAT_COMPLETION pfnCatCompletion,
    LPVOID pContext)
{
    CatFunctEnterEx((LPARAM)this, "CCategorizer::AsyncResolveIMsg");
    HRESULT hr;
    CICategorizerListResolveIMP *pCICatListResolveIMP = NULL;
    //
    // If we are totally disabled, skip all work
    //
    if(! IsCatEnabled()) {
        //
        // Skip counter increment/decrement when we are disabled by
        // calling the completion directly
        //
        _VERIFY( SUCCEEDED( pfnCatCompletion(S_OK, pContext, pIMsg, NULL)));
        hr = S_OK;
        goto CLEANUP;
    }

    INCREMENT_COUNTER(CatSubmissions);
    INCREMENT_COUNTER(CurrentCategorizations);

    if(fIsShuttingDown()) {
        hr = CAT_E_SHUTDOWN;
        ERROR_LOG("fIsShuttingDown");
        goto CLEANUP;
    }

    hr = DelayedInitializeIfNecessary();
    ERROR_CLEANUP_LOG("DelayedInitializeIfNecessary");

    //
    // Allocate pICatListResolve quick and dirty..
    //
    pCICatListResolveIMP = new (m_cICatListResolveProps) CICategorizerListResolveIMP(
        this,
        pfnCatCompletion,
        pContext);

    if(pCICatListResolveIMP == NULL) {
        ErrorTrace(0, "out of memory allocing CICategorizerListResolveIMP");
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CICategorizerListResolveIMP");
        goto CLEANUP;
    }
    //
    // The constructor of ICategorizerListResolve starts with refcount 1
    //
    hr = pCICatListResolveIMP->Initialize(pIMsg);
    ERROR_CLEANUP_LOG("pCICatListResolveIMP->Initialize");

    hr = pCICatListResolveIMP->StartMessageCategorization();
    ERROR_CLEANUP_LOG("pCICatListResolveIMP->StartMessageCategorization");

    if(hr == S_FALSE) {
        //
        // Nothing was necessary to resolve
        //
        CatCompletion(pfnCatCompletion, S_OK, pContext, pIMsg, NULL);
        hr = S_OK;
        goto CLEANUP;
    }

 CLEANUP:
    // Cleanup
    if(FAILED(hr)) {

        ErrorTrace(0, "AsyncResolveIMsg internal failure, hr %08lx", hr);
        //
        // If the above code came to here with a failed hr, that means
        // the store will not be calling our completion routine.
        // Therefore, we need to clean up our mem and return an error
        //
        ErrorTrace(0, "AsyncResolveIMsg calling completion routine with error %08lx", hr);
        //
        // Even 'tho we are returning an error, increment the counters
        // as if we were calling CatCompletion.  This also determines
        // wether or not hr is a retryable error.
        //
        hr = HrAdjustCompletionCounters(hr, pIMsg, NULL);
    }

    if(pCICatListResolveIMP)
        pCICatListResolveIMP->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CCategorizer::AsyncResolveDLs
//
// Synopsis: Accepts an IMsg for asynchronous DL categorization.
//
// Arguments:
//   PIMsg: IMsg to categorize
//   pfnCatCompletion: Completion routine to call when done categorizing
//   pContext: Context to call completion routine with
//   fMatchOnly: Do we only care about finding an address?
//   pfmatch: ptr to BOOL to set to TRUE if match is found
//   CAType: address type you're looking for
//   pszAddress: address you're looking for
//
// Returns:
//  S_OK: Successfully queued
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/12/07 18:58:41: Created
//
//-------------------------------------------------------------
HRESULT CCategorizer::AsyncResolveDLs(
    IUnknown *pIMsg,
    PFNCAT_COMPLETION pfnCatCompletion,
    LPVOID pContext,
    BOOL fMatchOnly,
    PBOOL pfMatch,
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszAddress)
{
    CatFunctEnter("CCategorizer::AsyncResolveDLs");
    HRESULT hr;
    CICategorizerDLListResolveIMP *pCICatListResolveIMP = NULL;

    //
    // If we are totally disabled, skip all work
    //
    if(! IsCatEnabled()) {

        _VERIFY( SUCCEEDED( pfnCatCompletion(S_OK, pContext, pIMsg, NULL)));
        hr = S_OK;
        goto CLEANUP;
    }

    INCREMENT_COUNTER(CatSubmissions);

    if(fIsShuttingDown()) {
        hr = CAT_E_SHUTDOWN;
        ERROR_LOG("fIsShuttingDown");
        goto CLEANUP;
    }

    hr = DelayedInitializeIfNecessary();
    ERROR_CLEANUP_LOG("DelayedInitializeIfNecessary");

    //
    // Allocate pICatListResolve quick and dirty..
    //
    pCICatListResolveIMP = new (m_cICatListResolveProps) CICategorizerDLListResolveIMP(
        this,
        pfnCatCompletion,
        pContext);

    if(pCICatListResolveIMP == NULL) {
        ErrorTrace(0, "out of memory allocing CICategorizerListResolveIMP");
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CICategorizerDLListResolveIMP");
        goto CLEANUP;
    }
    //
    // The constructor of ICategorizerListResolve starts with refcount 1
    //
    hr = pCICatListResolveIMP->Initialize(
        pIMsg,
        !fMatchOnly, // Expand all?
        pfMatch,
        CAType,
        pszAddress);
    ERROR_CLEANUP_LOG("pCICatListResolveIMP->Initialize");

    hr = pCICatListResolveIMP->StartMessageCategorization();
    ERROR_CLEANUP_LOG("pCICatListResolveIMP->StartMessageCategorization");

    if(hr == S_FALSE)
    {
        //
        // Nothing was necessary to resolve
        //
        CatCompletion(pfnCatCompletion, S_OK, pContext, pIMsg, NULL);
        hr = S_OK;
        goto CLEANUP;
    }

 CLEANUP:

    // Cleanup
    if(FAILED(hr)) {

        ErrorTrace(0, "AsyncResolveIMsg internal failure, hr %08lx", hr);
        // If the above code came to here with a failed hr, that means
        // the store will not be calling our completion routine.
        // Therefore, we need to clean up our mem and call our
        // completion routine with error

        ErrorTrace(0, "AsyncResolveIMsg calling completion routine with error %08lx", hr);
        // Instead of returning an error, return S_OK and call the
        // user's completion routine

        CatCompletion(pfnCatCompletion, hr, pContext, pIMsg, NULL);
        hr = S_OK;
    }

    if(pCICatListResolveIMP)
        pCICatListResolveIMP->Release();

    CatFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Default_CatRegister
//
// Synopsis: Wrapper to call back into CCategorizer::Register
//
// Arguments:
//  hrStatus: current status of event
//  pvContext: register event params structure
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/23 21:22:36: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Default_CatRegister(
    HRESULT hrStatus,
    PVOID pvContext)
{
    CatFunctEnter("MailTransport_Default_CatRegister");

    //
    // For the register event, do the default processing before
    // triggering the server event so all sinks will have access to
    // the config info (even those higher than default priority)
    //

    CatFunctLeave();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CCategorizer::Register
//
// Synopsis: Sets initial categorizer parameters given a sourceline
//
// Arguments:
//   pszSourceLine: String of the following form:
//                  "Host=host.corp.com,Account=Administrator,Password=xx",
//                  giving the information about the LDAP server for the
//                  default domain.
//
// Returns:
//  S_OK: Success
//  or error from ParseSourceLine
//
// History:
// jstamerj 1998/06/23 19:01:57: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::Register()
{
    CatFunctEnterEx((LPARAM)this, "CCategorizer::Register");
    HRESULT hrResult;

    //
    // Set the ICatParams based on info in m_ConfigInfo
    //
    hrResult = SetICatParamsFromConfigInfo();

    CatFunctLeaveEx((LPARAM)this);
    return hrResult;

}


//+------------------------------------------------------------
//
// Function: CCategorizer::SetICatParamsFromConfigInfo
//
// Synopsis: Sets parameters in m_pICatParams based on values in m_ConfigInfo
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/15 15:28:55: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::SetICatParamsFromConfigInfo()
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CCategorizer::SetICatParamsFromConfigInfo");

    //
    // Run through each parameter copying them from m_ConfigInfo
    // to ICategorizerParameters
    //
    #define PARAMCOPY( ciflag, cimember, dsparamid ) \
        if(m_ConfigInfo.dwCCatConfigInfoFlags & ciflag) { \
            hr = m_pICatParams->SetDSParameterA( \
                dsparamid, \
                m_ConfigInfo.cimember); \
            if(FAILED(hr)) \
                goto CLEANUP; \
        }

    PARAMCOPY( CCAT_CONFIG_INFO_BINDDOMAIN, pszBindDomain, DSPARAMETER_LDAPDOMAIN );
    PARAMCOPY( CCAT_CONFIG_INFO_USER, pszUser, DSPARAMETER_LDAPACCOUNT );
    PARAMCOPY( CCAT_CONFIG_INFO_PASSWORD, pszPassword, DSPARAMETER_LDAPPASSWORD );
    PARAMCOPY( CCAT_CONFIG_INFO_BINDTYPE, pszBindType, DSPARAMETER_LDAPBINDTYPE );
    PARAMCOPY( CCAT_CONFIG_INFO_HOST, pszHost, DSPARAMETER_LDAPHOST );
    PARAMCOPY( CCAT_CONFIG_INFO_NAMINGCONTEXT, pszNamingContext, DSPARAMETER_LDAPNAMINGCONTEXT );


    if(m_ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_PORT) {
        //
        // itoa documentation states up to 17 chars will be stored in
        // the buffer (including the NULL terminator)
        //
        CHAR szTmp[17];

        _itoa(m_ConfigInfo.dwPort, szTmp, 10 /* radix */);

        hr = m_pICatParams->SetDSParameterA(
            DSPARAMETER_LDAPPORT,
            szTmp);
        ERROR_CLEANUP_LOG("m_pICatParams->SetDSParameterA");
    }

    //
    // Register the schema specific parameters
    //
    if(m_ConfigInfo.dwCCatConfigInfoFlags &
       CCAT_CONFIG_INFO_SCHEMATYPE) {

        hr = RegisterSchemaParameters(
            m_ConfigInfo.pszSchemaType);
        ERROR_CLEANUP_LOG("RegisterSchemaParameters");
    }

 CLEANUP:

    DebugTrace((LPARAM)this, "SetICatParamsFromConfigInfo returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);

    return hr;
}

//+------------------------------------------------------------
//
// Function: CCategorizer::RegisterSchemaParameters
//
// Synopsis: Adds required attributes to m_pICatParams based on a schema type
//
// Arguments:
//   scht: Schema type of config
//
// Returns:
//   S_OK: Success
//
// History:
// jstamerj 980615 13:45:04: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::RegisterSchemaParameters(
    LPSTR pszSchema)
{
    CatFunctEnter("CCategorizer::RegisterSchemaParameters");
    HRESULT hr = S_OK;

    SCHEMA_CONFIG_STRING_TABLE_ENTRY *pSchemaStrings = NULL;
    LPSTR *pRequestAttributeStrings = NULL;

    SCHEMA_CONFIG_STRING_TABLE_ENTRY pSchemaStringsNT5[] =
        SCHEMA_CONFIG_STRING_TABLE_NT5;

    SCHEMA_CONFIG_STRING_TABLE_ENTRY pSchemaStringsMCIS3[] =
        SCHEMA_CONFIG_STRING_TABLE_MCIS3;

    SCHEMA_CONFIG_STRING_TABLE_ENTRY pSchemaStringsExchange5[] =
        SCHEMA_CONFIG_STRING_TABLE_EXCHANGE5;

    LPSTR pRequestAttributeStringsNT5[] =
        SCHEMA_REQUEST_STRINGS_NT5;

    LPSTR pRequestAttributeStringsMCIS3[] =
        SCHEMA_REQUEST_STRINGS_MCIS3;

    LPSTR pRequestAttributeStringsExchange5[] =
        SCHEMA_REQUEST_STRINGS_EXCHANGE5;

    if(lstrcmpi(pszSchema, "NT5") == 0) {
         pSchemaStrings = pSchemaStringsNT5;
         pRequestAttributeStrings = pRequestAttributeStringsNT5;
    } else if(lstrcmpi(pszSchema, "MCIS3") == 0) {
         pSchemaStrings = pSchemaStringsMCIS3;
         pRequestAttributeStrings = pRequestAttributeStringsMCIS3;
    } else if(lstrcmpi(pszSchema, "Exchange5") == 0) {
         pSchemaStrings = pSchemaStringsExchange5;
         pRequestAttributeStrings = pRequestAttributeStringsExchange5;
    } else {
        ErrorTrace((LPARAM)this, "Unknown schema type %s", pszSchema);
        ERROR_LOG("--unknown schema type--");
    }

    if(pSchemaStrings) {
        //
        // Traverse the schema string table adding strings as we go.
        //
        SCHEMA_CONFIG_STRING_TABLE_ENTRY *pEntry;
        pEntry = pSchemaStrings;
        while(SUCCEEDED(hr) && (pEntry->DSParam != DSPARAMETER_INVALID)) {

            hr = m_pICatParams->SetDSParameterA(
                pEntry->DSParam, pEntry->pszValue);
            DebugTrace((LPARAM)this,
                       "hr = %08lx setting schemaparameter %ld to \"%s\"",
                       hr, pEntry->DSParam, pEntry->pszValue);
            pEntry++;
        }
    }
    if(pRequestAttributeStrings) {
        //
        // Traverse the requested attribute strings and add as we go.
        //
        LPSTR *ppszReqAttr;
        ppszReqAttr = pRequestAttributeStrings;
        while(SUCCEEDED(hr) && (*ppszReqAttr)) {

            hr = m_pICatParams->RequestAttributeA(
                *ppszReqAttr);
            DebugTrace((LPARAM)this, "hr = %08lx from RequestAttribute(\"%s\")",
                       hr, *ppszReqAttr);
            ppszReqAttr++;
        }
    }
    if(FAILED(hr))
    {
        ERROR_LOG("SetDSParameter or RequestAttributeA");
    }

    CatFunctLeaveEx((LPARAM)this);
    return SUCCEEDED(hr) ? S_OK : hr;
}


//+------------------------------------------------------------
//
// Function: CCategorizer::CopyCCatConfigInfo
//
// Synopsis: Copy a passed in config structure (possibly
//  partialled filled in) to the member config structure.
//  Default paramters will be set for any parameters not specified.
//
// Arguments: pConfigInfo: passed in struct
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/09/14 16:55:33: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::CopyCCatConfigInfo(
    PCCATCONFIGINFO pConfigInfo)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this,
                      "CCategorizer::CopyCCatConfigInfo");

    _ASSERT(pConfigInfo);

    _ASSERT(m_ConfigInfo.dwCCatConfigInfoFlags == 0);

    //
    // Copy the virtual server ID to the new structure
    //
    m_ConfigInfo.dwVirtualServerID =
        (pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_VSID) ?
         pConfigInfo->dwVirtualServerID :
        CCAT_CONFIG_DEFAULT_VSID;

    //
    // Copy MsgCat enable/disable flag to the new structure
    //
    m_ConfigInfo.dwEnable =
        (pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ENABLE) ?
        pConfigInfo->dwEnable :
        CCAT_CONFIG_DEFAULT_ENABLE;

    //
    // Copy MsgCat flags to the new structure
    //
    m_ConfigInfo.dwCatFlags =
        (pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_FLAGS) ?
        pConfigInfo->dwCatFlags :
        CCAT_CONFIG_DEFAULT_FLAGS;

    //
    // Copy the LDAP port to the new structure
    //
    m_ConfigInfo.dwPort =
        (pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_PORT) ?
        pConfigInfo->dwPort :
        CCAT_CONFIG_DEFAULT_PORT;

    //
    // Copy/Addref the interface pointers to the new structure
    //
    if((pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ISMTPSERVER) &&
       (pConfigInfo->pISMTPServer)) {

        m_ConfigInfo.pISMTPServer = pConfigInfo->pISMTPServer;
        m_ConfigInfo.pISMTPServer->AddRef();

    } else {

        m_ConfigInfo.pISMTPServer = NULL;
    }

    if((pConfigInfo->dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_IDOMAININFO) &&
        (pConfigInfo->pIDomainInfo)) {

        m_ConfigInfo.pIDomainInfo = pConfigInfo->pIDomainInfo;
        m_ConfigInfo.pIDomainInfo->AddRef();

    } else {

        m_ConfigInfo.pIDomainInfo = NULL;
    }

    //
    // Set the flags for dwEnable, dwCatFlags, dwPort, the 3 interface members,    // and the default flag
    //
    m_ConfigInfo.dwCCatConfigInfoFlags |=
        ( CCAT_CONFIG_INFO_VSID |
          CCAT_CONFIG_INFO_FLAGS |
          CCAT_CONFIG_INFO_ENABLE |
          CCAT_CONFIG_INFO_PORT |
          CCAT_CONFIG_INFO_ISMTPSERVER |
          CCAT_CONFIG_INFO_IDOMAININFO |
          CCAT_CONFIG_INFO_DEFAULT);

    //
    // To avoid cut+paste coding, define a macro that copies a string member
    // from one struct to the other; or'ing in the appropriate flag on success
    //
    #define COPYSTRING(member, flag, default) \
        m_ConfigInfo.member = pszStrdup( \
            (pConfigInfo->dwCCatConfigInfoFlags & flag) ? \
            pConfigInfo->member : \
            default); \
        if(m_ConfigInfo.member != NULL) \
            m_ConfigInfo.dwCCatConfigInfoFlags |= flag;


    COPYSTRING(pszRoutingType, CCAT_CONFIG_INFO_ROUTINGTYPE, CCAT_CONFIG_DEFAULT_ROUTINGTYPE);
    COPYSTRING(pszBindDomain, CCAT_CONFIG_INFO_BINDDOMAIN, CCAT_CONFIG_DEFAULT_BINDDOMAIN);
    COPYSTRING(pszUser, CCAT_CONFIG_INFO_USER, CCAT_CONFIG_DEFAULT_USER);
    COPYSTRING(pszPassword, CCAT_CONFIG_INFO_PASSWORD, CCAT_CONFIG_DEFAULT_PASSWORD);
    COPYSTRING(pszBindType, CCAT_CONFIG_INFO_BINDTYPE, CCAT_CONFIG_DEFAULT_BINDTYPE);
    COPYSTRING(pszSchemaType, CCAT_CONFIG_INFO_SCHEMATYPE, CCAT_CONFIG_DEFAULT_SCHEMATYPE);
    COPYSTRING(pszHost, CCAT_CONFIG_INFO_HOST, CCAT_CONFIG_DEFAULT_HOST);
    COPYSTRING(pszNamingContext, CCAT_CONFIG_INFO_NAMINGCONTEXT, CCAT_CONFIG_DEFAULT_NAMINGCONTEXT);
    COPYSTRING(pszDefaultDomain, CCAT_CONFIG_INFO_DEFAULTDOMAIN, CCAT_CONFIG_DEFAULT_DEFAULTDOMAIN);

    //
    // Make sure all flags in the structure were set.
    //
    if(m_ConfigInfo.dwCCatConfigInfoFlags != CCAT_CONFIG_INFO_ALL) {
        //
        // We must have failed because we ran out of memory
        //
        ErrorTrace((LPARAM)this, "Ran out of memory copying flags");
        CatFunctLeaveEx((LPARAM)this);
        return E_OUTOFMEMORY;
    }

    //
    // Get ISMTPServerEx if available
    //
    if(m_ConfigInfo.pISMTPServer)
    {
        hr = m_ConfigInfo.pISMTPServer->QueryInterface(
            IID_ISMTPServerEx,
            (LPVOID *) &m_pISMTPServerEx);
        if(FAILED(hr))
        {
            ErrorTrace((LPARAM)this, "QI for ISMTPServerEx failed hr %08lx", hr);
            //
            // Ignore error
            //
        }
    }
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCategorizer::ReleaseConfigInfo
//
// Synopsis: Release all memory and interfaces held by the configinfo struct
//
// Arguments: NONE (member variable)
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/14 17:26:06: Created.
//
//-------------------------------------------------------------
VOID CCategorizer::ReleaseConfigInfo()
{
    //
    // Release interfaces
    //
    if((m_ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_ISMTPSERVER) &&
       (m_ConfigInfo.pISMTPServer)) {

        m_ConfigInfo.pISMTPServer->Release();
    }

    if((m_ConfigInfo.dwCCatConfigInfoFlags & CCAT_CONFIG_INFO_IDOMAININFO) &&
       (m_ConfigInfo.pIDomainInfo)) {

        m_ConfigInfo.pIDomainInfo->Release();
    }

    //
    // Again, a handy macro instead of cut+paste coding
    //
    #define RELEASESTRING(member, flag) \
        if(m_ConfigInfo.dwCCatConfigInfoFlags & flag) \
            FreePv(m_ConfigInfo.member);

    RELEASESTRING(pszRoutingType, CCAT_CONFIG_INFO_ROUTINGTYPE);
    RELEASESTRING(pszBindDomain, CCAT_CONFIG_INFO_BINDDOMAIN);
    RELEASESTRING(pszUser, CCAT_CONFIG_INFO_USER);
    RELEASESTRING(pszPassword, CCAT_CONFIG_INFO_PASSWORD);
    RELEASESTRING(pszBindType, CCAT_CONFIG_INFO_BINDTYPE);
    RELEASESTRING(pszSchemaType, CCAT_CONFIG_INFO_SCHEMATYPE);
    RELEASESTRING(pszHost, CCAT_CONFIG_INFO_HOST);
    RELEASESTRING(pszNamingContext, CCAT_CONFIG_INFO_NAMINGCONTEXT);
    RELEASESTRING(pszDefaultDomain, CCAT_CONFIG_INFO_DEFAULTDOMAIN);

    //
    // Since we released everything, set flags to zero
    //
    m_ConfigInfo.dwCCatConfigInfoFlags = 0;
}


//+------------------------------------------------------------
//
// Function: CCategorizer::CancelAllPendingListResolves
//
// Synopsis: Set the resolve status on all pending list resolves
//
// Arguments:
//  hrReason (optional): the status to set on all list resolves
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/01/29 18:30:24: Created.
//
//-------------------------------------------------------------
VOID CCategorizer::CancelAllPendingListResolves(
    HRESULT hrReason)
{
    PLIST_ENTRY ple;

    AcquireSpinLock(&m_PendingResolveListLock);

    for(ple = m_ListHeadPendingResolves.Flink;
        ple != &(m_ListHeadPendingResolves);
        ple = ple->Flink) {

        CICategorizerListResolveIMP *pListResolve;

        pListResolve = CONTAINING_RECORD(
            ple,
            CICategorizerListResolveIMP,
            m_li);

        pListResolve->Cancel();
    }

    ReleaseSpinLock(&m_PendingResolveListLock);
}


//+------------------------------------------------------------
//
// Function: CCategorizer::CatCompletion
//
// Synopsis: Increment perf counters and call the next level's catcompletion
//
// Arguments:
//  hr: Status of resolution
//  pContext: user part of list resolve context
//  pIMsg: categorized message
//  rgpIMsg: array of categorized messages
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/02/24 16:00:11: Created.
//
//-------------------------------------------------------------
VOID CCategorizer::CatCompletion(
    PFNCAT_COMPLETION pfnCatCompletion,
    HRESULT hrResult,
    LPVOID  pContext,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    HRESULT hr;
    PCATMSG_CONTEXT pCatContext = (PCATMSG_CONTEXT)pContext;

    CatFunctEnter("CCategorizer::CatCompletion");
    //
    // Increment counters AND determine wether or not hrResult is a
    // retryable error
    //
    hr = HrAdjustCompletionCounters(hrResult, pIMsg, rgpIMsg);

    _VERIFY(SUCCEEDED(pfnCatCompletion(
        hr,
        pContext,
        pIMsg,
        rgpIMsg)));

    CatFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CCategorizer::HrAdjustCompletionCounters
//
// Synopsis: Increment/Decrement the perf counters associated with a
//           CatCompletion.  Also determines wether or not a list
//           resolve error is retryable
//
// Arguments:
//  hrListResolveStatus: status of the categorization
//  pIMsg: value of the parameter to be passed to CatCompletion (the
//         message to be completed or NULL if there are multiple messages)
//  rgpIMsg: value of the parameter to be passed to CatCompletion (the
//           array of messages to be completed or NULL if there is
//           only one message)
//
// Returns: HRESULT:
//  S_OK: Categorization completed successfully
//  CAT_E_RETRY: hrListResolveStatus is a retryable error
//  hrListResolveStatus: hrListResolveStatus is a non-retryable error
//
// History:
// jstamerj 1999/06/10 11:58:43: Created.
//
//-------------------------------------------------------------
HRESULT CCategorizer::HrAdjustCompletionCounters(
    HRESULT hrListResolveStatus,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    HRESULT hr = hrListResolveStatus;
    CatFunctEnterEx((LPARAM)this, "CCategorizer::HrAdjustCompletionCounters");
    if(FAILED(hr)) {
        //
        // Adjust completion counters
        //
        switch(hr) {

         case E_OUTOFMEMORY:
         case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):

             INCREMENT_COUNTER(RetryOutOfMemory);
             break;

         case HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE):

             INCREMENT_COUNTER(RetryDSLogon);
             break;

         case CAT_E_DBCONNECTION:
         case CAT_E_DBFAIL:
         case CAT_E_NO_GC_SERVERS:

             INCREMENT_COUNTER(RetryDSConnection);
             break;

         default:
             if(FIsHResultRetryable(hr)) {
                 INCREMENT_COUNTER(RetryGeneric);
             }
             break;
        }
        //
        // Is this HRESULT retryable?
        //
        if(FIsHResultRetryable(hr))
        {
            hr = CAT_E_RETRY;
        }

        if(CAT_E_RETRY == hr) {

            CHAR szKey[16]; // Stringized HRESULT
            _snprintf(szKey, sizeof(szKey), "%08lx", hrListResolveStatus);

            ErrorTrace(0, "Categorizer failing with retryable error: %08lx", hrListResolveStatus);
            INCREMENT_COUNTER(RetryFailureCategorizations);

            //
            // Event log
            //
            // We switch to TransportLogEventEx() here in order to
            // generate system string using FormatMessage
            // note: rgszStrings[0] is set inside CEvntWrapp::LogEvent( )
            // because FormatMessageA is used inside LogEvent to generate
            // this string and assign it to rgszString[1]
            const char *rgszStrings[1] = { NULL };

            if (m_ConfigInfo.pISMTPServer) {

                CatLogEvent(
                    m_ConfigInfo.pISMTPServer,
                    CAT_EVENT_RETRYABLE_ERROR,                      // Message ID
                    1,                                              // Word count of substring
                    rgszStrings,                                    // Substring
                    hrListResolveStatus,                            // error code
                    szKey,                                          // key to this event
                    LOGEVENT_FLAG_PERIODIC,                         // Logging option
                    LOGEVENT_LEVEL_MEDIUM,                          // Logging level
                    0                                               // index of format message string in rgszStrings
                    );
            }

        } else {

            FatalTrace(0, "Categorizer failing with nonretryable error: %08lx", hr);
            INCREMENT_COUNTER(HardFailureCategorizations);
            //
            // Pass the hard error to aqueue
            //
        }

    } else {
        //
        // Successfull categorization
        //
        INCREMENT_COUNTER(SucceededCategorizations);

    }
    //
    // Success/failure, increment message counters
    //
    if(pIMsg) {

        INCREMENT_COUNTER(MessagesSubmittedToQueueing);

    } else {
        IUnknown **ppMsg = rgpIMsg;

        while(*ppMsg)
            ppMsg++;

        INCREMENT_COUNTER_AMOUNT(MessagesSubmittedToQueueing, (LONG)(ppMsg - rgpIMsg));
    }

    DECREMENT_COUNTER(CurrentCategorizations);
    INCREMENT_COUNTER(CatCompletions);

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCategorizer::HrAdjustCompletionCounters


//+------------------------------------------------------------
//
// Function: FIsHResultRetryable
//
// Synopsis: Determines if categorization should be retried for a
//           specific HRESULT code.
//
// Arguments:
//  hr: HResult to test
//
// Returns:
//  TRUE: Retry
//  FALSE: Do not retry
//
// History:
// jstamerj 2001/12/10 13:31:54: Created.
//
//-------------------------------------------------------------
BOOL FIsHResultRetryable(
    IN  HRESULT hr)
{
    CatFunctEnter("FIsHResultRetryable");

    switch(hr) 
    {
     //
     // The retryable HRESULTS
     //
     case E_OUTOFMEMORY:
     case HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
     case HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE):
     case CAT_E_DBCONNECTION:
     case CAT_E_DBFAIL:
     case CAT_E_NO_GC_SERVERS:
     case CAT_E_RETRY:
     case HRESULT_FROM_WIN32(ERROR_TIMEOUT):
     case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
     case HRESULT_FROM_WIN32(RPC_S_NOT_LISTENING):
     case HRESULT_FROM_WIN32(RPC_S_OUT_OF_RESOURCES):
     case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):
     case HRESULT_FROM_WIN32(RPC_S_SERVER_TOO_BUSY):
     case STOREDRV_E_RETRY:

     //
     // We are shutting down -- return a retryable error so
     // that the message is not badmailed and will get
     // enumerated/categorized again when the VS restarts
     //
     case HRESULT_FROM_WIN32(ERROR_RETRY):
     case HRESULT_FROM_WIN32(ERROR_CANCELLED):
     case CAT_E_SHUTDOWN:
     case STOREDRV_E_SHUTDOWN:
     case AQUEUE_E_SHUTDOWN:

     //
     // All initialize errors are retryable
     //
     case CAT_E_INIT_FAILED:

         DebugTrace((LPARAM)hr, "0x%08lx IS retryable", hr);
         CatFunctLeave();
         return TRUE;

     default:
         DebugTrace((LPARAM)hr, "0x%08lx is NOT retryable", hr);
         CatFunctLeave();
         return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\address.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: address.h
//
// Contents: 
//
// Classes: CABContext
//
// Functions:
//
// History:
//   jstamerj 1998/02/11 13:57:25: Copeid from routeldp project
//   jstamerj 1998/09/02 12:06:04: Removed CABWrapper/CLDWrapper
//
//-------------------------------------------------------------
#ifndef _ADDRESS_H_
#define _ADDRESS_H_


#include <transmem.h>
#include "ccat.h"
#include "rwex.h"

#define AB_CONTEXT_SIGNATURE            'TCBA'
#define AB_CONTEXT_SIGNATURE_INVALID    'XCBA'

/************************************************************
 * Class: CABContext
 ************************************************************/
//
// The handle passed into Ab functions is really a pointer to one of these
// It holds and manages a pointer to a CCategorizer (one per virtual server)
//
CatDebugClass(CABContext)
{

  public:
    CABContext() {
        m_dwSignature = AB_CONTEXT_SIGNATURE;
        m_pCCat = NULL;
    }

    ~CABContext() {
        //
        // Shutdown the virtual categorizer and wait for all
        // references to it to be released
        //
        if (m_pCCat != NULL)
            m_pCCat->ReleaseAndWaitForDestruction();

        m_dwSignature = AB_CONTEXT_SIGNATURE_INVALID;
    }
    //
    // Retrieve our internal CCategorizer
    //
    CCategorizer *AcquireCCategorizer()
    {
        CCategorizer *pCCat;

        m_CCatLock.ShareLock();
        
        pCCat = m_pCCat;
        pCCat->AddRef();

        m_CCatLock.ShareUnlock();

        return pCCat;
    }

    // change to use a new config
    HRESULT ChangeConfig(
        PCCATCONFIGINFO pConfigInfo);

    //
    // helper routine to change retain old parameters not specified in
    // a new configuration 
    //
    VOID MergeConfigInfo(
        PCCATCONFIGINFO pConfigInfoDest,
        PCCATCONFIGINFO pConfigInfoSrc);

    private:
        // our signature
        DWORD m_dwSignature;
      
        // our virtual categorizer
        CCategorizer *m_pCCat;
  
        // lock to protect multi threaded access to m_pCCat
        CExShareLock m_CCatLock;
};

#endif //_ADDRESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\catdebug.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1999, Microsoft Corporation
//
// File: catdebug.cpp
//
// Contents: Code used for debugging specific purposes
//
// Classes: None
//
// Functions:
//
// History:
// jstamerj 1999/08/05 12:02:03: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

//
// Global debug lists of various objects
//
#ifdef CATDEBUGLIST
DEBUGOBJECTLIST g_rgDebugObjectList[NUM_DEBUG_LIST_OBJECTS];
#endif //CATDEBUGLIST


//+------------------------------------------------------------
//
// Function: CatInitDebugObjectList
//
// Synopsis: Initialize global debug data -- this should be called
// once before any debug objects are created (DllMain/Process Attach
// is a good place) 
// 
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/08/03 16:54:08: Created.
//
//-------------------------------------------------------------
VOID CatInitDebugObjectList()
{
#ifdef CATDEBUGLIST
    CatFunctEnter("CatInitDebugObjectList");
    for(DWORD dw = 0; dw < NUM_DEBUG_LIST_OBJECTS; dw++) {
        InitializeSpinLock(&(g_rgDebugObjectList[dw].spinlock));
        InitializeListHead(&(g_rgDebugObjectList[dw].listhead));
        g_rgDebugObjectList[dw].dwCount = 0;
    }
    CatFunctLeave();
#endif
} // CatInitDebugObjectList


//+------------------------------------------------------------
//
// Function: CatVrfyEmptyDebugObjectList
//
// Synopsis: DebugBreak if any debug objects have leaked.
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/08/03 16:56:57: Created.
//
//-------------------------------------------------------------
VOID CatVrfyEmptyDebugObjectList()
{
#ifdef CATDEBUGLIST
    CatFunctEnter("CatDeinitDebugObjectList");
    for(DWORD dw = 0; dw < NUM_DEBUG_LIST_OBJECTS; dw++) {
        if(g_rgDebugObjectList[dw].dwCount != 0) {

            _ASSERT(0 && "Categorizer debug object leak detected");
            ErrorTrace(0, "Categorizer debug object %ld has leaked",
                       dw);
        }
    }
    CatFunctLeave();
#endif
} // CatDeinitDebugObjectList


//+------------------------------------------------------------
//
// Function: CatDebugBreakPoint
//
// Synopsis: THe categorizer version of DebugBreak()
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/08/06 16:50:47: Created.
//
//-------------------------------------------------------------
VOID CatDebugBreakPoint()
{
    //
    // Cause an AV instead of calling the real DebugBreak() (since
    // DebugBreak will put Dogfood into the kernel debugger)
    //
    ( (*((PVOID *)NULL)) = NULL);
} // CatDebugBreakPoint



//+------------------------------------------------------------
//
// Function: CatLogFuncFailure
//
// Synopsis: Log an event log describing a function failure
//
// Arguments:
//  pISMTPServerEx: ISMTPServerEx for the virtual server.  Without
//                  this, events can not be logged.
//  pICatItem: ICategorizerItem interface for an object related to the
//             error.  Without this, an email address will not be
//             logged with the eventlog.
//  pszFuncNameCaller: The function doing the logging.
//  pszFuncNameCallee: The function that failed.
//  hrFailure: THe error code of the failure
//  pszFileName: The source file name doing the logging
//  dwLineNumber: The source line number doing the logging
//
// Returns:
//  throws exception on error
//
// History:
// jstamerj 2001/12/10 13:27:31: Created.
//
//-------------------------------------------------------------
VOID CatLogFuncFailure(
    IN  ISMTPServerEx *pISMTPServerEx,
    IN  ICategorizerItem *pICatItem,
    IN  LPSTR pszFuncNameCaller,
    IN  LPSTR pszFuncNameCallee,
    IN  HRESULT hrFailure,
    IN  LPSTR pszFileName,
    IN  DWORD dwLineNumber)
{
    HRESULT hr = S_OK;
    DWORD idEvent = 0;
    BOOL fAddrEvent = (pICatItem != NULL);
    LPCSTR rgSubStrings[8];
    CHAR szErr[16];
    CHAR szLineNumber[16];
    CHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
    CHAR szAddressType[CAT_MAX_ADDRESS_TYPE_STRING];

    CatFunctEnter("CatLogFuncFailure");
    if(!fAddrEvent)
    {
        idEvent = FIsHResultRetryable(hrFailure) ? 
                  CAT_EVENT_RETRY_ERROR :
                  CAT_EVENT_HARD_ERROR;

        rgSubStrings[0] = NULL;
        rgSubStrings[1] = NULL;
    }
    else
    {
        idEvent = FIsHResultRetryable(hrFailure) ? 
                  CAT_EVENT_RETRY_ADDR_ERROR :
                  CAT_EVENT_HARD_ADDR_ERROR;
        //
        // Get the address
        //
        hr = HrGetAddressStringFromICatItem(
            pICatItem,
            sizeof(szAddressType) / sizeof(szAddressType[0]),
            szAddressType,
            sizeof(szAddress) / sizeof(szAddress[0]),
            szAddress);
        if(FAILED(hr))
        {
            //
            // Still log an event, but use "unknown" for address type/string
            //
            lstrcpyn(szAddressType, "unknown",
                     sizeof(szAddressType) / sizeof(szAddressType[0]));
            lstrcpyn(szAddress, "unknown",
                     sizeof(szAddress) / sizeof(szAddress[0]));
            hr = S_OK;
        }

        rgSubStrings[0] = szAddressType;
        rgSubStrings[1] = szAddress;
    }

    _snprintf(szErr, sizeof(szErr), "0x%08lx", hrFailure);
    _snprintf(szLineNumber, sizeof(szLineNumber), "%ld", dwLineNumber);

    rgSubStrings[2] = pszFuncNameCaller ? pszFuncNameCaller : "unknown";
    rgSubStrings[3] = pszFuncNameCallee ? pszFuncNameCallee : "unknown";
    rgSubStrings[4] = szErr;
    rgSubStrings[5] = NULL;
    rgSubStrings[6] = pszFileName;
    rgSubStrings[7] = szLineNumber;

    //
    // Can we log an event?
    //
    if(pISMTPServerEx == NULL)
    {
        FatalTrace((LPARAM)0, "Unable to log func failure event; NULL pISMTPServerEx");
        FatalTrace((LPARAM)0, "Event ID: 0x%08lx", idEvent);
        for(DWORD dwIdx = 0; dwIdx < 8; dwIdx++)
        {
            if( rgSubStrings[dwIdx] != NULL )
            {
                FatalTrace((LPARAM)0, "Event String %d: %s",
                           dwIdx, rgSubStrings[dwIdx]);
            }
        }
        goto CLEANUP;
    }

    CatLogEvent(
        pISMTPServerEx,
        idEvent,
        (fAddrEvent ? 8 : 6),
        (fAddrEvent ? rgSubStrings : &rgSubStrings[2]),
        hrFailure,
        pszFuncNameCallee ? pszFuncNameCallee : szErr,
        LOGEVENT_FLAG_ALWAYS,
        LOGEVENT_LEVEL_FIELD_ENGINEERING,
        (fAddrEvent ? 5 : 3)
    );

 CLEANUP:
    CatFunctLeave();
}


//+------------------------------------------------------------
//
// Function: HrGetAddressStringFromICatItem
//
// Synopsis: Gets the address string from an ICategorizerItem
//
// Arguments:
//  pICatItem: The item
//  dwcAddressType: size of pszAddressType buffer
//  pszAddressType: buffer to receive address type
//  dwcAddress: size of pszAddress buffer
//  pszAddress: buffer to receive address
//
// Returns:
//  S_OK: Success
//  error from mailmsg
//
// History:
// jstamerj 2001/12/10 15:24:53: Created.
//
//-------------------------------------------------------------

HRESULT HrGetAddressStringFromICatItem(
    IN  ICategorizerItem *pICatItem,
    IN  DWORD dwcAddressType,
    OUT LPSTR pszAddressType,
    IN  DWORD dwcAddress,
    OUT LPSTR pszAddress)
{
    HRESULT hr = S_OK;
    DWORD dwCount = 0;
    DWORD dwSourceType = 0;
    IMailMsgProperties *pMsg = NULL;
    IMailMsgRecipientsAdd *pRecips = NULL;
    DWORD dwRecipIdx = 0;

    struct _tagAddrProps
    {
        LPSTR pszAddressTypeName;
        DWORD dwSenderPropId;
        DWORD dwRecipPropId;
    } AddrProps[] = 
    {
        { "SMTP",     IMMPID_MP_SENDER_ADDRESS_SMTP,         IMMPID_RP_ADDRESS_SMTP },
        { "X500",     IMMPID_MP_SENDER_ADDRESS_X500,         IMMPID_RP_ADDRESS_X500 },
        { "LegDN",    IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN, IMMPID_RP_LEGACY_EX_DN },
        { "X400",     IMMPID_MP_SENDER_ADDRESS_X400,         IMMPID_RP_ADDRESS_X400 },
        { "Other",    IMMPID_MP_SENDER_ADDRESS_OTHER,        IMMPID_RP_ADDRESS_OTHER }
    };


    CatFunctEnter("HrGetAddressStringFromICatItem");
    //
    // Sender or recipient?
    //
    hr = pICatItem->GetDWORD(
        ICATEGORIZERITEM_SOURCETYPE,
        &dwSourceType);
    if(FAILED(hr))
        goto CLEANUP;

    if(dwSourceType == SOURCE_SENDER)
    {
        hr = pICatItem->GetIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            &pMsg);
        if(FAILED(hr))
            goto CLEANUP;
    }
    else
    {
        hr = pICatItem->GetIMailMsgRecipientsAdd(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADD,
            &pRecips);
        if(FAILED(hr))
            goto CLEANUP;

        hr = pICatItem->GetDWORD(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADDINDEX,
            &dwRecipIdx);
        if(FAILED(hr))
            goto CLEANUP;
    }    

    for(dwCount = 0; dwCount < (sizeof(AddrProps)/sizeof(AddrProps[0])); dwCount++)
    {
        if(dwSourceType == SOURCE_SENDER)
        {
            hr = pMsg->GetStringA(
                AddrProps[dwCount].dwSenderPropId,
                dwcAddress,
                pszAddress);
        }
        else
        {
            hr = pRecips->GetStringA(
                dwRecipIdx,
                AddrProps[dwCount].dwRecipPropId,
                dwcAddress,
                pszAddress);
        }
        if(SUCCEEDED(hr))
        {
            lstrcpyn(pszAddressType, AddrProps[dwCount].pszAddressTypeName, dwcAddressType);
            DebugTrace((LPARAM)0, "Retrieved address %s:%s",
                       pszAddressType, pszAddress);
            hr = S_OK;
            goto CLEANUP;
        }
        else if(hr != MAILMSG_E_PROPNOTFOUND)
        {
            ErrorTrace((LPARAM)0, "Mailmsg failed: 0x%08lx", hr);
            goto CLEANUP;
        }
    }        
    _ASSERT(hr == MAILMSG_E_PROPNOTFOUND);
    ErrorTrace((LPARAM)0, "Found no addresses!!!!!!!!!");

 CLEANUP:
    if(pMsg)
        pMsg->Release();
    if(pRecips)
        pRecips->Release();

    CatFunctLeave();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ccatsender.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccatsender.cpp
//
// Contents: Implamentation of:
//
// Classes:
//   CIMsgSenderAddr
//   CCatSender
//
// Functions:
//   CIMsgSenderAddr::CIMsgSenderAddr
//   CIMsgSenderAddr::HrGetOrigAddress
//   CIMsgSenderAddr::GetSpecificOrigAddress
//   CIMsgSenderAddr::HrAddAddresses
//
//   CCatSender::CCatSender
//   CCatSender::AddDLMember
//   CCatSender::AddForward
//   CCatSender::HrCompletion
//   
// History:
// jstamerj 980325 15:54:02: Created.
//
//-------------------------------------------------------------

//
// ccataddr.cpp -- This file contains the implementations of:
// CCatAddr
//      CLdapRecip
//      CLdapSender
//
// jstamerj 980305 15:37:21: Created
//
// Changes:
//

#include "precomp.h"
#include "address.hxx"

//
// class CIMsgSenderAddr
//


//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::CIMsgSenderAddr
//
// Synopsis: Initializes member data
//
// Arguments:
//   pStore:  Pointer to CEmailIDStore to use for queries
//   pIRC:    Pointer to our per IMsg Resolve list context
//   prlc:    Pointer to store's resolve list context
//   hLocalDomainContext: Domain context to use
//   pBifMgr: Bifurcation object
//
// Returns: Nothing
//
// History:
// jstamerj 980325 11:48:13: Created.
//

//-------------------------------------------------------------
CIMsgSenderAddr::CIMsgSenderAddr(
    CICategorizerListResolveIMP *pCICatListResolve) :
    CCatAddr(pCICatListResolve)
{
    CatFunctEnterEx((LPARAM)this, "CIMsgSenderAddr::CIMsgSenderAddr");
    _ASSERT(pCICatListResolve != NULL);
    CatFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::HrGetOrigAddress
//
// Synopsis: Fetches an original address from the IMsg object
//           Addresses are fetched with the following preference:
//           SMTP, X500, X400, Foreign addres type
//
// Arguments:
//   psz: Buffer in which to copy address
//  dwcc: Size of buffer pointed to by psz in chars.  For now, must be
//        at least CAT_MAX_INTERNAL_FULL_EMAIL
// pType: pointer to a CAT_ADDRESS_TYPE to set to the type of address
//        placed in psz. 
//
// Returns:
//  S_OK: on Success
//  CAT_E_PROPNOTFOUND: A required property was not set
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
//    dwcc needs to be at least CAT_MAX_INTERNAL_FULL_EMAIL
//  CAT_E_ILLEGAL_ADDRESS: Somehow, the original address retreived is
//    not legal for it's type
//  Or an error code from IMsg
//
// History:
// jstamerj 980325 11:50:49: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgSenderAddr::HrGetOrigAddress(
    LPTSTR psz,
    DWORD dwcc,
    CAT_ADDRESS_TYPE *pType)
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this, "CIMsgSenderAddr::HrGetOrigAddress");

    hr = CCatAddr::HrGetOrigAddress(
        psz,
        dwcc,
        pType);

    if(hr == CAT_IMSG_E_PROPNOTFOUND) {

        IMailMsgProperties *pIMsgProps;
        //
        // No sender address properties set.  Let's set a NULL sender SMTP address
        //
        // Make sure there is enough room...
        //
        if(sizeof(CAT_NULL_SENDER_ADDRESS_SMTP) > dwcc) {

            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            ERROR_LOG_ADDR(this, "sizeof(CAT_NULL_SENDER_ADDRESS_SMTP) > dwcc");

        } else {

            hr = GetIMailMsgProperties(&pIMsgProps);
            if(SUCCEEDED(hr)) {

                // Set up passed in parameters
                *pType = CAT_SMTP;
                lstrcpy(psz, CAT_NULL_SENDER_ADDRESS_SMTP);

                // Now set the info on the mailmsg
                DebugTrace((LPARAM)this, 
                           "No sender address found; Setting SMTP sender address to \"%s\"",
                           psz);

                hr = pIMsgProps->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP, psz);
                if(FAILED(hr)) {
                    ERROR_LOG_ADDR(this, "pIMsgProps->PutStringA(IMMPID_MP_SENDER_ADDRESS_SMTP");
                }

                pIMsgProps->Release();
            } else {
                ERROR_LOG_ADDR(this, "GetIMailMsgProperties");
            }
        }
    } else if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "CCatAddr::HrGetOrigAddress");
    }

    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Error retrieving sender address %08lx",
                   hr);
        CatFunctLeave();
        return hr;
    }

    CatFunctLeave();

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::GetSpecificOrigAddress
//
// Synopsis: Attempt to retrieve a specific type of address
//
// Arguments:
//  CAType: Address type to retrieve
//  psz: Buffer to receive address string
//  dwcc: Size of that buffer
//
// Returns:
//  S_OK: Success
//  CAT_IMSG_E_PROPNOTFOUND: this recipient does not have that address
//  or other error from mailmsg
//
// History:
// jstamerj 1998/07/30 20:47:59: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgSenderAddr::GetSpecificOrigAddress(
    CAT_ADDRESS_TYPE    CAType,
    LPTSTR              psz,
    DWORD               dwcc)
{
    HRESULT hr;
    IMailMsgProperties *pIMsgProps;

    CatFunctEnterEx((LPARAM)this, "CIMsgSenderAddr::GetSpecificOrigAddress");

    // Use default(original) IMsg
    hr = GetIMailMsgProperties(&pIMsgProps);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "GetIMailMsgProperties");
        ErrorTrace((LPARAM)this, "GetIMailMsgProperties failed, hr %08lx", hr);
        CatFunctLeaveEx((LPARAM)this);
        return hr;
    }

    hr = pIMsgProps->GetStringA(
        PropIdFromCAType(CAType),
        dwcc,
        psz);
    if(FAILED(hr) && (hr != MAILMSG_E_PROPNOTFOUND)) {
        ERROR_LOG_ADDR(this, "pIMsgProps->GetStringA");
    }

    pIMsgProps->Release();

    DebugTrace((LPARAM)this, "GetStringA returned hr %08lx", hr);

    //
    //$$BUGBUG: testing psz after a failure?
    //
    if(psz[0] == '\0')
        hr = CAT_IMSG_E_PROPNOTFOUND;

    return hr;
}
    

//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::AddAddresses
//
// Synopsis: Add the addresses contained in the arrays
//           to the IMsg object we contain
//
// Arguments:
//  dwNumAddresses: Number of new addresses
//  rgCAType: Array of address types
//  rgpsz: Array of pointers to address strings
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: A required property was not set
//
// History:
// jstamerj 980325 12:14:45: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgSenderAddr::HrAddAddresses(
    DWORD dwNumAddresses, 
    CAT_ADDRESS_TYPE *rgCAType, 
    LPTSTR *rgpsz)
{
    HRESULT hr;
    DWORD dwCount;
    IMailMsgProperties *pIMsgProps;

    CatFunctEnterEx((LPARAM)this, "CIMsgSenderAddr::AddAddresses");
    _ASSERT(dwNumAddresses > 0);

    // Get the IMailMsgProperties and reset the new sender address properties
    hr = GetIMailMsgProperties(&pIMsgProps);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "GetIMailMsgProperties");
        ErrorTrace((LPARAM)this, "GetIMailMsgProperties failed with hr %08lx", hr);
        return hr;
    }

    //
    // Add the new addresses from the array
    //
    for(dwCount = 0; dwCount < dwNumAddresses; dwCount++) {
        //
        // Get the Sender propID for this type
        //
        DWORD dwPropId = PropIdFromCAType(rgCAType[dwCount]);
        //
        // Set the property
        //
        hr = pIMsgProps->PutStringA(dwPropId, rgpsz[dwCount]);

        DebugTrace((LPARAM)this, "Adding address type %d", rgCAType[dwCount]);
        DebugTrace((LPARAM)this, "Adding address %s", rgpsz[dwCount]);

        if(FAILED(hr)) {
            pIMsgProps->Release();
            ERROR_LOG_ADDR(this, "pIMsgProps->PutStringA");
            ErrorTrace((LPARAM)this, "Error putting address property %08lx", hr);
            CatFunctLeave();
            return hr;
        }
    }
    pIMsgProps->Release();

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//
// class CCatSender
//


//+------------------------------------------------------------
//
// Function: CCatSender::CCatSender
//
// Synopsis: Initializes member data
//
// Arguments:
//   pStore: CEmailIDStore to use
//   pIRC:   per IMsg resolve context to use
//   prlc:   Resolve list context to use
//   hLocalDomainContext: local domain context to use
//   pBifMgr: BifMgr object from which to get IMsg interfaces
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 12:28:31: Created.
//
//-------------------------------------------------------------
CCatSender::CCatSender(
    CICategorizerListResolveIMP *pCICatListResolve) :
    CIMsgSenderAddr(pCICatListResolve)
{
    CatFunctEnterEx((LPARAM)this, "CCatSender::CCatSender");
    // Nothing to do.
    CatFunctLeave();
}
    


//+------------------------------------------------------------
//
// Function: CCatSender::AddDLMember
//
// Synopsis: Not implemented since we do nothing in ExpandItem_Default
//
// Arguments:
//   CAType: Known address type of the DL Member
//   pszAddress: pointer to the address string
//
// Returns:
//  E_NOTIMPL
//
// History:
// jstamerj 980325 12:37:02: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------
//
// Function: CCatSender::AddDynamicDLMember
//
// Synopsis: Not implemented since we do nothing in ExpandItem_Default
//
// Arguments: doesn't matter
//
// Returns:
//  E_NOTIMPL
//
// History:
// jstamerj 1998/09/29 21:14:48: 
//
//-------------------------------------------------------------
HRESULT CCatSender::AddDynamicDLMember(
    ICategorizerItemAttributes *pICatItemAttr)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------
//
// Function: CCatSender::AddForward
//
// Synopsis: Not implemented since we do nothing in ExpandItem_Default
//
// Arguments:
//   CAType: Known address type of the forwarding address
//   szForwardingAddres: The forwarding address
//
// Returns:
//  E_NOTIMPL
//
// History:
// jstamerj 980325 12:39:18: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::AddForward(CAT_ADDRESS_TYPE CAType, LPTSTR szForwardingAddress)
{
    return E_NOTIMPL;
}


//+------------------------------------------------------------
//
// Function: CCatSender::HrExpandItem
//
// Synopsis: ExpandItem processing
//
// Arguments:
//  HrStatus: Status of resolution
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/31 19:29:21: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::HrExpandItem_Default(
    PFN_EXPANDITEMCOMPLETION pfnCompletion,
    PVOID pContext)
{
    //
    // We don't expand anything for the sender
    //
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatSender::HrCompelteItem
//
// Synopsis: CompleteItem processing; handle any error status here
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/31 19:29:21: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::HrCompleteItem_Default()
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatSender::HrCompleteItem_Default");

    INCREMENT_COUNTER(AddressLookupCompletions);

    hr = GetItemStatus();

    if(FAILED(hr)) {

        INCREMENT_COUNTER(UnresolvedSenders);

        if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) {
            // No problem.  If we don't find our sender in the DS,
            // just leave him alone.
            DebugTrace((LPARAM)this, "Sender not found in the DS, but who cares?");
            INCREMENT_COUNTER(AddressLookupsNotFound);

        } else if(hr == CAT_E_MULTIPLE_MATCHES) {
            //
            // There are multiple user in the DS with our orig
            // address...
            //
            DebugTrace((LPARAM)this, "More than one sender found in the DS...");
            INCREMENT_COUNTER(AmbiguousSenders);
            ERROR_LOG_ADDR(this, "--status - CAT_E_MULTIPLE_MATCHES--");
            
        } else {

            DebugTrace((LPARAM)this, "Fatal error from EmailIDStore, setting list resolve error %08lx", hr);
            ERROR_LOG_ADDR(this, "--status--");
            _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
        }
    }

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatSender::HrNeedsResolving
//
// Synopsis: Determines if this sender should be resolved or not
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, it needs resolving
//  S_FALSE: Success, it doesn't need to be resolved
//
// History:
// jstamerj 1998/10/27 15:45:22: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::HrNeedsResolveing()
{
    DWORD dwFlags;
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatSender::HrNeedsResolveing");
    dwFlags = GetCatFlags();

    //
    // Do we resolve senders at all?
    //
    if(! (dwFlags & SMTPDSFLAG_RESOLVESENDER))
        return S_FALSE;

#define ISTRUE( x ) ( (x) != 0 ? TRUE : FALSE )
    //
    // Do we need to check if the address is local or not?
    //
    if( ISTRUE(dwFlags & SMTPDSFLAG_RESOLVELOCAL) !=
        ISTRUE(dwFlags & SMTPDSFLAG_RESOLVEREMOTE)) {
        //
        // We're resolving either local or remote (not both)
        //
        BOOL fLocal;

        hr = HrIsOrigAddressLocal(&fLocal);

        if(FAILED(hr)) {
            ERROR_LOG_ADDR(this, "HrIsOrigAddressLocal");
            return hr;
        }
            
        if( (dwFlags & SMTPDSFLAG_RESOLVELOCAL) &&
            (fLocal))
            return S_OK;

        if( (dwFlags & SMTPDSFLAG_RESOLVEREMOTE) &&
            (!fLocal))
            return S_OK;
        //
        // else Don't resolve
        //
        return S_FALSE;
    }
    //
    // 2 possabilities -- local and remote bits are on OR local and
    // remote bits are off
    //
    _ASSERT( ISTRUE(dwFlags & SMTPDSFLAG_RESOLVELOCAL) ==
             ISTRUE(dwFlags & SMTPDSFLAG_RESOLVEREMOTE));

    if(dwFlags & SMTPDSFLAG_RESOLVELOCAL) {
        //
        // Both bits are on; Resolve
        //
        _ASSERT(dwFlags & SMTPDSFLAG_RESOLVEREMOTE);

        return S_OK;

    } else {
        //
        // local and remote are disabled; don't resolve
        //
        return S_FALSE;
    }
}


//+------------------------------------------------------------
//
// Function: CCatSender::LookupCompletion
//
// Synopsis: Handle lookup completion from the emailidstore
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/14 16:19:38: Created.
//
//-------------------------------------------------------------
VOID CCatSender::LookupCompletion()
{
    CatFunctEnterEx((LPARAM)this, "CCatSender::LookupCompletion");

    if(GetItemStatus() == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        INCREMENT_COUNTER(AddressLookupsNotFound);

    //
    // DO the normal event stuff
    //
    CCatAddr::LookupCompletion();

    //
    // Tell list resolve that the sender has been resolved
    //
    SetSenderResolved(TRUE);
    DecrPendingLookups(); // Matches IncPendingLookups() in CCatAdddr::HrDispatchQuery
    CatFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CCatSender::HrDispatchQuery
//
// Synopsis: Dispatch an LDAP query for the sender
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from CCatAddr::HrDispatchQuery
//
// History:
// jstamerj 1999/01/27 13:00:09: Created.
//
//-------------------------------------------------------------
HRESULT CCatSender::HrDispatchQuery()
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatSender::HrDispatchQuery");

    hr = CCatAddr::HrDispatchQuery();

    if(SUCCEEDED(hr))
        SetResolvingSender(TRUE);
    else {
        ERROR_LOG_ADDR(this, "CCatAddr::HrDispatchQuery");
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ccatrecip.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccatrecip.cpp
//
// Contents: Implementation of classes:
//
// Classes:
//   CIMsgRecipListAddr
//   CCatRecip
//
// Functions:
//   CIMsgRecipListAddr::CIMsgRecipListAddr
//   CIMsgRecipListAddr::~CIMsgRecipListAddr
//   CIMsgRecipListAddr::GetSpecificOrigAddress
//   CIMsgRecipListAddr::CreateNewCatAddr
//   CIMsgRecipListAddr::HrAddAddresses
//   CIMsgRecipListAddr::SetUnresolved
//   CIMsgRecipListAddr::SetDontDeliver
//   CIMsgRecipListAddr::SetMailMsgCatStatus
//
//   CCatRecip::CCatRecip
//   CCatRecip::AddDLMember
//   CCatRecip::AddForward
//   CCatRecip::HrCompletion
//   CCatRecip::HandleFailure
//
// History:
// jstamerj 980325 15:32:17: Created.
//
//-------------------------------------------------------------

#include "precomp.h"

//
// class CIMsgRecipListAddr
//

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::CIMsgRecipListAddr
//
// Synopsis: Initializes member data
//
// Arguments:
//   pStore: EmailIDStore to use
//   pIRC:   per IMsg resolve list context to use
//   prlc:   store context to use
//   hLocalDomainContext: local domain context to use
//   pBifMgr: bifurcation manager to use for getting other
//            IMailMsgRecipientsAdd interaces
//   pRecipsAdd: IMailMsgRecipientsAdd of the original recipient to
//               resolve
//   dwRecipIndex: Index in pRecipsAdd of the original recipient to
//                 resolve
//   fPrimary: TRUE means original recipient was added as primary
//             FALSE means original recipient was added as secondary
//
// Returns: NOTHING
//
// History:
// jstamerj 980325 12:54:02: Created.
//
//-------------------------------------------------------------
CIMsgRecipListAddr::CIMsgRecipListAddr(
    CICategorizerListResolveIMP    *pCICatListResolve) :
    CCatAddr(pCICatListResolve)
{
    CatFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::CIMsgRecipListAddr");
    CatFunctLeave();
}

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::~CIMsgRecipListAddr
//
// Synopsis: Releases the IMailMsgRecipientsAdd reference
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 980325 12:59:50: Created.
//
//-------------------------------------------------------------
CIMsgRecipListAddr::~CIMsgRecipListAddr()
{
    CatFunctEnterEx((LPARAM)this, "CImsgRecipListAddr::~CIMsgRecipListAddr");
    CatFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::GetSpecificOrigAddress
//
// Synopsis: Attempts to retrieve a specified original address
//
// Arguments:
//  CAType: Address type to retrieve
//  psz: Buffer to receive address string
//  dwcc: Size of that buffer
//
// Returns:
//  S_OK: Success
//  CAT_IMSG_E_PROPNOTFOUND: this recipient does not have that address
//  or other error from mailmsg
//
// History:
// jstamerj 1998/07/30 20:20:22: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::GetSpecificOrigAddress(
    CAT_ADDRESS_TYPE        CAType,
    LPSTR                   psz,
    DWORD                   dwcc)
{
    HRESULT hr;
    IMailMsgRecipientsAdd *pRecipsAdd;
    DWORD dwRecipIndex;

    CatFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::GetSpecificOrigAddress");

    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIndex, NULL, NULL);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "GetIMsgRecipInfo");
        CatFunctLeaveEx((LPARAM)this);
        return hr;
    }

    hr = pRecipsAdd->GetStringA(
        dwRecipIndex,
        PropIdFromCAType(CAType),
        dwcc,
        psz);

    pRecipsAdd->Release();

    DebugTrace((LPARAM)this, "Item/GetStringA returned hr %08lx", hr);

    if(psz[0] == '\0')
        hr = CAT_IMSG_E_PROPNOTFOUND;

    if(FAILED(hr) && (hr != CAT_IMSG_E_PROPNOTFOUND))
    {
        ERROR_LOG_ADDR(this, "pRecipsAdd->GetStringA");
    }

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}



//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::CreateNewCatAddr
//
// Synopsis: CCatRecip methods call this function when they need to
//           create a new CCatRecip object and a corresponding recipient
//           in the member m_pRecipsAdd with one address only.  On
//           success, the CCatAddr is returned with a refcount of
//           one.
//
// Arguments:
//   CAType: Address type of new CCatRecip object
//   pszAddress: Address string.  If NULL, a new CCatRecip object is
//               created with properties set to point to the current
//               mailmsg recipient (AddPrimary/AddSecondary is not
//               called)
//   ppCCatAddr: Pointer to pointer to CCatAddr object that is set to
//               the newly allocated CCatRecip
//   fPrimary: if TRUE, add via AddPrimary
//             if FALSE, add via AddSecondary
//
// Returns:
//   S_OK: Success
//   E_OUTOFMEMORY: duh
//   CAT_E_PROP_NOT_FOUND: a required ICategorizerItem prop was not set
//   or Error from IMsg
//
// History:
// jstamerj 980325 14:15:50: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::CreateNewCatAddr(
    CAT_ADDRESS_TYPE CAType,
    LPTSTR pszAddress,
    CCatAddr **ppCCatAddr,
    BOOL   fPrimary)
{
    CatFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::CreateNewCatAddr");
    DWORD dwNewRecipIndex = 0;
    HRESULT hr = S_OK;
    LPCTSTR psz = pszAddress;
    DWORD dwPropId = 0;
    IMailMsgRecipientsAdd *pRecipsAdd = NULL;
    IMailMsgProperties *pIMailMsgProps = NULL;
    DWORD dwOrigIndex = 0;
    DWORD dwLevel = 0;
    ICategorizerItem *pICatItemNew = NULL;
    
    DebugTrace((LPARAM)this, "CAType = %d", CAType);

    if(pszAddress) 
    {
        DebugTrace((LPARAM)this, "pszAddress = %s", pszAddress);
    } 
    else 
    {
        DebugTrace((LPARAM)this, "pszAddress = NULL");
    }

    DebugTrace((LPARAM)this, "fPrimary = %d", fPrimary);

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwOrigIndex, NULL, &pIMailMsgProps);
    if(FAILED(hr)) 
    {
        ERROR_LOG_ADDR(this, "GetIMsgRecipInfo");
        pRecipsAdd = NULL;
        pIMailMsgProps = NULL;
        goto CLEANUP;
    }
    //
    // Get the recipient level
    //
    dwLevel = DWLevel() + 1;
    //
    // Unknown dwLevel is -1, so -1 + 1 = 0
    // If dwLevel is unknown, new value will be zero.
    //

    if(pszAddress == NULL) 
    {
        //
        // Create new CCatAddr pointing to the CURRENT recipient
        //
        dwNewRecipIndex = dwOrigIndex;
    } 
    else 
    {
        //
        // Get the equivilant mailmsg propID
        //
        dwPropId = PropIdFromCAType(CAType);

        if(fPrimary) 
        {
            hr = pRecipsAdd->AddPrimary(
                1,
                &psz,
                &dwPropId,
                &dwNewRecipIndex,
                pRecipsAdd,
                dwOrigIndex);
            _ASSERT(hr != CAT_IMSG_E_DUPLICATE);
        } 
        else 
        {
            hr = pRecipsAdd->AddSecondary(
                1,
                &psz,
                &dwPropId,
                &dwNewRecipIndex,
                pRecipsAdd,
                dwOrigIndex);
        }
        DebugTrace((LPARAM)this, "AddPrimary/AddSecondary returned hr %08lx", hr);
    }

    if(hr == CAT_IMSG_E_DUPLICATE) 
    {
        INCREMENT_COUNTER(MailmsgDuplicateCollisions);
        goto CLEANUP;
    } 
    else if(FAILED(hr))
    {
        ERROR_LOG_ADDR(this, "AddPrimary / AddSecondary");
        goto CLEANUP;
    }

    //
    // Alloc an ICategorizerItem so that it can set all the necessary properties
    //
    hr = m_pCICatListResolve->AllocICategorizerItem(
        SOURCE_RECIPIENT,
        &pICatItemNew);
    ERROR_CLEANUP_LOG_ADDR(this, "m_pCICatListResolve->AllocICategorizerItem");
    //
    // Set important ICategorizerItem props on the newborn
    //
    hr = PutIMsgRecipInfo(
        &pRecipsAdd,
        &dwNewRecipIndex,
        &fPrimary,
        &pIMailMsgProps,
        // Only set dwLevel if the old value is known
        (dwLevel == 0) ? NULL : &dwLevel,
        pICatItemNew);

    // This should never fail
    _ASSERT(SUCCEEDED(hr));

    //
    // Get the CCatAddr object
    // This should never fail as no sinks have had the chance
    // to muck with properties yet.
    //
    hr = m_pCICatListResolve->GetCCatAddrFromICategorizerItem(
        pICatItemNew,
        ppCCatAddr);

    _ASSERT(SUCCEEDED(hr));
    //
    // Reset the display name
    //
    hr = ((CIMsgRecipListAddr *)
          *ppCCatAddr)->HrSetDisplayNameProp(NULL);
    ERROR_CLEANUP_LOG_ADDR(this, "HrSetDisplayNameProp");

 CLEANUP:
    if(FAILED(hr))
    {
        *ppCCatAddr = NULL;
        if(pICatItemNew)
            pICatItemNew->Release();
    }
    if(pRecipsAdd)
        pRecipsAdd->Release();
    if(pIMailMsgProps)
        pIMailMsgProps->Release();

    CatFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::HrAddAddresses
//
// Synopsis: Add the addresses contained in the arrays to the IMsg
//           recipient we contain
//
// Arguments:
//  dwNumAddresses: Number of new addresses
//  rgCAType: Array of address types
//  rgpsz: Array of pointers to address strings
//
// Returns:
//  S_OK: Success
//  CAT_E_FORWARD_LOOP: One or more of the new addresses is a
//  duplicate of a recipient in the parent chain
//  CAT_E_NO_SMTP_ADDRESS: Did not add the new addresses because there
//  is no SMTP address
//
// History:
// jstamerj 980325 14:21:56: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::HrAddAddresses(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPTSTR *rgpsz)
{
    CatFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::AddAddresses");
    HRESULT hr, hrDupCheck;

    IMailMsgRecipientsAdd *pRecipsAdd;
    DWORD dwOrigIndex;
    BOOL fPrimary;
    DWORD dwCount;
    DWORD dwNewIndex;
    DWORD dwPropIds[CAT_MAX_ADDRESS_TYPES];
    BOOL  fSMTPAddress;
    DWORD dwSMTPAddressIdx = 0;

    _ASSERT(dwNumAddresses > 0);
    _ASSERT(dwNumAddresses <= CAT_MAX_ADDRESS_TYPES);

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwOrigIndex, &fPrimary, NULL);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "GetIMsgRecipInfo");
        return hr;
    }
    //
    // Initialize the array of address types
    //
    fSMTPAddress = FALSE;
    for(dwCount = 0; dwCount < dwNumAddresses; dwCount++) {


        dwPropIds[dwCount] = PropIdFromCAType(rgCAType[dwCount]);
        if(rgCAType[dwCount] == CAT_SMTP) {
            fSMTPAddress = TRUE;
            dwSMTPAddressIdx = dwCount;
        }
    }

    if(fSMTPAddress == FALSE) {
        ErrorTrace((LPARAM)this, "Not delivering to recipient without an SMTP address");
        hr = CAT_E_NO_SMTP_ADDRESS;
        goto CLEANUP;
    }
    //
    // Validate the SMTP address
    //
    hr = HrValidateAddress(
        rgCAType[dwSMTPAddressIdx],
        rgpsz[dwSMTPAddressIdx]);
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Default SMTP address is invalid: %s",
                   rgpsz[dwSMTPAddressIdx]);
        ERROR_LOG_ADDR(this, "HrValidateAddress");
        hr = HrHandleInvalidAddress();
        goto CLEANUP;
    }

    //
    // Call IMsg add with new addresses
    // If we're primary, we remain primary.
    //
    if(fPrimary) {
        //
        // We need to check for a loop here too since there could be a
        // loop where some other recipient is forwarding to one of our
        // non-default proxy addresses (bug #70220)
        //
        hr = CheckForLoop(
            dwNumAddresses,
            rgCAType,
            rgpsz,
            FALSE); // No need to check ourself for a duplicate

        if(FAILED(hr))
        {
            ERROR_LOG_ADDR(this, "CheckForLoop");
        }
        else
        {
            hr = pRecipsAdd->AddPrimary(
                dwNumAddresses,
                (LPCSTR *)rgpsz,
                dwPropIds,
                &dwNewIndex,
                pRecipsAdd,
                dwOrigIndex);
            _ASSERT(hr != CAT_IMSG_E_DUPLICATE);
            
            if(FAILED(hr))
            {
                ERROR_LOG_ADDR(this, "pRecipsAdd->AddPrimary");
            }
        }

    } else {

        hr = pRecipsAdd->AddSecondary(
            dwNumAddresses,
            (LPCSTR *)rgpsz,
            dwPropIds,
            &dwNewIndex,
            pRecipsAdd,
            dwOrigIndex);

        if(hr == CAT_IMSG_E_DUPLICATE) {

            INCREMENT_COUNTER(MailmsgDuplicateCollisions);
            //
            // The duplicate might be us (the recipient in the mailmsg
            // before resolution)
            //
            hrDupCheck = CheckForDuplicateCCatAddr(
                dwNumAddresses,
                rgCAType,
                rgpsz);

            if(hrDupCheck == CAT_IMSG_E_DUPLICATE) {
                //
                // So we do collide with our parent.
                // Remove if from duplicate detection and try again.
                //
                hr = RemoveFromDuplicateRejectionScheme(TRUE);

                if(SUCCEEDED(hr)) {
                    hr = pRecipsAdd->AddSecondary(
                        dwNumAddresses,
                        (LPCSTR *)rgpsz,
                        dwPropIds,
                        &dwNewIndex,
                        pRecipsAdd,
                        dwOrigIndex);

                    if(hr == CAT_IMSG_E_DUPLICATE)
                        INCREMENT_COUNTER(MailmsgDuplicateCollisions);

                }

            } else if(FAILED(hrDupCheck)) {

                ERROR_LOG_ADDR(this, "pRecipsAdd->AddSecondary");
                //
                // Return the error
                //
                hr = hrDupCheck;
                ERROR_LOG_ADDR(this, "CheckForDuplicateCCatAddr");

            } else {

                ERROR_LOG_ADDR(this, "pRecipsAdd->AddSecondary");

            }

            if(hr == CAT_IMSG_E_DUPLICATE) {
                //
                // If hr is STILL Duplicate, check to see if it's a loop
                // we've encountered
                //
                hrDupCheck = CheckForLoop(
                    dwNumAddresses,
                    rgCAType,
                    rgpsz,
                    FALSE); // No need to check ourself for a
                            // duplicate

                if(FAILED(hrDupCheck)) {
                    //
                    // Return the error -- this could be
                    // CAT_E_FORWARD_LOOP
                    //
                    hr = hrDupCheck;
                    ERROR_LOG_ADDR(this, "CheckForLoop");
                }
            }
        }
    }

    DebugTrace((LPARAM)this, "AddPrimary/AddSecondary returned hr %08lx", hr);

    if(SUCCEEDED(hr)) {
        // Since we were just adding addresses for the same recipient,
        // always mark the old recipient as "Don't deliver"
        hr = SetDontDeliver(TRUE);
        if(SUCCEEDED(hr)) {
            //
            // Relase old Recipient, update this to point to the new
            // recipient
            // IMailMsgRecipients and fPrimary always remain the same
            // for default processing
            //
            hr = PutIMailMsgRecipientsAddIndex(dwNewIndex, this);
            if(FAILED(hr))
            {
                ERROR_LOG_ADDR(this, "PutIMailMsgRecipientsAddIndex");
            }

        } else {

            ERROR_LOG_ADDR(this, "SetDontDeliver");
        }
    }
 CLEANUP:
    pRecipsAdd->Release();
    CatFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::SetUnresolved
//
// Synopsis: Sets recipient property on IMsg indicating this recipient
//           could not be resolved -- this will cause NDR generation for the
//           recipient
//
// Arguments:
//  HrReason: Reason why address is unresolved
//
// Returns:
//  S_OK: Success
//  Or error from IMsg
//
// History:
// jstamerj 980325 14:29:45: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::SetUnresolved(
    HRESULT HrStatus)
{
    CatFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::SetUnresolved");
    HRESULT hr;
    IMailMsgRecipientsAdd *pRecipsAdd;
    IMailMsgProperties *pIMailMsgProps;
    DWORD dwRecipIndex;
    DWORD dwFlags = 0;

    LogNDREvent(HrStatus);

    INCREMENT_COUNTER(NDRdRecipients);

    switch(HrStatus) {

     case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
         INCREMENT_COUNTER(UnresolvedRecipients);
         break;

     case CAT_E_MULTIPLE_MATCHES:
         INCREMENT_COUNTER(AmbiguousRecipients);
         break;

     case CAT_E_ILLEGAL_ADDRESS:
         INCREMENT_COUNTER(IllegalRecipients);
         break;

     case CAT_E_FORWARD_LOOP:
         INCREMENT_COUNTER(LoopRecipients);
         break;

     default:
         INCREMENT_COUNTER(GenericFailureRecipients);
         break;
    }

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIndex, NULL, &pIMailMsgProps);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "GetIMsgRecipInfo");
        return hr;
    }

    hr = pRecipsAdd->GetDWORD(dwRecipIndex,
                              IMMPID_RP_RECIPIENT_FLAGS,
                              &dwFlags);
    if(SUCCEEDED(hr) || (hr == CAT_IMSG_E_PROPNOTFOUND)) {

        dwFlags |= (RP_ERROR_CONTEXT_CAT | RP_UNRESOLVED);

        hr = pRecipsAdd->PutDWORD(dwRecipIndex,
                                  IMMPID_RP_RECIPIENT_FLAGS,
                                  dwFlags);

        if(SUCCEEDED(hr)) {

            hr = pRecipsAdd->PutDWORD(
                dwRecipIndex,
                IMMPID_RP_ERROR_CODE,
                HrStatus);

            if(SUCCEEDED(hr)) {

                hr = SetMailMsgCatStatus(
                    pIMailMsgProps,
                    CAT_W_SOME_UNDELIVERABLE_MSGS);
            } else {
                ERROR_LOG_ADDR(this, "SetMailMsgCatStatus");
            }
        } else {
            ERROR_LOG_ADDR(this, "pRecipsAdd->PutDWORD");
        }
    } else {
        ERROR_LOG_ADDR(this, "pRecipsAdd->GetDWORD(IMMPID_RP_RECIPIENT_FLAGS)");
    }
    
    pRecipsAdd->Release();
    pIMailMsgProps->Release();

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::SetDontDeliver
//
// Synopsis: Sets the IMsg property on a recipient that indicates this
//           recipient should be removed upon a call to WriteList
//
// Arguments:
//   fDontDeliver: TRUE means remove recipient on a WriteList
//                 FALSE means clear DontDeliver property, don't
//                 remove on a WriteList
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 14:34:44: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::SetDontDeliver(BOOL fDontDeliver)
{
    CatFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::SetDontDeliver");
    IMailMsgRecipientsAdd *pRecipsAdd;
    DWORD dwRecipIndex;
    HRESULT hr;

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIndex, NULL, NULL);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "GetIMsgRecipInfo");
        return hr;
    }

    hr = pRecipsAdd->PutBool(dwRecipIndex,
                             IMMPID_RPV_DONT_DELIVER,
                             fDontDeliver);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "pRecipsAdd->PutBool");
    }
    pRecipsAdd->Release();
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::RemoveFromDuplicateRejectionScheme
//
// Synopsis: Sets the IMsg property to indicate this recipient's names
//           should be ignored for duplicate detection
//
// Arguments:
//   fRemove: TRUE means remove recipient for dup detection
//            FALSE means clear property, don't remove recip for dup detection.
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 14:34:44: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::RemoveFromDuplicateRejectionScheme(BOOL fRemove)
{
    CatFunctEnterEx((LPARAM)this, "CIMsgRecipListAddr::SetDontDeliver");
    IMailMsgRecipientsAdd *pRecipsAdd;
    DWORD dwRecipIndex;
    HRESULT hr;

    // Retrieve IMsg interface/recip index
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIndex, NULL, NULL);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "GetIMsgRecipInfo");
        return hr;
    }

    hr = pRecipsAdd->PutBool(dwRecipIndex,
                             IMMPID_RPV_NO_NAME_COLLISIONS,
                             fRemove);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "pRecipsAdd->PutBool");
    }
    pRecipsAdd->Release();
    CatFunctLeave();
    return hr;
}

//
// class CCatRecip
//

//+------------------------------------------------------------
//
// Function: CCatRecip::CCatRecip
//
// Synopsis: initialize member data
//
// Arguments:
//   See CIMsgRecipListAddr::CIMsgRecipListAddr
//
// Returns: NOTHING
//
// History:
// jstamerj 980325 14:36:30: Created.
//
//-------------------------------------------------------------
CCatRecip::CCatRecip(
    CICategorizerListResolveIMP *pCICatListResolve) :
    CCatExpandableRecip(pCICatListResolve)
{
    CatFunctEnterEx((LPARAM)this, "CCatRecip::CCatRecip");

    INCREMENT_COUNTER(RecipsInMemory);

    CatFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CCatRecip::~CCatRecip
//
// Synopsis: Decrement count of recips in memory
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/02/24 19:26:01: Created.
//
//-------------------------------------------------------------
CCatRecip::~CCatRecip()
{
    DECREMENT_COUNTER(RecipsInMemory);
}



//+------------------------------------------------------------
//
// Function: CCatRecip::AddDLMember
//
// Synopsis: EmailIDStore calls this function once for every DL Member
//           when setting properties on a DL.  It is called before
//           CCatRecip::HrCompletion
//
// Arguments:
//   CAType: Known address type of the DL Member
//   pszAddress: pointer to the address string
//
// Returns:
//  S_OK: Success, issued a pending LDAP search
//  S_FALSE: Success, did not issue a search
//  Or, error from IMsg
//
// History:
// jstamerj 980325 14:39:20: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::AddDLMember(CAT_ADDRESS_TYPE CAType, LPTSTR pszAddress)
{
    HRESULT hr;
    CCatAddr *pMember = NULL;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::AddDLMember");
    DebugTrace((LPARAM)this, "CAType: %d", CAType);
    DebugTrace((LPARAM)this, "pszAddress: %s", pszAddress);

    hr = GetListResolveStatus();
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Not adding DL member since list resolve failed");
        ERROR_LOG_ADDR(this, "GetListResolveStatus")
        // Signal to ldapstor to stop resolution
        goto CLEANUP;
    }

    //
    // Validate the new address first
    //
    hr = HrValidateAddress(CAType, pszAddress);
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Invalid member address");
        ERROR_LOG_ADDR(this, "HrValidateAddress");
        hr = HrHandleInvalidAddress();
        goto CLEANUP;
    }


    // Create a new CCatAddr to handle resolution of this DL Member
    hr = CreateNewCatAddr(
        CAType,
        pszAddress,
        &pMember,
        FALSE);

    if(hr == CAT_IMSG_E_DUPLICATE) {
        DebugTrace((LPARAM)this, "Resolution failed with e_duplicate");
        // Fine, DL member was a duplicate so we won't be
        // re-resolving it.  Let it be.
    } else if(SUCCEEDED(hr)) {

        // Great....dispatch the query to the store
        hr = pMember->HrResolveIfNecessary();
        pMember->Release();
    } else {
        ERROR_LOG_ADDR(this, "CreateNewCatAddr");
    }

 CLEANUP:
    if(hr == CAT_IMSG_E_DUPLICATE)
        hr = S_FALSE;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeave();
    return hr;
}

//+------------------------------------------------------------
//
// Function: CCatRecip::AddDynamicDlMember
//
// Synopsis: Add a DL member that has already been looked up in the DS
//
// Arguments:
//  pICatItemAttr: the attributes of the DL member
//
// Returns:
//  S_OK: Success
//  MAILTRANSPORT_S_PENDING: doing an async operation, will call your
//  completion routine when I am finished
//
// History:
// jstamerj 1998/09/29 21:30:26: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::AddDynamicDLMember(
    ICategorizerItemAttributes *pICatItemAttr)
{
    HRESULT hr;
    CCatAddr *pMember = NULL;
    ATTRIBUTE_ENUMERATOR enumerator_dn;
    BOOL fEnumeratingDN = FALSE;
    LPSTR pszDistinguishedNameAttr = NULL;
    LPSTR pszDistinguishedName = NULL;
    ICategorizerUTF8Attributes *pIUTF8Attr = NULL;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::AddDynamicDlMember");

    _ASSERT(pICatItemAttr);

    hr = GetListResolveStatus();
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Not adding DL member since list resolve failed");
        ERROR_LOG_ADDR(this, "GetListResolveStatus");
        // Signal to ldapstor to stop resolution
        goto CLEANUP;
    }

    hr = GetICatParams()->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_DEFAULT_DN,
        &pszDistinguishedNameAttr);
    if(FAILED(hr)) {
        //
        // Fail entire message categorization
        //
        ErrorTrace((LPARAM)this,
            "Failing entire message categorization because we couldn\'t fetch the DN attribute name");
        ERROR_LOG_ADDR(this, "GetDSParameterA(DSPARAMETER_ATTRIBUTE_DEFAULT_DN)");
        hr = SetListResolveStatus(hr);
        _ASSERT(SUCCEEDED(hr));
        goto CLEANUP;
    }

    hr = pICatItemAttr->QueryInterface(
        IID_ICategorizerUTF8Attributes,
        (void **)&pIUTF8Attr);
    if (FAILED(hr)) {
        ERROR_LOG_ADDR(this, "pICatItemAttr->QueryInterface(IID_ICategorizerUTF8Attributes");
        hr = S_OK;
        goto CLEANUP;
    }

    hr = pIUTF8Attr->BeginUTF8AttributeEnumeration(
        pszDistinguishedNameAttr,
        &enumerator_dn);
    if (hr == CAT_E_PROPNOTFOUND) {
        //
        // Silently skip this recip
        //
        ErrorTrace((LPARAM)this,
            "DN attribute \'%s\' not present in results; skipping recip",
            pszDistinguishedNameAttr);
        ERROR_LOG_ADDR(this, "pIUTF8Attr->BeginUTF8AttributeEnumeration(dn)");
        hr = S_OK;
        goto CLEANUP;

    } else if (FAILED(hr)) {
        //
        // Enumeration failed for some other reason.
        // Fail entire message categorization.
        //
        ErrorTrace((LPARAM)this,
            "Failing entire message categorization because enumeration of attribute \'%s\' failed with %08lx",
            pszDistinguishedNameAttr, hr);
        ERROR_LOG_ADDR(this, "pIUTF8Attr->BeginUTF8AttributeEnumeration(dn)");
        hr = SetListResolveStatus(hr);
        _ASSERT(SUCCEEDED(hr));
        goto CLEANUP;
    }

    fEnumeratingDN = TRUE;

    hr = pIUTF8Attr->GetNextUTF8AttributeValue(
        &enumerator_dn,
        &pszDistinguishedName);
    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
        //
        // silently skip this recip
        //
        ErrorTrace((LPARAM)this,
            "attribute \'%s\' present but with no values; skipping recip",
            pszDistinguishedNameAttr);
        ERROR_LOG_ADDR(this, "pIUTF8Attr->GetNextUTF8AttributeValue");
        hr = S_OK;
        goto CLEANUP;

    } else if (FAILED(hr)) {
        //
        // fail entire message categorization
        //
        ErrorTrace((LPARAM)this,
            "Failed to enumerate DN attribute \'%s\' with hr %08lx",
            pszDistinguishedNameAttr, hr);
        ERROR_LOG_ADDR(this, "pIUTF8Attr->GetNextUTF8AttributeValue");
        hr = SetListResolveStatus(hr);
        _ASSERT(SUCCEEDED(hr));
        goto CLEANUP;
    }

    //
    // Create a new CCatAddr for this member
    //
    hr = CreateNewCatAddr(
        CAT_DN,
        pszDistinguishedName,
        &pMember,
        FALSE);

    if (hr == CAT_IMSG_E_DUPLICATE) {
        //
        // silently skip this recip
        //
        ErrorTrace((LPARAM)this, "duplicate address detected; skipping recip");
        hr = S_OK;
        goto CLEANUP;

    } else if (FAILED(hr)) {

        ERROR_LOG_ADDR(this, "CreateNewCatAddr");
        goto CLEANUP;
    }
    //
    // Since we've already looked up the attributes, just set the
    // ICatItemAttr property of the new guy and trigger
    // ProcessItem/ExpandItem/CompleteItem
    //
    hr = pMember->PutHRESULT(
        ICATEGORIZERITEM_HRSTATUS,
        S_OK);
    ERROR_CLEANUP_LOG_ADDR(this, "pMember->PutHRESULT");

    hr = pMember->PutICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        pICatItemAttr);
    ERROR_CLEANUP_LOG_ADDR(this, "pMember->PutICategorizerItemAttributes");

    //
    // Simulate DS completion
    //
    IncPendingLookups();
    pMember->LookupCompletion();
    hr = S_OK;

 CLEANUP:
    if(pMember)
        pMember->Release();

    if (fEnumeratingDN) {
        pIUTF8Attr->EndUTF8AttributeEnumeration(
            &enumerator_dn);
    }

    if (pIUTF8Attr)
        pIUTF8Attr->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}




//+------------------------------------------------------------
//
// Function: CCatRecip::AddForward
//
// Synopsis: EMailIDStore calls this function once for every
//           forwarding address the recipient has.  It is called before
//           CCatRecip::HrCompletion.  On any unhandleable errors,
//           this function sets a list resolve error (instead of
//           returning an error)
//
// Arguments:
//   CAType: Known address type of the forwarding address
//   szForwardingAddres: The forwarding address
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980325 14:48:49: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::AddForward(
    CAT_ADDRESS_TYPE CAType,
    LPTSTR szForwardingAddress)
{
    CatFunctEnterEx((LPARAM)this, "CCatRecip::AddForward");
    DebugTrace((LPARAM)this, "CAType: %d", CAType);
    DebugTrace((LPARAM)this, "szForwardingAddress: %s", szForwardingAddress);
    HRESULT hr;
    CCatAddr *pCCatAddr;
    BOOL fPrimary;

    //
    // Is the forwarding address valid?
    //
    hr = HrValidateAddress(CAType, szForwardingAddress);

    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "Forwarding address string is invalid");
        ERROR_LOG_ADDR(this, "HrValidateAddress");
        hr = HrHandleInvalidAddress();
        goto CLEANUP;
    }


    hr = GetFPrimary(&fPrimary);
    ERROR_CLEANUP_LOG_ADDR(this, "GetFPrimary");
    //
    // jstamerj 1998/07/31 19:58:53:
    //  If we're in the primary chain, we MUST check to see if we're
    //  in a forwarding loop before we call AddPrimary
    //  This is the place to do it
    //
    if(fPrimary) {
        //
        // Check for a loop before adding the forwarding address
        //
        hr = CheckForLoop(
            CAType,
            szForwardingAddress,
            TRUE);  // Check this object too (you could forward to yourself)
        ERROR_CLEANUP_LOG_ADDR(this, "CheckForLoop");
    }

    // Create the new address object with the address we know about
    hr = CreateNewCatAddr(CAType,
                          szForwardingAddress,
                          &pCCatAddr,
                          fPrimary);

    if(hr == CAT_IMSG_E_DUPLICATE) {

        _ASSERT(fPrimary == FALSE);
        DebugTrace((LPARAM)this, "Duplicate from CreateNewCatAddr, checking for a loop");

        //
        // Did we hit duplicate because we're in a loop?
        //
        hr = CheckForLoop(
            CAType,
            szForwardingAddress,
            TRUE);  // CHeck this object too
        if(FAILED(hr)) {

            ERROR_LOG_ADDR(this, "CheckForLoop");
        }

    } else if(SUCCEEDED(hr)) {
        //
        // Since this is forwarding, we need to set the parent
        // ICatItem pointer (to be able to do loop detection)
        //
        hr = PutICategorizerItemParent(
            this,
            pCCatAddr);

        _ASSERT(SUCCEEDED(hr));

        //
        // Resolve the new address
        //
        hr = pCCatAddr->HrResolveIfNecessary();

        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "Unable to dispatch query for forwarding address");
            ERROR_LOG_ADDR(this, "pCCatAddr->HrResolveIfNecessary");
        }
        pCCatAddr->Release();

    } else {
        
        ERROR_LOG_ADDR(this, "CreateNewCatAddr");
    }
 CLEANUP:
    if(FAILED(hr) && (hr != CAT_E_FORWARD_LOOP)) {

        ErrorTrace((LPARAM)this, "Setting the list resolve error:%08lx", hr);
        _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
    }

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::HrCompleteItem_Default
//
// Synopsis: Handle the CompleteItem call; finally make decisions
// about what to do concerning HrStatus failures.
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/31 18:50:01: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrCompleteItem_Default()
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::HrCompleteItem_Default");

    hr = GetItemStatus();
    //
    // Try to handle failures
    //
    if(FAILED(hr)) {

        hr = HandleFailure(hr);
        //
        // If we couldn't handle the recipient failure, fail the whole message
        // categorization
        //
        if(FAILED(hr)) {
            _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
        }
    }

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CCatRecip::HandleFailure
//
// Synopsis: When a completion happens with a failure status, this is
// the helper routine to handle the failure.  If the failure can be
// handeled, S_OK is returned.  If not, the failure itself is returned
//
// Arguments:
//  HrFailure: the failure error code
//
// Returns:
//  S_OK: Success
//  or error from Mailmsg
//
// History:
// jstamerj 1998/07/21 18:00:47: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HandleFailure(
    HRESULT HrFailure)
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::HandleFailure");

    _ASSERT(FAILED(HrFailure));

    switch(HrFailure) {

     case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
     {
         //
         // Address was not found but it is not a local address anyway
         //
         DebugTrace((LPARAM)this, "Remote address not found in DS");

         hr = S_OK;
     }

     case CAT_E_FORWARD_LOOP:
     case CAT_IMSG_E_DUPLICATE:
     case CAT_E_NO_SMTP_ADDRESS:
     {
         //
         // This guy was either a failed resolve where it turns out we
         // already resolved the recipient (in another place in the
         // recip list) or a recipient in a detected loop.  Don't do
         // anything here, DSN flags were/will be set in HandleLoopHead
         //
         hr = S_OK;
         break;
     }

     case CAT_E_BAD_RECIPIENT:
     {
         //
         // A generic recipient error code that indicates this
         // recipient should be NDR'd.  An optional reason can be set
         // in the ICATEGORIZERITEM_HRNDR property
         //
         HRESULT hrReason;
         hr = GetHRESULT(
             ICATEGORIZERITEM_HRNDRREASON,
             &hrReason);

         if(FAILED(hr)) {
             //
             // Use the generic error code for the NDR reason also
             //
             hrReason = CAT_E_BAD_RECIPIENT;
         }

         ErrorTrace((LPARAM)this, "NDRing recipient with error code %08lx",
                    hrReason);

         hr = SetUnresolved(hrReason);
         if(FAILED(hr)) {

             ERROR_LOG_ADDR(this, "SetUnresolved");
         }
         break;
     }
     case CAT_E_DELETE_RECIPIENT:
     {
         //
         // Don't deliver to this recipient
         //
         hr = SetDontDeliver(TRUE);
         if(FAILED(hr)) {

             ERROR_LOG_ADDR(this, "SetDontDeliver");
         }
         break;
     }

     default:
     {
         //
         // EmailIDStore is informing us of an unrecoverable error
         // There's nothing we can do to handle this error except
         // return it (HrCompletion will then SetListResolveStatus)
         //
         ErrorTrace((LPARAM)this, "Unrecoverable error returned from EmailIDStore: hr %08lx", HrFailure);
         hr = HrFailure;
         ERROR_LOG_ADDR(this, "--unhandeled recip error--");
         break;
     }
    }

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}



//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::CheckForLoop
//
// Synopsis: Helper routine to check for a loop in our ancestors
//
// Arguments:
//  dwNumAddresses: Number of addresses to check
//  rgCAType: array of address types
//  rgpsz: array of string pointers
//  fCheckSelf: Check for a dupicate with this CCatAddr?
//
// Returns:
//  S_OK: Success, no loops
//  CAT_E_FORWARD_LOOP: Detected a loop and called HandleLoopHead
//  successfully
//  or error from CheckAncestorsForDuplicate/HandleLoopHead
//
// History:
// jstamerj 1998/08/01 16:05:51: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::CheckForLoop(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPSTR *rgpsz,
    BOOL fCheckSelf)
{
    HRESULT hr;
    CCatAddr *pCCatAddrDup;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::CheckForLoop");

    hr = CheckAncestorsForDuplicate(
        dwNumAddresses,
        rgCAType,
        rgpsz,
        fCheckSelf,
        &pCCatAddrDup);

    if (hr == CAT_IMSG_E_DUPLICATE) {
        //
        // We've got a loop!
        //
        ErrorTrace((LPARAM)this, "Loop detected!");
        ERROR_LOG_ADDR(this, "CheckAncestorsForDuplicate");

        //
        // Generate the DSN on the CCatAddr at the top of the loop
        //
        hr = pCCatAddrDup->HandleLoopHead();
        if(SUCCEEDED(hr)) {
            //
            // Return error to caller
            //
            hr = CAT_E_FORWARD_LOOP;
        }
        else
        {
            ERROR_LOG_ADDR(this, "pCCatAddrDup->HandleLoopHead");
        }
        pCCatAddrDup->Release();
    }
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::CheckForLoop
//
// Synopsis: Same as above with different style parameters
//
// Arguments:
//  CAType: Addres type of pszAddress
//  pszAddress: Address string
//  fCheckSelf: Check this CCatAddr for a duplicate as well?
//
// Returns:
//  S_OK: Success
//  CAT_E_FORWARD_LOOP: Detected a loop and called HandleLoopHead
//  successfully
//  or error from CheckAncestorsForDuplicate/HandleLoopHead
//
// History:
// jstamerj 1998/08/01 16:10:28: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::CheckForLoop(
    CAT_ADDRESS_TYPE        CAType,
    LPTSTR                  pszAddress,
    BOOL                    fCheckSelf)
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this, "CCatRecip::CheckForLoop");

    hr = CheckForLoop(
        1,              // Number of addresses
        &CAType,        // TYpe array
        &pszAddress,    // String ptr array
        fCheckSelf);

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}



//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::HrSetDisplayNameProp
//
// Synopsis: Sets the mailmsg recipient display name property.
//
// Arguments:
//  pwszDisplayName: Display name value.  If NULL, function will set
//  display name to "".
//
// Returns:
//  S_OK: Success
//  error from mailmsg
//
// History:
// jstamerj 2001/04/03 17:21:17: Created.
//
//-------------------------------------------------------------
HRESULT CIMsgRecipListAddr::HrSetDisplayNameProp(
    IN  LPWSTR pwszDisplayName)
{
    HRESULT hr = S_OK;
    DWORD dwRecipIdx = 0;
    IMailMsgRecipientsAdd *pRecipsAdd = NULL;
    CatFunctEnterEx((LPARAM)this,
                      "CIMsgRecipListAddr::HrSetDisplayNameProp");
    
    hr = GetIMsgRecipInfo(&pRecipsAdd, &dwRecipIdx, NULL, NULL);
    ERROR_CLEANUP_LOG_ADDR(this, "GetIMsgRecipInfo");

    hr = pRecipsAdd->PutStringW(
        dwRecipIdx,
        IMMPID_RP_DISPLAY_NAME,
        pwszDisplayName ? pwszDisplayName : L"");
    ERROR_CLEANUP_LOG_ADDR(this, "pRecipsAdd->PutStringW");

    hr = S_OK;

 CLEANUP:
    if(pRecipsAdd)
        pRecipsAdd->Release();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CIMsgRecipListAddr::HrSetDisplayNameProp



//+------------------------------------------------------------
//
// Function: CIMsgRecipListAddr::LogNDREvent
//
// Synopsis: Log an NDR event
//
// Arguments:
//  hrNDRReason: Reason for NDR
//
// Returns: Nothing
//
// History:
// jstamerj 2001/12/12 23:39:20: Created.
//
//-------------------------------------------------------------
VOID CIMsgRecipListAddr::LogNDREvent(
    IN  HRESULT hrNDRReason)
{
    HRESULT hr = S_OK;
    LPCSTR rgSubStrings[4];
    CHAR szErr[16];
    CHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
    CHAR szAddressType[CAT_MAX_ADDRESS_TYPE_STRING];

    CatFunctEnter("CIMstRecipListAddr::LogNDREvent");

    //
    // Get the address
    //
    hr = HrGetAddressStringFromICatItem(
        this,
        sizeof(szAddressType) / sizeof(szAddressType[0]),
        szAddressType,
        sizeof(szAddress) / sizeof(szAddress[0]),
        szAddress);
    
    if(FAILED(hr))
    {
        //
        // Still log an event, but use "unknown" for address type/string
        //
        lstrcpyn(szAddressType, "unknown",
                 sizeof(szAddressType) / sizeof(szAddressType[0]));
        lstrcpyn(szAddress, "unknown",
                 sizeof(szAddress) / sizeof(szAddress[0]));
        hr = S_OK;
    }

    rgSubStrings[0] = szAddressType;
    rgSubStrings[1] = szAddress;

    _snprintf(szErr, sizeof(szErr), "0x%08lx", hrNDRReason);

    rgSubStrings[2] = szErr;
    rgSubStrings[3] = NULL;

    //
    // Can we log an event?
    //
    if(GetISMTPServerEx() == NULL)
    {
        FatalTrace((LPARAM)0, "Unable to log func NDR event; NULL pISMTPServerEx");
        for(DWORD dwIdx = 0; dwIdx < 4; dwIdx++)
        {
            if( rgSubStrings[dwIdx] != NULL )
            {
                FatalTrace((LPARAM)0, "Event String %d: %s",
                           dwIdx, rgSubStrings[dwIdx]);
            }
        }
    }
    else
    {
        CatLogEvent(
            GetISMTPServerEx(),
            CAT_EVENT_NDR_RECIPIENT,
            4,
            rgSubStrings,
            hrNDRReason,
            szErr,
            LOGEVENT_FLAG_ALWAYS,
            LOGEVENT_LEVEL_MAXIMUM,
            3
        );
    }
}



//+------------------------------------------------------------
//
// Function: CCatRecip::HandleLoopHead
//
// Synopsis: This is called when it is determined that this CCatAddr
// is the first in a loop chain.  It ensures an NDR will be generated
// for this recipient
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  or error from MailMsg
//
// History:
// jstamerj 1998/08/01 16:41:44: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HandleLoopHead()
{
    HRESULT hr = CAT_E_FORWARD_LOOP;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::HandleLoopHead");

    ERROR_LOG_ADDR(this, "--Handle Loop Head--");
    //
    // Set the status on this recipient to loop error, and UNSET Don't
    // Deliver so an NDR gets generated
    //
    hr = SetRecipientStatus(
        CAT_E_BAD_RECIPIENT);

    if(SUCCEEDED(hr)) {
        //
        // Set the reason
        //
        hr = SetRecipientNDRCode(
            CAT_E_FORWARD_LOOP);

        if(SUCCEEDED(hr)) {
            //
            // Set DSN flags
            //
            hr = SetUnresolved(CAT_E_FORWARD_LOOP);

            if(SUCCEEDED(hr)) {
                //
                // Make sure DSN will be generated even if we previously
                // wern't planning to deliver to this recipient
                //
                hr = SetDontDeliver(FALSE);
                if(FAILED(hr)) {

                    ERROR_LOG_ADDR(this, "SetDontDeliver");
                }
            } else {
                
                ERROR_LOG_ADDR(this, "SetUnresolved");
            }
        } else {
            
            ERROR_LOG_ADDR(this, "SetRecipientNDRCode");
        }
    } else {

        ERROR_LOG_ADDR(this, "SetRecipientStatus");
    }
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);

    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::HrHandleInvalidAddress
//
// Synopsis: Do what needs to be done when an invalid address is
// detected (either forwarding to an invalid address or a DL member
// with an invalid address or a new address that is invalid)
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/08/18 18:53:45: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrHandleInvalidAddress()
{
    HRESULT hr = CAT_E_ILLEGAL_ADDRESS;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::HandleInvalidAddress");

    ERROR_LOG_ADDR(this, "--Handle Invalid Address--");
    //
    // Set the status on this recipient to casue an NDR
    //
    hr = SetRecipientStatus(
        CAT_E_BAD_RECIPIENT);

    //
    // That should never fail
    //
    _ASSERT(SUCCEEDED(hr));

    //
    // Set the status on this recipient to invalid address error
    //
    hr = SetRecipientNDRCode(
        CAT_E_ILLEGAL_ADDRESS);

    //
    // That should never fail
    //
    _ASSERT(SUCCEEDED(hr));

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::LookupCompletion
//
// Synopsis: Lookup completion routine for a recipient.  Implement
//           defer logic so that RecipLookupCompletion is called after the
//           sender is resolved.
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/18 10:10:47: Created.
//
//-------------------------------------------------------------
VOID CCatRecip::LookupCompletion()
{
    CatFunctEnterEx((LPARAM)this, "CCatRecip::LookupCompletion");

    INCREMENT_COUNTER(AddressLookupCompletions);

    m_pCICatListResolve->ResolveRecipientAfterSender(this);

    CatFunctLeaveEx((LPARAM)this);
} // CCatRecip::LookupCompletion


//+------------------------------------------------------------
//
// Function: CCatRecip::RecipLookupCompletion
//
// Synopsis: Handle lookup completion from the emailidstore
//
// Arguments:
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/01 14:36:08: Created.
// jstamerj 1999/03/18 10:08:26: Removed return value, removed async
//                               completion to asyncctx.  Renamed to
//                               RecipLookupCompletion and removed
//                               defer logic
//
//-------------------------------------------------------------
VOID CCatRecip::RecipLookupCompletion()
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::RecipLookupCompletion");

    hr = GetItemStatus();

    if(FAILED(hr)) 
    {
        //
        // Recipient status indicates failure -- decide now if we
        // should NDR
        //
        switch(hr) 
        {
         case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
         {
             //
             // Address was not found.  Determine if the original
             // address we looked up looks local mailbox or not.
             //
             INCREMENT_COUNTER(AddressLookupsNotFound);

             DebugTrace((LPARAM)this, "Address was not found in DS.  Checking locality");

             BOOL fNDR;
             hr = HrNdrUnresolvedRecip(&fNDR);

             if(SUCCEEDED(hr) && fNDR) 
             {
                 //
                 // It's local and we need to NDR this recip
                 //
                 ErrorTrace((LPARAM)this, "Address appears to be local but was not found in DS.  Setting unresolved property.");
                 //
                 // Set NDR Status and the reason
                 //
                 hr = SetRecipientStatus(CAT_E_BAD_RECIPIENT);
                 if(SUCCEEDED(hr)) 
                 {
                     hr = SetRecipientNDRCode(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
                     if(FAILED(hr)) {

                         ERROR_LOG_ADDR(this, "SetRecipientNDRCode");
                     }
                 } else {
                     
                     ERROR_LOG_ADDR(this, "SetRecipientStatus");
                 }
             } else if(FAILED(hr)) {

                 ERROR_LOG_ADDR(this, "HrNdrUnresolvedRecip");
             }
             break;
         }

         case CAT_E_MULTIPLE_MATCHES:
         case CAT_E_ILLEGAL_ADDRESS:
         case CAT_E_NO_FILTER:
         {
             //
             // Multiple entries for this guy exist in the DS or this guy
             // has an illegal address/forwards to an illegal address
             //
             ErrorTrace((LPARAM)this, "NDRing recipient, reason%08lx",
                        hr);

             hr = SetRecipientNDRCode(hr);
             if(SUCCEEDED(hr)) 
             {
                 hr = SetRecipientStatus(CAT_E_BAD_RECIPIENT);
                 if(FAILED(hr)) {
                     
                     ERROR_LOG_ADDR(this, "SetRecipientStatus");
                 }
             } else {
                 
                 ERROR_LOG_ADDR(this, "SetRecipientNDRCode");
             }
             break;
         }
         case CAT_E_BAD_RECIPIENT:
         {
             //
             // We processed this recipient earlier and returned defer
             //
             hr = S_OK;
             break;
         }
         default:
         {
             //
             // EmailIDStore is informing us of an unrecoverable error
             // There's nothing we can do to handle this error except
             // fail the entire message categorization
             //
             ErrorTrace((LPARAM)this, "Unrecoverable error returned from EmailIDStore: hr %08lx", hr);
             break;
         }
        }
        if(FAILED(hr))
            goto CLEANUP;
    }

    //
    // Set this recipient's display name before triggering events
    //
    hr = HrSetDisplayName();
    ERROR_CLEANUP_LOG_ADDR(this, "HrSetDisplayName");

    //
    // If we handeled the error, go ahead and trigger events.
    // Otherwise, we're failing the message categorization so forget
    // it.
    //
    CCatAddr::LookupCompletion();

 CLEANUP:
    if(FAILED(hr)) {

        ErrorTrace((LPARAM)this, "failing msg categorization hr %08lx", hr);
        _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
    }
    DecrPendingLookups(); // Matches IncPendingLookups() in CCatAdddr::HrDispatchQuery
    CatFunctLeaveEx((LPARAM)this);
}




//+------------------------------------------------------------
//
// Function: CCatRecip::HrProcessItem_Default
//
// Synopsis: The default sink code for the ProcessItem event.
//           Override CCatAddr's implementation so that we can catch
//           and handle errors from AddAddresses
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
// jstamerj 1998/12/01 14:47:15: //
// History:
// jstamerj 980325 14:57:05: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrProcessItem_Default()
{
    HRESULT hr = S_OK;
    HRESULT hrItemStatus = S_OK;
    BOOL fPrimary = FALSE;
    CatFunctEnterEx((LPARAM)this, "CCatRecip::HrProcessItem_Default");

    hr = GetFPrimary(&fPrimary);
    ERROR_CLEANUP_LOG_ADDR(this, "GetFPrimary");
    //
    // CHeck the recipient status
    //
    hrItemStatus = GetItemStatus();
    if(SUCCEEDED(hrItemStatus)) {
        //
        // Add all known addresses to the new address list
        //
        hr = HrAddNewAddressesFromICatItemAttr();
        switch(hr)
        {
         case CAT_E_NO_SMTP_ADDRESS:
             //
             // If this is a primary recipient, NDR
             // Otherwise, fall through and delete this recipient
             //
             if(fPrimary)
             {
                 DebugTrace((LPARAM)this, "NDRing primary recipient without SMTP address");
                 // NDR
                 hr = SetRecipientNDRCode(
                     CAT_E_NO_SMTP_ADDRESS);
                 if(SUCCEEDED(hr))
                     hr = SetRecipientStatus(
                         CAT_E_BAD_RECIPIENT);
                 break;
             }
             else
             {
                 //
                 // Log event when we are deleting recip
                 //
                 ERROR_LOG_ADDR(this, "HrAddNewAddressesFromiCatItemAttr");;
             }
             //
             // Fall through for secondary recipients
             //
         case CAT_IMSG_E_DUPLICATE:
         case CAT_E_FORWARD_LOOP:
         case CAT_E_DELETE_RECIPIENT:

             DebugTrace((LPARAM)this, "AddAddresses failed, removing recip, hr %08lx", hr);
             //
             // Set the recip status to an error so we don't do
             // anything stupid later (like spinning off a resolve for
             // an alternate recipient later)
             //
             hr = SetRecipientStatus(hr);
             if(SUCCEEDED(hr)) 
             {
                 //
                 // Don't deliver to this partialy resolved recipient
                 //
                 hr = SetDontDeliver(TRUE);
                 if(FAILED(hr))
                 {
                     ERROR_LOG_ADDR(this, "SetDontDeliver");
                 }
             }
             else
             {
                 ERROR_LOG_ADDR(this, "SetRecipientStatus");
             }
             break;
         default:
             // Do nothing
             break;
        }
    }
 CLEANUP:
    //
    // Fail the categorization if the above calls failed
    //
    if(FAILED(hr)) 
    {
        ErrorTrace((LPARAM)this, "Setting list resolve error %08lx", hr);
        hr = SetListResolveStatus(hr);
        _ASSERT(SUCCEEDED(hr));
    }
    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatRecip::HrExpandItem_Default
//
// Synopsis: Handle the ExpandItem event
//
// Arguments:
//  pfnCompletion: Async completion routine
//  pContext: Context to pass to async completion
//
// Returns:
//  S_OK: Success, will NOT call async completion
//  MAILTRANSPORT_S_PENDING: Will call async completion
//
// History:
// jstamerj 1998/07/31 18:29:57: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrExpandItem_Default(
    PFN_EXPANDITEMCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    HRESULT hrRet = S_OK;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::HrExpandItem_Default");

    //
    // CHeck the recipient status
    //
    hr = GetItemStatus();
    if(SUCCEEDED(hr)) {
        //
        // Call AddDlMember/AddForward once per DL member or
        // forwarding address
        //
        hr = HrAddDlMembersAndForwardingAddresses(
            pfnCompletion,
            pContext);

        DebugTrace((LPARAM)this, "HrAddDlMembersAndForwardingAddresses returned hr %08lx", hr);
        //
        // if hr is a failure value, something must have failed; so we fail
        // the whole message categorization
        //
        if(FAILED(hr)) {
            ERROR_LOG_ADDR(this, "HrAddDlMembersAndForwardingAddresses");
            _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));

        } else {
            //
            // Return the status returned from HrAddDlMembers...
            // It could be S_OK or S_PENDING
            //
            hrRet = hr;
        }
    }

    CatFunctLeaveEx((LPARAM)this);
    return hrRet;
}


//+------------------------------------------------------------
//
// Function: CCatRecipient::HrNeedsResolving
//
// Synopsis: Determines if this recipient should be resolved or not
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, it needs resolving
//  S_FALSE: Success, it doesn't need to be resolved
//
// History:
// jstamerj 1998/10/27 15:45:22: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrNeedsResolveing()
{
    DWORD dwFlags;
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatRecip::HrNeedsResolveing");

    dwFlags = GetCatFlags();

    //
    // Do we resolve recipients at all?
    //
    if(! (dwFlags & SMTPDSFLAG_RESOLVERECIPIENTS))
        return S_FALSE;

#define ISTRUE( x ) ( (x) != 0 ? TRUE : FALSE )
    //
    // Do we need to check if the address is local or not?
    //
    if( ISTRUE(dwFlags & SMTPDSFLAG_RESOLVELOCAL) !=
        ISTRUE(dwFlags & SMTPDSFLAG_RESOLVEREMOTE)) {
        //
        // We're resolving either local or remote (not both)
        //
        BOOL fLocal;

        hr = HrIsOrigAddressLocal(&fLocal);

        if(FAILED(hr)) {
            ERROR_LOG_ADDR(this, "HrIsOrigAddressLocal");
            return hr;
        }
        //
        // Resolve if it's local and we're resolving local addrs
        //
        if( (dwFlags & SMTPDSFLAG_RESOLVELOCAL) &&
            (fLocal))
            return S_OK;
        //
        // Resolve if it's remote and we're resolving remote addrs
        //
        if( (dwFlags & SMTPDSFLAG_RESOLVEREMOTE) &&
            (!fLocal))
            return S_OK;
        //
        // else Don't resolve
        //
        return S_FALSE;
    }
    //
    // 2 possabilities -- local and remote bits are on OR local and
    // remote bits are off
    //
    _ASSERT( ISTRUE(dwFlags & SMTPDSFLAG_RESOLVELOCAL) ==
             ISTRUE(dwFlags & SMTPDSFLAG_RESOLVEREMOTE));

    if(dwFlags & SMTPDSFLAG_RESOLVELOCAL) {
        //
        // Both bits are on; Resolve
        //
       _ASSERT(dwFlags & SMTPDSFLAG_RESOLVEREMOTE);

        return S_OK;

    } else {
        //
        // local and remote are disabled; don't resolve
        //
        return S_FALSE;
    }
}



//+------------------------------------------------------------
//
// Function: CCatRecip::HrSetDisplayName
//
// Synopsis: Set this recipients IMMPID_RP_DISPLAY_NAME property.
// Normally, this is set to the "displayName" attribute.  Hello, if
// that attribute is not available, IMMPID_RP_DISPLAY_NAME will bet
// set to L"".
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 2001/04/03 16:25:27: Created.
//
//-------------------------------------------------------------
HRESULT CCatRecip::HrSetDisplayName()
{
    HRESULT hr = S_OK;
    ICategorizerParameters *pICatParams = NULL;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ICategorizerItemRawAttributes *pIRaw = NULL;
    LPSTR pszDisplayNameAttr = NULL;
    DWORD dwcbDisplayName = 0;
    LPVOID pvDisplayName = NULL;
    LPWSTR pwszDisplayName = NULL;
    BOOL  fEnumerating = FALSE;
    ATTRIBUTE_ENUMERATOR enumerator;
    
    CatFunctEnterEx((LPARAM)this, "CCatRecip::HrSetDisplayName");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    hr = pICatParams->GetDSParameterA(
        PHAT_DSPARAMETER_ATTRIBUTE_DISPLAYNAME,
        &pszDisplayNameAttr);
    if(FAILED(hr) || (pszDisplayNameAttr == NULL))
    {
        hr = S_OK;
        goto CLEANUP;
    }

    hr = GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);
    
    if(FAILED(hr) || (pICatItemAttr == NULL)) 
    {
        pICatItemAttr = NULL;
        hr = S_OK;
        goto CLEANUP;
    }

    hr = pICatItemAttr->QueryInterface(
        IID_ICategorizerItemRawAttributes,
        (LPVOID *)&pIRaw);
    ERROR_CLEANUP_LOG_ADDR(this, "pICatItemAttr->QueryInterface(IID_ICategorizerItemRawAttributes)");

    hr = pIRaw->BeginRawAttributeEnumeration(
        pszDisplayNameAttr,
        &enumerator);
    if(FAILED(hr))
    {
        //
        // No display name
        //
        hr = S_OK;
        goto CLEANUP;
    }

    fEnumerating = TRUE;

    hr = pIRaw->GetNextRawAttributeValue(
        &enumerator,
        &dwcbDisplayName,
        &pvDisplayName);
    if(FAILED(hr))
    {
        //
        // No display name
        //
        hr = S_OK;
        goto CLEANUP;
    }

    hr = HrConvertToUnicodeWithAlloc(
        CP_UTF8,
        dwcbDisplayName,
        (LPSTR) pvDisplayName,
        &pwszDisplayName);
    ERROR_CLEANUP_LOG_ADDR(this, "HrConvertToUnicodeWithAlloc");

    hr = HrSetDisplayNameProp(pwszDisplayName);
    ERROR_CLEANUP_LOG_ADDR(this, "HrSetDisplayNameProp");

 CLEANUP:

    if(pwszDisplayName)
        CodePageConvertFree(pwszDisplayName);
    if(fEnumerating)
        pIRaw->EndRawAttributeEnumeration(
            &enumerator);
    if(pIRaw)
        pIRaw->Release();
    if(pICatItemAttr)
        pICatItemAttr->Release();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatRecip::HrSetDisplayName




//
// class CCatExpandableRecip
//

//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::HrAddDlMembersAndForwardingAddresses
//
// Synopsis: Dig through the ICatItemAttr and figure out wether to
//           call HrAddDlMembers or HrAddForwardingAddresses
//
// Arguments:
//  PFN_EXPANDITEMCOMPLETION pfnCompletion: Async completion routine
//  PVOID pContext: completion routine context
//
// Returns:
//  S_OK: Success, will not call completion routine
//  MAILTRANSPORT_S_PENDING: Will call completion routine
//  or error from mailmsg/icatitem/HrAddDlMembers/HrAddForwardingAddresses
//
// History:
// jstamerj 1998/09/29 11:28:54: Created.
//
//-------------------------------------------------------------
HRESULT CCatExpandableRecip::HrAddDlMembersAndForwardingAddresses(
    PFN_EXPANDITEMCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ICategorizerParameters *pICatParams;
    LPSTR pszX500DL = NULL;
    LPSTR pszSMTPDL = NULL;
    LPSTR pszDynamicDL = NULL;
    LPSTR pszObjectClassAttribute;
    LPSTR pszObjectClass;
    DLOBJTYPE dlt;
    ATTRIBUTE_ENUMERATOR enumerator;

    CatFunctEnterEx((LPARAM)this, "CCatExpandableRecip::HrAddDlMembersAndForwardingAddresses");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    hr = GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);

    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        goto CLEANUP;
    }

    //
    // Fetch DL objectclasses from IDSParams
    //  On failure, the LPSTR will remain pointed to NULL
    //
    pICatParams->GetDSParameterA(
        DSPARAMETER_OBJECTCLASS_DL_X500,
        &pszX500DL);
    pICatParams->GetDSParameterA(
        DSPARAMETER_OBJECTCLASS_DL_SMTP,
        &pszSMTPDL);
    pICatParams->GetDSParameterA(
        DSPARAMETER_OBJECTCLASS_DL_DYNAMIC,
        &pszDynamicDL);

    //
    // Fetch objectclass attribute string from IDSParams
    //
    hr = pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_OBJECTCLASS,
        &pszObjectClassAttribute);

    if(FAILED(hr))
        goto CLEANUP;

    //
    // Now, try to match a DL objectClass with something in
    // pICatItemAttr
    //
    hr = pICatItemAttr->BeginAttributeEnumeration(
        pszObjectClassAttribute,
        &enumerator);
    ERROR_CLEANUP_LOG_ADDR(this, "pICatItemAttr->BeginAttributeEnumeartion(objectClass)");

    hr = pICatItemAttr->GetNextAttributeValue(
        &enumerator,
        &pszObjectClass);

    for (dlt = DLT_NONE; SUCCEEDED(hr) && (dlt == DLT_NONE);) {
        if (pszX500DL && (lstrcmpi(pszObjectClass, pszX500DL) == 0)) {

            dlt = DLT_X500;

        } else if (pszSMTPDL && (lstrcmpi(pszObjectClass, pszSMTPDL) == 0)) {

            dlt = DLT_SMTP;

        } else if (pszDynamicDL && (lstrcmpi(pszObjectClass, pszDynamicDL) == 0)) {

            dlt = DLT_DYNAMIC;
        }
        hr = pICatItemAttr->GetNextAttributeValue(
            &enumerator,
            &pszObjectClass);
    }
    pICatItemAttr->EndAttributeEnumeration(
        &enumerator);

    //
    // Call the appropriate routine
    //
    if(dlt == DLT_NONE) {

        hr = HrAddForwardingAddresses();
        _ASSERT(hr != MAILTRANSPORT_S_PENDING);
        ERROR_CLEANUP_LOG_ADDR(this, "HrAddForwardingAddresses");

    } else {

        hr = HrAddDlMembers(
            dlt,
            pfnCompletion,
            pContext);
        ERROR_CLEANUP_LOG_ADDR(this, "HrAddDlMembers");
    }

 CLEANUP:
    if(pICatItemAttr)
        pICatItemAttr->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::HrAddForwardingAddresses
//
// Synopsis: Call AddForward once for every forwarding address found
//           in ICatItemAttr
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/29 13:56:37: Created.
//
//-------------------------------------------------------------
HRESULT CCatExpandableRecip::HrAddForwardingAddresses()
{
    HRESULT hr;
    ICategorizerParameters *pICatParams;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ATTRIBUTE_ENUMERATOR enumerator;
    LPSTR pszForwardingSMTPAttribute;
    LPSTR pszForwardingSMTPAddress;
    BOOL fForwarding = FALSE;

    CatFunctEnterEx((LPARAM)this, "CCatExpandableRecip::HrAddForwardingAddresses");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    hr = GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);

    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "GetICategorizerItemAttributes");
        pICatItemAttr = NULL;
        goto CLEANUP;
    }

    //
    // Get the Forwarding address(es)
    //
    hr = pICatParams->GetDSParameterA(
        DSPARAMETER_ATTRIBUTE_FORWARD_SMTP,
        &pszForwardingSMTPAttribute);
    if(SUCCEEDED(hr)) {
        hr = pICatItemAttr->BeginAttributeEnumeration(
            pszForwardingSMTPAttribute,
            &enumerator);
        if(SUCCEEDED(hr)) {
            hr = pICatItemAttr->GetNextAttributeValue(
                &enumerator,
                &pszForwardingSMTPAddress);
            while(SUCCEEDED(hr)) {
                //
                // jstamerj 980317 15:53:34: Adding support for multiple
                // forwarding addresses -- send to all of them.
                //
                _VERIFY(SUCCEEDED(
                    AddForward( CAT_SMTP,
                                pszForwardingSMTPAddress )));
                //
                // Remember that we're forwarding to at least one address
                //
                fForwarding = TRUE;

                hr = pICatItemAttr->GetNextAttributeValue(
                    &enumerator,
                    &pszForwardingSMTPAddress);

            }
            pICatItemAttr->EndAttributeEnumeration(&enumerator);
        }
    }
    //
    // Check our recipient status -- if it's a failure, that means
    // we're NDRing this recipient due to an invalid address,
    // forward loop, etc.  In this case, we don't want to mark
    // "Don't Deliver"
    //
    if(fForwarding && SUCCEEDED(GetItemStatus())) {
        //
        // Don't deliver to the original recipient when we're
        // forwarding
        //
        hr = SetDontDeliver(TRUE);
        ERROR_CLEANUP_LOG_ADDR(this, "SetDontDeliver");

    } else {
        //
        // Don't return errors from attribute enumeration calls
        //
        hr = S_OK;
    }

 CLEANUP:
    if(pICatItemAttr)
        pICatItemAttr->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::HrAddDlMembers
//
// Synopsis: Call AddDlMember (or AddDynamicDlMember) once for every
//           DlMember
//
// Arguments:
//  dlt: The type of the DL we're expanding
//  PFN_EXPANDITEMCOMPLETION pfnCompletion: Async completion routine
//  PVOID pContext: completion routine context
//
// Returns:
//  S_OK: Success, will not call completion routine
//  MAILTRANSPORT_S_PENDING: Will call completion routine
//  or error from mailmsg/icatitem
//
// History:
// jstamerj 1998/09/29 14:09:56: Created.
//
//-------------------------------------------------------------
HRESULT CCatExpandableRecip::HrAddDlMembers(
    DLOBJTYPE dlt,
    PFN_EXPANDITEMCOMPLETION pfnCompletion,
    PVOID pContext)
{
    HRESULT hr;
    DWORD dwNumMembers = 0;
    PDLCOMPLETIONCONTEXT pDLContext = NULL;

    CatFunctEnterEx((LPARAM)this, "CCatExpandableRecip::HrAddDlMembers");
    //
    // Since we're a DL, don't deliver to the DL object
    //
    hr = SetDontDeliver(TRUE);
    ERROR_CLEANUP_LOG_ADDR(this, "SetDontDeliver");

    switch(dlt) {

     case DLT_X500:
     case DLT_SMTP:
     {
         LPSTR pszMemberAttribute;
         ICategorizerParameters *pICatParams;

         pICatParams = GetICatParams();
         _ASSERT(pICatParams);

         hr = pICatParams->GetDSParameterA(
             DSPARAMETER_ATTRIBUTE_DL_MEMBERS,
             &pszMemberAttribute);

         if(SUCCEEDED(hr)) {

             hr = HrExpandAttribute(
                 NULL,
                 (dlt == DLT_X500) ? CAT_DN : CAT_SMTP,
                 pszMemberAttribute,
                 &dwNumMembers);

             if(SUCCEEDED(hr) && (dwNumMembers == 0)) {
                 //
                 // This might be a paged DL
                 //  Since paged DLs require additional special LDAP
                 //  lookups, use a store function to expand it -- it will
                 //  return S_PENDING and call AddDLMember once per member
                 //
                 pDLContext = AllocDlCompletionContext(this, pfnCompletion, pContext);
                 if(pDLContext == NULL) {

                     hr = E_OUTOFMEMORY;
                     ERROR_LOG_ADDR(this, "AllocDlCompletionContext");

                 } else {

                     hr = GetCCategorizer()->GetEmailIDStore()->HrExpandPagedDlMembers(
                         this,
                         GetResolveListContext(),
                         (dlt == DLT_X500) ? CAT_DN : CAT_SMTP,
                         DlExpansionCompletion,
                         pDLContext);
                     if(FAILED(hr)) {

                         ERROR_LOG_ADDR(this, "HrExpandPagedDlMembers");
                     }
                 }
             } else if(FAILED(hr)) {

                 ERROR_LOG_ADDR(this, "HrExpandAttribute");
             }
         } else {
             ERROR_LOG_ADDR(this, "pICatParams->GetDSParameterA(members)");
         }
         break;
     }

     case DLT_DYNAMIC:
         //
         // Since dynamic DLs require additional special LDAP lookups,
         // use a store function to expand them.  It will return
         // S_PENDING and call AddDynamicDLMember once per member
         //
         pDLContext = AllocDlCompletionContext(this, pfnCompletion, pContext);
         if(pDLContext == NULL) {

             hr = E_OUTOFMEMORY;
             ERROR_LOG_ADDR(this, "AllocDlCompletionContext");

         } else {
             hr = GetCCategorizer()->GetEmailIDStore()->HrExpandDynamicDlMembers(
                 this,
                 GetResolveListContext(),
                 DlExpansionCompletion,
                 pDLContext);
             if(FAILED(hr)) {

                 ERROR_LOG_ADDR(this, "HrExpandDynamicDlMembers");
             }
         }
    }

 CLEANUP:
    if((hr != MAILTRANSPORT_S_PENDING) && (pDLContext != NULL))
        delete pDLContext;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::DlExpansionCompletion
//
// Synopsis: Handle completion of the expansion of a paged/dynamic DL
//
// Arguments:
//  hrStatus: Status of the expansion
//  pContext: Our context
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/01/29 21:17:46: Created.
//
//-------------------------------------------------------------
VOID CCatExpandableRecip::DlExpansionCompletion(
    HRESULT hrStatus,
    PVOID pContext)
{
    PDLCOMPLETIONCONTEXT pDLContext;

    CatFunctEnterEx((LPARAM)pContext, "CCatExpandableRecip::DlExpansionCompletion");

    pDLContext = (PDLCOMPLETIONCONTEXT)pContext;
    _ASSERT(pDLContext);

    DebugTrace((LPARAM)pContext, "hrStatus %08lx", hrStatus);

    if(FAILED(hrStatus)) {

        HRESULT hr = hrStatus;

        ErrorTrace((LPARAM)pContext, "DlExpansion failed hr %08lx",
                   hrStatus);
        ERROR_LOG_ADDR_STATIC(
            pDLContext->pCCatAddr,
            "async",
            pDLContext->pCCatAddr,
            pDLContext->pCCatAddr->GetISMTPServerEx());

        _VERIFY(SUCCEEDED(pDLContext->pCCatAddr->SetListResolveStatus(hrStatus)));
    }
    //
    // Notify that the expanditem event is complete
    //
    pDLContext->pfnCompletion(pDLContext->pContext);

    delete pDLContext;

    CatFunctLeaveEx((LPARAM)pContext);
}



//+------------------------------------------------------------
//
// Function: CCatExpandableRecip::HrExpandAttribute
//
// Synopsis: Call AddDlMember(CAType, *) for every attribute value
//
// Arguments:
//  pICatItemAttr: Optional ICategorizerItemAttribute to use (if NULL,
//                 will attempt retrieval from ICatItem)
//  CAType: The address type of the DL.
//  pszAttributeName: Attribute name to use
//  pdwNumberMembers: optional pointer to a DWORD to increment once
//                    per member added (not initialized here)
//
// Returns:
//  S_OK: Success
//  or error from ICatItemAttr
//
// History:
// jstamerj 1998/09/23 17:54:57: Created.
//
//-------------------------------------------------------------
HRESULT CCatExpandableRecip::HrExpandAttribute(
    ICategorizerItemAttributes *pICatItemAttrIN,
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszAttributeName,
    PDWORD pdwNumberMembers)
{
    HRESULT hr;
    CMembersInsertionRequest *pCInsertionRequest = NULL;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ICategorizerUTF8Attributes *pIUTF8 = NULL;
    ATTRIBUTE_ENUMERATOR enumerator;
    DWORD dwcMembers;
    BOOL fEndEnumeration = FALSE;

    CatFunctEnterEx((LPARAM)this,
                      "CCatExpandableRecip::HrExpandAttribute");

    _ASSERT(pszAttributeName);

    if(pICatItemAttrIN) {
        //
        // Use specified attributes interface
        //
        pICatItemAttr = pICatItemAttrIN;
        pICatItemAttr->AddRef();

    } else {
        //
        // Use default attribute interface
        //
        hr = GetICategorizerItemAttributes(
            ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
            &pICatItemAttr);

        if(FAILED(hr)) {
            pICatItemAttr = NULL;
            ERROR_LOG_ADDR(this, "GetICategorizerItemAttributes");
            goto CLEANUP;
        }
    }

    hr = pICatItemAttr->QueryInterface(
        IID_ICategorizerUTF8Attributes,
        (LPVOID *) &pIUTF8);
    ERROR_CLEANUP_LOG_ADDR(this, "pICatItemAttr->QueryInterface(utf8)");

    DebugTrace((LPARAM)this, "Attribute name: %s", pszAttributeName);

    hr = pIUTF8->BeginUTF8AttributeEnumeration(
        pszAttributeName,
        &enumerator);
    ERROR_CLEANUP_LOG_ADDR(this, "pIUTF8->BeginUTF8AttributeEnumeration");

    fEndEnumeration = TRUE;
    //
    // Get the count of values (members)
    //
    hr = pIUTF8->CountUTF8AttributeValues(
        &enumerator,
        &dwcMembers);
    ERROR_CLEANUP_LOG_ADDR(this, "pIUTF8->CountUTF8AttributeValues");

    if(pdwNumberMembers)
        (*pdwNumberMembers) += dwcMembers;

    if(dwcMembers > 0) {

        pCInsertionRequest = new CMembersInsertionRequest(
            this,
            pIUTF8,
            &enumerator,
            CAType);
        if(pCInsertionRequest == NULL) {
            hr = E_OUTOFMEMORY;
            ERROR_LOG_ADDR(this, "new CMembersInsertionRequest");
            goto CLEANUP;
        }
        //
        // The destructor of CMembersInseritonRequest will now end the
        // attribute enumeration
        //
        fEndEnumeration = FALSE;

        hr = HrInsertInsertionRequest(
            pCInsertionRequest);
        ERROR_CLEANUP_LOG_ADDR(this, "HrInsertInsertionRequest");
    }

 CLEANUP:
    //
    // Don't return prop not found errors
    //
    if((hr == CAT_E_PROPNOTFOUND) ||
       (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)))

       hr = S_OK;

    if(fEndEnumeration)
        pIUTF8->EndUTF8AttributeEnumeration(&enumerator);
    if(pIUTF8)
        pIUTF8->Release();
    if(pICatItemAttr)
        pICatItemAttr->Release();
    if(pCInsertionRequest)
        pCInsertionRequest->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::CCatDLRecip
//
// Synopsis: Construct the DL recipient
//
// Arguments:
//  pIListResolve: the list resolve object to handle expanding this DL
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/05 16:15:20: Created.
//
//-------------------------------------------------------------
CCatDLRecip::CCatDLRecip(
    CICategorizerDLListResolveIMP *pIListResolve) :
    CCatRecip(pIListResolve)
{
    _ASSERT(pIListResolve);
    m_pIListResolve = pIListResolve;
    m_pIListResolve->AddRef();
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::~CCatDLRecip
//
// Synopsis: release references held by this object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/05 16:19:47: Created.
//
//-------------------------------------------------------------
CCatDLRecip::~CCatDLRecip()
{
    if(m_pIListResolve)
        m_pIListResolve->Release();
}




//+------------------------------------------------------------
//
// Function: CCatDLRecip::LookupCompletion
//
// Synopsis: Handle the DS lookup completion of a recipient we're only expanding for
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/05 15:51:13: Created.
// jstamerj 1999/03/18 10:14:35: Removed return value; removed async
//                               completion to asyncctx
//
//-------------------------------------------------------------
VOID CCatDLRecip::LookupCompletion()
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatDLRecip::HrLookupCompletion");

    hr = GetItemStatus();

    if(FAILED(hr)) {

        switch(hr) {
         case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            //
            // This object was not in the DS.  We do nothing
            //
            hr = S_OK;
            break;

         case CAT_E_MULTIPLE_MATCHES:
         case CAT_E_ILLEGAL_ADDRESS:
             //
             // These are caused by DS misconfiguration.  Instead of
             // failing the entire expand, we'll just ignore the
             // recipients that have these problems.
             //
             hr = S_OK;
             break;
         default:
             //
             // We have no choice but to fail the list resolve for any
             // other error
             //
             ErrorTrace((LPARAM)this, "Unrecoverable error returned from EmailIDStore: hr %08lx", hr);
             ERROR_LOG_ADDR(this, "--emailIDStore--");
             break;
        }

    } else {
        //
        // Original recipient status was SUCCESS
        //
        // Call HrAddNewAddressesFromICatItemAttr -- it will dig out all
        // the addresses from ICatItemAttr and call
        // CCatDLRecip::HrAddAddresses -- here we will notify the
        // DLListResolve of the new addresses
        //
        hr = HrAddNewAddressesFromICatItemAttr();
        if(FAILED(hr)) {
            ERROR_LOG_ADDR(this, "HrAddNewAddressesFromICatItemAttr");
        }

        if(SUCCEEDED(hr) || (hr == CAT_E_NO_SMTP_ADDRESS)) {
            //
            // Should we keep resolving?
            //
            hr = m_pIListResolve->HrContinueResolve();
            if(hr == S_OK) {
                //
                // Assume async operation
                //
                IncPendingLookups();

                //
                // Go ahead and expand this if it's a DL
                //
                hr = HrAddDlMembersAndForwardingAddresses(
                    ExpansionCompletion,
                    this);

                if(hr != MAILTRANSPORT_S_PENDING)
                    DecrPendingLookups();
                if(FAILED(hr)) {
                    ERROR_LOG_ADDR(this, "HrAddDlMembersAndForwardingAddresses");
                }
                //
                // MUST preserve return code: MAILTRANSPORT_S_PENDING
                //
            } else if(hr == S_FALSE) {
                hr = S_OK;
            } else {
                ERROR_LOG_ADDR(this, "HrContinueResolve");
            }

        }


        if((hr == CAT_IMSG_E_DUPLICATE) || (hr == CAT_E_FORWARD_LOOP)) {

            DebugTrace((LPARAM)this, "Duplicate collision on AddAddresses hr %08lx", hr);
            //
            // We're just trying to expand DL -- we don't care about
            // loops and such.  However, let's not leave a partially
            // resolved recipient in the recip list
            //
            hr = SetDontDeliver(TRUE);
            if(FAILED(hr)) {
                
                ERROR_LOG_ADDR(this, "SetDontDeliver");
            }
        }
    }
    //
    // Fail the DL expansion if any of the above fails
    //
    if(FAILED(hr)) {
        ErrorTrace((LPARAM)this, "Setting list resolve error %08lx", hr);
        hr = SetListResolveStatus(hr);
        _ASSERT(SUCCEEDED(hr));
    }
    DecrPendingLookups(); // Matches IncPendingLookups() in CCatAdddr::HrDispatchQuery
    CatFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::HrAddAddresses
//
// Synopsis: Catch the default AddAddresses and notify m_pIListResolve
//
// Arguments:
//  dwNumAddresses: the number of addresses found
//  rgCAType: array of address types
//  rgpsz: array of address strings
//
// Returns:
//  S_OK: Success
//  return value from CIMsgRecipListAddr::HrAddAddresses
//
// History:
// jstamerj 1998/12/05 16:42:12: Created.
//
//-------------------------------------------------------------
HRESULT CCatDLRecip::HrAddAddresses(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPTSTR *rgpsz)
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatDLRecip::HrAddAddresses");

    hr = m_pIListResolve->HrNotifyAddress(
        dwNumAddresses,
        rgCAType,
        rgpsz);

    if(SUCCEEDED(hr)) {
        //
        // Add addresses to mailmsg
        //
        hr = CIMsgRecipListAddr::HrAddAddresses(
            dwNumAddresses,
            rgCAType,
            rgpsz);
        if(FAILED(hr))
        {
            ERROR_LOG_ADDR(this, "CIMsgRecipListAddr::HrAddAddresses");
        }

    } else {

        ERROR_LOG_ADDR(this, "m_pIListResolve->HrNotifyAddress");
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::AddForward
//
// Synopsis: Catch the AddForward call.  Since we do not care about
//           forwarding addresses, do nothing
//
// Arguments:
//  CAType: addresses type of the forwarding address
//  pszForwardingAddress: the address string
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/05 16:52:58: Created.
//
//-------------------------------------------------------------
HRESULT CCatDLRecip::AddForward(
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszForwardingAddress)
{
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::AddDLMember
//
// Synopsis: Kick off a resolve after we discover this object is a DL
//
// Arguments:
//  CAType: address type we have for this DL member
//  pszAddress: address we have for this DL member
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/05 16:54:47: Created.
//
//-------------------------------------------------------------
HRESULT CCatDLRecip::AddDLMember(
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszAddress)
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatDLRecip:AddDlMember");
    //
    // Notify the DLListResolve about the new address
    //
    hr = m_pIListResolve->HrNotifyAddress(
        1,
        &CAType,
        &pszAddress);

    //
    // Do we keep resolving?
    //
    if(hr == S_OK) {
        //
        // kick off async resolve
        //
        hr = CCatRecip::AddDLMember(
            CAType,
            pszAddress);
        if(FAILED(hr)) {
            
            ERROR_LOG_ADDR(this, "CCatRecip::AddDLMember");
        }

    } else if(SUCCEEDED(hr)) {
        //
        // Remove S_FALSE
        //
        hr = S_OK;

    } else {

        ERROR_LOG_ADDR(this, "m_pIListResolve->HrNotifyAddress");
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatDLRecip::ExpansionCompletion
//
// Synopsis: Handle async DL expansion completion
//
// Arguments:
//  pContext: a CCatDLRecip in disguise
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/18 13:26:20: Created.
//
//-------------------------------------------------------------
VOID CCatDLRecip::ExpansionCompletion(
    PVOID pContext)
{
    CCatDLRecip *pRecip;

    CatFunctEnterEx((LPARAM)pContext, "CCatDLRecip::ExpansionCompletion");

    pRecip = (CCatDLRecip *)pContext;
    pRecip->DecrPendingLookups();

    CatFunctLeaveEx((LPARAM)pContext);
} // CCatDLRecip::ExpansionCompletion


//+------------------------------------------------------------
//
// Function: CMembersInsertionRequest::HrInsertSearches
//
// Synopsis: Insert LDAP searches for the next few DL members
//
// Arguments:
//  dwcSearches: Number of searches we may insert
//
// Returns:
//  S_OK: Success
//  error: Stop calling HrInsertSearches
//
// History:
// jstamerj 1999/03/25 13:56:46: Created.
//
//-------------------------------------------------------------
HRESULT CMembersInsertionRequest::HrInsertSearches(
    DWORD dwcSearches)
{
    HRESULT hr = S_OK;
    LPSTR pszMember = NULL;
    DWORD dwc;

    CatFunctEnterEx((LPARAM)this, "CMembersInsertionRequest::HrInsertSearches");

    dwc = 0;
    while(SUCCEEDED(hr) && (dwc < dwcSearches)) {

        hr = m_pUTF8Attributes->GetNextUTF8AttributeValue(
            &m_enumerator,
            &pszMember);
        //    
        // GetNextUTF8AttributeValue will return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
        // when we are at the end of the enumeration.
        //
        if(SUCCEEDED(hr)) {
            hr = m_pDLRecipAddr->AddDLMember(m_CAType, pszMember);
            if(hr == S_OK)
                dwc++;
            else if(FAILED(hr)) {
                ERROR_LOG_ADDR(m_pDLRecipAddr, "m_pDLRecipAddr->AddDLMember");
                _VERIFY(SUCCEEDED(m_pDLRecipAddr->SetListResolveStatus(hr)));
            }
        }
    }

    if(FAILED(hr))
        m_hr = hr;

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CMembersInsertionRequest::HrInsertSearches


//+------------------------------------------------------------
//
// Function: CMemberInsertionRequest::NotifyDeQueue
//
// Synopsis: Callback to notify us that our request is being removed
//           from the store's queue
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/25 14:11:12: Created.
//
//-------------------------------------------------------------
VOID CMembersInsertionRequest::NotifyDeQueue(
    HRESULT hrReason)
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this, "CMemberInsertionRequest::NotifyDeQueue");
    //
    // If we still have things left to resolve, reinsert this
    // insertion request
    //
    hr = hrReason;
    if(SUCCEEDED(m_hr)) {
        if( (hr == CAT_E_DBCONNECTION) || (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))) {

            hr = m_pDLRecipAddr->HrInsertInsertionRequest(
                this);
        }

        if(FAILED(hr))
        {
            ERROR_LOG_ADDR(m_pDLRecipAddr,
                           "m_pDLRecipAddr->HrInsertInsertionRequest");
            _VERIFY(SUCCEEDED(m_pDLRecipAddr->SetListResolveStatus(hr)));
        }
    }

    CatFunctLeaveEx((LPARAM)this);
} // CMemberInsertionRequest::NotifyDeQueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\comdll.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: comdll.cpp
//
// Contents: DLL entry points needed for COM
//
// Classes: 
//  CCatFactory
//  CSMTPCategorizer
//
// Functions:
//
// History:
// jstamerj 1998/12/12 15:17:12: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "registry.h"
#include "comdll.h"
#include <smtpguid.h>

//
// Globals
//
// g_cObjects: count of active objects
// g_cServerLocks: count of server locks
// g_hInstance: DLL module handle
//
LONG g_cObjects = 0;
LONG g_cServerLocks = 0;
HINSTANCE g_hInstance = NULL;
BOOL g_fInitialized = FALSE;



//+------------------------------------------------------------
//
// Function: CatDllMain
//
// Synopsis: Handle what cat needs to do in DLLMain
//
// Arguments:
//  hInstance
//  dwReason: Why are you calling me?
//  lpReserved
//
// Returns: TRUE
//
// History:
// jstamerj 1998/12/12 23:06:08: Created.
//
//-------------------------------------------------------------
BOOL WINAPI CatDllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /* lpReserved */)
{
    switch(dwReason) {

     case DLL_PROCESS_ATTACH:
         //
         // Save hInstance
         //
         g_hInstance = hInstance;
         //
         // Initialize global debug lists
         //
         CatInitDebugObjectList();
         break;

     case DLL_PROCESS_DETACH:
         //
         // Verify all Cat objects are destroyed
         //
         CatVrfyEmptyDebugObjectList();
         break;
    }
    return TRUE;
}


//+------------------------------------------------------------
//
// Function: RegisterCatServer
//
// Synopsis: Register the categorizer com objects
//
// Arguments:
//  hInstance: the hInstance passed to DllMain or WinMain
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 15:07:20: Created.
//
//-------------------------------------------------------------
STDAPI RegisterCatServer()
{
    HRESULT hr = S_OK;
    _ASSERT(g_hInstance != NULL);
    hr = RegisterServer(
        g_hInstance,
        CLSID_SmtpCat,
        SZ_CATFRIENDLYNAME,
        SZ_PROGID_SMTPCAT,
        SZ_PROGID_SMTPCAT_VERSION);

    if(SUCCEEDED(hr))
        hr = RegisterServer(
            g_hInstance,
            CLSID_PhatQCat,
            SZ_PHATQCAT_FRIENDLY_NAME,
            SZ_PROGID_PHATQCAT,
            SZ_PROGID_PHATQCAT_VERSION);

    return hr;
}



//+------------------------------------------------------------
//
// Function: UnregisterCatServer
//
// Synopsis: Unregister the categorizer com objects
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 15:08:09: Created.
//
//-------------------------------------------------------------
STDAPI UnregisterCatServer()
{
    HRESULT hr = S_OK;
    hr = UnregisterServer(
        CLSID_SmtpCat,
        SZ_PROGID_SMTPCAT,
        SZ_PROGID_SMTPCAT_VERSION);

    if(SUCCEEDED(hr))
        hr = UnregisterServer(
            CLSID_PhatQCat,
            SZ_PROGID_PHATQCAT,
            SZ_PROGID_PHATQCAT_VERSION);

    return hr;
}


//+------------------------------------------------------------
//
// Function: DllCanUnloadCatNow
//
// Synopsis: Return to COM wether it's okay or not to unload our dll
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, can unload
//  S_FALSE: Success, do not unload
//
// History:
// jstamerj 1998/12/12 15:09:02: Created.
//
//-------------------------------------------------------------
STDAPI DllCanUnloadCatNow()
{
    if((g_cObjects == 0) && (g_cServerLocks == 0)) {

        return S_OK;

    } else {

        return S_FALSE;
    }
}


//+------------------------------------------------------------
//
// Function: DllGetCatClassObject
//
// Synopsis: Return the class factory object (an interface to it)
//
// Arguments:
//  clsid: The CLSID of the object you want a class factory for
//  iid: the interface you want
//  ppv: out param to set to the interface pointer
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: don't support that interface
//  CLASS_E_CLASSNOTAVAILABLE: don't support that clsid
//
// History:
// jstamerj 1998/12/12 15:11:48: Created.
//
//-------------------------------------------------------------
STDAPI DllGetCatClassObject(
    const CLSID& clsid,
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    BOOL fDllInit = FALSE;
    BOOL fCatInitGlobals = FALSE;
    CCatFactory *pFactory = NULL;

    if((clsid != CLSID_SmtpCat) &&
       (clsid != CLSID_PhatQCat))
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        goto CLEANUP;
    }

    //
    // Call init once for every class factory object created
    // (CCatFactory will release this reference in its destructor)
    //
    hr = HrDllInitialize();
    if(FAILED(hr))
        goto CLEANUP;

    fDllInit = TRUE;

    hr = CatInitGlobals();
    if(FAILED(hr))
        goto CLEANUP;

    fCatInitGlobals = TRUE;

    pFactory = new CCatFactory;
    //
    // Refcount of pFactory starts at 1
    //
    if(pFactory == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    //
    // CCatFactory will call DllDeinitialize and CatDeinitGlobals in
    // its final release call
    //
    fDllInit = fCatInitGlobals = FALSE;

    //
    // Get the requested interface
    //
    hr = pFactory->QueryInterface(
        iid,
        ppv);

    //
    // Release our refcount
    //
    pFactory->Release();

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Deinit what was initialized
        //
        if(fCatInitGlobals)
            CatDeinitGlobals();

        if(fDllInit)
            DllDeinitialize();
    }
    return hr;
}

    

//+------------------------------------------------------------
//
// Function: CCatFactory::QueryInterface
//
// Synopsis: return interface pointers that this object inplements
//
// Arguments:
//  iid: Interface you want
//  ppv: out pointer to where to place the interface pointer
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: we don't support that interface
//
// History:
// jstamerj 1998/12/12 22:19:38: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CCatFactory::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    if((iid == IID_IUnknown) ||
       (iid == IID_IClassFactory)) {

        *ppv = (IClassFactory *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatFactory::CreateInstance
//
// Synopsis: Create an object
//
// Arguments:
//  pUnknownOuter: aggreation pointer
//  iid: Interface ID you'd like
//  ppv: place to return the interface ptr
//
// Returns:
//  S_OK: Success
//  CLASS_E_NOAGGREATION: Sorry, no.
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/12/12 22:25:00: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CCatFactory::CreateInstance(
    IUnknown *pUnknownOuter,
    REFIID iid,
    LPVOID *ppv)
{
    HRESULT hr;

    if(pUnknownOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    //
    // Create the new object
    //
    CSMTPCategorizer *pCat = new CSMTPCategorizer(&hr);

    if(pCat == NULL)
        return E_OUTOFMEMORY;

    if(FAILED(hr)) {
        delete pCat;
        return hr;
    }

    hr = pCat->QueryInterface(iid, ppv);

    // Release IUnknown ptr...if QI failed, this will delete the object
    pCat->Release();

    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatFactory::LockServer
// 
// Synopsis: Lock the server (keep the DLL loaded)
//
// Arguments:
//  fLock: TRUE, lock the server.  FALSE, unlock.
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 22:29:48: Created.
//
//-------------------------------------------------------------
HRESULT CCatFactory::LockServer(
    BOOL fLock)
{
    if(fLock)
        InterlockedIncrement(&g_cServerLocks);
    else
        InterlockedDecrement(&g_cServerLocks);

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::QueryInterface
//
// Synopsis: Get any interface on the public categorizer interface
//
// Arguments:
//  iid: Interface ID
//  ppv: ptr to where to place the interface ptr
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support this interface
//
// History:
// jstamerj 1998/12/12 22:31:43: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CSMTPCategorizer::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    if((iid == IID_IUnknown) ||
        (iid == IID_ISMTPCategorizer)) {

        *ppv = (ISMTPCategorizer *)this;

    } else if(iid == IID_IMarshal) {

        _ASSERT(m_pMarshaler);
        return m_pMarshaler->QueryInterface(iid, ppv);

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::ChangeConfig
//
// Synopsis: Change the configuration of this categorizer
//
// Arguments:
//  pConfigInfo: the config info structure
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/12/12 22:35:21: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::ChangeConfig(
    IN  PCCATCONFIGINFO pConfigInfo)
{
    return m_ABCtx.ChangeConfig(
        pConfigInfo);
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatMsg
//
// Synopsis: Categorizer a message
//
// Arguments:
//  pMsg: the mailmsg to categorize
//  pICompletion: the completion interface
//  pUserContext: a user supplied context
//
// Returns:
//  S_OK: Success, will complete async
//  E_INVALIDARG
//  CAT_E_INIT_FAILED
//
// History:
// jstamerj 1998/12/12 22:37:57: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatMsg(
    IN  IUnknown *pMsg,
    IN  ISMTPCategorizerCompletion *pICompletion,
    IN  LPVOID pUserContext)
{
    HRESULT hr = S_OK;
    PCATMSGCONTEXT pContext = NULL;

    if((pMsg == NULL) ||
       (pICompletion == NULL)) {

        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    pContext = new CATMSGCONTEXT;
    if(pContext == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    ZeroMemory(pContext, sizeof(CATMSGCONTEXT));

    pContext->pCCat = m_ABCtx.AcquireCCategorizer();

    if(pContext->pCCat) {

        pContext->pCSMTPCat = this;
        pContext->pICompletion = pICompletion;
        pContext->pUserContext = pUserContext;

        pICompletion->AddRef();
        AddRef();

        hr = pContext->pCCat->AsyncResolveIMsg(
                pMsg,
                CatMsgCompletion,
                pContext);
        if(FAILED(hr))
            goto CLEANUP;

    } else {
        //
        // If pCCat is NULL, initialization did not happen
        //
        hr = CAT_E_INIT_FAILED;
        goto CLEANUP;
    }
    hr = S_OK;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Cleanup context when failing
        //
        if(pContext) {
            if(pContext->pCCat)
                pContext->pCCat->Release();
            if(pContext->pCSMTPCat)
                pContext->pCSMTPCat->Release();
            if(pContext->pICompletion)
                pContext->pICompletion->Release();
            delete pContext;
        }
    }
    return hr;
}

    

//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatMsgCompletion
//
// Synopsis: Called upon categorizer completion
//
// Arguments:
//  hr: Status of categorization
//  pContext: our context
//  pIMsg: the categorized message
//  rgpIMsg: array of categorized messages
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 22:50:26: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatMsgCompletion(
    HRESULT hr,
    PVOID pContext,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    _ASSERT(pContext);

    PCATMSGCONTEXT pMyContext = (PCATMSGCONTEXT)pContext;

    //
    // Release the virtual cat reference (ccategorizer)
    //
    pMyContext->pCCat->Release();
    pMyContext->pCSMTPCat->Release();

    _VERIFY(SUCCEEDED(pMyContext->pICompletion->CatCompletion(
        hr,
        pMyContext->pUserContext,
        pIMsg,
        rgpIMsg)));

    //
    // Release user's completion interface
    //
    pMyContext->pICompletion->Release();

    delete pMyContext;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatDLMsg
//
// Synopsis: Categorizer a message just to expand DLs
//
// Arguments:
//  pMsg: the mailmsg to categorize
//  pICompletion: the completion interface
//  pUserContext: a user supplied context
//  fMatchOnly: stop resolution when a match is found?
//  CAType: address type you're looking for
//  pszAddress: address string you're looking for
//
// Returns:
//  S_OK: Success, will complete async
//  E_INVALIDARG
//  CAT_E_INIT_FAILED
//
// History:
// jstamerj 1998/12/12 22:55:40: Created
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatDLMsg(
    IN  IUnknown *pMsg,
    IN  ISMTPCategorizerDLCompletion *pICompletion,
    IN  LPVOID pUserContext,
    IN  BOOL fMatchOnly,
    IN  CAT_ADDRESS_TYPE CAType,
    IN  LPSTR pszAddress)
{
    HRESULT hr = S_OK;
    PCATDLMSGCONTEXT pContext = NULL;

    if((pMsg == NULL) ||
       (pICompletion == NULL)) {

        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    pContext = new CATDLMSGCONTEXT;

    if(pContext == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    ZeroMemory(pContext, sizeof(CATDLMSGCONTEXT));

    pContext->pCCat = m_ABCtx.AcquireCCategorizer();

    if(pContext->pCCat) {

        pContext->pCSMTPCat = this;
        pContext->pICompletion = pICompletion;
        pContext->pUserContext = pUserContext;
        pContext->fMatch = FALSE;
        pICompletion->AddRef();
        AddRef();

        hr = pContext->pCCat->AsyncResolveDLs(
            pMsg,
            CatDLMsgCompletion,
            pContext,
            fMatchOnly,
            &(pContext->fMatch),
            CAType,
            pszAddress);
        if(FAILED(hr))
            goto CLEANUP;

    } else {
        //
        // Init must have failed
        //
        hr = CAT_E_INIT_FAILED;
        goto CLEANUP;
    }
    hr = S_OK;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Cleanup context when failing
        //
        if(pContext) {
            if(pContext->pCCat)
                pContext->pCCat->Release();
            if(pContext->pCSMTPCat)
                pContext->pCSMTPCat->Release();
            if(pContext->pICompletion)
                pContext->pICompletion->Release();
            delete pContext;
        }
    }
    return hr;
}

    

//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatDLMsgCompletion
//
// Synopsis: Called upon categorizer completion
//
// Arguments:
//  hr: Status of categorization
//  pContext: our context
//  pIMsg: the categorized message
//  rgpIMsg: array of categorized messages
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/12 22:50:26: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatDLMsgCompletion(
    HRESULT hr,
    PVOID pContext,
    IUnknown *pIMsg,
    IUnknown **rgpIMsg)
{
    _ASSERT(pContext);

    PCATDLMSGCONTEXT pMyContext = (PCATDLMSGCONTEXT)pContext;

    _ASSERT(rgpIMsg == NULL);

    //
    // Release the virtual cat reference (ccategorizer)
    //
    pMyContext->pCCat->Release();
    pMyContext->pCSMTPCat->Release();

    _VERIFY(SUCCEEDED(pMyContext->pICompletion->CatDLCompletion(
        hr,
        pMyContext->pUserContext,
        pIMsg,
        pMyContext->fMatch)));

    //
    // Release user's completion interface
    //
    pMyContext->pICompletion->Release();
    delete pMyContext;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CatCancel
//
// Synopsis: Cancel pending resolves
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/13 00:07:47: Created.
//
//-------------------------------------------------------------
HRESULT CSMTPCategorizer::CatCancel()
{
    CCategorizer *pCCat;

    pCCat = m_ABCtx.AcquireCCategorizer();

    if(pCCat) {

        pCCat->Cancel();
        pCCat->Release();
    }
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::CSMTPCategorizer
//
// Synopsis: constructor -- initialize Cat with a default config
//
// Arguments:
//  phr: pointer to hresult to set to status
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/13 00:10:15: Created.
//
//-------------------------------------------------------------
CSMTPCategorizer::CSMTPCategorizer(
    HRESULT *phr)
{
    #define STATUS_DLLINIT     0x1
    #define STATUS_GLOBINIT    0x2
    DWORD dwStatus = 0;
    CCATCONFIGINFO ConfigInfo;
    CHAR szBindType[] = "CurrentUser";

    InterlockedIncrement(&g_cObjects);

    _ASSERT(phr);

    m_pMarshaler = NULL;

    //
    // Call HrDllInitialize once for every CSMTPCategorizer object created
    //
    *phr = HrDllInitialize();
    if(FAILED(*phr))
        goto CLEANUP;

    dwStatus |= STATUS_DLLINIT;
    //
    // Call CatInitGlobals once for every CSMTPCategorizer object created
    //
    *phr = CatInitGlobals();
    if(FAILED(*phr))
        goto CLEANUP;

    dwStatus |= STATUS_GLOBINIT;

    *phr = CoCreateFreeThreadedMarshaler(
        (IUnknown *)this,
        &m_pMarshaler);
    if(FAILED(*phr))
        goto CLEANUP;

    //
    // Bind as currentUser until we are told differently
    //
    ConfigInfo.dwCCatConfigInfoFlags = CCAT_CONFIG_INFO_FLAGS |
                                       CCAT_CONFIG_INFO_ENABLE |
                                       CCAT_CONFIG_INFO_BINDTYPE;
        
                                       
    ConfigInfo.dwCatFlags = SMTPDSFLAG_ALLFLAGS;
    ConfigInfo.dwEnable = SMTPDSUSECAT_ENABLED;
    ConfigInfo.pszBindType = szBindType;

    *phr = m_ABCtx.ChangeConfig(&ConfigInfo);

 CLEANUP:
    if(FAILED(*phr)) {

        if(dwStatus & STATUS_GLOBINIT)
            CatDeinitGlobals();

        if(dwStatus & STATUS_DLLINIT)
            DllDeinitialize();
    }
}


//+------------------------------------------------------------
//
// Function: CSMTPCategorizer::~CSMTPCategorizer
//
// Synopsis: Release data/references held by this object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/15 17:53:58: Created.
//
//-------------------------------------------------------------
CSMTPCategorizer::~CSMTPCategorizer()
{
    if(m_pMarshaler)
        m_pMarshaler->Release();
    InterlockedDecrement(&g_cObjects);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\comdll.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: comdll.h
//
// Contents: definitions of things needed to implement comdll.cpp
//
// Classes:
//  CCatFactory
//  CSMTPCategorizer
//
// Functions:
//
// History:
// jstamerj 1998/12/12 15:18:03: Created.
//
//-------------------------------------------------------------
#ifndef __CATCOMDLL_H__
#define __CATCOMDLL_H__

#include <windows.h>
#include <objbase.h>
#include <baseobj.h>
#include <aqinit.h>
#include "smtpevent.h"
#include "address.h"
#include "catglobals.h"

//
// These defines are relevant to the Platinum version (phatq.dll)
//
#define SZ_PHATQCAT_FRIENDLY_NAME   "Microsoft Exchange Categorizer"
#define SZ_PROGID_PHATQCAT          "Exchange.PhatQCat"
#define SZ_PROGID_PHATQCAT_VERSION  "Exchange.PhatQCat.1"

//
// These defines are relevant to the NT5 version (aqueue.dll)
//
#define SZ_CATFRIENDLYNAME "Microsoft SMTPSVC Categorizer"
#define SZ_PROGID_SMTPCAT_VERSION   "Smtp.Cat.1"

#ifdef PLATINUM
#define SZ_CATVER_FRIENDLY_NAME     SZ_PHATQCAT_FRIENDLY_NAME
#define SZ_PROGID_CATVER            SZ_PROGID_PHATQCAT
#define SZ_PROGID_CATVER_VERSION    SZ_PROGID_PHATQCAT_VERSION
#define CLSID_CATVER                CLSID_PhatQCat
#else //PLATINUM
#define SZ_CATVER_FRIENDLY_NAME     SZ_CATFRIENDLYNAME
#define SZ_PROGID_CATVER            SZ_PROGID_SMTPCAT
#define SZ_PROGID_CATVER_VERSION    SZ_PROGID_SMTPCAT_VERSION
#define CLSID_CATVER                CLSID_SmtpCat
#endif //PLATINUM


extern LONG g_cObjects;

//
// The categorizer class factory
//
class CCatFactory : 
    public IClassFactory,
    public CBaseObject
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (
        REFIID iid,
        LPVOID *ppv);

    STDMETHOD_(ULONG, AddRef) ()
    { 
        return CBaseObject::AddRef();
    }
    STDMETHOD_(ULONG, Release) () 
    {
        ULONG lRet;
        lRet = CBaseObject::Release();

        if(lRet == 0) {
            //
            // Deinit reference added from DllGetClassObject
            //
            CatDeinitGlobals();
            DllDeinitialize();
        }
        return lRet;
    }

    //IClassFactory
    STDMETHOD (CreateInstance) (
        IUnknown *pUnknownOuter,
        REFIID iid,
        LPVOID *ppv);

    STDMETHOD (LockServer) (
        BOOL fLock);

  public:
    CCatFactory()
    {
        InterlockedIncrement(&g_cObjects);
    }
    ~CCatFactory()
    {
        InterlockedDecrement(&g_cObjects);
    }
};

//
// The ISMTPCategorizer object
//
CatDebugClass(CSMTPCategorizer),
    public ISMTPCategorizer,
    public CBaseObject
{
  public:
    //IUnknown
    STDMETHOD (QueryInterface) (
        REFIID iid,
        LPVOID *ppv);

    STDMETHOD_(ULONG, AddRef) ()
    { 
        return CBaseObject::AddRef();
    }
    STDMETHOD_(ULONG, Release) () 
    {
        ULONG lRet;
        lRet = CBaseObject::Release();
        if(lRet == 0) {
            //
            // Release DLL refcount added from this object's constructor
            //
            CatDeinitGlobals();
            DllDeinitialize();
        }
        return lRet;
    }

    //ISMTPCategorizer
    STDMETHOD (ChangeConfig) (
        IN  PCCATCONFIGINFO pConfigInfo);

    STDMETHOD (CatMsg) (
        IN  IUnknown *pMsg,
        IN  ISMTPCategorizerCompletion *pICompletion,
        IN  LPVOID pContext);

    STDMETHOD (CatDLMsg) (
        IN  IUnknown *pMsg,
        IN  ISMTPCategorizerDLCompletion *pICompletion,
        IN  LPVOID pContext,
        IN  BOOL fMatchOnly,
        IN  CAT_ADDRESS_TYPE CAType,
        IN  LPSTR pszAddress);

    STDMETHOD (CatCancel) ();

    //Constructor
    CSMTPCategorizer(HRESULT *phr);
    //Destructor
    ~CSMTPCategorizer();

  private:
    static HRESULT CatMsgCompletion(
        HRESULT hr,
        PVOID pContext,
        IUnknown *pIMsg,
        IUnknown **rgpIMsg);

    static HRESULT CatDLMsgCompletion(
        HRESULT hr,
        PVOID pContext,
        IUnknown *pIMsg,
        IUnknown **rgpIMsg);

  private:
    CABContext m_ABCtx;
    IUnknown *m_pMarshaler;

  private:
    typedef struct _CatMsgContext {
        CCategorizer *pCCat;
        CSMTPCategorizer *pCSMTPCat;
        ISMTPCategorizerCompletion *pICompletion;
        LPVOID pUserContext;
    } CATMSGCONTEXT, *PCATMSGCONTEXT;

    typedef struct _CatDLMsgContext {
        CCategorizer *pCCat;
        CSMTPCategorizer *pCSMTPCat;
        ISMTPCategorizerDLCompletion *pICompletion;
        LPVOID pUserContext;
        BOOL fMatch;
    } CATDLMSGCONTEXT, *PCATDLMSGCONTEXT;
};
#endif //__CATCOMDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc

$(O)\phatqmsg.h $(O)\phatqmsg.rc $(O)\msg00001.bin: $(STAXINC)\export\phatqmsg.mc
    copy /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\phatqmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\phatqmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ccataddr.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: ccataddr.cpp
//
// Contents: Implementation of CCatAddr methods
//
// Classes:
//   CCatAddr
//
// Functions:
//   CCatAddr::CCatAddr
//   CCatAddr::~CCatAddr
//   CCatAddr::HrDispatchQuery
//   CCatAddr::IsAddressLocal
//   CCatAddr::SwitchToAliasedDomain
//
// History:
// jstamerj 980324 19:26:50: Created.
//
//-------------------------------------------------------------

#include "precomp.h"
#include "addr821.hxx"

//
// Convert the X400 address with leading '/' as 
// seperator to the form with trailing ';'
//
// If conversion is needed, pszOriginalAddr will
// be changed. 
//
void  ConvertX400DelimitersIfNeeded ( char *pszOriginalAddr)
{
    char * pCurrent = NULL;
 
    //
    // If the x400 doesn't contain '/'
    // or it doesn't start with '/'
    // then no need to do any conversion
    //   
    if ( NULL == pszOriginalAddr ||  '/' != pszOriginalAddr[0] )
        return;
    
    //
    // shift left one byte 
    // and convert all the / to ;
    //
    for (pCurrent = pszOriginalAddr; *(pCurrent+1) != 0; pCurrent++) {
        
        *pCurrent = *(pCurrent+1);
        if ('/' == *pCurrent ) 
            *pCurrent = ';' ;
    }

    // We need to terminate with ';', otherwise LDAP search will not match.
    if ((pCurrent > pszOriginalAddr) && (*(pCurrent - 1) != ';'))
        *pCurrent++ = ';';

    *pCurrent = 0;
}

//+------------------------------------------------------------
//
// Function: CCatAddr::CCatAddr
//
// Synopsis: Initializes member data of CCatAddr
//
// Arguments:
//   pIRC:   pointer to IMsg resolve list context structure
//
// Returns: Nothing
//
// History:
// jstamerj 980324 19:29:07: Created.
//
//-------------------------------------------------------------

CCatAddr::CCatAddr(
    CICategorizerListResolveIMP *pCICatListResolve
)
{
    CatFunctEnterEx((LPARAM)this,"CCatAddr::CCatAddr");
    _ASSERT(pCICatListResolve != NULL);
    _ASSERT(pCICatListResolve->GetCCategorizer() != NULL);

    m_pCICatListResolve = pCICatListResolve;
    //
    // AddRef here, release in destructor
    //
    m_pCICatListResolve->AddRef();

    m_dwlocFlags = LOCF_UNKNOWN;

    CatFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CCatAddr::~CCatAddr()
//
// Synopsis: Releases CCatAddr member data
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 980324 19:31:48: Created.
//
//-------------------------------------------------------------
CCatAddr::~CCatAddr()
{
    CatFunctEnterEx((LPARAM)this, "CCatAddr::~CCatAddr");
    m_pCICatListResolve->Release();
    CatFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CIMsgSenderAddr::HrGetOrigAddress
//
// Synopsis: Fetches an original address from the IMsg object
//           Addresses are fetched with the following preference:
//           SMTP, X500, X400, Foreign addres type
//
// Arguments:
//   psz: Buffer in which to copy address
//  dwcc: Size of buffer pointed to by psz in chars.
// pType: pointer to a CAT_ADDRESS_TYPE to set to the type of address
//        placed in psz. 
//
// Returns:
//  S_OK: on Success
//  CAT_E_PROPNOTFOUND: A required property was not set
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER):
//    dwcc needs to be at most CAT_MAX_INTERNAL_FULL_EMAIL
//
// History:
// jstamerj 1998/07/30 20:55:46: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetOrigAddress(
    LPTSTR psz,
    DWORD dwcc,
    CAT_ADDRESS_TYPE *pType)
{
    HRESULT hr;
    //
    // Array of possible address to retrieve in order of priority:
    //
    CAT_ADDRESS_TYPE *pCAType;
    CAT_ADDRESS_TYPE rgCAType[] = {
        CAT_SMTP,
        CAT_DN,
        CAT_X400,
        CAT_LEGACYEXDN,
        CAT_CUSTOMTYPE,
        CAT_UNKNOWNTYPE         // Must be the last element of the array
    };

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrGetOrigAddress");

    pCAType = rgCAType;

    do {

        hr = GetSpecificOrigAddress(
            *pCAType,
            psz,
            dwcc);

    } while((hr == CAT_IMSG_E_PROPNOTFOUND) && 
            (*(++pCAType) != CAT_UNKNOWNTYPE));

    if(SUCCEEDED(hr)) {

        // Pass back the type found
        *pType = *pCAType;

        DebugTrace((LPARAM)this, "found address type %d", *pType);
        DebugTrace((LPARAM)this, "found address %s", psz);

    } else {

        ERROR_LOG_ADDR(this, "GetSpecificOrigAddress");
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrGetLookupAddresss
//
// Synopsis: Retrieve the address to be looked up in the DS -- this
//           calls HrGetOrigAddress, then switches any alias domain
//
// Arguments:
//   psz: Buffer in which to copy address
//  dwcc: Size of buffer pointed to by psz in chars.
// pType: pointer to a CAT_ADDRESS_TYPE to set to the type of address
//        placed in psz. 
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/10/28 15:44:45: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetLookupAddress(
    LPTSTR psz,
    DWORD dwcc,
    CAT_ADDRESS_TYPE *pType)
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this, "HrGetLookupAddress");
    
    hr = HrGetOrigAddress(psz, dwcc, pType);
    ERROR_CLEANUP_LOG_ADDR(this, "HrGetOrigAddress");

    hr = HrSwitchToAliasedDomain(*pType, psz, dwcc);
    ERROR_CLEANUP_LOG_ADDR(this, "HrSwitchToAliasedDomain");
    //
    // Custom type addresses can contain extended characters so
    // convert ANSI 1252 -> UTF8
    //
    if (*pType == CAT_CUSTOMTYPE){
              
        hr = HrCodePageConvert (
            1252,               // source code page
            psz,                //Source address
            CP_UTF8,            // target code page
            psz,                //Target address
            (int) dwcc) ;       //cbytes of preallocated buffer for target address
        ERROR_CLEANUP_LOG_ADDR(this, "HrCodePageConvert");
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    
    return hr;
}

//
// ------------------------------------------------------------
// Async lookup/completion routines:
//


//+------------------------------------------------------------
//
// Function: CCatAddr::HrDispatchQuery()
//
// Synopsis: Dispatch a query to the store for this address
//
// Arguments: None
//
// Returns:
//  S_OK on Success, error hresult on error.
//
// History:
// jstamerj 980324 19:33:28: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrDispatchQuery()
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrDispatchQuery");
    //
    // Only dispatch queries when the list resolve status is OK
    //
    hr = GetListResolveStatus();
    ERROR_CLEANUP_LOG_ADDR(this, "GetListResolveStatus");
    //
    // Assume LookupEntryAsync will succeed and increment pending IO
    // count here
    //
    IncPendingLookups();

    hr =  m_pCICatListResolve->GetEmailIDStore()->LookupEntryAsync(
        this,
        m_pCICatListResolve->GetResolveListContext());
    
    if(FAILED(hr))
    {
        //
        // Wrong assumption...it failed
        //
        DecrPendingLookups();
        ERROR_LOG_ADDR(this, "m_pCICatListResolve->GetEmailIDStore()->LookupEntryAsync");
    }

    if(SUCCEEDED(hr))

        INCREMENT_COUNTER(AddressLookups);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeave();
    return hr;
}


//+------------------------------------------------------------
//
// Function: HrValidateAddress
//
// Synopsis: Given an address type and address, make sure the address
//           is legal AND has a domain part
//
// Arguments:
//   CAType: The address type
//   pszAddress: The address string
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS
//
// History:
// jstamerj 1998/08/18 14:25:58: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrValidateAddress(
    CAT_ADDRESS_TYPE CAType,
    LPTSTR pszAddress)
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrValidateAddress");

    _ASSERT(pszAddress);

    if(CAType != CAT_SMTP) {
        //
        // Assume non-SMTP types are correct
        //
        hr = S_OK;

    } else {
        DWORD dwLen = lstrlen(pszAddress);

        //
        // Run it through the addr821 library
        //
        if(Validate821Address(
            pszAddress,
            dwLen)) {
            
            //
            // it's valid, but does it have a domain?
            //
            LPSTR pszDomain;

            if(Get821AddressDomain(
                pszAddress,
                dwLen,
                &pszDomain) && pszDomain) {
                //
                // Yes, it has a domian part
                //
                hr = S_OK;

            } else {
                //
                // Valid address with no domain
                //
                ErrorTrace((LPARAM)this, "Detected legal address without a domain: %s", 
                           pszAddress);
                hr = CAT_E_ILLEGAL_ADDRESS;
                ERROR_LOG_ADDR(this, "Get821AddressDomain");
            }

        } else {
            //
            // Validate821Address failed
            //
            ErrorTrace((LPARAM)this, "Detected ILLEGAL address: %s",
                       pszAddress);

            hr = CAT_E_ILLEGAL_ADDRESS;
            ERROR_LOG_ADDR(this, "Validate821Address");
        }
    }

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}
            

//+------------------------------------------------------------
//
// Function: CCatAddr::HrGetAddressLocFlags
//
// Synopsis: Given an address, will determine wether or not the
// address SHOULD be local (wether or not the domain is local/alias/whatnot)
//
// Arguments:
//   szAddress: Address string
//   CAType:    Address type of szAddress
//   pfloctype: Pointer to loctype enumeration to set
//   pdwDomainOffset: Pointer to dword to set to the offset of domain
//                    part of address string
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS: szAdderss is not a valid CAType address
//
// History:
// jstamerj 980324 19:35:15: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetAddressLocFlags(
    LPTSTR szAddress,
    CAT_ADDRESS_TYPE CAType,
    DWORD *pdwlocflags,
    DWORD *pdwDomainOffset)
{
    HRESULT hr;
    
    CatFunctEnterEx((LPARAM)this, "CCatAddr::IsAddressLocal");
    _ASSERT(szAddress);
    _ASSERT(pdwlocflags);

    if(CAType == CAT_SMTP) {

        BOOL f;
        LPSTR pszDomain;
        //
        // Get the address domain
        //
        f = Get821AddressDomain(
            szAddress,
            lstrlen(szAddress),
            &pszDomain);

        if(f == FALSE) {

            ErrorTrace((LPARAM)this, "Illegal address: %s", szAddress);
            hr = CAT_E_ILLEGAL_ADDRESS;
            ERROR_LOG_ADDR(this, "Get821AddressDomain");
            return hr;
        }

        if(pszDomain == NULL) {
            //
            // Assume any SMTP address without a domain is the same as
            // the default local domain 
            //
            DebugTrace((LPARAM)this, "Assuming \"%s\" is local", szAddress);

            pszDomain = GetCCategorizer()->GetDefaultSMTPDomain();

            *pdwDomainOffset = 0;

        } else {
            //
            // Remember the offset into the SMTP address where the domain
            // is
            //
            if(pdwDomainOffset)
                *pdwDomainOffset = (DWORD)(pszDomain - szAddress);
        }

        //
        // Lookup the domain and see if it's local
        //
        hr = HrGetSMTPDomainLocFlags(pszDomain, pdwlocflags);

        if(FAILED(hr)) {
            ErrorTrace((LPARAM)this, "GetSMTPDomainLocFlags failed hr %08lx", hr);
            ERROR_LOG_ADDR(this, "HrGetSMTPDomainLocFlags");
            return hr;
        }

    } else {

        DebugTrace((LPARAM)this, "Assuming \"%s\":%d is local",
                   szAddress, CAType);
        //
        //$$TODO: Check locality on other address types
        //
        *pdwlocflags = LOCF_UNKNOWNTYPE;
    }

    DebugTrace((LPARAM)this, "szAddress = %s", szAddress);
    DebugTrace((LPARAM)this, "CAType = %d", CAType);
    DebugTrace((LPARAM)this, "loctype = %08lx", *pdwlocflags);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::GetSMTPDomainLocFlags
//
// Synopsis: Figure out the local type of an SMTP domain
//
// Arguments:
//  pszDomain: SMTP domain string
//  pdwlocflags: Pointer to DWORD falgs to set
//
// Returns:
//  S_OK: Success
//  error from IAdvQueueDomainType
//
// History:
// jstamerj 1998/07/29 13:29:51: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetSMTPDomainLocFlags(
    LPTSTR pszDomain,
    DWORD *pdwlocflags)
{
    HRESULT hr;
    DWORD dwDomainInfoFlags;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::IsSMTPDomainLocal");

    _ASSERT(pszDomain);

    DebugTrace((LPARAM)this, "Domain is %s", pszDomain);

    hr = HrGetSMTPDomainFlags(
        pszDomain,
        &dwDomainInfoFlags);
    ERROR_CLEANUP_LOG_ADDR(this, "HrGetSMTPDomainFlags");

    //
    // Wonderfull...translate from the domain info flags to locflags
    //
    *pdwlocflags = 0;

    if(dwDomainInfoFlags & DOMAIN_INFO_LOCAL_MAILBOX) {
            
        *pdwlocflags |= LOCF_LOCALMAILBOX;

    } else if(dwDomainInfoFlags & DOMAIN_INFO_LOCAL_DROP) {
            
        *pdwlocflags |= LOCF_LOCALDROP;

    } else {
            
        *pdwlocflags |= LOCF_REMOTE;
    }

    if(dwDomainInfoFlags & DOMAIN_INFO_ALIAS) {

        *pdwlocflags |= LOCF_ALIAS;
    }
    DebugTrace((LPARAM)this, "dwlocflags is %08lx", *pdwlocflags);

 CLEANUP:
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}
    
    

//+------------------------------------------------------------
//
// Function: CCatAddr::HrGetSMTPDomainFlags
//
// Synopsis: Given an SMTP domain, retrieive its flags.
//
// Arguments: 
//  pszDomain: SMTP domain to lookup
//  pdwFlags: DWORD flags to fill in
//
// Returns:
//  S_OK: Success
//  error from IAdvQueueDomainType
//
// History:
// jstamerj 1998/09/15 17:11:15: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrGetSMTPDomainFlags(
    LPTSTR pszDomain,
    PDWORD pdwFlags)
{
    HRESULT hr;
    ICategorizerDomainInfo *pIDomainInfo;
    DWORD dwDomainInfoFlags;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrGetSMTPDomainFlags");

    _ASSERT(pszDomain);
    _ASSERT(pdwFlags);

    DebugTrace((LPARAM)this, "Domain is %s", pszDomain);

    pIDomainInfo = m_pCICatListResolve->GetIDomainInfo();

    if(pIDomainInfo) {

        hr = pIDomainInfo->GetDomainInfoFlags(
            pszDomain,
            &dwDomainInfoFlags);

    } else {
        //
        // We have no domain info
        //
        dwDomainInfoFlags = 0;
        hr = S_OK;
    }

    DebugTrace((LPARAM)this, "GetDomainInfoFlags returned hr %08lx", hr);
    DebugTrace((LPARAM)this, "DomainInfoFlags %08lx", dwDomainInfoFlags);

    if(SUCCEEDED(hr)) {

        *pdwFlags = dwDomainInfoFlags;

    } else {

        *pdwFlags = 0;
        ERROR_LOG_ADDR(this, "pIDomainInfo->GetDomainInfoFlags");
    }

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CCatAddr::HrSwitchToAliasedDomain
//
// Synopsis: Swap the domain in pszAddress with the default local
//           domain
//
// Arguments:
//   CAType: Address type
//   pszAddress: Address string
//   dwcch: Size of the pszAddress buffer we have to work with
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS: pszAddress is not a legal CAType address
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): Unable to make the
//  switch because of an insufficient buffer size
//  CAT_E_UNKNOWN_ADDRESS_TYPE: Alias domains are not supported for
//                              this type
//
// History:
// jstamerj 980324 19:39:30: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrSwitchToAliasedDomain(
    CAT_ADDRESS_TYPE CAType,
    LPTSTR pszAddress,
    DWORD dwcch)
{
    HRESULT hr;
    LPTSTR pszDefaultDomain;
    DWORD dwLocFlags;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::SwitchToAliasedDomain");
    DebugTrace((LPARAM)this, "Before switch: %s", pszAddress);

    //
    // Lookup domain info if we haven't already done so
    //
    dwLocFlags = DwGetOrigAddressLocFlags();
    if(dwLocFlags == LOCF_UNKNOWN) {
        hr = CAT_E_ILLEGAL_ADDRESS;
        ERROR_LOG_ADDR(this, "DwGetOrigAddressLocFlags");
        goto CLEANUP;
    }

    if(dwLocFlags & LOCF_ALIAS) {
        //
        // We only handle alias SMTP domains
        //
        _ASSERT(CAType == CAT_SMTP);
        //
        // Assert check the '@' is where we think it is
        //
        _ASSERT(m_dwDomainOffset > 0);
        _ASSERT(dwcch > m_dwDomainOffset);
        _ASSERT(pszAddress[m_dwDomainOffset-1] == '@');

        DebugTrace((LPARAM)this, "Detected alias domain for \"%s\"", pszAddress);
        //
        // Do we have enough buffer space for the switch?
        //
        pszDefaultDomain = GetCCategorizer()->GetDefaultSMTPDomain();

        _ASSERT(pszDefaultDomain);

        if( ((DWORD) lstrlen(pszDefaultDomain)) >=
           (dwcch - m_dwDomainOffset)) {
            //
            // Not enough space
            //
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            ERROR_LOG_ADDR(this, "--insufficient buffer--");
            //
            //$$BUGBUG: error is not returned to caller
            //
        } else {

            lstrcpy(pszAddress + m_dwDomainOffset, pszDefaultDomain);
        }
    }
 CLEANUP:

    DebugTrace((LPARAM)this, "After switch: %s", pszAddress);
    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CCatAddr::CheckForDuplicateCCatAddr
//
// Synopsis: Checks to see if any of the addresses in the list match
//           on orig address of this CCatAddr
//
// Arguments:
//  dwNumAddresses: Number of addresses to check
//  rgCAType: Array of address types
//  rgpsz: Array of address strings
//
// Returns:
//  S_OK: Success, no duplicate
//  CAT_IMSG_E_DUPLICATE: Duplicate collision with this CCatAddr
//  or error from GetSpecificOrigAddress
//
// History:
// jstamerj 1998/07/30 21:44:42: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::CheckForDuplicateCCatAddr(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPTSTR *rgpsz)
{
    HRESULT hr = S_OK;
    DWORD dwCount;
    TCHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];

    CatFunctEnterEx((LPARAM)this,
                      "CCatAddr::CheckForDuplicateCCatAddr");

    for(dwCount = 0; dwCount < dwNumAddresses; dwCount++) {
        //
        // Check for this type of address
        //
        hr = GetSpecificOrigAddress(
            rgCAType[dwCount],
            szAddress,
            CAT_MAX_INTERNAL_FULL_EMAIL);

        if(hr == CAT_IMSG_E_PROPNOTFOUND) {
            //
            // If the address doesn't exist, it's obviously not a duplicate
            //
            hr = S_OK;

        } else if(FAILED(hr)) {

            ErrorTrace((LPARAM)this, "GetSpecificOrigAddress failed hr %08lx", hr);
            ERROR_LOG_ADDR(this, "GetSpecificOrigAddress");
            break;

        } else {
            //
            // Match?
            //
            if(lstrcmpi(szAddress, rgpsz[dwCount]) == 0) {

                DebugTrace((LPARAM)this, "CCatAddr detected duplicate for address %s", szAddress);

                hr = CAT_IMSG_E_DUPLICATE;

                break;
            }
        }
    }    
    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::CheckAncestorsForDuplicate
//
// Synopsis: Check our ancestor parent chain for a duplicate address
//
// Arguments:
//  dwNumAddresses: Number of addresses to check
//  rgCAType: Array of address types
//  rgpsz: Array of address strings
//  fCheckSelf: Indicates wether or not to start by checking this
//              CCatAddr (or this CCatAddr's parent)
//  ppCCatAddr: Optional pointer to a pointer to recieve the duplicate
//  CCatAddr.  On CAT_IMSG_E_DUPLICATE, the returned CCatAddr is
//  addref'd for the caller.  Otherwise, this pointer is set to NULL.
//
// Returns:
//  S_OK: Success, no duplicate
//  CAT_IMSG_E_DUPLICATE: Duplicate collision with this CCatAddr
//  or error from GetSpecificOrigAddress
//
// History:
// jstamerj 1998/07/30 21:55:41: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::CheckAncestorsForDuplicate(
    DWORD dwNumAddresses,
    CAT_ADDRESS_TYPE *rgCAType,
    LPTSTR *rgpsz,
    BOOL fCheckSelf,
    CCatAddr **ppCCatAddrDup)
{
    HRESULT hr = S_OK;
    CCatAddr *pCCatAddr;
    CCatAddr *pCCatAddrNew;

    CatFunctEnterEx((LPARAM)this,
                      "CCatAddr::CheckAncestorsForDuplicate");

    if(ppCCatAddrDup) {
        *ppCCatAddrDup = NULL;
    }

    //
    // Get the initial CCatAddr
    //
    if(fCheckSelf) {
        //
        // Start with ourselves
        //
        pCCatAddr = this;
        pCCatAddr->AddRef();

    } else {
        //
        // Start with our parent
        //
        hr = GetParentAddr(&pCCatAddr);
        if(FAILED(hr))
            pCCatAddr = NULL;
    }
    //
    // Loop until something fails as it must eventually do (when there
    // are no more parents)
    //
    while(SUCCEEDED(hr)) {
        //
        // Check duplicate on this ccataddr
        //
        hr = pCCatAddr->CheckForDuplicateCCatAddr(
            dwNumAddresses,
            rgCAType,
            rgpsz);

        //
        // Advance a generation
        //
        if(SUCCEEDED(hr)) {

            hr = pCCatAddr->GetParentAddr(
                &pCCatAddrNew);

            if(SUCCEEDED(hr)) {
                
                pCCatAddr->Release();
                pCCatAddr = pCCatAddrNew;
            }
        }
    }

    if(hr == CAT_E_PROPNOTFOUND) {
        //
        // This means the parent wasn't found -- which means no
        // duplicates were found in the chain
        //  
        hr = S_OK;

    } else if((hr == CAT_IMSG_E_DUPLICATE) && (ppCCatAddrDup)) {
        //
        // If we found a duplicate, let the caller know who the duplicate is
        //
        *ppCCatAddrDup = pCCatAddr;
        //
        // Addref for the caller
        //
        pCCatAddr->AddRef();
    }

    if(pCCatAddr)
        pCCatAddr->Release();

    DebugTrace((LPARAM)this, "Returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::CheckAncestorsForDuplicate
//
// Synopsis: Just like the other CheckAncestorsForDuplicate but it
//           doesn't require any arrays.
//
// Arguments:
//  CAType: Address type
//  pszAddress: Address String
//  fCheckSelf: Check to see if the address is a duplicate of THIS
//  ccataddr as well?
//  ppCCatAddrDup: Optional pointer to recieve a pointer to the
//  CCatAddr that is the duplicate
//
// Returns:
//  S_OK: Success
//  or error from CheckAncestorsForDuplicate (above)
//
// History:
// jstamerj 1998/07/31 20:27:52: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::CheckAncestorsForDuplicate(
    CAT_ADDRESS_TYPE        CAType,
    LPTSTR                  pszAddress,
    BOOL                    fCheckSelf,
    CCatAddr                **ppCCatAddrDup)
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this,
                      "CCatAddr::CheckAncestorsForDuplicate");

    _ASSERT(pszAddress);

    hr = CheckAncestorsForDuplicate(
        1,                  // Number of addresses
        &CAType,            // Array of address types
        &pszAddress,        // Array of address strings
        fCheckSelf,
        ppCCatAddrDup);
    
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrIsOrigAddressLocal
//
// Synopsis: CHeck to see if the original address is local (and
//           remember that fact).  If m_loct is already set, just use it's info
//
// Arguments:
//  pfLocal: ptr to Boolean to set to TRUE of domain is local, FALSE
//           for remote domains
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS: Something prevented us from determining the
//                         local flags of the address
//
// History:
// jstamerj 1998/09/15 17:37:17: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrIsOrigAddressLocal(
    BOOL *pfLocal)
{
    HRESULT hr = S_OK;
    DWORD dwLocFlags;

    _ASSERT(pfLocal);

    dwLocFlags = DwGetOrigAddressLocFlags();
    if(dwLocFlags == LOCF_UNKNOWN)
        return CAT_E_ILLEGAL_ADDRESS;

    *pfLocal = (dwLocFlags & LOCFS_LOCAL)
               ? TRUE : FALSE;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrIsOrigAddressLocalMailbox
//
// Synopsis: CHeck to see if the original address is local mailbox
//
// Arguments:
//  pfLocal: ptr to Boolean to set to TRUE of domain is local mailbox, FALSE
//           for remote domains
//
// Returns:
//  S_OK: Success
//  CAT_E_ILLEGAL_ADDRESS: Something prevented us from determining the
//                         local flags of the address
//
// History:
// jstamerj 1998/09/15 17:37:17: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrIsOrigAddressLocalMailbox(
    BOOL *pfLocal)
{
    HRESULT hr = S_OK;
    DWORD dwLocFlags;

    _ASSERT(pfLocal);

    dwLocFlags = DwGetOrigAddressLocFlags();
    if(dwLocFlags == LOCF_UNKNOWN)
        return CAT_E_ILLEGAL_ADDRESS;

    *pfLocal = (dwLocFlags & LOCF_LOCALMAILBOX)
               ? TRUE : FALSE;

    return S_OK;
}


//+------------------------------------------------------------
//
// Function: DwGetOrigAddressLocFlags
//
// Synopsis: Figure out the LocType of our original address
//
// Arguments: NONE; member data is set
//
// Returns: 
//  LOCF_UNKNOWN: An error was encountered retrieving the local flags
//  non-zero: The local flags
//
// History:
// jstamerj 1998/10/27 18:14:01: Created.
//
//-------------------------------------------------------------
DWORD CCatAddr::DwGetOrigAddressLocFlags()
{
    TCHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
    CAT_ADDRESS_TYPE CAType;
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::DwGetOrigAddressLocFlags");

    if(m_dwlocFlags != LOCF_UNKNOWN)
        //
        // We already have the local type
        //
        goto CLEANUP;

    //
    // Find the domain and look it up
    //
    hr = HrGetOrigAddress(szAddress, CAT_MAX_INTERNAL_FULL_EMAIL, &CAType);
    ERROR_CLEANUP_LOG_ADDR(this, "HrGetOrigAddress");

    hr = HrGetAddressLocFlags(szAddress, CAType, &m_dwlocFlags, &m_dwDomainOffset);
    ERROR_CLEANUP_LOG_ADDR(this, "HrGetAddressLocFlags");

 CLEANUP:
    CatFunctLeaveEx((LPARAM)this);
    return m_dwlocFlags;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::LookupCompletion
//
// Synopsis: Handle the triggering of events once this object has been
//           looked up in the DS
//
// Arguments:
//
// Returns:
//  S_OK: Success, won't call completion
//  MAILTRANSPORT_S_PENDING: will call your completion routine
//
// History:
// jstamerj 1998/09/28 15:59:01: Created.
// jstamerj 1999/03/18 10:04:33: Removed return value and async
//                               completion to asyncctx 
//
//-------------------------------------------------------------
VOID CCatAddr::LookupCompletion()
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::LookupCompletion");

    DebugTrace((LPARAM)this, "Calling HrProcessItem");

    hr = HrProcessItem();

    DebugTrace((LPARAM)this, "HrProcessItem returned hr %08lx", hr);

    _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    ERROR_CLEANUP_LOG_ADDR(this, "HrProcessItem");

    DebugTrace((LPARAM)this, "Calling HrExpandItem");

    hr = HrExpandItem();

    DebugTrace((LPARAM)this, "HrExpandItem returned hr %08lx", hr);

    if(hr == MAILTRANSPORT_S_PENDING)
        goto CLEANUP;
    ERROR_CLEANUP_LOG_ADDR(this, "HrExpandItem");


    DebugTrace((LPARAM)this, "Calling HrCompleteItem");

    hr = HrCompleteItem();

    DebugTrace((LPARAM)this, "HrCompleteItem returned hr %08lx", hr);

    _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    ERROR_CLEANUP_LOG_ADDR(this, "HrCompleteItem");

 CLEANUP:
    if(FAILED(hr)) {

        DebugTrace((LPARAM)this, "Failing categorization with hr %08lx", hr);
        //
        // Fail the entire message categorization
        //
        hr = SetListResolveStatus(hr);

        _ASSERT(SUCCEEDED(hr));

        //
        // We handeled the error
        //
    }
    CatFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrProcessItem
//
// Synopsis: Trigger the processitem event
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from SEO
//
// History:
// jstamerj 1998/09/28 16:32:19: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrProcessItem()
{
    HRESULT hr;
    ISMTPServer *pIServer;
    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrProcessItem");


    pIServer = GetISMTPServer();

    //
    // Trigger ProcessItem -- it's time to figure out these attributes
    //
    EVENTPARAMS_CATPROCESSITEM ProcessParams;
    ProcessParams.pICatParams = GetICatParams();
    ProcessParams.pICatItem   = this;
    ProcessParams.pfnDefault  = MailTransport_Default_ProcessItem;
    ProcessParams.pCCatAddr   = this;

    if(pIServer) {

        hr = pIServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_PROCESSITEM_EVENT,
            &ProcessParams);

        _ASSERT(hr != MAILTRANSPORT_S_PENDING);

    } else {
        hr = E_NOTIMPL;
    }

    if(hr == E_NOTIMPL) {
        //
        // Events are disabled, call default processing directly
        //
        MailTransport_Default_ProcessItem(
            S_OK,
            &ProcessParams);
        hr = S_OK;
    }
    
    //
    // Fail the list resolve when triggerserveevent fails
    //
    if(FAILED(hr)) {

        ERROR_LOG_ADDR(this, "TriggerServerEvent(processitem)");
        //
        // Fail the entire message categorization
        //
        hr = SetListResolveStatus(hr);

        _ASSERT(SUCCEEDED(hr));
    }

    //
    // We handeled the error
    //
    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Default_ProcessItem
//
// Synopsis: Do default work of ProcessItem
//
// Arguments:
//  hrStatus: status of server events
//
// Returns:
//  Whatever HrProcessItem_Default returns
//
// History:
// jstamerj 1998/07/05 18:55:00: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Default_ProcessItem(
    HRESULT hrStatus,
    PVOID pContext)
{
    HRESULT hr;
    PEVENTPARAMS_CATPROCESSITEM pParams = (PEVENTPARAMS_CATPROCESSITEM) pContext;
    CCatAddr *pCCatAddr = (CCatAddr *) (pParams->pCCatAddr);

    hr = pCCatAddr->HrProcessItem_Default();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrProcessItem_Default
//
// Synopsis: Do the default work of ProcessItem
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/28 16:49:21: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrProcessItem_Default()
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this,
                      "CCatAddr::HrProcessItem_Default");

    //
    // CHeck the recipient status
    //
    hr = GetItemStatus();
    if(SUCCEEDED(hr)) {
        //
        // Add all known addresses to the new address list
        //
        hr = HrAddNewAddressesFromICatItemAttr();

        //
        // Fail the categorization if the above call
        // failed
        //
        if(FAILED(hr)) {
            ERROR_LOG_ADDR(this, "HrAddNewAddressesFromICatItemAttr");
            hr = SetListResolveStatus(hr);
            _ASSERT(SUCCEEDED(hr));
        }
    }
    
    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrAddNewAddressesFromICatItemAttr
//
// Synopsis: Dig out each known address type from
//           ICategorizerItemAttributes, format the parameters and
//           call HrAddAddresses
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND: A REQUIRED property was not found
//  return value from HrAddAddresses
//
// History:
// jstamerj 1998/09/28 17:31:39: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrAddNewAddressesFromICatItemAttr()
{
    HRESULT hr;
    DWORD  dwFound, dwTry;
    ICategorizerParameters *pICatParams;
    ICategorizerItemAttributes *pICatItemAttr = NULL;
    ICategorizerUTF8Attributes *pIUTF8 = NULL;
    LPSTR pszAttribute;

    //
    // These are arrays to be filled in with pointers/values of
    // addresses set on the object
    //
    CAT_ADDRESS_TYPE rgCATypes[CAT_MAX_ADDRESS_TYPES];
    LPSTR  rgpszAddrs[CAT_MAX_ADDRESS_TYPES];
    ATTRIBUTE_ENUMERATOR rgenumerators[CAT_MAX_ADDRESS_TYPES];

    //
    // These arrays define the address types to receive
    //
    DWORD rgdwAddressAttributeIds_Try[] = {
        DSPARAMETER_ATTRIBUTE_DEFAULT_SMTP,
        DSPARAMETER_ATTRIBUTE_DEFAULT_X400,
        DSPARAMETER_ATTRIBUTE_DEFAULT_DN,
        DSPARAMETER_ATTRIBUTE_DEFAULT_LEGACYEXDN
    };
    CAT_ADDRESS_TYPE rgCATypes_Try[] = {
        CAT_SMTP,
        CAT_X400,
        CAT_DN,
        CAT_LEGACYEXDN,
        CAT_UNKNOWNTYPE //terminator
    };


    CatFunctEnterEx((LPARAM)this, "CCatAddr:HrAddNewAddressesFromICatItemAttr");

    //
    // Formulate the array
    //
    pICatParams = GetICatParams();
    _ASSERT(pICatParams);
    
    hr = GetICategorizerItemAttributes(
        ICATEGORIZERITEM_ICATEGORIZERITEMATTRIBUTES,
        &pICatItemAttr);
    
    if(FAILED(hr)) {
        pICatItemAttr = NULL;
        ERROR_LOG_ADDR(this, "GetICategorizerItemAttributes");
        goto CLEANUP;
    }

    hr = pICatItemAttr->QueryInterface(
        IID_ICategorizerUTF8Attributes,
        (LPVOID *)&pIUTF8);
    ERROR_CLEANUP_LOG_ADDR(this, "pICatItemAttr->QueryInterface(IID_ICategorizerUTF8Attributes)");
    //
    // Start trying to fetch address.  dwTry maintains our index into
    // the _Try arrays (address prop IDs to try).  dwFound keeps track
    // of the number of addresses we've found and stored in the arrays
    //
    for(dwTry = dwFound = 0;
        rgCATypes_Try[dwTry] != CAT_UNKNOWNTYPE;
        dwTry++) {
        
        //
        // Get the attribute name for this address type
        //
        hr = pICatParams->GetDSParameterA(
            rgdwAddressAttributeIds_Try[dwTry],
            &pszAttribute);

        if(SUCCEEDED(hr)) {

            hr = pIUTF8->BeginUTF8AttributeEnumeration(
                pszAttribute,
                &rgenumerators[dwFound]);

            if(SUCCEEDED(hr)) {
                hr = pIUTF8->GetNextUTF8AttributeValue(
                    &rgenumerators[dwFound],
                    &rgpszAddrs[dwFound]);

                if(SUCCEEDED(hr)) {
                    //
                    // Found the address!  Leave it in the new array;
                    // call EndAttributeEnumeration later
                    //
                    rgCATypes[dwFound] = rgCATypes_Try[dwTry];

                    DebugTrace((LPARAM)this, "Address #%d, type %d: \"%s\"",
                               dwFound,
                               rgCATypes[dwFound],
                               rgpszAddrs[dwFound]);

                    dwFound++;

                } else {
                    //
                    // Not found; call EndAttributeEnumeration now
                    //
                    pIUTF8->EndUTF8AttributeEnumeration(&rgenumerators[dwFound]);
                }   
            }
        }
    }
    DebugTrace((LPARAM)this, "Found %d addresses on this recipient", dwFound);

    //
    // Call HrAddAddresses with the addresses we've found
    //
    hr = HrAddAddresses(
        dwFound,
        rgCATypes,
        rgpszAddrs);
    if(FAILED(hr)) {
        ERROR_LOG_ADDR(this, "HrAddAddresses");
    }

    //
    // End all attribute enumerations going on
    //
    for(dwTry = 0; dwTry < dwFound; dwTry++) {

        pIUTF8->EndUTF8AttributeEnumeration(&rgenumerators[dwTry]);
    }

 CLEANUP:
    if(pIUTF8)
        pIUTF8->Release();
    if(pICatItemAttr)
        pICatItemAttr->Release();
    //
    // jstamerj 2001/12/13 16:36:07:
    // We are working around a bizarre compiler problem here...
    // If you delete this comment block and you try to compile a
    // RETAIL build with VC++ version 13.00.8806, the compiler gives
    // you the following error: 
    //
    // d:\src\ptsp\0\transmt\src\phatq\cat\src\ccataddr.cpp(1469) : fatal error C1001: INTERNAL COMPILER ERROR
    // (compiler file 'f:\vs70builds\8809\vc\p2\src\P2\color.c', line 6219)
    // Please choose the Technical Support command on the Visual C++
    // Help menu, or open the Technical Support help file for more information
    //
    // jstamerj 2001/12/20 14:13:02: Today I am getting the internal
    // compiler error regardless of wether or not the comment block is
    // here.  I am commenting out the DebugTrace line to make the
    // compiler error go away.
    //
    //DebugTrace((LPARAM)this, "Function returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrExpandItem
//
// Synopsis: Trigger the expandItem event
//
// Arguments:
//  pfnCompletion: Async completion routine
//  lpCompletionContext: context for the completion routine
//
// Returns:
//  S_OK: Success
//  MAILTRANSPORT_S_PENDING: will call the completion routine
//  or error from SEO
//
// History:
// jstamerj 1998/09/28 18:26:49: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrExpandItem()
{
    HRESULT hr;
    ISMTPServer *pIServer;
    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrExpandItem");

    pIServer = GetISMTPServer();

    //
    // Increment the IO count assuming this will compelete async
    //
    IncPendingLookups();

    //
    // Trigger ExpandItem
    //
    EVENTPARAMS_CATEXPANDITEM ExpandParams;
    ExpandParams.pICatParams = GetICatParams();
    ExpandParams.pICatItem = this;
    ExpandParams.pfnDefault = MailTransport_Default_ExpandItem;
    ExpandParams.pfnCompletion = MailTransport_Completion_ExpandItem;
    ExpandParams.pCCatAddr = (PVOID) this;

    if(pIServer) {

        hr = pIServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_EXPANDITEM_EVENT,
            &ExpandParams);

    } else {
        hr = E_NOTIMPL;
    }

    if(hr == E_NOTIMPL) {
        ExpandParams.pIMailTransportNotify = NULL;
        //
        // Events are disabled -- since this is an async capable event
        // we need to realloc on the heap
        //
        PEVENTPARAMS_CATEXPANDITEM pParams;
        pParams = new EVENTPARAMS_CATEXPANDITEM;

        if(pParams == NULL) {

            hr = E_OUTOFMEMORY;
            ERROR_LOG_ADDR(this, "new EVENTPARAMS_CATEXPANDITEM");

        } else {

            CopyMemory(pParams, &ExpandParams, sizeof(EVENTPARAMS_CATEXPANDITEM));
            //
            // Events are disabled, call default processing directly
            //
            hr = MailTransport_Default_ExpandItem(
                S_OK,
                pParams);
        }
    }
    
    if(hr != MAILTRANSPORT_S_PENDING)
        DecrPendingLookups(); // We did not complete async

    if(FAILED(hr)) {
        //
        // Set the resolve status for this item to error
        //
        ERROR_LOG_ADDR(this, "TriggerServerEvent(expanditem)");
        //
        // Fail the entire message categorization
        //
        hr = SetListResolveStatus(hr);

        _ASSERT(SUCCEEDED(hr));
    }
    //
    // If TriggerServerEvent returned pending, we must also return
    // pending.  MailTransport_Completon_ExpandItem will be called
    // when all sinks have fired.
    //
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: MailTransport_Default_ExpandItem
//
// Synopsis: Wrapper to do default work of ExpandItem
//
// Arguments:
//  hrStatus: status of server events
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/07/05 18:58:01: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Default_ExpandItem(
    HRESULT hrStatus,
    PVOID pContext)
{
    HRESULT hr;
    PEVENTPARAMS_CATEXPANDITEM pParams = (PEVENTPARAMS_CATEXPANDITEM) pContext;
    CCatAddr *pCCatAddr = (CCatAddr *) (pParams->pCCatAddr);

    hr = pCCatAddr->HrExpandItem_Default(
        MailTransport_DefaultCompletion_ExpandItem,
        pContext);

    return hr;
}


//+------------------------------------------------------------
//
// Function: MailTransport_DefaultCompletion_ExpandItem
//
// Synopsis: The completion routine called when expanding the item is done
//
// Arguments:
//  pContext: Context passed to ExpandPropsFromLdapEntry
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/09/23 16:09:04: Created.
//
//-------------------------------------------------------------
VOID MailTransport_DefaultCompletion_ExpandItem(
    PVOID pContext)
{
    HRESULT hr;
    PEVENTPARAMS_CATEXPANDITEM pParams = (PEVENTPARAMS_CATEXPANDITEM) pContext;

    _ASSERT(pParams);

    if(pParams->pIMailTransportNotify) {
        //
        // Notify the SEO dispatcher of async completion
        //
        hr = pParams->pIMailTransportNotify->Notify(
            S_OK,
            pParams->pvNotifyContext);

    } else {
        //
        // Events are disabled
        //
        hr = MailTransport_Completion_ExpandItem(
            S_OK,
            pContext);
    }
    _ASSERT(SUCCEEDED(hr));
}


//+------------------------------------------------------------
//
// Function: MailTransport_Completion_ExpandItem
//
// Synopsis: Handle async completion of an event -- this is only
//           called when one or more ExpandItem sinks complete asynch
//
// Arguments:
//  hrStatus: status of server event
//  pContext: a PEVENTPARAMS_CATEXPANDITEM
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/09/18 18:09:56: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Completion_ExpandItem(
    HRESULT hrStatus,
    PVOID pContext)
{
    HRESULT hr;

    PEVENTPARAMS_CATEXPANDITEM pParams = (PEVENTPARAMS_CATEXPANDITEM) pContext;
    CCatAddr *pCCatAddr = (CCatAddr *) (pParams->pCCatAddr);
    ISMTPServer *pISMTPServer;

    pISMTPServer = pCCatAddr->GetISMTPServer();
    //
    // After ExpandItem, trigger CompleteItem
    //
    hr = pCCatAddr->HrCompleteItem();

    _ASSERT(hr != MAILTRANSPORT_S_PENDING);
    _ASSERT(SUCCEEDED(hr));

    if(pISMTPServer == NULL) {
        //
        // Events are disabled -- need to free eventparams
        //
        delete pParams;
    }
    //
    // Decrement the pending lookup count incremented in HrExpandItem
    //
    pCCatAddr->DecrPendingLookups();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CCatAddr::HrCompleteItem
//
// Synopsis: Trigger the completeitem event
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from SEO
//
// History:
// jstamerj 1998/09/28 16:32:19: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrCompleteItem()
{
    HRESULT hr;
    ISMTPServer *pIServer;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrCompleteItem");

    pIServer = GetISMTPServer();
    //
    // Trigger ProcessItem -- it's time to figure out these attributes
    //
    EVENTPARAMS_CATCOMPLETEITEM CompleteParams;
    CompleteParams.pICatParams = GetICatParams();
    CompleteParams.pICatItem = this;
    CompleteParams.pfnDefault = MailTransport_Default_CompleteItem;
    CompleteParams.pCCatAddr = this;

    if(pIServer) {

        hr = pIServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_COMPLETEITEM_EVENT,
            &CompleteParams);

    } else {
        hr = E_NOTIMPL;
    }

    if(hr == E_NOTIMPL) {
        //
        // Events are disabled, call default processing directly
        //
        MailTransport_Default_CompleteItem(
            S_OK,
            &CompleteParams);
        
        hr = S_OK;
    }

    _ASSERT(hr != MAILTRANSPORT_S_PENDING);
    
    //
    // Fail the list resolve when triggerserveevent fails
    //
    if(FAILED(hr)) {

        ERROR_LOG_ADDR(this, "TriggerServerEvent(completeitem)");
        //
        // Fail the entire message categorization
        //
        hr = SetListResolveStatus(hr);

        _ASSERT(SUCCEEDED(hr));
    }

    //
    // We handeled the any error
    //
    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: MailTransport_Default_CompleteItem
//
// Synopsis: Wrapper routing to do default work of CompleteItem
//
// Arguments:
//  hrStatus: status of server events
//
// Returns:
//  Whatever HrCompleteItem_Default returns
//
// History:
// jstamerj 1998/07/05 18:58:01: Created.
//
//-------------------------------------------------------------
HRESULT MailTransport_Default_CompleteItem(
    HRESULT hrStatus,
    PVOID pContext)
{
    HRESULT hr;
    PEVENTPARAMS_CATCOMPLETEITEM pParams = (PEVENTPARAMS_CATCOMPLETEITEM) pContext;
    CCatAddr *pCCatAddr = (CCatAddr *) (pParams->pCCatAddr);

    hr = pCCatAddr->HrCompleteItem_Default();
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCatAddr::HrResolveIfNecessary
//
// Synopsis: Call DispatchQuery only if DsUseCat indicates we should
//           resolve this type of recipient
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, dispatched an async query
//  S_FALSE: It was not necessary to resolve this recipient
//  or error from HrDispatchQuery
//
// History:
// jstamerj 1998/10/27 15:31:54: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrResolveIfNecessary()
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrResolveIfNecessary");
    //
    // So is it necessary?
    //
    hr = HrNeedsResolveing();
    ERROR_CLEANUP_LOG_ADDR(this, "HrNeedsResolveing");

    if(hr == S_OK) {
        //  
        // It is necessary; resolve it.
        //
        hr = HrDispatchQuery();
        ERROR_CLEANUP_LOG_ADDR(this, "HrDispatchQuery");
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}



//+------------------------------------------------------------
//
// Function: CCatAddr::HrTriggerBuildQuery
//
// Synopsis: Build a query for this CCatAddr
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1999/03/23 16:00:08: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrTriggerBuildQuery()
{
    HRESULT hr = S_OK;
    ISMTPServer *pISMTPServer;
    ICategorizerParameters *pICatParams;
    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrTriggerBuildQuery");

    //
    // Trigger the buildquery event
    //
    pISMTPServer = GetISMTPServer();
    pICatParams = GetICatParams();
    
    EVENTPARAMS_CATBUILDQUERY EventParams;
    EventParams.pICatParams = pICatParams;
    EventParams.pICatItem = this;
    EventParams.pfnDefault = HrBuildQueryDefault;
    EventParams.pCCatAddr = (PVOID)this;

    if(pISMTPServer) {

        hr = pISMTPServer->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_BUILDQUERY_EVENT,
            &EventParams);

    } else {
        hr = E_NOTIMPL;
    }
    
    if(hr == E_NOTIMPL) {
        //
        // Server events are disabled; call default sink directly
        //
        HrBuildQueryDefault(
            S_OK,
            &EventParams);
        hr = S_OK;
    }
    ERROR_CLEANUP_LOG_ADDR(this, "TriggerServerEvent");

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrTriggerBuildQuery


//+------------------------------------------------------------
//
// Function: CCatAddr::HrBuildQueryDefault
//
// Synopsis: The default sink for the buildquery event
//
// Arguments:
//  HrStatus: status of the event so far
//  pContext: Context passed to 
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/23 16:02:41: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrBuildQueryDefault(
    HRESULT HrStatus,
    PVOID   pContext)
{
    HRESULT hr = S_OK;
    PEVENTPARAMS_CATBUILDQUERY pParams;
    CCatAddr *pCCatAddr;
    
    pParams = (PEVENTPARAMS_CATBUILDQUERY) pContext;
    pCCatAddr = (CCatAddr *)pParams->pCCatAddr;

    CatFunctEnterEx((LPARAM)pCCatAddr, "CCatAddr::HrBuildQueryDefault");
    hr = pCCatAddr->HrComposeLdapFilter();

    DebugTrace((LPARAM)pCCatAddr, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)pCCatAddr);
    return hr;
} // CCatAddr::HrBuildQueryDefault


//+------------------------------------------------------------
//
// Function: CCatAddr::HrComposeLdapFilter
//
// Synopsis: Build a query string for this CCatAddr
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/23 16:08:30: Created.
// dlongley 2001/08/02 Modified.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrComposeLdapFilter()
{
    HRESULT hr = S_OK;
    ICategorizerParameters *pICatParams;
    CAT_ADDRESS_TYPE CAType;
    TCHAR szAddress[CAT_MAX_INTERNAL_FULL_EMAIL];
    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrComposeLdapFilter");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    hr = HrGetLookupAddress(
        szAddress,
        CAT_MAX_INTERNAL_FULL_EMAIL,
        &CAType);
    ERROR_CLEANUP_LOG_ADDR(this, "HrGetLookupAddress");

    switch(CAType) {
     case CAT_SMTP:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_SMTP,
             DSPARAMETER_SEARCHFILTER_SMTP,
             szAddress);
         ERROR_CLEANUP_LOG_ADDR(this, "HrComposeLdapFilterForType -- SMTP");
         break;

     case CAT_LEGACYEXDN:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_LEGACYEXDN,
             DSPARAMETER_SEARCHFILTER_LEGACYEXDN,
             szAddress);
         ERROR_CLEANUP_LOG_ADDR(this, "HrComposeLdapFilterForType -- LegDN");
         break;

     case CAT_X400:
         ConvertX400DelimitersIfNeeded(szAddress);
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_X400,
             DSPARAMETER_SEARCHFILTER_X400,
             szAddress);
         ERROR_CLEANUP_LOG_ADDR(this, "HrComposeLdapFilterForType -- X400");
         break;

     case CAT_CUSTOMTYPE:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_FOREIGNADDRESS,
             DSPARAMETER_SEARCHFILTER_FOREIGNADDRESS,
             szAddress);
         ERROR_CLEANUP_LOG_ADDR(this, "HrComposeLdapFilterForType -- foreign");
         break;

     case CAT_X500:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_X500,
             DSPARAMETER_SEARCHFILTER_X500,
             szAddress);

         if(SUCCEEDED(hr)) {
             break;
         } else if((hr != CAT_E_PROPNOTFOUND) && FAILED(hr)) {
             ERROR_LOG_ADDR(this, "HrComposeLdapFilterForType -- X500");
             goto CLEANUP;
         }
         //
         // Special case -- we can't resolve an X500 address
         // directly.  Convert it to a DN and try here.
         //
         // Fall through to DN case
         //
     case CAT_DN:
         hr = HrComposeLdapFilterForType(
             DSPARAMETER_SEARCHATTRIBUTE_DN,
             DSPARAMETER_SEARCHFILTER_DN,
             szAddress);
         if(SUCCEEDED(hr)) {
             break;
         } else if((hr != CAT_E_PROPNOTFOUND) && FAILED(hr)) {
             ERROR_LOG_ADDR(this, "HrComposeLdapFilterForType -- DN");
             goto CLEANUP;
         }

         //
         // Special case -- we can't resolve a DN directly. Try to do
         // it by searching on RDN
         //
         // Convert DN to RDN attribute/value pair
         TCHAR szRDN[CAT_MAX_INTERNAL_FULL_EMAIL];
         TCHAR szRDNAttribute[CAT_MAX_INTERNAL_FULL_EMAIL];
         LPSTR pszRDNAttribute;
         TCHAR szRDNAttributeValue[CAT_MAX_INTERNAL_FULL_EMAIL];

         hr = pICatParams->GetDSParameterA(
             DSPARAMETER_SEARCHATTRIBUTE_RDN,
             &pszRDNAttribute);
         if (SUCCEEDED(hr)) {
             hr = HrConvertDNtoRDN(szAddress, NULL, szRDN);
             ERROR_CLEANUP_LOG_ADDR(this, "HrConvertDNtoRDN -- 0");

         } else if (hr == CAT_E_PROPNOTFOUND) {
             //
             // since RDN attribute was not present in the config, we will obtain
             // it from the DN.
             //
             hr = HrConvertDNtoRDN(szAddress, szRDNAttribute, szRDN);
             ERROR_CLEANUP_LOG_ADDR(this, "HrConvertDNtoRDN -- 1");
             pszRDNAttribute = szRDNAttribute;

         } else {
             ERROR_LOG_ADDR(this, "GetDSParameterA(DSPARAMETER_SEARCHATTRIBUTE_RDN)");
             goto CLEANUP;
         }

         hr = HrFormatAttributeValue(
             szRDN,
             DSPARAMETER_SEARCHFILTER_RDN,
             szRDNAttributeValue);
         ERROR_CLEANUP_LOG_ADDR(this, "HrFormatAttributeValue");

         hr = HrComposeLdapFilterFromPair(
             pszRDNAttribute,
             szRDNAttributeValue);
         ERROR_CLEANUP_LOG_ADDR(this, "HrComposeLdapFilterFromPair");

         //
         // flag this as an RDN search
         //
         hr = PutBool(
             ICATEGORIZERITEM_FISRDNSEARCH,
             TRUE);
         ERROR_CLEANUP_LOG_ADDR(this, "PutBool(ICATEGORIZERITEM_FISRDNSEARCH)");

         //
         // Set distinguishing attribute/value back to the DN since
         // RDN really isn't distinguishing
         //
         LPSTR pszDistinguishingAttributeTemp;
         hr = pICatParams->GetDSParameterA(
             DSPARAMETER_ATTRIBUTE_DEFAULT_DN,
             &pszDistinguishingAttributeTemp);
         ERROR_CLEANUP_LOG_ADDR(this, "pICatParams->GetDSParameterA(DSPARAMETER_ATTRIBUTE_DEFAULT_DN");

         hr = PutStringA(
             ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
             pszDistinguishingAttributeTemp);
         ERROR_CLEANUP_LOG_ADDR(this, "PutStringA(ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE)");
         //
         // And set the distinguishing attribute value to the DN
         //
         hr = PutStringA(
             ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE,
             szAddress);
         ERROR_CLEANUP_LOG_ADDR(this, "PutStringA(ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE)");
         break;
         
     default:
         _ASSERT(0 && "Unknown address type -- not supported for MM3");
    }
    hr = S_OK;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrComposeLdapFilter



//+------------------------------------------------------------
//
// Function: CCatAddr::HrComposeLdapFilterForType
//
// Synopsis: Given an address type and address, format the filter and
//           distinguishing attribute/value strings.  Set the
//           properties on CCatAddr
//
// Arguments:
//   dwSearchAttribute: propID of search attribute in IDSParams
//   dwSearchFilter:    propID of filter attribute in IDSParams
//   pszAddress: the Address
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1999/03/23 16:12:27: Created.
// dlongley 2001/07/31 Modified.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrComposeLdapFilterForType(
    DWORD     dwSearchAttribute,
    DWORD     dwSearchFilter,
    LPTSTR    pszAddress)
{
    HRESULT hr = S_OK;
    LPSTR pszSearchAttribute;
    TCHAR szAttributeValue[CAT_MAX_INTERNAL_FULL_EMAIL];
    ICategorizerParameters *pICatParams;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrComposeLdapFilterForType");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);
    //
    // Use ICategorizerDSParameters to figure out our filter
    // string
    //

    // The attribute we search on will be our distinguishing
    // attribute
    //
    hr = pICatParams->GetDSParameterA(
        dwSearchAttribute,
        &pszSearchAttribute);
    if(FAILED(hr))
    {
        if(hr != CAT_E_PROPNOTFOUND)
        {
            ERROR_LOG_ADDR(this,
                           "pICatParams->GetDSParameterA(dwSearchAttribute)");
        }
        goto CLEANUP;
    }
    //
    // Now set the distinguishing attribute in ICategorizerItem
    //
    hr = PutStringA(
        ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE,
        pszSearchAttribute);
    ERROR_CLEANUP_LOG_ADDR(this, "PutStringA(ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTE)");

    hr = HrFormatAttributeValue(
        pszAddress,
        dwSearchFilter,
        szAttributeValue);
    ERROR_CLEANUP_LOG_ADDR(this, "HrFormatAttributeValue");
    
    //
    // Set the distinguishingAttributeValue in ICategorizerParameters
    //
    hr = PutStringA(
        ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE,
        szAttributeValue);
    ERROR_CLEANUP_LOG_ADDR(this, "PutStringA(ICATEGORIZERITEM_DISTINGUISHINGATTRIBUTEVALUE");

    hr = HrComposeLdapFilterFromPair(
        pszSearchAttribute,
        szAttributeValue);
    ERROR_CLEANUP_LOG_ADDR(this, "HrComposeLdapFilterFromPair");

    hr = S_OK;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrComposeLdapFilterForType


//+------------------------------------------------------------
//
// Function: CCatAddr::HrFormatAttributeValue
//
// Synopsis: Given address and search format string parameter,
//           format the address.
//
// Arguments:
//   pszAddress: the Address
//   dwSearchFilter:    propID of filter attribute in IDSParams
//   pszAttributeValue: the formatted address attribute
//
// Returns:
//  S_OK: Success
//
// History:
// dlongley 2001/08/13 Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrFormatAttributeValue(
    LPTSTR    pszAddress,
    DWORD     dwSearchFilter,
    LPTSTR    pszAttributeValue)
{
    HRESULT hr = S_OK;
    LPSTR pszTemp;
    ICategorizerParameters *pICatParams;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrFormatAttributeValue");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    //
    // Get the search format string
    //
    hr = pICatParams->GetDSParameterA(
        dwSearchFilter,
        &pszTemp);
    ERROR_CLEANUP_LOG_ADDR(this, "GetDSParameterA(dwSearchFilter)");
    //
    // Create the attribute value string by
    // sprintf'ing the search format string
    //
    _snprintf(pszAttributeValue,
              CAT_MAX_INTERNAL_FULL_EMAIL,
              pszTemp, //ICategorizerDSParameters search filter
              pszAddress);

    hr = S_OK;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrFormatAttributeValue


//+------------------------------------------------------------
//
// Function: CCatAddr::HrComposeLdapFilterFromPair
//
// Synopsis: Given attribute name/value strings, escape the
//           strings and set the properties on CCatAddr.
//
// Arguments:
//   pszSearchAttribute: the name of the search attribute
//   pszAttributeValue:  the value of the search attribute
//
// Returns:
//  S_OK: Success
//
// History:
// dlongley 2001/08/13 Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrComposeLdapFilterFromPair(
    LPTSTR    pszSearchAttribute,
    LPTSTR    pszAttributeValue)
{
    HRESULT hr = S_OK;
    LPSTR pszDest, pszSrc;
    CHAR  szEscapedSearchAttribute[CAT_MAX_INTERNAL_FULL_EMAIL];
    CHAR  szEscapedAttributeValue[CAT_MAX_INTERNAL_FULL_EMAIL];
    CHAR  szFilter[MAX_SEARCH_FILTER_SIZE];
    ICategorizerParameters *pICatParams;

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrComposeLdapFilterFromPair");

    pICatParams = GetICatParams();
    _ASSERT(pICatParams);

    //
    // Escape characters required for LDAP filter strings
    //
    hr = HrEscapeFilterString(
        pszSearchAttribute,
        sizeof(szEscapedSearchAttribute),
        szEscapedSearchAttribute);
    ERROR_CLEANUP_LOG_ADDR(this, "HrEscapeFilterString");
    //
    //$$BUGBUG: Why the devil are we calling this twice???
    //
    hr = HrEscapeFilterString(
        pszAttributeValue,
        sizeof(szEscapedAttributeValue),
        szEscapedAttributeValue);
    ERROR_CLEANUP_LOG_ADDR(this, "HrEscapeFilterString");
    //
    // Create the actual filter from the distinguishing attribute
    // and distinguishing value
    //
    pszDest = szFilter;
    *pszDest++ = '(';
    pszSrc = szEscapedSearchAttribute;

    while(*pszSrc) {
        *pszDest++ = *pszSrc++;
    }

    *pszDest++ = '=';

    pszSrc = szEscapedAttributeValue;
    while(*pszSrc) {
        *pszDest++ = *pszSrc++;
    }

    *pszDest++ = ')';
    *pszDest = '\0';

    DebugTrace((LPARAM)this, "Formatted filter: \"%s\"", szFilter);

    // Set this filter in ICategorizerItem
    hr = PutStringA(
        ICATEGORIZERITEM_LDAPQUERYSTRING,
        szFilter);
    ERROR_CLEANUP_LOG_ADDR(this, "PutStringA(ICATEGORIZERITEM_LDAPQUERYSTRING)");

    hr = S_OK;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrComposeLdapFilterFromPair



//+------------------------------------------------------------
//
// Function: CCatAddr::HrConvertDNtoRDN
//
// Synopsis: Convert a string of the format "cn=blah,cn=blah,..." to
//           "cn" and "blah".  No bounds checking is done on pszRDN or
//           pszRDNAttribute (if it is at least as big as
//           strlen(pszDN)+1, there will be no problem)
//
// Arguments:
//  pszDN: Pointer to buffer containig DN string
//  pszRDN: Pointer to buffer to receive RDN string
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: pszDN is invalid
//
// History:
// jstamerj 1998/09/29 14:48:39: Created.
// dlongley 2001/08/13 Modified.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrConvertDNtoRDN(
    LPTSTR    pszDN,
    LPTSTR    pszRDNAttribute,
    LPTSTR    pszRDN)
{
    BOOL fInsideQuote = FALSE;
    LPSTR pszSrc, pszDest;

    _ASSERT(pszDN && pszRDN);
    //
    // Copy from pszDN to pszRDN removing quoted characters (per RFC
    // 1779) until we hit the first unquoted , in pszDN 
    //
    // Copy/skip characters up to first '='
    //
    pszSrc = pszDN;
    pszDest = pszRDNAttribute;

    while((*pszSrc != '\0') && (*pszSrc != '=')) {     // Stop at an '='
        if (pszDest) *pszDest++ = *pszSrc;
        pszSrc++;
    }

    if(*pszSrc == '\0')
        return E_INVALIDARG; // No '=' found

    _ASSERT(*pszSrc == '=');

    pszSrc++;                               // skip '='
    if (pszDest) *pszDest = '\0';           // terminate the attribute name
    
    pszDest = pszRDN;

    while((*pszSrc != '\0') &&                  // Stop at a null terminator
          (fInsideQuote || (*pszSrc != ','))) { // Stop at the end of
                                                // the RDN part of the DN

        if(*pszSrc == '\\') {
            //
            // Backslash pair detected -- take the next character (it
            // should be \, , \+, \=, \", \r, \<, \>, \#, or \; )
            //
            pszSrc++;
            if(*pszSrc == '\0')
                return E_INVALIDARG;
            *pszDest++ = *pszSrc++;

        } else if(*pszSrc == '"') {

            fInsideQuote = !fInsideQuote;
            pszSrc++;

        } else {
            //
            // Normal case
            //
            *pszDest++ = *pszSrc++;
        }
    }

    //
    // Termiante the RDN
    //
    *pszDest = '\0';

    //
    // If we think we did not find a matching \", this is an invalid
    // DN
    //
    if(fInsideQuote)
        return E_INVALIDARG;

    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CCatAddr::HrEscapeFilterString
//
// Synopsis: Copy Src to Dest, escaping LDAP characters that need to
//           be escaped as we go.
//
// Arguments:
//  pszSrcString: Source string
//  dwcchDest: Size of dest buffer
//  pszDestBuffer: Dest buffer.  Note: this can not be the same as pszSrc
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//
// History:
// jstamerj 2000/04/11 17:49:19: Created.
//
//-------------------------------------------------------------
HRESULT CCatAddr::HrEscapeFilterString(
    LPSTR pszSrcString,
    DWORD dwcchDest,
    LPSTR pszDestBuffer)
{
    HRESULT hr = S_OK;
    DWORD dwcchRemain = dwcchDest;
    LPSTR pszSrc = pszSrcString;
    LPSTR pszDest = pszDestBuffer;
    CHAR szHexDigits[17] = "0123456789ABCDEF"; // 16 digits + 1
                                               // for NULL termintor

    CatFunctEnterEx((LPARAM)this, "CCatAddr::HrEscapeFilterString");

    _ASSERT(pszSrcString);
    _ASSERT(pszDestBuffer);
    _ASSERT(pszSrcString != pszDestBuffer);

    while(*pszSrc) {
        
        switch(*pszSrc) {
            //
            // These are the characters that RFC 2254 says we must
            // escape
            //
         case '(':
         case ')':
         case '*':
         case '\\':
             //
             // We must escape this because WLDAP32 strips off
             // leading spaces
             //
         case ' ':

             if(dwcchRemain < 3) {
                 hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                 goto CLEANUP;
             }
             dwcchRemain -= 3;
             *pszDest++ = '\\';
             // High 4 bits
             *pszDest++ = szHexDigits[((*pszSrc) >> 4)];
             // Low 4 bits
             *pszDest++ = szHexDigits[((*pszSrc) & 0xF)];
             break;

         default:
             if(dwcchRemain < 1) {
                 hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                 goto CLEANUP;
             }
             dwcchRemain--;
             *pszDest++ = *pszSrc;
             break;
        }
        pszSrc++;
    }
    //
    // Add NULL termintor
    //
    if(dwcchRemain < 1) {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto CLEANUP;
    }
    dwcchRemain--;
    *pszDest = '\0';

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CCatAddr::HrEscapeFilterString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\ntpch.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: ntpch.cpp
//
//  Description:  NT PCH File - Includes the real .cpp file.  This lets us
//                 generate a seperate obj file to satisfy the NT build env.
//
//
//-----------------------------------------------------------------------------

#include <precomp.h>

#include "precomp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\guids.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 2000, Microsoft Corporation
//
// File: guids.cpp
//
// Contents: Source file for defining GUIDs
//
// Classes: None
//
// Functions: None
//
// History:
// jstamerj 2001/05/18 11:10:26: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

#include "initguid.h"
#include <phatqcat.h>

DEFINE_GUID(CLSID_SmtpCat,
            0xb23c35b7, 0x9219, 0x11d2,
            0x9e, 0x17, 0x0, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatitem.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitem.cpp
//
// Contents: Implementation of ICategorizerItemIMP
//
// Classes: CCategorizerItemIMP
//
// Functions:
//
// History:
// jstamerj 980515 12:42:59: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatitem.h"


//+------------------------------------------------------------
//
// Function:  CICategorizerItemIMP::CICategorizerItemIMP
//
// Synopsis: Set initial values of member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 18:26:07: Created.
//
//-------------------------------------------------------------
CICategorizerItemIMP::CICategorizerItemIMP() :

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4355)

    CICategorizerPropertiesIMP((ICategorizerItem *)this)

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4355)
#endif

{
    m_dwSignature = CICATEGORIZERITEMIMP_SIGNATURE;
}


//+------------------------------------------------------------
//
// Function: CICategorizerItemIMP::~CICategorizerItemIMP
//
// Synopsis: Release all of our data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 20:15:14: Created.
//
//-------------------------------------------------------------
CICategorizerItemIMP::~CICategorizerItemIMP()
{
    _ASSERT(m_dwSignature == CICATEGORIZERITEMIMP_SIGNATURE);
    m_dwSignature = CICATEGORIZERITEMIMP_SIGNATURE_FREE;
}


//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerListResolve
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerItemIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerItem) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerProperties) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatlistresolve.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatlistresolve.cpp
//
// Contents: Implementation of CICategorizerListResolveIMP
//
// Classes: CICategorizerListResolveIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/25 17:41:17: Created.
//
//-------------------------------------------------------------
#include "precomp.h"

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerListResolve
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerListResolve) {
        *ppv = (LPVOID) ((ICategorizerListResolve *) this);
    } else if (iid == IID_ICategorizerProperties) {
        *ppv = (LPVOID) ((ICategorizerProperties *) this);
    } else if (iid == IID_ICategorizerMailMsgs) {
        *ppv = (LPVOID) ((ICategorizerMailMsgs *) &m_CICategorizerMailMsgs);
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::AllocICategorizerItem
//
// Synopsis: Creates a CCatAddr object and an ICategorizerItem
//           property bag
//
// Arguments:
//  eSourceType: Specifies source type of Sender, Recipient, or Verify
//  ppICatItem:  ICategorizerItem created
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  E_INVALIDARG
//
// History:
// jstamerj 1998/06/25 17:59:38: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::AllocICategorizerItem(
    eSourceType SourceType,
    ICategorizerItem **ppICatItem)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::AllocICategorizerItem");

    _ASSERT(ppICatItem);

    CCatAddr *pCCatAddr;
    switch(SourceType) {
     case SOURCE_RECIPIENT:
         pCCatAddr = new (GetNumCatItemProps()) CCatRecip(this);
         break;

     case SOURCE_SENDER:
         pCCatAddr = new (GetNumCatItemProps()) CCatSender(this);
         break;

     default:
         return E_INVALIDARG;
    }

    if(pCCatAddr == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CCatRecip / CCatSender");
        goto CLEANUP;
    }
    //
    // The constructor for CCatRecip/Sender starts with a refcount of 1
    //

    //
    // Set the CCatAddr property so that we can get back the
    // CCatAddr from an ICategorizerItem later.
    //
    _VERIFY(SUCCEEDED(pCCatAddr->PutPVoid(
        m_pCCat->GetICatItemCCatAddrPropId(),
        (PVOID)pCCatAddr)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutDWORD(
        ICATEGORIZERITEM_SOURCETYPE,
        SourceType)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutICategorizerListResolve(
        ICATEGORIZERITEM_ICATEGORIZERLISTRESOLVE,
        this)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutICategorizerMailMsgs(
        ICATEGORIZERITEM_ICATEGORIZERMAILMSGS,
        &m_CICategorizerMailMsgs)));

    *ppICatItem = pCCatAddr;

 CLEANUP:
    return hr;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::ResolveICategorizerItem
//
// Synopsis: Accepts an ICategorizerItem for resolving
//
// Arguments:
//  pICatItem: Item to resolve
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/25 18:53:22: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::ResolveICategorizerItem(
    ICategorizerItem *pICatItem)
{
    HRESULT hr;
    CCatAddr *pCCatAddr;

    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::ResolveICategorizerItem");
    if(pICatItem == NULL)
        return E_INVALIDARG;

    hr = GetCCatAddrFromICategorizerItem(
        pICatItem,
        &pCCatAddr);

    if(FAILED(hr))
    {
        ERROR_LOG("GetCCatAddrFromICategorizerItem");
        return hr;
    }
    //
    // Insert the CCatAddr into the pending resolve list
    //
    m_CSinkInsertionRequest.InsertItem(pCCatAddr);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerListResolve::SetListResolveStatus
//
// Synopsis: Sets the list resolve status -- the status of
//           categorization.  If hrStatus is S_OK, the resolve status
//           will be reset (to S_OK).  Otherwise if hrStatus is less
//           severe than the current status, it will be ignored.
//
// Arguments:
//  hrStatus: status to set
//
// Returns:
//  S_OK: Success, new status set
//  S_FALSE: Success, but we already have a more or equally severe status
//
// History:
// jstamerj 1998/06/25 19:06:59: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::SetListResolveStatus(
    HRESULT hrStatus)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::SetListResolveStatus");
    //
    // CAT_W_SOME_UNDELIVERABLE_MSGS should no longer be the list
    // resolve error
    //
    _ASSERT(hrStatus != CAT_W_SOME_UNDELIVERABLE_MSGS);

    //
    // Is hrStatus more severe than m_hrListResolveStatus ?
    //
    if( (hrStatus == S_OK) ||
        ((unsigned long)(hrStatus & 0xC0000000) >
         (unsigned long)(m_hrListResolveStatus & 0xC0000000))) {
        m_hrListResolveStatus = hrStatus;

        DebugTrace((LPARAM)this, "Setting new list resolve error %08lx",
                   m_hrListResolveStatus);

        return S_OK;
    }
    return S_FALSE;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolve::GetListResolveStatus
//
// Synopsis: Retrieve the current list resolve status
//
// Arguments:
//  phrStatus: ptr to hresult to set to the current status
//
// Returns:
//  S_OK: Success, new status set
//  E_INVALIDARG
//
// History:
// jstamerj 1998/12/17 22:22:24: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerListResolveIMP::GetListResolveStatus(
    HRESULT *phrStatus)
{
    HRESULT hr = S_OK;
    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::GetListResolveStatus");

    if(phrStatus == NULL) {

        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    *phrStatus = m_hrListResolveStatus;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolve::Initialize
//
// Synopsis: Initializes member data
//
// Arguments:
//  pIMsg: Origianl IMsg for this resolution
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/25 19:28:30: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::Initialize(
    IUnknown *pIMsg)
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::Initialize");

    hr = m_CICategorizerMailMsgs.Initialize(pIMsg);
    ERROR_CLEANUP_LOG("m_CICategorizerMailMsgs.Initailize");

 CLEANUP:
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerListResolve::CompleteMessageCategorization
//
// Synopsis: Master completion routine of an IMsg Categorization
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success (any errors passed to completion function)
//
// History:
// jstamerj 1998/06/26 10:46:17: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::CompleteMessageCategorization()
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolve::CompelteMessageCategorization");
    HRESULT hr = m_hrListResolveStatus;
    HRESULT hrEvent;

    IUnknown **rgpIMsg = NULL;
    DWORD cIMsgs = 1;
    ISMTPServer *pIServer;

    pIServer = GetISMTPServer();

    //
    // Remove ourselves from the pending listresolve list
    //
    m_pCCat->RemovePendingListResolve(this);

    DebugTrace(0, "CompleteMessageCategorization called with hrListResolveError %08lx", m_hrListResolveStatus);

    //
    // Now that we have our context, we are done with the store's
    // context
    //
    m_pCCat->GetEmailIDStore()->FreeResolveListContext(&m_rlc); //WOW!

    cIMsgs = m_CICategorizerMailMsgs.GetNumIMsgs();

    // Prepare for completion call
    if(SUCCEEDED(hr) && (cIMsgs > 1)) {
        //
        // Allocate array space if there is more than one message
        //
        rgpIMsg = new IUnknown *[cIMsgs+1];
        if(rgpIMsg == NULL) {
            ErrorTrace(0, "Out of memory allocating array of pointers to IMsgs for bifurcation callback");
            hr = E_OUTOFMEMORY;
            ERROR_LOG("new IUnknown *");
        }
    }
    if(SUCCEEDED(hr)) {
        //
        // WriteList/Commit our resolved addresses
        //
        hr = m_CICategorizerMailMsgs.HrPrepareForCompletion();
        if(FAILED(hr))
        {
            ERROR_LOG("m_CICategorizermailMsgs.HrPrepareForCompletion");
        }
    }
    //
    // Set list resolve status if something failed above
    //
    if(FAILED(hr)) {
        _VERIFY(SUCCEEDED(SetListResolveStatus(hr)));
    }
    //
    // Delete bifurcatd messages when the list resolve is failing
    //
    if(FAILED(m_hrListResolveStatus))
        m_CICategorizerMailMsgs.DeleteBifurcatedMessages();

    if(pIServer) {
        //
        // Now that we've determined the status for this categorization,
        // trigger OnCategorizeEnd
        //
        EVENTPARAMS_CATEND EventParams;
        EventParams.pICatMailMsgs = &m_CICategorizerMailMsgs;
        EventParams.hrStatus = m_hrListResolveStatus;
        hrEvent = GetISMTPServer()->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_END_EVENT,
            &EventParams);
        if(FAILED(hrEvent) && (hrEvent != E_NOTIMPL)) {
            ERROR_LOG("TriggerServerEvent");
            _VERIFY(SUCCEEDED(SetListResolveStatus(hrEvent)));
            m_CICategorizerMailMsgs.DeleteBifurcatedMessages();
        }
    }
    if(FAILED(m_hrListResolveStatus)) {
        ErrorTrace(0, "Categorization for this IMsg failed with hr %08lx", 
                   m_hrListResolveStatus);
        // If we failed, revert all changes
        _VERIFY(SUCCEEDED(m_CICategorizerMailMsgs.RevertAll()));

        // Call completion routine with original IMsg and error
        CallCompletion( 
            m_hrListResolveStatus,
            m_pCompletionContext,
            m_CICategorizerMailMsgs.GetDefaultIUnknown(),
            NULL);
    } else {
        // Noraml case we will succeed!
        if(rgpIMsg) {
            _VERIFY( SUCCEEDED(
                m_CICategorizerMailMsgs.GetAllIUnknowns(rgpIMsg, cIMsgs+1)));

            // Use the original list resolve hr (might be cat_w_something)
            CallCompletion( 
                m_hrListResolveStatus,
                m_pCompletionContext,
                NULL,
                rgpIMsg);

        } else {
            CallCompletion( 
                m_hrListResolveStatus,
                m_pCompletionContext,
                m_CICategorizerMailMsgs.GetDefaultIUnknown(),
                NULL);
        }
    }

    //
    // Common cleanup code
    // Release reference to ourself added in StartMessageCategorization
    //
    Release();

    if(rgpIMsg)
        delete rgpIMsg;
    
    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICateogirzerListResolveIMP::StartMessageCategorization
//
// Synopsis: Kicks off first level categorization
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, async resolution in progress
//  S_FALSE: Nothing needed to be resolved
//  error: will not call your completion routine, could not kick off
//  async categorize
//
// History:
// jstamerj 1998/06/26 11:05:21: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::StartMessageCategorization()
{
    IMailMsgProperties    *pIMailMsgProperties = NULL;
    IMailMsgRecipients    *pIMailMsgRecipients = NULL;
    IMailMsgRecipientsAdd *pICatRecipList  = NULL;
    HRESULT hr;
    ISMTPServer *pIServer;
    BOOL fStoreListResolveContext = FALSE;

    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::StartCategorization");

    pIServer = GetISMTPServer();
    //
    // Retrieve the interfaces we need -- these routines do NOT Addref
    // the interfaces for the caller
    //
    pIMailMsgProperties = m_CICategorizerMailMsgs.GetDefaultIMailMsgProperties();
    _ASSERT(pIMailMsgProperties);

    pIMailMsgRecipients = m_CICategorizerMailMsgs.GetDefaultIMailMsgRecipients();
    _ASSERT(pIMailMsgRecipients);

    pICatRecipList = m_CICategorizerMailMsgs.GetDefaultIMailMsgRecipientsAdd();
    _ASSERT(pICatRecipList);

    //
    // Start out with the message status set to S_OK
    //
    hr = SetMailMsgCatStatus(pIMailMsgProperties, S_OK);
    ERROR_CLEANUP_LOG("SetMailMsgCatStatus");

    //
    // Increment pending lookups here so that we can't possibly
    // finish the list resolve until we are finished starting the list
    // resolve
    //
    IncPendingLookups();

    // Let the store initialize it's resolve context so that it knows
    // how many address to expect for the first search.
    hr = m_pCCat->GetEmailIDStore()->InitializeResolveListContext(
        (LPVOID)this,
        &m_rlc);
    ERROR_CLEANUP_LOG("InitializeResolveListContext");

    fStoreListResolveContext = TRUE;

    if(pIServer) {
        //
        // Trigger OnCategorizerBegin event
        //
        EVENTPARAMS_CATBEGIN EventParams;
        EventParams.pICatMailMsgs = &m_CICategorizerMailMsgs;
        hr = GetISMTPServer()->TriggerServerEvent(
            SMTP_MAILTRANSPORT_CATEGORIZE_BEGIN_EVENT,
            &EventParams);
        if(FAILED(hr) && (hr != E_NOTIMPL)) {
            //
            // Ignore E_NOTIMPL errors as this just indicates server
            // events are disabled.
            //
            ERROR_LOG("TriggerServerEvent");
            goto CLEANUP;
        }
    }
    //
    // TriggerServerEvent could return S_FALSE.  However, we are okay
    // to go for async resolution, so we will return S_OK
    //
    hr = S_OK;

    //
    // Since everything has suceeded thus far, we are go for async
    // resolution
    // AddRef here, release in completion
    //
    AddRef();

    //
    // Great, we're doing an async categorization.  Add the list
    // resolve to the list of pending list resolves
    //
    m_pCCat->AddPendingListResolve(
        this);

    //
    // Call CreateBeginItemResolves
    //
    _VERIFY(SUCCEEDED(BeginItemResolves(
        pIMailMsgProperties,
        pIMailMsgRecipients,
        pICatRecipList)));

    //
    // Decrement the pending count incremented above (which calls
    // completion if necessary)
    //
    DecrPendingLookups();

 CLEANUP:
    if(FAILED(hr)) {

        if(fStoreListResolveContext) {
            //
            // Need to release the store list resolve context that we
            // initialized
            // 
            m_pCCat->GetEmailIDStore()->FreeResolveListContext(&m_rlc);
        }
    }
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CCategorizer::BeginItemResolves
//
// Synopsis: kick off resolves
//
// Arguments:
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/25 20:24:17: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::BeginItemResolves(
    IMailMsgProperties *pIMailMsgProperties,
    IMailMsgRecipients *pOrigRecipList,
    IMailMsgRecipientsAdd *pCatRecipList)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this,
                      "CICatListResolveIMP::BeginItemResolves");

    _ASSERT(pIMailMsgProperties);
    _ASSERT(pOrigRecipList);
    _ASSERT(pCatRecipList);

    m_CTopLevelInsertionRequest.BeginItemResolves(
        pIMailMsgProperties,
        pOrigRecipList,
        pCatRecipList);

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::SetMailMsgCatStatus
//
// Synopsis: Set the categorization status on the mailmsg
//
// Arguments:
//  pIMailMsgProps: IMailMsgProperties interface
//  hrStatus: The status to set
//
// Returns:
//  The return code from mailmsgprop's PutDWord
//
// History:
// jstamerj 1998/07/29 12:22:30: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::SetMailMsgCatStatus(
    IMailMsgProperties *pIMailMsgProps, 
    HRESULT hrStatus)
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this,
                      "CICategorizerListResolve::SetMailMsgCatStatus");
    DebugTrace((LPARAM)this, "Status is %08lx", hrStatus);

    _ASSERT(pIMailMsgProps);

    hr = pIMailMsgProps->PutDWORD(
        IMMPID_MP_HR_CAT_STATUS,
        hrStatus);
    if(FAILED(hr))
    {
        ERROR_LOG("pIMailMsgProperties->PutDWORD(IMMPID_MP_HR_CAT_STATUS)");
    }
    
    DebugTrace((LPARAM)this, "PutDWORD returned hr %08lx", hr);

    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::SetMailMsgCatStatus
//
// Synopsis: Same as the other SetMailMsgCatStatus but QI for
//           IMailMsgProperties first
//
// Arguments:
//  pIMsg: an IUnknown interface
//  hrStatus: Status to set
//
// Returns:
//  S_OK: Success
//  or error from QI
//  or error from PutDWORD
//
// History:
// jstamerj 1998/07/29 12:27:21: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerListResolveIMP::SetMailMsgCatStatus(
    IUnknown *pIMsg,
    HRESULT hrStatus)
{
    HRESULT hr;
    IMailMsgProperties *pIMailMsgProperties = NULL;

    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::SetMailMsgCatStatus");
    _ASSERT(pIMsg);

    hr = pIMsg->QueryInterface(
        IID_IMailMsgProperties,
        (PVOID *) &pIMailMsgProperties);
    ERROR_CLEANUP_LOG("pIMsg->QueryInterface(IID_IMailMsgProperties");

    hr = SetMailMsgCatStatus(
        pIMailMsgProperties,
        hrStatus);
    ERROR_CLEANUP_LOG("SetMailMsgCatStatus");

 CLEANUP:
    if(pIMailMsgProperties)
        pIMailMsgProperties->Release();
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::CICategorizerDLListResolveIMP
//
// Synopsis: Construct the list resolve object for only resolving DLs
//
// Arguments:
//  pCCat: the CCategorizer object for this virtual server
//  pfnCatCompeltion: the completion routine to call when finished
//  pContext: the context to pass pfnCatCompletion
//  pfMatch: ptr to bool to set to TRUE or FALSE on address match
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/07 11:16:50: Created.
//
//-------------------------------------------------------------
CICategorizerDLListResolveIMP::CICategorizerDLListResolveIMP(
    CCategorizer *pCCat,
    PFNCAT_COMPLETION pfnCatCompletion,
    PVOID pContext) :
    CICategorizerListResolveIMP(
        pCCat,
        pfnCatCompletion,
        pContext)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerDLListResolveIMP::CICategorizerDLListResolveIMP");

    m_fExpandAll = FALSE;
    m_CAType = CAT_UNKNOWNTYPE;
    m_pszAddress = NULL;
    m_pwszUTF8DN = NULL;
    m_pfMatch = NULL;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::Initialize
//
// Synopsis: Initialize error prone things with this object
//
// Arguments:
//  fExpandAll: expand the entire DL?
//  pfMatch: ptr to Bool to set when a match is detected
//  CAType: (optinal) the address type to match
//  pszAddress: (optinal) the address to match
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/12/07 11:46:17: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerDLListResolveIMP::Initialize(
    IUnknown *pMsg,
    BOOL fExpandAll,
    PBOOL pfMatch,
    CAT_ADDRESS_TYPE CAType,
    LPSTR pszAddress)
{
    HRESULT hr = S_OK;
    IMailMsgProperties *pIProps = NULL;

    CatFunctEnterEx((LPARAM)this, "CICategoriezrDLListResolveIMP::Initialize");

    m_fExpandAll = fExpandAll;
    m_CAType = CAType;

    if(pfMatch) 
    {
        *pfMatch = FALSE;
        m_pfMatch = pfMatch;
    }
        
    if(pszAddress) 
    {
        if((CAType == CAT_X500) ||
           (CAType == CAT_DN))
        {
            int cch = 0;
            //
            // Convert the UTF8 DN to unicode
            //
            cch = MultiByteToWideChar(
                CP_UTF8,
                0,          // Flags
                pszAddress,
                -1,
                NULL,
                0);
            if(cch == 0)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                _ASSERT(FAILED(hr));
                ERROR_LOG("MultiByteToWideChar - 0");
                goto CLEANUP;
            }
            m_pwszUTF8DN = new WCHAR[cch];
            if(m_pwszUTF8DN == NULL)
            {
                hr = E_OUTOFMEMORY;
                ERROR_LOG("new WCHAR[]");
                goto CLEANUP;
            }
            cch = MultiByteToWideChar(
                CP_UTF8,
                0,          // Flags
                pszAddress,
                -1,
                m_pwszUTF8DN,
                cch);
            if(cch == 0)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                _ASSERT(FAILED(hr));
                ERROR_LOG("MultiByteToWideChar - 1");
                delete [] m_pwszUTF8DN;
                m_pwszUTF8DN = NULL;
                goto CLEANUP;
            }            
        }
        else
        {
            m_pszAddress = TrStrdupA(pszAddress);
            if(m_pszAddress == NULL) 
            {
                hr = E_OUTOFMEMORY;
                ERROR_LOG("TrStrdupA");
                goto CLEANUP;
            }
        }
    }

    hr = CICategorizerListResolveIMP::Initialize(
        pMsg);
    ERROR_CLEANUP_LOG("CICategorizerListResolveIMP::Initialize");
        
 CLEANUP:
    if(pIProps)
        pIProps->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}




//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::~CICategorizerDLListResolveIMP
//
// Synopsis: destroy this object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/12/07 11:44:05: Created.
//
//-------------------------------------------------------------
CICategorizerDLListResolveIMP::~CICategorizerDLListResolveIMP()
{
    if(m_pszAddress)
        TrFree(m_pszAddress);
    if(m_pwszUTF8DN)
        delete [] m_pwszUTF8DN;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::AllocICategorizerItem
//
// Synopsis: override the
// CICategorizerListResolveIMP::AllocICategorizerItem -- alloc
// CCatDLRecip's instead of CCatRecips
//
// Arguments:
//  eSourceType: Specifies source type of Sender, Recipient, or Verify
//  ppICatItem:  ICategorizerItem created
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  E_INVALIDARG
//
// History:
// jstamerj 1998/12/07 13:27:56: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerDLListResolveIMP::AllocICategorizerItem(
    eSourceType SourceType,
    ICategorizerItem **ppICatItem)
{
    HRESULT hr = S_OK;
    CCatAddr *pCCatAddr;

    CatFunctEnterEx((LPARAM)this, "CICategorizerDLListResolveIMP::AllocICategorizerItem");
    _ASSERT(ppICatItem);

    if(SourceType != SOURCE_RECIPIENT)
    {
        hr = CICategorizerListResolveIMP::AllocICategorizerItem(
            SourceType,
            ppICatItem);
        if(FAILED(hr))
        {
            ERROR_LOG("CICategorizerListResolveIMP::AllocICategorizerItem");;
        }
        goto CLEANUP;
    }

    pCCatAddr = new (GetNumCatItemProps()) CCatDLRecip(this);
    if(pCCatAddr == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CCatDLRecip");
        goto CLEANUP;
    }
    //
    // The constructor for CCatRecip/Sender starts with a refcount of 1
    //

    //
    // Set the CCatAddr property so that we can get back the
    // CCatAddr from an ICategorizerItem later.
    //
    _VERIFY(SUCCEEDED(pCCatAddr->PutPVoid(
        GetCCategorizer()->GetICatItemCCatAddrPropId(),
        (PVOID)pCCatAddr)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutDWORD(
        ICATEGORIZERITEM_SOURCETYPE,
        SourceType)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutICategorizerListResolve(
        ICATEGORIZERITEM_ICATEGORIZERLISTRESOLVE,
        this)));
    _VERIFY(SUCCEEDED(pCCatAddr->PutICategorizerMailMsgs(
        ICATEGORIZERITEM_ICATEGORIZERMAILMSGS,
        GetCICategorizerMailMsgs())));

    *ppICatItem = pCCatAddr;

 CLEANUP:
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::HrContinueResolve
//
// Synopsis: Answer the question "should the resolve continue?"
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success, continue the resolve
//  S_FALSE: Success, stop the resolve
//
// History:
// jstamerj 1998/12/07 13:46:50: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerDLListResolveIMP::HrContinueResolve()
{
    HRESULT hr;

    CatFunctEnterEx((LPARAM)this,
                      "CICategorizerDLListResolveIMP::HrContinueResolve");

    //
    // If we're not supposed to expand everything AND we've already
    // found a match, stop resolving
    //
    if((m_fExpandAll == FALSE) &&
       (m_pfMatch) && (*m_pfMatch == TRUE))
        hr = S_FALSE;
    else
        hr = S_OK;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerDLListResolveIMP::HrNotifyAddress
//
// Synopsis: We're being notified about a resolved user's addresses.
//           Check against what we're looking for if we care.
//
// Arguments:
//  dwNumAddresses: size of the address array
//  rgCAType: type array
//  rgpszAddress: address string ptr array
//
// Returns:
//  S_OK: Success, continue resolving
//  S_FALSE: Thanks for the info.  You can stop resolving now.
//
// History:
// jstamerj 1998/12/07 13:50:04: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerDLListResolveIMP::HrNotifyAddress(
    DWORD               dwNumAddresses,
    CAT_ADDRESS_TYPE    *rgCAType,
    LPSTR               *rgpszAddress)
{
    HRESULT hr = S_OK;
    
    CatFunctEnterEx((LPARAM)this,
                      "CICategorizerDLListResolveIMP::HrNotifyAddress");

    //
    // Do we care what matches?
    //
    if((m_pfMatch) && (m_pszAddress || m_pwszUTF8DN)) 
    {
        //
        // Have we not yet found a match?
        //
        if(*m_pfMatch == FALSE) 
        {
            //
            // Is this a match?
            //
            for(DWORD dwCount = 0, hr = S_OK; 
                (dwCount < dwNumAddresses) && (hr == S_OK);
                dwCount++) 
            {
                if(rgCAType[dwCount] == m_CAType)
                {
                    if((m_CAType == CAT_X500) ||
                       (m_CAType == CAT_DN))
                    {
                        hr = wcsutf8cmpi(
                            m_pwszUTF8DN,
                            rgpszAddress[dwCount]);
                        if(hr == S_OK)
                        {
                            *m_pfMatch = TRUE;
                        }
                        else if(FAILED(hr))
                        {
                            ERROR_LOG("wcsutf8cmpi");
                            goto CLEANUP;
                        }
                    }
                    else
                    {
                        if(lstrcmpi(m_pszAddress, rgpszAddress[dwCount]) == 0)
                        {
                            //
                            // Match
                            //
                            *m_pfMatch = TRUE;
                        }
                    }
                }
            }
        }
    }
    hr = HrContinueResolve();
    if(FAILED(hr))
    {
        ERROR_LOG("HrContinueResolve");;
    }
 CLEANUP:
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::SetSenderResolved
//
// Synopsis: Sets the sender resolved bit...when setting to TRUE, call
//           recip completions of all the recipients whose queries completed
//           from LDAP earlier
//
// Arguments:
//  fResolved: Wether to set the sender as resolved or not
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/17 15:37:26: Created.
//
//-------------------------------------------------------------
VOID CICategorizerListResolveIMP::SetSenderResolved(
    BOOL fResolved)
{
    BOOL fFirstSender = FALSE;
    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::SetSenderResolved");

    AcquireSpinLock(&m_spinlock);
    //
    // If we are change m_fSenderResolved from FALSE to TRUE, then
    // this is the first sender to be resolved.
    //
    fFirstSender =  ((!m_fSenderResolved) && fResolved);
    m_fSenderResolved = fResolved;
    ReleaseSpinLock(&m_spinlock);
    //
    // Traverse the delayed recip list after the first sender has
    // resolved.  Do not traverse it for later senders.
    // Due to sinks completing queries synchronously, it is possible
    // for pRecip->RecipLookupCompletion() to eventually call back
    // into SetSenderResolved.  For example, RecipLookupCompletion of
    // a DL with report to owner may bifurcate a message, alloc
    // CCatSender corresponding to that DL's owner, resolve the owner
    // synchronously, and call SetSendreResolved.
    // We will do nothing here unless we are processing the first
    // sender to resolve.
    //
    if(fFirstSender && (!IsListEmpty(&m_listhead_recipients))) {
        //
        // Resolve all recip objects that were waiting for the
        // sender resolve to finish
        //
        PLIST_ENTRY ple;
        for(ple = m_listhead_recipients.Flink;
            ple != &m_listhead_recipients;
            ple = m_listhead_recipients.Flink) {
            
            CCatRecip *pRecip;
            pRecip = CONTAINING_RECORD(ple, CCatRecip, m_le);

            pRecip->RecipLookupCompletion();
            RemoveEntryList(ple);
            pRecip->Release();
        }
    }

    CatFunctLeaveEx((LPARAM)this);
} // CICategorizerListResolveIMP::SetSenderResolved


//+------------------------------------------------------------
//
// Function: CICategorizerListResolveIMP::ResolveRecipientAfterSender
//
// Synopsis: Calls pRecip->RecipLookupCompletion after the sender
//           lookup completion is finished.  One of two things can
//           happen:
//           1) RecipLookupCompletion is called immediately if the
//           sender lookup is finished or if we're not looking up the
//           sender
//           2) This recip is added to a queue and called later when
//           after the sender lookup is finished
//
// Arguments:
//  pRecip: the recip object
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/18 09:58:56: Created.
//
//-------------------------------------------------------------
VOID CICategorizerListResolveIMP::ResolveRecipientAfterSender(
    CCatRecip *pRecip)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerListResolveIMP::ResolveRecipientAfterSender");

    AcquireSpinLock(&m_spinlock);
    if(IsSenderResolveFinished()) {
        ReleaseSpinLock(&m_spinlock);
        //
        // Sender has been resolved, call recip lookup completion
        //
        pRecip->RecipLookupCompletion();

    } else {
        //
        // Sender has not been resolved, queue up in a list until
        // the sender resolve is finished 
        //
        InsertTailList(&m_listhead_recipients, &(pRecip->m_le));
        pRecip->AddRef();
        ReleaseSpinLock(&m_spinlock);
    }

    CatFunctLeaveEx((LPARAM)this);
} // CICategorizerListResolveIMP::ResolveRecipientAfterSender


//+------------------------------------------------------------
//
// Function: CSinkInsertionRequest::HrInsertSearches
//
// Synopsis: This is the callback routine from LdapConn requesting
//           that we insert search requests now.
//
// Arguments:
//  dwcSearches: Number of searches we are allowed to insert
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1999/03/23 20:00:25: Created.
//
//-------------------------------------------------------------
HRESULT CSinkInsertionRequest::HrInsertSearches(
    DWORD dwcSearches)
{
    HRESULT hr = S_OK;
    HRESULT hrFailure = S_OK;
    LIST_ENTRY listhead;
    PLIST_ENTRY ple;
    DWORD dwc;
    BOOL fDone = FALSE;

    CatFunctEnterEx((LPARAM)this,
                      "CSinkInsertionRequest::HrInsertSearches");

    dwc = 0;

    //
    // Grab the pending list
    //
    AcquireSpinLock(&m_spinlock);

    if(!IsListEmpty(&m_listhead)) {
        CopyMemory(&listhead, &m_listhead, sizeof(LIST_ENTRY));
        InitializeListHead(&m_listhead);
        //
        // Fix list pointers
        //
        listhead.Flink->Blink = &listhead;
        listhead.Blink->Flink = &listhead;
    } else {
        InitializeListHead(&listhead);
    }
    ReleaseSpinLock(&m_spinlock);

    //
    // Insert items on the list
    //
    for(ple = listhead.Flink;
        (ple != &listhead) && (dwc < dwcSearches);
        ple = listhead.Flink) {
        
        CCatAddr *pCCatAddr;
        pCCatAddr = CONTAINING_RECORD(ple, CCatAddr, m_listentry);

        if(SUCCEEDED(hr)) {
            hr = pCCatAddr->HrResolveIfNecessary();
            if(hr == S_OK)
                dwc++;
            else if(FAILED(hr))
            {
                ERROR_LOG("pCCatAddr->HrResolveIfNecessary");
            }
        }
        RemoveEntryList(&(pCCatAddr->m_listentry));
        pCCatAddr->Release();
        m_pCICatListResolve->DecrPendingLookups();
    }

    if(!IsListEmpty(&listhead)) {
        
        _ASSERT(SUCCEEDED(hr));
        _ASSERT(dwc == dwcSearches);
        //
        // Link our remaining blocks to the head of the list
        //
        AcquireSpinLock(&m_spinlock);
        listhead.Flink->Blink = &m_listhead;
        listhead.Blink->Flink = m_listhead.Flink;
        m_listhead.Flink->Blink = listhead.Blink;
        m_listhead.Flink = listhead.Flink;
        ReleaseSpinLock(&m_spinlock);
        
        InsertInternalInsertionRequest();
    } else {
    
        fDone = TRUE;
    }

    if(FAILED(hr)) {
        _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));
    } else {
        hr = (fDone ? HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) : S_OK);
    }

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
        
    return hr;
} // CSinkInsertionRequest::HrInsertSearches



//+------------------------------------------------------------
//
// Function: CSinkInsertionRequest::NotifyDeQueue
//
// Synopsis: Notification that our insertion request is being removed
//           from the LDAPConn queue
//
// Arguments:
//  hr: THe reason why we are being dequeue'd
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/24 13:04:59: Created.
//
//-------------------------------------------------------------
VOID CSinkInsertionRequest::NotifyDeQueue(
    HRESULT hr)
{
    CatFunctEnterEx((LPARAM)this, "CSinkInsertionRequest::NotifyDeQueue");

    //
    // Reinsert the block if necessary
    //
    InsertInternalInsertionRequest(TRUE);

    CatFunctLeaveEx((LPARAM)this);
} // CSinkInsertionRequest::NotifyDeQueue


//+------------------------------------------------------------
//
// Function: CSinkInsertionRequest::InsertInternalInsertionRequest
//
// Synopsis: Inserts this object's internal insertion request if necessary
//
// Arguments:
//  fReinsert: if TRUE, this is the notification that we are being
//             un-inserted and should reinsert if necessary 
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/24 15:21:06: Created.
//
//-------------------------------------------------------------
VOID CSinkInsertionRequest::InsertInternalInsertionRequest(
    BOOL fReinsert)
{
    HRESULT hr = S_OK;
    BOOL fNeedToInsert;

    CatFunctEnterEx((LPARAM)this,
                      "CSinkInsertionRequest::InsertInternalInsertionRequest");
    
    //
    // Decide if we need to insert the request or not
    //
    AcquireSpinLock(&m_spinlock);

    if(fReinsert)
        m_fInserted = FALSE;

    if(IsListEmpty(&m_listhead) || 
       (m_fInserted == TRUE)) {
        
        fNeedToInsert = FALSE;

    } else {
        //
        // We have a non-empty list and our insertion context has not
        // been inserted.  We need to insert it.
        //
        fNeedToInsert = TRUE;
        m_fInserted = TRUE; // Do not allow another thread to insert
                            // at the same time
    }
    ReleaseSpinLock(&m_spinlock);

    if(fNeedToInsert) {

        hr = m_pCICatListResolve->HrInsertInsertionRequest(this);
        if(FAILED(hr)) {
            LIST_ENTRY listhead;
            PLIST_ENTRY ple;

            ERROR_LOG("m_pCICatListResolve->HrInsertInsertionRequest");
            _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));
            AcquireSpinLock(&m_spinlock);
            
            if(!IsListEmpty(&m_listhead)) {
                CopyMemory(&listhead, &m_listhead, sizeof(LIST_ENTRY));
                listhead.Blink->Flink = &listhead;
                listhead.Flink->Blink = &listhead;
                InitializeListHead(&m_listhead);
            } else {
                InitializeListHead(&listhead);
            }
            m_fInserted = FALSE;
            ReleaseSpinLock(&m_spinlock);
                       
            //
            // Empty out the list
            //
            for(ple = listhead.Flink;
                ple != &listhead;
                ple = listhead.Flink) {
        
                CCatAddr *pCCatAddr;
                pCCatAddr = CONTAINING_RECORD(ple, CCatAddr, m_listentry);

                RemoveEntryList(&(pCCatAddr->m_listentry));
                pCCatAddr->Release();
                m_pCICatListResolve->DecrPendingLookups();
            }
        }
    }

    CatFunctLeaveEx((LPARAM)this);
} // CSinkInsertionRequest::InsertInternalInsertionRequest


//+------------------------------------------------------------
//
// Function: CSinkInsertionRequest::InsertItem
//
// Synopsis: Inserts one item into the pending queue of CCatAddrs to
//           be resolved
//
// Arguments:
//  pCCatAddr: the item to be inserted
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/25 10:46:59: Created.
//
//-------------------------------------------------------------
VOID CSinkInsertionRequest::InsertItem(
    CCatAddr *pCCatAddr)
{
    CatFunctEnterEx((LPARAM)this, "CSinkInsertionRequest::InsertItem");

    //
    // Put this thing in our queue
    //
    _ASSERT(pCCatAddr);
    pCCatAddr->AddRef();
    m_pCICatListResolve->IncPendingLookups();
    AcquireSpinLock(&m_spinlock);
    InsertTailList(&m_listhead, &(pCCatAddr->m_listentry));
    ReleaseSpinLock(&m_spinlock);
    //
    // Insert the InsertionContext if necessary
    //
    InsertInternalInsertionRequest();

    CatFunctLeaveEx((LPARAM)this);
} // CSinkInsertionRequest::InsertItem


//+------------------------------------------------------------
//
// Function: GetISMTPServerEx
//
// Synopsis: Gets the ISMTPServerEx interface
//
// Arguments: None
//
// Returns:
//  Pointer to ISMTPServerEx interface, OR
//  NULL if unavailable
//
// History:
// jstamerj 2001/12/11 01:02:15: Created.
//
//-------------------------------------------------------------
ISMTPServerEx * CSinkInsertionRequest::GetISMTPServerEx()
{
    return m_pCICatListResolve->GetISMTPServerEx();
}



//+------------------------------------------------------------
//
// Function: CTopLevelInsertionRequest::HrInsertSearches
//
// Synopsis: Insert the top level categorizer searches
//
// Arguments:
//  dwcSearches: Number of searches we are allowed to insert
//
// Returns:
//  S_OK: Success
//  error: Stop inserting
//
// History:
// jstamerj 1999/03/25 23:30:50: Created.
//
//-------------------------------------------------------------
HRESULT CTopLevelInsertionRequest::HrInsertSearches(
    DWORD dwcSearches)
{
    HRESULT hr = S_OK;
    CCatAddr *pCCatAddr = NULL;
    ICategorizerItem *pICatItemNew = NULL;
    DWORD dwCatFlags;
    DWORD dwc;

    CatFunctEnterEx((LPARAM)this, "CTopLevelInsertionRequest::HrInsertSearches");

    dwc = 0;

    if(FAILED(m_hr))
        goto CLEANUP;

    if(dwcSearches == 0)
        goto CLEANUP;

    //
    // Resolve the sender?
    //
    dwCatFlags = m_pCICatListResolve->GetCatFlags();

    if(!m_fSenderFinished) {
        //
        // Perf shortcut; skip creating an ICatItem if we know we don't
        // resolve senders
        //
        if(dwCatFlags & SMTPDSFLAG_RESOLVESENDER) {
        
            // Create sender address object
            hr = m_pCICatListResolve->AllocICategorizerItem(
                SOURCE_SENDER,
                &pICatItemNew);
            ERROR_CLEANUP_LOG("m_pCICatListResolve->AllocICategorizerItem - 0");
            //
            // Set required ICategorizerItem props
            //
            _VERIFY(SUCCEEDED(pICatItemNew->PutIMailMsgProperties(
                ICATEGORIZERITEM_IMAILMSGPROPERTIES,
                m_pIMailMsgProperties)));

            hr = m_pCICatListResolve->GetCCatAddrFromICategorizerItem(
                pICatItemNew,
                &pCCatAddr);
            ERROR_CLEANUP_LOG("m_pCICatListResolve->PutIMailMsgProperties");

            hr = pCCatAddr->HrResolveIfNecessary();
            if(hr == S_OK) {
                dwc++;
            } else if(FAILED(hr)) {
                ERROR_LOG("pCCatAddr->HrResolveIfNecessary");
                goto CLEANUP;
            }

            pICatItemNew->Release();
            pICatItemNew = NULL;
        }
        //
        // How many recips do we have?
        //
        hr = m_pOrigRecipList->Count(&m_dwcRecips);
        ERROR_CLEANUP_LOG("m_pOrigRecipList->Count");
        //
        // Increment the pre-cat recip count
        //
        INCREMENT_COUNTER_AMOUNT(PreCatRecipients, m_dwcRecips);
        m_fSenderFinished = TRUE;
    }
    //
    // m_dwNextRecip is initialized in the class constructor
    //
    for(; 
        (m_dwNextRecip < m_dwcRecips) && (dwc < dwcSearches); 
        m_dwNextRecip++) {
        // Create the container for this recipient
        DWORD dwNewIndex;

        hr = m_pCatRecipList->AddPrimary(
            0,
            NULL,
            NULL,
            &dwNewIndex,
            m_pOrigRecipList,
            m_dwNextRecip);
        ERROR_CLEANUP_LOG("m_pCatRecipList->AddPrimary");

        hr = m_pCICatListResolve->AllocICategorizerItem(
            SOURCE_RECIPIENT,
            &pICatItemNew);
        ERROR_CLEANUP_LOG("m_pCICatListResolve->AllocICategorizerItem - 1");
        //
        // Set required ICatItem props
        //
        _VERIFY(SUCCEEDED(pICatItemNew->PutIMailMsgProperties(
            ICATEGORIZERITEM_IMAILMSGPROPERTIES,
            m_pIMailMsgProperties)));
        _VERIFY(SUCCEEDED(pICatItemNew->PutIMailMsgRecipientsAdd(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADD,
            m_pCatRecipList)));
        _VERIFY(SUCCEEDED(pICatItemNew->PutDWORD(
            ICATEGORIZERITEM_IMAILMSGRECIPIENTSADDINDEX,
            dwNewIndex)));
        _VERIFY(SUCCEEDED(pICatItemNew->PutBool(
            ICATEGORIZERITEM_FPRIMARY,
            TRUE)));
        _VERIFY(SUCCEEDED(pICatItemNew->PutDWORD(
            ICATEGORIZERITEM_DWLEVEL,
            0)));

        hr = m_pCICatListResolve->GetCCatAddrFromICategorizerItem(
            pICatItemNew,
            &pCCatAddr);
        ERROR_CLEANUP_LOG_ADDR(pICatItemNew, "m_pCICatListResolve->GetCCatAddrFromICategorizerItem");
            
        hr = pCCatAddr->HrResolveIfNecessary();
        if(hr == S_OK) {
            dwc++;
        } else if(FAILED(hr)) {
            ERROR_LOG("pCCatAddr->HrResolveIfNecessary");
            goto CLEANUP;
        }

        pICatItemNew->Release();
        pICatItemNew = NULL;
    }

 CLEANUP:
    if(pICatItemNew)
        pICatItemNew->Release();

    if(FAILED(hr)) {
        ErrorTrace(0, "Something failed during query dispatch phase with hr %08lx - canceling all dispatched lookups", hr);
        // On any errors in here, cancel all pending searches.
        // -- their completion routines will be called with errors
        // as well as our master completion routine (by the store).
        // It, not us, will notify caller that there was an error.

        // Set the list resolve error just in case no CCatAddr objets
        // were dispatched (which normally set the list resolve error)
        _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));
        m_hr = hr;
    } else {
    
        hr = (m_dwNextRecip >= m_dwcRecips ? HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) : S_OK);
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CTopLevelInsertionRequest::HrInsertSearches


//+------------------------------------------------------------
//
// Function: CTopLevelInsertionRequest::NotifyDeQueue
//
// Synopsis: Notification that the insertion request is being dequeued
//
// Arguments:
//  hrReason: THe reason why we were dequeue'd
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/25 23:50:08: Created.
//
//-------------------------------------------------------------
VOID CTopLevelInsertionRequest::NotifyDeQueue(
    HRESULT hrReason)
{
    HRESULT hr = hrReason;
    BOOL fReinserted = FALSE;

    CatFunctEnterEx((LPARAM)this, "CTopLevelInsertionRequest::NotifyDeQueue");
    
    if( hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) )
        hr = S_OK;

    if( ((hr == CAT_E_DBCONNECTION) || (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED))) &&
        (!fTopLevelInsertionFinished())) {
        //
        // We have more to issue, so reinsert this request
        //
        hr = m_pCICatListResolve->HrInsertInsertionRequest(this);
        if(SUCCEEDED(hr))
            fReinserted = TRUE;
        else {
            ERROR_LOG("m_pCICatListResolve->HrInsertInsertionRequest");
        }
    }

    if(FAILED(hr))
        _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));

    if(!fReinserted)
        m_pCICatListResolve->DecrPendingLookups();

    CatFunctLeaveEx((LPARAM)this);
} // CTopLevelInsertionRequest::NotifyDeQueue


//+------------------------------------------------------------
//
// Function: CTopLevelInsertionRequest::BeginItemResolves
//
// Synopsis: Inserts the insertion request for the top level item resolves
//
// Arguments: Interfaces to use for the top level recipients
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/03/26 01:07:20: Created.
//
//-------------------------------------------------------------
VOID CTopLevelInsertionRequest::BeginItemResolves(
        IMailMsgProperties *pIMailMsgProperties,
        IMailMsgRecipients *pOrigRecipList,
        IMailMsgRecipientsAdd *pCatRecipList) 
{
    HRESULT hr;
    CatFunctEnterEx((LPARAM)this,
                      "CTopLevelInsertionRequest::BeginItemResolves");

    m_pIMailMsgProperties = pIMailMsgProperties;
    m_pOrigRecipList = pOrigRecipList;
    m_pCatRecipList = pCatRecipList;
    m_pCICatListResolve->IncPendingLookups();

    hr = m_pCICatListResolve->HrInsertInsertionRequest(this);
    if(FAILED(hr)) {
        ERROR_LOG("m_pCICatListResolve->HrInsertInsertionRequest");
        _VERIFY(SUCCEEDED(m_pCICatListResolve->SetListResolveStatus(hr)));
        m_pCICatListResolve->DecrPendingLookups();
    }

    CatFunctLeaveEx((LPARAM)this);
} // CTopLevelInsertionRequest::BeginItemResolves


//+------------------------------------------------------------
//
// Function: GetISMTPServerEx
//
// Synopsis: Gets the ISMTPServerEx interface
//
// Arguments: None
//
// Returns:
//  Pointer to ISMTPServerEx interface, OR
//  NULL if unavailable
//
// History:
// jstamerj 2001/12/11 01:02:15: Created.
//
//-------------------------------------------------------------
ISMTPServerEx * CTopLevelInsertionRequest::GetISMTPServerEx()
{
    return m_pCICatListResolve->GetISMTPServerEx();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatparam.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatdsparam.cpp
//
// Contents: Implementation of ICategorizerParameters
//
// Classes:
//   CICategorizerParametersIMP
//
// Functions:
//   CICategorizerParameters
//   ~CICategorizerParameters
//   QueryInterface
//   AddRef
//   Release
//
// History:
// jstamerj 980611 16:20:27: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatparam.h"

//+------------------------------------------------------------
//
// Function: CICategorizerParameters::CICategorizerParameters
//
// Synopsis: Initialize private member data
//
// Arguments:
//  pCCatConfigInfo: pointer to the config info for this virtual categorizer
//  dwInitialICatItemProps: Initailly reserved ICategorizerItem properties
//  dwInitialICatListReesolveProps: Initially reserved
//                                  ICategorizerListResolve properties
//  pISMTPServerEx: ISMTPServerEx interface
// Returns: NOTHING
//
// History:
// jstamerj 980611 20:02:35: Created.
//
//-------------------------------------------------------------
CICategorizerParametersIMP::CICategorizerParametersIMP(
    PCCATCONFIGINFO pCCatConfigInfo,
    DWORD dwInitialICatItemProps,
    DWORD dwInitialICatListResolveProps,
    ISMTPServerEx *pISMTPServerEx)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerParameters::CICategorizerParameters");
    m_dwSignature = SIGNATURE_CICategorizerParametersIMP;
    m_cRef = 0;

    m_fReadOnly = FALSE;

    ZeroMemory(m_rgszDSParameters, sizeof(m_rgszDSParameters));
    ZeroMemory(m_rgwszDSParameters, sizeof(m_rgwszDSParameters));

    m_dwCurPropId_ICatItem = dwInitialICatItemProps;
    m_dwCurPropId_ICatListResolve = dwInitialICatListResolveProps;

    m_pCCatConfigInfo = pCCatConfigInfo;
    m_pCIRequestedAttributes = NULL;
    m_pICatLdapConfigInfo = NULL;

    m_pISMTPServerEx = pISMTPServerEx;
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->AddRef();
    //
    // HrDllInitialize should always succeed here (since the DLL is
    // already initialized, it will just increment the refcount)
    //
    _VERIFY(SUCCEEDED(HrDllInitialize()));
    CatFunctLeaveEx((LPARAM)this);
}


//+------------------------------------------------------------
//
// Function: CICategorizerParameters::~CICategorizerParameters
//
// Synopsis: Release all allocateded data
//
// Arguments:
//
// Returns: NOTHING
//
// History:
// jstamerj 980611 20:04:08: Created.
//
//-------------------------------------------------------------
CICategorizerParametersIMP::~CICategorizerParametersIMP()
{
    LONG lCount;

    CatFunctEnterEx((LPARAM)this, "CICategorizerParameters::~CICategorizerParameters");
    _ASSERT(m_cRef == 0);
    _ASSERT(m_dwSignature == SIGNATURE_CICategorizerParametersIMP);

    m_dwSignature = SIGNATURE_CICategorizerParametersIMP_Invalid;

    //
    // Free all string parameters
    //
    for(lCount = 0; lCount < PHAT_DSPARAMETER_ENDENUMMESS; lCount++) {
        if(m_rgszDSParameters[lCount])
            delete m_rgszDSParameters[lCount];
        if(m_rgwszDSParameters[lCount])
            delete m_rgwszDSParameters[lCount];
    }
    if(m_pCIRequestedAttributes)
        m_pCIRequestedAttributes->Release();

    if(m_pICatLdapConfigInfo)
        m_pICatLdapConfigInfo->Release();

    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    DllDeinitialize();
    CatFunctLeaveEx((LPARAM)this);
}

//+------------------------------------------------------------
//
// Function: QueryInterface
//
// Synopsis: Returns pointer to this object for IUnknown and ICategorizerParameters
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 980612 14:07:57: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) ((ICategorizerParametersEx *)this);
    } else if (iid == IID_ICategorizerParameters) {
        *ppv = (LPVOID) ((ICategorizerParametersEx *)this);
    } else if (iid == IID_ICategorizerParametersEx) {
        *ppv = (LPVOID) ((ICategorizerParametersEx *)this);
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: AddRef
//
// Synopsis: adds a reference to this object
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:14: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerParametersIMP::AddRef()
{
    return InterlockedIncrement((PLONG)&m_cRef);
}


//+------------------------------------------------------------
//
// Function: Release
//
// Synopsis: releases a reference, deletes this object when the
//           refcount hits zero.
//
// Arguments: NONE
//
// Returns: New reference count
//
// History:
// jstamerj 980611 20:07:33: Created.
//
//-------------------------------------------------------------
ULONG CICategorizerParametersIMP::Release()
{
    LONG lNewRefCount;
    lNewRefCount = InterlockedDecrement((PLONG)&m_cRef);
    if(lNewRefCount == 0) {
        delete this;
        return 0;
    } else {
        return lNewRefCount;
    }
}



//+------------------------------------------------------------
//
// Function: GetDSParameterA
//
// Synopsis: Retrieves pointer to DSParameter string
//
// Arguments:
//   dwDSParameter: Identifies parameter to retrieve
//   ppszValue: pointer to pointer to recieve value string
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 980611 20:28:02: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::GetDSParameterA(
    DWORD   dwDSParameter,
    LPSTR  *ppszValue)
{
    CatFunctEnterEx((LPARAM)this, "GetDSParamterA");

    if(dwDSParameter >= PHAT_DSPARAMETER_ENDENUMMESS) {
        ErrorTrace((LPARAM)this, "Invalid dwDSParameter %ld", dwDSParameter);
        CatFunctLeaveEx((LPARAM)this);
        return E_INVALIDARG;
    }

    if(ppszValue == NULL) {
        ErrorTrace((LPARAM)this, "Invalid ppszValue (NULL)");
        CatFunctLeaveEx((LPARAM)this);
        return E_INVALIDARG;
    }

    *ppszValue = m_rgszDSParameters[dwDSParameter];
    CatFunctLeaveEx((LPARAM)this);
    return (*ppszValue) ? S_OK : CAT_E_PROPNOTFOUND;
}


//+------------------------------------------------------------
//
// Function: GetDSParameterA
//
// Synopsis: Retrieves pointer to DSParameter string
//
// Arguments:
//   dwDSParameter: Identifies parameter to retrieve
//   ppszValue: pointer to pointer to recieve value string
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1999/12/09 20:23:24: Created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::GetDSParameterW(
    DWORD   dwDSParameter,
    LPWSTR *ppszValue)
{
    CatFunctEnterEx((LPARAM)this, "GetDSParamterA");

    if(dwDSParameter >= PHAT_DSPARAMETER_ENDENUMMESS) {
        ErrorTrace((LPARAM)this, "Invalid dwDSParameter %ld", dwDSParameter);
        CatFunctLeaveEx((LPARAM)this);
        return E_INVALIDARG;
    }

    if(ppszValue == NULL) {
        ErrorTrace((LPARAM)this, "Invalid ppszValue (NULL)");
        CatFunctLeaveEx((LPARAM)this);
        return E_INVALIDARG;
    }

    *ppszValue = m_rgwszDSParameters[dwDSParameter];
    CatFunctLeaveEx((LPARAM)this);
    return (*ppszValue) ? S_OK : CAT_E_PROPNOTFOUND;
}


//+------------------------------------------------------------
//
// Function: SetDSParameterA
//
// Synopsis: Copies string and sets DS Parameter
//
// Arguments:
//   dwDSParameter: Identifies parameter to retrieve
//   pszValue: pointer to string to copy/set
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_ACCESSDENIED
//
// History:
// jstamerj 980611 20:47:53: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::SetDSParameterA(
    DWORD dwDSParameter,
    LPCSTR pszValue)
{
    HRESULT hr = S_OK;
    LPSTR pszNew = NULL;
    LPSTR pszOld = NULL;
    LPWSTR pwszNew = NULL;
    LPWSTR pwszOld = NULL;
    int   cch, i;

    CatFunctEnterEx((LPARAM)this, "SetDSParamterA");

    if(dwDSParameter >= PHAT_DSPARAMETER_ENDENUMMESS) {
        ErrorTrace((LPARAM)this, "Invalid dwDSParameter %ld", dwDSParameter);
        hr = E_INVALIDARG;
        goto CLEANUP;
    }
    if(m_fReadOnly) {
        ErrorTrace((LPARAM)this, "Error: we are read only");
        hr = E_ACCESSDENIED;
        goto CLEANUP;
    }

    DebugTrace((LPARAM)this, "Setting parameter %ld to \"%s\"",
               dwDSParameter, pszValue ? pszValue : "NULL");

    if(pszValue) {
        pszNew = new CHAR[lstrlen(pszValue) + 1];
        if(pszNew == NULL) {
            ErrorTrace((LPARAM)this, "Out of memory copying string");
            hr = E_OUTOFMEMORY;
            ERROR_LOG("new CHAR");
            goto CLEANUP;
        }
        lstrcpy(pszNew, pszValue);
        //
        // Convert to unicode
        //
        cch = MultiByteToWideChar(
            CP_UTF8,
            0,
            pszValue,
            -1,
            NULL,
            0);
        if(cch == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERROR_LOG("MultiByteToWideChar - 0");
            goto CLEANUP;
        }
        pwszNew = new WCHAR[cch];
        if(pwszNew == NULL) {
            hr = E_OUTOFMEMORY;
            ERROR_LOG("new WCHAR");
            goto CLEANUP;
        }
        i = MultiByteToWideChar(
            CP_UTF8,
            0,
            pszValue,
            -1,
            pwszNew,
            cch);
        if(cch == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERROR_LOG("MultiByteToWideChar - 1");
            goto CLEANUP;
        }
    }
    pszOld = m_rgszDSParameters[dwDSParameter];
    m_rgszDSParameters[dwDSParameter] = pszNew;
    pwszOld = m_rgwszDSParameters[dwDSParameter];
    m_rgwszDSParameters[dwDSParameter] = pwszNew;

    if(pszOld)
        delete [] pszOld;
    if(pwszOld)
        delete [] pwszOld;

 CLEANUP:
    if(FAILED(hr)) {

        if(pszNew)
            delete [] pszNew;
        if(pwszNew)
            delete [] pwszNew;
    }
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: RequestAttributeA
//
// Synopsis: Adds an attribute to the array
//
// Arguments:
//   pszName: name of attribute to add
//
// Returns:
//  S_OK: Success
//  S_FALSE: Yeah, we already have that attribute
//  E_OUTOFMEMORY: duh
//  E_ACCESSDENIED: we are read only
//  HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)
//
// History:
// jstamerj 980611 20:08:07: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::RequestAttributeA(
    LPCSTR pszName)
{
    HRESULT hr;
    BOOL fExclusiveLock = FALSE;
    LPSTR *rgsz;
    LPSTR *ppsz;
    CICategorizerRequestedAttributesIMP *pCIRequestedAttributes = NULL;

    CatFunctEnterEx((LPARAM)this,
                      "CICategorizerParametersIMP::RequestAttributeA");
    _ASSERT(pszName);
    if(pszName == NULL) {
        ErrorTrace((LPARAM)this, "RequestAttributeA called with NULL pszName");
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CLEANUP;
    }

    m_sharelock.ExclusiveLock();
    fExclusiveLock = TRUE;
    //
    // Create the ICategorizerRequestedAttributes object if it does
    // not exist yet
    //
    if(m_pCIRequestedAttributes == NULL) {

        m_pCIRequestedAttributes = new CICategorizerRequestedAttributesIMP(GetISMTPServerEx());
        if(m_pCIRequestedAttributes == NULL) {
            //
            // Out of memory
            //
            hr = E_OUTOFMEMORY;
            ERROR_LOG("new CICategorizerRequestedAttributesIMP");
            goto CLEANUP;

        } else {
            //
            // One reference from this object
            //
            m_pCIRequestedAttributes->AddRef();
        }
    }
    //
    // Don't add the attribute if it is alrady in the list
    //
    if(SUCCEEDED(m_pCIRequestedAttributes->FindAttribute(pszName))) {
        DebugTrace((LPARAM)this, "Already added attribute %s", pszName);
        hr = S_FALSE;
        goto CLEANUP;
    }

    //
    // There are two paths we can go down here.
    // 1) If have the only reference to m_pCIRequestedAttributes, we
    //    safely direcly add the attribute to the existing
    //    RequestedAttributes object (we will not give out the object
    //    until we release the exclusivelock below).
    // 2) If someone else does have a reference to
    // m_pCIRequestedAttributes, we need to construct a new
    // RequestedAttributes object and copy all of the old
    // RequestedAttributes to the new object.
    //
    if(m_pCIRequestedAttributes->GetReferenceCount() != 1) {
        //
        // Construct a new object
        //
        pCIRequestedAttributes = new CICategorizerRequestedAttributesIMP(GetISMTPServerEx());
        if(pCIRequestedAttributes == NULL) {
            ErrorTrace((LPARAM)this, "Out of memory");
            hr = E_OUTOFMEMORY;
            ERROR_LOG("new CICategorizerRequestedAttributesIMP");
            goto CLEANUP;
        }

        pCIRequestedAttributes->AddRef();

        //
        // Copy all the attributes
        //
        hr = m_pCIRequestedAttributes->GetAllAttributes(
            &rgsz);
        ERROR_CLEANUP_LOG("m_pCIRequestedAttributes->GetAllAttributeValues");

        if(rgsz) {
            ppsz = rgsz;
            while((*ppsz) && SUCCEEDED(hr)) {

                hr = pCIRequestedAttributes->AddAttribute(
                    *ppsz);
                ppsz++;
            }
            ERROR_CLEANUP_LOG("pCIRequestedAttributes->AddAttribute");
        }
        //
        // Release the old interface; switch to using the new one
        //
        m_pCIRequestedAttributes->Release();
        m_pCIRequestedAttributes = pCIRequestedAttributes;
        pCIRequestedAttributes = NULL;
    }
    //
    // Now add the new attribute
    //
    hr = m_pCIRequestedAttributes->AddAttribute(pszName);
    ERROR_CLEANUP_LOG("m_pCIRequestedAttributes->AddAttribute");

 CLEANUP:
    if(fExclusiveLock)
        m_sharelock.ExclusiveUnlock();

    if(FAILED(hr)) 
    {
        if(pCIRequestedAttributes)
            pCIRequestedAttributes->Release();
    }
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: GetRequetedAttributes
//
// Synopsis: Retrieve interface ptr that can be used to get all attributes
//
// Arguments:
//  ppIRequestedAttributes: Out paramter to receive ptr to the
//                          attributes interface.  This must be
//                          released by the caller
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND): No attributes have been
//  requested to date.
//
// History:
// jstamerj 980611 20:57:08: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::GetRequestedAttributes(
    OUT  ICategorizerRequestedAttributes **ppIRequestedAttributes)
{
    HRESULT hr = S_OK;
    _ASSERT(ppIRequestedAttributes);
    m_sharelock.ShareLock();

    if(m_pCIRequestedAttributes == NULL) {

        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    } else {

        *ppIRequestedAttributes = m_pCIRequestedAttributes;
        (*ppIRequestedAttributes)->AddRef();
    }
    m_sharelock.ShareUnlock();
    return hr;
}


//+------------------------------------------------------------
//
// Function: ReserveICatItemPropIds
//
// Synopsis: Register a range of PropIds to use
//
// Arguments:
//   dwNumPropIdsRequested: how many props do you want?
//   pdwBeginningRange: pointer to dword to recieve your first propId
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1998/06/26 18:32:51: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::ReserveICatItemPropIds(
    DWORD dwNumPropIdsRequested,
    DWORD *pdwBeginningPropId)
{
    if(pdwBeginningPropId == NULL) {
        return E_INVALIDARG;
    }

    *pdwBeginningPropId = InterlockedExchangeAdd(
        (PLONG) &m_dwCurPropId_ICatItem,
        (LONG) dwNumPropIdsRequested);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: ReserveICatListResolvePropIds
//
// Synopsis: Register a range of PropIds to use
//
// Arguments:
//   dwNumPropIdsRequested: how many props do you want?
//   pdwBeginningRange: pointer to dword to recieve your first propId
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1998/11/11 19:51:19: created
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::ReserveICatListResolvePropIds(
    DWORD dwNumPropIdsRequested,
    DWORD *pdwBeginningPropId)
{
    if(pdwBeginningPropId == NULL) {
        return E_INVALIDARG;
    }

    *pdwBeginningPropId = InterlockedExchangeAdd(
        (PLONG) &m_dwCurPropId_ICatListResolve,
        (LONG) dwNumPropIdsRequested);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerParametersIMP::GetCCatConfigInfo
//
// Synopsis: Return a pointer to the ccatconfiginfo structure without
//  extended members
//
// Arguments:
//  ppCCatConfigInfo: ptr to the ptr to set to the CCatConfigInfo ptr
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//
// History:
// jstamerj 1998/12/14 11:53:20: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerParametersIMP::GetCCatConfigInfo(
    PCCATCONFIGINFO *ppCCatConfigInfo)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this,
                      "CICategorizerParametersIMP::GetCCatConfigInfo");

    if(ppCCatConfigInfo == NULL)
        hr = E_INVALIDARG;
    else
        *ppCCatConfigInfo = m_pCCatConfigInfo;

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: RegisterCatLdapConfigInterface
//
// Synopsis: In order to allow the user to customize which LDAP
//  servers are to be used by the Categorizer, we provide this
//  function to Register a config-interface with the categorizer.
//  The config-interface can be queried to retrieve a list of LDAP
//  servers. Currently PhatCat implements the config-interface and
//  registers it with categorizer.
//
// Arguments:
//   pICatLdapConfigInfo: Ptr to the callback interface
//
// Returns:
//  S_OK: Success
//
// History:
//  gpulla created
//-------------------------------------------------------------
STDMETHODIMP CICategorizerParametersIMP::RegisterCatLdapConfigInterface(
    ICategorizerLdapConfig *pICatLdapConfigInfo)
{
    ICategorizerLdapConfig *pICatLdapConfigInfoOld = NULL;

    CatFunctEnterEx((LPARAM)this, "CICategorizerParametersIMP::RegisterCatLdapConfigInterface");

    DebugTrace((LPARAM)this, "Registering ldap config info interface");

    if(pICatLdapConfigInfo)
        pICatLdapConfigInfo->AddRef();

    pICatLdapConfigInfoOld = (ICategorizerLdapConfig *)
        InterlockedExchangePointer((void**)&m_pICatLdapConfigInfo, pICatLdapConfigInfo);

    if(pICatLdapConfigInfoOld)
        pICatLdapConfigInfoOld->Release();

    CatFunctLeaveEx((LPARAM)this);
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: GetCatLdapConfigInterface
//
// Synopsis: A simple "Get" function to obtain the config-interface
//  registered by RegisterCatLdapConfigInterface(). The config-interface
//  returned is valid as long as CICategorizerParametersIMP has not been
//  destroyed.
//
// Arguments:
//   ppICatLdapConfigInfo: Returned ptr to callback interface.
//                         Gets Released with CICategorizerParametersIMP
//
// Returns:
//  S_OK: Success
//
// History:
//  gpulla created
//-------------------------------------------------------------
STDMETHODIMP  CICategorizerParametersIMP::GetLdapConfigInterface(
    OUT  ICategorizerLdapConfig **ppICatLdapConfigInfo)
{
   *ppICatLdapConfigInfo = m_pICatLdapConfigInfo;
   return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerRequestedAttributesIMP::CICategorizerRequestedAttributesIMP
//
// Synopsis: Initialize member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/07/08 14:41:51: Created.
//
//-------------------------------------------------------------
CICategorizerRequestedAttributesIMP::CICategorizerRequestedAttributesIMP(
    IN  ISMTPServerEx *pISMTPServerEx)
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerRequestedAttributesIMP::CICategorizerRequestedAttributesIMP");

    m_dwSignature = SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP;

    m_lAttributeArraySize = 0;
    m_rgszAttributeArray  = NULL;
    m_rgwszAttributeArray = NULL;
    m_lNumberAttributes   = 0;
    m_ulRef = 0;
    m_pISMTPServerEx = pISMTPServerEx;
    if(m_pISMTPServerEx)
        m_pISMTPServerEx->AddRef();

    CatFunctLeaveEx((LPARAM)this);
} // CICategorizerRequestedAttributesIMP::CICategorizerRequestedAttributesIMP



//+------------------------------------------------------------
//
// Function: CICategorizerRequestedAttributesIMP::~CICategorizerRequestedAttributesIMP
//
// Synopsis: Clean up member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/07/08 15:01:17: Created.
//
//-------------------------------------------------------------
CICategorizerRequestedAttributesIMP::~CICategorizerRequestedAttributesIMP()
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerRequestedAttributesIMP::~CICategorizerRequestedAttributesIMP");

    if(m_rgszAttributeArray) {
        _ASSERT(m_rgwszAttributeArray);
        //
        // Free attribute array
        //
        for(LONG lCount = 0; lCount < m_lNumberAttributes; lCount++) {
            delete m_rgszAttributeArray[lCount];
            delete m_rgwszAttributeArray[lCount];
        }
        delete m_rgszAttributeArray;
        delete m_rgwszAttributeArray;
    }

    if(m_pISMTPServerEx)
        m_pISMTPServerEx->Release();

    _ASSERT(m_dwSignature == SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP);
    m_dwSignature = SIGNATURE_CICATEGORIZERREQUESTEDATTRIBUTESIMP_INVALID;

    CatFunctLeaveEx((LPARAM)this);
} // CICategorizerRequestedAttributesIMP::~CICategorizerRequestedAttributesIMP


//+------------------------------------------------------------
//
// Function: CICategorizerRequestedAttributesIMP::QueryInterface
//
// Synopsis: Get interfaces supported by this object
//
// Arguments:
//   iid -- interface ID
//   ppv -- pvoid* to fill in with pointer to interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Don't support that interface
//
// History:
// jstamerj 1999/07/08 15:04:35: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerRequestedAttributesIMP::QueryInterface(
    REFIID iid,
    LPVOID *ppv)
{
    *ppv = NULL;

    if(iid == IID_IUnknown) {
        *ppv = (LPVOID) this;
    } else if (iid == IID_ICategorizerRequestedAttributes) {
        *ppv = (LPVOID) this;
    } else {
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
} // CICategorizerRequestedAttributesIMP::QueryInterface


//+------------------------------------------------------------
//
// Function: ReAllocArrayIfNecessary
//
// Synopsis: Reallocate the parameter string pointer array if necessary
//
// Arguments:
//   lNewAttributeCount: number of attribute we want to add right now
//
// Returns:
//  S_OK: Success
//  S_FALSE: Success, no realloc was necessary
//  E_OUTOFMEMORY: duh
//
// History:
// jstamerj 980611 16:55:36: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerRequestedAttributesIMP::ReAllocArrayIfNecessary(
    LONG lNewAttributeCount)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CICategorizerRequestedAttributesIMP::ReAllocArrayIfNecessary");

    if(m_lNumberAttributes + lNewAttributeCount >= m_lAttributeArraySize) {
        //
        // Grow the array by DSPARAMETERS_DEFAULT_ATTR_ARRAY_SIZE
        //
        LPSTR *rgTemp;
        LPWSTR *rgwTemp;
        LONG lNewSize = m_lAttributeArraySize + DSPARAMETERS_DEFAULT_ATTR_ARRAY_SIZE;

        DebugTrace((LPARAM)this, "Attempting realloc, new size = %d", lNewSize);

        rgTemp = new LPSTR[lNewSize];
        if(rgTemp == NULL) {
            hr = E_OUTOFMEMORY;
            ErrorTrace((LPARAM)this, "Out of memory reallocing array");
            ERROR_LOG("new LPSTR[]");
            return hr;
        }

        rgwTemp = new LPWSTR[lNewSize];
        if(rgwTemp == NULL) {
            hr = E_OUTOFMEMORY;
            delete [] rgTemp;
            ErrorTrace((LPARAM)this, "Out of memory reallocing array");
            ERROR_LOG("new LPWSTR[]");
            return hr;
        }

        if(m_rgszAttributeArray) {
            _ASSERT(m_rgwszAttributeArray);
            //
            // Copy old ptr array to new
            //
            CopyMemory(rgTemp, m_rgszAttributeArray, sizeof(LPSTR) * m_lNumberAttributes);
            CopyMemory(rgwTemp, m_rgwszAttributeArray, sizeof(LPWSTR) * m_lNumberAttributes);
            //
            // Zero the rest of the memory (keep the LPSTR array NULL termianted)
            //
            ZeroMemory(rgTemp + m_lNumberAttributes,
                       (lNewSize - m_lNumberAttributes) * sizeof(LPSTR));
            ZeroMemory(rgwTemp + m_lNumberAttributes,
                       (lNewSize - m_lNumberAttributes) * sizeof(LPWSTR));
            //
            // Release old array
            //
            LPSTR *rgTempOld = m_rgszAttributeArray;
            LPWSTR *rgwTempOld = m_rgwszAttributeArray;
            m_rgszAttributeArray = rgTemp;
            m_rgwszAttributeArray = rgwTemp;
            delete [] rgTempOld;
            delete [] rgwTempOld;

        } else {
            //
            // This is the first time we've alloc'd the array
            //
            ZeroMemory(rgTemp, lNewSize * sizeof(LPSTR));
            ZeroMemory(rgwTemp, lNewSize * sizeof(LPWSTR));
            m_rgszAttributeArray = rgTemp;
            m_rgwszAttributeArray = rgwTemp;
        }

        m_lAttributeArraySize = lNewSize;

        CatFunctLeaveEx((LPARAM)this);
        return S_OK;

    } else {
        //
        // No realloc required
        //
        DebugTrace((LPARAM)this, "No realloc required");
        CatFunctLeaveEx((LPARAM)this);
        return S_FALSE;
    }
}


//+------------------------------------------------------------
//
// Function: FindAttribute
//
// Synopsis: Checks to see if our array contains an attribute string
//
// Arguments:
//  pszAttribute: The attribute you're looking for
//
// Returns:
//  S_OK: Found it
//  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
//
// History:
// jstamerj 980611 20:34:51: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerRequestedAttributesIMP::FindAttribute(
    LPCSTR pszAttribute)
{
    for(LONG lCount = 0; lCount < m_lNumberAttributes; lCount++) {
        if(lstrcmpi(pszAttribute, m_rgszAttributeArray[lCount]) == 0) {
            return S_OK;
        }
    }
    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
}


//+------------------------------------------------------------
//
// Function: AddAttribute
//
// Synopsis: Adds an attribute to the attribute array.  Allocs and
//           copies the string.
//
// Arguments:
//   pszAttribute: pointer to string to copy and add to array
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY: duh
//
// History:
// jstamerj 980611 17:15:40: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerRequestedAttributesIMP::AddAttribute(
    LPCSTR pszAttribute)
{
    HRESULT hr = S_OK;
    DWORD cchAttributeUTF8;
    int i;
    LONG lIndex = -1;

    CatFunctEnterEx((LPARAM)this, "CICategorizerParametersIMP::AddAttribute");

    _ASSERT(pszAttribute);

    //
    // Make sure there is room in the array
    //
    hr = ReAllocArrayIfNecessary(1);
    ERROR_CLEANUP_LOG("ReAllocArrayIfNecessary");

    lIndex = m_lNumberAttributes++;
    m_rgszAttributeArray[lIndex] = NULL;
    m_rgwszAttributeArray[lIndex] = NULL;
    //
    // Calc lengths
    //
    cchAttributeUTF8 = lstrlen(pszAttribute) + 1;
    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        pszAttribute,
        cchAttributeUTF8,
        NULL,
        0);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG("MultiByteToWideChar");
        goto CLEANUP;
    }
    m_rgwszAttributeArray[lIndex] = new WCHAR[i];
    if(m_rgwszAttributeArray[lIndex] == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new WCHAR[]");
        goto CLEANUP;
    }
    //
    // Convert
    //
    i = MultiByteToWideChar(
        CP_UTF8,
        0,
        pszAttribute,
        cchAttributeUTF8,
        m_rgwszAttributeArray[lIndex],
        i);
    if(i == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERROR_LOG("MultiByteToWideChar");
        goto CLEANUP;
    }

    m_rgszAttributeArray[lIndex] = new CHAR[lstrlen(pszAttribute) + 1];
    if(m_rgszAttributeArray[lIndex] == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new CHAR[]");
        goto CLEANUP;
    }
    lstrcpy(m_rgszAttributeArray[lIndex], pszAttribute);

 CLEANUP:
    if(FAILED(hr)) {
        if(lIndex != -1) {
            if(m_rgszAttributeArray[lIndex]) {
                delete [] m_rgszAttributeArray[lIndex];
                m_rgszAttributeArray[lIndex] = NULL;
            }
            if(m_rgwszAttributeArray[lIndex]) {
                delete [] m_rgwszAttributeArray[lIndex];
                m_rgwszAttributeArray[lIndex] = NULL;
            }
            //
            // Obviously, this is not thread safe.
            //
            m_lNumberAttributes--;
            _ASSERT(lIndex == m_lNumberAttributes);
        }
    }
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}

//+------------------------------------------------------------
//
// Function: GetAllAttributes
//
// Synopsis: Retrieve pointer to the array of attributes
//
// Arguments:
//   pprgszAllAttributes: Ptr to ptr to recieve array of attributes
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 980611 20:57:08: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerRequestedAttributesIMP::GetAllAttributes(
    LPTSTR **pprgszAllAttributes)
{
    _ASSERT(pprgszAllAttributes);
    *pprgszAllAttributes = m_rgszAttributeArray;
    return S_OK;
}
//
// Wide version of above
//
STDMETHODIMP CICategorizerRequestedAttributesIMP::GetAllAttributesW(
    LPWSTR **pprgszAllAttributes)
{
    _ASSERT(pprgszAllAttributes);
    *pprgszAllAttributes = m_rgwszAttributeArray;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatmailmsgs.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatmailmsgs.cpp
//
// Contents: Implementation of CICategorizerMailMsgsIMP
//
// Classes: CICategorizerMailMsgsIMP
//
// Functions:
//
// History:
// jstamerj 1998/06/30 13:35:09: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatmailmsgs.h"

//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP constructor
//
// Synopsis: Initialize member data
//
// Arguments:
//  pCICatListResolve: backpointer for QI/AddRef/Release
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/30 13:35:56: Created.
//
//-------------------------------------------------------------
CICategorizerMailMsgsIMP::CICategorizerMailMsgsIMP(
    CICategorizerListResolveIMP *pCICatListResolveIMP)
{
    m_dwSignature = SIGNATURE_CICATEGORIZERMAILMSGSIMP;

    _ASSERT(pCICatListResolveIMP);

    InitializeListHead(&m_listhead);
    m_dwNumIMsgs = 0;
    m_pCICatListResolveIMP = pCICatListResolveIMP;
    m_pIUnknown = (IUnknown *)((ICategorizerListResolve *)pCICatListResolveIMP);
    InitializeCriticalSection(&m_cs);
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::~CICategorizerMailMsgsIMP
//
// Synopsis: Release/delete member data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/30 14:47:13: Created.
//
//-------------------------------------------------------------
CICategorizerMailMsgsIMP::~CICategorizerMailMsgsIMP()
{
    _ASSERT(m_dwSignature == SIGNATURE_CICATEGORIZERMAILMSGSIMP);
    m_dwSignature = SIGNATURE_CICATEGORIZERMAILMSGSIMP_INVALID;
    //
    // Everything should be cleaned up in FinalRelease()
    //
    _ASSERT(IsListEmpty(&m_listhead));

    DeleteCriticalSection(&m_cs);
}

//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::FinalRelease
//
// Synopsis: Release all mailmsg references from this object
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1999/07/14 14:09:08: Created.
//
//-------------------------------------------------------------
VOID CICategorizerMailMsgsIMP::FinalRelease()
{
    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::FinalRelease");

    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    for(ple = m_listhead.Flink; (ple != &m_listhead); ple = m_listhead.Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        if(pIE->pIUnknown)
            pIE->pIUnknown->Release();
        if(pIE->pIMailMsgProperties)
            pIE->pIMailMsgProperties->Release();
        if(pIE->pIMailMsgRecipients)
            pIE->pIMailMsgRecipients->Release();
        if(pIE->pIMailMsgRecipientsAdd)
            pIE->pIMailMsgRecipientsAdd->Release();
        RemoveEntryList(ple);
        delete pIE;
    }
    CatFunctLeaveEx((LPARAM)this);
} // CICategorizerMailMsgsIMP::FinalRelease


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::CreateIMSGEntry
//
// Synopsis: Allocates an IMSGENTRY and initializes interface data members
//
// Arguments:
//  ARG_pIUnknown: Optional Original IMsg IUnknown for this categorization
//  ARG_pIMailMsgProperties: Optional IMailMsgProperties interface to use
//  ARG_pIMailMsgRecipients: Optional IMailMsgRecipients to use
//  ARG_pIMailMsgRecipientsAdd: Optional IMailMsgRecipientsAdd to use
//  fBoundToStore: wether or not the message is bound to a store backing
//
//  NOTE: One of pIUnknown/pIMailMsgProperties/pIMailMsgRecipients MUST be
//  provided
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  E_INVALIDARG
//
// History:
// jstamerj 1998/06/30 13:48:47: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::CreateIMsgEntry(
    PIMSGENTRY *ppIE,
    IUnknown *ARG_pIUnknown,
    IMailMsgProperties *ARG_pIMailMsgProperties,
    IMailMsgRecipients *ARG_pIMailMsgRecipients,
    IMailMsgRecipientsAdd *ARG_pIMailMsgRecipientsAdd,
    BOOL fBoundToStore)
{
    HRESULT hr = S_OK;
    PIMSGENTRY pIE = NULL;
    IUnknown *pValidIMailMsgInterface = NULL;
    IUnknown *pIUnknown = NULL;
    IMailMsgProperties *pIMailMsgProperties = NULL;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd = NULL;

    CatFunctEnterEx((LPARAM)this, "CreateIMsgEntry");

    _ASSERT(ppIE);

    //
    // Allocate IMSGENTRY
    //
    pIE = new IMSGENTRY;
    if(pIE == NULL) {
        hr = E_OUTOFMEMORY;
        ERROR_LOG("new ISMGENTRY");
        goto CLEANUP;
    }

    //
    // Figure out what interface we can QI with
    //
    if(ARG_pIUnknown) {
        pValidIMailMsgInterface = ARG_pIUnknown;
    } else if(ARG_pIMailMsgProperties) {
        pValidIMailMsgInterface = ARG_pIMailMsgProperties;
    } else if(ARG_pIMailMsgRecipients) {
        pValidIMailMsgInterface = ARG_pIMailMsgRecipients;
    } else {
        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    //
    // Get all the interfaces if necessary
    // Copy interface pointers and addref them if passed in
    // QI for interfaces not passed in
    // Here's a macro to do that:
    //

#define QI_IF_NECESSARY(ARG_pInterface, IID_Interface, ppDestInterface) \
    if(ARG_pInterface) { \
        (*(ppDestInterface)) = (ARG_pInterface); \
        (*(ppDestInterface))->AddRef(); \
    } else { \
        hr = pValidIMailMsgInterface->QueryInterface( \
            (IID_Interface), \
            (PVOID*)(ppDestInterface)); \
        if(FAILED(hr)) \
            goto CLEANUP; \
    }

    QI_IF_NECESSARY(ARG_pIUnknown, IID_IUnknown, &pIUnknown)
    QI_IF_NECESSARY(ARG_pIMailMsgProperties, IID_IMailMsgProperties, &pIMailMsgProperties)
    QI_IF_NECESSARY(ARG_pIMailMsgRecipients, IID_IMailMsgRecipients, &pIMailMsgRecipients)

    //
    // Set/create an IMailMsgRecipientsAdd
    //
    if(ARG_pIMailMsgRecipientsAdd) {
        pIMailMsgRecipientsAdd = ARG_pIMailMsgRecipientsAdd;
        pIMailMsgRecipientsAdd->AddRef();
    } else {
        hr = pIMailMsgRecipients->AllocNewList(&pIMailMsgRecipientsAdd);
        if(FAILED(hr)) {
            pIMailMsgRecipientsAdd = NULL;
            ERROR_LOG("pIMailMsgRecipients->AllocNewList");
            goto CLEANUP;
        }
    }
    //
    // Success!  Initialize pIE members
    //
    pIE->pIUnknown = pIUnknown;
    pIE->pIMailMsgProperties = pIMailMsgProperties;
    pIE->pIMailMsgRecipients = pIMailMsgRecipients;
    pIE->pIMailMsgRecipientsAdd = pIMailMsgRecipientsAdd;
    pIE->fBoundToStore = fBoundToStore;

    *ppIE = pIE;

 CLEANUP:
    if(FAILED(hr)) {
        //
        // Cleanup everything
        //
        if(pIE)
            delete pIE;
        if(pIUnknown)
            pIUnknown->Release();
        if(pIMailMsgProperties)
            pIMailMsgProperties->Release();
        if(pIMailMsgRecipients)
            pIMailMsgRecipients->Release();
        if(pIMailMsgRecipientsAdd)
            pIMailMsgRecipientsAdd->Release();
    }
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CreateAddIMsgEntry
//
// Synopsis: Creates/Adds an IMSGENTRY struct to the class list
//
// Arguments:
//   dwId: The Id to set on the list entry
//   ARG_pIUnknown: Optional Original IMsg IUnknown for this categorization
//   ARG_pIMailMsgProperties: Optional IMailMsgProperties interface to use
//   ARG_pIMailMsgRecipients: Optional IMailMsgRecipients to use
//   ARG_pIMailMsgRecipientsAdd: Optional IMailMsgRecipientsAdd to use
//   fBoundToStore: Wether or not the message is bound to a store backing
//
//  NOTE: One of pIUnknown/pIMailMsgProperties/pIMailMsgRecipients MUST be
//  provided
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/06/30 14:02:46: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::CreateAddIMsgEntry(
    DWORD dwId,
    IUnknown *pIUnknown,
    IMailMsgProperties *pIMailMsgProperties,
    IMailMsgRecipients *pIMailMsgRecipients,
    IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd,
    BOOL fBoundToStore)
{
    HRESULT hr = S_OK;
    PIMSGENTRY pIE;

    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::CreateAddIMsgEntry");
    
    hr = CreateIMsgEntry(
        &pIE, 
        pIUnknown, 
        pIMailMsgProperties,
        pIMailMsgRecipients,
        pIMailMsgRecipientsAdd,
        fBoundToStore);
    ERROR_CLEANUP_LOG("CreateIMsgEntry");

    pIE->dwId = dwId;
    InsertTailList(&m_listhead, &(pIE->listentry));
    m_dwNumIMsgs++;
    hr = S_OK;

 CLEANUP:
    return hr;
}


//+------------------------------------------------------------
//
// Function: Initialize
//
// Synopsis: Adds the first, original IMsg entry
//
// Arguments:
//  pIMsg: Original IMsg of categorization
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/06/30 14:05:37: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::Initialize(
    IUnknown *pIMsg)
{
    HRESULT hr = S_OK;

    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::Initialize");

    hr = CreateAddIMsgEntry(
        ICATEGORIZERMAILMSGS_DEFAULTIMSGID, 
        pIMsg,
        NULL,
        NULL,
        NULL,
        TRUE);
    ERROR_CLEANUP_LOG("CreateAddIMsgEntry");

 CLEANUP:
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: FindIMsgEntry
//
// Synopsis: Retrieves a PIMSGENTRY with the matching dwId
//
// Arguments:
//  dwId: Id to find
//
// Returns:
//  NULL: not found
//  else pointer to an IMSGENTRY
//
// History:
// jstamerj 1998/06/30 14:08:42: Created.
//
//-------------------------------------------------------------
CICategorizerMailMsgsIMP::PIMSGENTRY CICategorizerMailMsgsIMP::FindIMsgEntry(
    DWORD dwId)
{
    //
    // Traverse the list, look for our PIMSGEntry
    //
    PLIST_ENTRY ple;
    PIMSGENTRY pIE_Found = NULL;
    PIMSGENTRY pIE_Compare;

    for(ple = m_listhead.Flink; ple != &m_listhead; ple = ple->Flink) {
        pIE_Compare = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        if(pIE_Compare->dwId == dwId) {
            pIE_Found = pIE_Compare;
            break;
        }
    }
    return pIE_Found;
}


//+------------------------------------------------------------
//
// Function: GetDefaultIMsg
//
// Synopsis: Get the original messages IUnknown
//
// Arguments: NONE
//
// Returns:
//  Interface ptr
//
// History:
// jstamerj 1998/06/30 14:18:43: Created.
//
//-------------------------------------------------------------
IUnknown * CICategorizerMailMsgsIMP::GetDefaultIUnknown()
{
    PIMSGENTRY pIE;
    //
    // Unless Init failed, FindIMsgEntry should never fail
    //
    pIE = FindIMsgEntry(ICATEGORIZERMAILMSGS_DEFAULTIMSGID);
    _ASSERT(pIE);

    return pIE->pIUnknown;
}


//+------------------------------------------------------------
//
// Function: GetDefaultIMailMsgProperties
//
// Synopsis: Get the original messages IMailMsgProperties
//
// Arguments: NONE
//
// Returns:
//  Interface ptr
//
// History:
// jstamerj 1998/06/30 14:18:43: Created.
//
//-------------------------------------------------------------
IMailMsgProperties * CICategorizerMailMsgsIMP::GetDefaultIMailMsgProperties()
{
    PIMSGENTRY pIE;
    //
    // Unless Init failed, FindIMsgEntry should never fail
    //
    pIE = FindIMsgEntry(ICATEGORIZERMAILMSGS_DEFAULTIMSGID);
    _ASSERT(pIE);

    return pIE->pIMailMsgProperties;
}


//+------------------------------------------------------------
//
// Function: GetDefaultIMailMsgRecipients
//
// Synopsis: Get the original messages IMailMsgRecipients
//
// Arguments: NONE
//
// Returns:
//  Interface ptr
//
// History:
// jstamerj 1998/06/30 14:18:43: Created.
//
//-------------------------------------------------------------
IMailMsgRecipients * CICategorizerMailMsgsIMP::GetDefaultIMailMsgRecipients()
{
    PIMSGENTRY pIE;
    //
    // Unless Init failed, FindIMsgEntry should never fail
    //
    pIE = FindIMsgEntry(ICATEGORIZERMAILMSGS_DEFAULTIMSGID);
    _ASSERT(pIE);

    return pIE->pIMailMsgRecipients;
}


//+------------------------------------------------------------
//
// Function: GetDefaultIMailMsgRecipientsAdd
//
// Synopsis: Get the original messag's IMailMsgRecipientsAdd
//
// Arguments: NONE
//
// Returns:
//  Interface ptr
//
// History:
// jstamerj 1998/06/30 14:18:43: Created.
//
//-------------------------------------------------------------
IMailMsgRecipientsAdd * CICategorizerMailMsgsIMP::GetDefaultIMailMsgRecipientsAdd()
{
    PIMSGENTRY pIE;
    //
    // Unless Init failed, FindIMsgEntry should never fail
    //
    pIE = FindIMsgEntry(ICATEGORIZERMAILMSGS_DEFAULTIMSGID);
    _ASSERT(pIE);

    return pIE->pIMailMsgRecipientsAdd;
}


//+------------------------------------------------------------
//
// Function: WriteListAll
//
// Synopsis: Calls WriteList on all contained mailmsgs
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  Error from writelist
//
// History:
// jstamerj 1998/06/30 14:30:12: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::WriteListAll()
{
    HRESULT hr = S_OK;
    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    IMailMsgProperties *pIMailMsgProperties_Default;

    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::WriteListAll");

    pIMailMsgProperties_Default = GetDefaultIMailMsgProperties();
    //
    // First double check that all messages are bound to a store backing
    //
    for(ple = m_listhead.Flink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        if(! (pIE->fBoundToStore)) {

            hr = pIE->pIMailMsgProperties->RebindAfterFork(
                pIMailMsgProperties_Default,
                NULL); // Backing store -- use orignal store
            ERROR_CLEANUP_LOG("pIE->pIMailMsgProperties->RebindAfterFork");
            pIE->fBoundToStore = TRUE;
        }
    }

    //
    // Traverse the list backwards so that we touch the original IMsg last.
    //
    for(ple = m_listhead.Blink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Blink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        hr = pIE->pIMailMsgRecipients->WriteList(pIE->pIMailMsgRecipientsAdd);

        if(SUCCEEDED(hr)) {
            
            DWORD dwcRecips;
            //
            // If the resulting message has zero recipients, set the
            // message status to MP_STATUS_ABORT so that aqueue won't
            // throw it in badmail 
            //
            hr = pIE->pIMailMsgRecipients->Count(&dwcRecips);
            if(SUCCEEDED(hr)) {

                if(dwcRecips == 0) {
                
                    DebugTrace((LPARAM)this, "Deleting post-categorized message with 0 recips");
                    hr = pIE->pIMailMsgProperties->PutDWORD(
                        IMMPID_MP_MESSAGE_STATUS,
                        MP_STATUS_ABORT_DELIVERY);

                    if(SUCCEEDED(hr))
                        INCREMENT_COUNTER(MessagesAborted);
                    else {
                        ERROR_LOG("pIE->pIMailMsgProperties->PutDWORD");
                    }

                } else {
                    //
                    // Increment post-cat recip count
                    //
                    INCREMENT_COUNTER_AMOUNT(PostCatRecipients, dwcRecips);
                }
            } else {
                ERROR_LOG("pIE->pIMailMsgRecipients->Count(&dwcRecips)");
            }
        } else {
            ERROR_LOG("pIE->pIMailMsgRecipients->WriteList(pIE->pIMailMsgRecipientsAdd");
        }
    }
 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: RevertAll
//
// Synopsis: Release all IMailMsgRecipientsAdd thus reverting all messages to their original state
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 1998/06/30 14:40:22: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::RevertAll()
{
    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    for(ple = m_listhead.Flink; (ple != &m_listhead); ple = ple->Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        pIE->pIMailMsgRecipientsAdd->Release();
        pIE->pIMailMsgRecipientsAdd = NULL;
    }
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: GetAllIUnknowns
//
// Synopsis: Fills in a null terminated array of pointers to IMsgs
//           including our original IMsg and every IMsg we've bifurcated
//
// Arguments:
//   rgpIMsg pointer to array of IMsg pointers
//   cPtrs   size of rpgIMsg array in number of pointers
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER): Array size was not
//  large enough
//
// History:
// jstamerj 1998/06/30 14:43:30: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::GetAllIUnknowns(
    IUnknown **rgpIMsg,
    DWORD cPtrs)
{
    if(cPtrs <= m_dwNumIMsgs)
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    IUnknown **ppIUnknown = rgpIMsg;

    for(ple = m_listhead.Flink; (ple != &m_listhead); ple = ple->Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        *ppIUnknown = pIE->pIUnknown;
        ppIUnknown++;
    }
    *ppIUnknown = NULL;
    return S_OK;
}    


//+------------------------------------------------------------
//
// Function: GetMailMsg
//
// Synopsis: Retrieve interface pointers for a particular ID.
//           Bifurcate if necessary
//
// Arguments:
//  dwId: ID for the message you want
//  ppIMailMsgProperties: interface pointer to recieve
//  ppIMailMsgRecipientsAdd: interface pointer to recieve
//  pfCreated: Set to TRUE if just now bifurcated.  FALSE otherwise
//
// Returns:
//  S_OK: Success
//  error from mailmsg
//
// History:
// jstamerj 1998/06/30 15:12:41: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::GetMailMsg(
    IN  DWORD                   dwId,
    OUT IMailMsgProperties      **ppIMailMsgProperties,
    OUT IMailMsgRecipientsAdd   **ppIMailMsgRecipientsAdd,
    OUT BOOL                    *pfCreated)
{
    PIMSGENTRY pIE;

    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::GetMailMsg");

    _ASSERT(ppIMailMsgProperties);
    _ASSERT(ppIMailMsgRecipientsAdd);
    _ASSERT(pfCreated);
    //
    // If two threads come in here at the same time with the same
    // dwId, we only want to create one message (and set *pfCreated =
    // TRUE for one of the threads).  We accomplish this by searching
    // for an exsting message and creating the new message inside a
    // critical section.
    //
    EnterCriticalSection(&m_cs);
    //
    // Find an existing IMsg
    //
    pIE = FindIMsgEntry(dwId);
    if(pIE != NULL) {
        (*ppIMailMsgProperties) = pIE->pIMailMsgProperties;
        (*ppIMailMsgProperties)->AddRef();
        (*ppIMailMsgRecipientsAdd) = pIE->pIMailMsgRecipientsAdd;
        (*ppIMailMsgRecipientsAdd)->AddRef();
        *pfCreated = FALSE;
        LeaveCriticalSection(&m_cs);
        return S_OK;

    } else {
        HRESULT hr;
        //
        // Not found, so bifurcate/create a new message
        //
        IMailMsgProperties *pIMailMsgProperties_Default;
        IMailMsgProperties *pIMailMsgProperties_New;
        IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd_New;
        pIMailMsgProperties_Default = GetDefaultIMailMsgProperties();
        _ASSERT(pIMailMsgProperties_Default);

        //
        // Bifurcate
        //
        hr = pIMailMsgProperties_Default->ForkForRecipients(
            &pIMailMsgProperties_New,
            &pIMailMsgRecipientsAdd_New);

        if(SUCCEEDED(hr)) {

            INCREMENT_COUNTER(MessagesCreated);
            //
            // Save this bifurcated message
            //
            hr = CreateAddIMsgEntry(
                dwId,
                NULL,
                pIMailMsgProperties_New,
                NULL,
                pIMailMsgRecipientsAdd_New,
                FALSE); // not bound to store
            
            if(SUCCEEDED(hr)) {
                // Transfer our creation refcount to the caller
                (*ppIMailMsgProperties) = pIMailMsgProperties_New;
                (*ppIMailMsgRecipientsAdd) = pIMailMsgRecipientsAdd_New;
                *pfCreated = TRUE;

            } else {
                ERROR_LOG("CreateAddIMsgEntry");
                // Release our creation refcount - we're failing
                pIMailMsgProperties_New->Release();
                pIMailMsgRecipientsAdd_New->Release();
            }
        } else {

            ERROR_LOG("pIMailMsgProperties_Default->ForkForRecipients");;
        }
        LeaveCriticalSection(&m_cs);
        return hr;
    }
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::ReBindMailMsg
//
// Synopsis: Bind a message recieved via GetMailMsg to a store backing
//
// Arguments:
//  dwFlags: Flags passed into GetMailMsg
//  pStoreDriver: the store driver to bind it to
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
//  error from mailmsg
//
// History:
// jstamerj 1999/02/06 21:51:42: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerMailMsgsIMP::ReBindMailMsg(
    DWORD dwFlags,
    IUnknown *pStoreDriver)
{
    HRESULT hr;
    PIMSGENTRY pEntry;
    IMailMsgProperties *pIMailMsgProperties_Default;

    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::ReBindMailMsg");

    DebugTrace((LPARAM)this, "dwFlags: %08lx", dwFlags);

    pIMailMsgProperties_Default = GetDefaultIMailMsgProperties();

    //
    // Find our mailmsg
    //
    pEntry = FindIMsgEntry(dwFlags);
    if(pEntry == NULL) {
        
        ErrorTrace((LPARAM)this, "Did not find this bifid");
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        ERROR_LOG("FindIMsgEntry");
        goto CLEANUP;
    }
    
    _ASSERT(pEntry->fBoundToStore == FALSE);
    //
    // bind the message to a store driver
    //
    hr = pEntry->pIMailMsgProperties->RebindAfterFork(
        pIMailMsgProperties_Default,
        pStoreDriver);
    ERROR_CLEANUP_LOG("pEntry->pIMailMsgProperties->RebindAfterFork");

    pEntry->fBoundToStore = TRUE;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}
        


//+------------------------------------------------------------
//
// Function: SetMsgStatusAll
//
// Synopsis: Sets the message status property of all mailmsgs
//
// Arguments:
//  dwMsgStatus: Status to set
//
// Returns:
//  S_OK: Success
//  Error from mailmsg
//
// History:
// jstamerj 1998/06/30 14:30:12: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::SetMsgStatusAll(
    DWORD dwMsgStatus)
{
    //
    // Traverse the list backwards so that we touch the original IMsg last.
    //
    HRESULT hr = S_OK;
    PLIST_ENTRY ple;
    PIMSGENTRY pIE;

    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::SetMsgStatusAll");

    for(ple = m_listhead.Blink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Blink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        hr = pIE->pIMailMsgProperties->PutDWORD(
            IMMPID_MP_MESSAGE_STATUS,
            dwMsgStatus);
    }
    if(FAILED(hr)) {

        ERROR_LOG("pIE->pIMailMsgProperties->PutDWORD");
    }
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::BeginMailMsgEnumeration
//
// Synopsis: Initialize mailmsg enumerator
//
// Arguments:
//  penumerator: data to use to keep track of enumeration
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG: I'm not touching a null pointer
//
// History:
// jstamerj 1998/12/17 15:12:31: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerMailMsgsIMP::BeginMailMsgEnumeration(
    IN  PCATMAILMSG_ENUMERATOR penumerator)
{
    //  
    // Initialize the pvoid enumeator to our listhead
    //
    if(penumerator == NULL)
        return E_INVALIDARG;

    *penumerator = (CATMAILMSG_ENUMERATOR) &m_listhead;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::GetNextMailMsg
//
// Synopsis: Return info on the next mailmsg in an enumeration
//
// Arguments:
//  penumerator: enumerator initialized by BeginMailMsgEnumeration()
//  pdwFlags: to recieve the next mailmsg's flags
//  ppIMailMsgProperties: to recieve the next mailmsg's properties interface
//  ppIMailMsgRecipientsAdd: to recieve the next mailmsg's recip list interface
//
// Returns:
//  S_OK: Success
//  E_INVALIDARG
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//
// History:
// jstamerj 1998/12/17 15:15:29: Created.
//
//-------------------------------------------------------------
STDMETHODIMP CICategorizerMailMsgsIMP::GetNextMailMsg(
    IN  PCATMAILMSG_ENUMERATOR penumerator,
    OUT DWORD *pdwFlags,
    OUT IMailMsgProperties **ppIMailMsgProperties,
    OUT IMailMsgRecipientsAdd **ppIMailMsgRecipientsAdd)
{
    HRESULT hr;
    PIMSGENTRY pIE;

    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::GetNextMailMsg");

    _ASSERT(ppIMailMsgProperties);
    _ASSERT(ppIMailMsgRecipientsAdd);

    if(penumerator == NULL) {
        hr = E_INVALIDARG;
        goto CLEANUP;
    }
    
    pIE = (PIMSGENTRY) ((PLIST_ENTRY)(*penumerator))->Flink;

    if((PVOID)&m_listhead == (PVOID)pIE) {
        hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
        goto CLEANUP;
    }

    //  
    // AddRef and return pointers
    //
    (*ppIMailMsgProperties) = pIE->pIMailMsgProperties;
    (*ppIMailMsgProperties)->AddRef();
    (*ppIMailMsgRecipientsAdd) = pIE->pIMailMsgRecipientsAdd;
    (*ppIMailMsgRecipientsAdd)->AddRef();
    *pdwFlags = pIE->dwId;
    // remember our new position
    *penumerator = pIE;
    hr = S_OK;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::GetPerfBlock()
//
// Synopsis: Get the perf block for this virtual server
//
// Arguments: NONE
//
// Returns: Perf block pointer
//
// History:
// jstamerj 1999/02/24 18:38:07: Created.
//
//-------------------------------------------------------------
inline PCATPERFBLOCK CICategorizerMailMsgsIMP::GetPerfBlock()
{
    return m_pCICatListResolveIMP->GetPerfBlock();
}


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgs::HrPrepareForCompletion
//
// Synopsis: Call WriteList/SetMessageStatus/Commit on all messages
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  error from mailmsg
//
// History:
// jstamerj 1999/06/10 10:39:14: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerMailMsgsIMP::HrPrepareForCompletion()
{
    HRESULT hr = S_OK;
    PLIST_ENTRY ple;
    PIMSGENTRY pIE;
    IMailMsgProperties *pIMailMsgProperties_Default;
    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::HrPrepareForCompletion");

    pIMailMsgProperties_Default = GetDefaultIMailMsgProperties();
    //
    // First double check that all messages are bound to a store backing
    //
    for(ple = m_listhead.Flink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Flink) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        if(! (pIE->fBoundToStore)) {

            hr = pIE->pIMailMsgProperties->RebindAfterFork(
                pIMailMsgProperties_Default,
                NULL); // Backing store -- use orignal store
            ERROR_CLEANUP_LOG("pIE->pIMailMsgProperties->RebindAfterFork");
            pIE->fBoundToStore = TRUE;
        }
    }
    //
    // Traverse the list backwards so that we touch the original IMsg last.
    //
    // For each message, do the following:
    //  1) WriteList
    //  2) Set message status
    //  3) Commit (exception: not necessary for the original message)
    // 
    // If Commit fails, then delete all the bifurcated messages
    //
    for(ple = m_listhead.Blink; (ple != &m_listhead) && SUCCEEDED(hr); ple = ple->Blink) {

        DWORD dwcRecips;

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        hr = pIE->pIMailMsgRecipients->WriteList(pIE->pIMailMsgRecipientsAdd);
        ERROR_CLEANUP_LOG("pIE->pIMailMsgRecipients->WriteList");
        //
        // If the resulting message has zero recipients, set the
        // message status to MP_STATUS_ABORT so that aqueue won't
        // throw it in badmail 
        //
        hr = pIE->pIMailMsgRecipients->Count(&dwcRecips);
        ERROR_CLEANUP_LOG("pIE->pIMailMsgRecipients->Count");

        if(dwcRecips == 0) {
                
            DebugTrace((LPARAM)this, "Deleting post-categorized message with 0 recips");
            hr = pIE->pIMailMsgProperties->PutDWORD(
                IMMPID_MP_MESSAGE_STATUS,
                MP_STATUS_ABORT_DELIVERY);
            ERROR_CLEANUP_LOG("pIE->pIMailMsgProperties->PutDWORD(IMMPID_MP_MESSAGE_STATUS) - 0");

            INCREMENT_COUNTER(MessagesAborted);
            //
            // Do no bother to commit messages with zero recipients
            // (after all, who cares if a zero recipient message gets
            // lost?) 
            //

        } else {
            //
            // Increment post-cat recip count
            //
            INCREMENT_COUNTER_AMOUNT(PostCatRecipients, dwcRecips);
            //
            // Set the message status to Categorized
            //
            hr = pIE->pIMailMsgProperties->PutDWORD(
                IMMPID_MP_MESSAGE_STATUS,
                MP_STATUS_CATEGORIZED);
            ERROR_CLEANUP_LOG("pIE->pIMailMsgProperties->PutDWORD(IMMPID_MP_MESSAGE_STATUS) - 1");
            //
            // We must commit all bifurcated messages to prevent
            // loosing mail
            //
            if(pIE->dwId != 0) {

                hr = pIE->pIMailMsgProperties->Commit(NULL);

                if (hr == E_FAIL) hr = CAT_E_RETRY;

                ERROR_CLEANUP_LOG("pIE->pIMailMsgProperties->Commit");
            }
        }
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    CatFunctLeaveEx((LPARAM)this);
    return hr;
} // CICategorizerMailMsgsIMP::HrPrepareForCompletion


//+------------------------------------------------------------
//
// Function: CICategorizerMailMsgsIMP::DeleteBifurcatedMessages
//
// Synopsis: Calls delete on all mailmsgs (except original mailmsg)
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 2000/07/23 20:45:52: Created.
//
//-------------------------------------------------------------
VOID CICategorizerMailMsgsIMP::DeleteBifurcatedMessages()
{
    PLIST_ENTRY ple = NULL;
    PLIST_ENTRY ple_next = NULL;
    PIMSGENTRY pIE = NULL;
    CatFunctEnterEx((LPARAM)this, "CICategorizerMailMsgsIMP::DeleteBifurcatedMessages");

    EnterCriticalSection(&m_cs);

    for(ple = m_listhead.Flink; (ple != &m_listhead); ple = ple_next) {

        pIE = CONTAINING_RECORD(ple, IMSGENTRY, listentry);
        ple_next = ple->Flink;
        //
        // Delete all messages except for the original message (ID == 0)
        //
        if(pIE->dwId != 0) {
            HRESULT hrDelete;
            IMailMsgQueueMgmt *pMsgQueueMgmt = NULL;
                
            hrDelete = pIE->pIMailMsgProperties->QueryInterface(
                IID_IMailMsgQueueMgmt,
                (LPVOID *)&pMsgQueueMgmt);
            if(SUCCEEDED(hrDelete)) {
                hrDelete = pMsgQueueMgmt->Delete(NULL);
                if(FAILED(hrDelete))
                {
                    HRESULT hr = hrDelete;
                    ErrorTrace((LPARAM)this, "Delete failed hr %08lx", hrDelete);
                    ERROR_LOG("pMsgQueueMgmt->Delete");
                }
                //
                // If delete fails, there is nothing we can do about it.
                //
                pMsgQueueMgmt->Release();
                pMsgQueueMgmt = NULL;
            } else {
                HRESULT hr = hrDelete;
                ErrorTrace((LPARAM)this, "QI for IMailMsgQueueMgmt failed hr %08lx", hrDelete);
                ERROR_LOG("pIE->pIMailMsgProperties->QueryInterface(IID_IMailMsgQueueMgmt)");
            }

            if(pIE->pIUnknown)
                pIE->pIUnknown->Release();
            if(pIE->pIMailMsgProperties)
                pIE->pIMailMsgProperties->Release();
            if(pIE->pIMailMsgRecipients)
                pIE->pIMailMsgRecipients->Release();
            if(pIE->pIMailMsgRecipientsAdd)
                pIE->pIMailMsgRecipientsAdd->Release();

            RemoveEntryList(ple);
            delete pIE;
        }
    }

    LeaveCriticalSection(&m_cs);

    CatFunctLeaveEx((LPARAM)this);
} // CICategorizerMailMsgsIMP::DeleteBifurcatedMessages


//+------------------------------------------------------------
//
// Function: GetISMTPServerEx
//
// Synopsis: Gets the ISMTPServerEx interface
//
// Arguments: None
//
// Returns:
//  Pointer to ISMTPServerEx interface, OR
//  NULL if unavailable
//
// History:
// jstamerj 2001/12/11 01:02:15: Created.
//
//-------------------------------------------------------------
ISMTPServerEx * CICategorizerMailMsgsIMP::GetISMTPServerEx()
{
    return m_pCICatListResolveIMP->GetISMTPServerEx();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\precomp.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: precomp.cpp
//
//  Description:  Precompiled CPP for phatq\cat\src
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\icatprops.cpp ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: icatitem.cpp
//
// Contents: Implementation of CICategorizerPropertiesIMP
//
// Classes: CICategorizerPropertiesIMP
//
// Functions:
//
// History:
// jstamerj 980515 12:42:59: Created.
//
//-------------------------------------------------------------
#include "precomp.h"
#include "icatitem.h"


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::operator new
//
// Synopsis: Allocate memory for this and all the propIds contiguously
//
// Arguments:
//  size: Normal size of object
//  dwNumProps: Number of props desired in this object
//
// Returns: ptr to allocated memory or NULL
//
// History:
// jstamerj 1998/06/25 21:11:12: Created.
//
//-------------------------------------------------------------
void * CICategorizerPropertiesIMP::operator new(
    size_t size,
    DWORD dwNumProps)
{
    size_t cbSize;
    CICategorizerPropertiesIMP *pCICatItem;

    //
    // Calcualte size in bytes required
    //
    cbSize = size + (dwNumProps*sizeof(PROPERTY));

    pCICatItem = (CICategorizerPropertiesIMP *) new BYTE[cbSize];

    if(pCICatItem == NULL)
        return NULL;

    //
    // Set some member data in this catitem
    //
    pCICatItem->m_dwSignature = CICATEGORIZERPROPSIMP_SIGNATURE;
    pCICatItem->m_dwNumPropIds = dwNumProps;
    pCICatItem->m_rgProperties = (PPROPERTY) ((PBYTE)pCICatItem + size);
    return pCICatItem;
}


//+------------------------------------------------------------
//
// Function:  CICategorizerPropertiesIMP::CICategorizerPropertiesIMP
//
// Synopsis: Set initial values of member data
//
// Arguments:
//  pIUnknown: back pointer to use for QI
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 18:26:07: Created.
//
//-------------------------------------------------------------
CICategorizerPropertiesIMP::CICategorizerPropertiesIMP(
    IUnknown *pIUnknown)
{
    // Make sure we were created with our custom new operator
    _ASSERT(m_dwSignature == CICATEGORIZERPROPSIMP_SIGNATURE &&
            "PLEASE USE MY CUSTOM NEW OPERATOR!");

    _ASSERT(pIUnknown);

    m_pIUnknown = pIUnknown;

    // Initialize property data
    _VERIFY(SUCCEEDED(Initialize()));
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::~CICategorizerPropertiesIMP
//
// Synopsis: Release all of our data
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 20:15:14: Created.
//
//-------------------------------------------------------------
CICategorizerPropertiesIMP::~CICategorizerPropertiesIMP()
{
    _ASSERT(m_dwSignature == CICATEGORIZERPROPSIMP_SIGNATURE);
    m_dwSignature = CICATEGORIZERPROPSIMP_SIGNATURE_FREE;

    if(m_rgProperties) {
        for(DWORD dwIdx = 0; dwIdx < m_dwNumPropIds; dwIdx++) {
            UnSetPropId(dwIdx);
        }
    }
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::Initialize
//
// Synopsis: Initialize member property data
//
// Arguments: NONE
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 1998/06/20 18:31:21: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::Initialize()
{
    if(m_dwNumPropIds) {
        //
        // Initialize all propstatus to PROPSTATUS_UNSET
        //
        _ASSERT(PROPSTATUS_UNSET == 0);
        ZeroMemory(m_rgProperties, m_dwNumPropIds * sizeof(PROPERTY));
    }
    return S_OK;
}



//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetStringA
//
// Synopsis: Retrieves a string property
//
// Arguments:
//   
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//
// History:
// jstamerj 1998/06/20 18:38:15: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetStringA(
    DWORD dwPropId,
    DWORD cch,
    LPSTR pszValue)
{
    _ASSERT(pszValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_STRINGA) {
        return CAT_E_PROPNOTFOUND;
    }
    if(((DWORD)lstrlenA(m_rgProperties[dwPropId].PropValue.pszValue)) >= cch) {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    lstrcpy(pszValue, m_rgProperties[dwPropId].PropValue.pszValue);
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetStringAPtr
//
// Synopsis: Retrieves a pointer to the internal string attribute.
//           Note this memory will be free'd the next time this propID
//           is set or when all references to ICatItem are released
//
// Arguments:
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//
// History:
// jstamerj 1998/07/01 10:39:40: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetStringAPtr(
    DWORD dwPropId,
    LPSTR *ppsz)
{
    _ASSERT(ppsz);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_STRINGA) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppsz = m_rgProperties[dwPropId].PropValue.pszValue;
    return S_OK;
}    



//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutStringA
//
// Synopsis: Copies string buffer and sets property
//
// Arguments:
//   dwPropId: Property to set
//   pszValue: String to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 18:59:13: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutStringA(
    DWORD dwPropId,
    LPSTR pszValue)
{
    LPSTR pszCopy;

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    pszCopy = m_strdup(pszValue);

    if(pszCopy == NULL)
        return E_OUTOFMEMORY;

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_STRINGA;
    m_rgProperties[dwPropId].PropValue.pszValue = pszCopy;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetDWORD
//
// Synopsis:
//   Retrieve a DWORD property
//
// Arguments:
//   dwPropId: propId to retrieve
//   pdwValue: out parameter
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:14:20: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetDWORD(
    DWORD dwPropId,
    DWORD *pdwValue)
{
    _ASSERT(pdwValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_DWORD) {
        return CAT_E_PROPNOTFOUND;
    }
    *pdwValue = m_rgProperties[dwPropId].PropValue.dwValue;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutDWORD
//
// Synopsis: Set a dword property
//
// Arguments:
//   dwPropId: prop to set
//   dwValue:  value to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:18:50: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutDWORD(
    DWORD dwPropId,
    DWORD dwValue)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_DWORD;
    m_rgProperties[dwPropId].PropValue.dwValue = dwValue;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetHRESULT
//
// Synopsis:
//   Retrieve a HRESULT property
//
// Arguments:
//   dwPropId: propId to retrieve
//   pdwValue: out parameter
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:14:20: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetHRESULT(
    DWORD dwPropId,
    HRESULT *pdwValue)
{
    _ASSERT(pdwValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_HRESULT) {
        return CAT_E_PROPNOTFOUND;
    }
    *pdwValue = m_rgProperties[dwPropId].PropValue.dwValue;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutHRESULT
//
// Synopsis: Set a HRESULT property
//
// Arguments:
//   dwPropId: prop to set
//   dwValue:  value to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:18:50: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutHRESULT(
    DWORD dwPropId,
    HRESULT dwValue)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_HRESULT;
    m_rgProperties[dwPropId].PropValue.dwValue = dwValue;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetBool
//
// Synopsis: Retrieves a boolean property
//
// Arguments:
//   dwPropId: propID to retrieve
//   pfValue: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:22:28: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetBool(
    DWORD dwPropId,
    BOOL  *pfValue)
{
    _ASSERT(pfValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_BOOL) {
        return CAT_E_PROPNOTFOUND;
    }
    *pfValue = m_rgProperties[dwPropId].PropValue.fValue;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutBool
//
// Synopsis: Sets a boolean property
//
// Arguments:
//   dwPropId: property id to set
//   fValue: value of boolean to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutBool(
    DWORD dwPropId,
    BOOL  fValue)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_BOOL;
    m_rgProperties[dwPropId].PropValue.fValue = fValue;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetPVoid
//
// Synopsis: Retrieve a pvoid property
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppValue: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetPVoid(
    DWORD dwPropId,
    PVOID *ppValue)
{
    _ASSERT(ppValue);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_PVOID) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppValue = m_rgProperties[dwPropId].PropValue.pvValue;
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutPVoid
//
// Synopsis: Sets a boolean property
//
// Arguments:
//   dwPropId: property id to set
//   pvValue: prop value to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutPVoid(
    DWORD dwPropId,
    PVOID pvValue)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_PVOID;
    m_rgProperties[dwPropId].PropValue.pvValue = pvValue;
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetIUnknown
//
// Synopsis: Retrieve an IUnknown property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppUnknown: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetIUnknown(
    DWORD dwPropId,
    IUnknown  **ppUnknown)
{
    _ASSERT(ppUnknown);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_IUNKNOWN) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppUnknown = m_rgProperties[dwPropId].PropValue.pIUnknownValue;
    (*ppUnknown)->AddRef();
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutIUnknown
//
// Synopsis: Sets an IUnknown property
//
// Arguments:
//   dwPropId: property id to set
//   pUnknown: IUnknown to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutIUnknown(
    DWORD dwPropId,
    IUnknown *pUnknown)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_IUNKNOWN;
    m_rgProperties[dwPropId].PropValue.pIUnknownValue = pUnknown;

    //
    // Hold a reference to this IUnknown
    //
    pUnknown->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetIMailMsgProperties
//
// Synopsis: Retrieve an IMailMsgProperties property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppIMsg: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetIMailMsgProperties(
    DWORD dwPropId,
    IMailMsgProperties  **ppIMailMsgProperties)
{
    _ASSERT(ppIMailMsgProperties);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_IMAILMSGPROPERTIES) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppIMailMsgProperties = m_rgProperties[dwPropId].PropValue.pIMailMsgPropertiesValue;
    (*ppIMailMsgProperties)->AddRef();
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutIMailMsgProperties
//
// Synopsis: Sets an IMailMsgProperties property
//
// Arguments:
//   dwPropId: property id to set
//   pIMsg: IMailMsgProperties to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutIMailMsgProperties(
    DWORD dwPropId,
    IMailMsgProperties *pIMailMsgProperties)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_IMAILMSGPROPERTIES;
    m_rgProperties[dwPropId].PropValue.pIMailMsgPropertiesValue = pIMailMsgProperties;

    //
    // Hold a reference to this IUnknown
    //
    pIMailMsgProperties->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetIMailMsgRecipientsAdd
//
// Synopsis: Retrieve an IMailMsgReceipientsAdd property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppIMailMsgRecipientsAdd: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetIMailMsgRecipientsAdd(
    DWORD dwPropId,
    IMailMsgRecipientsAdd  **ppIMailMsgRecipientsAdd)
{
    _ASSERT(ppIMailMsgRecipientsAdd);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_IMAILMSGRECIPIENTSADD) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppIMailMsgRecipientsAdd = m_rgProperties[dwPropId].PropValue.pIMailMsgRecipientsAddValue;
    (*ppIMailMsgRecipientsAdd)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutIMailMsgRecipientsAdd
//
// Synopsis: Sets an IMailMsgRecipientsAdd property
//
// Arguments:
//   dwPropId: property id to set
//   pIMailMsgRecipientsAdd: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutIMailMsgRecipientsAdd(
    DWORD dwPropId,
    IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_IMAILMSGRECIPIENTSADD;
    m_rgProperties[dwPropId].PropValue.pIMailMsgRecipientsAddValue = pIMailMsgRecipientsAdd;

    //
    // Hold a reference to this interface
    //
    pIMailMsgRecipientsAdd->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetICategorizerListResolve
//
// Synopsis: Retrieve an IMailMsgReceipientsAdd property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppICategorizerListResolve: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetICategorizerListResolve(
    DWORD dwPropId,
    ICategorizerListResolve  **ppICategorizerListResolve)
{
    _ASSERT(ppICategorizerListResolve);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_ICATEGORIZERLISTRESOLVE) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppICategorizerListResolve = m_rgProperties[dwPropId].PropValue.pICategorizerListResolveValue;
    (*ppICategorizerListResolve)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutICategorizerListResolve
//
// Synopsis: Sets an ICategorizerListResolve property
//
// Arguments:
//   dwPropId: property id to set
//   pICategorizerListResolve: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutICategorizerListResolve(
    DWORD dwPropId,
    ICategorizerListResolve *pICategorizerListResolve)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_ICATEGORIZERLISTRESOLVE;
    m_rgProperties[dwPropId].PropValue.pICategorizerListResolveValue = pICategorizerListResolve;

    //
    // Hold a reference to this interface
    //
    pICategorizerListResolve->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetICategorizerItemAttributes
//
// Synopsis: Retrieve an IMailMsgReceipientsAdd property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppICategorizerItemAttributes: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetICategorizerItemAttributes(
    DWORD dwPropId,
    ICategorizerItemAttributes  **ppICategorizerItemAttributes)
{
    _ASSERT(ppICategorizerItemAttributes);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_ICATEGORIZERITEMATTRIBUTES) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppICategorizerItemAttributes = m_rgProperties[dwPropId].PropValue.pICategorizerItemAttributesValue;
    (*ppICategorizerItemAttributes)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutICategorizerItemAttributes
//
// Synopsis: Sets an ICategorizerItemAttributes property
//
// Arguments:
//   dwPropId: property id to set
//   pICategorizerItemAttributes: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutICategorizerItemAttributes(
    DWORD dwPropId,
    ICategorizerItemAttributes *pICategorizerItemAttributes)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_ICATEGORIZERITEMATTRIBUTES;
    m_rgProperties[dwPropId].PropValue.pICategorizerItemAttributesValue = pICategorizerItemAttributes;

    //
    // Hold a reference to this interface
    //
    pICategorizerItemAttributes->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetICategorizerMailMsgs
//
// Synopsis: Retrieve an IMailMsgReceipientsAdd property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppICategorizerMailMsgs: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetICategorizerMailMsgs(
    DWORD dwPropId,
    ICategorizerMailMsgs  **ppICategorizerMailMsgs)
{
    _ASSERT(ppICategorizerMailMsgs);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_ICATEGORIZERMAILMSGS) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppICategorizerMailMsgs = m_rgProperties[dwPropId].PropValue.pICategorizerMailMsgsValue;
    (*ppICategorizerMailMsgs)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutICategorizerMailMsgs
//
// Synopsis: Sets an ICategorizerMailMsgs property
//
// Arguments:
//   dwPropId: property id to set
//   pICategorizerMailMsgs: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutICategorizerMailMsgs(
    DWORD dwPropId,
    ICategorizerMailMsgs *pICategorizerMailMsgs)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_ICATEGORIZERMAILMSGS;
    m_rgProperties[dwPropId].PropValue.pICategorizerMailMsgsValue = pICategorizerMailMsgs;

    //
    // Hold a reference to this interface
    //
    pICategorizerMailMsgs->AddRef();
    
    return S_OK;
}


//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::GetICategorizerItem
//
// Synopsis: Retrieve an ICategorizerItem property.  Does an AddRef() for the caller
//
// Arguments:
//   dwPropId: propID to retrieve
//   ppICategorizerItem: value to fill in
//
// Returns:
//  S_OK: Success
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 20:01:03: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::GetICategorizerItem(
    DWORD dwPropId,
    ICategorizerItem  **ppICategorizerItem)
{
    _ASSERT(ppICategorizerItem);

    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }
    if(m_rgProperties[dwPropId].PropStatus != PROPSTATUS_SET_ICATEGORIZERITEM) {
        return CAT_E_PROPNOTFOUND;
    }
    *ppICategorizerItem = m_rgProperties[dwPropId].PropValue.pICategorizerItemValue;
    (*ppICategorizerItem)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::PutICategorizerItem
//
// Synopsis: Sets an ICategorizerItem property
//
// Arguments:
//   dwPropId: property id to set
//   pICategorizerItem: interface to set
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//  CAT_E_PROPNOTFOUND
//
// History:
// jstamerj 1998/06/20 19:24:32: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::PutICategorizerItem(
    DWORD dwPropId,
    ICategorizerItem *pICategorizerItem)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    //
    // Release old property value, if any
    //
    UnSetPropId(dwPropId);
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_SET_ICATEGORIZERITEM;
    m_rgProperties[dwPropId].PropValue.pICategorizerItemValue = pICategorizerItem;

    //
    // Hold a reference to this interface
    //
    pICategorizerItem->AddRef();
    
    return S_OK;
}

//+------------------------------------------------------------
//
// Function: CICategorizerPropertiesIMP::UnsetPropId
//
// Synopsis: Release the propId if allocated
//
// Arguments:
//   dwPropId: Property to release
//
// Returns: NOTHING
//
// History:
// jstamerj 1998/06/20 19:10:30: Created.
//
//-------------------------------------------------------------
HRESULT CICategorizerPropertiesIMP::UnSetPropId(
    DWORD dwPropId)
{
    if(dwPropId >= m_dwNumPropIds) {
        return CAT_E_PROPNOTFOUND;
    }

    switch(m_rgProperties[dwPropId].PropStatus) {
     default:
         //
         // Do nothing
         //
         break;

     case PROPSTATUS_SET_STRINGA:
         //
         // Free the string
         //
         delete m_rgProperties[dwPropId].PropValue.pszValue;
         break;
         
     case PROPSTATUS_SET_IUNKNOWN:
     case PROPSTATUS_SET_IMAILMSGPROPERTIES:
     case PROPSTATUS_SET_IMAILMSGRECIPIENTSADD:
     case PROPSTATUS_SET_ICATEGORIZERITEMATTRIBUTES:
     case PROPSTATUS_SET_ICATEGORIZERLISTRESOLVE:
     case PROPSTATUS_SET_ICATEGORIZERMAILMSGS:
     case PROPSTATUS_SET_ICATEGORIZERITEM:
         //
         // Release the interface
         //
         (m_rgProperties[dwPropId].PropValue.pIUnknownValue)->Release();
         break;
    }
    m_rgProperties[dwPropId].PropStatus = PROPSTATUS_UNSET;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\precomp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: precomp.h
//
//  Description:  Precompiled header for phatq\cat\src
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Moved to transmt
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQ_PRECOMP_H__
#define __AQ_PRECOMP_H__

//Includes from external directories
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <listmacr.h>
#include <dbgtrace.h>
#include "aqinit.h"
#include "spinlock.h"
#include <lmcons.h>
#include <dsgetdc.h>
#include <lmapibuf.h>
#include <time.h>
#include "caterr.h"
#include <rwex.h>
#include "smtpevent.h"
#include <transmem.h>
#include <winldap.h>
#include <perfcat.h>
#include <catperf.h>
#include <cpool.h>
#include <mailmsgprops.h>
#include <phatqmsg.h>
#include <mailmsg.h>
#include <phatqcat.h>

//Local includes
#include "CodePageConvert.h"
#ifdef PLATINUM
#include <ptntintf.h>
#include <ptntdefs.h>
#define AQ_MODULE_NAME "phatq"
#else //not PLATINUM
#define AQ_MODULE_NAME "aqueue"
#endif //PLATINUM
#include "catdebug.h"
#include "cat.h"
#include "ccat.h"
#include "ccatfn.h"
#include "address.h"
#include "catconfig.h"
#include "propstr.h"
#include "catglobals.h"
#include "ccataddr.h"
#include "ccatsender.h"
#include "ccatrecip.h"
#include "idstore.h"
#include <smtpseo.h>
#include "icatlistresolve.h"
#include "catdefs.h"
#include "catutil.h"

//Wrappers for transmem macros
#include <aqmem.h>
#endif //__AQ_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\registry.cpp ===
//+------------------------------------------------------------
//
// File: registry.cpp -- copied from "Inside COM" by Dale Rogerson
//       Chapter 7 sample code, a Microsoft Press book.
//
// History:
// jstamerj 1998/12/12 23:25:11: Copied.
//
//-------------------------------------------------------------


#include "precomp.h"
#include <objbase.h>
#include <assert.h>

#include "Registry.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const char* pszPath,
                    const char* szSubkey,
                    const char* szValue,
                    const char* szName = NULL) ;

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 char* szCLSID,
                 int length) ;

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const char* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const char* szFriendlyName, // Friendly Name
                       const char* szVerIndProgID, // Programmatic
                       const char* szProgID)       //   IDs
{
	// Get server location.
	char szModule[512] ;
	DWORD dwResult =
		::GetModuleFileName(hModule, 
		                    szModule,
		                    sizeof(szModule)/sizeof(char)) ;
	assert(dwResult != 0) ;

	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;
  
	// Add the CLSID to the registry.
	setKeyAndValue(szKey, NULL, szFriendlyName) ;

	// Add the server filename subkey under the CLSID key.
	setKeyAndValue(szKey, "InprocServer32", szModule) ;

	// Add the ProgID subkey under the CLSID key.
	setKeyAndValue(szKey, "ProgID", szProgID) ;

	// Add the version-independent ProgID subkey under CLSID key.
	setKeyAndValue(szKey, "VersionIndependentProgID",
	               szVerIndProgID) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, "InprocServer32", "Free", "ThreadingModel") ;

	// Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szVerIndProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szVerIndProgID, "CLSID", szCLSID) ;
	setKeyAndValue(szVerIndProgID, "CurVer", szProgID) ;

	// Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
	setKeyAndValue(szProgID, NULL, szFriendlyName) ; 
	setKeyAndValue(szProgID, "CLSID", szCLSID) ;

	return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid,         // Class ID
                      const char* szVerIndProgID, // Programmatic
                      const char* szProgID)       //   IDs
{
	// Convert the CLSID into a char.
	char szCLSID[CLSID_STRING_SIZE] ;
	CLSIDtochar(clsid, szCLSID, sizeof(szCLSID)) ;

	// Build the key CLSID\\{...}
	char szKey[64] ;
	strcpy(szKey, "CLSID\\") ;
	strcat(szKey, szCLSID) ;

	// Delete the CLSID Key - CLSID\{...}
	LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the version-independent ProgID Key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	// Delete the ProgID key.
	lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
	assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Internal helper functions
//

// Convert a CLSID to a char string.
void CLSIDtochar(const CLSID& clsid,
                 char* szCLSID,
                 int length)
{
	assert(length >= CLSID_STRING_SIZE) ;
	// Get CLSID
	LPOLESTR wszCLSID = NULL ;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
	assert(SUCCEEDED(hr)) ;

	// Covert from wide characters to non-wide.
	wcstombs(szCLSID, wszCLSID, length) ;

	// Free memory.
	CoTaskMemFree(wszCLSID) ;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const char* lpszKeyChild)  // Key to delete
{
	// Open the child.
	HKEY hKeyChild ;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
	                         KEY_ALL_ACCESS, &hKeyChild) ;
	if (lRes != ERROR_SUCCESS)
	{
		return lRes ;
	}

	// Enumerate all of the decendents of this child.
	FILETIME time ;
	char szBuffer[256] ;
	DWORD dwSize = 256 ;
	while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
	                    NULL, NULL, &time) == S_OK)
	{
		// Delete the decendents of this child.
		lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
		if (lRes != ERROR_SUCCESS)
		{
			// Cleanup before exiting.
			RegCloseKey(hKeyChild) ;
			return lRes;
		}
		dwSize = 256 ;
	}

	// Close the child.
	RegCloseKey(hKeyChild) ;

	// Delete this child.
	return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const char* szKey,
                    const char* szSubkey,
                    const char* szValue,
                    const char* szName)
{
	HKEY hKey;
	char szKeyBuf[1024] ;

	// Copy keyname into buffer.
	strcpy(szKeyBuf, szKey) ;

	// Add subkey name to buffer.
	if (szSubkey != NULL)
	{
		strcat(szKeyBuf, "\\") ;
		strcat(szKeyBuf, szSubkey ) ;
	}

	// Create and open key and subkey.
	long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
	                              szKeyBuf, 
	                              0, NULL, REG_OPTION_NON_VOLATILE,
	                              KEY_ALL_ACCESS, NULL, 
	                              &hKey, NULL) ;
	if (lResult != ERROR_SUCCESS)
	{
		return FALSE ;
	}

	// Set the Value.
	if (szValue != NULL)
	{
		RegSetValueEx(hKey, szName, 0, REG_SZ, 
		              (BYTE *)szValue, 
		              strlen(szValue)+1) ;
	}

	RegCloseKey(hKey) ;
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\cpropbag.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    cpropbag.h

Abstract:

    This module contains the definition of the 
    generic property bag class

Author:

    Keith Lau   (keithlau@microsoft.com)

Revision History:

    keithlau    06/30/98    created
    jstamerj    12/07/00    Copied source for use in dsnsink

--*/

#ifndef _CPROPBAG_H_
#define _CPROPBAG_H_


#include "filehc.h"
#include "mailmsg.h"
#include "cmmtypes.h"


/***************************************************************************/
// Definitions
//

#define GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID     ((DWORD)'PTGv')


/***************************************************************************/
// CMailMsgPropertyBag
//

class CMailMsgPropertyBag : 
    public IMailMsgPropertyBag
{
  public:

    CMailMsgPropertyBag() :
        m_bmBlockManager(NULL),
        m_ptProperties(
            PTT_PROPERTY_TABLE,
            GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID,
            &m_bmBlockManager,
            &m_InstanceInfo,
            CompareProperty,
            NULL,
            NULL
        )
    {
        m_lRefCount = 1;

        // Copy the default instance into our instance
        MoveMemory(
                &m_InstanceInfo, 
                &s_DefaultInstanceInfo, 
                sizeof(PROPERTY_TABLE_INSTANCE));
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
            if (riid == IID_IUnknown)
                *ppvObj = (IUnknown *)(IMailMsgPropertyBag *)this;
            else if (riid == IID_IMailMsgPropertyBag)
                *ppvObj = (IMailMsgPropertyBag *)this;
            else if (riid == IID_IMailMsgRegisterCleanupCallback)
                *ppvObj = (IMailMsgRegisterCleanupCallback *)this;
            else
                return(E_NOINTERFACE);
            AddRef();
            return(S_OK);
    }

    unsigned long STDMETHODCALLTYPE AddRef() 
    {
        return(InterlockedIncrement(&m_lRefCount));
    }

    unsigned long STDMETHODCALLTYPE Release() 
    {
        LONG    lTemp = InterlockedDecrement(&m_lRefCount);
        if (!lTemp)
        {
            // Extra releases are bad!
            _ASSERT(lTemp);
        }
        return(lTemp);
    }

    HRESULT STDMETHODCALLTYPE PutProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                LPBYTE  pbValue
                )
    {
        GLOBAL_PROPERTY_ITEM    piItem;
        piItem.idProp = dwPropID;
        return(m_ptProperties.PutProperty(
                        (LPVOID)&dwPropID,
                        (LPPROPERTY_ITEM)&piItem,
                        cbLength,
                        pbValue));
    }

    HRESULT STDMETHODCALLTYPE GetProperty(
                DWORD   dwPropID,
                DWORD   cbLength,
                DWORD   *pcbLength,
                LPBYTE  pbValue
                )
    {
        GLOBAL_PROPERTY_ITEM    piItem;
        return(m_ptProperties.GetPropertyItemAndValue(
                                (LPVOID)&dwPropID,
                                (LPPROPERTY_ITEM)&piItem,
                                cbLength,
                                pcbLength,
                                pbValue));
    }

    HRESULT STDMETHODCALLTYPE PutStringA(
                DWORD   dwPropID,
                LPCSTR  pszValue
                ) 
    {
        return(PutProperty(dwPropID, pszValue?strlen(pszValue)+1:0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringA(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPSTR   pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength, &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutStringW(
                DWORD   dwPropID,
                LPCWSTR pszValue
                )
    {
        return(PutProperty(dwPropID, pszValue?(wcslen(pszValue)+1)*sizeof(WCHAR):0, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetStringW(
                DWORD   dwPropID,
                DWORD   cchLength,
                LPWSTR  pszValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, cchLength*sizeof(WCHAR), &dwLength, (LPBYTE)pszValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutDWORD(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetDWORD(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        DWORD dwLength;
        return(GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue));
    }
    
    HRESULT STDMETHODCALLTYPE PutBool(
                DWORD   dwPropID,
                DWORD   dwValue
                )
    {
        dwValue = dwValue ? 1 : 0;
        return(PutProperty(dwPropID, sizeof(DWORD), (LPBYTE)&dwValue));
    }
    
    HRESULT STDMETHODCALLTYPE GetBool(
                DWORD   dwPropID,
                DWORD   *pdwValue
                )
    {
        HRESULT hrRes;
        DWORD dwLength;

        hrRes = GetProperty(dwPropID, sizeof(DWORD), &dwLength, (LPBYTE)pdwValue);
        if (pdwValue)
            *pdwValue = *pdwValue ? 1 : 0;
        return (hrRes);
    }

  private:

    // The specific compare function for this type of property table
    static HRESULT CompareProperty(
                LPVOID          pvPropKey,
                LPPROPERTY_ITEM pItem
                );

  private:

    // Usage count
    LONG                            m_lRefCount;

    // Property table instance
    PROPERTY_TABLE_INSTANCE         m_InstanceInfo;
    static PROPERTY_TABLE_INSTANCE  s_DefaultInstanceInfo;

    // IMailMsgProperties is an instance of CPropertyTable
    CPropertyTable                  m_ptProperties;

    // An instance of the block memory manager 
    CBlockManager                   m_bmBlockManager;

};

// =================================================================
// Compare function
//

inline HRESULT CMailMsgPropertyBag::CompareProperty(
            LPVOID          pvPropKey,
            LPPROPERTY_ITEM pItem
            )
{
    if (*(PROP_ID *)pvPropKey == ((LPGLOBAL_PROPERTY_ITEM)pItem)->idProp)
        return(S_OK);
    return(STG_E_UNKNOWN);
}                       



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\b64octet.h ===
//-----------------------------------------------------------------------------
//
//
//  File: B64Octet.h
//
//  Description:  Octet-Stream based processing of UNICODE characters. 
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/21/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __B64OCTET_H__
#define __B64OCTET_H__

#include <windows.h>
#include <dbgtrace.h>

//Buffer size to store conversions... 
//should be no less than 6... multples of 8
//Reasons... we need to be able to fit an entire wide character in buffer.
//Each wide character coverts to 2 1/3 base64 'digits'... plus the possibility
//of 2 more filler characters.  We need 5 characters plus a buffer char to 
//store a single wide char. A 'even' number of WCHAR is 3 (2 1/3 * 3 = 7), 
//which requires 7 base64 digits to encode (plus buffer).
#define BASE64_OCTET_BUFFER_SIZE    9
#define BASE64_OCTET_SIG            '46Bc'
#define BASE64_INVALID_FILL_CHAR    '!'

class CBase64CircularBuffer
{
  private:
    DWORD       m_iHead;
    DWORD       m_iTail;
    CHAR        m_rgchBuffer[BASE64_OCTET_BUFFER_SIZE];
  public:
    CBase64CircularBuffer();
    DWORD       cSize();
    DWORD       cSpaceLeft();
    BOOL        fIsFull();
    BOOL        fIsEmpty();
    BOOL        fPushChar(CHAR ch);
    BOOL        fPopChar(CHAR *pch);
};

class CBase64OctetStream
{
  protected:
    DWORD                   m_dwSignature;
    DWORD                   m_dwCurrentState;
    BYTE                    m_bCurrentLeftOver;
    CBase64CircularBuffer   m_CharBuffer;
    void                    NextState();
    void                    ResetState();
  public:
    CBase64OctetStream();

    //returns FALSE when buffer is full
    BOOL                    fProcessWideChar(WCHAR wch); 
    BOOL                    fProcessSingleByte(BYTE b);

    //The following will terminate the stream a zero-fill any remaining chars
    BOOL                    fTerminateStream(BOOL fUTF7Encoded);

    //returns FALSE when buffer is empty
    BOOL                    fNextValidChar(CHAR *pch) ;
};


//inline functions that implement circular buffer
inline CBase64CircularBuffer::CBase64CircularBuffer()
{
    m_iHead = 0;
    m_iTail = 0;
    memset(&m_rgchBuffer, BASE64_INVALID_FILL_CHAR, BASE64_OCTET_BUFFER_SIZE);
}

inline DWORD CBase64CircularBuffer::cSize()
{
    if (m_iHead <= m_iTail)
        return m_iTail - m_iHead;
    else
        return m_iTail + BASE64_OCTET_BUFFER_SIZE - m_iHead;
}

inline DWORD CBase64CircularBuffer::cSpaceLeft()
{
    return BASE64_OCTET_BUFFER_SIZE - cSize() - 1;
}

inline BOOL CBase64CircularBuffer::fIsFull()
{
    return ((BASE64_OCTET_BUFFER_SIZE-1) == cSize());
}

inline BOOL CBase64CircularBuffer::fIsEmpty() 
{
    return (m_iHead == m_iTail);
}

inline BOOL CBase64CircularBuffer::fPushChar(CHAR ch)
{
    if (fIsFull())
        return FALSE;
    
    m_rgchBuffer[m_iTail] = ch;
    m_iTail++;
    m_iTail %= BASE64_OCTET_BUFFER_SIZE;
    return TRUE;
}

inline BOOL CBase64CircularBuffer::fPopChar(CHAR *pch)
{
    _ASSERT(pch);
    if (fIsEmpty())
        return FALSE;
    
    *pch = m_rgchBuffer[m_iHead];
    _ASSERT(BASE64_INVALID_FILL_CHAR != *pch);
    m_rgchBuffer[m_iHead] = BASE64_INVALID_FILL_CHAR;
    m_iHead++;
    m_iHead %= BASE64_OCTET_BUFFER_SIZE;
    return TRUE;
}

#endif //__B64OCTET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\b64octet.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: b64octet.cpp 
//
//  Description:  Implementation of Base64 encoding stream designed for use
//      with UTF7 encoding.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/21/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "precomp.h"

//Alphabet for BASE64 encoding as defined in RFC1421 and RFC1521
CHAR g_rgchBase64[64] = 
{
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const DWORD BASE64_OCTET_STATE_0_BITS   = 0;
const DWORD BASE64_OCTET_STATE_2_BITS   = 1;
const DWORD BASE64_OCTET_STATE_4_BITS   = 2;
const DWORD BASE64_NUM_STATES           = 3;

//---[ CBase64OctetStream::CBase64OctetStream ]--------------------------------
//
//
//  Description: 
//      Default contructor for CBase64OctetStream
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CBase64OctetStream::CBase64OctetStream()
{
    m_dwSignature = BASE64_OCTET_SIG;
    m_dwCurrentState = BASE64_OCTET_STATE_0_BITS;
    m_bCurrentLeftOver = 0;
}

//---[ CBase64OctetStream::NextState ]------------------------------------------
//
//
//  Description: 
//      Moves the internal state machine to the next state
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CBase64OctetStream::NextState()
{
    m_dwCurrentState++;
    if (BASE64_NUM_STATES == m_dwCurrentState)
    {
        m_dwCurrentState = BASE64_OCTET_STATE_0_BITS;
        m_bCurrentLeftOver = 0;
    }
}

//---[ CBase64OctetStream::ResetState ]----------------------------------------
//
//
//  Description: 
//      Resets the internal state machine
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
void CBase64OctetStream::ResetState()
{
    m_dwCurrentState = BASE64_OCTET_STATE_0_BITS;
    m_bCurrentLeftOver = 0;
}

//---[ CBase64OctetStream::fProcessWideChar ]----------------------------------
//
//
//  Description: 
//      Processes a single wide character and stores the results in its 
//      buffer.  It will also ensure that there is always enough room to 
//      safely calll TerminateStream.
//  Parameters:
//      IN      wch     UNICODE character to process
//  Returns:
//      TRUE    if there is enough room in the buffer to convert this char
//      FALSE   if there is not enough room to conver this char safely
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CBase64OctetStream::fProcessWideChar(WCHAR wch)
{
    BYTE   bHigh = HIBYTE(wch);
    BYTE   bLow  = LOBYTE(wch);
    //At most... a single WCHAR will generate 3 base64 characters evenly or 2
    //base64 characters plus a remainder which can be expanded to 
    //3 more characters (with trailing "==")
    if (m_CharBuffer.cSpaceLeft() < 5)
        return FALSE;

    //We know we have enough room to safely convert this character.... we 
    //will _VERIFY all PushChar's.

    //Loop through bytes in WCHAR
    _VERIFY(fProcessSingleByte(bHigh));
    _VERIFY(fProcessSingleByte(bLow));
    return TRUE;
}

//---[ CBase64OctetStream::fProcessSingleByte ]--------------------------------
//
//
//  Description: 
//      Does the actual work of converting a single byte to the appropriate 
//      base64 char(s).  Also keeps track of state.
//  Parameters:
//      IN b   BYTE to convert
//  Returns:
//      TRUE if there is enough room for the conversion
//      FALSE otherwise
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CBase64OctetStream::fProcessSingleByte(BYTE b)
{
    const BYTE BASE64_MASK = 0x3F; //can only use 6 bits in Base64

    BOOL fRet = TRUE;
    if (m_CharBuffer.fIsFull())
        return FALSE;

    switch (m_dwCurrentState)
    {
        case BASE64_OCTET_STATE_0_BITS:
            //There were no bits left from previous state
            m_bCurrentLeftOver = b & 0x03; //there will now be 2 bits left over
            m_bCurrentLeftOver <<= 4; //shift to MSB in six bits
            _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[BASE64_MASK & (b >> 2)]));
            NextState();
            break;
        case BASE64_OCTET_STATE_2_BITS:
            //There were 2 bits left from previous state.. 
            m_bCurrentLeftOver += (0x0F & (b >> 4));
            _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[BASE64_MASK & m_bCurrentLeftOver]));

            //we will leave 4 low bits over
            m_bCurrentLeftOver = 0x0F & b;
            m_bCurrentLeftOver <<= 2; //shift to MSB is six bit grouping
            NextState();
            break;
        case BASE64_OCTET_STATE_4_BITS:
            //There were 4 bits left over
            if (m_CharBuffer.cSpaceLeft() < 2)
            {
                //There is not enough room for both characters we would push...
                //so don't process byte at all. 
                //Do not move to the next state... do not collection $200.
                fRet = FALSE;
            }
            else
            {
                m_bCurrentLeftOver += (0x03 & (b >> 6));
                _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[BASE64_MASK & m_bCurrentLeftOver]));
                m_bCurrentLeftOver = 0;
                _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[BASE64_MASK & b]));
                NextState();
            }
            break;
        default:
            _ASSERT(0 && "Invalid State");
    }
    return fRet;
}

//---[ CBase64OctetStream::cTerminateStream ]----------------------------------
//
//
//  Description: 
//      Used to signal the termination of the current stream.  Resets the 
//      state as performs any padding necessary
//  Parameters:
//      IN  fUTF7Encoded    TRUE if the stream is UTF7 encoded (does not 
//                          require '=' padding).
//  Returns:
//      TRUE if there is anything left in the buffer.
//      FALSE if there are no characters left to convert
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CBase64OctetStream::fTerminateStream(BOOL fUTF7Encoded)
{
    if (BASE64_OCTET_STATE_0_BITS != m_dwCurrentState)
    {
        //There should always be space left to do this
        _VERIFY(m_CharBuffer.fPushChar(g_rgchBase64[m_bCurrentLeftOver]));
        if (!fUTF7Encoded)
        {
            switch(m_dwCurrentState)
            {
                case BASE64_OCTET_STATE_2_BITS:
                    //There are 2 bits in this byte we did not use... which 
                    //means that there are 2 more base64 chars to fill 24 bits
                    //+ => Used bits
                    //- => Unused (but parsed) bits
                    //? => Unseed bits to fill out to 24 bits
                    //++++ ++-- ???? ???? ???? ????
                    _VERIFY(m_CharBuffer.fPushChar('='));
                    _VERIFY(m_CharBuffer.fPushChar('='));
                    break;
                case BASE64_OCTET_STATE_4_BITS:
                    //In these chase there is only 1 extra base64 char needed
                    //++++ ++++ ++++ ---- ???? ????
                    _VERIFY(m_CharBuffer.fPushChar('='));
                    break;
            }
        }
    }
    ResetState();
    return (!m_CharBuffer.fIsEmpty());
}

//---[ CBase64OctetStream::fNextValidChar ]------------------------------------
//
//
//  Description: 
//      Iterates over buffered converted characters
//  Parameters:
//      OUT pch     Next buffer char
//  Returns:
//      TRUE    If there is a character to get
//      FALSE   If there were no characters to get
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CBase64OctetStream::fNextValidChar(CHAR *pch)
{
    _ASSERT(pch);
    return m_CharBuffer.fPopChar(pch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\cat\src\registry.h ===
//+------------------------------------------------------------
//
// File: registry.h -- copied from "Inside COM" by Dale Rogerson
//       Chapter 7 sample code, a Microsoft Press book.
//
// History:
// jstamerj 1998/12/12 23:26:48: Copied.
//
//-------------------------------------------------------------
#ifndef __Registry_H__
#define __Registry_H__
#include <windows.h>

//
// Registry.h
//   - Helper functions registering and unregistering a component.
//

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const char* szFriendlyName,
                       const char* szVerIndProgID,
                       const char* szProgID) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid,
                         const char* szVerIndProgID,
                         const char* szProgID) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\cpropbag.cxx ===
//
// cpropbag.cxx and cpropbag.h already exist in the SMTP/server project
// When phatq is converted back to aqueue, this code should be reused
// (ideally by creating a static library used by both SMTPSVC.dll and
// AQUEUE.dll)
//
#ifndef PLATINUM
#error Do not use this file in the win2K build environment -- see jstamerj for details
#endif

/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

	cpropbag.cpp

Abstract:

	This module contains the definition of the 
	generic property bag class

Author:

	Keith Lau	(keithlau@microsoft.com)

Revision History:

	keithlau	06/30/98	created
    jstamerj    12/07/00    Copied source for use in dsnsink

--*/

#define INCL_INETSRV_INCS
#include "precomp.h"

// =================================================================
// Default instance info
//

PROPERTY_TABLE_INSTANCE	CMailMsgPropertyBag::s_DefaultInstanceInfo =
{
	GENERIC_PTABLE_INSTANCE_SIGNATURE_VALID,
	INVALID_FLAT_ADDRESS,
	GLOBAL_PROPERTY_TABLE_FRAGMENT_SIZE,
	GLOBAL_PROPERTY_ITEM_BITS,
	GLOBAL_PROPERTY_ITEM_SIZE,
	0,
	INVALID_FLAT_ADDRESS
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsnbuff.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnbuff
//
//  Description: Header file for CDSNBuffer.  Class used to abstract writting
//      DSN buffers to P2 file.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNBUFF_H__
#define __DSNBUFF_H__

#include <windows.h>
#include <dbgtrace.h>
#include "filehc.h"
#include "dsnconv.h"

#define DSN_BUFFER_SIG  'BNSD'
#define DSN_BUFFER_SIZE 1000  

class CDSNBuffer 
{
  public:
    DWORD       	m_dwSignature;
    OVERLAPPED  	m_overlapped;
    DWORD       	m_cbOffset;
    DWORD       	m_cbFileSize;
    DWORD       	m_cFileWrites;
    PFIO_CONTEXT	m_pDestFile;
    BYTE        	m_pbFileBuffer[DSN_BUFFER_SIZE];

    CDSNBuffer();
    ~CDSNBuffer();
    HRESULT     HrInitialize(PFIO_CONTEXT hDestFile);
    HRESULT     HrWriteBuffer(BYTE *pbInputBuffer, DWORD cbInputBuffer);
    HRESULT     HrWriteModifiedUnicodeString(LPWSTR pwszString);
    HRESULT     HrFlushBuffer(OUT DWORD *pcbFileSize);
    HRESULT     HrSeekForward(IN DWORD cbBytesToSeek, OUT DWORD *pcbFileSize);

    //Used to set (and reset) custom conversion contexts.  This feature was
    //designed explitily for UTF7 encoding of DSN content, but could also
    //be used to enforce:
    //  - RFC822 header formats
    //  - RFC822 content restricts
    void        SetConversionContext(CResourceConversionContext *presconv)
    {
        _ASSERT(presconv);
        m_presconv = presconv;
    }
    
    //Used to reset to the defaut memcopy
    void        ResetConversionContext() {m_presconv = &m_defconv;};
    HRESULT     HrWriteResource(WORD wResourceId, LANGID LangId);

    //Encapsulates the functionality of (the nonexistant) LoadStringEx
    HRESULT     HrLoadResourceString(WORD wResourceId, LANGID LangId, 
                                     LPWSTR *pwszResource, DWORD *pcbResource);
   protected:
    CDefaultResourceConversionContext   m_defconv;
    CResourceConversionContext          *m_presconv;
    HRESULT     HrPrivWriteBuffer(BOOL fASCII, BYTE *pbInputBuffer, 
                                  DWORD cbInputBuffer);
    HRESULT     HrWriteBufferToFile();
};

//---[ CDSNBuffer::CDSNBuffer ]------------------------------------------------
//
//
//  Description: 
//      Inlined default constructor for CDSNBuffer
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline CDSNBuffer::CDSNBuffer()
{
    m_dwSignature = DSN_BUFFER_SIG;
    m_overlapped.Offset = 0;
    m_overlapped.OffsetHigh = 0;
    m_overlapped.hEvent = NULL;
    m_cbOffset = 0;
    m_cbFileSize = 0;
    m_cFileWrites = 0;
    m_pDestFile = NULL;
    m_presconv = &m_defconv;
}

//---[ CDSNBuffer::HrFlushBuffer ]---------------------------------------------
//
//
//  Description: 
//      Flushes remaining buffers to File and returns the total number of bytes
//      written to the file.
//  Parameters:
//      OUT pcbFileSize     The size (in bytes) of the file written
//  Returns:
//      S_OK on success
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline HRESULT CDSNBuffer::HrFlushBuffer(OUT DWORD *pcbFileSize)
{
    HRESULT hr = HrWriteBufferToFile();

    _ASSERT(pcbFileSize);
    *pcbFileSize = m_cbFileSize;
    
    return hr;
}

#endif //__DSNBUFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsnbuff.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnbuff.cpp
//
//  Description:  Implementation of CDSNBuffer... class that abstracts writes
//      of DSN information to P2 file.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "precomp.h"

//---[ CDSNBuffer::~CDSNBuffer ]-----------------------------------------------
//
//
//  Description: 
//      Destructor for CDSNBuffer.  Does NOT close file handle (caller is
//      responisble for that).
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CDSNBuffer::~CDSNBuffer()
{
    TraceFunctEnterEx((LPARAM) this, "CDSNBuffer::~CDSNBuffer");

    DebugTrace((LPARAM) this, "INFO: %d File writes needed by CDSNBuffer", m_cFileWrites);

    //make sure we don't pass in 1 bit
    if (m_overlapped.hEvent)
    {
        _VERIFY(CloseHandle((HANDLE) (((DWORD_PTR) m_overlapped.hEvent) & -2)));
    }
    TraceFunctLeave();
}

//---[ CDSNBuffer::HrInitialize ]----------------------------------------------
//
//
//  Description: 
//      Initialize CDSNBuffer object.
//          - Associates destination file handle with object (will not close it)
//          - Creates an event for synchronizing file operations
//  Parameters:
//      hDestFile   - Destination File Handle (must be opend with FILE_FLAG_OVERLAPPED)
//  Returns:
//      S_OK    on success
//      E_INVALIDARG if handle invalid is passed in
//      E_FAIL if CreateEvent fails for an unknown reason
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrInitialize(PFIO_CONTEXT pDestFile)
{
    TraceFunctEnterEx((LPARAM) this, "CDSNBuffer::HrInitialize");
    HRESULT hr = S_OK;

    _ASSERT(pDestFile);

    if (!pDestFile)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    m_pDestFile = pDestFile;

    //allow this to act as reset
    m_overlapped.Offset = 0;
    m_overlapped.OffsetHigh = 0;
    m_cbOffset = 0;
    m_cbFileSize = 0;
    m_cFileWrites = 0;

    m_overlapped.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!m_overlapped.hEvent)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ErrorTrace((LPARAM) this, "ERROR: Unable to create DSNBuffer event - hr 0x%08X", hr);
        goto Exit;
    }

    //Set low bit stop ATQ completion routine from being called
    m_overlapped.hEvent = ((HANDLE) (((DWORD_PTR) m_overlapped.hEvent) | 0x00000001)); 

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDSNBuffer::HrWriteBuffer ]---------------------------------------------
//
//
//  Description: 
//      Writes the given buffer, will call write file if needed
//  Parameters:
//      pbInputBuffer   Buffer to write
//      cbInputBuffer   Number of bytes to write
//  Returns:
//      S_OK on success
//  History:
//      7/3/98 - MikeSwa Created 
//      10/21/98 - MikeSwa Updated to support resource conversion
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrWriteBuffer(BYTE *pbInputBuffer, DWORD cbInputBuffer)
{
    return HrPrivWriteBuffer(TRUE, pbInputBuffer, cbInputBuffer);
}

//---[ CDSNBuffer::HrWriteModifiedUnicodeString ]------------------------------
//
//
//  IMPORTANT NOTE:
//      This function replaces any whitespace characters in the input string
//      with unicode whitespace (0x0020). Becaase fUTF7EncodeBuffer treats
//      whitespace characters such as 0x3000 (Japanese whitespace) as a UTF7
//      "separator", it will encode strings with such characters embedded as
//      2 separate UTF7 strings. By replacing these characters with 0x0020 we
//      guarantee that the output UTF7 string is a single encoded string.
//  Description: 
//      Writes a given NULL terminated Unicode string, and will call write file
//      if needed. Converts to UTF7 encoding.
//  Parameters:
//      pwszString   String to write
//  Returns:
//      S_OK on success
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrWriteModifiedUnicodeString(LPWSTR pwszString)
{
    DWORD i = 0;
    DWORD cbLength = lstrlenW(pwszString);

    _ASSERT(pwszString != NULL);

    //Replace whitespace characters with 
    for(i = 0; i < cbLength; i++) {
        if(iswspace(pwszString[i]))
            pwszString[i] = L' ';
    }

    return HrPrivWriteBuffer(FALSE, (PBYTE) pwszString, cbLength * sizeof(WCHAR));
}

//---[ CDSNBuffer::HrPrivWriteBuffer ]-----------------------------------------
//
//
//  Description: 
//      Private function to handle writing UNICODE and ASCII buffers
//  Parameters:
//      fASCII          TRUE if buffer is ASCII
//      pbInputBuffer   Buffer to write
//      cbInputBuffer   #of bytes to write
//  Returns:
//      S_OK on success
//      Any errors returned from flushing buffer to disk
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrPrivWriteBuffer(BOOL fASCII, BYTE *pbInputBuffer, 
                                      DWORD cbInputBuffer)
{
    HRESULT hr = S_OK;
    BOOL    fDone = FALSE;
    BYTE    *pbCurrentInput = pbInputBuffer;
    DWORD   cbInputRead = 0;
    DWORD   cbTotalInputRead = 0;
    DWORD   cbOutputWritten = 0;
    DWORD   cTimesThruLoop = 0;
    
    _ASSERT(NULL != m_pDestFile);

    while (!fDone)
    {
        cTimesThruLoop++;

        //the buffer can't be *that* large... this will hopfully catch infinite loops
        _ASSERT(cTimesThruLoop < 100); 
        fDone = m_presconv->fConvertBuffer(fASCII, pbCurrentInput, 
                    cbInputBuffer-cbTotalInputRead, m_pbFileBuffer+m_cbOffset,
                    DSN_BUFFER_SIZE - m_cbOffset, &cbOutputWritten, 
                    &cbInputRead);

        m_cbOffset += cbOutputWritten;
        _ASSERT(m_cbOffset <= DSN_BUFFER_SIZE);

        if (!fDone)
        {
            //Update vars passed to fConvertBuffer
            cbTotalInputRead += cbInputRead;
            pbCurrentInput += cbInputRead;

            _ASSERT(cbTotalInputRead <= cbInputBuffer);

            hr = HrWriteBufferToFile();
            if (FAILED(hr))
                goto Exit;
        }
    }

  Exit:
    return hr;
}

//---[ CDSNBuffer::HrWriteBufferToFile ]---------------------------------------
//
//
//  Description: 
//      Write the current buffer contents to the fils
//  Parameters:
//      -
//  Returns:
//      S_OK on success
//  History:
//      7/3/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrWriteBufferToFile()
{
    TraceFunctEnterEx((LPARAM) this, "CDSNBuffer::HrWriteBufferToFile");
    HRESULT hr = S_OK;
    DWORD   cbWritten = 0;
    DWORD   dwError = 0;


    if (m_cbOffset) //there is stuff to write
    {
        //fix up overlapped
        if (!WriteFile(m_pDestFile->m_hFile, m_pbFileBuffer, m_cbOffset, &cbWritten, &m_overlapped))
        {
            dwError = GetLastError();
            if (ERROR_IO_PENDING != dwError)
            {
                hr = HRESULT_FROM_WIN32(dwError);
                goto Exit;
            }

            //Wait for result, so we don't overwrite buffer and overlapped
            if (!GetOverlappedResult(m_pDestFile->m_hFile, &m_overlapped, &cbWritten, TRUE))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
            DebugTrace((LPARAM) this, "INFO: Async write pending for FIOContext 0x%08X", m_pDestFile);
        }
        
        _ASSERT(m_cbOffset == cbWritten);
        m_cbOffset = 0;
        m_cbFileSize += cbWritten;
        m_overlapped.Offset += cbWritten;
        m_cFileWrites++;
    }
     
  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDSNBuffer::SeekForward ]-----------------------------------------------
//
//
//  Description: 
//      Seeks buffers place in file forward specified number of bytes.  Flushes
//      Buffer in process of doing so.
//  Parameters:
//      cbBytesToSeek       Number of bytes to seek forward
//      pcbFileSize         Returns old file size
//  Returns:
//      S_OK on succedd
//  History:
//      7/6/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrSeekForward(IN DWORD cbBytesToSeek,OUT DWORD *pcbFileSize)
{
    _ASSERT(pcbFileSize);
    HRESULT hr = HrWriteBufferToFile();
    if (FAILED(hr))
        return hr;

    *pcbFileSize = m_cbFileSize;

    m_cbFileSize += cbBytesToSeek;
    m_overlapped.Offset += cbBytesToSeek;

    return S_OK;
}

//---[ CDSNBuffer::HrLoadResourceString ]--------------------------------------
//
//
//  Description: 
//      Encapsulates the functionality of LoadString... but allows you to
//      specify a LangId, returns read only data
//  Parameters:
//      IN  wResourceId     ID of the resource
//      IN  LangId          LangID to get resource for
//      OUT pwszResource    Read-only UNICODE resource (not NULL terminated)
//      OUT pcbResource     Size (in bytes) of UNICODE String
//  Returns:
//      S_OK on success
//      HRESULTS from errors trying to get load resources
//  History:
//      10/22/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrLoadResourceString(WORD wResourceId, LANGID LangId, 
                                        LPWSTR *pwszResource, DWORD *pcbResource)
{
    HRESULT hr = S_OK;
    HINSTANCE hModule = GetModuleHandle(DSN_RESOUCE_MODULE_NAME);
    HRSRC hResInfo = NULL;
    HGLOBAL hResData = NULL;
    WORD    wStringIndex = wResourceId & 0x000F;
    LPWSTR  wszResData = NULL;
    WCHAR   wchLength = 0; //character representing current length

    _ASSERT(pwszResource);
    _ASSERT(pcbResource);

    *pwszResource = NULL;
    *pcbResource = NULL;

    if (NULL == hModule)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERT(0 && "Unable to load resource DLL");
        goto Exit;
    }

    //Find handle to string table segment
    hResInfo = FindResourceEx(hModule, RT_STRING,
                            MAKEINTRESOURCE(((WORD)((USHORT)wResourceId >> 4) + 1)),
                            LangId);

    if (NULL == hResInfo)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        _ASSERT(0 && "Failed to find resource for requested LangId");
        goto Exit;
    }


    hResData = LoadResource(hModule, hResInfo);

    if (NULL == hResData)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //Get pointer to string table segement data
    wszResData = (LPWSTR) LockResource(hResData);

    if (NULL == wszResData)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
   
    //OK Now we have a pointer to the string table segment
    //Lets use some code from LoadStringOrError to handle this
    //There are 16 strings in a segment, which means we can look at
    //The low 4 bits of the wResourceId (wStringIndex)

    //String Table segment format
    //PASCAL like string count first UTCHAR is count if TCHARs
    //A zero length string (ie resource 0) is simply the WORD 0x0000...
    //This loop handles both the same... when loop is done.
    //  wszResData  - Ptr to UNICODE string
    //  wchLenght   - Length of that string (in WCHARS)
    while (TRUE) 
    {
        wchLength = *((WCHAR *)wszResData++);
        if (0 == wStringIndex--)
            break;
        // Step to start if next string... 
        wszResData += wchLength;                
    }

    *pwszResource = wszResData;
    *pcbResource = (DWORD) wchLength*sizeof(WCHAR);

  Exit:
    return hr;
}

//---[ CDSNBuffer::HrWriteResource ]-------------------------------------------
//
//
//  Description: 
//      Gets resource for specified language ID, and dumps UNICODE to DSN 
//      content using current conversion context.
//
//      It will assert if the resource cannot be found for the given language
//      ID.
//  Parameters:
//      dwResourceID        The resouce ID of the resource to get
//      LandId              The language ID to use
//  Returns:
//      S_OK on success
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
HRESULT CDSNBuffer::HrWriteResource(WORD wResourceId, LANGID LangId)
{
    HRESULT hr = S_OK;
    LPWSTR  wszResource = NULL;
    DWORD   cbResource = NULL;

    hr = HrLoadResourceString(wResourceId, LangId, &wszResource, &cbResource);
    if (FAILED(hr))
    {
        _ASSERT(0 && "Unable to load resources");
        //Fail silently in retail
        hr = S_OK;
    }
    
    //OK... now we have everything we need to write the buffer
    hr = HrPrivWriteBuffer(FALSE /*not ASCII */,
                           (BYTE *) wszResource, cbResource);

    //$$REVIEW: Do we need to do any special cleanup here?
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsnconv.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnconv.h
//
//  Description:  Base classes for DSN resource conversion
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/21/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNCONV_H__
#define __DSNCONV_H__

//---[ CResourceConversionContext ]----------------------------------------------
//
//
//  Description: 
//      Class used to abstract the various types of content conversion we 
//      may be forced to do to support charsets other than US-ASCII.
//  Hungarian: 
//      resconv, presconv
//  
//-----------------------------------------------------------------------------
class CResourceConversionContext
{
  public:
      //Used to convert a UNICODE/ASCII resource to DSN body text
      //This additional abstraction (UNICODE vs ASCII)
      //is require for supporting potential additions like without messing with
      //the mainline buffer code
      //    - guaranteed line length
      //    - handling special ASCII characters in RFC822 headers
      //    - Provides single code path for all buffer writes
      virtual BOOL fConvertBuffer(
          IN BOOL   fASCII, 
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead) = 0;
};

//---[ CDefaultResourceConversionContext ]-------------------------------------
//
//
//  Description: 
//      Default resource conversion object... simple memcpy for base case
//  Hungarian: 
//      defconv, pdefconv
//  
//-----------------------------------------------------------------------------
class CDefaultResourceConversionContext : public CResourceConversionContext
{
  public:
    BOOL fConvertBuffer(
          IN BOOL   fASCII, 
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead);
};


//---[ CDefaultResourceConversionContext::fConvertBuffer ]----------------------
//
//
//  Description: 
//      Default Resource conversion for DSNs 
//  Parameters:
//      IN  fASCII              TRUE if buffer is ASCII 
//                                  (*must* be TRUE for default)
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//      IN  pbOutputBuffer      Buffer to write data to
//      IN  cbOutputBuffer      Size of buffer to write data to
//      OUT pcbWritten          # of bytes written to output bufferbuffer
//      OUT pcbRead             # of bytes read from Input buffer
//  Returns:
//      TRUE if done converting
//      FALSE if needs more output buffer
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline BOOL CDefaultResourceConversionContext::fConvertBuffer(
                                          IN BOOL   fASCII, 
                                          IN PBYTE  pbInputBuffer,
                                          IN DWORD  cbInputBuffer,
                                          IN PBYTE  pbOutputBuffer,
                                          IN DWORD  cbOutputBuffer,
                                          OUT DWORD *pcbWritten,
                                          OUT DWORD *pcbRead)
{
    _ASSERT(pcbWritten);
    _ASSERT(pcbRead);
    _ASSERT(fASCII);

    if (cbInputBuffer <= cbOutputBuffer)
    {
        //everything can fit in current buffer
        memcpy(pbOutputBuffer, pbInputBuffer, cbInputBuffer);
        *pcbRead = cbInputBuffer;
        *pcbWritten = cbInputBuffer;
        return TRUE;
    }
    else
    {
        //we need to write in chunks
        memcpy(pbOutputBuffer, pbInputBuffer, cbOutputBuffer);
        *pcbRead = cbOutputBuffer;
        *pcbWritten = cbOutputBuffer;
        return FALSE;
    }
}

#endif //__DSNCONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsninternal.h ===
//+------------------------------------------------------------
//
// Copyright (C) 2001, Microsoft Corporation
//
// File: dsninternal.h
//
// Contents: Classes used internally in the DSN code
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 2001/05/10 20:34:19: Created.
//
//-------------------------------------------------------------
#ifndef __DSNINTERNAL_H__
#define __DSNINTERNAL_H__

#define RECIPITER_SIG           (DWORD)'IpRD'
#define RECIPITER_SIG_INVALID   (DWORD)'XpRD'

//
// The default implementation of the DSN Recipient iterator
//
class CDefaultDSNRecipientIterator :
    public IDSNRecipientIterator
{
  public: //IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    //
    // This class is allocated as a part of another object. Pass
    // AddRef/Release to the parent object
    //
    STDMETHOD_(ULONG, AddRef)(void) 
    {
        return m_pUnk->AddRef();
    }
    STDMETHOD_(ULONG, Release)(void) 
    {
        return m_pUnk->Release();
    }
  public:
    STDMETHOD(HrReset) ();

    STDMETHOD(HrGetNextRecipient) (
        OUT DWORD *piRecipient,
        OUT DWORD *pdwDSNAction);

    STDMETHOD(HrNotifyActionHandled) (
        IN  DWORD iRecipient,
        IN  DWORD dwDSNAction);

  public:
    CDefaultDSNRecipientIterator(
        IUnknown *pUnk)
    {
        m_dwStartDomain = 0;
        m_dwDSNActions = 0;
        m_pIRecips = NULL;
        m_fFilterInit = NULL;
        m_pUnk = pUnk;
        m_dwSig = RECIPITER_SIG;
    }

    ~CDefaultDSNRecipientIterator();

    HRESULT HrInit(
        IN  IMailMsgProperties          *pIMsg,
        IN  DWORD                        dwStartDomain,
        IN  DWORD                        dwDSNActions);

  private:
    VOID GetFilterMaskAndFlags(
        IN  DWORD dwDSNActions, 
        OUT DWORD *pdwRecipMask, 
        OUT DWORD *pdwRecipFlags);

    VOID GetDSNAction(
        IN  DWORD dwDSNAction,
        IN  DWORD dwCurrentRecipFlags,
        OUT DWORD *pdwCurrentDSNAction);

    VOID GetRecipientFlagsForActions(
        IN  DWORD dwDSNAction,
        OUT DWORD *pdwRecipientFlags);

    VOID TerminateFilter();

  private:
    DWORD                       m_dwSig;
    IUnknown                   *m_pUnk;
    DWORD                       m_dwStartDomain;
    DWORD                       m_dwDSNActions;
    IMailMsgRecipients         *m_pIRecips;
    BOOL                        m_fFilterInit;
    RECIPIENT_FILTER_CONTEXT    m_rpfctxt;
};

class CPostDSNHandler :
    public IDSNSubmission
{
    #define SIGNATURE_CPOSTDSNHANDLER           (DWORD)'SDPC'
    #define SIGNATURE_CPOSTDSNHANDLER_INVALID   (DWORD)'SDPX'
  public:
    CPostDSNHandler(
        IN  IUnknown *pUnk,
        IN  CDSNGenerator *pDSNGenerator,
        IN  IAQServerEvent *pIServerEvent,
        IN  DWORD dwVSID,
        IN  ISMTPServer *pISMTPServer,
        IN  IMailMsgProperties *pIMsgOrig,
        IN  IDSNSubmission *pIAQDSNSubmission,
        IN  IDSNGenerationSink *pDefaultSink);

    ~CPostDSNHandler();

    VOID SetPropInterface(
        IN  IMailMsgPropertyBag *pIDSNProps)
    {
        if(m_pIDSNProps)
            m_pIDSNProps->Release();
        m_pIDSNProps = pIDSNProps;
        m_pIDSNProps->AddRef();
    }

    VOID ReleaseAQDSNSubmission()
    {
        if(m_pIAQDSNSubmission)
        {
            m_pIAQDSNSubmission->Release();
            m_pIAQDSNSubmission = NULL;
        }
    }
  public:
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    //
    // This class is allocated as a part of another object. Pass
    // AddRef/Release to the parent object
    //
    STDMETHOD_(ULONG, AddRef)(void) 
    {
        return m_pUnk->AddRef();
    }
    STDMETHOD_(ULONG, Release)(void) 
    {
        return m_pUnk->Release();
    }
    STDMETHOD(HrAllocBoundMessage)(
        OUT IMailMsgProperties **ppMsg,
        OUT PFIO_CONTEXT *phContent);
    
    STDMETHOD(HrSubmitDSN)(
        IN  DWORD dwDSNAction,
        IN  DWORD cRecipsDSNd,
        IN  IMailMsgProperties *pDSNMsg);

  private:
    DWORD m_dwSig;
    IUnknown *m_pUnk;
    CDSNGenerator *m_pDSNGenerator;
    IAQServerEvent *m_pIServerEvent;
    DWORD m_dwVSID;
    ISMTPServer *m_pISMTPServer;
    IMailMsgProperties *m_pIMsgOrig;
    IMailMsgPropertyBag *m_pIDSNProps;
    IDSNSubmission *m_pIAQDSNSubmission;
    IDSNGenerationSink *m_pDefaultSink;
};

//
// The class will control the refcounting and lifetime of all the
// per-DSN classes
//
#define SIGNATURE_CDSNPOOL                  (DWORD)'PSDC'
#define SIGNATURE_CDSNPOOL_INVALID          (DWORD)'PSDX'

class CDSNPool :
    public IUnknown
{
  public:
    //
    // Disable the warning that we are using "this" in the
    // constructor.  Since All we do is save the pointer for later
    // use, we are safe.
    //
#pragma warning( disable : 4355)
    CDSNPool(
        IN  CDSNGenerator *pDSNGenerator,
        IN  IAQServerEvent *pIServerEvent,
        IN  DWORD dwVSID,
        IN  ISMTPServer *pISMTPServer,
        IN  IMailMsgProperties *pIMsgOrig,
        IN  IDSNSubmission *pIAQDSNSubmission,
        IN  IDSNGenerationSink *pDefaultSink) :
        m_DefaultRecipIter(this),
        m_PostDSNHandler(
            this,
            pDSNGenerator,
            pIServerEvent,
            dwVSID,
            pISMTPServer,
            pIMsgOrig,
            pIAQDSNSubmission,
            pDefaultSink)
    {
        m_dwSig = SIGNATURE_CDSNPOOL;
        m_lRef = 1;
    }
#pragma warning( default : 4355 )
    ~CDSNPool()
    {
        _ASSERT(m_dwSig == SIGNATURE_CDSNPOOL);
        m_dwSig = SIGNATURE_CDSNPOOL_INVALID;
    }

    void *operator new(size_t size)
    {
        return sm_Pool.Alloc();
    }
    void operator delete(void *p, size_t size)
    {
        return sm_Pool.Free(p);
    }

  public:
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj)
    {
        if(riid == IID_IUnknown)
        {
            *ppvObj = (IUnknown *)this;
            AddRef();
            return S_OK;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }
    STDMETHOD_(ULONG, AddRef)(void) 
    {
        return InterlockedIncrement(&m_lRef);
    }
    STDMETHOD_(ULONG, Release)(void) 
    {
        ULONG ulRet = InterlockedDecrement(&m_lRef);
        if(ulRet == 0)
        {
            delete this;
        }
        return ulRet;
    }

    CDefaultDSNRecipientIterator * GetDefaultIter()
    {
        return &m_DefaultRecipIter;
    }
    CPostDSNHandler * GetPostDSNHandler()
    {
        return &m_PostDSNHandler;
    }
    CMailMsgPropertyBag * GetDSNProperties()
    {
        return &m_PropBag;
    }

    static HRESULT HrStaticInit();
    static VOID StaticDeinit();

  private:
    static CPool sm_Pool;
    DWORD m_dwSig;
    LONG m_lRef;
    CDefaultDSNRecipientIterator m_DefaultRecipIter;
    CPostDSNHandler m_PostDSNHandler;
    CMailMsgPropertyBag m_PropBag;
};

#endif //__DSNINTERNAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsntext.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsntext.h
//
//  Description:  Defines DSN test
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/3/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSNTEXT_H__
#define __DSNTEXT_H__

#ifdef PLATINUM
#define DSN_RESOUCE_MODULE_NAME     "phatq.dll"
#else //PLATINUM
#define DSN_RESOUCE_MODULE_NAME     "aqueue.dll"
#endif //PLATINUM

//822 DSN Message headers
#define TO_HEADER                   "\r\nTo: "
#define BCC_HEADER                  "\r\nBcc: "
#define DSN_CONTEXT_HEADER          "\r\nX-DSNContext: "
#define DSN_CONTENT_FAILURE_HEADER  "\r\nX-Content-Failure: "
#define MIME_HEADER                 "\r\nMIME-Version: 1.0\r\n" \
                                    "Content-Type: multipart/report; " \
                                    "report-type=delivery-status;\r\n" \
                                    "\tboundary="
#define DATE_HEADER                 "\r\nDate: "
#define SUBJECT_HEADER              "\r\nSubject: "
#define MSGID_HEADER                "\r\nMessage-ID: "
#define MIME_DELIMITER              "--"
#define DSN_MAIL_FROM               "<>"
#define DSN_FROM_HEADER             "From: "
#define DSN_SENDER_ADDRESS_PREFIX   "postmaster@"
#define DSN_RFC822_SENDER           DSN_FROM_HEADER DSN_SENDER_ADDRESS_PREFIX
#define BLANK_LINE                  "\r\n\r\n"
#define DSN_INDENT                  "       "
#define DSN_CRLF                    "\r\n"

//822 DSN Headers used when copying original message... since we do not
//know if we will have a preceeeding property, these do not include the
//preceeeding CRLF.
#define DSN_FROM_HEADER_NO_CRLF     "From: "
#define SUBJECT_HEADER_NO_CRLF      "Subject: "
#define MSGID_HEADER_NO_CRLF        "Message-ID: "
#define DATE_HEADER_NO_CRLF         "Date: "
#define TO_HEADER_NO_CRLF           "To: "
#define ADDRESS_SEPERATOR           ", " // Seperate addresses with comma

//DSN Report fields
#define MIME_CONTENT_TYPE           "\r\nContent-Type: "
#define DSN_HEADER_TYPE_DELIMITER   ";"
#define DSN_MIME_TYPE               "message/delivery-status"
#define DSN_HUMAN_READABLE_TYPE     "text/plain"
#define DSN_MIME_CHARSET_HEADER     "; charset="
#define DSN_RFC822_TYPE             "message/rfc822"
#define DSN_HEADERS_TYPE            "text/rfc822-headers"
#define DSN_HEADER_ENVID            "\r\nOriginal-Envelope-Id: "
#define DSN_HEADER_REPORTING_MTA    "\r\nReporting-MTA: dns;"
#define DSN_HEADER_DSN_GATEWAY      "\r\nDSN-Gateway: "
#define DSN_HEADER_RECEIVED_FROM    "\r\nReceived-From-MTA: dns;"
#define DSN_HEADER_ARRIVAL_DATE     "\r\nArrival-Date: "

#define DSN_RP_HEADER_ORCPT         "\r\nOriginal-Recipient: "
#define DSN_HEADER_DISPLAY_NAME     "\r\nX-Display-Name: "
#define DSN_RP_HEADER_FINAL_RECIP   "\r\nFinal-Recipient: "
#define DSN_RP_HEADER_ACTION        "\r\nAction: "
#define DSN_RP_HEADER_ACTION_FAILURE "failed"
#define DSN_RP_HEADER_ACTION_DELAYED "delayed"
#define DSN_RP_HEADER_ACTION_DELIVERED "delivered"
#define DSN_RP_HEADER_ACTION_RELAYED "relayed"
#define DSN_RP_HEADER_ACTION_EXPANDED "expanded"
#define DSN_RP_HEADER_STATUS        "\r\nStatus: "
#define DSN_RP_HEADER_REMOTE_MTA    "\r\nRemote-MTA: dns;"
#define DSN_RP_HEADER_DIAG_CODE     "\r\nDiagnostic-Code: smtp;"
#define DSN_RP_HEADER_LAST_ATTEMPT  "\r\nLast-Attempt-Date: "
#define DSN_RP_HEADER_FINAL_LOG     "\r\nFinal-Log-Id: "
#define DSN_RP_HEADER_RETRY_UNTIL   "\r\nWill-Retry-Until: "

//status codes 
#define DSN_STATUS_CH_DELIMITER     '.'
#define DSN_STATUS_CH_INVALID       '\0'
#define DSN_STATUS_CH_GENERIC       '0'
//generic status codes
#define DSN_STATUS_FAILED           "5.0.0"
#define DSN_STATUS_DELAYED          "4.0.0"
#define DSN_STATUS_SUCCEEDED        "2.0.0"
#define DSN_STATUS_SMTP_PROTOCOL_ERROR  "5.5.0" // Generic SMTP protocol error

//Class (first) digit of status codes
#define DSN_STATUS_CH_CLASS_SUCCEEDED   '2'
#define DSN_STATUS_CH_CLASS_TRANSIENT   '4'
#define DSN_STATUS_CH_CLASS_FAILED      '5'

//Subject (second) digit(s) of status codes
#define DSN_STATUS_CH_SUBJECT_GENERAL   '0'
#define DSN_STATUS_CH_SUBJECT_ADDRESS   '1'
#define DSN_STATUS_CH_SUBJECT_MAILBOX   '2'
#define DSN_STATUS_CH_SUBJECT_SYSTEM    '3'
#define DSN_STATUS_CH_SUBJECT_NETWORK   '4'
#define DSN_STATUS_CH_SUBJECT_PROTOCOL  '5'
#define DSN_STATUS_CH_SUBJECT_CONTENT   '6'
#define DSN_STATUS_CH_SUBJECT_POLICY    '7'

//Detail (third) digit(s) of status codes
#define DSN_STATUS_CH_DETAIL_GENERAL    '0'

//This part appears before the first MIME part and is intended for non-MIME 
//clients.  It *cannot* be localized since it is not actually part of any MIME
//part and must be 100% US-ASCII
#define MESSAGE_SUMMARY         "This is a MIME-formatted message.  \r\n" \
                                "Portions of this message may be unreadable without a MIME-capable mail program."

//String that can be localized are located in dsnlang.h and aqueue.rc


#endif //__DSNTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsnsink.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dsnsink.cpp
//
//  Description: Implementation of default DSN Generation sink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/30/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "precomp.h"

//
//  This length is inspired by the other protocols that we deal with.  The
//  default address limit is 1024, but the MTA can allow 1024 + 834  for the
//  OR address.  We'll define out default buffer size to allow this large
//  of an address.
//
#define PROP_BUFFER_SIZE 1860

#ifdef DEBUG
#define DEBUG_DO_IT(x) x
#else
#define DEBUG_DO_IT(x)
#endif  //DEBUG

//min sizes for valid status strings
#define MIN_CHAR_FOR_VALID_RFC2034  10
#define MIN_CHAR_FOR_VALID_RFC821   3

#define MAX_RFC822_DATE_SIZE 35
BOOL FileTimeToLocalRFC822Date(const FILETIME & ft, char achReturn[MAX_RFC822_DATE_SIZE]);

static  char  *s_rgszMonth[ 12 ] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};

static  char *s_rgszWeekDays[7] =
{
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
};

#define MAX_RFC_DOMAIN_SIZE         64

//String used in generation of MsgID
static char g_szBoundaryChars [] = "0123456789abcdefghijklmnopqrstuvwxyz"
"ABCDEFGHIJKLMNOPQRSTUVWXYZ";

static LONG g_cDSNMsgID = 0;

//Address types to check for, and their corresponding address types.
const DWORD   g_rgdwSenderPropIDs[] = {
    IMMPID_MP_SENDER_ADDRESS_SMTP,
    IMMPID_MP_SENDER_ADDRESS_X400,
    IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN,
    IMMPID_MP_SENDER_ADDRESS_X500,
    IMMPID_MP_SENDER_ADDRESS_OTHER};

const DWORD   g_rgdwRecipPropIDs[] = {
    IMMPID_RP_ADDRESS_SMTP,
    IMMPID_RP_ADDRESS_X400,
    IMMPID_RP_LEGACY_EX_DN,
    IMMPID_RP_ADDRESS_X500,
    IMMPID_RP_ADDRESS_OTHER};

const DWORD   NUM_DSN_ADDRESS_PROPERTIES = 5;

const CHAR    *g_rgszAddressTypes[] = {
    "rfc822",
    "x-x400",
    "x-ex",
    "x-x500",
    "unknown"};

CPool CDSNPool::sm_Pool;


//---[ fLanguageAvailable ]----------------------------------------------------
//
//
//  Description:
//      Checks to see if resources for a given language are available.
//  Parameters:
//      LangId      Language to check for
//  Returns:
//      TRUE    If localized resources for requested language are available
//      FALSE   If resources for that language are not available.
//  History:
//      10/26/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fLanguageAvailable(LANGID LangId)
{
    TraceFunctEnterEx((LPARAM) LangId, "fLanguageAvailable");
    HINSTANCE hModule = GetModuleHandle(DSN_RESOUCE_MODULE_NAME);
    HRSRC hResInfo = NULL;
    BOOL  fResult = FALSE;

    if (NULL == hModule)
    {
        _ASSERT( 0 && "Cannot get resource module handle");
        return FALSE;
    }

    //Find handle to string table segment
    hResInfo = FindResourceEx(hModule, RT_STRING,
                              MAKEINTRESOURCE(((WORD)((USHORT)GENERAL_SUBJECT >> 4) + 1)),
                              LangId);

    if (NULL != hResInfo)
        fResult = TRUE;
    else
        ErrorTrace((LPARAM) LangId, "Unable to load DSN resources for language");

    TraceFunctLeave();
    return fResult;

}

//---[ fIsValidMIMEBoundaryChar ]----------------------------------------------
//
//
//  Description:
//
//      Checks to see if the given character is a valid as described by the
//      RFC2046 BNF for MIME Boundaries:
//          boundary := 0*69<bchars> bcharsnospace
//          bchars := bcharsnospace / " "
//          bcharsnospace := DIGIT / ALPHA / "'" / "(" / ")" /
//                         "+" / "_" / "," / "-" / "." /
//                         "/" / ":" / "=" / "?"
//  Parameters:
//      ch      Char to check
//  Returns:
//      TRUE if VALID
//      FALSE otherwise
//  History:
//      7/6/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fIsValidMIMEBoundaryChar(CHAR ch)
{
    if (isalnum((UCHAR)ch))
        return TRUE;

    //check to see if it is one of the special case characters
    if (('\'' == ch) || ('(' == ch) || (')' == ch) || ('+' == ch) ||
        ('_' == ch) || (',' == ch) || ('_' == ch) || ('.' == ch) ||
        ('/' == ch) || (':' == ch) || ('=' == ch) || ('?' == ch))
        return TRUE;
    else
        return FALSE;
}

//---[ GenerateDSNMsgID ]------------------------------------------------------
//
//
//  Description:
//      Generates a unique MsgID string
//
//      The format is:
//          <random-unique-string>@<domain>
//  Parameters:
//      IN  szDomain            Domain to generate MsgID for
//      IN  cbDomain            Domain to generate MsgID for
//      IN OUT  szBuffer        Buffer to write MsgID in
//      IN  cbBuffer            Size of buffer to write MsgID in
//  Returns:
//      TRUE on success
//      FALSE otherwise
//  History:
//      3/2/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fGenerateDSNMsgID(LPSTR szDomain,DWORD cbDomain,
                       LPSTR szBuffer, DWORD cbBuffer)
{
    TraceFunctEnterEx((LPARAM) NULL, "fGenerateDSNMsgID");
    _ASSERT(szDomain);
    _ASSERT(cbDomain);
    _ASSERT(szBuffer);
    _ASSERT(cbBuffer);

    // insert the leading <
    if (cbBuffer >= 1) {
        *szBuffer = '<';
        szBuffer++;
        cbBuffer--;
    }

    const CHAR szSampleFormat[] = "00000000@"; // sample format string
    const DWORD cbMsgIdLen = 20;  //default size of random string
    LPSTR szStop = szBuffer + cbMsgIdLen;
    LPSTR szCurrent = szBuffer;
    DWORD cbCurrent = 0;

    //minimize size for *internal* static buffer
    _ASSERT(cbBuffer > MAX_RFC_DOMAIN_SIZE + cbMsgIdLen);

    if (!szDomain || !cbDomain || !szBuffer || !cbBuffer ||
        (cbBuffer <= MAX_RFC_DOMAIN_SIZE + cbMsgIdLen))
        return FALSE;

    //We want to figure how much room we have for random characters
    //We will need to fit the domain name, the '@', and the 8 character unique
    //number
    // awetmore - add 1 for the trailing >
    if(cbBuffer < cbDomain + cbMsgIdLen + 1)
    {
        //Fall through an allow for 20 characaters and part of domain name
        //We want to catch this in debug builds
        _ASSERT(0 && "Buffer too small for MsgID");
    }

    //this should have been caught in parameter checking
    _ASSERT(cbBuffer > cbMsgIdLen);

    szStop -= (sizeof(szSampleFormat) + 1);
    while (szCurrent < szStop)
    {
        *szCurrent = g_szBoundaryChars[rand() % (sizeof(g_szBoundaryChars) - 1)];
        szCurrent++;
    }

    //Add unique number
    cbCurrent = sprintf(szCurrent, "%8.8x@", InterlockedIncrement(&g_cDSNMsgID));
    _ASSERT(sizeof(szSampleFormat) - 1 == cbCurrent);

    //Figure out how much room we have and add domain name
    szCurrent += cbCurrent;
    cbCurrent = (DWORD) (szCurrent-szBuffer);

    //unless I've messed up the logic this is always true
    _ASSERT(cbCurrent < cbBuffer);

    //Add domain part to message id
    strncat(szCurrent-1, szDomain, cbBuffer - cbCurrent - 1);

    _ASSERT(cbCurrent + cbDomain < cbBuffer);

    // Add the trailing >.  we accounted for the space above check for
    // cbBuffer size
    strncat(szCurrent, ">", cbBuffer - cbCurrent - cbDomain - 1);

    DebugTrace((LPARAM) NULL, "Generating DSN Message ID %s", szCurrent);
    TraceFunctLeave();
    return TRUE;
}

//---[ fIsMailMsgDSN ]---------------------------------------------------------
//
//
//  Description:
//      Determines if a mailmsg is a DSN.
//  Parameters:
//      IN  pIMailMsgProperties
//  Returns:
//      TRUE if the orinal message is a DSN
//      FALSE if it is not a DSN
//  History:
//      2/11/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
BOOL fIsMailMsgDSN(IMailMsgProperties *pIMailMsgProperties)
{
    CHAR    szSenderBuffer[sizeof(DSN_MAIL_FROM)];
    DWORD   cbSender = 0;
    HRESULT hr = S_OK;
    BOOL    fIsDSN = FALSE; //unless proven otherwise... it is not a DSN

    _ASSERT(pIMailMsgProperties);

    szSenderBuffer[0] = '\0';
    //Get the sender of the original message
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_SENDER_ADDRESS_SMTP,
                                          sizeof(szSenderBuffer), &cbSender, (BYTE *) szSenderBuffer);
    if (SUCCEEDED(hr) &&
        ('\0' == szSenderBuffer[0] || !strcmp(DSN_MAIL_FROM, szSenderBuffer)))
    {
        //If the sender is a NULL string... or "<>"... then it is a DSN
        fIsDSN = TRUE;
    }

    return fIsDSN;
}

#ifdef DEBUG
#define _ASSERT_RECIP_FLAGS  AssertRecipFlagsFn
#define _ASSERT_MIME_BOUNDARY(szMimeBoundary) AssertMimeBoundary(szMimeBoundary)

//---[ AssertRecipFlagsFn ]----------------------------------------------------
//
//
//  Description:
//      ***DEBUG ONLY***
//      Asserts that the recipient flags defined in mailmsgprops.h are correct
//  Parameters:
//      -
//  Returns:
//      -
//  History:
//      7/2/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void AssertRecipFlagsFn()
{
    DWORD i, j;
    DWORD rgdwFlags[] = {RP_DSN_NOTIFY_SUCCESS, RP_DSN_NOTIFY_FAILURE,
                         RP_DSN_NOTIFY_DELAY, RP_DSN_NOTIFY_NEVER, RP_DELIVERED,
                         RP_DSN_SENT_NDR, RP_FAILED, RP_UNRESOLVED, RP_EXPANDED,
                         RP_DSN_SENT_DELAYED, RP_DSN_SENT_EXPANDED, RP_DSN_SENT_RELAYED,
                         RP_DSN_SENT_DELIVERED, RP_REMOTE_MTA_NO_DSN, RP_ERROR_CONTEXT_STORE,
                         RP_ERROR_CONTEXT_CAT, RP_ERROR_CONTEXT_MTA};
    DWORD cFlags = sizeof(rgdwFlags)/sizeof(DWORD);

    for (i = 0; i < cFlags;i ++)
    {
        for (j = i+1; j < cFlags; j++)
        {
            //make sure all have some unique bits
            if (rgdwFlags[i] & rgdwFlags[j])
            {
                _ASSERT((rgdwFlags[i] & rgdwFlags[j]) != rgdwFlags[j]);
                _ASSERT((rgdwFlags[i] & rgdwFlags[j]) != rgdwFlags[i]);
            }
        }
    }

    //Verify that handled bit is used correctly
    _ASSERT(RP_HANDLED & RP_DELIVERED);
    _ASSERT(RP_HANDLED & RP_DSN_SENT_NDR);
    _ASSERT(RP_HANDLED & RP_FAILED);
    _ASSERT(RP_HANDLED & RP_UNRESOLVED);
    _ASSERT(RP_HANDLED & RP_EXPANDED);
    _ASSERT(RP_HANDLED ^ RP_DELIVERED);
    _ASSERT(RP_HANDLED ^ RP_DSN_SENT_NDR);
    _ASSERT(RP_HANDLED ^ RP_FAILED);
    _ASSERT(RP_HANDLED ^ RP_UNRESOLVED);
    _ASSERT(RP_HANDLED ^ RP_EXPANDED);

    //Verify that DSN-handled bit is used correctly
    _ASSERT(RP_DSN_HANDLED & RP_DSN_SENT_NDR);
    _ASSERT(RP_DSN_HANDLED & RP_DSN_SENT_EXPANDED);
    _ASSERT(RP_DSN_HANDLED & RP_DSN_SENT_RELAYED);
    _ASSERT(RP_DSN_HANDLED & RP_DSN_SENT_DELIVERED);
    _ASSERT(RP_DSN_HANDLED ^ RP_DSN_SENT_NDR);
    _ASSERT(RP_DSN_HANDLED ^ RP_DSN_SENT_EXPANDED);
    _ASSERT(RP_DSN_HANDLED ^ RP_DSN_SENT_RELAYED);
    _ASSERT(RP_DSN_HANDLED ^ RP_DSN_SENT_DELIVERED);

    //Verify that general failure bit is used correctly
    _ASSERT(RP_GENERAL_FAILURE & RP_FAILED);
    _ASSERT(RP_GENERAL_FAILURE & RP_UNRESOLVED);
    _ASSERT(RP_GENERAL_FAILURE ^ RP_FAILED);
    _ASSERT(RP_GENERAL_FAILURE ^ RP_UNRESOLVED);

}

//---[ AssertMimeBoundary ]----------------------------------------------------
//
//  ***DEBUG ONLY***
//  Description:
//      Asserts that the given MIME boundary is NULL-terminated and has only
//      Valid characters
//  Parameters:
//      szMimeBoundary      NULL-terminated MIME Boundary string
//  Returns:
//      -
//  History:
//      7/6/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void AssertMimeBoundary(LPSTR szMimeBoundary)
{
    CHAR *pcharCurrent = szMimeBoundary;
    DWORD cChars = 0;
    while ('\0' != *pcharCurrent)
    {
        cChars++;
        _ASSERT(cChars <= MIME_BOUNDARY_RFC2046_LIMIT);
        _ASSERT(fIsValidMIMEBoundaryChar(*pcharCurrent));
        pcharCurrent++;
    }
}

#else //not DEBUG
#define _ASSERT_RECIP_FLAGS()
#define _VERIFY_MARKED_RECIPS(a, b, c)
#define _ASSERT_MIME_BOUNDARY(szMimeBoundary)
#endif //DEBUG

//---[ CDSNGenerator::CDSNGenerator ]--------------------------------------
//
//
//  Description:
//      CDSNGenerator constructor
//  Parameters:
//      -
//  Returns:
//
//  History:
//      6/30/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDSNGenerator::CDSNGenerator(
    IUnknown *pUnk) :
    m_CDefaultDSNSink(pUnk)
{
    m_dwSignature = DSN_SINK_SIG;
}

//---[ CDSNGenerator::~CDSNGenerator ]-------------------------------------
//
//
//  Description:
//
//  Parameters:
//
//  Returns:
//
//  History:
//      2/11/99 - MikeSwa Created
//
//-----------------------------------------------------------------------------
CDSNGenerator::~CDSNGenerator()
{
    m_dwSignature = DSN_SINK_SIG_FREED;

}

//---[ CDSNGenerator::GenerateDSN ]------------------------------------------
//
//
//  Description:
//      Implements GenerateDSN.  Generates a DSN
//      IMailMsgProperties and
//  Parameters:
//      pIServerEvent           Interface for triggering events
//      dwVSID                  VSID for this server
//      pISMTPServer            Interface used to generate DSN
//      pIMailMsgProperties     IMailMsg to generate DSN for
//      dwStartDomain           Domain to start recip context
//      dwDSNActions            DSN action to perform
//      dwRFC821Status          Global RFC821 status DWORD
//      hrStatus                Global HRESULT status
//      szDefaultDomain         Default domain (used to create FROM address)
//      szReportingMTA          Name of MTA requesting DSN generation
//      szReportingMTAType      Type of MTA requestiong DSN (SMTP is "dns"
//      PreferredLangId         Language to generate DSN in
//      dwDSNOptions            Options flags as defined in aqueue.idl
//      szCopyNDRTo             SMTP Address to copy NDR to
//      pIDSNSubmission         Interface for submitting DSNs
//      dwMaxDSNSize            Return HDRS by default for messages
//                              larger than this
//
//  Returns:
//      S_OK on success
//      AQUEUE_E_NDR_OF_DSN if attempting to NDR a DSN
//      E_OUTOFMEMORY
//      error from mailmsg
//  History:
//      6/30/98 - MikeSwa Created
//      12/14/98 - MikeSwa Modified (Added pcIterationsLeft)
//      10/13/1999 - MikeSwa Modified (Added szDefaultDomain)
//      5/10/2001 - jstamerj Modified for server events
//
//
//-----------------------------------------------------------------------------
STDMETHODIMP CDSNGenerator::GenerateDSN(
    IAQServerEvent *pIServerEvent,
    DWORD dwVSID,
    ISMTPServer *pISMTPServer,
    IMailMsgProperties *pIMailMsgProperties,
    DWORD dwStartDomain,
    DWORD dwDSNActions,
    DWORD dwRFC821Status,
    HRESULT hrStatus,
    LPSTR szDefaultDomain,
    LPSTR szReportingMTA,
    LPSTR szReportingMTAType,
    LPSTR szDSNContext,
    DWORD dwPreferredLangId,
    DWORD dwDSNOptions,
    LPSTR szCopyNDRTo,
    FILETIME *pftExpireTime,
    IDSNSubmission *pIAQDSNSubmission,
    DWORD dwMaxDSNSize)
{
    HRESULT hr = S_OK;
    HRESULT hrReturn = S_OK;
    DWORD dwCount = 0;
    DWORD fBadmailMsg = FALSE;
    IDSNRecipientIterator *pIRecipIter = NULL;
    CDSNPool *pDSNPool = NULL;
    CDefaultDSNRecipientIterator *pDefaultRecipIter = NULL;
    CPostDSNHandler *pPostDSNHandler = NULL;
    CMailMsgPropertyBag *pPropBag = NULL;

    TraceFunctEnterEx((LPARAM) this, "CDSNGenerator::GenerateDSN");
    //
    // Parameter -> Property mapping tables
    //
    struct _tagDWORDProps
    {
        DWORD dwPropId;
        DWORD dwValue;
    } DsnDwordProps[] =
      {
          { DSNPROP_DW_DSNACTIONS,        dwDSNActions },
          { DSNPROP_DW_DSNOPTIONS,        dwDSNOptions },
          { DSNPROP_DW_RFC821STATUS,      dwRFC821Status },
          { DSNPROP_DW_HRSTATUS,          (DWORD) hrStatus },
          { DSNPROP_DW_LANGID,            dwPreferredLangId },
      };
    struct _tagStringProps
    {
        DWORD dwPropId;
        LPSTR psz;
    } DsnStringProps[] =
      {
          { DSNPROP_SZ_DEFAULTDOMAIN,     szDefaultDomain },
          { DSNPROP_SZ_REPORTINGMTA,      szReportingMTA },
          { DSNPROP_SZ_REPORTINGMTATYPE,  szReportingMTAType },
          { DSNPROP_SZ_DSNCONTEXT,        szDSNContext },
          { DSNPROP_SZ_COPYNDRTO,         szCopyNDRTo },
      };
    pDSNPool = new CDSNPool(
        this,
        pIServerEvent,
        dwVSID,
        pISMTPServer,
        pIMailMsgProperties,
        pIAQDSNSubmission,
        &m_CDefaultDSNSink);
    if(pDSNPool == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    pDefaultRecipIter = pDSNPool->GetDefaultIter();
    pPostDSNHandler = pDSNPool->GetPostDSNHandler();
    pPropBag = pDSNPool->GetDSNProperties();

    pPostDSNHandler->SetPropInterface(
        pPropBag);

    for(dwCount = 0;
        dwCount < ( sizeof(DsnDwordProps) / sizeof(DsnDwordProps[0]));
        dwCount++)
    {
        hr = pPropBag->PutDWORD(
            DsnDwordProps[dwCount].dwPropId,
            DsnDwordProps[dwCount].dwValue);
        if(FAILED(hr))
            goto CLEANUP;
    }
    for(dwCount = 0;
        dwCount < ( sizeof(DsnStringProps) / sizeof(DsnStringProps[0]));
        dwCount++)
    {
        if(DsnStringProps[dwCount].psz)
        {
            hr = pPropBag->PutStringA(
                DsnStringProps[dwCount].dwPropId,
                DsnStringProps[dwCount].psz);
            if(FAILED(hr))
                goto CLEANUP;
        }
    }
    //
    //Set MsgExpire Time
    //
    if(pftExpireTime)
    {
        hr = pPropBag->PutProperty(
            DSNPROP_FT_EXPIRETIME,
            sizeof(FILETIME),
            (PBYTE) pftExpireTime);
        if(FAILED(hr))
            goto CLEANUP;
    }
    //
    //Set the return type
    //
    hr = HrSetRetType(
        dwMaxDSNSize,
        pIMailMsgProperties,
        pPropBag);
    if(FAILED(hr))
        goto CLEANUP;

    hr = pDefaultRecipIter->HrInit(
        pIMailMsgProperties,
        dwStartDomain,
        dwDSNActions);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "DefaultRecipIter.HrInit failed hr %08lx", hr);
        goto CLEANUP;
    }
    pIRecipIter = pDefaultRecipIter;
    pIRecipIter->AddRef();
    //
    // Trigger events
    //
    hr = HrTriggerGetDSNRecipientIterator(
        pIServerEvent,
        dwVSID,
        pISMTPServer,
        pIMailMsgProperties,
        pPropBag,
        dwStartDomain,
        dwDSNActions,
        &pIRecipIter);
    if(FAILED(hr))
        goto CLEANUP;

    hr = HrTriggerGenerateDSN(
        pIServerEvent,
        dwVSID,
        pISMTPServer,
        pPostDSNHandler,
        pIMailMsgProperties,
        pPropBag,
        pIRecipIter);
    if(FAILED(hr))
        goto CLEANUP;

    //
    // Check sink's indicated return status
    //
    hr = pPropBag->GetDWORD(
        DSNPROP_DW_HR_RETURN_STATUS,
        (DWORD *) &hrReturn);
    if(hr == MAILMSG_E_PROPNOTFOUND)
    {
        //
        // If the property is not set, this indicates no error
        //
        hrReturn = S_OK;

    } else if(FAILED(hr))
        goto CLEANUP;

    DebugTrace((LPARAM)this, "Sink return status: %08lx", hrReturn);
    hr = hrReturn;
    if(FAILED(hr))
        goto CLEANUP;

    hr = pPropBag->GetBool(
        DSNPROP_F_BADMAIL_MSG,
        &fBadmailMsg);
    if(hr == MAILMSG_E_PROPNOTFOUND)
    {
        fBadmailMsg = FALSE;
        hr = S_OK;
    }
    else if(FAILED(hr))
        goto CLEANUP;

    if(fBadmailMsg)
        hr = AQUEUE_E_NDR_OF_DSN;

 CLEANUP:
    //
    // Sinks should not be submitting DSNs after the event has been
    // completed.  This is not supported and would be bad because the
    // object that implements pIAQDSNSubmission is allocated on the
    // stack.  Release this interface pointer here.
    //
    if(pPostDSNHandler)
        pPostDSNHandler->ReleaseAQDSNSubmission();

    if(pIRecipIter)
        pIRecipIter->Release();
    if(pDSNPool)
        pDSNPool->Release();

    DebugTrace((LPARAM)this, "returning hr %08lx", hr);
    TraceFunctLeave();
    return SUCCEEDED(hr) ? S_OK : hr;
}



//+------------------------------------------------------------
//
// Function: CDSNGenerator::HrSetRetType
//
// Synopsis: Set the (default) return type property in the DSN
// property bag
//
// Arguments:
//  dwMaxDSNSize: Messages larger than this will default to RET=HDRS
//  pIMsg: Mailmsg ptr
//  pDSNProps: DSN property bag
//
// Returns:
//  S_OK: Success
//  error from mailmsg
//
// History:
// jstamerj 2001/06/14 17:12:50: Created.
//
//-------------------------------------------------------------
HRESULT CDSNGenerator::HrSetRetType(
    IN  DWORD dwMaxDSNSize,
    IN  IMailMsgProperties *pIMsg,
    IN  IMailMsgPropertyBag *pDSNProps)
{
    HRESULT hr = S_OK;
    DWORD dwRetType = 0;
    DWORD dwMsgSize = 0;
    CHAR    szRET[] = "FULL";
    TraceFunctEnterEx((LPARAM)this, "CDSNGenerator::HrSetRetType");
    //
    //Determine if we want to return the full message or minimal headers.
    //The logic for this is:
    //  - Obey explicit RET (IMMPID_MP_DSN_RET_VALUE) values
    //  - Default to HDRS for all DSNs greater than a specified size
    //  - Do not set the property otherwise (let the sinks decide)
    //
    hr = pIMsg->GetStringA(
        IMMPID_MP_DSN_RET_VALUE, 
        sizeof(szRET),
        szRET);

    if (SUCCEEDED(hr))
    {
        if(!_strnicmp(szRET, (char * )"FULL", 4))
            dwRetType = DSN_RET_FULL;
        else if (!_strnicmp(szRET, (char * )"HDRS", 4))
            dwRetType = DSN_RET_HDRS;
    }
    else if(hr != MAILMSG_E_PROPNOTFOUND)
        goto CLEANUP;

    if(dwRetType)
    {
        DebugTrace((LPARAM)this, "DSN Return value specified: %s", szRET);
        goto CLEANUP;
    }

    if(dwMaxDSNSize)
    {
        //
        // Check the original message size
        //
        hr = pIMsg->GetDWORD(
            IMMPID_MP_MSG_SIZE_HINT,
            &dwMsgSize);
        if(hr == MAILMSG_E_PROPNOTFOUND)
        {
            hr = pIMsg->GetContentSize(
                &dwMsgSize, 
                NULL);
            if(FAILED(hr))
            {
                //
                // Assume a failure here means we don't have the resources
                // to get the original message content.
                // Rather than badmailing, generate a DSN with headers only
                //
                ErrorTrace((LPARAM)this, "GetContentSize failed hr %08lx", hr);
                hr = pDSNProps->PutDWORD(
                    DSNPROP_DW_CONTENT_FAILURE,
                    hr);
                if(FAILED(hr))
                    goto CLEANUP;

                dwRetType = DSN_RET_PARTIAL_HDRS;
                goto CLEANUP;
            }
        }
        else if(FAILED(hr))
            goto CLEANUP;

        if(dwMsgSize > dwMaxDSNSize)
        {
            //
            // Return a subset of the headers (so that we do not have to
            // generate the original message
            //
            dwRetType = DSN_RET_PARTIAL_HDRS;
        }
    }
    else
    {
        //
        // MaxDSNSize is zero.  Always default to header subset.
        //
        dwRetType = DSN_RET_PARTIAL_HDRS;
    }
    hr = S_OK;

 CLEANUP:
    if(dwRetType)
    {
        DebugTrace((LPARAM)this, "dwRetType: %08lx", dwRetType);
        hr = pDSNProps->PutDWORD(
            DSNPROP_DW_RET_TYPE,
            dwRetType);
    }
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return SUCCEEDED(hr) ? S_OK : hr;
} // CDSNGenerator::HrSetRetType


//+------------------------------------------------------------
//
// Function: CDSNGenerator::HrTriggerGetDSNRecipientIterator
//
// Synopsis: Trigger the server event
//
// Arguments: see ptntintf.idl
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/12/11 17:01:12: Created.
//
//-------------------------------------------------------------
HRESULT CDSNGenerator::HrTriggerGetDSNRecipientIterator(
    IAQServerEvent *pIServerEvent,
    DWORD dwVSID,
    ISMTPServer *pISMTPServer,
    IMailMsgProperties *pIMsg,
    IMailMsgPropertyBag *pIDSNProperties,
    DWORD dwStartDomain,
    DWORD dwDSNActions,
    IDSNRecipientIterator **ppIRecipIterator)
{
    HRESULT hr = S_OK;
    EVENTPARAMS_GET_DSN_RECIPIENT_ITERATOR EventParams;
    TraceFunctEnterEx((LPARAM)this, "CDSNGenerator::HrTriggerGetDSNRecipientIterator");

    EventParams.dwVSID = dwVSID;
    EventParams.pISMTPServer = pISMTPServer;
    EventParams.pIMsg = pIMsg;
    EventParams.pDSNProperties = pIDSNProperties;
    EventParams.dwStartDomain = dwStartDomain;
    EventParams.dwDSNActions = dwDSNActions;
    EventParams.pRecipIter = *ppIRecipIterator;

    hr = pIServerEvent->TriggerServerEvent(
        SMTP_GET_DSN_RECIPIENT_ITERATOR_EVENT,
        &EventParams);
    if(FAILED(hr))
        goto CLEANUP;

    *ppIRecipIterator = EventParams.pRecipIter;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDSNGenerator::HrTriggerGetDSNRecipientIterator


//+------------------------------------------------------------
//
// Function: CDSNGenerator::HrTriggerGenerateDSN
//
// Synopsis: Trigger the server event
//
// Arguments: See ptntintf.idl
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/12/11 17:10:26: Created.
//
//-------------------------------------------------------------
HRESULT CDSNGenerator::HrTriggerGenerateDSN(
    IAQServerEvent *pIServerEvent,
    DWORD dwVSID,
    ISMTPServer *pISMTPServer,
    IDSNSubmission *pIDSNSubmission,
    IMailMsgProperties *pIMsg,
    IMailMsgPropertyBag *pIDSNProperties,
    IDSNRecipientIterator *pIRecipIterator)
{
    HRESULT hr = S_OK;
    EVENTPARAMS_GENERATE_DSN EventParams;
    TraceFunctEnterEx((LPARAM)this, "CDSNGenerator::HrTriggerGenerateDSN");

    EventParams.dwVSID = dwVSID;
    EventParams.pDefaultSink = &m_CDefaultDSNSink;
    EventParams.pISMTPServer = pISMTPServer;
    EventParams.pIDSNSubmission = pIDSNSubmission;
    EventParams.pIMsg = pIMsg;
    EventParams.pDSNProperties = pIDSNProperties;
    EventParams.pRecipIter = pIRecipIterator;

    hr = pIServerEvent->TriggerServerEvent(
        SMTP_GENERATE_DSN_EVENT,
        &EventParams);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "HrTriggerServerEvent failed hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDSNGenerator::HrTriggerGenerateDSN


//+------------------------------------------------------------
//
// Function: CDSNGenerator::HrTriggerPostGenerateDSN
//
// Synopsis: Triggers the server event
//
// Arguments: See ptntintf.idl
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/12/11 17:18:17: Created.
//
//-------------------------------------------------------------
HRESULT CDSNGenerator::HrTriggerPostGenerateDSN(
    IAQServerEvent *pIServerEvent,
    DWORD dwVSID,
    ISMTPServer *pISMTPServer,
    IMailMsgProperties *pIMsgOrig,
    DWORD dwDSNAction,
    DWORD cRecipsDSNd,
    IMailMsgProperties *pIMsgDSN,
    IMailMsgPropertyBag *pIDSNProperties)
{
    HRESULT hr = S_OK;
    EVENTPARAMS_POST_GENERATE_DSN EventParams;
    TraceFunctEnterEx((LPARAM)this, "CDSNGenerator::HrTriggerPostGenerateDSN");

    EventParams.dwVSID = dwVSID;
    EventParams.pISMTPServer = pISMTPServer;
    EventParams.pIMsgOrig = pIMsgOrig;
    EventParams.dwDSNAction = dwDSNAction;
    EventParams.cRecipsDSNd = cRecipsDSNd;
    EventParams.pIMsgDSN = pIMsgDSN;
    EventParams.pIDSNProperties = pIDSNProperties;

    hr = pIServerEvent->TriggerServerEvent(
        SMTP_POST_DSN_EVENT,
        &EventParams);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "HrTriggerServerEvent failed hr %08lx", hr);
        goto CLEANUP;
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDSNGenerator::HrTriggerPostGenerateDSN


//---[ FileTimeToLocalRFC822Date ]---------------------------------------------
//
//
//  Description:
//      Converts filetime to RFC822 compliant date
//  Parameters:
//      ft          Filetime to generate date for
//      achReturn   Buffer for filetime
//  Returns:
//     BOOL - success or not
//  History:
//      8/19/98 - MikeSwa Modified from various timeconv.cxx functions written
//                  by      Lindsay Harris  - lindasyh
//                          Carl Kadie [carlk]
//
//-----------------------------------------------------------------------------
BOOL FileTimeToLocalRFC822Date(const FILETIME & ft, char achReturn[MAX_RFC822_DATE_SIZE])
{
    TraceFunctEnterEx((LPARAM)0, "FileTimeToLocalRFC822Date");
    FILETIME ftLocal;
    SYSTEMTIME  st;
    char    chSign;                         // Sign to print.
    DWORD   dwResult;
    int     iBias;                          // Offset relative to GMT.
    TIME_ZONE_INFORMATION   tzi;            // Local time zone data.
    BOOL bReturn = FALSE;

    dwResult = GetTimeZoneInformation( &tzi );

    _ASSERT(achReturn); //real assert

    achReturn[0]='\0';
    if (!FileTimeToLocalFileTime(&ft, &ftLocal))
    {
        ErrorTrace((LPARAM)0, "FileTimeToLocalFileTime failed - %x", GetLastError());
        bReturn = FALSE;
        goto Exit;
    }

    if (!FileTimeToSystemTime(&ftLocal, &st))
    {
        ErrorTrace((LPARAM)0, "FileTimeToSystemTime failed - %x", GetLastError());
        bReturn = FALSE;
        goto Exit;
    }
    //  Calculate the time zone offset.
    iBias = tzi.Bias;
    if( dwResult == TIME_ZONE_ID_DAYLIGHT )
        iBias += tzi.DaylightBias;

    /*
     *   We always want to print the sign for the time zone offset, so
     *  we decide what it is now and remember that when converting.
     *  The convention is that west of the 0 degree meridian has a
     *  negative offset - i.e. add the offset to GMT to get local time.
     */

    if( iBias > 0 )
    {
        chSign = '-';       // Yes, I do mean negative.
    }
    else
    {
        iBias = -iBias;
        chSign = '+';
    }

    /*
     *    No major trickery here.  We have all the data, so simply
     *  format it according to the rules on how to do this.
     */

    wsprintf( achReturn, "%s, %d %s %04d %02d:%02d:%02d %c%02d%02d",
              s_rgszWeekDays[st.wDayOfWeek],
              st.wDay, s_rgszMonth[ st.wMonth - 1 ],
              st.wYear,
              st.wHour, st.wMinute, st.wSecond, chSign,
              (iBias / 60) % 100, iBias % 60 );

    _ASSERT(lstrlen(achReturn) < MAX_RFC822_DATE_SIZE);
    bReturn = TRUE;
Exit:
    TraceFunctLeaveEx((LPARAM)0);    
    return bReturn;

}


//+------------------------------------------------------------
//
// Function: CDefaultDSNRecipientIterator::Init
//
// Synopsis: Constructor.  Initializes member variables.
//
// Arguments:
//  pIMsg: Mailmsg interface
//  dwStartDomain: First domain of recipient enumeration
//  dwDSNActions: The DSN actions to perform
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/11/09 14:18:45: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNRecipientIterator::HrInit(
    IN  IMailMsgProperties          *pIMsg,
    IN  DWORD                        dwStartDomain,
    IN  DWORD                        dwDSNActions)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNRecipientIterator::Init");

    TerminateFilter();
    if(m_pIRecips)
    {
        m_pIRecips->Release();
        m_pIRecips = NULL;
    }

    m_dwStartDomain = dwStartDomain;
    m_dwDSNActions = dwDSNActions;

    hr = pIMsg->QueryInterface(
        IID_IMailMsgRecipients,
        (LPVOID *) &m_pIRecips);

    _ASSERT(SUCCEEDED(hr));
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "QI failed %08lx", hr);
        goto CLEANUP;
    }

    hr = HrReset();
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "HrReset failed %08lx", hr);
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNRecipientIterator::HrInit



//+------------------------------------------------------------
//
// Function: CDefaultDSNRecipientIterator::~CDefaultDSNRecipientIterator
//
// Synopsis: Destructor.  Cleanup
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 2000/11/09 18:42:32: Created.
//
//-------------------------------------------------------------
CDefaultDSNRecipientIterator::~CDefaultDSNRecipientIterator()
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNRecipientIterator::~CDefaultDSNRecipientIterator");

    TerminateFilter();
    if(m_pIRecips)
        m_pIRecips->Release();

    _ASSERT(m_dwSig == RECIPITER_SIG);
    m_dwSig = RECIPITER_SIG_INVALID;
    TraceFunctLeaveEx((LPARAM)this);
} // CDefaultDSNRecipientIterator::~CDefaultDSNRecipientIterator



//+------------------------------------------------------------
//
// Function: CDefaultDSNRecipientIterator::QueryInterface
//
// Synopsis: Return requested interface
//
// Arguments:
//  riid: Interface ID
//  ppvObj: Out paramter for itnerface
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/11/09 14:25:39: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNRecipientIterator::QueryInterface(
    IN  REFIID  riid,
    OUT LPVOID *ppvObj)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNRecipientIterator::QueryInterface");
    _ASSERT(ppvObj);

    *ppvObj = NULL;

    if(riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else if(riid == IID_IDSNRecipientIterator)
    {
        *ppvObj = (IDSNRecipientIterator *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if(SUCCEEDED(hr))
        AddRef();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNRecipientIterator::QueryInterface


//+------------------------------------------------------------
//
// Function: CDefaultDSNRecipientIterator::HrReset
//
// Synopsis: Reset recipent iteration
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/11/09 14:32:04: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNRecipientIterator::HrReset()
{
    HRESULT hr = S_OK;
    DWORD dwRecipFilterMask = 0;
    DWORD dwRecipFilterFlags = 0;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNRecipientIterator::HrReset");

    GetFilterMaskAndFlags(
        m_dwDSNActions,
        &dwRecipFilterMask,
        &dwRecipFilterFlags);

    TerminateFilter();

    hr = m_pIRecips->InitializeRecipientFilterContext(
        &m_rpfctxt,
        m_dwStartDomain,
        dwRecipFilterFlags,
        dwRecipFilterMask);
    if (FAILED(hr))
        goto CLEANUP;

    m_fFilterInit = TRUE;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNRecipientIterator::HrReset

//---[ CDefaultDSNRecipientIterator::GetFilterMaskAndFlags ]-------------------
//
//
//  Description:
//      Determines what the appropriate mask and flags for a recip serch filter
//      are based on the given actions.
//
//      It may not be possible to constuct a perfectly optimal search (ie Failed
//      and delivered).... this function will attempt to find the "most optimal"
//      search possible.
//  Parameters:
//      dwDSNActions        Requested DSN generation operations
//      pdwRecipMask        Mask to pass to InitializeRecipientFilterContext
//      pdwRecipFlags       Flags to pass to InitializeRecipientFilterContext
//  Returns: Nothing
//  History:
//      7/1/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDefaultDSNRecipientIterator::GetFilterMaskAndFlags(
    IN DWORD dwDSNActions,
    OUT DWORD *pdwRecipMask,
    OUT DWORD *pdwRecipFlags)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNRecipientIterator::HrGetFilterMaskAndFlags");
    _ASSERT(pdwRecipMask);
    _ASSERT(pdwRecipFlags);

    //in general we are only interested in un-DSN'd recipients
    *pdwRecipFlags  = 0x00000000;
    *pdwRecipMask   = RP_DSN_HANDLED | RP_DSN_NOTIFY_NEVER;


    //Note these searches are just optimizations... so we don't look at
    //recipients we don't need to.  However, it may not be possible to
    //limit the search precisely
    if (DSN_ACTION_FAILURE == dwDSNActions)
    {
        //We are interested in hard failures
        *pdwRecipMask |= RP_GENERAL_FAILURE;
        *pdwRecipFlags |= RP_GENERAL_FAILURE;
    }

    if (!((DSN_ACTION_DELIVERED | DSN_ACTION_RELAYED) & dwDSNActions))
    {
        //are not interested in delivered
        if ((DSN_ACTION_FAILURE_ALL | DSN_ACTION_DELAYED) & dwDSNActions)
        {
            //it is safe to check only undelivered
            *pdwRecipMask |= (RP_DELIVERED ^ RP_HANDLED); //must be un-set
            _ASSERT(!(*pdwRecipFlags & (RP_DELIVERED ^ RP_HANDLED)));
        }
    }
    else
    {
        //$$TODO - can narrow this search more
        //we are interested in delivered
        if (!((DSN_ACTION_FAILURE_ALL | DSN_ACTION_FAILURE| DSN_ACTION_DELAYED)
            & dwDSNActions))
        {
            //it is safe to check only delivered
            *pdwRecipMask |= RP_DELIVERED;
            *pdwRecipFlags |= RP_DELIVERED;
        }
    }

    DebugTrace((LPARAM) this,
        "DSN Action 0x%08X, Recip mask 0x%08X, Recip flags 0x%08X",
        dwDSNActions, *pdwRecipMask, *pdwRecipFlags);
    TraceFunctLeave();
}


//+------------------------------------------------------------
//
// Function: CDefaultDSNRecipientIterator::HrGetNextRecipient
//
// Synopsis: Returns the next recipient for wich a DSN action should
//           be taken.
//
// Arguments:
//  piRecipient: Receives next recipient index
//  pdwDSNAction: Receives DSN Action(s) that should be taken
//
// Returns:
//  S_OK: Success
//  HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)
//  E_UNEXPECTED: Need to call HrReset first.
//
// History:
// jstamerj 2000/11/09 15:30:17: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNRecipientIterator::HrGetNextRecipient(
    OUT DWORD *piRecipient,
    OUT DWORD *pdwDSNAction)
{
    HRESULT hr = S_OK;
    DWORD iCurrentRecip = 0;
    DWORD dwCurrentRecipFlags = 0;
    DWORD dwCurrentDSNAction = 0;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNRecipientIterator::HrGetNextRecipient");

    if((piRecipient == NULL) ||
       (pdwDSNAction == NULL))
    {
        hr = E_INVALIDARG;
        goto CLEANUP;
    }

    if(! m_fFilterInit)
    {
        hr = E_UNEXPECTED;
        goto CLEANUP;
    }

    while(SUCCEEDED(hr) && (dwCurrentDSNAction == 0))
    {
        hr = m_pIRecips->GetNextRecipient(&m_rpfctxt, &iCurrentRecip);
        if(FAILED(hr))
            goto CLEANUP;

        hr = m_pIRecips->GetDWORD(
            iCurrentRecip,
            IMMPID_RP_RECIPIENT_FLAGS,
            &dwCurrentRecipFlags);
        if(hr == MAILMSG_E_PROPNOTFOUND)
        {
            dwCurrentRecipFlags = 0;
        }
        else if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                       "Failure 0x%08X to get flags for recip %d",
                       hr, iCurrentRecip);
            goto CLEANUP;
        }

        DebugTrace((LPARAM) this,
                   "Recipient %d with flags 0x%08X found",
                   iCurrentRecip, dwCurrentRecipFlags);

        GetDSNAction(
            m_dwDSNActions,
            dwCurrentRecipFlags,
            &dwCurrentDSNAction);
    }
    if(SUCCEEDED(hr))
    {
        *pdwDSNAction = dwCurrentDSNAction;
        *piRecipient = iCurrentRecip;
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNRecipientIterator::HrGetNextRecipient



//---[ CDefaultDSNRecipientIterator::GetDSNAction ]-------------------------
//
//
//  Description:
//      Determines what DSN action needs to happen on a recipient based on
//      the requested DSN actions and the recipient flags
//  Parameters:
//      IN     dwDSNAction          The requested DSN actions
//      IN     dwCurrentRecipFlags The flags for current recipient...
//      OUT    pdwCurrentDSNAction  The DSN action that needs to be performed
//                                  On this recipient (DSN_ACTION_FAILURE is
//                                  used to denote sending a NDR)
//  Returns: Nothing
//  History:
//      7/2/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
VOID CDefaultDSNRecipientIterator::GetDSNAction(
    IN  DWORD dwDSNAction,
    IN  DWORD dwCurrentRecipFlags,
    OUT DWORD *pdwCurrentDSNAction)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNRecipientIterator::fdwGetDSNAction");
    _ASSERT(pdwCurrentDSNAction);
    DWORD   dwOriginalRecipFlags = dwCurrentRecipFlags;
    DWORD   dwRecipFlagsForAction = 0;
    DWORD   dwFlags = 0;

    //This should never be hit because of the filter
    _ASSERT(!(dwCurrentRecipFlags & (RP_DSN_HANDLED | RP_DSN_NOTIFY_NEVER)));

    *pdwCurrentDSNAction = 0;

    if (DSN_ACTION_FAILURE & dwDSNAction)
    {
        if ((RP_GENERAL_FAILURE & dwCurrentRecipFlags) &&
            ((RP_DSN_NOTIFY_FAILURE & dwCurrentRecipFlags) ||
             (!(RP_DSN_NOTIFY_MASK & dwCurrentRecipFlags))))

        {
            DebugTrace((LPARAM) this, "Recipient matched for FAILURE DSN");
            // Recip flags will be updated in HrNotifyActionHandled
            // dwCurrentRecipFlags |= RP_DSN_SENT_NDR;
            *pdwCurrentDSNAction = DSN_ACTION_FAILURE;
            goto Exit;
        }
    }

    if (DSN_ACTION_FAILURE_ALL & dwDSNAction)
    {
        //Fail all non-delivered that we haven't sent notifications for
        if (((!((RP_DSN_HANDLED | (RP_DELIVERED ^ RP_HANDLED)) & dwCurrentRecipFlags))) &&
            ((RP_DSN_NOTIFY_FAILURE & dwCurrentRecipFlags) ||
             (!(RP_DSN_NOTIFY_MASK & dwCurrentRecipFlags))))
        {
            //Don't send failures for expanded DL;s
            if (RP_EXPANDED != (dwCurrentRecipFlags & RP_EXPANDED))
            {
                DebugTrace((LPARAM) this, "Recipient matched for FAILURE (all) DSN");
                // dwCurrentRecipFlags |= RP_DSN_SENT_NDR;
                *pdwCurrentDSNAction = DSN_ACTION_FAILURE_ALL;
                goto Exit;
            }
        }
    }

    if (DSN_ACTION_DELAYED & dwDSNAction)
    {
        //send at most 1 delay DSN
        //Also send only if DELAY was requested or no specific instructions were
        //specified
        if ((!((RP_DSN_SENT_DELAYED | RP_HANDLED) & dwCurrentRecipFlags)) &&
            ((RP_DSN_NOTIFY_DELAY & dwCurrentRecipFlags) ||
             (!(RP_DSN_NOTIFY_MASK & dwCurrentRecipFlags))))
        {
            DebugTrace((LPARAM) this, "Recipient matched for DELAYED DSN");
            // dwCurrentRecipFlags |= RP_DSN_SENT_DELAYED;
            *pdwCurrentDSNAction = DSN_ACTION_DELAYED;
            goto Exit;
        }
    }

    if (DSN_ACTION_RELAYED & dwDSNAction)
    {
        //send relay if it was delivered *and* DSN not supported by remote MTA
        //*and* notification of success was explicitly requested
        dwFlags = (RP_DELIVERED ^ RP_HANDLED) |
                   RP_REMOTE_MTA_NO_DSN |
                   RP_DSN_NOTIFY_SUCCESS;
        if ((dwFlags & dwCurrentRecipFlags) == dwFlags)
        {
            DebugTrace((LPARAM) this, "Recipient matched for RELAYED DSN");
            // dwCurrentRecipFlags |= RP_DSN_SENT_RELAYED;
            *pdwCurrentDSNAction = DSN_ACTION_RELAYED;
            goto Exit;
        }
    }

    if (DSN_ACTION_DELIVERED & dwDSNAction)
    {
        //send delivered if it was delivered *and* no DSN sent yet
        dwFlags = (RP_DELIVERED ^ RP_HANDLED) | RP_DSN_NOTIFY_SUCCESS;
        _ASSERT(!(dwCurrentRecipFlags & RP_DSN_HANDLED)); //should be filtered out
        if ((dwFlags & dwCurrentRecipFlags) == dwFlags)
        {
            DebugTrace((LPARAM) this, "Recipient matched for SUCCESS DSN");
            // dwCurrentRecipFlags |= RP_DSN_SENT_DELIVERED;
            *pdwCurrentDSNAction = DSN_ACTION_DELIVERED;
            goto Exit;
        }
    }

    if (DSN_ACTION_EXPANDED & dwDSNAction)
    {
        //Send expanded if the recipient is marked as expanded and
        //NOTIFY=SUCCESS was requested
        if ((RP_EXPANDED == (dwCurrentRecipFlags & RP_EXPANDED)) &&
            (dwCurrentRecipFlags & RP_DSN_NOTIFY_SUCCESS) &&
            !(dwCurrentRecipFlags & RP_DSN_SENT_EXPANDED))
        {
            DebugTrace((LPARAM) this, "Recipient matched for EXPANDED DSN");
            // dwCurrentRecipFlags |= RP_DSN_SENT_EXPANDED;
            *pdwCurrentDSNAction = DSN_ACTION_EXPANDED;
            goto Exit;
        }
    }

  Exit:
    GetRecipientFlagsForActions(
        *pdwCurrentDSNAction,
        &dwRecipFlagsForAction);

    TraceFunctLeave();
}



//+------------------------------------------------------------
//
// Function: CDefaultDSNRecipientIterator::HrNotifyActionHandled
//
// Synopsis: Notifies that particular DSN(s) have been generated.
// Sets recipient flags so that recipient will not be enumerated again.
//
// Arguments:
//  iRecipient: Recip index
//  dwDSNAction: The action(s) performed
//
// Returns:
//  S_OK: Success
//  error from mailmsg
//
// History:
// jstamerj 2000/11/09 18:26:50: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNRecipientIterator::HrNotifyActionHandled(
    IN  DWORD iRecipient,
    IN  DWORD dwDSNAction)
{
    HRESULT hr = S_OK;
    DWORD dwRecipFlags = 0;
    DWORD dwNewRecipFlags = 0;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNRecipientIterator::HrNotifyActionHandled");

    hr = m_pIRecips->GetDWORD(
        iRecipient,
        IMMPID_RP_RECIPIENT_FLAGS,
        &dwRecipFlags);
    if(hr == MAILMSG_E_PROPNOTFOUND)
    {
        dwRecipFlags = 0;
    }
    else if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "m_pIRecips->GetDWORD failed");
        goto CLEANUP;
    }

    GetRecipientFlagsForActions(
        dwDSNAction,
        &dwNewRecipFlags);

    DebugTrace((LPARAM)this, "Orig recip flags: %08lx", dwRecipFlags);
    dwRecipFlags |= dwNewRecipFlags;

    hr = m_pIRecips->PutDWORD(
        iRecipient,
        IMMPID_RP_RECIPIENT_FLAGS,
        dwRecipFlags);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "m_pIRecips->PutDWORD failed hr %08lx", hr);
        goto CLEANUP;
    }
    DebugTrace((LPARAM)this, "New  recip flags: %08lx", dwRecipFlags);

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNRecipientIterator::HrNotifyActionHandled




//+------------------------------------------------------------
//
// Function: CDefaultDSNRecipientIterator::GetRecipientFlagsForActions
//
// Synopsis: Get mailmsg recipient flags corresponding to an action
//
// Arguments:
//  dwDSNAction: Action in question
//  pdwRecipientFlags: Recip flags
//
// Returns: Nothing
//
// History:
// jstamerj 2000/11/09 16:18:34: Created.
//
//-------------------------------------------------------------
VOID CDefaultDSNRecipientIterator::GetRecipientFlagsForActions(
    IN      DWORD dwDSNAction,
    OUT     DWORD *pdwRecipientFlags)
{
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNRecipientIterator::GetRecipientFlagsForActions");


    *pdwRecipientFlags = 0;

    if(dwDSNAction & (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL))
    {
        *pdwRecipientFlags |= RP_DSN_SENT_NDR;
    }
    if(dwDSNAction & DSN_ACTION_DELAYED)
    {
        *pdwRecipientFlags |= RP_DSN_SENT_DELAYED;
    }
    if(dwDSNAction & DSN_ACTION_RELAYED)
    {
        *pdwRecipientFlags |= RP_DSN_SENT_RELAYED;
    }
    if(dwDSNAction & DSN_ACTION_DELIVERED)
    {
        *pdwRecipientFlags |= RP_DSN_SENT_DELIVERED;
    }
    if(dwDSNAction & DSN_ACTION_EXPANDED)
    {
        *pdwRecipientFlags |= RP_DSN_SENT_EXPANDED;
    }

    DebugTrace((LPARAM)this, "dwDSNAction:        %08lx", dwDSNAction);
    DebugTrace((LPARAM)this, "*pdwRecipientFlags: %08lx", *pdwRecipientFlags);
    TraceFunctLeaveEx((LPARAM)this);
} // CDefaultDSNRecipientIterator::GetRecipientFlagsForActions


//+------------------------------------------------------------
//
// Function: CDefaultDSNRecipientIterator::TermianteFilter
//
// Synopsis: Terminate the mailmsg filter
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 2000/11/14 14:14:59: Created.
//
//-------------------------------------------------------------
VOID CDefaultDSNRecipientIterator::TerminateFilter()
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNRecipientIterator::TermianteFilter");

    if(m_fFilterInit)
    {
        //recycle context
        m_fFilterInit = FALSE;
        hr = m_pIRecips->TerminateRecipientFilterContext(&m_rpfctxt);
        _ASSERT(SUCCEEDED(hr) && "TerminateRecipientFilterContext FAILED!!!!");
    }

    TraceFunctLeaveEx((LPARAM)this);
} // CDefaultDSNRecipientIterator::TermianteFilter


//+------------------------------------------------------------
//
// Function: CDefaultDSNSink::CDefaultDSNSink
//
// Synopsis: Constructor; initialize member data
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 2000/12/04 17:41:35: Created.
//
//-------------------------------------------------------------
CDefaultDSNSink::CDefaultDSNSink(
    IUnknown *pUnk)
{
    FILETIME ftStartTime;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNSink::CDefaultDSNSink");

    m_dwSig = SIGNATURE_CDEFAULTDSNSINK;
    m_pUnk = pUnk;
    _ASSERT_RECIP_FLAGS();
    m_fInit = FALSE;
    m_cDSNsRequested = 0;

    //Init string for MIME headers
    GetSystemTimeAsFileTime(&ftStartTime);
    wsprintf(m_szPerInstanceMimeBoundary, "%08X%08X",
        ftStartTime.dwHighDateTime, ftStartTime.dwLowDateTime);

    TraceFunctLeaveEx((LPARAM)this);
} // CDefaultDSNSink::CDefaultDSNSink



//+------------------------------------------------------------
//
// Function: CDefaultDSNSink::QueryInterface
//
// Synopsis: Return a requested interface
//
// Arguments:
//  riid: Interface ID
//  ppvObj: Return place for interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: Not a supported interface
//
// History:
// jstamerj 2000/12/08 20:05:46: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNSink::QueryInterface(
    REFIID riid,
    LPVOID *ppvObj)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNSink::QueryInterface");

    *ppvObj = NULL;

    if(riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else if(riid == IID_IDSNGenerationSink)
    {
        *ppvObj = (IDSNGenerationSink *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    if(SUCCEEDED(hr))
        AddRef();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNSink::QueryInterface


//+------------------------------------------------------------
//
// Function: CDefaultDSNSink::OnSyncSinkInit
//
// Synopsis: Initialize the sink.
//
// Arguments:
//  dwVSID: Virtual server ID
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/11/14 13:58:32: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNSink::OnSyncSinkInit(
    IN  DWORD                        dwVSID)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNSink::OnSyncSinkInit");
    DebugTrace((LPARAM)this, "VSID: %d", dwVSID);
    m_dwVSID = dwVSID;

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNSink::OnSyncSinkInit


//+------------------------------------------------------------
//
// Function: CDefaultDSNSink::OnSyncGetDSNRecipientIterator
//
// Synopsis: Not implemented
//
// Arguments: see smtpevent.idl
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 2000/11/14 14:00:00: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNSink::OnSyncGetDSNRecipientIterator(
    IN  ISMTPServer                 *pISMTPServer,
    IN  IMailMsgProperties          *pIMsg,
    IN  IMailMsgPropertyBag         *pDSNProperties,
    IN  DWORD                        dwStartDomain,
    IN  DWORD                        dwDSNActions,
    IN  IDSNRecipientIterator       *pRecipIterIN,
    OUT IDSNRecipientIterator     **ppRecipIterOUT)
{
    return E_NOTIMPL;
} // CDefaultDSNSink::OnSyncGetDSNRecipientIterator


//+------------------------------------------------------------
//
// Function: CDefaultDSNSink::OnSyncGenerateDSN
//
// Synopsis: Implements the default DSN generation sink
//
// Arguments: see smtpevent.idl
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/11/14 14:30:45: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNSink::OnSyncGenerateDSN(
    IN  ISMTPServer                 *pISMTPServer,
    IN  IDSNSubmission              *pIDSNSubmission,
    IN  IMailMsgProperties          *pIMsg,
    IN  IMailMsgPropertyBag         *pDSNProperties,
    IN  IDSNRecipientIterator       *pRecipIter)
{
    HRESULT hr = S_OK;
    DWORD dwCount = 0;
    //
    // Initialize parameters to default values
    //
    DWORD dwDSNActions = 0;
    DWORD dwDSNOptions = 0;
    DWORD dwRFC821Status = 0;
    HRESULT hrStatus = S_OK;
    DWORD dwPreferredLangId = 0;
    LPSTR szDefaultDomain = NULL;
    LPSTR szReportingMTA = NULL;
    LPSTR szReportingMTAType = NULL;
    LPSTR szDSNContext = NULL;
    LPSTR szCopyNDRTo = NULL;
    LPSTR szTopCustomText = NULL;
    LPSTR szBottomCustomText = NULL;
    LPWSTR wszTopCustomText = NULL;
    LPWSTR wszBottomCustomText = NULL;
    DWORD cIterationsLeft = 0;
    IMailMsgProperties *pDSNMsg = NULL;
    DWORD   cbCurrentSize = 0; //used to get size of returned property
    FILETIME ftExpireTime;
    FILETIME *pftExpireTime = NULL;
    DWORD dwDSNRetType = 0;
    HRESULT hrContentFailure = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNSink::OnSyncGenerateDSN");

    struct _tagDWORDProps
    {
        DWORD dwPropId;
        DWORD *pdwValue;
    } DsnDwordProps[] =
    {
        { DSNPROP_DW_DSNACTIONS,        & dwDSNActions },
        { DSNPROP_DW_DSNOPTIONS,        & dwDSNOptions },
        { DSNPROP_DW_RFC821STATUS,      & dwRFC821Status },
        { DSNPROP_DW_HRSTATUS,          (DWORD *) & hrStatus },
        { DSNPROP_DW_LANGID,            & dwPreferredLangId },
        { DSNPROP_DW_RET_TYPE,          & dwDSNRetType },
        { DSNPROP_DW_CONTENT_FAILURE,   (DWORD *) & hrContentFailure },
    };
    struct _tagStringProps
    {
        DWORD dwPropId;
        LPSTR *ppsz;
    } DsnStringProps[] =
    {
        { DSNPROP_SZ_DEFAULTDOMAIN,     & szDefaultDomain },
        { DSNPROP_SZ_REPORTINGMTA,      & szReportingMTA },
        { DSNPROP_SZ_REPORTINGMTATYPE,  & szReportingMTAType },
        { DSNPROP_SZ_DSNCONTEXT,        & szDSNContext },
        { DSNPROP_SZ_COPYNDRTO,         & szCopyNDRTo },
        { DSNPROP_SZ_HR_TOP_CUSTOM_TEXT_A,    & szTopCustomText },
        { DSNPROP_SZ_HR_BOTTOM_CUSTOM_TEXT_A, & szBottomCustomText },
    };
    struct _tagWideStringProps
    {
        DWORD dwPropId;
        LPWSTR *ppwsz;
    } DsnWideStringProps[] =
    {
        { DSNPROP_SZ_HR_TOP_CUSTOM_TEXT_W,    & wszTopCustomText },
        { DSNPROP_SZ_HR_BOTTOM_CUSTOM_TEXT_W, & wszBottomCustomText },
    };

    //
    // Get DWORDs
    //
    for(dwCount = 0;
        dwCount < ( sizeof(DsnDwordProps) / sizeof(DsnDwordProps[0]));
        dwCount++)
    {
        hr = pDSNProperties->GetDWORD(
            DsnDwordProps[dwCount].dwPropId,
            DsnDwordProps[dwCount].pdwValue);
        if(FAILED(hr) && (hr != MAILMSG_E_PROPNOTFOUND))
            goto CLEANUP;
    }
    //
    // Get Strings
    //
    for(dwCount = 0;
        dwCount < ( sizeof(DsnStringProps) / sizeof(DsnStringProps[0]));
        dwCount++)
    {
        BYTE bStupid = 0;
        DWORD dwcb = 0;

        hr = pDSNProperties->GetProperty(
            DsnStringProps[dwCount].dwPropId,
            0, // Length
            &dwcb, // pcbLength
            &bStupid);
        if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            *(DsnStringProps[dwCount].ppsz) = new CHAR[dwcb+1];
            if( (*(DsnStringProps[dwCount].ppsz)) == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto CLEANUP;
            }
            hr = pDSNProperties->GetStringA(
                DsnStringProps[dwCount].dwPropId,
                dwcb+1,
                *(DsnStringProps[dwCount].ppsz));
            if(FAILED(hr))
            {
                ErrorTrace((LPARAM)this, "GetStringA failed hr %08lx", hr);
                goto CLEANUP;
            }
        }
        else if(FAILED(hr) && (hr != MAILMSG_E_PROPNOTFOUND))
        {
            ErrorTrace((LPARAM)this, "GetProperty failed hr %08lx", hr);
            goto CLEANUP;
        }
    }
    //
    // Get Wide Strings
    //
    for(dwCount = 0;
        dwCount < ( sizeof(DsnWideStringProps) / sizeof(DsnWideStringProps[0]));
        dwCount++)
    {
        BYTE bStupid = 0;
        DWORD dwcb = 0;

        hr = pDSNProperties->GetProperty(
            DsnWideStringProps[dwCount].dwPropId,
            0, // Length
            &dwcb, // pcbLength
            &bStupid);
        if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            *(DsnWideStringProps[dwCount].ppwsz) = new WCHAR[(dwcb / sizeof(WCHAR))+1];
            if( (*(DsnWideStringProps[dwCount].ppwsz)) == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto CLEANUP;
            }
            hr = pDSNProperties->GetStringW(
                DsnWideStringProps[dwCount].dwPropId,
                (dwcb / sizeof(WCHAR))+1,
                *(DsnWideStringProps[dwCount].ppwsz));
            if(FAILED(hr))
            {
                ErrorTrace((LPARAM)this, "GetStringA failed hr %08lx", hr);
                goto CLEANUP;
            }
        }
        else if(FAILED(hr) && (hr != MAILMSG_E_PROPNOTFOUND))
        {
            ErrorTrace((LPARAM)this, "GetProperty failed hr %08lx", hr);
            goto CLEANUP;
        }
    }

    //Get MsgExpire Time
    //Write DSN_RP_HEADER_RETRY_UNTIL using expire FILETIME
    hr = pDSNProperties->GetProperty(
        DSNPROP_FT_EXPIRETIME,
        sizeof(FILETIME),
        &cbCurrentSize,
        (BYTE *) &ftExpireTime);
    if (SUCCEEDED(hr))
    {
        _ASSERT(sizeof(FILETIME) == cbCurrentSize);
        if (sizeof(FILETIME) == cbCurrentSize) 
            pftExpireTime = &ftExpireTime;
    }
    else if (MAILMSG_E_PROPNOTFOUND == hr)
        hr = S_OK;
    else
        goto CLEANUP;


    do
    {
        DWORD dwDSNActionsGenerated = 0;
        DWORD cRecipsDSNd = 0;

        hr = HrGenerateDSNInternal(
            pISMTPServer,
            pIMsg,
            pRecipIter,
            pIDSNSubmission,
            dwDSNActions,
            dwRFC821Status,
            hrStatus,
            szDefaultDomain,
            szDefaultDomain ? lstrlen(szDefaultDomain) : 0,
            szReportingMTA,
            szReportingMTA ? lstrlen(szReportingMTA) : 0,
            szReportingMTAType,
            szReportingMTAType ? lstrlen(szReportingMTAType) : 0,
            szDSNContext,
            szDSNContext ? lstrlen(szDSNContext) : 0,
            dwPreferredLangId,
            dwDSNOptions,
            szCopyNDRTo,
            szCopyNDRTo ? lstrlen(szCopyNDRTo) : 0,
            pftExpireTime,
            szTopCustomText,
            wszTopCustomText,
            szBottomCustomText,
            wszBottomCustomText,
            &pDSNMsg,
            &dwDSNActionsGenerated,
            &cRecipsDSNd,
            &cIterationsLeft,
            dwDSNRetType,
            hrContentFailure);

        if(FAILED(hr))
        {
            _ASSERT(pDSNMsg == NULL);
            ErrorTrace((LPARAM)this, "HrGenerateDSNInternal failed hr %08lx", hr);
            goto CLEANUP;
        }
        else if(pDSNMsg)
        {
            //
            // Submit the DSN to the system
            //
            hr = pIDSNSubmission->HrSubmitDSN(
                dwDSNActionsGenerated,
                cRecipsDSNd,
                pDSNMsg);
            if(FAILED(hr))
            {
                ErrorTrace((LPARAM)this, "HrSubmitDSN failed hr %08lx", hr);
                goto CLEANUP;
            }
            pDSNMsg->Release();
            pDSNMsg = NULL;
        }
    } while(SUCCEEDED(hr) && cIterationsLeft);

    if(hr == AQUEUE_E_NDR_OF_DSN)
    {
        DebugTrace((LPARAM)this, "NDR of DSN; setting badmail flag");
        hr = pDSNProperties->PutBool(
            DSNPROP_F_BADMAIL_MSG,
            TRUE);
    }

 CLEANUP:
    for(dwCount = 0;
        dwCount < ( sizeof(DsnStringProps) / sizeof(DsnStringProps[0]));
        dwCount++)
    {
        if(*(DsnStringProps[dwCount].ppsz))
        {
            delete [] (*(DsnStringProps[dwCount].ppsz));
            *(DsnStringProps[dwCount].ppsz) = NULL;
        }
    }
    for(dwCount = 0;
        dwCount < ( sizeof(DsnWideStringProps) / sizeof(DsnWideStringProps[0]));
        dwCount++)
    {
        if(*(DsnWideStringProps[dwCount].ppwsz))
        {
            delete [] (*(DsnWideStringProps[dwCount].ppwsz));
            *(DsnWideStringProps[dwCount].ppwsz) = NULL;
        }
    }
    if(pDSNMsg)
        pDSNMsg->Release();

    //
    // Return failures in a property
    //
    if(FAILED(hr))
    {
        HRESULT hrProp;
        hrProp = pDSNProperties->PutDWORD(
            DSNPROP_DW_HR_RETURN_STATUS,
            hr);
        _ASSERT(SUCCEEDED(hrProp));
        ErrorTrace((LPARAM)this, "Unable to generate DSN: %08lx", hr);
        //
        // Return S_OK to dispatcher
        //
        hr = S_OK;
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return SUCCEEDED(hr) ? S_OK : hr;
} // CDefaultDSNSink::OnSyncGenerateDSN


//+------------------------------------------------------------
//
// Function: CDefaultDSNSink::HrGenerateDSNInternal
//
// Synopsis: Generates one DSN message
//
// Arguments:
//      pISMTPServer            Interface used to generate DSN
//      pIMailMsgProperties     IMailMsg to generate DSN for
//      pIRecipIter             Controls which recipients to DSN
//      dwDSNActions            DSN Actions requested
//      dwRFC821Status          Global RFC821 status DWORD
//      hrStatus                Global HRESULT status
//      szDefaultDomain         Default domain (used to create FROM address)
//      cbDefaultDomain         string length of szDefaultDomain
//      szReportingMTA          Name of MTA requesting DSN generation
//      cbReportingMTA          string length of szReportingMTA
//      szReportingMTAType      Type of MTA requestiong DSN (SMTP is "dns"
//      cbReportingMTAType      string length of szReportingMTAType
//      PreferredLangId         Language to generate DSN in
//      dwDSNOptions            Options flags as defined in aqueue.idl
//      szCopyNDRTo             SMTP Address to copy NDR to
//      cbCopyNDRTo             string lengtt of szCopyNDRTo
//      ppIMailMsgPeropertiesDSN Generated DSN.
//      pdwDSNTypesGenerated    Describes the type(s) of DSN's generated
//      pcRecipsDSNd            # of recipients that were DSN'd for this message
//      pcIterationsLeft        # of times remaining that this function needs
//                              to be called to generate all requested DSNs.
//                              First-time caller should initialize to
//                              zero
//      dwDSNRetType            Return type for DSN
//      hrContentFailure        Value for X-Content-Failure header
//
//  Returns:
//      S_OK on success
//      AQUEUE_E_NDR_OF_DSN if attempting to NDR a DSN
//  History:
//      6/30/98 - MikeSwa Created
//      12/14/98 - MikeSwa Modified (Added pcIterationsLeft)
//      10/13/1999 - MikeSwa Modified (Added szDefaultDomain)
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/11/16 10:53:30: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGenerateDSNInternal(
    ISMTPServer *pISMTPServer,
    IMailMsgProperties *pIMailMsgProperties,
    IDSNRecipientIterator *pIRecipIter,
    IDSNSubmission *pIDSNSubmission,
    DWORD dwDSNActions,
    DWORD dwRFC821Status,
    HRESULT hrStatus,
    LPSTR szDefaultDomain,
    DWORD cbDefaultDomain,
    LPSTR szReportingMTA,
    DWORD cbReportingMTA,
    LPSTR szReportingMTAType,
    DWORD cbReportingMTAType,
    LPSTR szDSNContext,
    DWORD cbDSNContext,
    DWORD dwPreferredLangId,
    DWORD dwDSNOptions,
    LPSTR szCopyNDRTo,
    DWORD cbCopyNDRTo,
    FILETIME *pftExpireTime,
    LPSTR szHRTopCustomText,
    LPWSTR wszHRTopCustomText,
    LPSTR szHRBottomCustomText,
    LPWSTR wszHRBottomCustomText,
    IMailMsgProperties **ppIMailMsgPropertiesDSN,
    DWORD *pdwDSNTypesGenerated,
    DWORD *pcRecipsDSNd,
    DWORD *pcIterationsLeft,
    DWORD dwDSNRetTypeIN,
    HRESULT hrContentFailure)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    DWORD   iCurrentRecip = 0;
    DWORD   dwCurrentDSNAction = 0;
    DWORD   dwDSNActionsNeeded = 0; //the type of DSNs that will actually be sent
    IMailMsgRecipients  *pIMailMsgRecipients = NULL;
    IMailMsgProperties *pIMailMsgPropertiesDSN = NULL;
    PFIO_CONTEXT  pDSNBody = NULL;
    CDSNBuffer  dsnbuff;
    CHAR    szMimeBoundary[MIME_BOUNDARY_SIZE];
    DWORD   cbMimeBoundary = 0;
    CHAR    szExpireTimeBuffer[MAX_RFC822_DATE_SIZE];
    LPSTR   szExpireTime = NULL; //will point to szExpireTimeBuffer if found
    DWORD   cbExpireTime = 0;
    DWORD   iRecip = 0;
    DWORD   dwDSNAction = 0;
    DWORD   dwDSNRetType = dwDSNRetTypeIN;
    DWORD   dwOrigMsgSize = 0;
    HRESULT hrContent = hrContentFailure;

    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNSink::HrGenerateDSNInternal");

    _ASSERT(ppIMailMsgPropertiesDSN);
    _ASSERT(pISMTPServer);
    _ASSERT(pIMailMsgProperties);
    _ASSERT(pdwDSNTypesGenerated);
    _ASSERT(pcRecipsDSNd);
    _ASSERT(pcIterationsLeft);

    *pcRecipsDSNd = 0;
    *ppIMailMsgPropertiesDSN = NULL;
    *pdwDSNTypesGenerated = 0;
    GetCurrentMimeBoundary(szReportingMTA, cbReportingMTA, szMimeBoundary, &cbMimeBoundary);


    //Get Recipients interface
    hr = pIMailMsgProperties->QueryInterface(IID_IMailMsgRecipients,
                                    (PVOID *) &pIMailMsgRecipients);
    if (FAILED(hr))
        goto Exit;

    hr = pIRecipIter->HrReset();
    if (FAILED(hr))
        goto Exit;

    //Loop over recipients to make sure we can need to allocate a message
    hr = pIRecipIter->HrGetNextRecipient(
        &iRecip,
        &dwDSNAction);
    while (SUCCEEDED(hr))
    {
        DebugTrace((LPARAM) this,
            "Recipient %d with DSN Action 0x%08X found",
            iRecip, dwDSNAction);

        //keep track of the types of DSN's we will be generating
        dwDSNActionsNeeded |= dwDSNAction;

        hr = pIRecipIter->HrGetNextRecipient(
            &iRecip,
            &dwDSNAction);
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        hr = S_OK;  //we just reached the end of the context
    else if (FAILED(hr))
        ErrorTrace((LPARAM) this, "GetNextRecipient failed with 0x%08X",hr);

    if (dwDSNActionsNeeded == 0)
    {
        DebugTrace((LPARAM) this,
                "Do not need to generate a 0x%08X DSN",
                dwDSNActions, pIMailMsgProperties);
        *pcIterationsLeft = 0;
        goto Exit; //don't create a message object if we don't have to
    }

    //Check if message is a DSN (we will not genrate a DSN of a DSN)
    //This must be checked after we run through the recipients, because
    //we need to check them to keep from badmailing this message
    //multiple times.
    if (fIsMailMsgDSN(pIMailMsgProperties))
    {
        DebugTrace((LPARAM) pIMailMsgProperties, "Message is a DSN");
        *pcIterationsLeft = 0;
        if (dwDSNActions & (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL))
        {
            //NDR of DSN... return special error code
            hr = AQUEUE_E_NDR_OF_DSN;

            //mark all the appropriate recipient flags so we don't
            //generate 2 badmails
            HrMarkAllRecipFlags(
                dwDSNActions,
                pIRecipIter);
        }
        goto Exit;
    }

    //if we can generate a failure DSN and the orginal request was for
    //fail *all* make sure dwDSNActionNeeded reflects this
    if ((DSN_ACTION_FAILURE & dwDSNActionsNeeded) &&
        (DSN_ACTION_FAILURE_ALL & dwDSNActions))
        dwDSNActionsNeeded |= DSN_ACTION_FAILURE_ALL;

    GetCurrentIterationsDSNAction(&dwDSNActionsNeeded, pcIterationsLeft);
    if (!dwDSNActionsNeeded)
    {
        *pcIterationsLeft = 0;
        goto Exit; //don't create a message object if we don't have to
    }


    hr = pIDSNSubmission->HrAllocBoundMessage(
        &pIMailMsgPropertiesDSN,
        &pDSNBody);
    if (FAILED(hr))
        goto Exit;

    //workaround to handle AllocBoundMessage on shutdown
    if (NULL == pDSNBody)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES);
        ErrorTrace((LPARAM) this, "ERROR: AllocBoundMessage failed silently");
        goto Exit;
    }

    //Associate file handle with CDSNBuffer
    hr = dsnbuff.HrInitialize(pDSNBody);
    if (FAILED(hr))
        goto Exit;

    //Get MsgExpire Time
    //Write DSN_RP_HEADER_RETRY_UNTIL using expire FILETIME
    if (pftExpireTime)
    {
        //convert to internet standard
        if (FileTimeToLocalRFC822Date(*pftExpireTime, szExpireTimeBuffer))
        {
            szExpireTime = szExpireTimeBuffer;
            cbExpireTime = lstrlen(szExpireTime);
        }
    }

    //
    // If the RET type has not yet been specified, default to:
    // FULL for Failure/Delay DSNs
    // HDRS for other types of DSNs (Expanded/Delivered/Relayed)
    //
    if(dwDSNRetType == 0)
    {
        if ((DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL | DSN_ACTION_DELAYED)
            & dwDSNActionsNeeded)
            dwDSNRetType = DSN_RET_FULL;
        else
            dwDSNRetType = DSN_RET_HDRS;
    }
    //
    // If we're going to need the original content, get the size now.
    //
    if(SUCCEEDED(hrContent) && (dwDSNRetType != DSN_RET_PARTIAL_HDRS))
    {
        //Get the content size
        hrContent = pIMailMsgProperties->GetContentSize(&dwOrigMsgSize, NULL);
    }

    //
    //  If we received EFNF on obtaining content size, we should simply skip this message
    //  without generating an NDR.
    //
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrContent) {
        DebugTrace((LPARAM)this, "GetContentSize failed with EFNF so not generating NDR or badmail.");
        *pcIterationsLeft = 0;
        hr = S_OK;
        goto Exit;
    }

    if (FAILED(hrContent))
    {
        //
        // Rather than badmailing, generate a DSN with only a header subset
        //
        ErrorTrace((LPARAM)this, "GetContentSize failed hr %08lx", hr);
        dwDSNRetType = DSN_RET_PARTIAL_HDRS;
    }

    hr = HrWriteDSNP1AndP2Headers(dwDSNActionsNeeded,
                                pIMailMsgProperties, pIMailMsgPropertiesDSN,
                                &dsnbuff, szDefaultDomain, cbDefaultDomain,
                                szReportingMTA, cbReportingMTA,
                                szDSNContext, cbDSNContext,
                                szCopyNDRTo, hrStatus,
                                szMimeBoundary, cbMimeBoundary, dwDSNOptions,
                                hrContent);
    if (FAILED(hr))
        goto Exit;

    hr = HrWriteDSNHumanReadable(pIMailMsgPropertiesDSN, pIMailMsgRecipients,
                                pIRecipIter,
                                dwDSNActionsNeeded,
                                &dsnbuff, dwPreferredLangId,
                                szMimeBoundary, cbMimeBoundary, hrStatus,
                                szHRTopCustomText, wszHRTopCustomText,
                                szHRBottomCustomText, wszHRBottomCustomText);
    if (FAILED(hr))
        goto Exit;

    hr = HrWriteDSNReportPerMsgProperties(pIMailMsgProperties,
                                &dsnbuff, szReportingMTA, cbReportingMTA,
                                szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    //recycle context again (may be used during generation of human readable)
    hr = pIRecipIter->HrReset();
    if (FAILED(hr))
        goto Exit;

    //$$REVIEW - Do we need to keep an "undo" list... or perhaps reverse
    //engineer what the previous value was in case of a failure
    hr = pIRecipIter->HrGetNextRecipient(&iCurrentRecip, &dwCurrentDSNAction);
    while (SUCCEEDED(hr))
    {
        if(dwDSNActionsNeeded & dwCurrentDSNAction)
        {
            *pdwDSNTypesGenerated |= (dwCurrentDSNAction & DSN_ACTION_TYPE_MASK);
            (*pcRecipsDSNd)++;
            hr = HrWriteDSNReportPreRecipientProperties(
                pIMailMsgRecipients, &dsnbuff,
                iCurrentRecip, szExpireTime, cbExpireTime,
                dwCurrentDSNAction, dwRFC821Status, hrStatus);
            if (FAILED(hr))
                goto Exit;

            hr = pIRecipIter->HrNotifyActionHandled(
                iCurrentRecip,
                dwCurrentDSNAction);
            _ASSERT(SUCCEEDED(hr) && "HrNotifyActionHandled failed on 2nd pass");
            if (FAILED(hr))
                goto Exit;

            // DSN Logging
            hr = HrLogDSNGenerationEvent(
                                pISMTPServer,
                                pIMailMsgProperties,
                                pIMailMsgRecipients,
                                iCurrentRecip,
                                dwCurrentDSNAction,
                                dwRFC821Status,
                                hrStatus);

            if (FAILED(hr))
            {
                ErrorTrace((LPARAM) this, "Failed to log DSN generation with 0x%08X",hr);
                hr = S_OK; // We can accept this failure ...
            }
        }

        hr = pIRecipIter->HrGetNextRecipient(&iCurrentRecip, &dwCurrentDSNAction);
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        hr = S_OK;

    if (0 == (*pcRecipsDSNd))
        goto Exit; //no work to do

    hr = HrWriteDSNClosingAndOriginalMessage(pIMailMsgProperties, 
                        pIMailMsgPropertiesDSN, &dsnbuff, pDSNBody, 
                        dwDSNActionsNeeded, szMimeBoundary, cbMimeBoundary,
                        dwDSNRetType, dwOrigMsgSize);
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgPropertiesDSN->Commit(NULL);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pIMailMsgProperties, "ERROR: IMailMsg::Commit failed - hr 0x%08X", hr);
        goto Exit;
    }

    *ppIMailMsgPropertiesDSN = pIMailMsgPropertiesDSN;
    pIMailMsgPropertiesDSN = NULL;

  Exit:
    if (pIMailMsgRecipients)
    {
        pIMailMsgRecipients->Release();
    }

    if (pIMailMsgPropertiesDSN)
    {
        IMailMsgQueueMgmt *pIMailMsgQueueMgmt = NULL;
        //if non-NULL, then we should not be returning any value
        _ASSERT(NULL == *ppIMailMsgPropertiesDSN);
        //Check for alloc bound message failure
        if (HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) != hr)
        {
            if (SUCCEEDED(pIMailMsgPropertiesDSN->QueryInterface(IID_IMailMsgQueueMgmt,
                        (void **) &pIMailMsgQueueMgmt)))
            {
                _ASSERT(pIMailMsgQueueMgmt);
                pIMailMsgQueueMgmt->Delete(NULL);
                pIMailMsgQueueMgmt->Release();
            }
        }
        pIMailMsgPropertiesDSN->Release();
    }

    if (FAILED(hr))
        *pcIterationsLeft = 0;

    //workaround for alloc bound message
    if (HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES) == hr)
    {
        hr = S_OK;
    }

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNSink::HrGenerateDSNInternal


//+------------------------------------------------------------
//
// Function: CDefaultDSNSink::HrMarkAllRecipFlags
//
// Synopsis:
//      Marks all recipient according to the DSN action.  Used when an NDR of
//      an NDR is found and we will not be generating a DSN, but need to mark
//      the recips so we can not generate 2 badmail events.
//
// Arguments:
//  IN  DWORD dwDSNActions: Actions to mark
//  IN  IDSNRecipientIterator *pIRecipIter: Recipient iterator
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/11/20 17:13:12: Created.
//
//-------------------------------------------------------------
HRESULT CDefaultDSNSink::HrMarkAllRecipFlags(
    IN  DWORD dwDSNActions,
    IN  IDSNRecipientIterator *pIRecipIter)
{
    HRESULT hr = S_OK;
    DWORD iRecip = 0;
    DWORD dwRecipDSNActions = 0;
    TraceFunctEnterEx((LPARAM)this, "CDefaultDSNSink::HrMarkAllRecipFlags");

    hr = pIRecipIter->HrReset();
    if(FAILED(hr))
        goto CLEANUP;

    hr = pIRecipIter->HrGetNextRecipient(
        &iRecip,
        &dwRecipDSNActions);
    if(FAILED(hr))
        goto CLEANUP;

    while(SUCCEEDED(hr))
    {
        hr = pIRecipIter->HrNotifyActionHandled(
            iRecip,
            dwDSNActions);
        if(FAILED(hr))
            goto CLEANUP;

        hr = pIRecipIter->HrGetNextRecipient(
            &iRecip,
            &dwRecipDSNActions);
        if(FAILED(hr))
            goto CLEANUP;
    }

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CDefaultDSNSink::HrMarkAllRecipFlags

//---[ CDefaultDSNSink::GetCurrentIterationsDSNAction ]------------------------
//
//
//  Description:
//      This function will select one of the pdwActualDSNAction to generate
//      DSNs on during this call to the DSN generation sink.
//  Parameters:
//      IN OUT  pdwActionDSNAction      DSN Actions that can/will be used.
//      IN OUT  pcIterationsLeft        Approximate # of times needed to call
//                                      DSN generation
//  Returns:
//      -
//  History:
//      12/14/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDefaultDSNSink::GetCurrentIterationsDSNAction(
    IN OUT DWORD   *pdwActualDSNAction,
    IN OUT DWORD   *pcIterationsLeft)
{
    _ASSERT(pdwActualDSNAction);
    _ASSERT(pcIterationsLeft);
    const DWORD MAX_DSN_ACTIONS = 6;

    //In the following array FAILURE_ALL must come first or else we will
    //generate separate failure DSNs for hard failures and undelivereds.
    DWORD rgPossibleDSNActions[MAX_DSN_ACTIONS] = {DSN_ACTION_FAILURE_ALL,
                                                   DSN_ACTION_FAILURE,
                                                   DSN_ACTION_DELAYED,
                                                   DSN_ACTION_RELAYED,
                                                   DSN_ACTION_DELIVERED,
                                                   DSN_ACTION_EXPANDED};
    DWORD i = 0;
    DWORD iLastMatch = MAX_DSN_ACTIONS;
    DWORD iFirstMatch = MAX_DSN_ACTIONS;
    DWORD iStartIndex = 0;

    //Since the possible DSNs to generate may change from call to call (because
    //we are updating the pre-recipient flags), we need to generate and maintain
    //pcIterationsLeft based on the possible Actions (which will not be changing
    //from call to call).

    _ASSERT(*pcIterationsLeft < MAX_DSN_ACTIONS);

    //Figure out where we should start if this is not the
    if (*pcIterationsLeft)
        iStartIndex = MAX_DSN_ACTIONS-*pcIterationsLeft;

    //Loop through possible DSN actions (that we haven't seen) and determine
    //the first and last
    for (i = iStartIndex; i < MAX_DSN_ACTIONS; i++)
    {
        if (rgPossibleDSNActions[i] & *pdwActualDSNAction)
        {
            iLastMatch = i;
            if (MAX_DSN_ACTIONS == iFirstMatch)
                iFirstMatch = i;
        }
    }

    if (MAX_DSN_ACTIONS == iLastMatch)
    {
        //No matches... we are done
        *pdwActualDSNAction = 0;
        *pcIterationsLeft = 0;
        return;
    }

    //If this is possible after the above check... then I've screwed up
    _ASSERT(MAX_DSN_ACTIONS != iFirstMatch);

    *pdwActualDSNAction = rgPossibleDSNActions[iFirstMatch];
    if ((iLastMatch == iFirstMatch) ||
       ((rgPossibleDSNActions[iFirstMatch] == DSN_ACTION_FAILURE_ALL) &&
        (rgPossibleDSNActions[iLastMatch] == DSN_ACTION_FAILURE)))
    {
        //This is our last time through
        *pcIterationsLeft = 0;
    }
    else
    {
        *pcIterationsLeft = MAX_DSN_ACTIONS-1-iFirstMatch;
    }
}

//---[ CDefaultDSNSink::HrWriteDSNP1AndP2Headers ]-----------------------------
//
//
//  Description:
//      Writes global DSN P1 Properties to IMailMsgProperties
//  Parameters:
//      dwDSNAction             DSN action specified for sink
//      pIMailMsgProperties     Msg that DSN is being generated for
//      pIMailMsgPropertiesDSN  DSN being generated
//      psndbuff                Buffer to write  to
//      szDefaultDomain         Default domain - used from postmaster from address
//      cbDefaultDomain         strlen of szDefaultDomain
//      szReportingMTA          Reporting MTA as passed to event sink
//      cbReportingMTA          strlen of szReportingMTA
//      szDSNConext             Debug File and line number info passed in
//      cbDSNConext             strlen of szDSNContext
//      szCopyNDRTo             SMTP Address to copy NDR to
//      hrStatus                Status to record in DSN context
//      szMimeBoundary          MIME boundary string
//      cbMimeBoundary          strlen of MIME boundary
//      dwDSNOptions            DSN Options flags
//      hrContent               Content result
//
//  Returns:
//      S_OK on success
//  History:
//      7/5/98 - MikeSwa Created
//      8/14/98 - MikeSwa Modified - Added DSN context headers
//      11/9/98 - MikeSwa Added copy NDR to functionality
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNP1AndP2Headers(
                                  IN DWORD dwDSNAction,
                                  IN IMailMsgProperties *pIMailMsgProperties,
                                  IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                  IN CDSNBuffer *pdsnbuff,
                                  IN LPSTR szDefaultDomain,
                                  IN DWORD cbDefaultDomain,
                                  IN LPSTR szReportingMTA,
                                  IN DWORD cbReportingMTA,
                                  IN LPSTR szDSNContext,
                                  IN DWORD cbDSNContext,
                                  IN LPSTR szCopyNDRTo,
                                  IN HRESULT hrStatus,
                                  IN LPSTR szMimeBoundary,
                                  IN DWORD cbMimeBoundary,
                                  IN DWORD dwDSNOptions,
                                  IN HRESULT hrContent)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteDSNP1AndP2Headers");
    HRESULT hr = S_OK;
    BOOL bReturn = TRUE;
    HRESULT hrTmp = S_OK;
    CHAR  szBuffer[512];
    LPSTR szSender = (LPSTR) szBuffer; //tricks to avoid AV'ing in AddPrimary
    IMailMsgRecipientsAdd *pIMailMsgRecipientsAdd = NULL;
    IMailMsgRecipients *pIMailMsgRecipients = NULL;
    DWORD dwRecipAddressProp = IMMPID_RP_ADDRESS_SMTP;
    DWORD dwSMTPAddressProp = IMMPID_RP_ADDRESS_SMTP;
    DWORD iCurrentAddressProp = 0;
    DWORD dwDSNRecipient = 0;
    DWORD cbPostMaster = 0;
    CHAR  szDSNAction[15];
    FILETIME ftCurrentTime;
    CHAR    szCurrentTimeBuffer[MAX_RFC822_DATE_SIZE];

    _ASSERT(pIMailMsgProperties);
    _ASSERT(pIMailMsgPropertiesDSN);
    _ASSERT(pdsnbuff);

    szBuffer[0] = '\0';

    //Get and write Message tracking properties
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_SERVER_VERSION,
            sizeof(szBuffer), szBuffer);
    if (SUCCEEDED(hr))
    {
        hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_SERVER_VERSION, szBuffer);
        if (FAILED(hr))
            DebugTrace((LPARAM) this,
                "Warning: Unable to write version to msg - 0x%08X", hr);
        hr = S_OK;
    }
    else
    {
        DebugTrace((LPARAM) this,
            "Warning: Unable to get server version from msg - 0x%08X", hr);
        hr = S_OK; //ignore this non-fatal error
    }

    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_SERVER_NAME,
            sizeof(szBuffer), szBuffer);
    if (SUCCEEDED(hr))
    {
        hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_SERVER_NAME, szBuffer);
        if (FAILED(hr))
            DebugTrace((LPARAM) this,
                "Warning: Unable to write server name to msg - 0x%08X", hr);
        hr = S_OK;
    }
    else
    {
        DebugTrace((LPARAM) this,
            "Warning: Unable to get server name from msg - 0x%08X", hr);
        hr = S_OK; //ignore this non-fatal error
    }

    //Set the type of message
    if (dwDSNAction &
            (DSN_ACTION_EXPANDED | DSN_ACTION_RELAYED | DSN_ACTION_DELIVERED)) {
        hr = pIMailMsgPropertiesDSN->PutDWORD(IMMPID_MP_MSGCLASS,
                                                MP_MSGCLASS_DELIVERY_REPORT);
    } else if (dwDSNAction &
           (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL | DSN_ACTION_DELAYED)) {
        hr = pIMailMsgPropertiesDSN->PutDWORD(IMMPID_MP_MSGCLASS,
                                                MP_MSGCLASS_NONDELIVERY_REPORT);
    }

    if (FAILED(hr)) {
        DebugTrace((LPARAM) this,
            "Warning: Unable to set msg class for dsn - 0x%08X", hr);
        hr = S_OK;
    }

    for (iCurrentAddressProp = 0;
         iCurrentAddressProp < NUM_DSN_ADDRESS_PROPERTIES;
         iCurrentAddressProp++)
    {
        szBuffer[0] = '\0';
        //Get the sender of the original message
        hr = pIMailMsgProperties->GetStringA(
                g_rgdwSenderPropIDs[iCurrentAddressProp],
                sizeof(szBuffer), szBuffer);
        if (FAILED(hr) && (MAILMSG_E_PROPNOTFOUND != hr))
        {
            ErrorTrace((LPARAM) this,
                "ERROR: Unable to get 0x%X sender of IMailMsg %p",
                g_rgdwSenderPropIDs[iCurrentAddressProp], pIMailMsgProperties);
            goto Exit;
        }

        //
        //  If we have found an address break
        //
        if (SUCCEEDED(hr))
            break;
    }

    //
    //  If we failed to get a property... bail
    //
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "ERROR: Unable to get any sender of IMailMsg 0x%08X",
            pIMailMsgProperties);
        goto Exit;
    }

    //write DSN Sender (P1)
    hr = pIMailMsgPropertiesDSN->PutProperty(IMMPID_MP_SENDER_ADDRESS_SMTP,
        sizeof(DSN_MAIL_FROM), (BYTE *) DSN_MAIL_FROM);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "ERROR: Unable to write P1 DSN sender for IMailMsg 0x%08X",
            pIMailMsgProperties);
        goto Exit;
    }

    //write DSN Recipient
    hr = pIMailMsgPropertiesDSN->QueryInterface(IID_IMailMsgRecipients,
                                           (void **) &pIMailMsgRecipients);

    _ASSERT(SUCCEEDED(hr) && "QueryInterface for IID_IMailMsgRecipients failed");

    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgRecipients->AllocNewList(&pIMailMsgRecipientsAdd);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "ERROR: Unable to Alloc List for DSN generation of IMailMsg 0x%08X",
            pIMailMsgProperties);
        goto Exit;
    }

    dwRecipAddressProp = g_rgdwRecipPropIDs[iCurrentAddressProp];
    hr = pIMailMsgRecipientsAdd->AddPrimary(
                    1,
                    (LPCSTR *) &szSender,
                    &dwRecipAddressProp,
                    &dwDSNRecipient,
                    NULL,
                    0);

    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this,
            "ERROR: Unable to write DSN recipient for IMailMsg 0x%p hr - 0x%08X",
            pIMailMsgProperties, hr);
        goto Exit;
    }


    //Write Address to copy NDR to (NDRs only)
    if (szCopyNDRTo &&
        (dwDSNAction & (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL)))
    {
        hr = pIMailMsgRecipientsAdd->AddPrimary(
                        1,
                        (LPCSTR *) &szCopyNDRTo,
                        &dwSMTPAddressProp,
                        &dwDSNRecipient,
                        NULL,
                        0);

        if (FAILED(hr))
        {
            ErrorTrace((LPARAM) this,
                "ERROR: Unable to write DSN recipient for IMailMsg 0x%08X",
                pIMailMsgProperties);
            goto Exit;
        }
    }

    //write P2 DSN sender
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RFC822_SENDER, sizeof(DSN_RFC822_SENDER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szDefaultDomain, cbDefaultDomain);
    if (FAILED(hr))
        goto Exit;

    //
    //  If we do not have a SMTP address, write a blank BCC instead of
    //  a TO address (since we do not have a address we can write in the 822.
    //  This is similar to what we do with the pickup dir when we have no TO
    //  headers.
    //
    if (IMMPID_MP_SENDER_ADDRESS_SMTP == g_rgdwSenderPropIDs[iCurrentAddressProp])
    {

        //Write P2 "To:" header (using the szSender value we determined above)
        hr = pdsnbuff->HrWriteBuffer((BYTE *) TO_HEADER, sizeof(TO_HEADER)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szSender, lstrlen(szSender));
        if (FAILED(hr))
            goto Exit;

        //Save recipient (original sender) for Queue Admin/Message Tracking
        hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_RFC822_TO_ADDRESS, szSender);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) BCC_HEADER, sizeof(BCC_HEADER)-1);
        if (FAILED(hr))
            goto Exit;
    }

    //Use szBuffer to construct 822 from to set for Queue Admin/Msg Tracking
    //"Postmaster@" + max of 64 characters should be less than 1/2 K!!
    _ASSERT(sizeof(szBuffer) > sizeof(DSN_SENDER_ADDRESS_PREFIX) + cbReportingMTA);
    memcpy(szBuffer, DSN_SENDER_ADDRESS_PREFIX, sizeof(DSN_SENDER_ADDRESS_PREFIX));
    strncat(szBuffer, szDefaultDomain, sizeof(szBuffer) - sizeof(DSN_SENDER_ADDRESS_PREFIX));
    hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_RFC822_FROM_ADDRESS, szSender);
    if (FAILED(hr))
        goto Exit;

    //Write P2 "Date:" header
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DATE_HEADER, sizeof(DATE_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    //Get current time
    GetSystemTimeAsFileTime(&ftCurrentTime);
    bReturn = FileTimeToLocalRFC822Date(ftCurrentTime, szCurrentTimeBuffer);
    // The only reason this function fails is a bad filetime. Since we get it from GetSystemTimeAsFileTime, there's no reason it fails.
    _ASSERT(bReturn);

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szCurrentTimeBuffer, lstrlen(szCurrentTimeBuffer));
    if (FAILED(hr))
        goto Exit;

    //Write the MIME header
    hr = pdsnbuff->HrWriteBuffer( (BYTE *) MIME_HEADER, sizeof(MIME_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) "\"", sizeof(CHAR));
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) "\"", sizeof(CHAR));
    if (FAILED(hr))
        goto Exit;

    //write x-DSNContext header
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CONTEXT_HEADER,
                                 sizeof(DSN_CONTEXT_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szDSNContext, cbDSNContext);
    if (FAILED(hr))
        goto Exit;

    wsprintf(szDSNAction, " - %08X", dwDSNAction);
    hr = pdsnbuff->HrWriteBuffer((BYTE *) szDSNAction, strlen(szDSNAction));
    if (FAILED(hr))
        goto Exit;

    wsprintf(szDSNAction, " - %08X", hrStatus);
    hr = pdsnbuff->HrWriteBuffer((BYTE *) szDSNAction, strlen(szDSNAction));
    if (FAILED(hr))
        goto Exit;

    //Get and write the message ID
    if (fGenerateDSNMsgID(szReportingMTA, cbReportingMTA, szBuffer, sizeof(szBuffer)))
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) MSGID_HEADER, sizeof(MSGID_HEADER)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, strlen(szBuffer));
        if (FAILED(hr))
            goto Exit;

        hr = pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_RFC822_MSG_ID,
                                                szBuffer);
        if (FAILED(hr))
            goto Exit;
    }

    //Write the X-Content-Failure DSN
    if(FAILED(hrContent))
    {
        CHAR szHRESULT[11];
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CONTENT_FAILURE_HEADER,
                                     sizeof(DSN_CONTENT_FAILURE_HEADER)-1);
        if(FAILED(hr))
            goto Exit;

        wsprintf(szHRESULT, "0x%08lx", hrContent);

        hr = pdsnbuff->HrWriteBuffer((PBYTE) szHRESULT, 10);
        if(FAILED(hr))
            goto Exit;
    }
    
  Exit:

    if (pIMailMsgRecipients)
    {
        if (pIMailMsgRecipientsAdd)
        {
            hrTmp = pIMailMsgRecipients->WriteList( pIMailMsgRecipientsAdd );
            _ASSERT(SUCCEEDED(hrTmp) && "Go Get Keith");

            if (FAILED(hrTmp) && SUCCEEDED(hr))
                hr = hrTmp;
        }

        pIMailMsgRecipients->Release();
    }

    if (pIMailMsgRecipientsAdd)
        pIMailMsgRecipientsAdd->Release();

    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteDSNHumanReadable ]--------------------
//
//
//  Description:
//      Write human readable portion of DSN (including subject header)
//  Parameters:
//      pIMailMsgProperties     Message DSN is being generated for
//      pIMailMsgREcipeints     Recip Interface for Message
//      prpfctxt                Delivery context that DSN's are being generated for
//      dwDSNActions            DSN actions being taken (after looking at recips)
//                              So we can generate a reasonable subject
//      pdsnbuff                DSN Buffer to write content to
//      PreferredLangId         Preferred language to generate DSN in
//      szMimeBoundary          MIME boundary string
//      cbMimeBoundary          strlen of MIME boundary
//      hrStatus                Status to use to decide which text to display
//  Returns:
//      S_OK on success
//  History:
//      7/5/98 - MikeSwa Created
//      12/15/98 - MikeSwa Added list of recipients & fancy human readable
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNHumanReadable(
    IN IMailMsgProperties *pIMailMsgPropertiesDSN,
    IN IMailMsgRecipients *pIMailMsgRecipients,
    IN IDSNRecipientIterator *pIRecipIter,
    IN DWORD dwDSNActions,
    IN CDSNBuffer *pdsnbuff,
    IN DWORD dwPreferredLangId,
    IN LPSTR szMimeBoundary,
    IN DWORD cbMimeBoundary,
    IN HRESULT hrStatus,
    IN LPSTR szHRTopCustomText,
    IN LPWSTR wszHRTopCustomText,
    IN LPSTR szHRBottomCustomText,
    IN LPWSTR wszHRBottomCustomText)

{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNGenerationSink::HrWriteDSNHumanReadable");
    HRESULT hr = S_OK;
    DWORD dwDSNType = (dwDSNActions & DSN_ACTION_TYPE_MASK);
    LANGID LangID = (LANGID) dwPreferredLangId;
    CUTF7ConversionContext utf7conv(FALSE);
    CUTF7ConversionContext utf7convSubject(TRUE);
    BOOL   fWriteRecips = TRUE;
    WORD   wSubjectID = GENERAL_SUBJECT;
    LPWSTR wszSubject = NULL;
    LPWSTR wszStop    = NULL;
    DWORD  cbSubject = 0;
    LPSTR  szSubject = NULL;
    LPSTR  szSubjectCurrent = NULL;

    if (!fLanguageAvailable(LangID))
    {
        //Use default of server
        LangID = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    }

    hr = pdsnbuff->HrWriteBuffer((BYTE *) SUBJECT_HEADER, sizeof(SUBJECT_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    //Set conversion context to UTF7 for RFC1522 subject
    pdsnbuff->SetConversionContext(&utf7convSubject);

    //Write subject with useful info
    if (((DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL) & dwDSNType) == dwDSNType)
        wSubjectID = FAILURE_SUBJECT;
    else if (DSN_ACTION_RELAYED == dwDSNType)
        wSubjectID = RELAY_SUBJECT;
    else if (DSN_ACTION_DELAYED == dwDSNType)
        wSubjectID = DELAY_SUBJECT;
    else if (DSN_ACTION_DELIVERED == dwDSNType)
        wSubjectID = DELIVERED_SUBJECT;
    else if (DSN_ACTION_EXPANDED == dwDSNType)
        wSubjectID = EXPANDED_SUBJECT;

    hr = pdsnbuff->HrWriteResource(wSubjectID, LangID);
    if (FAILED(hr))
        goto Exit;

    //Write *English* subject for Queue Admin/Message tracking
    //Use english, becuase we return a ASCII string to queue admin
    hr = pdsnbuff->HrLoadResourceString(wSubjectID,
                            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                            &wszSubject, &cbSubject);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) this, "Unable to get resource for english subject 0x%08X", hr);
    }
    else
    {
        //We need to convert from UNICODE to ASCII... remember resource is not
        //NULL terminated
        szSubject = (LPSTR) pvMalloc(cbSubject/sizeof(WCHAR) + 1);
        wszStop = wszSubject + (cbSubject/sizeof(WCHAR));
        if (szSubject)
        {
            szSubjectCurrent = szSubject;
            while ((wszSubject < wszStop) && *wszSubject)
            {
                wctomb(szSubjectCurrent, *wszSubject);
                szSubjectCurrent++;
                wszSubject++;
            }
            *szSubjectCurrent = '\0';
            pIMailMsgPropertiesDSN->PutStringA(IMMPID_MP_RFC822_MSG_SUBJECT, szSubject);
            FreePv(szSubject);
        }

    }



    pdsnbuff->ResetConversionContext();

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    //write summary saying that this is a MIME message
    hr = pdsnbuff->HrWriteBuffer((BYTE *) MESSAGE_SUMMARY, sizeof(MESSAGE_SUMMARY)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    //Write content type
    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_CONTENT_TYPE, sizeof(MIME_CONTENT_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HUMAN_READABLE_TYPE, sizeof(DSN_HUMAN_READABLE_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_MIME_CHARSET_HEADER, sizeof(DSN_MIME_CHARSET_HEADER)-1);
    if (FAILED(hr))
        goto Exit;

    //For now... we do our encoding as UTF7.... put that as the charset
    hr = pdsnbuff->HrWriteBuffer((BYTE *) UTF7_CHARSET, sizeof(UTF7_CHARSET)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    //Set conversion context to UTF7
    pdsnbuff->SetConversionContext(&utf7conv);
    //
    // Custom header text
    //
    if(szHRTopCustomText)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) szHRTopCustomText, lstrlenA(szHRTopCustomText));
        if(FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;
    }
    if(wszHRTopCustomText)
    {
        hr = pdsnbuff->HrWriteModifiedUnicodeString(wszHRTopCustomText);
        if(FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

    }

    hr = pdsnbuff->HrWriteResource(DSN_SUMMARY, LangID);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    //Describe the type of DSN
    if (((DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL) & dwDSNType) == dwDSNType)
    {
        //See if we have a failure-specific message
        switch(hrStatus)
        {
#ifdef NEVER
            //CAT can generate errors other than unresolved recipeints
            //We will use the generic DSN failure message rather than confuse
            //recipients
            case CAT_W_SOME_UNDELIVERABLE_MSGS:
                hr = pdsnbuff->HrWriteResource(FAILURE_SUMMARY_MAILBOX, LangID);
                break;
#endif //NEVER
           case AQUEUE_E_MAX_HOP_COUNT_EXCEEDED:
                hr = pdsnbuff->HrWriteResource(FAILURE_SUMMARY_HOP, LangID);
                break;
            case AQUEUE_E_MSG_EXPIRED:
            case AQUEUE_E_HOST_NOT_RESPONDING:
            case AQUEUE_E_CONNECTION_DROPPED:
                hr = pdsnbuff->HrWriteResource(FAILURE_SUMMARY_EXPIRE, LangID);
                break;
            default:
                hr = pdsnbuff->HrWriteResource(FAILURE_SUMMARY, LangID);
        }
        if (FAILED(hr))
            goto Exit;
    }
    else if (DSN_ACTION_RELAYED == dwDSNType)
    {
        hr = pdsnbuff->HrWriteResource(RELAY_SUMMARY, LangID);
        if (FAILED(hr))
            goto Exit;
    }
    else if (DSN_ACTION_DELAYED == dwDSNType)
    {
        //UE want this three line warning.
        hr = pdsnbuff->HrWriteResource(DELAY_WARNING, LangID);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteResource(DELAY_DO_NOT_SEND, LangID);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteResource(DELAY_SUMMARY, LangID);
        if (FAILED(hr))
            goto Exit;
    }
    else if (DSN_ACTION_DELIVERED == dwDSNType)
    {
        hr = pdsnbuff->HrWriteResource(DELIVERED_SUMMARY, LangID);
        if (FAILED(hr))
            goto Exit;
    }
    else if (DSN_ACTION_EXPANDED == dwDSNType)
    {
        hr = pdsnbuff->HrWriteResource(EXPANDED_SUMMARY, LangID);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        //In retail this will cause an extra blank line to appear in the DSN,
        _ASSERT(0 && "Unsupported DSN Action");
        fWriteRecips = FALSE;
    }

    //Write a list of recipients for this DSN
    if (fWriteRecips)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = HrWriteHumanReadableListOfRecips(pIMailMsgRecipients, pIRecipIter,
                                              dwDSNType, pdsnbuff);

        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;
    }
    //
    // Custom trailer text
    //
    if(wszHRBottomCustomText)
    {
        hr = pdsnbuff->HrWriteModifiedUnicodeString(wszHRBottomCustomText);
        if(FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;
    }
    if(szHRBottomCustomText)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) szHRBottomCustomText, lstrlenA(szHRBottomCustomText));
        if(FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;
    }

    //Extra space to have nicer formatting in Outlook 97.
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //Reset resource conversion context to default
    pdsnbuff->ResetConversionContext();


  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteDSNReportPerMsgProperties ]-----------
//
//
//  Description:
//      Write the per-msg portion of the DSN Report
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to generate DSN for
//      pdsnbuff                CDSNBuffer to write content to
//      szReportingMTA          MTA requesting DSN
//      cbReportingMTA          String length of reporting MTA
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//  Returns:
//      S_OK on success
//  History:
//      7/6/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNReportPerMsgProperties(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN CDSNBuffer *pdsnbuff,
                                IN LPSTR szReportingMTA,
                                IN DWORD cbReportingMTA,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary)
{
    HRESULT hr = S_OK;
    CHAR szPropBuffer[PROP_BUFFER_SIZE];
    _ASSERT(szReportingMTA && cbReportingMTA);

    //Write properly formatted MIME boundary and report type
    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER,
            sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_CONTENT_TYPE,
            sizeof(MIME_CONTENT_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_MIME_TYPE, sizeof(DSN_MIME_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //Write DSN_HEADER_ENVID if we have it
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_DSN_ENVID_VALUE,
                    PROP_BUFFER_SIZE, szPropBuffer);
    if (SUCCEEDED(hr))
    {
        //Prop found
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_ENVID,
                    sizeof(DSN_HEADER_ENVID)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szPropBuffer, lstrlen(szPropBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
            hr = S_OK;
        else
            goto Exit;
    }

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_REPORTING_MTA,
                sizeof(DSN_HEADER_REPORTING_MTA)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szReportingMTA, cbReportingMTA);
    if (FAILED(hr))
        goto Exit;

    //Write DSN_HEADER_RECEIVED_FROM if we have it
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_HELO_DOMAIN,
                    PROP_BUFFER_SIZE, szPropBuffer);
    if (SUCCEEDED(hr))
    {
        //Prop found
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_RECEIVED_FROM,
                    sizeof(DSN_HEADER_RECEIVED_FROM)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szPropBuffer, lstrlen(szPropBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
            hr = S_OK;
        else
            goto Exit;
    }

    //Write DSN_HEADER_ARRIVAL_DATE if we have it
    hr = pIMailMsgProperties->GetStringA(IMMPID_MP_ARRIVAL_TIME,
                    PROP_BUFFER_SIZE, szPropBuffer);
    if (SUCCEEDED(hr))
    {
        //Prop found
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_ARRIVAL_DATE,
                    sizeof(DSN_HEADER_ARRIVAL_DATE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szPropBuffer, lstrlen(szPropBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
            hr = S_OK;
        else
            goto Exit;
    }

  Exit:
    return hr;
}


//---[ CDefaultDSNSink::HrWriteDSNReportPreRecipientProperties ]-----
//
//
//  Description:
//      Write a per-recipient portion of the DSN Report
//  Parameters:
//      pIMailMsgRecipients     IMailMsgProperties that DSN is being generated for
//      pdsnbuff                CDSNBuffer to write content to
//      iRecip                  Recipient to generate report for
//      szExpireTime            Time (if known) when message expires
//      cbExpireTime            size of string
//      dwDSNAction             DSN Action to take for this recipient
//      dwRFC821Status          Global RFC821 status DWORD
//      hrStatus                Global HRESULT status
//  Returns:
//      S_OK on success
//  History:
//      7/6/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNReportPreRecipientProperties(
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN CDSNBuffer *pdsnbuff,
                                IN DWORD iRecip,
                                IN LPSTR szExpireTime,
                                IN DWORD cbExpireTime,
                                IN DWORD dwDSNAction,
                                IN DWORD dwRFC821Status,
                                IN HRESULT hrStatus)
{
    HRESULT hr = S_OK;
    CHAR szTempBuffer[PROP_BUFFER_SIZE * sizeof(WCHAR)];    // Multiply by sizeof(WCHAR) because
                                                            // we'll also use it for Unicode props
    LPSTR szBuffer = szTempBuffer;
    LPWSTR wszBuffer = (LPWSTR) szTempBuffer;
    CUTF7ConversionContext utf7conv(TRUE);
    CHAR szStatus[STATUS_STRING_SIZE];
    BOOL fFoundDiagnostic = FALSE;
    CHAR szAddressType[PROP_BUFFER_SIZE];
    DWORD cbBuffer = 0;

    //Write blank line between recipient reports (recip fields start with \n)
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //Write DSN_RP_HEADER_ORCPT if we have it
    hr = pIMailMsgRecipients->GetStringA(iRecip, IMMPID_RP_DSN_ORCPT_VALUE,
        PROP_BUFFER_SIZE, szBuffer);
    if (S_OK == hr) //prop was found
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ORCPT, sizeof(DSN_RP_HEADER_ORCPT)-1);
        if (FAILED(hr))
            goto Exit;

        //write address value - type should be included in this property
        hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else if (FAILED(hr))
    {
        if (MAILMSG_E_PROPNOTFOUND == hr)
            hr = S_OK;
        else
            goto Exit;
    }

    //Write DSN_RP_HEADER_FINAL_RECIP
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_FINAL_RECIP, sizeof(DSN_RP_HEADER_FINAL_RECIP)-1);
    if (FAILED(hr))
        goto Exit;

    //Check for IMMPID_RP_DSN_PRE_CAT_ADDRESS first
    hr = pIMailMsgRecipients->GetStringA(iRecip, IMMPID_RP_DSN_PRE_CAT_ADDRESS,
        PROP_BUFFER_SIZE, szBuffer);
    if (S_OK == hr) //prop was found
    {
        //write address value - type should be included in this property
        hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
        if (FAILED(hr))
            goto Exit;
    }
    else //we need to use IMMPID_RP_ADDRESS_SMTP instead
    {
        hr = HrGetRecipAddressAndType(pIMailMsgRecipients, iRecip, PROP_BUFFER_SIZE,
                                      szBuffer, sizeof(szAddressType), szAddressType);

        if (SUCCEEDED(hr))
        {
            //write address type
            hr = pdsnbuff->HrWriteBuffer((BYTE *) szAddressType, lstrlen(szAddressType));
            if (FAILED(hr))
                goto Exit;

            hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_TYPE_DELIMITER, sizeof(DSN_HEADER_TYPE_DELIMITER)-1);
            if (FAILED(hr))
                goto Exit;

            //write address value
            hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
            if (FAILED(hr))
                goto Exit;
        }
        else
        {
            _ASSERT(SUCCEEDED(hr) && "Recipient address *must* be present");
        }


    }

    //Write DSN_RP_HEADER_ACTION
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION, sizeof(DSN_RP_HEADER_ACTION)-1);
    if (FAILED(hr))
        goto Exit;

    if (dwDSNAction & (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL))
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_FAILURE,
                        sizeof(DSN_RP_HEADER_ACTION_FAILURE)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else if (dwDSNAction & DSN_ACTION_DELAYED)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_DELAYED,
                        sizeof(DSN_RP_HEADER_ACTION_DELAYED)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else if (dwDSNAction & DSN_ACTION_RELAYED)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_RELAYED,
                        sizeof(DSN_RP_HEADER_ACTION_RELAYED)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else if (dwDSNAction & DSN_ACTION_DELIVERED)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_DELIVERED,
                        sizeof(DSN_RP_HEADER_ACTION_DELIVERED)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else if (dwDSNAction & DSN_ACTION_EXPANDED)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_ACTION_EXPANDED,
                        sizeof(DSN_RP_HEADER_ACTION_EXPANDED)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        _ASSERT(0 && "No DSN Action requested");
    }


    //Write DSN_RP_HEADER_STATUS
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_STATUS,
                    sizeof(DSN_RP_HEADER_STATUS)-1);
    if (FAILED(hr))
        goto Exit;

    //Get status code
    hr = HrGetStatusCode(pIMailMsgRecipients, iRecip, dwDSNAction,
            dwRFC821Status, hrStatus,
            PROP_BUFFER_SIZE, szBuffer, szStatus);
    if (FAILED(hr))
        goto Exit;
    if (S_OK == hr)
    {
        //found diagnostic code
        fFoundDiagnostic = TRUE;
    }

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szStatus, lstrlen(szStatus));
    if (FAILED(hr))
        goto Exit;

    if (fFoundDiagnostic)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_DIAG_CODE,
                        sizeof(DSN_RP_HEADER_DIAG_CODE)-1);
        if (FAILED(hr))
            goto Exit;

        //
        // The SMTP response may be CRLF terminated, and we cannot put
        // the CRLF in the DSN since CRLF is the header-separator. So we
        // check for CRLF and strip it... actually since CRLF *must* be
        // the last 2 bytes in the string (if present), and since CR isn't
        // allowed to be part of the SMTP response, we cheat a little and
        // only set the second last byte to NULL if it is CR.
        //
        cbBuffer = lstrlen(szBuffer);
        if(szBuffer[cbBuffer-2] == '\r')
        {
            _ASSERT(szBuffer[cbBuffer-1] == '\n');
            szBuffer[cbBuffer-2] = '\0';
            cbBuffer -= 2;  // We chomped the last 2 chars
        }

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, cbBuffer);
        if (FAILED(hr))
            goto Exit;

    }

    //Write DSN_RP_HEADER_RETRY_UNTIL using expire time if delay
    if (szExpireTime && (DSN_ACTION_DELAYED & dwDSNAction))
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RP_HEADER_RETRY_UNTIL,
                        sizeof(DSN_RP_HEADER_RETRY_UNTIL)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) szExpireTime, cbExpireTime);
        if (FAILED(hr))
            goto Exit;
    }

    //Write the X-Display-Name header last
    hr = pIMailMsgRecipients->GetStringW(iRecip, IMMPID_RP_DISPLAY_NAME,
                            PROP_BUFFER_SIZE, wszBuffer);
    if ( (hr == S_OK) &&
         (wszBuffer[0] != L'\0') )
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADER_DISPLAY_NAME, sizeof(DSN_HEADER_DISPLAY_NAME) - 1);
        if (FAILED(hr))
            goto Exit;

        //
        // Convert the X-Display-Name from UNICODE to RFC 1522. We also replace all
        // whitespace characters in the input with Unicode whitespace (0x20). See
        // documentation of HrWriteModifiedUnicodeBuffer for the reasons.
        //
        pdsnbuff->SetConversionContext(&utf7conv);

        hr = pdsnbuff->HrWriteModifiedUnicodeString(wszBuffer);

        pdsnbuff->ResetConversionContext();

        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
    }
    else
    {
        //  Not a fatal error if there is no display name...
        hr = S_OK;
    }

  Exit:
    return hr;
}


//---[ CDefaultDSNSink::HrLogDSNGenerationEvent ]------------------------------
//
//
//  Description:
//      Write a per-recipient portion of the DSN Report
//  Parameters:
//      pIMailMsgRecipients     IMailMsgProperties that DSN is being generated for
//      pdsnbuff                CDSNBuffer to write content to
//      iRecip                  Recipient to generate report for
//      szExpireTime            Time (if known) when message expires
//      cbExpireTime            size of string
//      dwDSNAction             DSN Action to take for this recipient
//      dwRFC821Status          Global RFC821 status DWORD
//      hrStatus                Global HRESULT status
//  Returns:
//      S_OK on success
//  History:
//      6/12/2000 - dbraun created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrLogDSNGenerationEvent(
                                ISMTPServer *pISMTPServer,
                                IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN DWORD iRecip,
                                IN DWORD dwDSNAction,
                                IN DWORD dwRFC821Status,
                                IN HRESULT hrStatus)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrLogDSNGenerationEvent");

    HRESULT hr = S_OK;
    CHAR szBuffer[PROP_BUFFER_SIZE * sizeof(WCHAR)];
    CHAR szDiagBuffer[PROP_BUFFER_SIZE * sizeof(WCHAR)];
    CHAR szStatus[STATUS_STRING_SIZE];
    CHAR szRecipient[PROP_BUFFER_SIZE * sizeof(WCHAR)];
    CHAR szMessageID[PROP_BUFFER_SIZE * sizeof(WCHAR)];
    CHAR szAddressType[PROP_BUFFER_SIZE];
    ISMTPServerEx   *pISMTPServerEx = NULL;
    DWORD   cbPropSize = 0;

    const char *rgszSubstrings[] = {
                szStatus,
                szRecipient,
                szMessageID,
            };

    _ASSERT(pISMTPServer);

    // If this is not an NDR, skip it
    if (!(dwDSNAction & (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL)))
        goto Exit;

    // See if we can QI for ISMTPServerEx
    hr = pISMTPServer->QueryInterface(
                IID_ISMTPServerEx,
                (LPVOID *)&pISMTPServerEx);
    if (FAILED(hr))
    {
        ErrorTrace((LPARAM) pISMTPServer,
            "Unable to QI for ISMTPServerEx 0x%08X",hr);
        pISMTPServerEx = NULL;
        goto Exit;
    }

    // Get the final recipient name

    //Check for IMMPID_RP_DSN_PRE_CAT_ADDRESS first
    hr = pIMailMsgRecipients->GetStringA(iRecip, IMMPID_RP_DSN_PRE_CAT_ADDRESS,
        PROP_BUFFER_SIZE, szRecipient);
    if (S_OK != hr) // S_OK = prop was found, otherwise ...
    {
        //we need to use IMMPID_RP_ADDRESS_SMTP instead
        hr = HrGetRecipAddressAndType(pIMailMsgRecipients, iRecip, PROP_BUFFER_SIZE,
                                      szBuffer, sizeof(szAddressType), szAddressType);
        if (SUCCEEDED(hr))
        {
            // Construct the address string
            sprintf(szRecipient, "%s%s%s", szAddressType, DSN_HEADER_TYPE_DELIMITER, szBuffer);
        }
        else
        {
            _ASSERT(SUCCEEDED(hr) && "Recipient address *must* be present");
            goto Exit;
        }
    }

    // Get status code
    hr = HrGetStatusCode(pIMailMsgRecipients, iRecip, dwDSNAction,
            dwRFC821Status, hrStatus,
            PROP_BUFFER_SIZE, szDiagBuffer, szStatus);
    if (FAILED(hr))
        goto Exit;

    // Get the message ID
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_MSG_ID,
                          sizeof(szMessageID), &cbPropSize, (PBYTE) szMessageID);
    if (FAILED(hr))
        goto Exit;

    // Trigger Log Event
    pISMTPServerEx->TriggerLogEvent(
        AQUEUE_E_NDR_GENERATED_EVENT,   // Event ID
        TRAN_CAT_CONNECTION_MANAGER,    // Category
        3,                              // Word count of substring
        rgszSubstrings,                 // Substring
        EVENTLOG_WARNING_TYPE,          // Type of the message
        hrStatus,                       // error code
        LOGEVENT_LEVEL_MAXIMUM,         // Logging level
        szRecipient,                    // Key to identify this event
        LOGEVENT_FLAG_ALWAYS,           // Event logging option
        0xffffffff,                     // format string's index in substring
        GetModuleHandle(AQ_MODULE_NAME) // module handle to format a message
        );


  Exit:
    if (pISMTPServerEx) {
        pISMTPServerEx->Release();
    }

    TraceFunctLeave();
    return hr;
}


//---[ CDefaultDSNSink::HrWriteDSNClosingAndOriginalMessage ]--------
//
//
//  Description:
//      Writes the closing of the DSN as well as the end of the
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to generate DSN for
//      pIMailMsgPropertiesDSN  IMailMsgProperties for DSN
//      pdsnbuff                CDSNBuffer to write content to
//      pDestFile               PFIO_CONTEXT for destination file
//      dwDSNAction             DSN actions for this DSN
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//      dwDSNRetTypeIN          DSN return type
//      dwOrigMsgSize           Content size of the original message
//
//  Returns:
//
//  History:
//      7/6/98 - MikeSwa Created
//      1/6/2000 - MikeSwa Modified to add RET=HDRS support
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteDSNClosingAndOriginalMessage(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN DWORD   dwDSNAction,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary,
                                IN DWORD dwDSNRetTypeIN,
                                IN DWORD dwOrigMsgSize)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteDSNClosingAndOriginalMessage");
    HRESULT hr = S_OK;
    DWORD dwDSNRetType = dwDSNRetTypeIN;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    //Write Body content type MIME_CONTENT_TYPE = rfc822
    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_CONTENT_TYPE, sizeof(MIME_CONTENT_TYPE)-1);
    if (FAILED(hr))
        goto Exit;

    if (dwDSNRetType == DSN_RET_PARTIAL_HDRS)
    {
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_HEADERS_TYPE, sizeof(DSN_HEADERS_TYPE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = HrWriteOriginalMessagePartialHeaders(
            pIMailMsgProperties, pIMailMsgPropertiesDSN,
            pdsnbuff, pDestFile, szMimeBoundary, cbMimeBoundary);
    }
    else
    {
        //
        //$$TODO: Check for DSN_RET_HDRS and implement a function that
        // returns the original headers only
        //
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_RFC822_TYPE, sizeof(DSN_RFC822_TYPE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
        if (FAILED(hr))
            goto Exit;

        hr = HrWriteOriginalMessageFull(
            pIMailMsgProperties, pIMailMsgPropertiesDSN,
            pdsnbuff, pDestFile, szMimeBoundary, cbMimeBoundary,
            dwOrigMsgSize);
    }
    if (FAILED(hr))
        goto Exit;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrInitialize ]-------------------------------
//
//
//  Description:
//      Performs initialization...
//          - Sets init flag
//          - Currently nothing else
//  Parameters:
//      -
//  Returns:
//      S_OK on SUCCESS
//  History:
//      7/3/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrInitialize()
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrInitialize");
    HRESULT hr = S_OK;

    m_fInit = TRUE;
    srand(GetTickCount());
    TraceFunctLeave();
    return hr;
}
//---[ CDefaultDSNSink::GetCurrentMimeBoundary ]---------------------
//
//
//  Description:
//      Creates unique MIME-boundary for message.
//
//      Format we are using for boundary is string versions of the following:
//          MIME_BOUNDARY_CONSTANT
//          FILETIME at start
//          DWORD count of DSNs Requested
//          16 bytes of our virtual server's domain name
//  Parameters:
//      IN     szReportingMTA   reporting MTA
//      IN     cbReportingMTA   String length of reporting MTA
//      IN OUT szMimeBoundary   Buffer to put boundary in (size is MIME_BOUNDARY_SIZE)
//      OUT    cbMimeBoundary   Amount of buffer used for MIME Boundary
//  Returns:
//      -
//  History:
//      7/6/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
void CDefaultDSNSink::GetCurrentMimeBoundary(
                    IN LPSTR szReportingMTA,
                    IN DWORD cbReportingMTA,
                    IN OUT CHAR szMimeBoundary[MIME_BOUNDARY_SIZE],
                    OUT DWORD *pcbMimeBoundary)
{
    _ASSERT(MIME_BOUNDARY_RFC2046_LIMIT >= MIME_BOUNDARY_SIZE);

    DWORD   iCurrentOffset = 0;
    szMimeBoundary[MIME_BOUNDARY_SIZE-1] = '\0';
    CHAR    *pcharCurrent = NULL;
    CHAR    *pcharStop = NULL;

    memcpy(szMimeBoundary+iCurrentOffset, MIME_BOUNDARY_CONSTANT,
            sizeof(MIME_BOUNDARY_CONSTANT)-1);

    iCurrentOffset += sizeof(MIME_BOUNDARY_CONSTANT)-1;

    memcpy(szMimeBoundary+iCurrentOffset, m_szPerInstanceMimeBoundary,
            MIME_BOUNDARY_START_TIME_SIZE);

    iCurrentOffset += MIME_BOUNDARY_START_TIME_SIZE;

    wsprintf(szMimeBoundary+iCurrentOffset, "%08X",
            InterlockedIncrement((PLONG) &m_cDSNsRequested));

    iCurrentOffset += 8;

    if (cbReportingMTA >= MIME_BOUNDARY_SIZE-iCurrentOffset)
    {
        memcpy(szMimeBoundary+iCurrentOffset, szReportingMTA,
            MIME_BOUNDARY_SIZE-iCurrentOffset - 1);
        *pcbMimeBoundary = MIME_BOUNDARY_SIZE-1;
    }
    else
    {
        memcpy(szMimeBoundary+iCurrentOffset, szReportingMTA,
            cbReportingMTA);
        szMimeBoundary[iCurrentOffset + cbReportingMTA] = '\0';
        *pcbMimeBoundary = iCurrentOffset + cbReportingMTA;
    }

    //Now we need to verify that the passed in string can be part of a valid
    //MIME Header
    pcharStop = szMimeBoundary + *pcbMimeBoundary;
    for (pcharCurrent = szMimeBoundary + iCurrentOffset;
         pcharCurrent < pcharStop;
         pcharCurrent++)
    {
      if (!fIsValidMIMEBoundaryChar(*pcharCurrent))
        *pcharCurrent = '?';  //turn it into a valid character
    }

    _ASSERT_MIME_BOUNDARY(szMimeBoundary);

    _ASSERT('\0' == szMimeBoundary[MIME_BOUNDARY_SIZE-1]);
}

//---[ CDefaultDSNSink::HrWriteOriginalMessageFull ]-----------------
//
//
//  Description:
//      Writes the entire original message to the DSN
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to generate DSN for
//      pIMailMsgPropertiesDSN  IMailMsgProperties for DSN
//      pdsnbuff                CDSNBuffer to write content to
//      pDestFile               PFIO_CONTEXT for destination file
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//      dwOrigMsgSize           Size of original message
//
//  Returns:
//      S_OK on success
//  History:
//      1/6/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteOriginalMessageFull(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary,
                                IN DWORD dwOrigMsgSize)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteOriginalMessageFull");
    HRESULT hr = S_OK;
    DWORD   dwFileSize = 0;
    DWORD   dwDontCare = 0;

    hr = pdsnbuff->HrSeekForward(dwOrigMsgSize, &dwFileSize);
    if (FAILED(hr))
        goto Exit;

    //Set size hint property on DSN for Queue Admin/Message Tracking
    hr = pIMailMsgPropertiesDSN->PutDWORD(IMMPID_MP_MSG_SIZE_HINT,
                                       dwOrigMsgSize + dwFileSize);
    if (FAILED(hr))
    {
        //We really don't care too much about a failure with this
        ErrorTrace((LPARAM) this, "Error writing size hint 0x%08X", hr);
        hr = S_OK;
    }

    //Write at end of file - *before* file handle is lost to IMailMsg,
    hr = HrWriteMimeClosing(pdsnbuff, szMimeBoundary, cbMimeBoundary, &dwDontCare);
    if (FAILED(hr))
        goto Exit;

    //write body
    hr = pIMailMsgProperties->CopyContentToFileAtOffset(pDestFile, dwFileSize, NULL);
    if (FAILED(hr))
        goto Exit;
  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteOriginalMessagePartialHeaders ]--------------
//
//
//  Description:
//      Writes only some headers of the original message to the DSN
//  Parameters:
//      pIMailMsgProperties     IMailMsgProperties to generate DSN for
//      pIMailMsgPropertiesDSN  IMailMsgProperties for DSN
//      pdsnbuff                CDSNBuffer to write content to
//      pDestFile               PFIO_CONTEXT for destination file
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//  Returns:
//      S_OK on success
//  History:
//      1/6/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteOriginalMessagePartialHeaders(
                                IN IMailMsgProperties *pIMailMsgProperties,
                                IN IMailMsgProperties *pIMailMsgPropertiesDSN,
                                IN CDSNBuffer *pdsnbuff,
                                IN PFIO_CONTEXT pDestFile,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteOriginalMessagePartialHeaders");
    HRESULT hr = S_OK;
    IMailMsgRecipients *pRecips = NULL;
    DWORD   dwFileSize = 0;
    DWORD   cbPropSize = 0;
    CHAR    szPropBuffer[1026] = "";

    //Loop through the 822 properties that we care about and write them
    //to the message.  A truely RFC-compliant version would re-parse the
    //messages... and return all the headers

    //
    // From header
    //
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_FROM_ADDRESS,
                          sizeof(szPropBuffer), &cbPropSize, (PBYTE) szPropBuffer);
    if (SUCCEEDED(hr))
    {
        hr = pdsnbuff->HrWriteBuffer((PBYTE)DSN_FROM_HEADER_NO_CRLF,
                                sizeof(DSN_FROM_HEADER_NO_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((PBYTE)szPropBuffer, cbPropSize-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
    }
    //
    // To header
    //
    hr = pdsnbuff->HrWriteBuffer((PBYTE)TO_HEADER_NO_CRLF,
                                 sizeof(TO_HEADER_NO_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pIMailMsgProperties->GetProperty(
        IMMPID_MP_RFC822_TO_ADDRESS,
        sizeof(szPropBuffer),
        &cbPropSize,
        (PBYTE) szPropBuffer);
    if(SUCCEEDED(hr))
    {
        hr = pdsnbuff->HrWriteBuffer((PBYTE)szPropBuffer, cbPropSize-1);
        if (FAILED(hr))
            goto Exit;
    }        
    else
    {
        //
        // Write the 821 recipients as 822 recipients
        //
        DWORD dwcRecips = 0;
        DWORD dwCount = 0;
        BOOL  fPrintedFirstRecip = FALSE;

        hr = pIMailMsgProperties->QueryInterface(
            IID_IMailMsgRecipients,
            (PVOID *) &pRecips);
        if(FAILED(hr))
            goto Exit;

        hr = pRecips->Count(&dwcRecips);
        if(FAILED(hr))
            goto Exit;

        for(dwCount = 0; dwCount < dwcRecips; dwCount++)
        {

            hr = pRecips->GetStringA(
                dwCount,                // Index
                IMMPID_RP_ADDRESS_SMTP,
                sizeof(szPropBuffer),
                szPropBuffer);
            if(SUCCEEDED(hr))
            {
                if(fPrintedFirstRecip)
                {
                    hr = pdsnbuff->HrWriteBuffer(
                        (PBYTE) ADDRESS_SEPERATOR,
                        sizeof(ADDRESS_SEPERATOR)-1);
                    if(FAILED(hr))
                        goto Exit;
                }
                hr = pdsnbuff->HrWriteBuffer(
                    (PBYTE) szPropBuffer,
                    lstrlen(szPropBuffer));
                if(FAILED(hr))
                    goto Exit;

                fPrintedFirstRecip = TRUE;
            }
        }
    }
    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //
    // Message ID
    //
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_MSG_ID,
                          sizeof(szPropBuffer), &cbPropSize, (PBYTE) szPropBuffer);
    if (SUCCEEDED(hr))
    {
        hr = pdsnbuff->HrWriteBuffer((PBYTE)MSGID_HEADER_NO_CRLF,
                                     sizeof(MSGID_HEADER_NO_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((PBYTE)szPropBuffer, cbPropSize-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
    }

    //
    // Subject header
    //
    hr = pIMailMsgProperties->GetProperty(IMMPID_MP_RFC822_MSG_SUBJECT,
                        sizeof(szPropBuffer), &cbPropSize, (PBYTE)szPropBuffer);
    if (SUCCEEDED(hr))
    {
        hr = pdsnbuff->HrWriteBuffer((PBYTE)SUBJECT_HEADER_NO_CRLF,
                                     sizeof(SUBJECT_HEADER_NO_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((PBYTE)szPropBuffer, cbPropSize-1);
        if (FAILED(hr))
            goto Exit;
        hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
        if (FAILED(hr))
            goto Exit;
    }

    hr = HrWriteMimeClosing(pdsnbuff, szMimeBoundary, cbMimeBoundary, &dwFileSize);
    if (FAILED(hr))
        goto Exit;

    //Set size hint property on DSN for Queue Admin/Message Tracking
    hr = pIMailMsgPropertiesDSN->PutDWORD(IMMPID_MP_MSG_SIZE_HINT, dwFileSize);
    if (FAILED(hr))
    {
        //We really don't care too much about a failure with this
        ErrorTrace((LPARAM) this, "Error writing size hint 0x%08X", hr);
        hr = S_OK;
    }

  Exit:
    if(pRecips)
        pRecips->Release();
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrWriteMimeClosing ]-------------------------
//
//
//  Description:
//      Write the MIME closing of the DSN after the 3rd MIME part.
//  Parameters:
//      pdsnbuff                CDSNBuffer to write content to
//      szReportingMTA          MTA requesting DSN
//      cbReportingMTA          String length of reporting MTA
//      szMimeBoundary          MIME boundary for this message
//      cbMimeBoundary          Length of MIME boundary
//  Returns:
//      S_OK on success
//      Failure code from CDSNBuffer on failure
//  History:
//      1/6/2000 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteMimeClosing(
                                IN CDSNBuffer *pdsnbuff,
                                IN LPSTR szMimeBoundary,
                                IN DWORD cbMimeBoundary,
                                OUT DWORD *pcbDSNSize)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrWriteMimeClosing");
    HRESULT hr = S_OK;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) BLANK_LINE, sizeof(BLANK_LINE)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) szMimeBoundary, cbMimeBoundary);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) MIME_DELIMITER, sizeof(MIME_DELIMITER)-1);
    if (FAILED(hr))
        goto Exit;

    hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-1);
    if (FAILED(hr))
        goto Exit;

    //flush buffers
    hr = pdsnbuff->HrFlushBuffer(pcbDSNSize);
    if (FAILED(hr))
        goto Exit;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrGetStatusCode ]----------------------------
//
//
//  Description:
//      Determines the status code (and diagnostic code) for a recipient.  Will
//      check the following (in order) to determine the status code to return:
//          IMMPID_RP_SMTP_STATUS_STRING (per-recipient diagnostic code)
//          Combination of:
//              IMMPID_RP_RECIPIENT_FLAGS (determine who set the error)
//              IMMPID_RP_ERROR_CODE (per-recipient HRESULT error code)
//              dwDSNAction - kind of DSN being sent
//          Combination of:
//              IMMPID_RP_RECIPIENT_FLAGS (determine who set the error)
//              dwRFC821Status - per message status code
//              dwDSNAction - kind of DSN being sent
//          Combination of:
//              IMMPID_RP_RECIPIENT_FLAGS (determine who set the error)
//              hrStatus - per message HRESULT failure
//              dwDSNAction - kind of DSN being sent
//      Status codes are defined in RFC 1893 as follows:
//          status-code = class "." subject "." detail
//          class = "2"/"4"/"5"
//          subject = 1*3digit
//          detail = 1*3digit
//
//          Additionally, the class of "2", "4", and "5" correspond to success,
//          transient failure, and hard failure respectively
//  Parameters:
//      pIMailMsgRecipients     IMailMsgRecipients of message being DSN'd
//      iRecip                  The index of the recipient we are looking at
//      dwDSNAction             The action code returned by fdwGetDSNAction
//      dwRFC821Status          RFC821 Status code returned by SMTP
//      hrStatus                HRESULT error if SMTP status is unavailable
//      cbExtendedStatus        Size of buffer for diagnostic code
//      szExtendedStatus        Buffer for diagnostic code
//      szStatus                Buffer for "n.n.n" formatted status code
//  Returns:
//      S_OK    Success - found diagnostic code as well
//      S_FALSE Success - but no diagnostic code
//  History:
//      7/6/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetStatusCode(
                                IN IMailMsgRecipients *pIMailMsgRecipients,
                                IN DWORD iRecip,
                                IN DWORD dwDSNAction,
                                IN DWORD dwRFC821Status,
                                IN HRESULT hrStatus,
                                IN DWORD cbExtendedStatus,
                                IN OUT LPSTR szExtendedStatus,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE])
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrGetStatusCode");
    HRESULT hr = S_OK;
    HRESULT hrPerRecipStatus = S_OK;
    BOOL fFoundDiagnostic = FALSE;
    BOOL fTryToFindStatusCode = FALSE;
    DWORD dwRecipFlags = 0;

    //Check for IMMPID_RP_SMTP_STATUS_STRING on recipient and try to get
    //status code from there
    hr = pIMailMsgRecipients->GetStringA(iRecip, IMMPID_RP_SMTP_STATUS_STRING,
        cbExtendedStatus, szExtendedStatus);
    if (SUCCEEDED(hr)) //prop was found
    {
        fFoundDiagnostic = TRUE;

        hr = HrGetStatusFromStatus(cbExtendedStatus, szExtendedStatus,
                        szStatus);

        if (S_OK == hr)
            goto Exit;
        else if (S_FALSE == hr)
            hr = S_OK; //not really an error... just get code from someplace else
        else
            goto Exit; //other failure

    }
    else if (MAILMSG_E_PROPNOTFOUND == hr)
    {
        //Not really a hard error
        _ASSERT(!fFoundDiagnostic);
        hr = S_OK;
    }
    else
    {
        goto Exit;
    }
    //Get the recipient flags
    hr = pIMailMsgRecipients->GetDWORD(iRecip, IMMPID_RP_RECIPIENT_FLAGS, &dwRecipFlags);
    if(FAILED(hr))
    {
        ErrorTrace((LPARAM)this, "Failure %08lx to get recipient flags for recip %d", hr, iRecip);
        goto Exit;
    }

    //Get Per Recipient HRESULT
    DEBUG_DO_IT(hrPerRecipStatus = 0xFFFFFFFF);
    hr = pIMailMsgRecipients->GetDWORD(iRecip, IMMPID_RP_ERROR_CODE, (DWORD *) &hrPerRecipStatus);
    if (SUCCEEDED(hr))
    {
        _ASSERT((0xFFFFFFFF != hrPerRecipStatus) && "Property not returned by MailMsg!!!");

        hr = HrGetStatusFromContext(hrPerRecipStatus, dwRecipFlags, dwDSNAction, szStatus);
        if (FAILED(hr))
            goto Exit;

        if (lstrcmp(szStatus, DSN_STATUS_FAILED))
            goto Exit;

        //
        //  We only found a generic status code (DSN_STATUS_FAILED), see if
        //  the global HRESULT or RFC821 status yield anything more specific.
        //
        fTryToFindStatusCode = TRUE;

    }
    else
    {
        if (MAILMSG_E_PROPNOTFOUND != hr)
            goto Exit;      //  An error occurred getting the per-recip status

        //
        //  There is no per-recip status. Fall back to global HRESULT or RFC821
        //  status string to try generate a status code.
        //
        fTryToFindStatusCode = TRUE;
    }

    if (fTryToFindStatusCode)
    {
        //
        //  We either couldn't generate a status string, or the status string
        //  wasn't good enough, try the global HRESULT and RFC822 status to
        //  generate a DSN status string.
        //

        hr = HrGetStatusFromRFC821Status(dwRFC821Status, szStatus);
        if (FAILED(hr))
            goto Exit;

        if (S_OK == hr) //got status code from dwRFC821Status
            goto Exit;

        //If all else fails Get status code using global HRESULT & context
        hr = HrGetStatusFromContext(hrStatus, dwRecipFlags, dwDSNAction, szStatus);
        if (FAILED(hr))
            goto Exit;
    }



  Exit:

    if (SUCCEEDED(hr))
    {
        if (fFoundDiagnostic)
            hr = S_OK;
        else
            hr = S_FALSE;
    }
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrGetStatusFromStatus ]----------------------
//
//
//  Description:
//      Parse status code from RFC2034 extended status code string
//
//      If string is not a complete RFC2034 extended status string, this
//      function will attempt to parse the RFC821 SMTP return code and
//      turn it into an extended status string.
//  Parameters:
//      IN     cbExtendedStatus     Size of extended status buffer
//      IN     szExtendedStatus     Extended status buffer
//      IN OUT szStatus             RFC1893 formatted status code
//  Returns:
//      S_OK on success
//      S_FALSE if could not be parsed
//      FAILED if other error occurs
//  History:
//      7/7/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetStatusFromStatus(
                                IN DWORD cbExtendedStatus,
                                IN OUT LPSTR szExtendedStatus,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE])
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrGetStatusFromStatus");
    HRESULT hr = S_OK;
    DWORD   dwRFC821Status = 0;
    BOOL fFormattedCorrectly = FALSE;
    CHAR *pchStatus = NULL;
    CHAR *pchDiag = NULL; //ptr to status string supplied by SMTP
    DWORD cNumDigits = 0;
    int i = 0;

    //copy status code from diagnostic string in to status code
    pchStatus = szStatus;
    pchDiag = szExtendedStatus;

    //there must be at least 3 characters to attempt parsing
    if (cbExtendedStatus < MIN_CHAR_FOR_VALID_RFC821)
    {
        hr = S_FALSE;
        goto Exit;
    }

    //check RFC822
    if (!((DSN_STATUS_CH_CLASS_SUCCEEDED == *pchDiag) ||
          (DSN_STATUS_CH_CLASS_TRANSIENT == *pchDiag) ||
          (DSN_STATUS_CH_CLASS_FAILED == *pchDiag)))
    {
        //Doesn't start with RFC822... can't be valid
        hr = S_FALSE;
        goto Exit;
    }

    //RFC2034 must have at least RFC822 + " " + "x.x.x" = 10 chanracters
    if (cbExtendedStatus >= MIN_CHAR_FOR_VALID_RFC2034)
    {
        pchDiag += MIN_CHAR_FOR_VALID_RFC821; //format is "xxx x.x.x"
        //Find first digit
        while(isspace((unsigned char)*pchDiag) && pchDiag < (szExtendedStatus + cbExtendedStatus))
            pchDiag++;

        if ((DSN_STATUS_CH_CLASS_SUCCEEDED == *pchDiag) ||
            (DSN_STATUS_CH_CLASS_TRANSIENT == *pchDiag) ||
            (DSN_STATUS_CH_CLASS_FAILED == *pchDiag))
        {
            //copy status code class
            *pchStatus = *pchDiag;
            pchStatus++;
            pchDiag++;

            //Next character must be a DSN_STATUS_CH_DELIMITER
            if (DSN_STATUS_CH_DELIMITER == *pchDiag)
            {
                *pchStatus = DSN_STATUS_CH_DELIMITER;
                pchStatus++;
                pchDiag++;

                //now parse this 1*3digit "." 1*3digit part
                for (i = 0; i < 3; i++)
                {
                    *pchStatus = *pchDiag;
                    if (!isdigit((unsigned char)*pchDiag))
                    {
                        if (DSN_STATUS_CH_DELIMITER != *pchDiag)
                        {
                            fFormattedCorrectly = FALSE;
                            break;
                        }
                        //copy delimiter
                        *pchStatus = *pchDiag;
                        pchStatus++;
                        pchDiag++;
                        break;
                    }
                    pchStatus++;
                    pchDiag++;
                    fFormattedCorrectly = TRUE; //hace first digit
                }

                if (fFormattedCorrectly) //so far.. so good
                {
                    fFormattedCorrectly = FALSE;
                    for (i = 0; i < 3; i++)
                    {
                        *pchStatus = *pchDiag;
                        if (!isdigit((unsigned char)*pchDiag))
                        {
                            if (!isspace((unsigned char)*pchDiag))
                            {
                                fFormattedCorrectly = FALSE;
                                break;
                            }
                            break;
                        }
                        pchStatus++;
                        pchDiag++;
                        fFormattedCorrectly = TRUE;
                    }

                    //If we have found a good status code... go to exit
                    if (fFormattedCorrectly)
                    {
                        *pchStatus = '\0'; //make sure last CHAR is a NULL
                        goto Exit;
                    }
                }
            }
        }
    }

    //We haven't been able to parse the extended status code, but we
    //know we have at least a valid RFC822 response string

    //convert to DWORD
    for (i = 0; i < MIN_CHAR_FOR_VALID_RFC821; i++)
    {
        dwRFC821Status *= 10;
        dwRFC821Status += szExtendedStatus[i] - '0';
    }

    hr = HrGetStatusFromRFC821Status(dwRFC821Status, szStatus);

    _ASSERT(S_OK == hr); //this cannot possibly fail

    //The code *should* be valid at this point
    _ASSERT((DSN_STATUS_CH_CLASS_SUCCEEDED == szStatus[0]) ||
            (DSN_STATUS_CH_CLASS_TRANSIENT == szStatus[0]) ||
            (DSN_STATUS_CH_CLASS_FAILED == szStatus[0]));

    hr = S_OK;

  Exit:
    TraceFunctLeave();
    return hr;
}

//---[ CDefaultDSNSink::HrGetStatusFromContext ]---------------------
//
//
//  Description:
//      Determine status based on supplied context information
//  Parameters:
//      hrRecipient     HRESULT for this recipient
//      dwRecipFlags    Flags for this recipient
//      dwDSNAction     DSN Action for this recipient
//      szStatus        Buffer to return status in
//  Returns:
//      S_OK    Was able to get a valid status code
//  History:
//      7/7/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetStatusFromContext(
                                IN HRESULT hrRecipient,
                                IN DWORD   dwRecipFlags,
                                IN DWORD   dwDSNAction,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE])
{
    HRESULT hr = S_OK;
    BOOL    fValidHRESULT = FALSE;
    BOOL    fRecipContext = FALSE;
    int     iStatus = 0;
    int     i = 0;
    CHAR    chStatusClass = DSN_STATUS_CH_INVALID;
    CHAR    rgchStatusSubject[3] = {DSN_STATUS_CH_INVALID, DSN_STATUS_CH_INVALID, DSN_STATUS_CH_INVALID};
    CHAR    rgchStatusDetail[3] = {DSN_STATUS_CH_INVALID, DSN_STATUS_CH_INVALID, DSN_STATUS_CH_INVALID};

    //check to make sure that HRESULT is set according to the type of DSN happening
    if (dwDSNAction & (DSN_ACTION_FAILURE | DSN_ACTION_FAILURE_ALL))
    {
        if (FAILED(hrRecipient)) //must be a failure code
            fValidHRESULT = TRUE;

        chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
    }
    else if (dwDSNAction & DSN_ACTION_DELAYED)
    {
        if (FAILED(hrRecipient)) //must be a failure code
            fValidHRESULT = TRUE;

        chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
    }
    else if ((dwDSNAction & DSN_ACTION_RELAYED) ||
             (dwDSNAction & DSN_ACTION_DELIVERED) ||
             (dwDSNAction & DSN_ACTION_EXPANDED))
    {
        if (SUCCEEDED(hrRecipient)) //must be a success code
            fValidHRESULT = TRUE;

        chStatusClass = DSN_STATUS_CH_CLASS_SUCCEEDED;
    }
    else
    {
        _ASSERT(0 && "No DSN Action specified");
    }

    //special case HRESULTS
    if (fValidHRESULT)
    {
        switch (hrRecipient)
        {
            case CAT_E_GENERIC: // 5.1.0 - General Cat failure.
            case CAT_E_BAD_RECIPIENT: //5.1.0 - general bad address error
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '0';
                goto Exit;
            case CAT_E_ILLEGAL_ADDRESS: //5.1.3 - bad address syntax
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '3';
                goto Exit;
            case CAT_W_SOME_UNDELIVERABLE_MSGS:  //5.1.1 - recipient could not be resolved
            case (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)):
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '1';
                goto Exit;
            case CAT_E_MULTIPLE_MATCHES:  //5.1.4 - amiguous address
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '4';
                goto Exit;
           case PHATQ_E_UNKNOWN_MAILBOX_SERVER: // 5.1.6 -- no homeMDB/msExchHomeServerName
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '6';
                goto Exit;
            case CAT_E_NO_SMTP_ADDRESS:   //5.1.7 - missing address
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
                rgchStatusDetail[0] = '7';
                goto Exit;
            case AQUEUE_E_MAX_HOP_COUNT_EXCEEDED: //4.4.6
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
            case CAT_E_FORWARD_LOOP: //5.4.6
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '6';
                goto Exit;
            case PHATQ_E_BAD_LOCAL_DOMAIN: //5.4.8
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '8';
                goto Exit;
            case AQUEUE_E_LOOPBACK_DETECTED: //5.3.5
                //server is configured to loop back on itself
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_SYSTEM;
                rgchStatusDetail[0] = '5';
                goto Exit;
            case AQUEUE_E_MSG_EXPIRED: //4.4.7
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '7';
                goto Exit;
            case AQUEUE_E_HOST_NOT_RESPONDING: //4.4.1
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '1';
                goto Exit;
            case AQUEUE_E_CONNECTION_DROPPED: //4.4.2
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_NETWORK;
                rgchStatusDetail[0] = '2';
                goto Exit;
            case AQUEUE_E_TOO_MANY_RECIPIENTS: //5.5.3
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_PROTOCOL;
                rgchStatusDetail[0] = '3';
                goto Exit;
            case AQUEUE_E_LOCAL_MAIL_REFUSED: //5.2.1
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_MAILBOX;
                rgchStatusDetail[0] = '1';
                goto Exit;
            case AQUEUE_E_MESSAGE_TOO_LARGE: //5.2.3
            case AQUEUE_E_LOCAL_QUOTA_EXCEEDED: //5.2.3
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_MAILBOX;
                rgchStatusDetail[0] = '3';
                goto Exit;
            case AQUEUE_E_ACCESS_DENIED: //5.7.1
            case AQUEUE_E_SENDER_ACCESS_DENIED: //5.7.1
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_POLICY;
                rgchStatusDetail[0] = '1';
                goto Exit;
            case AQUEUE_E_NO_ROUTE: //5.4.4
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = '4';
                rgchStatusDetail[0] = '4';
                goto Exit;
            case AQUEUE_E_QADMIN_NDR:   //4.3.2
                chStatusClass = DSN_STATUS_CH_CLASS_TRANSIENT;
                rgchStatusSubject[0] = '3';
                rgchStatusDetail[0] = '2';
                goto Exit;
            case AQUEUE_E_SMTP_GENERIC_ERROR:   //5.4.0
                chStatusClass = DSN_STATUS_CH_CLASS_FAILED;
                rgchStatusSubject[0] = '4';
                rgchStatusDetail[0] = '0';
                goto Exit;
        }
    }

    if ((RP_ERROR_CONTEXT_STORE | RP_ERROR_CONTEXT_CAT | RP_ERROR_CONTEXT_MTA) &
         dwRecipFlags)
        fRecipContext = TRUE;


    //Now look at the context on recipient flags
    //$$TODO - Use HRESULT's for these case as well
    if ((RP_ERROR_CONTEXT_STORE & dwRecipFlags) ||
        (!fRecipContext && (DSN_ACTION_CONTEXT_STORE & dwDSNAction)))
    {
        rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_MAILBOX;
        rgchStatusDetail[0] = DSN_STATUS_CH_DETAIL_GENERAL;
    }
    else if ((RP_ERROR_CONTEXT_CAT & dwRecipFlags) ||
        (!fRecipContext && (DSN_ACTION_CONTEXT_CAT & dwDSNAction)))
    {
        rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_ADDRESS;
        rgchStatusDetail[0] = DSN_STATUS_CH_DETAIL_GENERAL;
    }
    else if ((RP_ERROR_CONTEXT_MTA & dwRecipFlags) ||
        (!fRecipContext && (DSN_ACTION_CONTEXT_MTA & dwDSNAction)))
    {
        rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_PROTOCOL;
        rgchStatusDetail[0] = DSN_STATUS_CH_DETAIL_GENERAL;
    }
    else
    {
        rgchStatusSubject[0] = DSN_STATUS_CH_SUBJECT_GENERAL;
        rgchStatusDetail[0] = DSN_STATUS_CH_DETAIL_GENERAL;
    }

  Exit:
    if (SUCCEEDED(hr))
    {
        //compose szStatus
        _ASSERT(DSN_STATUS_CH_INVALID != chStatusClass);
        _ASSERT(DSN_STATUS_CH_INVALID != rgchStatusSubject[0]);
        _ASSERT(DSN_STATUS_CH_INVALID != rgchStatusDetail[0]);

        szStatus[iStatus] = chStatusClass;
        iStatus++;
        szStatus[iStatus] = DSN_STATUS_CH_DELIMITER;
        iStatus++;
        for (i = 0;
            (i < 3) && (DSN_STATUS_CH_INVALID != rgchStatusSubject[i]);
            i++)
        {
            szStatus[iStatus] = rgchStatusSubject[i];
            iStatus++;
        }
        szStatus[iStatus] = DSN_STATUS_CH_DELIMITER;
        iStatus++;
        for (i = 0;
            (i < 3) && (DSN_STATUS_CH_INVALID != rgchStatusDetail[i]);
             i++)
        {
            szStatus[iStatus] = rgchStatusDetail[i];
            iStatus++;
        }
        szStatus[iStatus] = '\0';
        hr = S_OK;
    }
    return hr;
}


//---[ CDefaultDSNSink::HrGetStatusFromRFC821Status ]----------------
//
//
//  Description:
//      Attempts to generate a DSN status code from a integer version of a
//      RFC821 response
//  Parameters:
//      IN     dwRFC821Status   Integer version of RFC821Status
//      IN OUT szStatus         Buffer to write status string to
//  Returns:
//      S_OK   if valid status that could be converted to dsn status code
//      S_FALSE if status code cannot be converted
//  History:
//      7/9/98 - MikeSwa Created
//
//  Note:
//      Eventually, there may be a way to pass extended information in the
//      DWORD to this event.  We *could* also encode RFC1893  (x.xxx.xxx format)
//      in a DWORD (in dwRFC821Status) as follows:
//
//         0xF 0 000 000
//           | | \-/ \-/
//           | |  |   +----- detail portion of status code
//           | |  +--------- subject portion of status code
//           | +------------ class portion of status code
//           +-------------- mask to distinguish from RFC821 status code
//
//      For example "2.1.256" could be encoded as 0xF2001256
//
//      If we do this, we will probably need to expose public functions to
//      compress/uncompress.
//
//      Yet another possiblity would be to expose an HRESULT facility "RFC1893"
//      Use success, warning, and failed bits to denote the class, and then
//      use the error code space to encode the status codes
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetStatusFromRFC821Status(
                                IN DWORD    dwRFC821Status,
                                IN OUT CHAR szStatus[STATUS_STRING_SIZE])
{
    HRESULT hr = S_OK;
    //For now, there will be a very simple implementation just converts
    //to 2.0.0, 4.0.0, or 5.0.0, but this function is designed to be
    //the central place that converts RFC821 status codes to DSN (RFC1893)
    //status codes

    _ASSERT((!dwRFC821Status) ||
            (((200 <= dwRFC821Status) && (299 >= dwRFC821Status)) ||
             ((400 <= dwRFC821Status) && (599 >= dwRFC821Status))) &&
             "Invalid Status Code");

    //For now have simplistic mapping of RFC821 status codes
    if ((200 <= dwRFC821Status) && (299 >= dwRFC821Status)) //200 level error
    {
        strcpy(szStatus, DSN_STATUS_SUCCEEDED);
    }
    else if ((400 <= dwRFC821Status) && (499 >= dwRFC821Status)) //400 level error
    {
        strcpy(szStatus, DSN_STATUS_DELAYED);
    }
    else if ((500 <= dwRFC821Status) && (599 >= dwRFC821Status)) //500 level error
    {
        strcpy(szStatus, DSN_STATUS_SMTP_PROTOCOL_ERROR);
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

//---[ CDefaultDSNSink::HrWriteHumanReadableListOfRecips ]-----------
//
//
//  Description:
//      Writes a list of recipients to the human readable portion
//  Parameters:
//      IN  pIMailMsgRecipients     Recipients interface
//      IN  prpfctxt                Recipient filter context for this DSN
//      IN  dwDSNActionsNeeded      Type of DSN that we are generating
//      IN  pdsnbuff                DSN buffer to write DSN to
//  Returns:
//      S_OK on success
//  History:
//      12/15/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrWriteHumanReadableListOfRecips(
    IN IMailMsgRecipients *pIMailMsgRecipients,
    IN IDSNRecipientIterator *pIRecipIter,
    IN DWORD dwDSNActionsNeeded,
    IN CDSNBuffer *pdsnbuff)
{
    HRESULT  hr = S_OK;
    DWORD   iCurrentRecip = 0;
    DWORD   dwCurrentRecipFlags = 0;
    DWORD   dwCurrentDSNAction = 0;
    CHAR    szBuffer[PROP_BUFFER_SIZE];
    CHAR    szAddressType[PROP_BUFFER_SIZE];

    hr = pIRecipIter->HrReset();
    if(FAILED(hr))
        goto Exit;

    hr = pIRecipIter->HrGetNextRecipient(
        &iCurrentRecip,
        &dwCurrentDSNAction);

    while (SUCCEEDED(hr))
    {
        if(dwDSNActionsNeeded & dwCurrentDSNAction)
        {
            hr = HrGetRecipAddressAndType(
                pIMailMsgRecipients, iCurrentRecip,
                PROP_BUFFER_SIZE, szBuffer,
                sizeof(szAddressType), szAddressType);

            if (SUCCEEDED(hr))
            {
                //write address value
                hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_INDENT, sizeof(DSN_INDENT)-sizeof(CHAR));
                if (FAILED(hr))
                    goto Exit;

                hr = pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
                if (FAILED(hr))
                    goto Exit;
#ifdef NEVER
                //Print the recipient flags as well
                wsprintf(szBuffer, " (0x%08X)", dwCurrentRecipFlags);
                pdsnbuff->HrWriteBuffer((BYTE *) szBuffer, lstrlen(szBuffer));
#endif //NEVER

                hr = pdsnbuff->HrWriteBuffer((BYTE *) DSN_CRLF, sizeof(DSN_CRLF)-sizeof(CHAR));
                if (FAILED(hr))
                    goto Exit;
            }
            else
            {
                //move along... these are not the error results you are interested in.
                hr = S_OK;
            }
        }
        hr = pIRecipIter->HrGetNextRecipient(
            &iCurrentRecip,
            &dwCurrentDSNAction);
    }

  Exit:
    return hr;
}


//---[ CDefaultDSNSink::HrGetRecipAddressAndType ]-------------------
//
//
//  Description:
//      Gets the recipient address and returns a pointer to the appropriate
//      string constant for the address type.
//  Parameters:
//      IN     pIMailMsgRecipients      Ptr To recipients interface
//      IN     iRecip                   Index of the recipient of interest
//      IN     cbAddressBuffer          Size of buffer for address
//      IN OUT pbAddressBuffer          Address buffer to dump address in
//      IN     cbAddressType            Size of buffer for address type
//      IN OUT pszAddressType           Buffer for address type.
//  Returns:
//      S_OK on success
//      MAILMSG_E_PROPNOTFOUND if no address properties could be found
//  History:
//      12/16/98 - MikeSwa Created
//
//-----------------------------------------------------------------------------
HRESULT CDefaultDSNSink::HrGetRecipAddressAndType(
                                IN     IMailMsgRecipients *pIMailMsgRecipients,
                                IN     DWORD iRecip,
                                IN     DWORD cbAddressBuffer,
                                IN OUT LPSTR szAddressBuffer,
                                IN     DWORD cbAddressType,
                                IN OUT LPSTR szAddressType)
{
    TraceFunctEnterEx((LPARAM) this, "CDefaultDSNSink::HrGetRecipAddressAndType");
    HRESULT hr = S_OK;
    BOOL    fFoundAddress = FALSE;
    DWORD   i = 0;
    LPSTR   szDelimiterLocation = NULL;
    CHAR    szXDash[] = "x-";
    CHAR    chSave = '\0';

    _ASSERT(szAddressType);
    _ASSERT(cbAddressType);
    _ASSERT(cbAddressBuffer);
    _ASSERT(szAddressBuffer);
    _ASSERT(pIMailMsgRecipients);

    szAddressType[0] = '\0';
    szAddressBuffer[0] = '\0';
    for (i = 0; i < NUM_DSN_ADDRESS_PROPERTIES; i ++)
    {
        hr = pIMailMsgRecipients->GetStringA(iRecip, g_rgdwRecipPropIDs[i],
                                                cbAddressBuffer, szAddressBuffer);

        if (SUCCEEDED(hr))
        {
            fFoundAddress = TRUE;
            strncpy(szAddressType, g_rgszAddressTypes[i], cbAddressType);
            break;
        }
    }

    if (!fFoundAddress)
    {
        hr = MAILMSG_E_PROPNOTFOUND;
        ErrorTrace((LPARAM) this,
            "Unable to find recip %d address for message", iRecip);
    }
    else if (IMMPID_RP_ADDRESS_OTHER == g_rgdwRecipPropIDs[i])
    {
        //Handle special case of IMMPID_RP_ADDRESS_OTHER... we should attempt to
        //parse out address from "type:address" format of IMMPID_RP_ADDRESS_OTHER
        //property
        szDelimiterLocation = strchr(szAddressBuffer, ':');
        if (szDelimiterLocation && cbAddressType > sizeof(szXDash))
        {
            chSave = *szDelimiterLocation;
            *szDelimiterLocation = '\0';
            DebugTrace((LPARAM) this,
                "Found Address type of %s", szAddressBuffer);
            strncpy(szAddressType, szXDash, cbAddressType);
            strncat(szAddressType, szAddressBuffer,
                cbAddressType - (sizeof(szXDash)-sizeof(CHAR)));
            *szDelimiterLocation = chSave;
        }
        else
        {
            ErrorTrace((LPARAM) this,
                "Unable to find address type for address %s", szAddressBuffer);
        }
    }

    DebugTrace((LPARAM) this,
        "Found recipient address %s:%s for recip %d (propery %i:%x)",
            szAddressType, szAddressBuffer, iRecip, i, g_rgdwRecipPropIDs[i]);
    TraceFunctLeave();
    return hr;

}

//+------------------------------------------------------------
//
// Function: CPostDSNHandler::CPostDSNHandler
//
// Synopsis: Constructor.  Initialize member variables
//
// Arguments:
//  pIUnk: IUnknown to aggregate for refcounting (NOT refcounted internally)
//  pDSNGenerator: CDSNGenerator object
//  pIServerEvent: Interface for triggering events
//  dwVSID: Virtual server instance number
//  pISMTPServer: ISMTPServer interface
//  pIMsgOrig: interface to original message
//  pIAQDSNSubmission: pointer to internal interface for allocing /
//                     submitting DSNs
//  pDefaultSink: Default sink pointer
//
// Returns: Nothing
//
// History:
// jstamerj 2001/05/14 13:17:34: Created.
//
//-------------------------------------------------------------
CPostDSNHandler::CPostDSNHandler(
    IN  IUnknown *pUnk,
    IN  CDSNGenerator *pDSNGenerator,
    IN  IAQServerEvent *pIServerEvent,
    IN  DWORD dwVSID,
    IN  ISMTPServer *pISMTPServer,
    IN  IMailMsgProperties *pIMsgOrig,
    IN  IDSNSubmission *pIAQDSNSubmission,
    IN  IDSNGenerationSink *pDefaultSink)
{
    TraceFunctEnterEx((LPARAM)this, "CPostDSNHandler::CPostDSNHandler");

    m_dwSig = SIGNATURE_CPOSTDSNHANDLER;
    m_pUnk = pUnk;
    m_pIDSNProps = NULL;
    m_pDSNGenerator = pDSNGenerator;
    m_pIServerEvent = pIServerEvent;
    m_pIServerEvent->AddRef();
    m_dwVSID = dwVSID;
    m_pISMTPServer = pISMTPServer;
    m_pISMTPServer->AddRef();
    m_pIMsgOrig = pIMsgOrig;
    m_pIMsgOrig->AddRef();
    m_pIAQDSNSubmission = pIAQDSNSubmission;
    m_pIAQDSNSubmission->AddRef();
    m_pDefaultSink = pDefaultSink;
    m_pDefaultSink->AddRef();

    TraceFunctLeaveEx((LPARAM)this);
} // CPostDSNHandler::CPostDSNHandler


//+------------------------------------------------------------
//
// Function: CPostDSNHandler::~CPostDSNHandler
//
// Synopsis: Desctrutor -- cleanup
//
// Arguments: NONE
//
// Returns: NOTHING
//
// History:
// jstamerj 2001/05/14 13:21:28: Created.
//
//-------------------------------------------------------------
CPostDSNHandler::~CPostDSNHandler()
{
    TraceFunctEnterEx((LPARAM)this, "CPostDSNHandler::~CPostDSNHandler");

    _ASSERT(m_dwSig == SIGNATURE_CPOSTDSNHANDLER);
    if(m_pIServerEvent)
        m_pIServerEvent->Release();
    if(m_pISMTPServer)
        m_pISMTPServer->Release();
    if(m_pIMsgOrig)
        m_pIMsgOrig->Release();
    if(m_pIDSNProps)
        m_pIDSNProps->Release();
    if(m_pIAQDSNSubmission)
        m_pIAQDSNSubmission->Release();
    if(m_pDefaultSink)
        m_pDefaultSink->Release();
    m_dwSig = SIGNATURE_CPOSTDSNHANDLER_INVALID;

    TraceFunctLeaveEx((LPARAM)this);
} // CPostDSNHandler::~CPostDSNHandler



//+------------------------------------------------------------
//
// Function: CPostDSNHandler::QueryInterface
//
// Synopsis: Return an interface to this object
//
// Arguments:
//  riid: interface IID requested
//  ppvObj: out param for interface
//
// Returns:
//  S_OK: Success
//  E_NOINTERFACE: not supported
//
// History:
// jstamerj 2000/12/08 21:26:14: Created.
//
//-------------------------------------------------------------
HRESULT CPostDSNHandler::QueryInterface(
    IN  REFIID riid,
    OUT LPVOID *ppvObj)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CPostDSNHandler::QueryInterface");

    *ppvObj = NULL;

    if(riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown *)this;
    }
    else if(riid == IID_IDSNSubmission)
    {
        *ppvObj = (IDSNSubmission *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    if(SUCCEEDED(hr))
        AddRef();

    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CPostDSNHandler::QueryInterface


//+------------------------------------------------------------
//
// Function: CPostDSNHandler::HrAllocBoundMessage
//
// Synopsis:
//  Allocates a bound message.
//
// Arguments:
//  ppMsg: Out param for Allocated mailmsg
//  phContent: Out param for content handle.  Handle is managed by mailmsg
//
// Returns:
//  S_OK: Success
//  error from SMTP
//
// History:
// jstamerj 2001/05/11 14:19:09: Created.
//
//-------------------------------------------------------------
HRESULT CPostDSNHandler::HrAllocBoundMessage(
    OUT IMailMsgProperties **ppMsg,
    OUT PFIO_CONTEXT *phContent)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CPostDSNHandler::HrAllocBoundMessage");

    if(m_pIAQDSNSubmission == NULL)
    {
        ErrorTrace((LPARAM)this, "PostDSNHandler called outside of event!");
        hr = E_POINTER;
        goto CLEANUP;
    }

    hr = m_pIAQDSNSubmission->HrAllocBoundMessage(
        ppMsg,
        phContent);
    if(FAILED(hr))
        goto CLEANUP;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CPostDSNHandler::HrAllocBoundMessage


//+------------------------------------------------------------
//
// Function: CPostDSNHandler::HrSubmitDSN
//
// Synopsis: Accept a sink generated DSN
//
// Arguments:
//  dwDSNAction: Type of DSN
//  cRecipsDSNd: # of recipients DSNd
//  pDSNMsg: The DSN mailmsg
//
// Returns:
//  S_OK: Success
//
// History:
// jstamerj 2000/12/08 21:27:56: Created.
//
//-------------------------------------------------------------
HRESULT CPostDSNHandler::HrSubmitDSN(
    IN  DWORD dwDSNAction,
    IN  DWORD cRecipsDSNd,
    IN  IMailMsgProperties *pDSNMsg)
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)this, "CPostDSNHandler::HrSubmitDSN");

    if(pDSNMsg == NULL)
    {
        hr = E_POINTER;
        goto CLEANUP;
    }

    if(m_pIAQDSNSubmission == NULL)
    {
        ErrorTrace((LPARAM)this, "PostDSNHandler called outside of event!");
        hr = E_POINTER;
        goto CLEANUP;
    }
    //
    // Trigger event
    //
    _ASSERT(m_pDSNGenerator);
    hr = m_pDSNGenerator->HrTriggerPostGenerateDSN(
        m_pIServerEvent,
        m_dwVSID,
        m_pISMTPServer,
        m_pIMsgOrig,
        dwDSNAction,
        cRecipsDSNd,
        pDSNMsg,
        m_pIDSNProps);
    if(FAILED(hr))
        goto CLEANUP;

    _ASSERT(m_pIAQDSNSubmission);
    hr = m_pIAQDSNSubmission->HrSubmitDSN(
        dwDSNAction,
        cRecipsDSNd,
        pDSNMsg);
    if(FAILED(hr))
        goto CLEANUP;

 CLEANUP:
    DebugTrace((LPARAM)this, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)this);
    return hr;
} // CPostDSNHandler::HrSubmitDSN


//+------------------------------------------------------------
//
// Function: CDSNGenerator::HrStaticInit
//
// Synopsis: Initialize static member data
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 2001/05/11 10:59:26: Created.
//
//-------------------------------------------------------------
HRESULT CDSNGenerator::HrStaticInit()
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)0, "CDSNGenerator::HrStaticInit");

    hr = CDSNPool::HrStaticInit();
    if(FAILED(hr))
        goto CLEANUP;

 CLEANUP:
    DebugTrace((LPARAM)0, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)0);
    return hr;
} // CDSNGenerator::HrStaticInit


//+------------------------------------------------------------
//
// Function: CDSNGenerator::StaticDeinit
//
// Synopsis: Deinitialize static data
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 2001/05/11 11:00:31: Created.
//
//-------------------------------------------------------------
VOID CDSNGenerator::StaticDeinit()
{
    TraceFunctEnterEx((LPARAM)0, "CDSNGenerator::HrStaticDeinit");

    CDSNPool::StaticDeinit();

    TraceFunctLeaveEx((LPARAM)0);
} // CDSNGenerator::HrStaticDeinit


//+------------------------------------------------------------
//
// Function: CDSNPool::HrStaticInit
//
// Synopsis: Initialize static member data
//
// Arguments: None
//
// Returns:
//  S_OK: Success
//  E_OUTOFMEMORY
//
// History:
// jstamerj 2001/05/11 11:02:18: Created.
//
//-------------------------------------------------------------
HRESULT CDSNPool::HrStaticInit()
{
    HRESULT hr = S_OK;
    TraceFunctEnterEx((LPARAM)0, "CDSNPool::HrStaticInit");
    //
    // There can't be more than one DSNGeneration per thread, so 1000
    // objects should be more than enough
    //
    if(!sm_Pool.ReserveMemory(1000, sizeof(CDSNPool)))
    {
       hr = E_OUTOFMEMORY;
       goto CLEANUP;
    }

 CLEANUP:
    DebugTrace((LPARAM)0, "returning %08lx", hr);
    TraceFunctLeaveEx((LPARAM)0);
    return hr;
} // CDSNPool::HrStaticInit


//+------------------------------------------------------------
//
// Function: CDSNPool::StaticDeinit
//
// Synopsis: Deinitialize static member data
//
// Arguments: None
//
// Returns: Nothing
//
// History:
// jstamerj 2001/05/11 11:37:51: Created.
//
//-------------------------------------------------------------
VOID CDSNPool::StaticDeinit()
{
    TraceFunctEnterEx((LPARAM)0, "CDSNPool::StaticDeinit");

    sm_Pool.ReleaseMemory();

    TraceFunctLeaveEx((LPARAM)0);
} // CDSNPool::StaticDeinit
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\precomp.cpp ===
//---------------------------------------------------------------------------
//
//
//  File: precomp.cpp
//
//  Description:  Precompiled CPP for phatq\dsnsink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created
//
//  Copyright (C) 1999 Microsoft Corporation
//
//---------------------------------------------------------------------------
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\precomp.h ===
//-----------------------------------------------------------------------------
//
//
//  File: precomp.h
//
//  Description:  Precompiled header for phatq\dsnsink
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      6/15/99 - MikeSwa Created
//      7/15/99 - MikeSwa Moved to transmt
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQ_PRECOMP_H__
#define __AQ_PRECOMP_H__

//Local includes
#ifdef PLATINUM
#include <ptntintf.h>
#include <ptntdefs.h>
#define AQ_MODULE_NAME "phatq"
#else //not PLATINUM
#define AQ_MODULE_NAME "aqueue"
#endif //PLATINUM

//Includes from external directories
#include <smtpevent.h>
#include <aqueue.h>
#include <transmem.h>
#include <dbgtrace.h>
#include <mailmsg.h>
#include <mailmsgprops.h>
#include <aqerr.h>
#include <phatqmsg.h>
#include <caterr.h>
#include <time.h>
#include <stdio.h>
#include <aqevents.h>
#include <aqintrnl.h>
#include <tran_evntlog.h>
#include "dsnsink.h"
#include "dsnbuff.h"
#include "dsntext.h"
#include "dsnlang.h"
#include "dsn_utf7.h"
#include "cpropbag.h"
#include "dsninternal.h"

//Wrappers for transmem macros
#include <aqmem.h>

#endif //__AQ_PRECOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsn_utf7.cpp ===
//-----------------------------------------------------------------------------
//
//
//  File: dsn_utf7.cpp
//
//  Description:
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/20/98 - MikeSwa Created 
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#include "precomp.h"

//---[ CUTF7ConversionContext::chNeedsEncoding ]--------------------------------
//
//
//  Description: 
//      Determines if a character needs to be encoded... returns it's ASCII 
//      equivalent if not.
//  Parameters:
//      wch     Wide character to check
//  Returns:
//      0, if the character needs encoding
//      The ASCII equivalent if not.
//  History:
//      10/23/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CHAR CUTF7ConversionContext::chNeedsEncoding(WCHAR wch)
{
    CHAR    ch = 0;
    //First look for characters that are a straight ASCII conversion for all 
    //cases.  This is Set D and Set O in the RFC1642
    if (((L'a' <= wch) && (L'z' >= wch)) ||
        ((L'A' <= wch) && (L'Z' >= wch)) ||
        ((L'0' <= wch) && (L'9' >= wch)) ||
        ((L'!'<= wch) && (L'*' >= wch)) ||
        ((L',' <= wch) && (L'/' >= wch)) ||
        ((L';' <= wch) && (L'@' >= wch)) ||
        ((L']' <= wch) && (L'`' >= wch)) ||
        ((L'{' <= wch) && (L'}' >= wch)) ||
        (L' ' == wch) || (L'\t' == wch) ||
        (L'[' == wch))
    {
        ch = (CHAR) wch & 0x00FF;
    }
    //Check things are not converted for content, but are for headers
    else if (!(UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState))
    {
        //Handle whitespace
        if ((L'\r' == wch) || (L'\n' == wch))
            ch = (CHAR) wch & 0x00FF;
    }

    //NOTE - We not not want to handle UNICODE <LINE SEPARATOR> (0x2028)
    //and <PARAGRAPH SEPARATOR> (0x2029)... which should ideally be 
    //converted to CRLF. We will consider this a mal-formed resource.  ASSERT
    //in Debug and encode as UNICODE on retail.
    _ASSERT((0x2028 != wch) && "Malformed Resource String");
    _ASSERT((0x2029 != wch) && "Malformed Resource String");


    return ch;
}


//---[ UTF7ConversionContext::CUTF7ConversionContext ]-------------------------
//
//
//  Description: 
//      Constuctor for UTF7ConversionContext object
//  Parameters:
//      IN  fIsRFC1522Subject   TRUE if we need to worry about converting
//                              to an RFC1522 Subject (defaults to FALSE)
//  Returns:
//      -
//  History:
//      10/20/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
CUTF7ConversionContext::CUTF7ConversionContext(BOOL fIsRFC1522Subject)
{
    m_dwSignature = UTF7_CONTEXT_SIG;
    m_dwCurrentState = UTF7_INITIAL_STATE;
    if (fIsRFC1522Subject)
        m_dwCurrentState |= UTF7_ENCODING_RFC1522_SUBJECT;

    m_cBytesSinceCRLF = 0;
}

//---[ <function> ]------------------------------------------------------------
//
//
//  Description: 
//      Writes a single character to the output buffer... used by 
//      fConvertBuffer.  Also updates relevant member vars/
//  Parameters:
//      IN      ch          Character to write
//      IN OUT  ppbBuffer   Buffer to write it to
//      IN OUT  pcbWritten  Running total of bytes written
//  Returns:
//      -
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline void CUTF7ConversionContext::WriteChar(IN CHAR ch, 
                                              IN OUT BYTE ** ppbBuffer, 
                                              IN OUT DWORD *pcbWritten)
{
    _ASSERT(ppbBuffer);
    _ASSERT(*ppbBuffer);
    _ASSERT(pcbWritten);

    **ppbBuffer = (BYTE) ch;
    (*ppbBuffer)++;
    (*pcbWritten)++;
    m_cBytesSinceCRLF++;

    if (UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState)
        _ASSERT(UTF7_RFC1522_MAX_LENGTH >= m_cBytesSinceCRLF);

}

//---[ CUTF7ConversionContext::fWriteString ]----------------------------------
//
//
//  Description: 
//      Used by fConvertBuffer to write a string to the outputt buffer.  
//      Updates m_cBytesSinceCRLF in the process.
//  Parameters:
//      IN      szString    String to write
//      IN      cbString    Size of string
//      IN      cbBuffer    Total size of output buffer
//      IN OUT  ppbBuffer   Buffer to write it to
//      IN OUT  pcbWritten  Running total of bytes written
//  Returns:    
//      
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
inline BOOL CUTF7ConversionContext::fWriteString(IN LPSTR szString, IN DWORD cbString,
                                          IN DWORD cbBuffer, 
                                          IN OUT BYTE ** ppbBuffer, 
                                          IN OUT DWORD *pcbWritten)
{
    _ASSERT(szString);
    _ASSERT(ppbBuffer);
    _ASSERT(*ppbBuffer);
    _ASSERT(pcbWritten);

    if (cbString > (cbBuffer - *pcbWritten))
        return FALSE;  //There is not enough room to write our buffer

    memcpy(*ppbBuffer, szString, cbString);
    (*ppbBuffer) += cbString;
    (*pcbWritten) += cbString;
    m_cBytesSinceCRLF += cbString;

    if (UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState)
        _ASSERT(UTF7_RFC1522_MAX_LENGTH >= m_cBytesSinceCRLF);

    return TRUE;
}

//---[ CUTF7ConversionContext::fSubjectNeedsEncodin ]--------------------------
//
//
//  Description: 
//      Determines if a subject needs to be UTF7 encoded... or can be 
//      transmitted as is.
//  Parameters:
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//  Returns:
//      TRUE if we need to encode the buffer
//      FALSE if we do not
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CUTF7ConversionContext::fSubjectNeedsEncoding(IN BYTE *pbBuffer, 
                                                   IN DWORD cbBuffer)
{
    LPWSTR wszBuffer = (LPWSTR) pbBuffer;
    LPWSTR wszBufferEnd = (LPWSTR) (pbBuffer + cbBuffer);
    WCHAR  wch = L'\0';

    while (wszBuffer < wszBufferEnd)
    {
        wch = *wszBuffer;
        if ((127 < wch) || (L'\r' == wch) || (L'\n' == wch))
        {
            //Encountered a non-valid char... must encode
            return TRUE;
        }
        wszBuffer++;
    }
    return FALSE;
}

//---[ UTF7ConversionContext::fConvertBufferTo7BitASCII ]----------------------
//
//
//  Description: 
//      Converts a buffer that is UNICODE contianing only 7bit ASCII characters
//      to an ASCII buffer.
//  Parameters:
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//      IN  pbOutputBuffer      Buffer to write data to
//      IN  cbOutputBuffer      Size of buffer to write data to
//      OUT pcbWritten          # of bytes written to output bufferbuffer
//      OUT pcbRead             # of bytes read from Input buffer
//  Returns:
//      TRUE if entire input buffer was processed
//      FALSE if buffer needs to be processe some more
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CUTF7ConversionContext::fConvertBufferTo7BitASCII(          
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead)
{
    LPWSTR wszBuffer = (LPWSTR) pbInputBuffer;
    LPWSTR wszBufferEnd = (LPWSTR) (pbInputBuffer + cbInputBuffer);
    WCHAR  wch = L'\0';
    BYTE  *pbCurrentOut = pbOutputBuffer;

    _ASSERT(pbCurrentOut);
    while ((*pcbWritten < cbOutputBuffer) && (wszBuffer < wszBufferEnd))
    {
        _ASSERT(!(0xFF80 & *wszBuffer)); //must be only 7-bit
        WriteChar((CHAR) *wszBuffer, &pbCurrentOut, pcbWritten);
        wszBuffer++;
        *pcbRead += sizeof(WCHAR);
    }

    return (wszBuffer == wszBufferEnd);
}

//---[ CUTF7ConversionContext::fUTF7EncodeBuffer ]------------------------------
//
//
//  Description: 
//      Converts buffer to UTF7 Encoding
//
//      This function implements the main state machine for UTF7 encoding.  It 
//      handles encoding of both RFC1522 subject encoding as well as regular
//      UTF7 content-encoding.
//  Parameters:
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//      IN  pbOutputBuffer      Buffer to write data to
//      IN  cbOutputBuffer      Size of buffer to write data to
//      OUT pcbWritten          # of bytes written to output bufferbuffer
//      OUT pcbRead             # of bytes read from Input buffer
//  Returns:
//      TRUE if entire input buffer was processed
//      FALSE if buffer needs to be processe some more
//  History:
//      10/26/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CUTF7ConversionContext::fUTF7EncodeBuffer(          
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead)
{
    LPWSTR wszBuffer = (LPWSTR) pbInputBuffer;
    WCHAR  wch = L'\0';
    CHAR   ch = '\0';
    BYTE  *pbCurrentOut = pbOutputBuffer;
    BOOL   fDone = FALSE;

    //Use loop to make sure we never exceed our buffers
    while (*pcbWritten < cbOutputBuffer)
    {
        //See if we need to handle any state that does not require reading
        //from the input buffer.
        if (UTF7_FLUSH_BUFFERS & m_dwCurrentState)
        {
            //We have converted characters buffered up... we need to write them
            //to the output buffer
            if (!m_Base64Stream.fNextValidChar(&ch))
            {
                //Nothing left to write
                m_dwCurrentState ^= UTF7_FLUSH_BUFFERS;
                continue;
            }
            WriteChar(ch, &pbCurrentOut, pcbWritten);
        }
        else if (UTF7_RFC1522_CHARSET_PENDING & m_dwCurrentState)
        {
            //We need to start with the =?charset?Q?+ stuff
            if (!fWriteString(UTF7_RFC1522_ENCODE_START, 
                              sizeof(UTF7_RFC1522_ENCODE_START)-sizeof(CHAR),
                              cbOutputBuffer, &pbCurrentOut, pcbWritten))
            {
                return FALSE;
            }
                    
            m_dwCurrentState ^= UTF7_RFC1522_CHARSET_PENDING;
            m_dwCurrentState |= (UTF7_ENCODING_WORD | UTF7_RFC1522_CURRENTLY_ENCODING);
        }
        else if (UTF7_WORD_CLOSING_PENDING & m_dwCurrentState)
        {
            //Need to write closing '-'
            m_dwCurrentState ^= UTF7_WORD_CLOSING_PENDING;
            WriteChar(UTF7_STOP_STREAM_CHAR, &pbCurrentOut, pcbWritten);
        }
        else if (UTF7_RFC1522_CLOSING_PENDING & m_dwCurrentState)
        {
            if (!fWriteString(UTF7_RFC1522_ENCODE_STOP, 
                              sizeof(UTF7_RFC1522_ENCODE_STOP)-sizeof(CHAR),
                              cbOutputBuffer, &pbCurrentOut, pcbWritten))
            {
                return FALSE;
            }
            m_dwCurrentState ^= (UTF7_RFC1522_CLOSING_PENDING | UTF7_FOLD_HEADER_PENDING);
        }
        else if (UTF7_FOLD_HEADER_PENDING & m_dwCurrentState)
        {
            if (*pcbRead >= cbInputBuffer) //there is no more text to read.. we don't need to wrap
            {
                fDone = TRUE;
                m_dwCurrentState ^= UTF7_FOLD_HEADER_PENDING;
                break;
            }
            m_cBytesSinceCRLF = 0;  //We're writing a CRLF now
            if (!fWriteString(UTF7_RFC1522_PHRASE_SEPARATOR, 
                              sizeof(UTF7_RFC1522_PHRASE_SEPARATOR)-sizeof(CHAR),
                              cbOutputBuffer, &pbCurrentOut, pcbWritten))
            {
                return FALSE;
            }
            
            m_cBytesSinceCRLF = sizeof(CHAR);//set count to leading tab
            m_dwCurrentState ^= UTF7_FOLD_HEADER_PENDING;
        }
        else if (*pcbRead >= cbInputBuffer)
        {
            //We have read our entire input buffer... now we need to handle 
            //any sort of cleanup.
            if (m_Base64Stream.fTerminateStream(TRUE))
            {
                _ASSERT(UTF7_ENCODING_WORD & m_dwCurrentState);
                m_dwCurrentState |= UTF7_FLUSH_BUFFERS;
            }
            else if (UTF7_ENCODING_WORD & m_dwCurrentState)
            {
                //We have already written everything to output.. but we 
                //still need to write the close of the stream
                _ASSERT(!(UTF7_WORD_CLOSING_PENDING & m_dwCurrentState));
                m_dwCurrentState ^= (UTF7_ENCODING_WORD | UTF7_WORD_CLOSING_PENDING);
            }
            else if (UTF7_RFC1522_CURRENTLY_ENCODING & m_dwCurrentState)
            {
                //Need to write closing ?=
                m_dwCurrentState |= UTF7_RFC1522_CLOSING_PENDING;
            }
            else
            {
                fDone = TRUE;
                break; //We're done
            }
        }
        else //need to process more of the input buffer
        {
            wch = *wszBuffer;
            ch = chNeedsEncoding(wch);
            //Are we at the end of a RFC1522 phrase? (ch will be 0)
            if ((UTF7_RFC1522_CURRENTLY_ENCODING & m_dwCurrentState) &&
                !ch && iswspace(wch))
            {
                //reset state 
                if (UTF7_ENCODING_WORD & m_dwCurrentState)
                    m_dwCurrentState |= UTF7_WORD_CLOSING_PENDING;  //need to write -

                m_dwCurrentState |= UTF7_RFC1522_CLOSING_PENDING;
                m_dwCurrentState &= ~(UTF7_ENCODING_WORD |
                                      UTF7_RFC1522_CURRENTLY_ENCODING);
                
                //eat up any extra whitespace
                do
                {
                     wszBuffer++;
                     *pcbRead += sizeof(WCHAR);
                     if (*pcbRead >= cbInputBuffer)
                        break;
                    wch = *wszBuffer;
                } while (iswspace(wch));
            }
            else if (UTF7_ENCODING_WORD & m_dwCurrentState)
            {
                if (ch) //we need to stop encoding
                {
                    m_Base64Stream.fTerminateStream(TRUE);
                   _ASSERT(!(UTF7_WORD_CLOSING_PENDING & m_dwCurrentState));
                    m_dwCurrentState ^= (UTF7_ENCODING_WORD | UTF7_WORD_CLOSING_PENDING | UTF7_FLUSH_BUFFERS);
                }
                else if (!m_Base64Stream.fProcessWideChar(wch))
                {
                    //flush our buffers and then continue on as we were
                    m_dwCurrentState |= UTF7_FLUSH_BUFFERS;
                }
                else
                {
                    //The write worked... 
                    wszBuffer++;
                    *pcbRead += sizeof(WCHAR);
                }
            }
            else if (!ch)
            {
                //we need to start encoding
                if ((UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState) &&
                    !(UTF7_RFC1522_CURRENTLY_ENCODING & m_dwCurrentState))
                {
                    //We need to start with the =?charset?Q?+ stuff
                    m_dwCurrentState |= UTF7_RFC1522_CHARSET_PENDING;
                }
                else
                {
                    //We are either not encoding RFC1522... or are already
                    //in the middle of a RFC1522 encoded phrase.. in this case
                    //we only need to write the '+'
                    WriteChar(UTF7_START_STREAM_CHAR, &pbCurrentOut, pcbWritten);
                    m_dwCurrentState |= UTF7_ENCODING_WORD;
                }
            }
            else
            {
                //
                // NOTE: It is not clear why we do not close out the UTF7 word
                // i.e. why we do not go into the UTF7 word closing pending state
                // like we do when we encounter an iswspace char. This means that
                // when a string is <jpn-char><0x0020><jpn-char> we will encode it
                // as =?charset?Q?+stuff, while if it is <jpn-char><0x3000><jpn-char>
                // where 0x3000 == Japanese whitespace, we will encode as:
                // =?charset?Q?+stuff<CRLF>=?charset?Q?+stuff. 
                //
                // If this is "fixed" in the future (i.e. we start closing out UTF7
                // encodings when we encounter 0x0020) be aware that we rely on the
                // current (non-closing) functionality for HrWriteModifiedUnicodeString.
                //

                //we are not encoding... and character can be written normally
                WriteChar(ch, &pbCurrentOut, pcbWritten);
                wszBuffer++;
                *pcbRead += sizeof(WCHAR);

                //if it was a space... and we are doing headers... lets fold
                //the header
                if ((UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState)
                    && isspace((UCHAR)ch))
                {
                    //eat up any extra whitespace
                    while (iswspace(*wszBuffer))
                    {
                         wszBuffer++;
                         *pcbRead += sizeof(WCHAR);
                         if (*pcbRead >= cbInputBuffer)
                            break;
                    }
                    m_dwCurrentState |= UTF7_FOLD_HEADER_PENDING;
                }
            }
        }
    }

    return fDone;
}

//---[ CUTF7ConversionContext::fConvertBuffer ]--------------------------------
//
//
//  Description: 
//      Converts UNICODE string to UTF7
//  Parameters:
//      IN  fASCII              TRUE if buffer is ASCII
//      IN  pbInputBuffer       Pointer to UNICODE string buffer
//      IN  cbInputBuffer       Size (in bytes) of string buffer
//      IN  pbOutputBuffer      Buffer to write data to
//      IN  cbOutputBuffer      Size of buffer to write data to
//      OUT pcbWritten          # of bytes written to output bufferbuffer
//      OUT pcbRead             # of bytes read from Input buffer
//  Returns:
//      TRUE if entire input buffer was processed
//      FALSE if buffer needs to be processe some more
//  History:
//      10/21/98 - MikeSwa Created 
//
//-----------------------------------------------------------------------------
BOOL CUTF7ConversionContext::fConvertBuffer(
          IN BOOL   fASCII,
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead)
{
    _ASSERT(pcbWritten);
    _ASSERT(pcbRead);
    _ASSERT(pbInputBuffer);
    _ASSERT(pbOutputBuffer);
    
    //Let the default implementation handle straight ASCII
    if (fASCII)
    {
        return CDefaultResourceConversionContext::fConvertBuffer(fASCII,
                pbInputBuffer, cbInputBuffer, pbOutputBuffer, cbOutputBuffer,
                pcbWritten, pcbRead);
    }

    //Now we know it is UNICODE... cbInputBuffer should be a multiple of sizeof(WCHAR)
    _ASSERT(0 == (cbInputBuffer % sizeof(WCHAR)));

    //If we are encoding the subject, and we haven't classified it yet,
    //we need to check to see if it needs encoding
    if (UTF7_ENCODING_RFC1522_SUBJECT & m_dwCurrentState &&
        !((UTF7_SOME_INVALID_RFC822_CHARS | UFT7_ALL_VALID_RFC822_CHARS) &
          m_dwCurrentState))
    {
        if (fSubjectNeedsEncoding(pbInputBuffer, cbInputBuffer))
            m_dwCurrentState |= UTF7_SOME_INVALID_RFC822_CHARS;
        else
            m_dwCurrentState |= UFT7_ALL_VALID_RFC822_CHARS;
    }

    *pcbWritten = 0;
    *pcbRead = 0;

    if (UFT7_ALL_VALID_RFC822_CHARS & m_dwCurrentState)
    {
        return fConvertBufferTo7BitASCII(pbInputBuffer, cbInputBuffer, pbOutputBuffer,
                                        cbOutputBuffer, pcbWritten, pcbRead);
    }
    else //we must convert
    {
        return fUTF7EncodeBuffer(pbInputBuffer, cbInputBuffer, pbOutputBuffer,
                                        cbOutputBuffer, pcbWritten, pcbRead);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\makefile.inc ===
$(O)\mailmsg.h $(O)\mailmsg_i.c : $(STAXINC)\export\mailmsg.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsg_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsg_i.c \
    -header $@ \
    -tlb $(O)\mailmsg.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\mailmsgi.h $(O)\mailmsgi_i.c : $(STAXINC)\export\mailmsgi.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char signed \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\mailmsgi_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\mailmsgi_i.c \
    -header $@ \
    -tlb $(O)\mailmsgi.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqintrnl.h $(O)\aqintrnl_i.c : $(STAXAQUEUE)\inc\aqintrnl.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqintrnl_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqintrnl_i.c \
    -header $@ \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqueue.h $(O)\aqueue_i.c : $(STAXINC)\export\aqueue.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\aqueue_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\aqueue_i.c \
    -header $@ \
    -tlb $(O)\aqueue.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\smtpevent.h $(O)\smtpevent_i.c : $(STAXINC)\export\smtpevent.idl
    $(MIDL) \
    $(PACKING) \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $(PASS0_SOURCEDIR)\smtpevent_p.c \
    -dlldata $(PASS0_SOURCEDIR)\dlldata.c \
    -iid $(MIDL_UUIDDIR)\smtpevent_i.c \
    -header $@ \
    -tlb $(O)\smtpevent.tlb \
    -cpp_cmd $(TARGET_CPP) \
    $(C_DEFINES) \
    $(MIDL_FLAGS) \
    $(MIDL_OPTIMIZATION) \
    $**

$(O)\aqerr.h $(O)\aqerr.rc $(O)\msg00001.bin: $(STAXINC)\export\aqerr.mc
    copy /a $(STAXINC)\export\aqerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\aqerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\aqerr.rc
    del  $(O)\tmp.rc

$(O)\caterr.h $(O)\caterr.rc $(O)\msg00001.bin: $(STAXINC)\export\caterr.mc
    copy /a $(STAXINC)\export\caterr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\caterr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\caterr.rc
    del  $(O)\tmp.rc

$(O)\imsgerr.h $(O)\imsgerr.rc $(O)\msg00001.bin: $(STAXINC)\export\imsgerr.mc
    copy /a $(STAXINC)\export\imsgerr.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\imsgerr.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\imsgerr.rc
    del  $(O)\tmp.rc

$(O)\phatqmsg.h $(O)\phatqmsg.rc $(O)\msg00001.bin: $(STAXINC)\export\phatqmsg.mc
    copy /a $(STAXINC)\export\phatqmsg.mc $(O)\tmp.mc
    mc -v -r $(O) -h $(O) $(O)\tmp.mc
    copy $(O)\tmp.h $(O)\phatqmsg.h
    del $(O)\tmp.h
    copy $(O)\tmp.rc $(O)\phatqmsg.rc
    del  $(O)\tmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\dsnsink\dsn_utf7.h ===
//-----------------------------------------------------------------------------
//
//
//  File: dsn_utf7
//
//  Description:  Implementations of UTF-7 based unicode character encoding
//      methods for DSN generation.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      10/20/98 - MikeSwa Created
//
//  Copyright (C) 1998 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __DSN_UTF7_H__
#define __DSN_UTF7_H__

#include <windows.h>
#include <dbgtrace.h>
#include "b64octet.h"
#include "dsnconv.h"

#define UTF7_CHARSET "unicode-1-1-utf-7"

#define UTF7_CONTEXT_SIG '7FTU'

#define UTF7_START_STREAM_CHAR  '+'
#define UTF7_STOP_STREAM_CHAR   '-'
#define UTF7_RFC1522_ENCODE_START "=?" UTF7_CHARSET "?Q?+"
#define UTF7_RFC1522_ENCODE_STOP  "?="
#define UTF7_RFC1522_PHRASE_SEPARATOR  " \r\n\t"
#define UTF7_RFC1522_MAX_LENGTH 76


class CUTF7ConversionContext : public CDefaultResourceConversionContext
{
  protected:
    DWORD   m_dwSignature;
    DWORD   m_cBytesSinceCRLF;
    DWORD   m_dwCurrentState;
    CHAR    chNeedsEncoding(WCHAR wch);
    CBase64OctetStream m_Base64Stream;

    //State Description enum flags
    enum
    {
        UTF7_INITIAL_STATE              = 0x00000000, //Initial state
        UTF7_ENCODING_RFC1522_SUBJECT   = 0x80000000, //encoding RFC1522 subject
        UTF7_ENCODING_WORD              = 0x00000001, //In process of encoding a word
        UTF7_WORD_CLOSING_PENDING       = 0x00000002, //Needs a '-'
        UTF7_RFC1522_CHARSET_PENDING    = 0x00000004, //=?charset?Q?+ pending
        UTF7_RFC1522_CLOSING_PENDING    = 0x00000008, //needs '=?'
        UTF7_RFC1522_CURRENTLY_ENCODING = 0x00000010, //Currently encoding RFC1522 phrase
        UTF7_FOLD_HEADER_PENDING        = 0x00000020, //Need to fold head before encoding
                                                      //more
        UTF7_FLUSH_BUFFERS              = 0x00000040, //Need to flush conversion buffers

        //Used to determine if subject needs to be encoded
        UTF7_SOME_INVALID_RFC822_CHARS  = 0x40000000, //Contains some invalid RFC822 chars
        UFT7_ALL_VALID_RFC822_CHARS     = 0x20000000, //All characters are valid RFC822 chars
    };

    void WriteChar(IN CHAR ch, IN OUT BYTE ** ppbBuffer, IN OUT DWORD *pcbWritten);
    BOOL fWriteString(IN LPSTR szString, IN DWORD cbString, IN DWORD cbBuffer,
                      IN OUT BYTE ** ppbBuffer, IN OUT DWORD *pcbWritten);
    BOOL fSubjectNeedsEncoding(IN BYTE *pbBuffer, IN DWORD cbBuffer);

    BOOL fUTF7EncodeBuffer(
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead);

    BOOL fConvertBufferTo7BitASCII(
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead);

  public:
    CUTF7ConversionContext(BOOL fIsRFC1522Subject = FALSE);
    BOOL fConvertBuffer(
          IN BOOL   fASCII,
          IN PBYTE  pbInputBuffer,
          IN DWORD  cbInputBuffer,
          IN PBYTE  pbOutputBuffer,
          IN DWORD  cbOutputBuffer,
          OUT DWORD *pcbWritten,
          OUT DWORD *pcbRead);
};

#endif //__DSN_UTF7_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\aqmem.h ===
//-----------------------------------------------------------------------------
//
//
//  File: aqmem.h
//
//  Description:  Header file with memory macros required to build AQUEUE
//      in the platinum build environment.
//
//  Author: Mike Swafford (MikeSwa)
//
//  History:
//      7/15/99 - MikeSwa Created 
//
//  Copyright (C) 1999 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef __AQMEM_H__
#define __AQMEM_H__

//Wrappers for transmem macros
#ifndef PvMalloc
#define PvMalloc(x) TrMalloc(x)
#endif  //PvMalloc

#ifndef PvRealloc
#define PvRealloc(x) TrRealloc(x)
#endif  //PvRealloc

#ifndef FreePv
#define FreePv(x) TrFree(x)
#endif  //FreePv

#endif //__AQMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\aqincs.h ===
//-----------------------------------------------------------------------------
//
//
//    File: aqincs.h
//
//    Description:  The base header file for transport advanced queueing.
//
//    Author: mikeswa
//
//    Copyright (C) 1997 Microsoft Corporation
//
//-----------------------------------------------------------------------------

#ifndef _AQINCS_H_
#define _AQINCS_H_

//General and windows headers

//Define WINSOCKAPI, so atq,h will compile
#define _WINSOCKAPI_

#include <atq.h>
#include <ole2.h>
#include <mapicode.h>
#include <stdio.h>
#include <string.h>

// Transport specific headers - every component should use these
#include "transmem.h"
#include "baseobj.h"
#include <dbgtrace.h>
#include <rwnew.h>
#include <mailmsg.h>

//can be used to mark signatures as deleted
//will shift the signature over 1 character and prepend a '!'
#define MARK_SIG_AS_DELETED(x) {x <<= 8; x |= 0x00000021;}

#ifndef MAXDWORD
#define MAXDWORD    0xffffffff
#endif //MAXDWORD

//my own special Assert
//place holder for MCIS _ASSERT, until I bring code over
#ifdef DEBUG
#undef  Assert
#define Assert(x)   _ASSERT(x)
#else 
#undef Assert
#define Assert(x)
#endif //DEBUG

#ifdef DEBUG
#define DEBUG_DO_IT(x) x
#else
#define DEBUG_DO_IT(x) 
#endif  //DEBUG

_declspec(selectany) HINSTANCE g_hAQInstance = NULL;

#endif //_AQINCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\aqevents.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

       aqevents.h

   Abstract:

       This file contains type definitions seo events

   Author:

        Rohan Phillips (Rohanp)     MAY-06-1998

   Revision History:

--*/

#ifndef _AQEVENT_PARAMS_
#define _AQEVENT_PARAMS_

#define SMTP_SERVER_EVENT_IO_TIMEOUT 5*60*1000

#include "filehc.h"


//
// These event IDs must not overlap with SMTP_DISPATCH_EVENT_TYPE
// defined in smtpseo.h
//
typedef enum _AQ_DISPATCH_EVENT_IDs
{
    SMTP_GET_DSN_RECIPIENT_ITERATOR_EVENT = 10000,
    SMTP_GENERATE_DSN_EVENT,
    SMTP_POST_DSN_EVENT
} SMTPAQ_DISPATCH_EVENT_TYPE;


//
// These define the structures passed to TriggerServerEvent (the PVOID
// pointer)
//
typedef struct _AQ_EVENT_ALLOC_
{
	PFIO_CONTEXT hContent;
	PVOID IMsgPtr;
	PVOID BindInterfacePtr;
	PVOID pAtqClientContext;
//	PATQ_CONTEXT pAtqContext;
	PVOID	* m_EventSmtpServer;
	LPCSTR  m_DropDirectory;

	DWORD   m_InstanceId;
	
	DWORD	m_RecipientCount;

	DWORD	*pdwRecipIndexes;
	HRESULT hr;

	DWORD	m_dwStartupType;
    PVOID   m_pNotify;
}AQ_ALLOC_PARAMS;

//
// DSN Events:
//
typedef struct _EVENTPARAMS_GET_DSN_RECIPIENT_ITERATOR {
    DWORD dwVSID;
    ISMTPServer *pISMTPServer;
    IMailMsgProperties *pIMsg;
    IMailMsgPropertyBag *pDSNProperties;
    DWORD dwStartDomain;
    DWORD dwDSNActions;
    IDSNRecipientIterator *pRecipIter;
} EVENTPARAMS_GET_DSN_RECIPIENT_ITERATOR, *PEVENTPARAMS_GET_DSN_RECIPIENT_ITERATOR;

typedef struct _EVENTPARAMS_GENERATE_DSN {
    DWORD dwVSID;
    IDSNGenerationSink *pDefaultSink;
    ISMTPServer *pISMTPServer;
    IDSNSubmission *pIDSNSubmission;
    IMailMsgProperties *pIMsg;
    IMailMsgPropertyBag *pDSNProperties;
    IDSNRecipientIterator *pRecipIter;
} EVENTPARAMS_GENERATE_DSN, *PEVENTPARAMS_GENERATE_DSN;

typedef struct _EVENTPARAMS_POST_GENERATE_DSN {
    DWORD dwVSID;
    ISMTPServer *pISMTPServer;
    IMailMsgProperties *pIMsgOrig;
    DWORD dwDSNAction;
    DWORD cRecipsDSNd;
    IMailMsgProperties *pIMsgDSN;
    IMailMsgPropertyBag *pIDSNProperties;
} EVENTPARAMS_POST_GENERATE_DSN, *PEVENTPARAMS_POST_GENERATE_DSN;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\dsnlang.h ===
//----------------------------------------------------------------------------
//
//  Copyright (C) 1998, Microsoft Corporation
//
//  File:      dsnlang.h
//
//  Contents:  Resource IDs for localizable DSN strings
//
//  Owner:   mikeswa
//
//-----------------------------------------------------------------------------

#ifndef __DSNLANG_H__
#define __DSNLANG_H__


//various subjects
#define FAILURE_SUBJECT         1
#define FALURE_RELAY_SUBJECT    2
#define FAILURE_RELAY_SUBJECT   3
#define DELAY_SUBJECT           4
#define GENERAL_SUBJECT         5
#define RELAY_SUBJECT           6
#define DELIVERED_SUBJECT       7
#define EXPANDED_SUBJECT        8
//Next group of ID's reserved for future localized subjects

//Human readable portions of DSN
#define DSN_SEE_ATTACHMENTS     10
#define FAILURE_SUMMARY         11
#define FAILURE_RELAY_SUMMARY   12
#define DELAY_SUMMARY           13
#define DSN_SUMMARY             14
#define RELAY_SUMMARY           15
#define DELIVERED_SUMMARY       16
#define EXPANDED_SUMMARY        17
#define FAILURE_SUMMARY_MAILBOX 18
#define FAILURE_SUMMARY_HOP     19
#define FAILURE_SUMMARY_EXPIRE  20
#define DELAY_WARNING           21
#define DELAY_DO_NOT_SEND       22
//helpful descriptions of the type of DSN being sent
#endif //__DSNLANG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\aqinit.h ===
//+------------------------------------------------------------
//
// Copyright (C) 1998, Microsoft Corporation
//
// File: aqinit.h
//
// Contents: Declarations of functions shared between aqueue and cat
//           to initialize/deinitialize
//
// Classes:
//
// Functions:
//
// History:
// jstamerj 1998/12/16 17:29:49: Created.
//
//-------------------------------------------------------------

//
// Refcounted initialize of exchmem and tracing
//
HRESULT HrDllInitialize();
//
// Refcounted deinitialize of exchmem and tracing
//
VOID DllDeinitialize();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\smtp\aqueue\inc\cat.h ===
/************************************************************
 * FILE: cat.h
 * PURPOSE: API for Categorizing IMsg objects.
 * HISTORY:
 *  // jstamerj 980211 13:53:44: Created
 *************************