  peDMAList = new DMA_LIST_ELEMENT;

			if (peDMAList == NULL)
			{
				continue;
			}

            peDMAList->dwDMA = iDMA;
            peDMAList->fConflict = FALSE;
            peDMAList->fAllocated = FALSE;
            (*ppDMAList)->push_back(peDMAList);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::InitMEMList
//
//  Purpose:    Initialize a MEM resource vector given a config manager
//              resource structure.
//
//  Arguments:
//      ppMEMList    [out]    returns MEM_LIST that will be created.
//      pMEMResource [in]     MEM_RESOURCE structure from config manager.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::InitMEMList(PMEM_LIST* ppMEMList, PMEM_RESOURCE pMEMResource) 
{
    PMEM_DES pMEMHeader;
    PMEM_RANGE pMEMData;
    PMEM_LIST_ELEMENT peMEMList;

    // For easy access
    pMEMHeader = &(pMEMResource->MEM_Header);
    pMEMData = pMEMResource->MEM_Data;

    // Create a new list.
    *ppMEMList = new MEM_LIST;

	if (*ppMEMList == NULL)
	{
		return;
	}
	
    ULONG iData;  // index of MEM_Range structure we're looking at.
    DWORDLONG MEMBase;   // current MEM Base we're adding to the list.
    ULONG cMEMBytes;  // number of bytes required.
    DWORDLONG MEMAlign;

    // Go through all the MEM_Range structures, and all MEMs in the
    // specified range to the list.

    for (iData = 0; iData < pMEMHeader->MD_Count; iData++) 
	{
        MEMAlign = pMEMData[iData].MR_Align;
        cMEMBytes = pMEMData[iData].MR_nBytes;

        // do sanity checks
        if (0 == MEMAlign)
        {
            TraceTag(ttidNetComm, "CHwRes::InitMEMList() - Bogus alignment "
                    "field while processing info from Config Manager.");
            break;
        }

        if (0 == cMEMBytes)
        {
            TraceTag(ttidNetComm, "CHwRes::InitMEMList() - Bogus membytes "
                    "field while processing info from Config Manager.");
            break;
        }

        for (MEMBase = pMEMData[iData].MR_Min;
                MEMBase+cMEMBytes-1 <= pMEMData[iData].MR_Max;
                MEMBase += ~MEMAlign + 1) 
		{
            // For each MEM that falls within the given range,
            // create new MEM List Element, populate its fields and insert
            // it into the MEMList.
            peMEMList = new MEM_LIST_ELEMENT;

			if (peMEMList == NULL)
			{
				continue;
			}

            //
            // BUGBUG (forrestf) dwMEM_Base and dwMEM_End are 32-bit fields.
            // It appears that they contain physical memory addresses, which
            // should be 64-bit (even on 32-bit machines), no?
            //

            peMEMList->dwMEM_Base = (DWORD)MEMBase;
            peMEMList->dwMEM_End = (DWORD)(MEMBase + cMEMBytes - 1);
            peMEMList->fConflict = FALSE;
            peMEMList->fAllocated = FALSE;
            (*ppMEMList)->push_back(peMEMList);

            // Check for wrapping.
            if (MEMBase >= MEMBase + ~MEMAlign + 1)
            {
                TraceTag(ttidError, "Memory base is greater than Memory "
                        "end!!!");
                break;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::InitIOList
//
//  Purpose:    Initialize an IO resource vector given a config manager
//              resource structure.
//
//  Arguments:
//      ppIOList    [out]    returns IO_LIST that will be created.
//      pIOResource [in]     IO_RESOURCE structure from config manager.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::InitIOList(PIO_LIST* ppIOList, PIO_RESOURCE pIOResource)
{
    PIO_DES pIOHeader;
    PIO_RANGE pIOData;
    PIO_LIST_ELEMENT peIOList;

    // For easy access
    pIOHeader = &(pIOResource->IO_Header);
    pIOData = pIOResource->IO_Data;

    // Create a new list.
    *ppIOList = new IO_LIST;

	if (*ppIOList == NULL)
	{
		return;
	}

    ULONG iData;  // index of IO_Range structure we're looking at.
    DWORDLONG IOBase;   // current IO Base we're adding to the list.
    ULONG cIOBytes;  // number of bytes required.
    DWORDLONG IOAlign;

    // Go through all the IO_Range structures, and all IOs in the
    // specified range to the list.

    for (iData = 0; iData < pIOHeader->IOD_Count; iData++) 
	{
        IOAlign = pIOData[iData].IOR_Align;
        cIOBytes = pIOData[iData].IOR_nPorts;

        // Perform sanity checks.
        if (0 == IOAlign)
        {
            TraceTag(ttidError, "CHwRes::InitIOList - Bogus alignment field "
                    "while processing data from Config Manager.");
            break;
        }

        if (0 == cIOBytes)
        {
            TraceTag(ttidError, "CHwRes::InitIOList - Bogus IObytes field "
                "while processing data from Config Manager.");
            break;
        }

        for (IOBase = pIOData[iData].IOR_Min;
                IOBase+cIOBytes-1 <= pIOData[iData].IOR_Max;
                IOBase += ~IOAlign + 1) 
		{
            // For each IO that falls within the given range,
            // create new IO List Element, populate its fields and insert
            // it into the IOList.
            peIOList = new IO_LIST_ELEMENT;

			if (peIOList == NULL)
			{
				continue;
			}

            peIOList->dwIO_Base = (DWORD)IOBase;
            peIOList->dwIO_End = (DWORD)(IOBase + cIOBytes-1);
            peIOList->fConflict = FALSE;
            peIOList->fAllocated = FALSE;
            (*ppIOList)->push_back(peIOList);

            // Check for wrapping.
            if (IOBase >= IOBase + ~IOAlign+1)
            {
                TraceTag(ttidError, "IO base is greater than IO end!!!");
                break;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::UseAnswerFile
//
//  Purpose:    Reads in settings from answerfile and puts them into m_vAf*
//              member variables.
//
//  Arguments:
//      szAnswerFile  [in]     Path to answerfile.
//      szSection     [in]     Section to read within answerfile
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::UseAnswerFile(const WCHAR * const szAnswerFile, const WCHAR * const szSection) {
    CWInfFile       AnswerFile;
    PCWInfSection   pSection;

    DWORD   dw;

    AssertSz(m_fInitialized,
             "UseAnswerFile called before CHwRes class HrInit'ed");

    // initialize answer file class
	if (AnswerFile.Init() == FALSE)
	{
        AssertSz(FALSE,"CHwRes::UseAnswerFile - Failed to initialize CWInfFile");
		return;
	}

    // Open the answerfile and find the desired section.
    AnswerFile.Open(szAnswerFile);
    pSection = AnswerFile.FindSection(szSection);

    // If the answer file section specified is missing
    // we should skip trying to read
    //
    if (pSection)
    {
        // Get the hardware resource keys
        if (pSection->GetIntValue(c_szAfIoAddr, &dw))
        {
            // set this only if the value isn't obviously wrong (i.e. <= 0)
            if (dw > 0)
            {
                m_vAfIo.SetDword(dw);
                m_vAfIo.SetPresent(TRUE);
            }
        }
        if (pSection->GetIntValue(c_szAfIrq, &dw))
        {
            // set this only if the value isn't obviously wrong (i.e. <= 0)
            if (dw > 0)
            {
                m_vAfIrq.SetDword(dw);
                m_vAfIrq.SetPresent(TRUE);
            }
        }
        if (pSection->GetIntValue(c_szAfDma, &dw))
        {
            // set this only if the value isn't obviously wrong (i.e. <= 0)
            if (dw > 0)
            {
                m_vAfDma.SetDword(dw);
                m_vAfDma.SetPresent(TRUE);
            }
        }
        if (pSection->GetIntValue(c_szAfMem, &dw))
        {
            // set this only if the value isn't obviously wrong (i.e. <= 0)
            if (dw > 0)
            {
                m_vAfMem.SetDword(dw);
                m_vAfMem.SetPresent(TRUE);
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FValidateAnswerfileSettings
//
//  Purpose:
//      Ensures that the hw resource settings read in from the answerfile
//      are valid.  It will, optionally, raise UI if the properties
//      are invalid.
//
//  Arguments:
//      fDisplayUI    [in]    TRUE, if an error UI is to be displayed if the
//                            answerfile settings are invalid
//
//  Returns:  HRESULT. S_OK if the answerfile settings are valid, S_FALSE if there
//                      are no resources to set, an error code otherwise
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//      Will set the m_vAfMemEnd and m_vAfIoEnd to correspond to
//      m_vAfMem and m_vAfIo.
//
HRESULT
CHwRes::HrValidateAnswerfileSettings(BOOL fDisplayUI)
{
    HRESULT hr = S_OK;

    AssertSz(m_fInitialized, "FValidateAnswerfileSettings called before "
             "CHwRes class HrInit'ed");

    // override current resource settings
    if (!m_vAfDma.IsPresent() &&
        !m_vAfIrq.IsPresent() &&
        !m_vAfIo.IsPresent() &&
        !m_vAfMem.IsPresent())
    {
        // no resources found...
        TraceTag(ttidNetComm, "No Hardware Resources found in answerfile.");
        hr = S_FALSE;
    }
    else
    {
        if (!FValidateAnswerfileResources())
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            TraceError("Error setting adapter resources from "
                    "answerfile.", hr);
        }
        else
        {
            // m_vAfMemEnd and m_vAfIoEnd were set by
            // FValidateAnswerfileResources()
            Assert(FImplies(m_vAfMem.IsPresent(), m_vAfMemEnd.IsPresent()));
            Assert(FImplies(m_vAfIo.IsPresent(), m_vAfIoEnd.IsPresent()));
        }
    }
    TraceError("CHwRes::HrValidateAnswerfileSettings",
        (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FCommitAnswerfileSettings
//
//  Purpose:
//      Commits (to the config manager) the hw resource settings read
//      in from the Answerfile.
//
//  Returns:    FALSE if there were problems writing the BootConfig entry.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FCommitAnswerfileSettings()
{
    AssertSz(m_fInitialized, "FCommitAnswerfileSettings called before "
             "CHwRes class HrInit'ed");

    Assert(FImplies(m_vAfIo.IsPresent(), m_vAfIoEnd.IsPresent()));
    Assert(FImplies(m_vAfMem.IsPresent(), m_vAfMemEnd.IsPresent()));

    // write out forced config entry to the config manager
    BOOL f;
    f = FCreateBootConfig(&m_vAfMem, &m_vAfMemEnd,
                            &m_vAfIo, &m_vAfIo,
                            &m_vAfDma,
                            &m_vAfIrq);
    return f;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FValidateAnswerfileResources
//
//  Purpose:    Validates the resource requirements read in from Answerfile.
//
//  Arguments:
//      nID       [out]       ID of thingy.
//      fInstall [in]       TRUE if installing, FALSE otherwise.
//      ppv      [in,out]   Old value is freed and this returns new value.
//
//  Returns:    TRUE, if resource requirement are valid.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//      Implementation note:  We have a set of resource requirements from
//      the answerfile (stored in m_vAf*).  This method iterates through
//      every logical config (execept alloc or boot ones) and tests to see
//      if the resource requirements are valid in the logical config.
//      If they are, then we can use the resource requirements.  If they're
//      not all valid in any logical config, then we return FALSE.
//
BOOL CHwRes::FValidateAnswerfileResources()
{
    DWORD dwMemEnd;
    DWORD dwIoEnd;
    BOOL fResourceValid;

    AssertSz(m_fInitialized, "FValidateAnswerfileResources called before "
             "CHwRes class HrInit'ed");

    // Configuration List should be initialized
    Assert(0 != m_ConfigList.size());
    PRESOURCE pResource;
    for (size_t iConfig = 0; iConfig < m_ConfigList.size(); iConfig++)
    {
        // we only want Basic configurations, so skip alloc or boot.
        if (m_ConfigList[iConfig]->fBoot || m_ConfigList[iConfig]->fAlloc)
        {
            continue;
        }

        fResourceValid = TRUE;
        if (m_vAfDma.IsPresent())
        {
            if (!FValidateDMA(m_ConfigList[iConfig], m_vAfDma.GetDword()))
            {
                fResourceValid = FALSE;
            }
        }
        if (m_vAfIrq.IsPresent())
        {
            if (!FValidateIRQ(m_ConfigList[iConfig], m_vAfIrq.GetDword()))
            {
                fResourceValid = FALSE;
            }
        }
        if (m_vAfIo.IsPresent())
        {
            if (!FGetIOEndPortGivenBasePort(m_ConfigList[iConfig],
                                           m_vAfIo.GetDword(), &dwIoEnd))
            {
                m_vAfIoEnd.SetPresent(FALSE);
                fResourceValid = FALSE;
            }
            else
            {
                m_vAfIoEnd.SetDword(dwIoEnd);
                m_vAfIoEnd.SetPresent(TRUE);
            }
        }
        if (m_vAfMem.IsPresent())
        {
            if (!FGetMEMEndGivenBase(m_ConfigList[iConfig],
                                    m_vAfMem.GetDword(), &dwMemEnd))
            {
                m_vAfMemEnd.SetPresent(FALSE);
                fResourceValid = FALSE;
            }
            else
            {
                m_vAfMemEnd.SetDword(dwMemEnd);
                m_vAfMemEnd.SetPresent(TRUE);
            }
        }
        if (fResourceValid) break; // found valid one.
    }
    // something has to be present (otherwise don't call this function!)
    Assert(m_vAfIo.IsPresent() || m_vAfIrq.IsPresent() ||
           m_vAfDma.IsPresent() || m_vAfMem.IsPresent());
    return fResourceValid;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FCreateBootConfig
//
//  Purpose:    Create and insert a Boot Config entry into the Config
//              Manager.
//
//  Arguments:
//      pvMem     [in]   Memory range base
//      pvMemEnd  [in]   Memory range end
//      pvIo      [in]   Io range base
//      pvIoEnd   [in]   Io range end
//      pvDma     [in]   Dma resource required.
//      pvIrq     [in]   Irq resource required.
//
//  Returns:    TRUE if creation of forced config was successful.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FCreateBootConfig(
    CValue * pvMem,
    CValue * pvMemEnd,
    CValue * pvIo,
    CValue * pvIoEnd,
    CValue * pvDma,
    CValue * pvIrq)
{
    DMA_RESOURCE DMARes;
    IO_RESOURCE IORes;
    MEM_RESOURCE MEMRes;
    IRQ_RESOURCE IRQRes;
    LOG_CONF lcLogConf = NULL;

    AssertSz(pvMem && pvMemEnd && pvIo && pvIoEnd && pvDma && pvIrq,
             "One of the pointer parameters passed to CHwRes::FCreate"
             "BootConfig() is null.");
    AssertSz(m_fInitialized, "FCreateBootConfig called before "
             "CHwRes class HrInit'ed");


    TraceTag(ttidNetComm, "In FCreateBootConfig");

    // Create a boot config
    //
    if (CM_Add_Empty_Log_Conf(&lcLogConf, m_DevNode, LCPRI_BOOTCONFIG,
            BOOT_LOG_CONF)
        != CR_SUCCESS)
    {
        TraceTag(ttidNetComm, "Unable to create BOOT_LOG_CONF");
        return FALSE;
    }

    if (pvDma->IsPresent())
    {
        Assert(pvDma->GetDword() > 0);
        // fill out DMAResource structure's header
        ZeroMemory(&DMARes, sizeof(DMARes));
        DMARes.DMA_Header.DD_Count = 0;
        DMARes.DMA_Header.DD_Type = DType_Range;
        DMARes.DMA_Header.DD_Flags = 0;
        DMARes.DMA_Header.DD_Alloc_Chan = pvDma->GetDword();
        // add to boot conf
        CM_Add_Res_Des(NULL, lcLogConf, ResType_DMA, &DMARes,
                       sizeof(DMARes), 0);
        TraceTag(ttidNetComm, "added Dma resource %lX", pvDma->GetDword());
    }
    if (pvIrq->IsPresent())
    {
        Assert(pvIrq->GetDword() > 0);
        // IRQResource structure
        ZeroMemory(&IRQRes, sizeof(IRQRes));
        IRQRes.IRQ_Header.IRQD_Count = 0;
        IRQRes.IRQ_Header.IRQD_Type = IRQType_Range;
        IRQRes.IRQ_Header.IRQD_Flags |=  fIRQD_Edge;
        IRQRes.IRQ_Header.IRQD_Alloc_Num = pvIrq->GetDword();
        IRQRes.IRQ_Header.IRQD_Affinity = 0;
        // add to boot conf
        CM_Add_Res_Des(NULL, lcLogConf, ResType_IRQ, &IRQRes,
                       sizeof(IRQRes), 0);
        TraceTag(ttidNetComm, "added IRQ resource %lX", pvIrq->GetDword());
    }
    if (pvIo->IsPresent()) {
        Assert(pvIo->GetDword() > 0);
        Assert(pvIoEnd->GetDword() > 0);
        ZeroMemory(&IORes, sizeof(IORes));
        IORes.IO_Header.IOD_Count = 0;
        IORes.IO_Header.IOD_Type = IOType_Range;
        IORes.IO_Header.IOD_Alloc_Base = pvIo->GetDword();
        IORes.IO_Header.IOD_Alloc_End = pvIoEnd->GetDword();
        IORes.IO_Header.IOD_DesFlags = fIOD_10_BIT_DECODE;
        // add to boot conf
        CM_Add_Res_Des(NULL, lcLogConf, ResType_IO, &IORes, sizeof(IORes), 0);
        TraceTag(ttidNetComm, "added IO resource %lX-%lX", pvIo->GetDword(),
                pvIoEnd->GetDword());
    }

    if (pvMem->IsPresent()) {
        Assert(pvMem->GetDword() > 0);
        Assert(pvMemEnd->GetDword() > 0);
        ZeroMemory(&MEMRes, sizeof(MEMRes));
        MEMRes.MEM_Header.MD_Count = 0;
        MEMRes.MEM_Header.MD_Type = MType_Range;
        MEMRes.MEM_Header.MD_Alloc_Base = pvMem->GetDword();
        MEMRes.MEM_Header.MD_Alloc_End = pvMemEnd->GetDword();
        MEMRes.MEM_Header.MD_Flags = 0;
        // add to boot conf
        CM_Add_Res_Des(NULL, lcLogConf, ResType_Mem, &MEMRes,
                       sizeof(MEMRes), 0);
        TraceTag(ttidNetComm, "added Memory resource %lX - %lX",
                pvMem->GetDword(), pvMemEnd->GetDword());
    }

    CM_Free_Log_Conf_Handle(lcLogConf);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FValidateIRQ
//
//  Purpose:    Validates that the IRQ given is valid in the given config.
//
//  Arguments:
//      pConfig  [in]    Config to use.
//      dwIRQ    [in]    irq setting to validate.
//
//  Returns:    TRUE if irq setting is valid.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FValidateIRQ(PCONFIGURATION pConfig, ULONG dwIRQ)
{
    PIRQ_LIST pIRQList;

    AssertSz(m_fInitialized, "FValidateIRQ called before "
             "CHwRes class HrInit'ed");

    Assert(pConfig != NULL);
    Assert(dwIRQ > 0);
    // For each IRQ resource in the given config
    //     go through list of valid IRQ looking for given one
    //         if found, return TRUE
    for (size_t iRes = 0; iRes < pConfig->cResource; iRes++)
    {
        if (pConfig->aResource[iRes].ResourceType != ResType_IRQ)
            continue;

        pIRQList = pConfig->aResource[iRes].pIRQList; // for easy access
        for (size_t iIRQ = 0; iIRQ < pIRQList->size(); iIRQ++)
        {
            if ((*pIRQList)[iIRQ]->dwIRQ == dwIRQ)
            {
                return TRUE;  // found it.
            }
        }
    }

    TraceTag(ttidNetComm, "IRQ %lX is not valid for this device", dwIRQ);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FValidateDMA
//
//  Purpose:    Validate that given DMA is valid in given config.
//
//  Arguments:
//      pConfig  [in]   configuration to use
//      dwDMA    [in]   dma setting to validate
//
//  Returns:    TRUE if dma setting is valid
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FValidateDMA(PCONFIGURATION pConfig, ULONG dwDMA)
{
    PDMA_LIST pDMAList;

    AssertSz(m_fInitialized, "FValidateDMA called before "
             "CHwRes class HrInit'ed");

    Assert(pConfig != NULL);
    Assert(dwDMA > 0);
    // For each dma resource in the given config
    //     go through list of valid dma looking for given one
    //         if found, return TRUE
    for (size_t iRes = 0; iRes < pConfig->cResource; iRes++)
    {
        if (pConfig->aResource[iRes].ResourceType != ResType_DMA)
            continue;

        pDMAList = pConfig->aResource[iRes].pDMAList; // for easy access
        for (size_t iDMA = 0; iDMA < pDMAList->size(); iDMA++)
        {
            if ((*pDMAList)[iDMA]->dwDMA == dwDMA)
            {
                return TRUE;
            }
        }
    }

    TraceTag(ttidNetComm, "DMA %lX is not valid for this device", dwDMA);
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FGetIOEndPortGivenBasePort
//
//  Purpose:    Get an IO Range given only the BasePort
//
//  Arguments:
//      pConfig  [in]       configuration to use.
//      dwBase   [in]       Io base
//      pdwEnd   [out]      Io end is returned
//
//  Returns:    TRUE if Io base is valid in given config.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FGetIOEndPortGivenBasePort(PCONFIGURATION pConfig, DWORD dwBase,
                               DWORD * pdwEnd)
{
    PIO_LIST pIOList;

    AssertSz(m_fInitialized, "FGetIOEndPortGivenBasePort called before "
             "CHwRes class HrInit'ed");

    Assert(pConfig != NULL);
    Assert(dwBase > 0);
    // For each resource in the given configuration
    //     if it's an IO Resource
    //         Go through the list of valid IO resources looking for
    //          a matching base port
    //              if found, then set the corresponding end port, return TRUE;
    for (size_t iRes = 0; iRes < pConfig->cResource; iRes++)
    {
        // ensure we're looking at an IO type
        if (pConfig->aResource[iRes].ResourceType != ResType_IO)
            continue;

        pIOList = pConfig->aResource[iRes].pIOList; // for easy access
        // go through all IO Elements in this list
        for (size_t iIO = 0; iIO < pIOList->size();  iIO++)
        {
            if ((*pIOList)[iIO]->dwIO_Base == dwBase)
            {
                // found matching IO base port
                *pdwEnd = (*pIOList)[iIO]->dwIO_End;
                return TRUE;
            }
        }
    }
    TraceTag(ttidNetComm, "IO %lX is not valid for this device", dwBase);
    return FALSE; // not found
}


//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FGetMEMEndGivenBase
//
//  Purpose:    Get a MEM range given the Mem base and config.
//
//  Arguments:
//      pConfig  [in]       configuration to use
//      dwBase   [in]       mem base
//      pdwEnd   [out]      mem end is returned.
//
//  Returns:    TRUE if the dwBase is a valid mem setting.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
BOOL CHwRes::FGetMEMEndGivenBase(PCONFIGURATION pConfig, DWORD dwBase,
                        DWORD * pdwEnd)
{
    PMEM_LIST pMEMList;

    AssertSz(m_fInitialized, "FGetMEMEndGivenBase called before "
             "CHwRes class HrInit'ed");

    Assert(pConfig != NULL);
    Assert(dwBase > 0);
    // For each resource in the given configuration
    //     if it's an MEM Resource
    //         Go through the list of valid MEM resources looking for
    //         a matching base port
    //              if found, then set the corresponding end port,return TRUE;
    for (size_t iRes = 0; iRes < pConfig->cResource; iRes++)
    {
        // ensure we're looking at an MEM type
        if (pConfig->aResource[iRes].ResourceType != ResType_Mem)
            continue;

        pMEMList = pConfig->aResource[iRes].pMEMList; // for easy access
        // go through all MEM Elements in this list
        for (size_t iMEM = 0; iMEM < pMEMList->size();  iMEM++)
        {
            if ((*pMEMList)[iMEM]->dwMEM_Base == dwBase)
            {
                // found matching MEM base addr
                *pdwEnd = (*pMEMList)[iMEM]->dwMEM_End;
                return TRUE;
            }
        }
    }
    TraceTag(ttidNetComm, "Memory %lX is not valid for this device", dwBase);
    return FALSE; // not found
}

//$REVIEW (t-pkoch) this function isn't yet in our custom STL...
//    it can be removed later (when it causes errors)

template<class T> void os_release(vector<T> & v)
{
    for(vector<T>::iterator iterDelete = v.begin() ; iterDelete != v.end() ;
        ++iterDelete)
        delete *iterDelete;
}


CHwRes::~CHwRes()
{
    AssertSz(m_fHrInitCalled, "CHwRes destructor called before "
             "CHwRes::HrInit() called");

    vector<CONFIGURATION *>::iterator ppConfig;
    RESOURCE *  pRes;

    // Delete everything from m_ConfigList.
    for (ppConfig = m_ConfigList.begin(); ppConfig != m_ConfigList.end();
         ppConfig++)
    {
        for (size_t iRes = 0; iRes < (*ppConfig)->cResource; iRes++)
        {
            pRes = &((*ppConfig)->aResource[iRes]);
            switch(pRes->ResourceType)
            {
            case ResType_IRQ:
                os_release(*(pRes->pIRQList));
                delete pRes->pIRQList;
                break;
            case ResType_DMA:
                os_release(*(pRes->pDMAList));
                delete pRes->pDMAList;
                break;
            case ResType_IO:
                os_release(*(pRes->pIOList));
                delete pRes->pIOList;
                break;
            case ResType_Mem:
                os_release(*(pRes->pMEMList));
                delete pRes->pMEMList;
                break;
            }
        }
        delete *ppConfig;
    }


    ReleaseObj(m_pnccItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\resource.h ===
#include <ncres.h>

// Error strings
#define IDS_PARAM_RANGE             IDS_NC_NETCOMM + 0
#define IDS_PARAM_RANGE_STEP        IDS_NC_NETCOMM + 1
#define IDS_NO_DESCRIPTION          IDS_NC_NETCOMM + 2
#define IDS_ERR_VALUE_BAD_CHARS     IDS_NC_NETCOMM + 3
#define IDS_ERR_VALUE_EMPTY         IDS_NC_NETCOMM + 4
#define IDS_ERROR_CAPTION           IDS_NC_NETCOMM + 5


// Advanced Property Page
#define DLG_PARAMS                  1505
#define IDD_PARAMS_LIST             1101
#define IDD_PARAMS_EDIT             1102
#define IDD_PARAMS_DROP             1103
#define IDD_PARAMS_SPIN             1104
#define IDD_PARAMS_PRESENT          1105
#define IDD_PARAMS_NOT_PRESENT      1106
#define IDD_ADVANCED_TEXT           1110
#define IDD_PARAMS_PRESENT_TEXT     1111  // Used for "KeyOnly" Type
#define IDD_PARAMS_VALUE            1112
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\param.cpp ===
#include "pch.h"
#pragma hdrstop
#include "global.h"
#include "ncreg.h"
#include "ncstring.h"
#include "ncxbase.h"
#include "param.h"
#include "resource.h"
#include "util.h"

CParam::CParam ()
:   m_fInit(FALSE),
    m_eType(VALUETYPE_UNKNOWN),
    m_hkRoot(NULL),
    m_pszKeyName(NULL),
    m_pszDesc(NULL),
    m_pszHelpFile(NULL),
    m_dwHelpContext(0),
    m_uLimitText(0),
    m_hkEnum(NULL),
    m_fOptional(FALSE),
    m_fModified(FALSE),
    m_fReadOnly(FALSE),
    m_fOEMText(FALSE),
    m_fUppercase(FALSE)
{
}

BOOL CParam::FInit(HKEY hkRoot, HKEY hkNdiParam, PWSTR pszSubKey)
{
    HRESULT hr = S_OK;
    DWORD   cbBuf;
    BYTE    szBuf[VALUE_SZMAX];
    UINT    uTemp;
    DWORD   dwType;
    HKEY    hkParamInfo;

    // store hkRoot, pszSubKey for future reference
    m_hkRoot = hkRoot;
    m_pszKeyName = new WCHAR[lstrlenW (pszSubKey) + 1];

	if (m_pszKeyName == NULL)
	{
		return(FALSE);
	}

    lstrcpyW (m_pszKeyName, pszSubKey);

    hr = HrRegOpenKeyEx(hkNdiParam, pszSubKey, KEY_READ,
                        &hkParamInfo);
    if (FAILED(hr))
    {
        hkParamInfo = NULL;
        goto error;
    }

    // Get the parameter type, use EDIT if none specified
    // range values (etc.) for the type. If 'type' is empty
    // or invalid, the "int" type is returned.
    cbBuf = sizeof(szBuf);
    hr = HrRegQueryValueEx(hkParamInfo,c_szRegParamType,&dwType,szBuf,&cbBuf);
    if (SUCCEEDED(hr))
    {
        AssertSz(REG_SZ == dwType,
                 "Expecting REG_SZ type but got something else.");
    }
    else
    {
        ((PWCHAR)szBuf)[0] = L'\0';
    }

    InitParamType((PTSTR)szBuf);

    // Get the description text
    cbBuf = sizeof(szBuf);
    hr = HrRegQueryValueEx(hkParamInfo,c_szRegParamDesc,&dwType,szBuf,&cbBuf);
    if (SUCCEEDED(hr))
    {
        AssertSz(REG_SZ == dwType,
                 "Expecting REG_SZ type but got something else.");
    }
    else
    {
        // No description string
        lstrcpyW((WCHAR *)szBuf, SzLoadIds (IDS_NO_DESCRIPTION));
    }

    // allocate and store description
    m_pszDesc = new WCHAR[lstrlenW((WCHAR *)szBuf) + 1];

	if (m_pszDesc == NULL)
	{
		return(FALSE);
	}

    lstrcpyW(m_pszDesc, (WCHAR *)szBuf);

    // Optional parameter
    m_fOptional = FALSE;
    uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamOptional,0);

    if (uTemp != 0)
    {
        m_fOptional = TRUE;
    }

    // Help file info
    m_pszHelpFile = NULL;
    m_dwHelpContext = 0;
    cbBuf = sizeof(szBuf);
    hr = HrRegQueryValueEx(hkParamInfo,c_szRegParamHelpFile,&dwType,
                           szBuf,&cbBuf);
    if (SUCCEEDED(hr))
    {
        AssertSz(REG_SZ == dwType,
                 "Expecting REG_SZ type but got something else.");
        m_pszHelpFile = new WCHAR[lstrlenW((WCHAR *)szBuf)+1];

		if (m_pszHelpFile == NULL)
		{
			return(FALSE);
		}

        lstrcpyW(m_pszHelpFile, (WCHAR *)szBuf);
        m_dwHelpContext = Reg_QueryInt(hkParamInfo,c_szRegParamHelpContext,0);
    }

    // Numeric Type Info
    if (m_vValue.IsNumeric())
    {
        // if no step value in registry, default to 1 (default already
        // set in FInitParamType() )
        m_vStep.FLoadFromRegistry(hkParamInfo,c_szRegParamStep);
        if (m_vStep.GetNumericValueAsDword() == 0)
        {
            m_vStep.SetNumericValue(1);
        }

        // get m_vMix and m_vMax from registry (no effect if doesn't exist,
        // defaults were set in FInitParamType() )
        (VOID) m_vMin.FLoadFromRegistry(hkParamInfo,c_szRegParamMin);
        (VOID) m_vMax.FLoadFromRegistry(hkParamInfo,c_szRegParamMax);
    }

    // Edit type info
    else if (m_eType == VALUETYPE_EDIT)
    {
        // Limit text
        m_uLimitText = VALUE_SZMAX-1;
        uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamLimitText,m_uLimitText);
        if ((uTemp > 0) && (uTemp < VALUE_SZMAX))
        {
            m_uLimitText = uTemp;
        }

        // Read-only
        m_fReadOnly = FALSE;
        uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamReadOnly,0);
        if (uTemp != 0)
        {
            m_fReadOnly = TRUE;
        }

        // OEMText
        m_fOEMText = FALSE;
        uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamOEMText,0);
        if (uTemp != 0)
        {
            m_fOEMText = TRUE;
        }

        // Uppercase
        m_fUppercase = FALSE;
        uTemp = Reg_QueryInt(hkParamInfo,c_szRegParamUppercase,0);
        if (uTemp != 0)
        {
            m_fUppercase = TRUE;
        }
    }

    // Enum type info
    else if (m_eType == VALUETYPE_ENUM)
    {
        hr = HrRegOpenKeyEx(hkParamInfo,c_szRegParamTypeEnum,KEY_READ,
                            &m_hkEnum);
        if (FAILED(hr))
        {
            m_hkEnum = NULL;
        }
    }

    // Current Value
    m_fModified = FALSE;
    if (!m_vValue.FLoadFromRegistry(m_hkRoot,m_pszKeyName,hkParamInfo))
    {
        // Use default value (current value not in registry)
        if (!m_vValue.FLoadFromRegistry(hkParamInfo,c_szRegParamDefault))
        {
            // If no default in registry, assume a decent value
            if (m_vValue.IsNumeric())
            {
                m_vValue.Copy(&m_vMin);
            }
            else
            {
                m_vValue.FromString(L"");
            }
        }

        // Keep not-present state of optional parameters.
        // Mark required parameters modified since we read the default.
        if (m_fOptional)
        {
            m_vValue.SetPresent(FALSE);
        }
        else
        {
            m_fModified = TRUE;
        }
    }

    // Save initial value for comparison in Param_Validate
    // The initial value is always valid - in case the user hand-mucks
    // it to something outside the specified range.
    m_vInitial.Copy(&m_vValue);

    m_fInit = TRUE;
    RegSafeCloseKey(hkParamInfo);
    return TRUE;

error:
    // Cleanup done by destructor.
    return FALSE;

}


VOID CParam::InitParamType(PTSTR pszType)
{
    typedef struct tagPTABLE
    {
        const WCHAR * pszToken;
        VALUETYPE        type;
        DWORD       dwMin;
        DWORD       dwMax;
    } PTABLE;
    static PTABLE ptable[] =
    {
        // 1st entry is default if pszType is invalid or unknown
        {c_szRegParamTypeEdit,  VALUETYPE_EDIT,  NULL,           NULL},
        {c_szRegParamTypeInt,   VALUETYPE_INT,   SHRT_MIN, SHRT_MAX},
        {c_szRegParamTypeLong,  VALUETYPE_LONG,  LONG_MIN,(DWORD)LONG_MAX},
        {c_szRegParamTypeWord,  VALUETYPE_WORD,  0,              USHRT_MAX},
        {c_szRegParamTypeDword, VALUETYPE_DWORD, 0,              ULONG_MAX},
        {c_szRegParamTypeEnum,  VALUETYPE_ENUM,  NULL,           NULL},
        {c_szRegParamTypeKeyonly, VALUETYPE_KONLY, NULL,           NULL}
    };

    UINT    i;
    PTABLE* pt;

    Assert(pszType != NULL);

    // Lookup token in param table
    for (i=0; i < celems(ptable); i++)
    {
        pt = &ptable[i];
        if (lstrcmpiW(pt->pszToken,pszType) == 0)
        {
            break;
        }
    }
    if (i >= celems(ptable))
    {
        pt = &ptable[0];
    }

    // Table default values
    m_eType = pt->type;
    m_vValue.Init(pt->type,0);
    m_vInitial.Init(pt->type,0);

    if (m_vValue.IsNumeric())
    {
        m_vMin.Init(pt->type,pt->dwMin);
        m_vMax.Init(pt->type,pt->dwMax);
        m_vStep.Init(pt->type,1);
    }
    else
    {
        m_vMin.Init(pt->type,NULL);
        m_vMax.Init(pt->type,NULL);
        m_vStep.Init(pt->type,0);
    }
}

// Notes: Don't close m_hkRoot since other's may have copies of it.
//        ~CAdvanced will close it.
//
CParam::~CParam()
{
    // Close the enum subkey
    RegSafeCloseKey(m_hkEnum);

    // free strings
    delete m_pszKeyName;
    delete m_pszDesc;
    delete m_pszHelpFile;

    // free values
    m_vValue.Destroy();
    m_vInitial.Destroy();
    m_vMin.Destroy();
    m_vMax.Destroy();
    m_vStep.Destroy();
}

// Applies from In-Memory storage to registry
BOOL CParam::Apply() {
    AssertSz(m_fInit,"CParam not FInit()'ed.");
    if (!FIsModified())
    {
        return TRUE;  // not modified, don't save.
    }
    Assert(0 == m_vValue.Compare(&m_vValue));
    m_fModified = FALSE;
    m_vInitial.Copy(&m_vValue);
    return m_vValue.FSaveToRegistry(m_hkRoot,m_pszKeyName);

}


UINT CParam::Validate()
{
    AssertSz(m_fInit, "CParam not FInit()'ed.");
    // Equal to the initial value is ok
    if (m_vValue.Compare(&m_vInitial) == 0)
    {
        return VALUE_OK;
    }

    // Unpresent-optional value is ok
    if (FIsOptional() && !m_vValue.IsPresent())
    {
        return VALUE_OK;
    }

    // Invalid characters
    if (m_vValue.IsInvalidChars())
    {
        return VALUE_BAD_CHARS;
    }

    // Empty required field
    if (m_vValue.IsEmptyString() && m_vValue.IsPresent() && (m_vValue.GetType() != VALUETYPE_KONLY))
    {
        return VALUE_EMPTY;
    }

    // Numeric range
    if (m_vValue.IsNumeric())
    {
        // If value is < min, out of range
        if (m_vValue.Compare(&m_vMin) < 0)
        {
            return VALUE_OUTOFRANGE;
        }

        // If value is > max, out of range
        if (m_vValue.Compare(&m_vMax) > 0)
        {
            return VALUE_OUTOFRANGE;
        }

        // Step-range
        Assert(m_vStep.GetNumericValueAsDword() != 0);

        if (((m_vValue.GetNumericValueAsDword() -
             m_vMin.GetNumericValueAsDword())
             % m_vStep.GetNumericValueAsDword()) != 0)
        {
            return VALUE_OUTOFRANGE;
        }
    }

    return VALUE_OK;
}


VOID CParam::GetDescription(WCHAR * sz, UINT cch)
{
    AssertSz(m_fInit, "CParam not FInit()'ed.");
    lstrcpynW(sz, m_pszDesc, cch);
}

VOID CParam::GetHelpFile(WCHAR * sz, UINT cch)
{
    AssertSz(m_fInit, "CParam not FInit()'ed.");
    lstrcpynW(sz, m_pszHelpFile, cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\util.h ===
VOID StripSpaces(PWSTR buf);
UINT Reg_QueryInt(HKEY hk, const WCHAR * pszValueName, UINT uDefault);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\util.cpp ===
#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncstring.h"

VOID StripSpaces(WCHAR * buf)
{
    WCHAR *   pch = buf;

    Assert(buf);

    // Find first non-space
    while( (*pch) == L' ' )
    {
        pch++;
    }
    MoveMemory(buf, pch, CbOfSzAndTerm(pch));

    if (lstrlenW(buf) > 0) {
        // Do this only if there's at least one character in string
        pch = buf + lstrlenW(buf);  // Point to null (at end of string)
        Assert(*pch == L'\0');
        pch--;  // Go back one character.

        // As long as character is ' ' go to prev char
        while( (pch >= buf) && (*pch == L' ') )
        {
            pch--;
        }
        Assert (pch >= buf);
        Assert (*pch != L' ');

        // Next position after last char
        pch++;

        // null terminate at last byte
        *pch = L'\0';
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//  Reg_QueryInt
//
/////////////////////////////////////////////////////////////////////////////

UINT Reg_QueryInt(HKEY hk, const WCHAR * pszValueName, UINT uDefault)
{
    DWORD cbBuf;
    BYTE szBuf[32];
    DWORD dwType;
    HRESULT hr;

    cbBuf = sizeof(szBuf);
    hr = HrRegQueryValueEx(hk, pszValueName, &dwType, szBuf, &cbBuf);
    if (SUCCEEDED(hr))
    {
        Assert(dwType == REG_SZ);
        return (UINT)_wtoi((WCHAR *)szBuf);
    }
    else
    {
        return uDefault;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\param.h ===
#pragma once
#include "value.h"

class CParam
{
public:
    CParam();
    ~CParam();
    BOOL FInit(HKEY hkRoot, HKEY hkNdiParam, PWSTR pszSubKey);
    BOOL Apply(); // Applies from Temp storage to In-Memory storage.
    UINT Validate();
    VOID GetDescription(WCHAR *sz, UINT cch);
    VOID GetHelpFile(WCHAR *sz, UINT cch);
    VOID AlertPrintfRange(HWND hDlg);

    // Data accessors
    VALUETYPE GetType() {return m_eType;}
    BOOL FIsOptional() {return m_fOptional;};
    BOOL FIsModified() {return m_fModified;}
    BOOL FIsReadOnly() {return m_fReadOnly;}
    BOOL FIsOEMText()  {return m_fOEMText;}
    BOOL FIsUppercase() {return m_fUppercase;}

    CValue * GetInitial() {return &m_vInitial;}
    CValue * GetValue() {return &m_vValue;}
    CValue * GetMin() {return &m_vMin;}
    CValue * GetMax() {return &m_vMax;}
    CValue * GetStep() {return &m_vStep;}

    HKEY GetEnumKey()
    {
        AssertH(VALUETYPE_ENUM == m_eType);
        return m_hkEnum;
    }

    UINT GetLimitText()
    {
        AssertH((VALUETYPE_EDIT == m_eType) || (VALUETYPE_DWORD == m_eType)
                || (VALUETYPE_LONG == m_eType));
        return m_uLimitText;
    }
    WCHAR * GetDesc()
    {
        return m_pszDesc;
    }

    PCWSTR SzGetKeyName()
    {
        return m_pszKeyName;
    }


    VOID SetModified(BOOL f) {m_fModified = f;}


    // Values
    CValue      m_vValue;         // current control value
    CValue      m_vInitial;       // initial value read in

    // Range info (type-specific)
    CValue      m_vMin;           // numeric types - minimum value
    CValue      m_vMax;           // numeric types - maximum value
    CValue      m_vStep;          // numeric types - step value

private:
    VOID InitParamType(PTSTR lpszType);

    BOOL        m_fInit;

    // General info
    VALUETYPE   m_eType;           // value type
    HKEY        m_hkRoot;         // instance root
    WCHAR *     m_pszKeyName;     // Name of subkey for this parameter.
    WCHAR *     m_pszDesc;        // value description
    WCHAR *     m_pszHelpFile;    // help file
    DWORD       m_dwHelpContext;  // help context id

    UINT        m_uLimitText;     // edit type - max chars
    HKEY        m_hkEnum;         // enum type - registry param enum subkey

    // Flags
    BOOL        m_fOptional;    // optional paramter
    BOOL        m_fModified;    // param has been modified
    BOOL        m_fReadOnly;    // edit type - read-only
    BOOL        m_fOEMText;     // edit type - oem convert
    BOOL        m_fUppercase;   // edit type - uppercase
};

const DWORD c_cchMaxNumberSize = 16;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\value.cpp ===
#include "pch.h"
#pragma hdrstop
#include "global.h"
#include "value.h"
#include "util.h"
#include "ncreg.h"
#include "ncstring.h"

static const int c_valueSzMax;

CValue::CValue()
:   m_fInit(FALSE),
    m_eType(VALUETYPE_UNKNOWN),
    m_fNumeric(FALSE),
    m_fHex(FALSE),
    m_fPresent(FALSE),
    m_fInvalidChars(FALSE),
    m_fEmptyString(FALSE),
    m_psz(0)
{
}

CValue::~CValue()
{
#ifdef DBG
    if (!m_fNumeric)
    {
        AssertSz(!m_psz, "m_psz not deallocated before ~CValue called.");
    }
#endif
}

VOID CValue::Init(VALUETYPE type, DWORD value)
{
    Assert(m_fInit == FALSE);
    m_fInit = TRUE;
    SetType(type);
    SetPresent(TRUE);
    SetInvalidChars(FALSE);
    SetEmptyString(FALSE);
    if ((GetType() == VALUETYPE_EDIT) ||
        (GetType() == VALUETYPE_ENUM) ||
        (GetType() == VALUETYPE_KONLY))
    {
        m_fNumeric = FALSE;
        m_psz = NULL;
        FromString(NULL);
    }
    else
    {
        m_fNumeric = TRUE;
        m_dw = value;
    }
}

VOID CValue::InitNotPresent(VALUETYPE type)
{
    Init(type, 0);
    SetPresent(FALSE);
}

VOID CValue::Destroy()
{
    AssertSz(m_fInit, "CValue class not Init'ed");
    if (!IsNumeric())
    {
        delete m_psz;
        m_psz = NULL;
    }
    m_dw = NULL;  // since all other values are a union, this'll clear
                  // out everything.
    m_fInit = FALSE;
}

// copies into current object
VOID CValue::Copy(CValue *pvSrc)
{
    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(pvSrc != NULL);
    AssertSz(m_eType == pvSrc->m_eType,
             "Can't copy from different value types.");
    // Clear out the destination value
    Destroy();
    AssertSz( ! m_psz, "Memory should have been deallocated by Destroy()");

    // Copy contents of source value
    *this = *pvSrc;

    // Reallocate string
    if ( ! pvSrc->IsNumeric())
    {
        if (pvSrc->m_psz)
        {
            // allocate and copy string.
            m_psz = new WCHAR[lstrlenW(pvSrc->m_psz) + 1];

			if (m_psz == NULL)
			{
				Assert(0);
				return;
			}

            lstrcpyW(m_psz,pvSrc->m_psz);
        }
    }
}

VOID CValue::SetNumericValue(DWORD dw)
{
    Assert(m_fInit);
    Assert(m_fNumeric);
    switch(m_eType)
    {
    case VALUETYPE_DWORD:
        SetDword(dw);
        break;
    case VALUETYPE_LONG:
        SetLong(dw);
        break;
    case VALUETYPE_WORD:
        Assert(dw <= USHRT_MAX);
        SetWord(static_cast<WORD>(dw));
        break;
    case VALUETYPE_INT:
        Assert(dw <= SHRT_MAX);
        Assert(dw >= SHRT_MIN);
        SetShort(static_cast<short>(dw));
        break;
    default:
        AssertSz(FALSE, "Invalid numeric type for this value");
        break;
    }
}

BOOL CValue::FromString(const WCHAR * const pszValue)
{
    UINT    uBase;
    PWSTR   pszEnd;
    PWSTR   psz;
    WCHAR   szTemp[VALUE_SZMAX];

    AssertSz(m_fInit, "CValue class not Init'ed");

    // Fixup string
    if (!pszValue)
    {
        szTemp[0] = L'\0';
    }
    else
    {
        lstrcpynW(szTemp,pszValue, celems(szTemp));
        StripSpaces(szTemp);
    }
    psz = szTemp;

    // Get numeric base
    uBase = IsHex() ? 16 : 10;

    // Initialize to valid
    SetInvalidChars(FALSE);
    SetEmptyString(FALSE);

    if ( ! *psz)
    {
        SetEmptyString(TRUE);
    }

    // Convert
    switch (GetType())
    {
        default:
        case VALUETYPE_INT:
            SetShort((short)wcstol(psz,&pszEnd,uBase));

            if (*pszEnd != L'\0')
			{
                SetInvalidChars(TRUE);
			}

            break;

        case VALUETYPE_LONG:
            SetLong(wcstol(psz,&pszEnd,uBase));

            if (*pszEnd != L'\0')
			{
                SetInvalidChars(TRUE);
			}

            break;

        case VALUETYPE_WORD:
            SetWord((WORD)wcstoul(psz,&pszEnd,uBase));

            if (*pszEnd != L'\0')
			{
                SetInvalidChars(TRUE);
			}

            break;

        case VALUETYPE_DWORD:
            SetDword(wcstoul(psz,&pszEnd,uBase));

            if (*pszEnd != L'\0')
			{
                SetInvalidChars(TRUE);
			}

            break;

        case VALUETYPE_ENUM:
        case VALUETYPE_EDIT:
            if (m_psz) 
			{
                delete m_psz;
                m_psz = NULL;
            }

            m_psz = new WCHAR[lstrlenW(psz) + 1];

			if (m_psz == NULL)
			{
				return(FALSE);
			}

            lstrcpyW(m_psz,psz);
            break;

        case VALUETYPE_KONLY:
            break;
    }

    return TRUE;
}

BOOL CValue::ToString(WCHAR * sz, UINT cch)
{
    UINT len;

    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(sz != NULL);

    switch (GetType())
    {
    case VALUETYPE_INT:
        len = (UINT)wsprintfW(sz,L"%d",GetShort());
        Assert(len+1 <= cch); // verify that we allocated enough space
        break;

    case VALUETYPE_LONG:
        len = (UINT)wsprintfW(sz,L"%ld",GetLong());
        Assert(len+1 <= cch);
        break;

    case VALUETYPE_WORD:
        if (IsHex()) {
            len = (UINT)wsprintfW(sz,L"%-2X",GetWord());
        } else {
            len = (UINT)wsprintfW(sz,L"%u",GetWord());
        }
        Assert(len+1 <= cch);
        break;

    case VALUETYPE_DWORD:
        if (IsHex()) {
            len = (UINT)wsprintfW(sz,L"%-2lX",GetDword());
        } else {
            len = (UINT)wsprintfW(sz,L"%lu",GetDword());
        }
        Assert(len+1 <= cch);
        break;

    case VALUETYPE_ENUM:
    case VALUETYPE_EDIT:
        lstrcpynW (sz, m_psz, cch);
        break;

    case VALUETYPE_KONLY:
        Assert(cch >= 2);
        lstrcpynW (sz, L"1", cch);  // If present, store a "1" in the registry.
        break;
    }

    return TRUE;
}

// Compares the current object to another object
// Return values: 0 = both objs are the same
//               <0 = cur obj is less then the other obj
//               >0 = cur obj is greater than the other obj
int CValue::Compare(CValue *pv2)
{
    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(pv2 != NULL);
    Assert(GetType() == pv2->GetType());

    // Present/not present (present is greater than not present)
    if (!IsPresent() && !pv2->IsPresent())
    {
        return 0;
    }
    if (!IsPresent() && pv2->IsPresent())
    {
        return -1;
    }
    if (IsPresent() && !pv2->IsPresent())
    {
        return 1;
    }

    // Compare
    switch (GetType())
    {
    case VALUETYPE_INT:
        if (GetShort() == pv2->GetShort())
        {
            return 0;
        }
        return (GetShort() < pv2->GetShort()) ? -1 : 1;
    case VALUETYPE_LONG:
        if (GetLong() == pv2->GetLong())
        {
            return 0;
        }
        return (GetLong() < pv2->GetLong())? -1 : 1;
    case VALUETYPE_WORD:
        if (GetWord() == pv2->GetWord())
        {
            return 0;
        }
        return (GetWord() < pv2->GetWord())? -1 : 1;
    case VALUETYPE_DWORD:
        if (GetDword() == pv2->GetDword())
        {
            return 0;
        }
        return (GetDword() < pv2->GetDword())? -1 : 1;
    case VALUETYPE_ENUM:
    case VALUETYPE_EDIT:
        if ((GetPsz() != NULL) && (pv2->GetPsz() != NULL))
        {
            return lstrcmpW(GetPsz(),pv2->GetPsz());
        }
        else
        {
            return -2; // REVIEW: what does -2 mean?
        }
    case VALUETYPE_KONLY:
        return 1;
    default:
        Assert(FALSE);
        return 1;  // to stop compiler warning.
    }
}

// if false, then value doesn't change.
BOOL CValue::FLoadFromRegistry(HKEY hk, const WCHAR * pszValueName, HKEY hkParam /* = INVALID_HANDLE_VALUE */)
{
    DWORD   cbBuf;
    WCHAR   szBuf[VALUE_SZMAX];
    DWORD   dwType;
    HRESULT hr = S_OK;
    HKEY    hkTemp;

    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(hk);
    Assert(pszValueName);

    // determine base
    SetHex(FALSE);

    if (hkParam != (HKEY)INVALID_HANDLE_VALUE)
        hkTemp = hkParam;
    else
        hkTemp = hk;

    if (Reg_QueryInt(hkTemp, c_szRegParamBase,10) == 16)
    {
        SetHex(TRUE);
    }

    cbBuf = sizeof(szBuf);

    hr = HrRegQueryValueEx(hk,pszValueName,&dwType,(BYTE*)szBuf,&cbBuf);
    if (SUCCEEDED(hr))
    {
        AssertSz(REG_SZ == dwType,
                 "Expecting REG_SZ, but got something else.");
    }
    if (FAILED(hr) || !szBuf[0])
    {
        return FALSE;
    }

    m_fPresent = TRUE;
    return FromString(szBuf);
}

BOOL CValue::FSaveToRegistry(HKEY hk, const WCHAR * pszValueName)
{
    DWORD   cbBuf;
    WCHAR   szBuf[VALUE_SZMAX];

    AssertSz(m_fInit, "CValue class not Init'ed");
    Assert(hk);
    Assert(pszValueName);
    if (!IsPresent())
    {
        RegDeleteValue(hk,pszValueName);
        return TRUE;
    }

    ToString(szBuf,celems(szBuf));
    cbBuf = CbOfSzAndTerm(szBuf);
    return (RegSetValueEx(
                hk,
                pszValueName,
                NULL,
                REG_SZ,
                (LPBYTE)
                szBuf,
                cbBuf)
            == ERROR_SUCCESS);
}

int CValue::GetNumericValueAsSignedInt()
{
    Assert(m_fInit);
    Assert(m_fPresent);
    Assert(m_fNumeric);

    int nret = 0;
    switch (m_eType)
    {
    case VALUETYPE_DWORD:
        nret = GetDword();
        break;
    case VALUETYPE_LONG:
        nret = GetLong();
        break;
    case VALUETYPE_WORD:
        nret = GetWord();
        break;
    case VALUETYPE_INT:
        nret = GetShort();
        break;
    default:
        Assert("Hit default case in GetNumericValueAsSignedInt");
        break;
    }

    return nret;
}

DWORD CValue::GetNumericValueAsDword()
{
    AssertH(m_fInit);
    AssertH(m_fPresent);
    AssertH(m_fNumeric);

    DWORD dwret = 0;
    switch (m_eType)
    {
    case VALUETYPE_DWORD:
        dwret = GetDword();
        break;
    case VALUETYPE_LONG:
        dwret = GetLong();
        break;
    case VALUETYPE_WORD:
        dwret = GetWord();
        break;
    case VALUETYPE_INT:
        dwret = GetShort();
        break;
    default:
        Assert("Hit default case in GetNumericValueAsSignedInt");
        break;
    }

    return dwret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\value.h ===
#pragma once

enum VALUETYPE
{
    VALUETYPE_UNKNOWN,
    VALUETYPE_INT,
    VALUETYPE_LONG,
    VALUETYPE_WORD,
    VALUETYPE_DWORD,
    VALUETYPE_ENUM,
    VALUETYPE_EDIT,
    VALUETYPE_KONLY
};

#define VALUE_SZMAX     256

#define VALUE_OK            0
#define VALUE_BAD_CHARS     1
#define VALUE_EMPTY         2
#define VALUE_OUTOFRANGE    3

class CValue
{
public:
    CValue();
    ~CValue();
    VOID Init(VALUETYPE type, DWORD value);
    VOID InitNotPresent(VALUETYPE type);
    VOID Destroy();

    BOOL FromString(const WCHAR * const pszValue);
    BOOL ToString(PWSTR psz, UINT cb);

    VOID Copy(CValue *pvSrc);
    int Compare(CValue *v2);

    BOOL FLoadFromRegistry(HKEY hk, const WCHAR * pszValueName, HKEY hkParam = (HKEY)INVALID_HANDLE_VALUE);
    BOOL FSaveToRegistry(HKEY hk, const WCHAR* pszValueName);

    // Value Property accessors
    VOID SetType(VALUETYPE e)
    {
        AssertH(m_fInit);
        m_eType = e;
    }
    VALUETYPE GetType()
    {
        AssertH(m_fInit);
        return m_eType;
    }
    BOOL IsNumeric()
    {
        AssertH(m_fInit);
        return m_fNumeric;
    }
    VOID SetNumeric(BOOL f)
    {
        AssertH(m_fInit);
        m_fNumeric = f;
    }
    BOOL IsHex()
    {
        AssertH(m_fInit);
        return m_fHex;
    }
    VOID SetHex(BOOL f)
    {
        AssertH(m_fInit);
        m_fHex = f;
    }
    BOOL IsPresent()
    {
        AssertH(m_fInit);
        return m_fPresent;
    }
    VOID SetPresent(BOOL f)
    {
        AssertH(m_fInit);
        m_fPresent = f;
    }
    BOOL IsInvalidChars()
    {
        AssertH(m_fInit);
        return m_fInvalidChars;
    }
    VOID SetInvalidChars(BOOL f)
    {
        AssertH(m_fInit);
        m_fInvalidChars = f;
    }
    BOOL IsEmptyString()
    {
        AssertH(m_fInit);
        return m_fEmptyString;
    }
    VOID SetEmptyString(BOOL f)
    {
        AssertH(m_fInit);
        m_fEmptyString = f;
    }

    // Data Accessors
    WORD GetWord()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH (VALUETYPE_WORD == m_eType);
        return m_w;
    }
    VOID SetWord(WORD w)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_WORD == m_eType);
        m_w = w;
    }
    LONG GetLong()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH(VALUETYPE_LONG == m_eType);
        return m_l;
    }
    VOID SetLong(LONG l)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_LONG == m_eType);
        m_l = l;
    }
    short GetShort()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH(VALUETYPE_INT == m_eType);
        return m_n;
    }
    VOID SetShort(short n)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_INT == m_eType);
        m_n = n;
    }
    DWORD GetDword()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH(VALUETYPE_DWORD == m_eType);
        return m_dw;
    }
    VOID SetDword(DWORD dw)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_DWORD == m_eType);
        m_dw = dw;
    }
    int GetNumericValueAsSignedInt();

    DWORD GetNumericValueAsDword();

    VOID SetNumericValue(DWORD dw);
    PWSTR GetPsz()
    {
        AssertH(m_fInit);
        AssertH (m_fPresent);
        AssertH(VALUETYPE_EDIT == m_eType || VALUETYPE_ENUM == m_eType);
        return m_psz;
    }
    VOID SetPsz(PWSTR psz)
    {
        AssertH(m_fInit);
        AssertH(VALUETYPE_EDIT == m_eType || VALUETYPE_ENUM == m_eType);
        m_psz = psz;
    }

private:
    BOOL        m_fInit;
    VALUETYPE   m_eType;
    BOOL        m_fNumeric;
    BOOL        m_fHex;
    BOOL        m_fPresent;
    BOOL        m_fInvalidChars;
    BOOL        m_fEmptyString;
    union {
        DWORD       m_dw;
        LONG        m_l;
        short       m_n;
        WORD        m_w;
        PWSTR       m_psz;
    };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwclicfg\nwclidef.h ===
// Only allow single inclusion of this file.
#pragma once

// Name of the NetWare Config file.
#define NW_CONFIG_DLL_NAME      L"nwcfg.dll"
#define NW_AUTH_PACKAGE_NAME    L"nwprovau"
#define NW_RDR_PERF_DLL_NAME    L"perfnw.dll"
#define NW_RDR_PERF_OPEN        L"OpenNetWarePerformanceData"
#define NW_RDR_PERF_COLLECT     L"CollectNetWarePerformanceData"
#define NW_RDR_PERF_CLOSE       L"CloseNetWarePerformanceData"

// Key values for the NWCWorkstation parameters subkeys
//
#define NW_NWC_PARAM_OPTION_KEY \
    L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\Option"

#define NW_NWC_PARAM_LOGON_KEY  \
    L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters\\Logon"

#define NW_RDR_SERVICE_PERF_KEY \
    L"System\\CurrentControlSet\\Services\\NWRdr\\Performance"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwclicfg\resource.h ===
#include <ncres.h>

#define IDS_PRINT_PROVIDER_NAME         IDS_NC_NWCLICFG + 1
#define IDS_AUTOEXEC_REM1               IDS_NC_NWCLICFG + 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwclicfg\nwcliobj.cpp ===
//
// N W C L I O B J . C P P
//
// Implementation of the CNWClient notify object model
//

#include "pch.h"
#pragma hdrstop
#include "ncerror.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "nwcliobj.h"

#include <ncshell.h>

extern const WCHAR c_szAfNWCWorkstationParameters[];
extern const WCHAR c_szAfNWCWorkstationShares[];
extern const WCHAR c_szAfNWCWorkstationDrives[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_Server[];

//---[ Constants ]-------------------------------------------------------------

static const WCHAR c_szNWClientParamPath[]      = L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Parameters";
static const WCHAR c_szNWClientSharesPath[]     = L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Shares";
static const WCHAR c_szNWClientDrivesPath[]     = L"System\\CurrentControlSet\\Services\\NWCWorkstation\\Drives";
static const WCHAR c_szLMServerParamPath[]      = L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
static const WCHAR c_szLMServerLinkagePath[]    = L"System\\CurrentControlSet\\Services\\LanmanServer\\Linkage";
static const WCHAR c_szEnableSharedNetDrives[]  = L"EnableSharedNetDrives";
static const WCHAR c_szOtherDependencies[]      = L"OtherDependencies";
static const WCHAR c_szGWEnabledValue[]         = L"GatewayEnabled";

extern const WCHAR c_szSvcLmServer[];          // L"LanmanServer";
extern const WCHAR c_szSvcNWCWorkstation[];    // L"NWCWorkstation";

HRESULT HrRefreshEntireNetwork();
HRESULT HrGetEntireNetworkPidl(LPITEMIDLIST *ppidlFolder);


//
// Constructor
//

CNWClient::CNWClient()
{
    // Initialize member variables.
    m_pnc            = NULL;
    m_pncc           = NULL;
    m_eInstallAction = eActUnknown;
    m_hlibConfig     = NULL;
    m_fUpgrade       = FALSE;

    // Get the product flavor (PF_WORKSTATION or PF_SERVER). Use this
    // to decide whether or not we need to install the "server" component.
    //
    GetProductFlavor(NULL, &m_pf);
}

CNWClient::~CNWClient()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);

    // Release KEY handles here.
}


//
// INetCfgNotify
//

STDMETHODIMP CNWClient::Initialize( INetCfgComponent *  pnccItem,
                                    INetCfg*            pnc,
                                    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    TraceTag(ttidNWClientCfg, "CNWClient::Initialize");

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "m_pncc NULL in CNWClient::Initialize");
    AssertSz(m_pnc, "m_pnc NULL in CNWClient::Initialize");

    // Addref the config objects
    //
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrRestoreRegistry
//
//  Purpose:    Restores the contents of the registry for this component
//
//  Arguments:
//      (none)
//
//  Returns:    Win32 error if failed, otherwise S_OK
//
//  Author:     jeffspr   13 Aug 1997
//
//  Notes:
//
HRESULT CNWClient::HrRestoreRegistry()
{
    HRESULT             hr                  = S_OK;
    HKEY                hkey                = NULL;
    TOKEN_PRIVILEGES *  ptpRestore          = NULL;
    DWORD               dwDisp              = 0;
    static const WCHAR c_szSvcDLLName[]     = L"%SystemRoot%\\System32\\nwwks.dll";
    static const WCHAR c_szServiceDll[]     = L"ServiceDll";

    TraceTag(ttidNWClientCfg, "CNWClient::HrRestoreRegistry");

    if (!m_strParamsRestoreFile.empty() ||
        !m_strDrivesRestoreFile.empty() ||
        !m_strSharesRestoreFile.empty())
    {
        hr = HrEnableAllPrivileges(&ptpRestore);
    }

    if (SUCCEEDED(hr) && !m_strParamsRestoreFile.empty())
    {
        // Ensure key is there by creating it
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szNWClientParamPath, 0,
                              KEY_ALL_ACCESS, NULL, &hkey, &dwDisp);
        if (SUCCEEDED(hr))
        {
            hr = HrRegRestoreKey(hkey, m_strParamsRestoreFile.c_str(), 0);
            if (FAILED(hr))
            {
                TraceError("CNWClient::HrRestoreRegistry - HrRestoreRegistry for "
                           "Parameters", hr);
                hr = S_OK;
            }

            //
            // Bug 182442. HrRegRestoreKey above overwrites the ServiceDll value added
            // from the inf file. So, we manually save it.
            //

            hr = HrRegSetValueEx(hkey, c_szServiceDll, REG_EXPAND_SZ,
                                 (const BYTE *)c_szSvcDLLName,
                                 (wcslen(c_szSvcDLLName) + 1) * sizeof(WCHAR));
            if (FAILED(hr))
            {
                TraceError("CNWClient::HrRestoreRegistry - HrRestoreRegistry for "
                        "ServiceDll", hr);
                        hr = S_OK;
            }

            RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    if (!m_strSharesRestoreFile.empty())
    {
        // Ensure key is there by creating it
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szNWClientSharesPath, 0,
                              KEY_ALL_ACCESS, NULL, &hkey, &dwDisp);
        if (SUCCEEDED(hr))
        {
            hr = HrRegRestoreKey(hkey, m_strSharesRestoreFile.c_str(), 0);
            if (FAILED(hr))
            {
                TraceError("CNWClient::HrRestoreRegistry - HrRestoreRegistry for "
                           "Shares", hr);
                hr = S_OK;
            }

            RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    if (!m_strDrivesRestoreFile.empty())
    {
        // Ensure key is there by creating it
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szNWClientDrivesPath, 0,
                              KEY_ALL_ACCESS, NULL, &hkey, &dwDisp);
        if (SUCCEEDED(hr))
        {
            hr = HrRegRestoreKey(hkey, m_strDrivesRestoreFile.c_str(), 0);
            if (FAILED(hr))
            {
                TraceError("CNWClient::HrRestoreRegistry - HrRestoreRegistry for "
                           "Drives", hr);
                hr = S_OK;
            }

            RegCloseKey(hkey);
            hkey = NULL;
        }
    }

    if (ptpRestore)
    {
        hr = HrRestorePrivileges(ptpRestore);

        delete [] reinterpret_cast<BYTE *>(ptpRestore);
    }

    TraceError("CNWClient::HrRestoreRegistry", hr);
    return hr;
}

static const WCHAR c_szDefaultLocation[]        = L"DefaultLocation";
static const WCHAR c_szDefaultScriptOptions[]   = L"DefaultScriptOptions";

HRESULT CNWClient::HrWriteAnswerFileParams()
{
    HRESULT     hr = S_OK;

    TraceTag(ttidNWClientCfg, "CNWClient::HrWriteAnswerFileParams");

    // Don't do anything if we don't have anything to write to the
    // registry
    if (!m_strDefaultLocation.empty() || (m_dwLogonScript != 0xFFFFFFFF))
    {
        HKEY        hkey;
        DWORD       dwDisp;

        // Ensure key is there by creating it
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szNWClientParamPath, 0,
                              KEY_ALL_ACCESS, NULL, &hkey, &dwDisp);
        if (SUCCEEDED(hr))
        {
            if (!m_strDefaultLocation.empty())
            {
                hr = HrRegSetString(hkey, c_szDefaultLocation,
                                    m_strDefaultLocation);
                if (FAILED(hr))
                {
                    TraceError("CNWClient::HrWriteAnswerFileParams - Couldn't"
                               " set DefaultLocation", hr);
                    hr = S_OK;
                }
            }

            if (m_dwLogonScript != 0xFFFFFFFF)
            {
                // 0x3 is combination of the following:
                //
                // #define NW_LOGONSCRIPT_DISABLED          0x00000000
                // #define NW_LOGONSCRIPT_ENABLED           0x00000001
                // #define NW_LOGONSCRIPT_4X_ENABLED        0x00000002
                //
                hr = HrRegSetDword(hkey, c_szDefaultScriptOptions,
                                   m_dwLogonScript ? 0x3 : 0x0);
                if (FAILED(hr))
                {
                    TraceError("CNWClient::HrWriteAnswerFileParams - Couldn't"
                               " set DefaultLocation", hr);
                    hr = S_OK;
                }
            }

            RegCloseKey(hkey);
        }
    }

    TraceError("CNWClient::HrWriteAnswerFileParams", hr);
    return hr;
}

static const WCHAR c_szPreferredServer[]    = L"PreferredServer";
static const WCHAR c_szDefaultTree[]        = L"DefaultTree";
static const WCHAR c_szDefaultContext[]     = L"DefaultContext";
static const WCHAR c_szLogonScript[]        = L"LogonScript";

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrProcessAnswerFile
//
//  Purpose:    Handles necessary processing of contents of the answer file.
//
//  Arguments:
//      pszAnswerFile       [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Comma-separated list of sections in the
//                                  file appropriate to this component.
//
//  Returns:    S_OK if successful, setup API error otherwise.
//
//  Author:     jeffspr   8 May 1997
//
//  Notes:
//
HRESULT CNWClient::HrProcessAnswerFile( PCWSTR pszAnswerFile,
                                        PCWSTR pszAnswerSection)
{
    HRESULT         hr;
    CSetupInfFile   csif;

    TraceTag(ttidNWClientCfg, "CNWClient::HrProcessAnswerFile");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto Exit;
    }

    // Restore portions of the registry based on file names from the answer
    // file

    // Get restore file for "Parameters" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfNWCWorkstationParameters,
                          &m_strParamsRestoreFile);
    if (FAILED(hr))
    {
        TraceError("CNWClient::HrProcessAnswerFile - Error restoring "
                   "Parameters key", hr);

        // oh well, just continue
        hr = S_OK;
    }

    // Get restore file for "Shares" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfNWCWorkstationShares,
                          &m_strSharesRestoreFile);
    if (FAILED(hr))
    {
        TraceError("CNWClient::HrProcessAnswerFile - Error restoring "
                   "Shares key", hr);

        // oh well, just continue
        hr = S_OK;
    }

    // Get restore file for "Drives" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfNWCWorkstationDrives,
                          &m_strDrivesRestoreFile);
    if (FAILED(hr))
    {
        TraceError("CNWClient::HrProcessAnswerFile - Error restoring "
                   "Drives key", hr);

        // oh well, just continue
        hr = S_OK;
    }

    //
    // Read answer file parameters (these are all optional so no errors are
    // saved)
    //

    TraceTag(ttidNWClientCfg, "Reading PreferredServer from answer file");

    // Read contents of PreferredServer key.
    if (FAILED(csif.HrGetString(pszAnswerSection, c_szPreferredServer,
                                &m_strDefaultLocation)))
    {
        // Couldn't read PreferredServer key, so we must assume that the other
        // two values are present
        tstring     strDefaultTree;
        tstring     strDefaultContext;

        TraceTag(ttidNWClientCfg, "PreferredServer not found so trying "
                 "DefaultTree and DefaultContext instead");

        // Read contents of DefaultTree key.
        if (SUCCEEDED(csif.HrGetString(pszAnswerSection, c_szDefaultTree,
                                       &strDefaultTree)))
        {
            TraceTag(ttidNWClientCfg, "Got DefaultTree ok: %S",
                     strDefaultTree.c_str());

            // Read contents of DefaultContext key.
            hr = csif.HrGetString(pszAnswerSection, c_szDefaultContext,
                                  &strDefaultContext);
            if (SUCCEEDED(hr))
            {
                TraceTag(ttidNWClientCfg, "Got DefaultContext ok: %S",
                         strDefaultContext.c_str());

                // Munge the DefaultLocation value with the DefaultTree and
                // DefaultContext values read from the answer file

                m_strDefaultLocation = L"*";
                m_strDefaultLocation += strDefaultTree;
                m_strDefaultLocation += L"\\";
                m_strDefaultLocation += strDefaultContext;

                TraceTag(ttidNWClientCfg, "DefaultLocation is: %S",
                         m_strDefaultLocation.c_str());
            }
            else
            {
                TraceError("CNWClient::HrProcessAnswerFile - error reading "
                           "DefaultContext", hr);
                hr = S_OK;
            }
        }
    }
    else
    {
        TraceTag(ttidNWClientCfg, "DefaultLocation is: %S",
                 m_strDefaultLocation.c_str());
    }

    // Init to impossible value so we know whether we read it or not
    m_dwLogonScript = 0xFFFFFFFF;

    // Read contents of LogonScript key.
    (VOID) csif.HrGetStringAsBool(pszAnswerSection, c_szLogonScript,
                                  reinterpret_cast<BOOL *>(&m_dwLogonScript));

    TraceTag(ttidNWClientCfg, "LogonScript is: %ld", m_dwLogonScript);

Exit:
    TraceError("CNWClient::HrProcessAnswerFile", hr);
    return hr;
}

STDMETHODIMP CNWClient::Upgrade(DWORD dwSetupFlags, DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}

STDMETHODIMP CNWClient::ReadAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile,
                                          pszAnswerSection);

    TraceTag(ttidNWClientCfg, "CNWClient::ReadAnswerFile");

    m_eInstallAction = eActInstall;

    // If we're not already installed, do the work.
    //
    if (pszAnswerFile && pszAnswerSection)
    {
        HRESULT hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
        if (FAILED(hr))
        {
            TraceError("CNWClient::NetworkInstall - Answer file has errors. Defaulting "
                       "all information as if answer file did not exist.",
                       hr);
        }
    }

    return S_OK;
}

STDMETHODIMP CNWClient::Install(DWORD dw)
{
    Validate_INetCfgNotify_Install(dw);

    TraceTag(ttidNWClientCfg, "CNWClient::Install");

    m_eInstallAction = eActInstall;

    // Install the NWLink sub-component
    HRESULT hr = HrInstallComponentOboComponent(m_pnc, NULL,
                                        GUID_DEVCLASS_NETTRANS,
                                        c_szInfId_MS_NWIPX,
                                        m_pncc,
                                        NULL);
    if (SUCCEEDED(hr))
    {
        // If we're NT Server, we DO need to install it, as what we're
        // installing is GSNW, not CSNW (and therefore, since we're sharing
        // resources, we need to use the server service)
        //
        if (PF_SERVER == m_pf)
        {
            NETWORK_INSTALL_PARAMS nip;

            nip.dwSetupFlags = dw;
            nip.dwUpgradeFromBuildNo = -1;
            nip.pszAnswerFile = NULL;
            nip.pszAnswerSection = NULL;

            // Install Server
            hr = HrInstallComponentOboComponent(m_pnc, &nip,
                                                GUID_DEVCLASS_NETSERVICE,
                                                c_szInfId_MS_Server,
                                                m_pncc,
                                                NULL);
        }
    }

    TraceError("CNWClient::Install", hr);
    return hr;
}

STDMETHODIMP CNWClient::Removing()
{
    TraceTag(ttidNWClientCfg, "CNWClient::Removing");

    m_eInstallAction = eActRemove;

    // Remove the NWLink service
    //
    HRESULT hr = HrRemoveComponentOboComponent(m_pnc,
                                       GUID_DEVCLASS_NETTRANS,
                                       c_szInfId_MS_NWIPX,
                                       m_pncc);

    if (SUCCEEDED(hr))
    {
        if (PF_SERVER == m_pf)
        {
            // Remove our reference of the Server service
            //
            hr = HrRemoveComponentOboComponent(m_pnc,
                                               GUID_DEVCLASS_NETSERVICE,
                                               c_szInfId_MS_Server,
                                               m_pncc);
        }
    }

    if (hr == NETCFG_S_STILL_REFERENCED)
    {
        // If services are still in use, that's OK, I just needed to make
        // sure that I released my reference.
        //
        hr = S_OK;
    }

    Validate_INetCfgNotify_Removing_Return(hr);

    TraceError("CNWClient::Removing()", hr);
    return hr;
}

STDMETHODIMP CNWClient::Validate()
{
    return S_OK;
}

STDMETHODIMP CNWClient::CancelChanges()
{
    return S_OK;
}

STDMETHODIMP CNWClient::ApplyRegistryChanges()
{
    HRESULT     hr = S_OK;

    TraceTag(ttidNWClientCfg, "CNWClient::ApplyRegistryChanges");

    if (m_eInstallAction == eActRemove)
    {
        hr = HrRemoveCodeFromOldINF();
    }
    else if (m_eInstallAction == eActInstall)
    {
        hr = HrRestoreRegistry();
        if (FAILED(hr))
        {
            TraceError("CNWClient::ApplyRegistryChanges - HrRestoreRegistry non-fatal error",
                       hr);
            hr = S_OK;
        }

        hr = HrWriteAnswerFileParams();
        if (FAILED(hr))
        {
            TraceError("CNWClient::ApplyRegistryChanges - HrWriteAnswerFileParams "
                       "non-fatal error", hr);
            hr = S_OK;
        }

        // If gateway is enabled, modify lanmanserver appropriately
        // Ignore the return code other than to trace it.
        //
        hr = HrEnableGatewayIfNeeded();
        if (FAILED(hr))
        {
            TraceError("CNWClient::ApplyRegistryChanges - HrEnableGatewayIfNeeded non-fatal error", hr);
        }

        hr = HrInstallCodeFromOldINF();
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CNWClient::ApplyRegistryChanges",
        (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

STDMETHODIMP CNWClient::ApplyPnpChanges (
    INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr;

    hr = HrRefreshEntireNetwork();

    if (FAILED(hr))
    {
        TraceError("CNWClient::ApplyPnpChanges - HrRefreshEntireNetwork"
                   "non-fatal error", hr);
        hr = S_OK;
    }

    // GlennC can't do the work to make NW Client PnP so we're forced to
    // prompt for a reboot for any change.
    //
    return NETCFG_S_REBOOT;
}

// Note -- Don't convert this to a constant. We need copies of it within the
// functions because ParseDisplayName actually mangles the string.
//
#define ENTIRE_NETWORK_PATH   L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}\\EntireNetwork"

//+---------------------------------------------------------------------------
//
//  Function:   HrGetEntireNetworkPidl
//
//  Purpose:    Get the pidl for "Entire Network". Used in places where we're
//              not folder specific, but we still need to update folder
//              entries.
//
//  Arguments:
//      ppidlFolder [out]   Return parameter for the folder pidl
//
//  Returns:
//
//  Author:     anbrad    08 Jun 1999
//              jeffspr   13 Jun 1998
//
//  Notes:
//
HRESULT HrGetEntireNetworkPidl(LPITEMIDLIST *ppidlFolder)
{
    HRESULT         hr          = S_OK;
    LPSHELLFOLDER   pshf        = NULL;
    LPITEMIDLIST    pidlFolder  = NULL;

    Assert(ppidlFolder);

    WCHAR szEntireNetworkPath[] = ENTIRE_NETWORK_PATH;

    // Get the desktop folder, so we can parse the display name and get
    // the UI object of the connections folder
    //
    hr = SHGetDesktopFolder(&pshf);
    if (SUCCEEDED(hr))
    {
        ULONG           chEaten;

        hr = pshf->ParseDisplayName(NULL, 0, (WCHAR *) szEntireNetworkPath,
            &chEaten, &pidlFolder, NULL);

        ReleaseObj(pshf);
    }

    // If succeeded, fill in the return param.
    //
    if (SUCCEEDED(hr))
    {
        *ppidlFolder = pidlFolder;
    }
    else
    {
        // If we failed, then delete the pidl if we already got it.
        //
        if (pidlFolder)
            SHFree(pidlFolder);
    }

    TraceHr(ttidNWClientCfg, FAL, hr, FALSE, "HrGetEntireNetworkPidl");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRefreshEntireNetwork
//
//  Purpose:    Update the "Entire Network" portion of the shell due to
//              the addition of a new networking client (NWClient)
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     anbrad  08  Jun 1999
//
//  Notes:
//
HRESULT HrRefreshEntireNetwork()
{
    HRESULT         hr          = S_OK;
    HCURSOR         hcWait      = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPITEMIDLIST    pidlFolder  = NULL;;

    hr = HrGetEntireNetworkPidl(&pidlFolder);

    // If we now have a pidl, send the GenerateEvent to update the item
    //
    if (SUCCEEDED(hr))
    {
        Assert(pidlFolder);
        // SHCNE_UPDATEDIR?ITEM
        GenerateEvent(SHCNE_UPDATEDIR, pidlFolder, NULL, NULL);
    }

    if (hcWait)
    {
        SetCursor(hcWait);
    }

    if (pidlFolder)
    {
        SHFree(pidlFolder);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrRefreshEntireNetwork");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableGatewayIfNeeded
//
//  Purpose:    Update the Lanman dependencies, if appropriate (meaning if
//              gateway is enabled).
//
//  Arguments:  
//      (none)
//
//  Returns:    
//
//  Author:     jeffspr   19 Aug 1999
//
//  Notes:      
//
HRESULT CNWClient::HrEnableGatewayIfNeeded()
{
    HRESULT         hr      = S_OK;
    HKEY            hKey    = NULL;
    DWORD           dwValue = 0;
    CServiceManager sm;
    CService        svc;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
        c_szNWClientParamPath,
        KEY_READ,  
        &hKey);
    if (FAILED(hr))
    {
        TraceError("Couldn't open NWClient param key", hr);
        goto Exit;
    }

    hr = HrRegQueryDword(hKey, 
        c_szGWEnabledValue,
        &dwValue);
    if (FAILED(hr))
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            TraceError("Couldn't query the GWEnabled Value", hr);
            goto Exit;
        }
        else
        {
            dwValue = 0;
        }
    }
    else
    {
        // Normalize to bool
        //
        dwValue = !!dwValue;
    }

    RegSafeCloseKey(hKey);
    hKey = NULL;

    // If there are gateway services present, then add the dependencies 
    // to LanmanServer
    // 
    if (dwValue > 0)
    {
        // Set the value in the registry for the server paramaters.
        //
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,  
            c_szLMServerParamPath,  
            KEY_WRITE,  
            &hKey);
        if (SUCCEEDED(hr))
        {
            hr = HrRegSetDword(hKey,
                c_szEnableSharedNetDrives,
                dwValue);

            RegSafeCloseKey(hKey);
            hKey = NULL;
        }

        hr = sm.HrOpen();
        if (SUCCEEDED(hr))
        {
            hr = sm.HrOpenService(&svc, c_szSvcLmServer, NO_LOCK);
            if (SUCCEEDED(hr))
            {
                // Add dependency of NWC Workstation to Server
                //
                hr = sm.HrAddServiceDependency(c_szSvcLmServer,
                    c_szSvcNWCWorkstation);

                if (SUCCEEDED(hr))
                {
                    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        c_szLMServerLinkagePath,
                        KEY_READ | KEY_WRITE,
                        &hKey);
                    if (SUCCEEDED(hr))
                    {
                        // Add the "OtherDependencies" to LanmanServer for legacy reasons
                        //
                        hr = HrRegAddStringToMultiSz(c_szSvcNWCWorkstation,
                            hKey,
                            NULL,
                            c_szOtherDependencies,
                            STRING_FLAG_ENSURE_AT_END | STRING_FLAG_DONT_MODIFY_IF_PRESENT,
                            0);

                        RegSafeCloseKey(hKey);
                        hKey = NULL;
                    }
                }
            }
            else
            {
                TraceError("Failed to open LanmanServer service for dependency mods", hr);
            }
        }
        else
        {
            TraceError("Failed to open service control manager", hr);
        }
    }

Exit:
    TraceHr(ttidNWClientCfg, FAL, hr, FALSE, "HrEnableGatewayIfNeeded");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwclicfg\nwcliinf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N W C L I I N F . C P P
//
//  Contents:   NetWare client configuration notify object.
//              Functionality from old INF
//
//  Notes:
//
//  Author:     jeffspr   24 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "lmerr.h"
#include "lmcons.h"
#include "lmserver.h"
#include "ncreg.h"
#include "nwclidef.h"
#include "nwcliobj.h"

extern const WCHAR c_szRegKeyCtlLsa[];

//---[ Constants ]------------------------------------------------------------

const WCHAR c_szConfigDLLName[]         = NW_CONFIG_DLL_NAME;
const WCHAR c_szAuthPackageName[]       = NW_AUTH_PACKAGE_NAME;
const WCHAR c_szParamOptionKeyPath[]    = NW_NWC_PARAM_OPTION_KEY;
const WCHAR c_szParamLogonKeyPath[]     = NW_NWC_PARAM_LOGON_KEY;

const WCHAR c_szNwDocGWHelpName[]       = L"nwdocgw.hlp";
const WCHAR c_szNwDocGWCNTName[]        = L"nwdocgw.cnt";
const WCHAR c_szNwDocHelpName[]         = L"nwdoc.hlp";
const WCHAR c_szNwDocCNTName[]          = L"nwdoc.cnt";

const DWORD c_dwOptionKeyPermissions    = KEY_SET_VALUE | KEY_CREATE_SUB_KEY;

//---[ Prototypes ]-----------------------------------------------------------

// See the function headers for descriptions
//
HRESULT HrAppendNetwareToAuthPackages();
HRESULT HrCreateParametersSubkeys();
HRESULT HrMungeAutoexecNT();
BOOL    FMoveSzToEndOfFile( PSTR pszAutoexecName, PSTR pszMatch);
HRESULT HrAddNetWareToWOWKnownList();
HRESULT HrUpdateLanmanSharedDrivesValue();
HRESULT HrRemoveNetwareFromAuthPackages();
HRESULT HrRemoveNetWareFromWOWKnownList();
HRESULT HrDeleteParametersSubkeys();
HRESULT HrRenameNWDocFiles();



//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrLoadConfigDLL
//
//  Purpose:    Load nwcfg.dll, so we can call some of the functions within.
//              Also, do the GetProcAddress calls for all of the functions
//              that we might need.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT CNWClient::HrLoadConfigDLL()
{
    HRESULT     hr                              = S_OK;

    AssertSz(!m_hlibConfig, "This should not be getting initialized twice");

    TraceTag(ttidNWClientCfgFn, ">> CNWClient::HrLoadConfigDLL");

    m_hlibConfig = LoadLibrary(c_szConfigDLLName);
    if (!m_hlibConfig)
    {
        DWORD dwLastError = GetLastError();

        TraceLastWin32Error("HrLoadConfigDLL() failed");

        // More specific info
        //
        TraceTag(ttidNWClientCfg,
                "HrLoadConfigDLL() - LoadLibrary failed on %S, Err: %d",
                c_szConfigDLLName, dwLastError);

        hr = E_FAIL;
        goto Exit;
    }

    // $$REVIEW: We probably won't need all of these, so make sure that we've
    // cut out the ones that we're no longer using (or have never used).
    //
    m_pfnAppendSzToFile                 = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "AppendSzToFile");
    m_pfnRemoveSzFromFile               = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "RemoveSzFromFile");
    m_pfnGetKernelVersion               = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "GetKernelVersion");
    m_pfnSetEverybodyPermission         = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "SetEverybodyPermission");
    m_pfnlodctr                         = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "lodctr");
    m_pfnunlodctr                       = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "unlodctr");
    m_pfnDeleteGatewayPassword          = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "DeleteGatewayPassword");
    m_pfnSetFileSysChangeValue          = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "SetFileSysChangeValue");
    m_pfnCleanupRegistryForNWCS         = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "CleanupRegistryForNWCS");
    m_pfnSetupRegistryForNWCS           = (NWCFG_PROC) GetProcAddress(m_hlibConfig, "SetupRegistryForNWCS");

    if (!m_pfnAppendSzToFile            || !m_pfnRemoveSzFromFile               ||
        !m_pfnGetKernelVersion          || !m_pfnSetEverybodyPermission         ||
        !m_pfnlodctr                    || !m_pfnunlodctr                       ||
        !m_pfnDeleteGatewayPassword     || !m_pfnSetFileSysChangeValue          ||
        !m_pfnCleanupRegistryForNWCS    || !m_pfnSetupRegistryForNWCS)
    {
        TraceLastWin32Error("HrLoadConfigDLL() - GetProcAddress failed");
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    TraceTag(ttidNWClientCfgFn, "<< CNWClient::HrLoadConfigDLL");
    TraceError("HrLoadConfigDLL", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::FreeConfigDLL
//
//  Purpose:    Free nwcfg.dll, and NULL out the function pointers.
//
//  Arguments:
//      (none)
//
//  Returns:    No return (VOID)
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
VOID CNWClient::FreeConfigDLL()
{
    TraceTag(ttidNWClientCfgFn, ">> CNWClient::FreeConfigDLL()");

    // If we successfully loaded the library, free it.
    if (m_hlibConfig)
    {
        // Free up the library resources.
        FreeLibrary(m_hlibConfig);
        m_hlibConfig = NULL;

        m_pfnAppendSzToFile                 = NULL;
        m_pfnRemoveSzFromFile               = NULL;
        m_pfnGetKernelVersion               = NULL;
        m_pfnSetEverybodyPermission         = NULL;
        m_pfnlodctr                         = NULL;
        m_pfnunlodctr                       = NULL;
        m_pfnDeleteGatewayPassword          = NULL;
        m_pfnSetFileSysChangeValue          = NULL;
        m_pfnCleanupRegistryForNWCS         = NULL;
        m_pfnSetupRegistryForNWCS           = NULL;
    }

    TraceTag(ttidNWClientCfgFn, "<< CNWClient::FreeConfigDLL()");
}

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrInstallCodeFromOldINF
//
//  Purpose:    This contains all of the logic from the old oemnsvnw.inf, or
//              at least calls to helper functions that perform all of the
//              logic. This runs pretty much straight through the old
//              installadapter code.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT CNWClient::HrInstallCodeFromOldINF()
{
    HRESULT hr              = S_OK;
    BOOL    fResult         = FALSE;

    // Get result from NWCFG functions. We won't use it though.
    PWSTR   pszDummy        = NULL;

    TraceTag(ttidNWClientCfgFn, ">> CNWClient::HrInstallCodeFromOldINF()");

    hr = HrLoadConfigDLL();
    if (FAILED(hr))
    {
        // Error traced in the call itself.
        goto Exit;
    }

    // Call the NWCFG function that does (their comment):
    //      "set the FileSysChangeValue to please NETWARE.DRV.
    //       also set win.ini parameter so wfwnet.drv knows we are there."

    fResult = m_pfnSetupRegistryForNWCS(0, NULL, &pszDummy);
    if (!fResult)
    {
        TraceTag(ttidNWClientCfg, "HrInstallCodeFromOldINF() - m_pfnSetupRegistryForNWCS failed");
        goto Exit;
    }

    // Append our name to the Lsa Authentication packages reg value.
    hr = HrAppendNetwareToAuthPackages();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    // Create the required subkeys under the services\NWCWorkstation\parameters
    // key
    //
    hr = HrCreateParametersSubkeys();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    // Munge the autoexec.nt (or autoexec.tmp) file. Pass the function pointers
    // to the munge that will allow it to manipulate the autoexec.nt
    hr = HrMungeAutoexecNT();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    hr = HrAddNetWareToWOWKnownList();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    // If this is the gateway that we're installing, do the work that will
    // allow us to share a redirected resource.
    //
    if (PF_SERVER == m_pf)
    {
        hr = HrUpdateLanmanSharedDrivesValue();
        if (FAILED(hr))
        {
            // Error traced within the function itself.
            //
            goto Exit;
        }

        // On the server build, rename nwdocgw.* to nwdoc.*
        hr = HrRenameNWDocFiles();
        if (FAILED(hr))
        {
            goto Exit;
        }

    }

Exit:
    // This will work even if the handle is NULL.
    FreeConfigDLL();

    TraceTag(ttidNWClientCfgFn, "<< CNWClient::HrInstallCodeFromOldINF()");
    TraceError("CNWClient::HrInstallCodeFromOldINF()", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNWClient::HrRemoveCodeFromOldINF
//
//  Purpose:    This contains all of the remove logic from the old
//              oemnsvnw.inf, or at least calls to helper functions that
//              perform all of the logic. This runs pretty much straight
//              through the old removeadapter code.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT CNWClient::HrRemoveCodeFromOldINF()
{
    HRESULT hr              = S_OK;
    BOOL    fResult         = FALSE;

    // Get result from NWCFG functions. We won't use it though.
    PWSTR   pszDummy        = NULL;

    TraceTag(ttidNWClientCfgFn, ">> CNWClient::HrRemoveCodeFromOldINF()");

    hr = HrLoadConfigDLL();
    if (FAILED(hr))
    {
        // Error traced in the call itself.
        goto Exit;
    }

    // Call the NWCFG function that does (their comment):
    //      "set the FileSysChangeValue to please NETWARE.DRV.
    //       also set win.ini parameter so wfwnet.drv knows we are there."

    fResult = m_pfnCleanupRegistryForNWCS(0, NULL, &pszDummy);
    if (!fResult)
    {
        TraceTag(ttidNWClientCfg, "HrRemoveCodeFromOldINF() - m_pfnCleanupRegistryForNWCS failed");
        goto Exit;
    }

    // Remove our name from the Lsa Authentication packages reg value.
    hr = HrRemoveNetwareFromAuthPackages();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    // Delete the NWC subkeys under the services\NWCWorkstation\parameters
    // key
    //
    hr = HrDeleteParametersSubkeys();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

    hr = HrRemoveNetWareFromWOWKnownList();
    if (FAILED(hr))
    {
        // Error traced within the function itself.
        //
        goto Exit;
    }

Exit:
    // This will work even if the handle is NULL.
    FreeConfigDLL();

    TraceTag(ttidNWClientCfgFn, "<< CNWClient::HrRemoveCodeFromOldINF()");
    TraceError("CNWClient::HrRemoveCodeFromOldINF()", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrAppendNetwareToAuthPackages
//
//  Purpose:    Helper function for HrCodeFromOldINF() - Appends the netware
//              authentication provider name to the end of the LSA
//              authentication packages value.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 Error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrAppendNetwareToAuthPackages()
{
    HRESULT     hr              = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrAppendNetwareToAuthPackages");

    // Call the cool new AddString... function
    //
    hr = HrRegAddStringToMultiSz(
            (PWSTR) c_szAuthPackageName,
            HKEY_LOCAL_MACHINE,
            c_szRegKeyCtlLsa,
            L"Authentication Packages",
            STRING_FLAG_ENSURE_AT_END,
            0);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrAppendNetwareToAuthPackages() - Failed to "
                 "Add string to multi-sz 'Authentication Packages' in key: %S",
                 c_szRegKeyCtlLsa);
        goto Exit;

    }

Exit:
    TraceTag(ttidNWClientCfgFn, "<< HrAppendNetwareToAuthPackages");
    TraceError("HrAppendNetwareToAuthPackages", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveNetwareFromAuthPackages
//
//  Purpose:    Helper function for HrCodeFromOldINF() - Appends the netware
//              authentication provider name to the end of the LSA
//              authentication packages value.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 Error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrRemoveNetwareFromAuthPackages()
{
    HRESULT     hr              = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrRemoveNetwareFromAuthPackages");

    // Call the cool new AddString... function
    //
    hr = HrRegRemoveStringFromMultiSz(
            (PWSTR) c_szAuthPackageName,
            HKEY_LOCAL_MACHINE,
            c_szRegKeyCtlLsa,
            L"Authentication Packages",
            STRING_FLAG_REMOVE_ALL);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrRemoveNetwareFromAuthPackages() - Failed to "
                 "Remove string to multi-sz 'Authentication Packages' in key: %S",
                 c_szRegKeyCtlLsa);
        goto Exit;

    }

Exit:
    TraceTag(ttidNWClientCfgFn, "<< HrRemoveNetwareFromAuthPackages");
    TraceError("HrRemoveNetwareFromAuthPackages", hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrNwLibSetEverybodyPermission
//
//  Purpose:    Set the registry key to everybody "Set Value" (or whatever
//              the caller want.)
//
//  Arguments:
//      hKey         [] The handle of the registry key to set security on
//      dwPermission [] The permission to add to "everybody"
//
//  Returns:
//
//  Author:     jeffspr   18 Jun 1997
//
//  Notes:
//
HRESULT HrNwLibSetEverybodyPermission(  IN HKEY     hKey,
                                        IN DWORD    dwPermission)
{
    LONG err;                           // error code
    PSECURITY_DESCRIPTOR psd = NULL;    // related SD
    PSID pSid = NULL;                   // original SID
    PACL pDacl = NULL;                  // Absolute DACL
    PACL pSacl = NULL;                  // Absolute SACL
    PSID pOSid = NULL;                  // Absolute Owner SID
    PSID pPSid = NULL;                  // Absolute Primary SID

    do {  // Not a loop, just for breaking out of error
        //
        // Initialize all the variables...
        //
                                                        // world sid authority
        SID_IDENTIFIER_AUTHORITY SidAuth= SECURITY_WORLD_SID_AUTHORITY;
        DWORD cbSize=0;                                 // Security key size
        PACL pAcl;                                      // original ACL
        BOOL fDaclPresent;
        BOOL fDaclDefault;
        SECURITY_DESCRIPTOR absSD;                      // Absolute SD
        DWORD AbsSize = sizeof(SECURITY_DESCRIPTOR);    // Absolute SD size
        DWORD DaclSize;                                 // Absolute DACL size
        DWORD SaclSize;                                 // Absolute SACL size
        DWORD OSidSize;                                 // Absolute OSID size
        DWORD PSidSize;                                 // Absolute PSID size

        // Get the original DACL list

        RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION, NULL, &cbSize);

        psd = (PSECURITY_DESCRIPTOR *)LocalAlloc(LMEM_ZEROINIT, cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID));
        pDacl = (PACL)LocalAlloc(LMEM_ZEROINIT, cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID));
        pSacl = (PACL)LocalAlloc(LMEM_ZEROINIT, cbSize);
        pOSid = (PSID)LocalAlloc(LMEM_ZEROINIT, cbSize);
        pPSid = (PSID)LocalAlloc(LMEM_ZEROINIT, cbSize);
        DaclSize = cbSize+sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID);
        SaclSize = cbSize;
        OSidSize = cbSize;
        PSidSize = cbSize;

        if (( NULL == psd) ||
            ( NULL == pDacl) ||
            ( NULL == pSacl) ||
            ( NULL == pOSid) ||
            ( NULL == pPSid))
        {
            err = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        if ( (err = RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION, psd, &cbSize )) != ERROR_SUCCESS )
        {
            break;
        }
        if ( !GetSecurityDescriptorDacl( psd, &fDaclPresent, &pAcl, &fDaclDefault ))
        {
            err = GetLastError();
            break;
        }

        // Increase the size for an extra ACE

        pAcl->AclSize += sizeof(ACCESS_ALLOWED_ACE)+sizeof(ACCESS_MASK)+sizeof(SID);

        // Get World SID

        if ( (err = RtlAllocateAndInitializeSid( &SidAuth, 1,
              SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSid)) != ERROR_SUCCESS)
        {
            break;
        }

        // Add Permission ACE

        if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, dwPermission ,pSid))
        {
            err = GetLastError();
            break;
        }

        // Convert from relate format to absolute format

        if ( !MakeAbsoluteSD( psd, &absSD, &AbsSize, pDacl, &DaclSize, pSacl, &SaclSize,
                        pOSid, &OSidSize, pPSid, &PSidSize ))
        {
            err = GetLastError();
            break;
        }

        // Set SD

        if ( !SetSecurityDescriptorDacl( &absSD, TRUE, pAcl, FALSE ))
        {
            err = GetLastError();
            break;
        }
        if ( (err = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, psd ))
              != ERROR_SUCCESS )
        {
            break;
        }

    } while (FALSE);

    // Clean up the memory

    RtlFreeSid( pSid );
    LocalFree( psd );
    LocalFree( pDacl );
    LocalFree( pSacl );
    LocalFree( pOSid );
    LocalFree( pPSid );

    return (HRESULT_FROM_WIN32(err));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetEverybodyPermissionsOnOptionsKeys
//
//  Purpose:    Recurse through the options keys (if any), and set the
//              "Everybody" permissions on them.
//
//  Arguments:
//      hkeyOptions   []
//      dwPermissions []
//
//  Returns:
//
//  Author:     jeffspr   10 Sep 1997
//
//  Notes:
//
HRESULT HrSetEverybodyPermissionsOnOptionsKeys(HKEY hkeyOptions, DWORD dwPermissions)
{
    HRESULT     hr      = S_OK;
    DWORD       dwIndex = 0;
    WCHAR       szSubkeyName[MAX_PATH+1];
    FILETIME    ft;

    Assert(hkeyOptions);

    // First, do it on the root key.
    //
    hr = HrNwLibSetEverybodyPermission(hkeyOptions, dwPermissions);

    // Enumerate the keys, and set it on them as well
    //
    while (SUCCEEDED(hr))
    {
        DWORD dwSubkeyNameSize  = MAX_PATH+1;

        // Get the next key (starting with 0)
        //
        hr = HrRegEnumKeyEx(    hkeyOptions,
                                dwIndex++,
                                szSubkeyName,
                                &dwSubkeyNameSize,
                                NULL,
                                NULL,
                                &ft);
        if (SUCCEEDED(hr))
        {
            HKEY hkeyUser   = NULL;

            // Open that key for write
            hr = HrRegOpenKeyEx(hkeyOptions,
                                szSubkeyName,
                                KEY_ALL_ACCESS,
                                &hkeyUser);

            if (SUCCEEDED(hr))
            {
                hr = HrNwLibSetEverybodyPermission(hkeyUser, dwPermissions);
            }

            RegSafeCloseKey(hkeyUser);
        }
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
    {
        hr = S_OK;
    }

    TraceError("HrSetEverybodyPermissionsOnOptionsKeys", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateParametersSubkeys
//
//  Purpose:    Creates the subkeys under the NWCWorkstation parameters key.
//              This could have been done in the INF, but there were some
//              permissions that needed to be set on the keys as well, so
//              all of the work now takes place in this function.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrCreateParametersSubkeys()
{
    HRESULT     hr                  = S_OK;
    HKEY        hkeyOption          = NULL;
    HKEY        hkeyLogon           = NULL;
    DWORD       dwDisposition       = 0;

    TraceTag(ttidNWClientCfgFn, ">> HrCreateParametersSubkeys");

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
            c_szParamOptionKeyPath,
            0,
            KEY_ALL_ACCESS,
            NULL,
            &hkeyOption,
            &dwDisposition);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrCreateParametersSubkeys() - failed to "
                 "create/open key %S", c_szParamOptionKeyPath);
        goto Exit;
    }

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
            c_szParamLogonKeyPath,
            0,
            KEY_SET_VALUE,
            NULL,
            &hkeyLogon,
            &dwDisposition);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrCreateParametersSubkeys() - failed to "
                 "create/open key %S", c_szParamLogonKeyPath);
        goto Exit;
    }

    hr = HrSetEverybodyPermissionsOnOptionsKeys(hkeyOption, c_dwOptionKeyPermissions);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrSetEverybodyPermissionsOnOptionsKeys failed, hr: 0x%08x", hr);
        goto Exit;
    }

Exit:
    // Close the hkeys, if they're open
    RegSafeCloseKey(hkeyLogon);
    RegSafeCloseKey(hkeyOption);

    TraceTag(ttidNWClientCfgFn, ">> HrCreateParametersSubkeys");
    TraceError("HrCreateParametersSubkeys", hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrDeleteParametersSubkeys
//
//  Purpose:    Deletes the subkeys under the NWCWorkstation parameters key.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrDeleteParametersSubkeys()
{
    HRESULT     hr                  = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrDeleteParametersSubkeys");

    // Note: We need to be taking ownership of these keys so we can delete
    // them. Regardless, ignore if the key deletions fail.

    hr = HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE,
            c_szParamOptionKeyPath);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrDeleteParametersSubkeys() - failed to "
                 "delete key %S, hr = 0x%08x", c_szParamOptionKeyPath, hr);
        hr = S_OK;
    }

    hr = HrRegDeleteKey(HKEY_LOCAL_MACHINE,
            c_szParamLogonKeyPath);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfg, "HrDeleteParametersSubkeys() - failed to "
                 "delete key %S, hr = 0x%08x", c_szParamLogonKeyPath, hr);
        hr = S_OK;
    }

    TraceTag(ttidNWClientCfgFn, ">> HrDeleteParametersSubkeys");
    TraceError("HrDeleteParametersSubkeys", hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FCheckForExistingFile
//
//  Purpose:    Checks for the existance of the passed in file. Should be
//              common-ized.
//
//  Arguments:
//      pszFileToCheck [] The file name to verify
//
//  Returns:    TRUE if the file was found, FALSE otherwise.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:      $$TODO: Should be improved if we move this to common code.
//              The thing that it doesn't do is distinguish between a file
//              being "not found" and a file error (such as access rights
//              or sharing violations) on the CreateFile call.
//
BOOL FCheckForExistingFile( PSTR pszFileToCheck )
{
    BOOL    fReturn = TRUE;
    HANDLE  hFile   = NULL;

    TraceTag(ttidNWClientCfgFn, ">> FCheckForExistingFile");

    hFile = CreateFileA(pszFileToCheck,
                        GENERIC_READ,
                        0,              // No sharing allowed
                        NULL,           // No security attributes
                        OPEN_EXISTING,  // Fail if file doesn't exist
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
        hFile = NULL;
    }
    else
    {
        // This was previously a bug. We weren't setting FALSE here, which made
        // the function somewhat useless.
        fReturn = FALSE;
    }

    TraceTag(ttidNWClientCfgFn, "<< FCheckForExistingFile");

    return fReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   KillTrailingWhitespace
//
//  Purpose:    Remove whitespace from a non-UNICODE string. This is a utility
//              function for the autoexec.nt parser
//
//  Arguments:
//      pszKillMyWhitespace [] String from which to remove whitespace
//
//  Returns:
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
VOID KillTrailingWhitespace( PSTR pszKillMyWhitespace )
{
    long lLength = 0;

    if (!pszKillMyWhitespace)
    {
        Assert(pszKillMyWhitespace);
        goto Exit;
    }

    lLength = lstrlenA(pszKillMyWhitespace);
    if (lLength == 0)
    {
        goto Exit;
    }

    while (isspace(pszKillMyWhitespace[lLength-1]))
    {
        pszKillMyWhitespace[--lLength] = '\0';
    }

Exit:
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   FMoveSzToEndOfFile
//
//  Purpose:    Find a string in the file of this name, and if it's present,
//              move the string to the end of the file. This is used by the
//              autoexec.nt parser to move the IPX stuff to the end of the
//              file. This is a rewrite of similar code in the nwcfg.dll
//              stuff. That code apparently wasn't UNICODE, and didn't work
//              for what we were doing.
//
//  Arguments:
//      pszAutoexecName [] Name of the file to modify
//      pszMatch        [] String to move
//
//  Returns:
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
BOOL FMoveSzToEndOfFile( PSTR pszAutoexecName, PSTR pszMatch )
{
    FILE *  hsrcfile        = NULL;
    FILE *  hdesfile        = NULL;
    char *  pszTempname     = NULL;
    char    szInput[1000];

    TraceTag(ttidNWClientCfgFn, ">> FMoveSzToEndOfFile");

    // Get a temp name
    //
    pszTempname = tmpnam(NULL);

    // Open the original and the destination files
    //
    hsrcfile = fopen(pszAutoexecName, "r");
    hdesfile = fopen(pszTempname, "w");

    if (( hsrcfile != NULL ) && ( hdesfile != NULL ))
    {
        while (fgets(szInput,1000,hsrcfile))
        {
            CHAR    szInputCopy[1000];

            // Copy to another temp buffer so that when we remove the
            // trailing whitespace for the comparison, we won't lose the
            // original text.
            //
            strcpy(szInputCopy, szInput);

            // Remove the trailing whitespace, so we only have to compare the
            // real text
            //
            KillTrailingWhitespace(szInputCopy);

            // Compare the strings
            //
            if (lstrcmpiA(szInputCopy, pszMatch) != 0)
            {
                // If the strings weren't identical, then we still want
                // to copy the line
                //
                fputs(szInput,hdesfile);
            }
        }

        // Append the string to the end of the file.
        fputs(pszMatch, hdesfile);
        fputs("\r\n",hdesfile);
    }

    if (hsrcfile != NULL)
    {
        fclose(hsrcfile);
    }

    if (hdesfile != NULL)
    {
        fclose(hdesfile);
    }

    if (( hsrcfile != NULL ) && ( hdesfile != NULL ))
    {
        CopyFileA(pszTempname,pszAutoexecName, FALSE);
        DeleteFileA(pszTempname);
    }

    TraceTag(ttidNWClientCfgFn, "<< FMoveSzToEndOfFile");

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMungeAutoexecNT
//
//  Purpose:    Move the IPX stuff to the end of the autoexec.nt. Do this by
//              calling FMoveSzToEndOfFile on each of our lines.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrMungeAutoexecNT()
{
    HRESULT     hr                              = S_OK;
    CHAR        szAutoNTPath[MAX_PATH+1]        = {0};
    CHAR        szAutoTmpPath[MAX_PATH+1]       = {0};
    CHAR        szWindowsDirANSI[MAX_PATH+1]    = {0};
    PSTR       pszAutoPath                     = NULL;
    BOOL        fResult                         = FALSE;
    PCWSTR      pszRem1                         = NULL;
    PSTR        pszaRem1MultiByte                = NULL;
    int         iLength                         = 0;

    TraceTag(ttidNWClientCfgFn, ">> HrMungeAutoexecNT");

    // Get the windows directory
    if (GetSystemWindowsDirectoryA(szWindowsDirANSI, sizeof(szWindowsDirANSI)) == 0)
    {
        TraceLastWin32Error("HrMungeAutoexecNT - Call to GetWindowsDirectoryA");
        hr = HrFromLastWin32Error();
        goto Exit;
    }

    // Build the path to the autoexec.nt
    //
    wsprintfA(szAutoNTPath, "%s\\system32\\%s", szWindowsDirANSI, "autoexec.nt");
    if (FCheckForExistingFile(szAutoNTPath) == FALSE)
    {
        wsprintfA(szAutoTmpPath, "%s\\system32\\%s", szWindowsDirANSI, "autoexec.tmp");
        if (FCheckForExistingFile(szAutoTmpPath) == FALSE)
        {
            // Per the old INF, skip the whole shebang.
            goto Exit;
        }
        else
        {
            pszAutoPath = szAutoTmpPath;
        }
    }
    else
    {
        pszAutoPath = szAutoNTPath;
    }

    // At this point, we should have found at least one valid
    // autoexec.nt or .tmp file. If not, we should have dropped out of the
    // function

    Assert(pszAutoPath);

    pszRem1 = SzLoadStringPcch(_Module.GetResourceInstance(), IDS_AUTOEXEC_REM1, &iLength);
    if (!pszRem1 || iLength == 0)
    {
        AssertSz(FALSE, "Failed to load STR_AUTOEXEC_REM from the resources");

        TraceTag(ttidNWClientCfg,
                "ERROR: Failed to load STR_AUTOEXEC_REM from the resources");

        hr = E_FAIL;
        goto Exit;
    }

    // Allocate memory for the demoted string.
    pszaRem1MultiByte = (PSTR) MemAlloc(lstrlenW(pszRem1) + 1);
    if (!pszaRem1MultiByte)
    {
        TraceTag(ttidNWClientCfg, "ERROR: Failed to alloc memory for demoted string");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // Demote the loaded string to multibyte (single char)
    WideCharToMultiByte(
        CP_ACP,                     // ANSI code page
        0,                          // flags for non-mapped character action
        pszRem1,                    // source string
        -1,                         // source string is NULL terminated
        pszaRem1MultiByte,           // destination string (multibyte)
        lstrlenW(pszRem1) + 1,       // size of destination string
        NULL,                       // default char on non-mapped char
        NULL);                      // return for default char mapping action

    // Move the REM from the autoexec.nt
    //
    fResult = FMoveSzToEndOfFile(pszAutoPath, pszaRem1MultiByte);
    if (!fResult)
    {
        // Traced in called function.
        hr = E_FAIL;
        goto Exit;
    }

    // Move the line that loads nw16
    //
    fResult = FMoveSzToEndOfFile(pszAutoPath, "lh %SystemRoot%\\system32\\nw16");
    if (!fResult)
    {
        // Traced in called function.
        hr = E_FAIL;
        goto Exit;
    }

    // Move the line that loads vwipxspx
    //
    fResult = FMoveSzToEndOfFile(pszAutoPath, "lh %SystemRoot%\\system32\\vwipxspx");
    if (!fResult)
    {
        // Traced in called function.
        hr = E_FAIL;
        goto Exit;
    }

Exit:
    MemFree(pszaRem1MultiByte);

    TraceTag(ttidNWClientCfgFn, "<< HrMungeAutoexecNT");
    TraceError("HrMungeAutoexecNT", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddNetWareToWOWKnownList
//
//  Purpose:    Add the netware.drv to the WOW "known DLLS" list.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrAddNetWareToWOWKnownList()
{
    HRESULT     hr              = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrAddNetWareToWOWKnownList");

    // Call the cool new AddString... function
    //
    hr = HrRegAddStringToSz(
            L"netware.drv",
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\WOW",
            L"KnownDLLS",
            L' ',
            STRING_FLAG_ENSURE_AT_END,
            0);

    TraceTag(ttidNWClientCfgFn, "<< HrAddNetWareToWOWKnownList");
    TraceError("HrAddNetWareToWOWKnownList", hr);

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveNetWareFromWOWKnownList
//
//  Purpose:    Add the netware.drv to the WOW "known DLLS" list.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrRemoveNetWareFromWOWKnownList()
{
    HRESULT     hr              = S_OK;

    TraceTag(ttidNWClientCfgFn, ">> HrRemoveNetWareFromWOWKnownList");

    // Call the cool new AddString... function
    //
    hr = HrRegRemoveStringFromSz(
            L"netware.drv",
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\WOW",
            L"KnownDLLS",
            L' ',
            STRING_FLAG_REMOVE_SINGLE);

    TraceTag(ttidNWClientCfgFn, "<< HrRemoveNetWareFromWOWKnownList");
    TraceError("HrRemoveNetWareFromWOWKnownList", hr);

    return hr;

}


//+---------------------------------------------------------------------------
//
//  Function:   HrUpdateLanmanSharedDrivesValue
//
//  Purpose:    If the LanmanServer service exists, make sure that they have the
//              EnableSharedNetDrives value turned on.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or valid Win32 error code.
//
//  Author:     jeffspr   24 Jun 1997
//
//  Notes:
//
HRESULT HrUpdateLanmanSharedDrivesValue()
{
    HRESULT             hr              = S_OK;
    const DWORD         c_dwESNDValue   = 1;
    HKEY                hkeyLMSP        = NULL;
    SERVER_INFO_1540    si1540          = {0};
    NET_API_STATUS      nas             = ERROR_SUCCESS;
    DWORD               dwDisposition   = 0;

    TraceTag(ttidNWClientCfgFn, ">> HrUpdateLanmanSharedDrivesValue");

    // Open the LanmanServer parameters key, if it exists. If it doesn't exist,
    // it will still return S_OK, but the hkey will still be NULL.
    //
    hr = HrRegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters",
            REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE,    // samDesired
            NULL,
            &hkeyLMSP,
            &dwDisposition);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfgFn, "Failed to create/open the "
                 "LanmanServer\\Parameters key");
        goto Exit;
    }

    Assert(hkeyLMSP);

    hr = HrRegSetDword(
            hkeyLMSP,
            L"EnableSharedNetDrives",
            c_dwESNDValue);
    if (FAILED(hr))
    {
        TraceTag(ttidNWClientCfgFn, "Failed to set the EnabledSharedNetDrives value in "
                 "HrUpdateLanmanSharedDrivesValue()");
        goto Exit;
    }

    // Call the NetServerSetInfo with the Enable Shared Net Drives info (1540).
    // This will allow this info to be set dynamically (so as not to require a
    // restart of the "Server" service.
    //
    si1540.sv1540_enablesharednetdrives = TRUE;

    // Set the server info for the EnableSharedDrives value. This will cause it to
    // take effect if the service is running (and will do nothing if it is not).
    //
    nas = NetServerSetInfo(NULL, 1540, (LPBYTE) &si1540, NULL);
    if (nas != NERR_Success)
    {
        // It's actually OK if this fails in one condition (0x842), because
        // it WILL fail if the server service That's not a problem, because
        // the value that I set in the registry above will be picked up the
        // next time the server service starts.
        //
        // OK, cheesy, but I don't know the define, I just know that this is the
        // right return code for our ignorable failure.
        //
        if (nas != 0x842)
        {
            AssertSz(nas == 0x842, "NetServerSetInfo failed for a reason other "
                   "than the service not running (which would have been ok)");
        }
    }

Exit:
    // Close the hkey, if it's open
    RegSafeCloseKey(hkeyLMSP);

    TraceTag(ttidNWClientCfgFn, "<< HrUpdateLanmanSharedDrivesValue");
    TraceError("HrUpdateLanmanSharedDrivesValue()", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRenameNWDocFiles
//
//  Purpose:    On the server install, rename the nwdocgw.* files, since
//              whether we're on CSNW or GSNW, the files are always called
//              nwdoc.*
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   13 Jul 1997
//
//  Notes:
//
HRESULT HrRenameNWDocFiles()
{
    HRESULT hr                          = S_OK;
    WCHAR   szWindowsDir[MAX_PATH+1];
    WCHAR   szSourceName[MAX_PATH+1];
    WCHAR   szTargetName[MAX_PATH+1];

    // Get the windows directory
    if (GetSystemWindowsDirectory(szWindowsDir, MAX_PATH) == 0)
    {
        TraceLastWin32Error("HrRenameNWDocFiles - Call to GetSystemWindowsDirectory");
        hr = HrFromLastWin32Error();
        goto Exit;
    }

    // Build the path for the first rename
    //
    wsprintfW(szSourceName, L"%s\\system32\\%s", szWindowsDir, c_szNwDocGWHelpName);
    wsprintfW(szTargetName, L"%s\\system32\\%s", szWindowsDir, c_szNwDocHelpName);

    // Rename the .HLP file. If this fails, no big deal.
    //
    if (!MoveFileEx(szSourceName, szTargetName, MOVEFILE_REPLACE_EXISTING))
    {
        // For debugging only.
        //
        DWORD dwLastError = GetLastError();
    }

    // Build the path for the second rename
    //
    wsprintfW(szSourceName, L"%s\\system32\\%s", szWindowsDir, c_szNwDocGWCNTName);
    wsprintfW(szTargetName, L"%s\\system32\\%s", szWindowsDir, c_szNwDocCNTName);

    // Rename the .CNT file. If this fails, no big deal.
    //
    if (!MoveFileEx(szSourceName, szTargetName, MOVEFILE_REPLACE_EXISTING))
    {
        // For debugging only.
        //
        DWORD dwLastError = GetLastError();
    }

Exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwclicfg\nwcliobj.h ===
//
// N W C L I O B J . H
//
// Declaration of CNWClient and helper functions
//

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "ncmisc.h"
#include "resource.h"

// Typedefs for the functions that we'll GetProcAddress from the
// NetWare config DLL
typedef BOOL (PASCAL *NWCFG_PROC)(DWORD, PWSTR [], PWSTR *);


/////////////////////////////////////////////////////////////////////////////
// NWClient

class ATL_NO_VTABLE CNWClient :
    public CComObjectRoot,
    public CComCoClass<CNWClient, &CLSID_CNWClient>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
public:
    CNWClient();
    ~CNWClient();
    BEGIN_COM_MAP(CNWClient)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNWClient)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NWCLICFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags, DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

public:
    // Helper functions.
    HRESULT HrInstallCodeFromOldINF();
    HRESULT HrRemoveCodeFromOldINF();

    // Load and free the config DLL
    HRESULT HrLoadConfigDLL();
    VOID    FreeConfigDLL();

// Private state info
private:
    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};

    INSTALLACTION       m_eInstallAction;
    INetCfgComponent *  m_pncc;             // Place to keep my component
    INetCfg *           m_pnc;              // Place to keep my component
    HINSTANCE           m_hlibConfig;       // From LoadLibrary call.
    PRODUCT_FLAVOR      m_pf;               // Server/Workstation
    BOOL                m_fUpgrade;         // TRUE if we are upgrading with
                                            // an answer file

    tstring             m_strParamsRestoreFile;
    tstring             m_strSharesRestoreFile;
    tstring             m_strDrivesRestoreFile;
    DWORD               m_dwLogonScript;
    tstring             m_strDefaultLocation;

    // These functions below are initialized in the HrLoadConfigDLL() call,
    // which does a GetProcAddress on the appropriate function in nwcfg.dll
    // Note: "Provider" is spelled incorrectly, since it's spelled that way
    // in the config DLL itself, and that's the name that we're using in
    // the GetProcAddress call.

    NWCFG_PROC          m_pfnAddNetwarePrinterProvider;
    NWCFG_PROC          m_pfnDeleteNetwarePrinterProvider;
    NWCFG_PROC          m_pfnAppendSzToFile;
    NWCFG_PROC          m_pfnRemoveSzFromFile;
    NWCFG_PROC          m_pfnGetKernelVersion;
    NWCFG_PROC          m_pfnSetEverybodyPermission;
    NWCFG_PROC          m_pfnlodctr;
    NWCFG_PROC          m_pfnunlodctr;
    NWCFG_PROC          m_pfnDeleteGatewayPassword;
    NWCFG_PROC          m_pfnSetFileSysChangeValue;
    NWCFG_PROC          m_pfnCleanupRegistryForNWCS;
    NWCFG_PROC          m_pfnSetupRegistryForNWCS;

    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection);
    HRESULT HrRestoreRegistry(VOID);
    HRESULT HrWriteAnswerFileParams(VOID);
    HRESULT HrEnableGatewayIfNeeded(VOID);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\nwlnkdlg.cpp ===
// nwlnkipx.cpp : Implementation of CNwlnkIPX

#include "pch.h"
#pragma hdrstop
#include "nwlnkipx.h"
#include "ncatlui.h"
#include "ncui.h"

extern const WCHAR c_szNetCfgHelpFile[];
extern const WCHAR c_sz8Zeros[];

static const FRAME_TYPE aFDDI_Frames[] = {{IDS_AUTO, AUTO},
                                          {IDS_FDDI, F802_2},
                                          {IDS_FDDI_SNAP, SNAP},
                                          {IDS_FDDI_802_3, F802_3},
                                          {0,0}
                                         };
static const FRAME_TYPE aTOKEN_Frames[] = {{IDS_AUTO, AUTO},
                                           {IDS_TK, F802_2},
                                           {IDS_802_5, SNAP},
                                           {0,0}
                                          };
static const FRAME_TYPE aARCNET_Frames[] = {
                                            {IDS_AUTO, AUTO},
                                            {IDS_ARCNET, ARCNET},
                                            {0,0}
                                           };
static const FRAME_TYPE aEthernet_Frames[] = {
                                              {IDS_AUTO, AUTO},
                                              {IDS_ETHERNET, ETHERNET},
                                              {IDS_802_2, F802_2},
                                              {IDS_802_3, F802_3},
                                              {IDS_SNAP, SNAP},
                                              {0,0}
                                             };

static const MEDIA_TYPE MediaMap[] = {{FDDI_MEDIA, aFDDI_Frames},
                                      {TOKEN_MEDIA, aTOKEN_Frames},
                                      {ARCNET_MEDIA, aARCNET_Frames},
                                      {ETHERNET_MEDIA, aEthernet_Frames}
                                     };

//+---------------------------------------------------------------------------
//
//  Member:     EditSubclassProc
//
//  Purpose:    Subclass proc for network number edit controls.  The
//              subclassing forces only correct input
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
STDAPI EditSubclassProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    WNDPROC pIpxEditProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

     // Allow copy/paste keys (CTRL)
    if ((!(GetKeyState(VK_CONTROL) & 0x8000)) &&
        (wMsg == WM_CHAR)) 
    {
        // Check for invalid hex characters
        if (!(((WCHAR)wParam >= L'0' && (WCHAR)wParam <= L'9') ||
              ((WCHAR)wParam >= L'a' && (WCHAR)wParam <= L'f') ||
              ((WCHAR)wParam >= L'A' && (WCHAR)wParam <= L'F') ||
              ((WCHAR)wParam == VK_BACK)))
        {
            // Not allowed
            MessageBeep(MB_ICONEXCLAMATION);
            return 0L;
        }
    }

    return (HRESULT)CallWindowProc( pIpxEditProc, hwnd, wMsg, wParam, lParam );
}

LRESULT CommonIPXOnContextMenu(HWND hWnd, const DWORD * padwHelpIDs)
{
    Assert(padwHelpIDs);

    WinHelp(hWnd,
        c_szNetCfgHelpFile,
        HELP_CONTEXTMENU,
        (ULONG_PTR)padwHelpIDs);

    return 0;
}

LRESULT CommonIPXOnHelp(LPARAM lParam, const DWORD * padwHelpIDs)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);
    Assert(padwHelpIDs);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        if (padwHelpIDs != NULL)
        {
            WinHelp(static_cast<HWND>(lphi->hItemHandle),
                    c_szNetCfgHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)padwHelpIDs);
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::CIpxConfigDlg
//
//  Purpose:    ctor for the CIpxConfigDlg class
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
CIpxConfigDlg::CIpxConfigDlg(CNwlnkIPX *pmsc, CIpxEnviroment * pIpxEnviroment,
                             CIpxAdapterInfo * pAI)
{
    // Note these parameters are on loan, do not free them...
    Assert(NULL != pmsc);
    Assert(NULL != pIpxEnviroment);
    m_pmsc = pmsc;
    m_pIpxEnviroment = pIpxEnviroment;
    ZeroMemory(&m_WrkstaDlgInfo, sizeof(m_WrkstaDlgInfo));
    m_pAICurrent     = pAI;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::OnInitDialog
//
//  Purpose:    Called when this dialog is first brought up.
//
//  Parameters:
//      uMsg     [in]
//      wParam   [in] See the ATL documentation for params.
//      lParam   [in]
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 11-Apr-1997
//
//  Notes:
//
LRESULT CIpxConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& bHandled)
{
    UINT    nIdx;
    int     aIds[] = {IDS_IPXPP_TEXT_1, IDS_IPXPP_TEXT_2};
    tstring strText;
    WCHAR   szBuf[12];
    HWND    hwndEdit = GetDlgItem(EDT_IPXPP_NETWORKNUMBER);
    HWND    hwndEditINN = GetDlgItem(EDT_IPXAS_INTERNAL);

    // Build the property page's informative text block
    for (nIdx=0; nIdx < celems(aIds); nIdx++)
        strText += SzLoadIds(aIds[nIdx]);

    ::SetWindowText(GetDlgItem(IDC_IPXPP_TEXT), strText.c_str());

    // Subclass the network number edit control
    ::SetWindowLongPtr(hwndEdit, GWLP_USERDATA, ::GetWindowLongPtr(hwndEdit, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);
    ::SetWindowLongPtr(hwndEditINN, GWLP_USERDATA, (LONG_PTR) ::GetWindowLongPtr(hwndEditINN, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEditINN, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);

    // Limit the text in the network # edit control
    ::SendMessage(hwndEdit, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);
    ::SendMessage(hwndEditINN, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);

    // Populate the Inernal Network Number edit control
    HexSzFromDw(szBuf, m_pIpxEnviroment->DwVirtualNetworkNumber());
    ::SetWindowText(hwndEditINN,szBuf);

    // If no adapter cards are present inform the user
    // and disable the UI.
    Assert(NULL != m_pIpxEnviroment);
    if (NULL == m_pAICurrent)
    {
        int aIdc[] = {CMB_IPXPP_FRAMETYPE,
                      EDT_IPXPP_NETWORKNUMBER,
                      IDC_STATIC_NETNUM,
                      IDC_STATIC_FRAMETYPE,
                      GB_IPXPP_ADAPTER,
                      IDC_IPXPP_ADAPTER_TEXT };

        // Disable the dialog controls
        for (nIdx = 0; nIdx<celems(aIdc); nIdx++)
            ::ShowWindow(GetDlgItem(aIdc[nIdx]), SW_HIDE);
    }
    else
    {
        Assert(m_pAICurrent);
        Assert(!m_pAICurrent->FDeletePending());
        Assert(!m_pAICurrent->FDisabled());
        Assert(!m_pAICurrent->FHidden());

        // Move the Adapter Info to the dialog's internal form
        m_WrkstaDlgInfo.pAI = m_pAICurrent;
        m_WrkstaDlgInfo.dwMediaType = m_pAICurrent->DwMediaType();
        m_WrkstaDlgInfo.dwFrameType = m_pAICurrent->DwFrameType();
        m_WrkstaDlgInfo.dwNetworkNumber = m_pAICurrent->DwNetworkNumber();

        // Adjust the UI to reflect the currently selected adapter
        AdapterChanged();
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed.
//
//  Parameters:
//      idCtrl   [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 11-Apr-1997
//
//  Notes:
//
LRESULT CIpxConfigDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
    HWND        hwndEdit = GetDlgItem(EDT_IPXAS_INTERNAL);
    WCHAR       szBuf[12];

    ::GetWindowText(hwndEdit,szBuf,sizeof(szBuf)/sizeof(WCHAR));
    if (0 == lstrlenW(szBuf))
    {
        NcMsgBox(m_hWnd, IDS_MANUAL_FRAME_DETECT, IDS_INCORRECT_NETNUM, MB_OK | MB_ICONEXCLAMATION);
        ::SetFocus(hwndEdit);
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
        return TRUE;
    }

    // Update the virtual network number
    m_pIpxEnviroment->SetVirtualNetworkNumber(DwFromSz(szBuf, 16));

    if (NULL != m_pAICurrent)
    {
        m_pAICurrent->SetDirty(TRUE);

        // Force update of the currently selection items in our internal data
        // structure.  This handles the case case of someone changing only
        // network num, and nothing else on the page.
        FrameTypeChanged();

        // Apply the internal data to original adapter info
        UpdateLstPtstring(m_WrkstaDlgInfo.pAI->m_lstpstrFrmType,
                          m_WrkstaDlgInfo.dwFrameType);

        UpdateLstPtstring(m_WrkstaDlgInfo.pAI->m_lstpstrNetworkNum,
                          m_WrkstaDlgInfo.dwNetworkNumber);
    }

    TraceError("CIpxConfigDlg::OnOk", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxConfigDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPX_CONFIG);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxConfigDlg::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPX_CONFIG);
}


//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::GetFrameType
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 25-Apr-1997
//
const FRAME_TYPE *CIpxConfigDlg::GetFrameType(DWORD dwMediaType)
{
    // Locate the media type
    for (int i=0; i<celems(MediaMap); i++)
        if (MediaMap[i].dwMediaType == dwMediaType)
            return MediaMap[i].aFrameType;

    return aEthernet_Frames;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::UpdateNetworkNumber
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 28-Apr-1997
//
//  Notes:
//
void CIpxConfigDlg::UpdateNetworkNumber(DWORD dwNetworkNumber,
                                        DWORD dwFrameType)
{
    HWND hwndEdit = GetDlgItem(EDT_IPXPP_NETWORKNUMBER);

    if (dwFrameType != AUTO)
    {
        WCHAR szBuf[12];
        HexSzFromDw(szBuf, dwNetworkNumber);
        ::SetWindowText(hwndEdit, szBuf);
        ::EnableWindow(hwndEdit, TRUE);
        ::EnableWindow(GetDlgItem(IDC_STATIC_NETNUM), TRUE);
    }
    else
    {
        ::SetWindowText(hwndEdit, L"");
        ::EnableWindow(hwndEdit, FALSE);
        ::EnableWindow(GetDlgItem(IDC_STATIC_NETNUM), FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::AdapterChanged
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 28-Apr-1997
//
void CIpxConfigDlg::AdapterChanged()
{
    DWORD dwFrameType;
    HWND  hwndFrame = GetDlgItem(CMB_IPXPP_FRAMETYPE);
    HWND  hwndEdit = GetDlgItem(EDT_IPXPP_NETWORKNUMBER);
    int   nIdxLoop;
    int   nIdx;

    const FRAME_TYPE *   pft;

    if ((NULL == hwndFrame) || (NULL == m_pAICurrent))
        return;

    // Locate the Correct Frame Type info for this adapter's media type
    pft = GetFrameType(m_WrkstaDlgInfo.dwMediaType);
    Assert(NULL != pft);

    // Populate the Frame Type Combo
    ::SendMessage(hwndFrame, CB_RESETCONTENT, 0, 0L);
    for (nIdxLoop=0;
         pft[nIdxLoop].nFrameIds != 0;
         nIdxLoop++)
    {
        // Add the Frame Type's descriptive string
        nIdx = (int)::SendMessage(hwndFrame, CB_ADDSTRING, 0,
                       (LPARAM)(PCWSTR)SzLoadIds(pft[nIdxLoop].nFrameIds));
        if (CB_ERR == nIdx)
            break;

        // Add the Frame Type for convenient access later
        ::SendMessage(hwndFrame, CB_SETITEMDATA, nIdx,
                      pft[nIdxLoop].dwFrameType);
    }

    // Update the network number based on the frame type
    UpdateNetworkNumber(m_WrkstaDlgInfo.dwNetworkNumber,
                        m_WrkstaDlgInfo.dwFrameType);

    switch (m_WrkstaDlgInfo.dwFrameType)
    {
    case ETHERNET:
        nIdx = IDS_ETHERNET;
        break;

    case F802_2:
        switch (m_WrkstaDlgInfo.dwMediaType)
        {
        case TOKEN_MEDIA:
            nIdx = IDS_TK;
            break;

        case FDDI_MEDIA:
            nIdx = IDS_FDDI;
            break;

        default:
            nIdx = IDS_802_2;
            break;
        }
        break;

    case F802_3:
        switch (m_WrkstaDlgInfo.dwMediaType)
        {
        case FDDI_MEDIA:
            nIdx = IDS_FDDI_802_3;
            break;

        default:
            nIdx = IDS_802_3;
            break;
        }
        break;

    case SNAP:
        switch (m_WrkstaDlgInfo.dwMediaType)
        {
        case TOKEN_MEDIA:
            nIdx = IDS_802_5;
            break;

        case FDDI_MEDIA:
            nIdx = IDS_FDDI_SNAP;
            break;

        default:
            nIdx = IDS_SNAP;
            break;
        }
        break;

    case ARCNET:
        nIdx = IDS_ARCNET;
        break;

    case AUTO:
            // Fall through...
    default:
        nIdx = IDS_AUTO;
        break;
    }

    // Set the frame type in the combo box
    ::SendMessage(hwndFrame, CB_SETCURSEL,
            ::SendMessage(hwndFrame, CB_FINDSTRINGEXACT,
                          0, ((LPARAM)(PCWSTR)SzLoadIds(nIdx))), 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::FrameTypeChanged
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 28-Apr-1997
//
void CIpxConfigDlg::FrameTypeChanged()
{
    HWND  hwndFrame =   GetDlgItem(CMB_IPXPP_FRAMETYPE);
    int   nIdx;

    if (NULL == m_pAICurrent)
        return;

    // Locate the currently selected frame type
    nIdx = (int)::SendMessage(hwndFrame, CB_GETCURSEL, 0, 0L);
    if (CB_ERR == nIdx)
        return;

    // Update the currently selected frame type
    m_WrkstaDlgInfo.dwFrameType = (DWORD)::SendMessage(hwndFrame, CB_GETITEMDATA, nIdx, 0L);

    SetNetworkNumber(&m_WrkstaDlgInfo.dwNetworkNumber);

    UpdateNetworkNumber(m_WrkstaDlgInfo.dwNetworkNumber,
                        m_WrkstaDlgInfo.dwFrameType);
}

void CIpxConfigDlg::SetNetworkNumber(DWORD *pdw)
{
    WCHAR szBuf[30];
    WCHAR szBuf2[30];
    szBuf[0] = NULL;

    HWND hwndEdit = GetDlgItem(EDT_IPXPP_NETWORKNUMBER);
    if (NULL == hwndEdit)
    {
        return;
    }

    // Get the new number and normalize it...
    ::GetWindowText(hwndEdit, szBuf, sizeof(szBuf)/sizeof(WCHAR));
    *pdw = DwFromSz(szBuf, 16);

    HexSzFromDw(szBuf2, *pdw);

    // Update the edit control if a parsing produced a net change
    if (lstrcmpW(szBuf,szBuf2) != 0)
    {
        ::SetWindowText(hwndEdit, szBuf2);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::HandleNetworkNumber
//
//  Purpose:    Called when the network number edit control gets a message.
//
//  Parameters: See the ATL documentation for params.
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 13-Aug-1997
//
//  Notes:
//
LRESULT
CIpxConfigDlg::HandleNetworkNumber(
    WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (EN_CHANGE == wNotifyCode)
    {
        SetChangedFlag();
    }

    if ((wNotifyCode != EN_KILLFOCUS) || (NULL == m_pAICurrent))
        return 0L;

    SetNetworkNumber(&m_WrkstaDlgInfo.dwNetworkNumber);

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxConfigDlg::HandleFrameCombo
//
//  Purpose:
//
//  Parameters:
//
//  Returns:
//
//  Author:     scottbri 28-Apr-1997
//
LRESULT CIpxConfigDlg::HandleFrameCombo(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& bHandled)
{
    Assert(CMB_IPXPP_FRAMETYPE == wID);

    if (CBN_SELENDOK != wNotifyCode)
    {
        bHandled = FALSE;
        return 0L;
    }

    FrameTypeChanged();
    SetChangedFlag();

    bHandled = TRUE;

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::CIpxASConfigDlg
//
//  Purpose:    ctor for the CIpxASConfigDlg class
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
CIpxASConfigDlg::CIpxASConfigDlg(CNwlnkIPX *pmsc,
                                 CIpxEnviroment * pIpxEnviroment,
                                 CIpxAdapterInfo * pAI)
{
    // Note these parameters are on loan, do not free them...
    Assert(NULL != pmsc);
    Assert(NULL != pIpxEnviroment);
    m_pmsc = pmsc;
    m_pIpxEnviroment = pIpxEnviroment;
    m_pAICurrent = pAI;
    m_nRadioBttn = 0;
    m_dwMediaType = ETHERNET_MEDIA;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::~CIpxASConfigDlg
//
//  Purpose:    dtor for the CIpxASConfigDlg class
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
CIpxASConfigDlg::~CIpxASConfigDlg()
{
    DeleteColString(&m_lstpstrFrmType);
    DeleteColString(&m_lstpstrNetworkNum);
    m_pmsc = NULL;
    m_pIpxEnviroment = NULL;
    m_pAICurrent = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::FIsNetNumberInUse
//
//  Purpose:    Compare a network number to those already in use.
//              Returning TRUE if the network number is already present.
//
//  Parameters: dwFrameType - Frame Type as a DWORD
//              pszNetNum - Network number as a hex string
//
//  Returns:    BOOL, TRUE if the network number is already present, FALSE otherwise
//
//  Author:     scottbri 29-Apr-1997
//
BOOL CIpxASConfigDlg::FIsNetNumberInUse(DWORD dwFrameType, PCWSTR pszNetNum)
{
    DWORD  dwNetNum = DwFromSz(pszNetNum, 16);

    if (0 == dwNetNum)
    {
        return FALSE;
    }

    list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
    list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();

    while (iterFrmType != m_lstpstrFrmType.end() &&
           iterNetworkNum != m_lstpstrNetworkNum.end())
    {
        tstring *pstr1 = *iterFrmType;
        tstring *pstr2 = *iterNetworkNum;
        if ((DwFromSz(pstr1->c_str(), 16) == dwFrameType) &&
            (DwFromSz(pstr2->c_str(),16) == dwNetNum))
        {
            return TRUE;
        }

        iterFrmType++;
        iterNetworkNum++;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnInitDialog
//
//  Purpose:    Called when this dialog is first brought up.
//
//  Parameters:
//      uMsg     [in]
//      wParam   [in] See the ATL documentation for params.
//      lParam   [in]
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 11-Apr-1997
//
//  Notes:
//
LRESULT CIpxASConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& bHandled)
{
    // Initialize the listview column headings
    int       aIds[] = {IDS_IPXAS_FRAME_TYPE,IDS_IPXAS_NETWORK_NUM};
    HWND      hwndTmp;
    int       iCol;
    LV_COLUMN lvc;
    RECT      rc;
    WCHAR     szBuf[12];

    m_hwndLV = GetDlgItem(LVC_IPXAS_DEST);
    ::GetClientRect(m_hwndLV, &rc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = (rc.right - rc.left) / 2;

    UINT    nIdx;
    int     aIds2[] = {IDS_IPXPP_TEXT_1, IDS_IPXPP_TEXT_2};
    tstring strText;

    // Build the property page's informative text block
    for (nIdx=0; nIdx < celems(aIds2); nIdx++)
    {
        strText += SzLoadIds(aIds2[nIdx]);
    }

    ::SetWindowText(GetDlgItem(IDC_IPXPP_TEXT), strText.c_str());

    // Add columns
    for (iCol = 0; iCol < celems(aIds); iCol++)
    {
        lvc.iSubItem = iCol;
        lvc.pszText = (PWSTR)SzLoadIds(aIds[iCol]);
        if (ListView_InsertColumn(m_hwndLV, iCol, &lvc) == -1)
            return FALSE;
    }

    // Initialize the Internal Network Number Edit Control
    HexSzFromDw(szBuf, m_pIpxEnviroment->DwVirtualNetworkNumber());
    hwndTmp = GetDlgItem(EDT_IPXAS_INTERNAL);
    ::SetWindowText(hwndTmp,szBuf);

    // Subclass the edit control to allow only network number's
    ::SetWindowLongPtr(hwndTmp, GWLP_USERDATA, ::GetWindowLongPtr(hwndTmp, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndTmp, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);

    // Limit the text in the network # edit control
    ::SendMessage(hwndTmp, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);

    // Initialize the rest of the Server's General page
    InitGeneralPage();
    UpdateButtons();

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::UpdateButtons
//
//  Purpose:    Update the button settings on the server's IPX general page
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
void CIpxASConfigDlg::UpdateButtons()
{
    INT  nCount     = ListView_GetItemCount(m_hwndLV);
    HWND hwndEdit   = GetDlgItem(BTN_IPXAS_EDIT);
    HWND hwndRemove = GetDlgItem(BTN_IPXAS_REMOVE);
    HWND hwndAdd    = GetDlgItem(BTN_IPXAS_ADD);
    BOOL fEnableAdd = FALSE;
    BOOL fEnableEditRemove = TRUE;

    Assert(NULL != m_hwndLV);
    if ((0 == nCount) || !IsDlgButtonChecked(BTN_IPXAS_MANUAL))
    {
        fEnableEditRemove = FALSE;
    }

    ::EnableWindow(hwndRemove, fEnableEditRemove);
    ::EnableWindow(hwndEdit, fEnableEditRemove);

    if (NULL != m_pAICurrent)
    {
         fEnableAdd = !(nCount >= DetermineMaxNumFrames());
    }

    if (!IsDlgButtonChecked(BTN_IPXAS_MANUAL))
    {
        fEnableAdd = FALSE;
    }

    ::EnableWindow(hwndAdd, fEnableAdd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::DetermineMaxNumFrames
//
//  Purpose:    Return the max number of frames allowed for a give adapter
//              based on that adapters media type.
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
int CIpxASConfigDlg::DetermineMaxNumFrames()
{
    int n;

    if (NULL == m_pAICurrent)
        return 0;

    switch(m_dwMediaType)
    {
    case FDDI_MEDIA:
        n = 3;
        break;

    case TOKEN_MEDIA:
        n = 2;
        break;

    case ARCNET_MEDIA:
        n = 1;
        break;

    default:
        n = 4;
        break;
    }

    return n;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::InitGeneralPage
//
//  Purpose:    Initialize the Server's IPX general page
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 28-Apr-1997
//
void CIpxASConfigDlg::InitGeneralPage()
{
    // Populate the adapter list
    int  nIdx;

    // Copy the adapter list info to a local structure
    // to allow user manipulation
    if (NULL != m_pAICurrent)
    {
        Assert(!m_pAICurrent->FDeletePending());
        Assert(!m_pAICurrent->FDisabled());
        Assert(!m_pAICurrent->FHidden());

        // Move the Adapter Info to the dialog's internal form
        m_dwMediaType = m_pAICurrent->DwMediaType();

        // Frame Type lists contain one of two possible values
        // 1) One AUTO entry
        // 2) One or more non-AUTO frame types
        //
        // If the first is not AUTO, then copy the frame and network number
        // pairs.  Otherwise, leave the local lists empty
        DWORD dw = DwFromLstPtstring(m_pAICurrent->m_lstpstrFrmType, c_dwPktTypeDefault, 16);
        if (AUTO != dw)
        {
            list<tstring*>::iterator    iterFrmType;
            list<tstring*>::iterator    iterNetworkNum;
            m_nRadioBttn = BTN_IPXAS_MANUAL;

            // Make an internal copy of the adapter's frame type and
            // Network number information
            for (iterFrmType = m_pAICurrent->m_lstpstrFrmType.begin(),
                  iterNetworkNum = m_pAICurrent->m_lstpstrNetworkNum.begin();
                 iterFrmType != m_pAICurrent->m_lstpstrFrmType.end(),
                  iterNetworkNum != m_pAICurrent->m_lstpstrNetworkNum.end();
                 iterFrmType++, iterNetworkNum++)
            {
                // Copy the Frame Type
                tstring *pstr1 = *iterFrmType;
                m_lstpstrFrmType.push_back(new tstring(pstr1->c_str()));

                // Copy the Network number
                tstring *pstr2 = *iterNetworkNum;
                m_lstpstrNetworkNum.push_back(new tstring(pstr2->c_str()));
            }
        }
        else
        {
            m_nRadioBttn = BTN_IPXAS_AUTO;
        }

        // Update the UI to reflect the currently selected adapter
        UpdateRadioButtons();
        HrUpdateListView();
        UpdateButtons();
    }
    else
    {
        // No adapters installed, disable the dialog sensibly
        //
        ::EnableWindow(GetDlgItem(BTN_IPXAS_MANUAL), FALSE);
        ::EnableWindow(GetDlgItem(BTN_IPXAS_ADD), FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::HrAddItemToList
//
//  Purpose:    Add a row to the list view
//
//  Parameters: idsFrameName - ie ARCNET, Ethernet II, etc
//              pszNetNum - Network number as a hex string
//
//  Returns:    HRESULT, S_OK if everything was added correctly
//
//  Author:     scottbri 29-Apr-1997
//
HRESULT CIpxASConfigDlg::HrAddItemToList(int idsFrameName, PCWSTR pszNetNum)
{
    int nIdx;
    LV_ITEM lvi;
    int nCount = ListView_GetItemCount(m_hwndLV);

    // Add the item info to the list view
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iItem = nCount;
    lvi.iSubItem = 0;
    lvi.state = 0;
    lvi.stateMask = 0;
    lvi.pszText = (PWSTR)SzLoadIds(idsFrameName);
    lvi.cchTextMax = lstrlenW(lvi.pszText);
    lvi.iImage = 0;
    lvi.lParam = idsFrameName;
    nIdx = ListView_InsertItem(m_hwndLV, &lvi);
    if (-1 == nIdx)
    {
        return E_OUTOFMEMORY;
    }

    Assert(lvi.iItem == nIdx);
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 1;
    lvi.pszText = (PWSTR)pszNetNum;
    lvi.cchTextMax = lstrlenW(lvi.pszText);
    if (FALSE == ListView_SetItem(m_hwndLV, &lvi))
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::HrUpdateListView
//
//  Purpose:    Update the contents of the listview
//
//  Parameters: none
//
//  Returns:    HRESULT, S_OK if everything was added correctly
//
//  Author:     scottbri 29-Apr-1997
//
HRESULT CIpxASConfigDlg::HrUpdateListView()
{
    HRESULT hr = S_OK;
    Assert(NULL != m_pAICurrent);
    int    nSize = m_lstpstrFrmType.size();

    if (0 == nSize)
        return S_OK;

    // The list view is expected to be empty when this function is called
    Assert(0 == ListView_GetItemCount(m_hwndLV));

    // For efficency tell the list view how many items we're adding
    ListView_SetItemCount(m_hwndLV, nSize);

    // Enumerate the frame type/network number pairs use that data to
    // populate the list view
    list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
    list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();

    while (iterFrmType != m_lstpstrFrmType.end() &&
           iterNetworkNum != m_lstpstrNetworkNum.end())
    {
        tstring *pstr1 = *iterFrmType;
        tstring *pstr2 = *iterNetworkNum;
        DWORD dwFrameType = DwFromSz(pstr1->c_str(), 16);

        if (F802_2 == dwFrameType)
        {
            switch (m_dwMediaType)
            {
            case TOKEN_MEDIA:
                hr = HrAddItemToList(IDS_TK, pstr2->c_str());
                break;

            case FDDI_MEDIA:
                hr = HrAddItemToList(IDS_FDDI, pstr2->c_str());
                break;

            case ARCNET_MEDIA:
                hr = HrAddItemToList(IDS_ARCNET, pstr2->c_str());
                break;

            default:
                hr = HrAddItemToList(IDS_802_2, pstr2->c_str());
                break;
            }
        }
        else if (ETHERNET == dwFrameType)
        {
            hr = HrAddItemToList(IDS_ETHERNET, pstr2->c_str());
        }
        else if (F802_3 == dwFrameType)
        {
            switch (m_dwMediaType)
            {
            case FDDI_MEDIA:
                hr = HrAddItemToList(IDS_FDDI_802_3, pstr2->c_str());
                break;

            default:
                hr = HrAddItemToList(IDS_802_3, pstr2->c_str());
                break;
            }
        }
        else if (SNAP == dwFrameType)
        {
            switch (m_dwMediaType)
            {
            case TOKEN_MEDIA:
                hr = HrAddItemToList(IDS_802_5, pstr2->c_str());
                break;

            case FDDI_MEDIA:
                hr = HrAddItemToList(IDS_SNAP, pstr2->c_str());
                break;

            default:
                hr = HrAddItemToList(IDS_SNAP, pstr2->c_str());
                break;
            }
        }
        else
        {
            Assert(ARCNET == dwFrameType);
            hr = HrAddItemToList(IDS_ARCNET, pstr2->c_str());
        }

        // Was the network number already present in the list?
        if (S_FALSE == hr)
        {
            // Remove the duplicate network number and frame
            // Note that this usage of erase correctly advances both iterators
            delete pstr1;
            delete pstr2;
            iterFrmType = m_lstpstrFrmType.erase(iterFrmType);
            iterNetworkNum = m_lstpstrNetworkNum.erase(iterNetworkNum);
            hr = S_OK;  // Normalize return
        }
        else if (FAILED(hr))
        {
            break;
        }
        else
        {
            Assert(SUCCEEDED(hr));
            // Advance the iterators
            iterFrmType++;
            iterNetworkNum++;
        }
    }

    // Select the first item in the list
    ListView_SetItemState(m_hwndLV, 0, LVIS_SELECTED, LVIS_SELECTED);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::HandleRadioButton
//
//  Purpose:    React to changes to the dialog's radio buttons
//
//  Parameters: Std ATL handler params
//
//  Returns:    LRESULT
//
//  Author:     scottbri 21-Aug-1997
//
LRESULT CIpxASConfigDlg::HandleRadioButton(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& bHandled)
{
    bHandled = FALSE;

    if ((wNotifyCode != BN_CLICKED) || (NULL == m_pAICurrent))
        return 0;

    SetChangedFlag();

    Assert((BTN_IPXAS_AUTO==wID) || (BTN_IPXAS_MANUAL==wID));
    m_nRadioBttn = wID;
    UpdateButtons();

    bHandled = TRUE;
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::UpdateRadioButtons
//
//  Purpose:    Update the radio button settings based on the selected adapter
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 29-Apr-1997
//
void CIpxASConfigDlg::UpdateRadioButtons()
{
    DWORD dw;

    if (NULL == m_pAICurrent)
    {
        return;
    }

    if (0 == m_nRadioBttn)
    {
        m_nRadioBttn = BTN_IPXAS_AUTO;
    }

    CheckRadioButton(BTN_IPXAS_AUTO, BTN_IPXAS_MANUAL, m_nRadioBttn);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed.
//
//  Parameters:
//      idCtrl   [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 11-Apr-1997
//
//  Notes:
//
LRESULT CIpxASConfigDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT             hr = S_OK;
    WCHAR               szBuf[12];
    HWND                hwndEdit = GetDlgItem(EDT_IPXAS_INTERNAL);

    ::GetWindowText(hwndEdit,szBuf,sizeof(szBuf)/sizeof(WCHAR));
    if (0 == lstrlenW(szBuf))
    {
        NcMsgBox(m_hWnd, IDS_MANUAL_FRAME_DETECT, IDS_INCORRECT_NETNUM, MB_OK | MB_ICONEXCLAMATION);
        ::SetFocus(hwndEdit);
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
        return TRUE;
    }

    // Update the virtual network number
    m_pIpxEnviroment->SetVirtualNetworkNumber(DwFromSz(szBuf, 16));

    // Rewrite the local versions of the frame type and Network Numbers
    if (NULL != m_pAICurrent)
    {
        m_pAICurrent->SetDirty(TRUE);

        // First empty the respective destination lists...
        Assert(NULL != m_pAICurrent);
        DeleteColString(&m_pAICurrent->m_lstpstrFrmType);
        DeleteColString(&m_pAICurrent->m_lstpstrNetworkNum);

        // When the listbox is empty we're in AUTO mode
        if (0 == ListView_GetItemCount(m_hwndLV))
        {
            m_nRadioBttn = BTN_IPXAS_AUTO;
            CheckRadioButton(BTN_IPXAS_AUTO, BTN_IPXAS_MANUAL, m_nRadioBttn);
        }

        // Only transfer the Frame Type/Network Number information if manual
        // frame type detection was requested.
        if (BTN_IPXAS_MANUAL == m_nRadioBttn)
        {
            // Then create new destination lists from the local data
            list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
            list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();

            for (;iterFrmType != m_lstpstrFrmType.end(),
                  iterNetworkNum != m_lstpstrNetworkNum.end();
                  iterFrmType++,
                  iterNetworkNum++)
            {
                tstring *pstr1 = *iterFrmType;
                tstring *pstr2 = *iterNetworkNum;
                m_pAICurrent->m_lstpstrFrmType.push_back(new tstring(pstr1->c_str()));
                m_pAICurrent->m_lstpstrNetworkNum.push_back(new tstring(pstr2->c_str()));
            }
        }

        Assert(m_pAICurrent->m_lstpstrFrmType.size() == m_pAICurrent->m_lstpstrNetworkNum.size());

        // If the destination lists end up empty, supply default values
        if (0 == m_pAICurrent->m_lstpstrFrmType.size())
        {
            WCHAR szBuf[12];
            HexSzFromDw(szBuf, c_dwPktTypeDefault);

            m_pAICurrent->m_lstpstrFrmType.push_back(new tstring(szBuf));
            m_pAICurrent->m_lstpstrNetworkNum.push_back(new tstring(c_sz8Zeros));
        }
    }

    TraceError("CIpxASConfigDlg::OnOk", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxASConfigDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPXAS_CONFIG);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxASConfigDlg::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPXAS_CONFIG);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnAdd
//
//  Purpose:    Called when the Add button is pressed.  Used to add additional
//              frame type/network number pairs
//
//  Parameters:
//      wNotifyCode [in]
//      wID      [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 29-Apr-1997
//
LRESULT CIpxASConfigDlg::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CASAddDialog *       pdlg;

    if (NULL == m_pAICurrent)
        return 0;

    SetChangedFlag();

    // Bring up the dialog
    pdlg = new CASAddDialog(this, m_hwndLV, m_dwMediaType,
                            c_dwPktTypeDefault, c_sz8Zeros);

    if (pdlg == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (pdlg->DoModal(m_hWnd) == IDOK)
    {
        // Update the internal structures and the dialog with the returned values
        if (S_OK == HrAddItemToList(pdlg->IdsGetFrameType(), pdlg->SzGetNetworkNumber()))
        {
            // Validated above, so add to the internal list
            WCHAR szBuf[12];
            HexSzFromDw(szBuf,pdlg->DwGetFrameType());
            m_lstpstrFrmType.push_back(new tstring(szBuf));
            m_lstpstrNetworkNum.push_back(new tstring(pdlg->SzGetNetworkNumber()));

            // Select the new item
            int nCount = ListView_GetItemCount(m_hwndLV);
            Assert(0 < nCount);
            ListView_SetItemState(m_hwndLV, nCount-1, LVIS_SELECTED, LVIS_SELECTED);

            // Update the state of the Add, Edit, and Remove buttons
            HWND hwndFocus = GetFocus();
            UpdateButtons();
            if (!::IsWindowEnabled(hwndFocus))
            {
                ::SetFocus(GetDlgItem(BTN_IPXAS_EDIT));
            }
        }
    }

    delete pdlg;

    return 0;
}

LRESULT CIpxASConfigDlg::HandleInternalNetworkNumber(
    WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (EN_CHANGE == wNotifyCode)
    {
        SetChangedFlag();
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnEdit
//
//  Purpose:    Called when the Edit button is pressed.  Used to edit a
//              Frame Type/Network number pair
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 29-Apr-1997
//
LRESULT CIpxASConfigDlg::OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                  nIdx = 0;
    int                  nIdxSelected;

    // Locate the selected row in the listview
    if (FALSE == FGetSelectedRowIdx(&nIdxSelected))
        return 0;

    if (NULL == m_pAICurrent)
        return 0;

    SetChangedFlag();

    // Enumerate the internal data to locate the frame type/network number for
    // the selection
    list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
    list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();
    while ((iterFrmType != m_lstpstrFrmType.end()) &&
           (iterNetworkNum != m_lstpstrNetworkNum.end()))
    {
        if (nIdx == nIdxSelected)
        {
            tstring *pstr1 = *iterNetworkNum;
            tstring *pstr2 = *iterFrmType;

            // Create the dialog
            CASEditDialog * pdlg = new CASEditDialog(this, m_hwndLV,
                                                     DwFromSz(pstr2->c_str(), 16),
                                                     pstr1->c_str());
            if (pdlg->DoModal(m_hWnd) == IDOK)
            {
                LV_ITEM lvi;

                // Apply the dialog changes to the ListView Control
                ZeroMemory(&lvi, sizeof(lvi));
                lvi.mask = LVIF_TEXT;
                lvi.iItem = nIdxSelected;
                lvi.iSubItem = 1;
                lvi.pszText = (PWSTR)pdlg->SzGetNetworkNumber();
                ListView_SetItem(m_hwndLV, &lvi);

                // Apply the changes to the local data
                *(*iterNetworkNum) = pdlg->SzGetNetworkNumber();
            }

            delete pdlg;
            break;
        }

        nIdx++;
        iterFrmType++;
        iterNetworkNum++;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::FGetSelectedRowIdx
//
//  Purpose:    Returns the index of the selected row in the listview, if it exists
//
//  Parameters: pnIdx [out] - The selected row's zero based index
//
//  Returns:    BOOL, TRUE if a selected row exists, FALSE otherwise
//
BOOL CIpxASConfigDlg::FGetSelectedRowIdx(int *pnIdx)
{
    int nCount = ListView_GetItemCount(m_hwndLV);
    int nIdx;
    LV_ITEM lvi;

    lvi.mask      = LVIF_STATE;
    lvi.iSubItem  = 0;
    lvi.stateMask = LVIS_SELECTED;

    // Determine the selected pair
    for (nIdx = 0; nIdx < nCount; nIdx++)
    {
        lvi.iItem = nIdx;
        if ((TRUE == ListView_GetItem(m_hwndLV, &lvi)) &&
            (lvi.state & LVIS_SELECTED))
        {
            // Located the selected Item
            *pnIdx = nIdx;
            return TRUE;
        }
    }

    *pnIdx = 0;

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASConfigDlg::OnRemove
//
//  Purpose:    Called when the Remove button is pressed.  Used to remove a
//              Frame Type/Network Number pair.
//
//  Parameters:
//      wNotifyCode [in]
//      wID      [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 29-Apr-1997
//
LRESULT
CIpxASConfigDlg::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                  nCount;
    int                  nIdx = 0;
    int                  nIdxSelected;
#ifdef DBG
    BOOL                 fFound = FALSE;
#endif

    // Locate the selected row in the listview
    if (FALSE == FGetSelectedRowIdx(&nIdxSelected))
        return 0;

    if (NULL == m_pAICurrent)
        return 0;

    SetChangedFlag();

    // Remove the row from the internal local representation and listview
    list<tstring *>::iterator iterFrmType = m_lstpstrFrmType.begin();
    list<tstring *>::iterator iterNetworkNum = m_lstpstrNetworkNum.begin();
    while ((iterFrmType != m_lstpstrFrmType.end()) &&
           (iterNetworkNum != m_lstpstrNetworkNum.end()))
    {
        if (nIdx == nIdxSelected)
        {
#ifdef DBG
            fFound = TRUE;
#endif
            // Remove and free the Frame Type piece
            tstring *pstr = *iterFrmType;
            m_lstpstrFrmType.erase(iterFrmType);
            delete pstr;

            // Remove and free the Network Number piece
            pstr = *iterNetworkNum;
            m_lstpstrNetworkNum.erase(iterNetworkNum);
            delete pstr;

            // We're done...
            break;
        }

        nIdx++;
        iterFrmType++;
        iterNetworkNum++;
    }

#ifdef DBG
    Assert(TRUE == fFound);
#endif

    // Remove the frame type/network number pair from the list view
    ListView_DeleteItem(m_hwndLV, nIdxSelected);

    nCount = ListView_GetItemCount(m_hwndLV);
    if (nCount <= nIdxSelected)
    {
        nIdxSelected = nCount - 1;
    }
    if (0 <= nIdxSelected)
    {
        ListView_SetItemState(m_hwndLV, nIdxSelected, LVIS_SELECTED, LVIS_SELECTED);
    }

    // Update the state of the Add, Edit, and Remove buttons
    HWND hwndFocus = GetFocus();
    UpdateButtons();
    if (!::IsWindowEnabled(hwndFocus))
    {
        ::SetFocus(GetDlgItem(BTN_IPXAS_ADD));
    }

    return 0;
}

#ifdef INCLUDE_RIP_ROUTING
//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::CIpxASInternalDlg
//
//  Purpose:    ctor for the CIpxASInternalDlg class
//
//  Parameters: none
//
//  Returns:    nothing
//
//  Author:     scottbri 29-Apr-1997
//
CIpxASInternalDlg::CIpxASInternalDlg(CNwlnkIPX *pmsc,
                                     CIpxEnviroment * pIpxEnviroment)
{
    // Note these parameters are on loan, do not free them...
    Assert(NULL != pmsc);
    Assert(NULL != pIpxEnviroment);
    m_pmsc = pmsc;
    m_pIpxEnviroment = pIpxEnviroment;

    m_dwRipValue = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnInitDialog
//
//  Purpose:
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CIpxASInternalDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    ::EnableWindow(GetDlgItem(BTN_IPXAS_RIP), m_pIpxEnviroment->FRipEnabled());
    CheckDlgButton(BTN_IPXAS_RIP, m_pIpxEnviroment->FRipEnabled());
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnRip
//
//  Purpose:    Handle changes to the Rip check box on the routing page
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CIpxASInternalDlg::OnRip(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (BN_CLICKED != wNotifyCode)
    {
        bHandled = FALSE;
        return 0L;
    }

    if (!m_pIpxEnviroment->FRipInstalled())
    {
        // Don't allow the user to check this box, if rip isn't installed
        if (IsDlgButtonChecked(BTN_IPXAS_RIP))
            CheckDlgButton(BTN_IPXAS_RIP, FALSE);

        // Tell the user they must install RIP first
        //$ REVIEW - Post Beta 1, this should trigger Rip Installation
        NcMsgBox(m_hWnd, IDS_ROUTING, IDS_INSTALL_RIP,
                     MB_OK | MB_ICONEXCLAMATION);
    }
    else
    {
        m_dwRipValue = 0;

        // Ask the user if they want type 20 broadcast enabled
        if (!m_pIpxEnviroment->FRipInstalled())
        {
            if (IDYES == NcMsgBox(m_hWnd, IDS_ROUTING, IDS_NETBIOS_BROADCAST,
                                  MB_YESNO | MB_ICONQUESTION))
                m_dwRipValue = 1;
        }
    }

    return 0L;
}
//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed.
//
//  Parameters:
//      idCtrl   [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     scottbri 29-Apr-1997
//
LRESULT CIpxASInternalDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;

    // Was the RIP checkbox changed?
    if (IsDlgButtonChecked(BTN_IPXAS_RIP) != m_pIpxEnviroment->FRipEnabled())
    {
        m_pIpxEnviroment->ChangeRipEnabling(IsDlgButtonChecked(BTN_IPXAS_RIP),
                                            m_dwRipValue);
    }

    TraceError("CIpxASInternalDlg::OnOk", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxASInternalDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPXAS_INTERNAL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CIpxASInternalDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CIpxASInternalDlg::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPXAS_INTERNAL);
}

#endif  // INCLUDE_RIP_ROUTING

//+---------------------------------------------------------------------------
//
//  Function:   CenterChildOverListView
//
//  Purpose:    Center the specified top level window over the listview
//              control of the parent dialog
//
//  Parameters: hwnd - Dialog to center
//
//  Returns:    nothing
//
void CenterChildOverListView(HWND hwnd, HWND hwndLV)
{
    RECT rc;
    ::GetWindowRect(hwndLV, &rc);
    ::SetWindowPos(hwnd, NULL,  rc.left, rc.top, 0, 0,
                   SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDialog::CASAddDialog
//
//  Purpose:    ctor for the CASAddDialog class
//
//  Parameters: dwMediaType -
//              dwFrameType -
//              szNetworkNumber -
//
//  Returns:    nothing
//
CASAddDialog::CASAddDialog(CIpxASConfigDlg * pASCD, HWND hwndLV,
                           DWORD dwMediaType, DWORD dwFrameType,
                           PCWSTR pszNetworkNum) :
                           m_strNetworkNumber(pszNetworkNum)
{
    m_pASCD        = pASCD;         // Borrowed pointer
    m_hwndLV       = hwndLV;
    m_dwMediaType  = dwMediaType;
    m_dwFrameType  = dwFrameType;
    m_idsFrameType = 0;             // Out param
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDialog::OnInitDialog
//
//  Purpose:
//
//  Parameters:
//      wNotifyCode [in]
//      wID      [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CASAddDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    Assert(NULL != m_hwndLV);
    HWND hwndCBM = GetDlgItem(CMB_IPXAS_DEST);
    HWND hwndEdit = GetDlgItem(EDT_IPXAS_NETNUM);

    // Search for the set of frames matching this adapter's media type

    for (int idxMM=0; idxMM < celems(MediaMap); idxMM++)
    {
        if (m_dwMediaType == MediaMap[idxMM].dwMediaType)
        {
            const FRAME_TYPE *ft = MediaMap[idxMM].aFrameType;

            // For each frame type not already in use, present in the server's
            // general page ListView, add the available combo box

            for (int idxFT=0; 0 != ft[idxFT].nFrameIds; idxFT++)
            {
                LV_FINDINFO lvfi;
                lvfi.flags = LVFI_STRING;
                lvfi.psz = SzLoadIds(ft[idxFT].nFrameIds);

                if ((IDS_AUTO != ft[idxFT].nFrameIds) &&
                    (-1 == ListView_FindItem(m_hwndLV, -1, &lvfi)))
                {
                    int idx = (int)::SendMessage(hwndCBM, CB_ADDSTRING, 0,
                                            (LPARAM)SzLoadIds(ft[idxFT].nFrameIds));
                    if (CB_ERR != idx)
                    {
                        // Store the IDS we used for future reference
                        ::SendMessage(hwndCBM, CB_SETITEMDATA, idx, ft[idxFT].nFrameIds);
                    }
                }
            }

            break;
        }
    }

    // Select the first item in the combo box
    Assert(0 != ::SendMessage(hwndCBM, CB_GETCOUNT, 0, 0L));
    ::SendMessage(hwndCBM, CB_SETCURSEL, 0, 0L);

    // Subclass the network number edit control
    ::SetWindowLongPtr(hwndEdit, GWLP_USERDATA,
                       ::GetWindowLongPtr(hwndEdit, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);

    // Limit the text in the network # edit control
    ::SendMessage(hwndEdit, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);

    // Initialize the network controls contents
    ::SetWindowText(hwndEdit, m_strNetworkNumber.c_str());

    // Center window of parent's listview window
    CenterChildOverListView(m_hWnd, m_hwndLV);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDialog::OnOk
//
//  Purpose:
//
//  Parameters:
//      wNotifyCode [in]
//      wID      [in]
//      pnmh     [in] See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CASAddDialog::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    HWND hwndCBM = GetDlgItem(CMB_IPXAS_DEST);
    WCHAR szBuf[12];

    // Retrieve the network number
    ::GetWindowText(GetDlgItem(EDT_IPXAS_NETNUM), szBuf, sizeof(szBuf)/sizeof(WCHAR));
    if (lstrlenW(szBuf))
    {
        // Normalize value (String -> Number -> Formated String)
        DWORD dw = DwFromSz(szBuf, 16);
        HexSzFromDw(szBuf, dw);
    }
    else
    {
        // Tell the user they must enter a number
        NcMsgBox(m_hWnd, IDS_MANUAL_FRAME_DETECT, IDS_INCORRECT_NETNUM,
                     MB_OK | MB_ICONEXCLAMATION);
        return 0L;
    }

    // Retrieve the selection form the combo box
    int idx = (int)::SendMessage(hwndCBM, CB_GETCURSEL, 0, 0L);
    if (CB_ERR != idx)
    {
        UINT idsFrameType = (UINT)::SendMessage(hwndCBM, CB_GETITEMDATA, idx, 0L);
        Assert(CB_ERR != idsFrameType);

        // Look up the Frame IDS to retreive the actual frame type
        for (int idxMM=0; idxMM < celems(MediaMap); idxMM++)
        {
            if (MediaMap[idxMM].dwMediaType != m_dwMediaType)
            {
                continue;
            }

            const FRAME_TYPE *ft = MediaMap[idxMM].aFrameType;

            for (int idxFT=0; 0 != ft[idxFT].nFrameIds; idxFT++)
            {
                if (ft[idxFT].nFrameIds != idsFrameType)
                {
                    continue;
                }

                // Ensure the frame type/netnum is not in use elsewhere
                if (m_pASCD->FIsNetNumberInUse(ft[idxFT].dwFrameType, szBuf))
                {
                    // Warn the user that the network number specified
                    // was already in use.
                    NcMsgBox(m_hWnd, IDS_GENERAL, IDS_NETNUM_INUSE,
                             MB_OK | MB_ICONEXCLAMATION);
                    goto Done;
                }

                m_strNetworkNumber = szBuf;

                // Return the stashed Frame IDS
                m_idsFrameType = idsFrameType;

                // Return the selected frame type
                m_dwFrameType = ft[idxFT].dwFrameType;
                EndDialog(IDOK);
                return 0;
            }
        }
    }

Done:
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CASAddDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPXAS_FRAME_ADD);
}

//+---------------------------------------------------------------------------
//
//  Member:     CASAddDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CASAddDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPXAS_FRAME_ADD);
}



//+---------------------------------------------------------------------------
//
//  Member:     CASEditDialog::OnInitDialog
//
//  Purpose:    Initialize the contents of the Edit Network Number dialog
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CASEditDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    HWND hwndEdit = GetDlgItem(EDT_IPXAS_NETNUM);

    // Set the initial contents of the network number edit control
    ::SetWindowText(hwndEdit, SzGetNetworkNumber());

    // Subclass the network number edit control
    ::SetWindowLongPtr(hwndEdit, GWLP_USERDATA,
                       ::GetWindowLongPtr(hwndEdit, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)EditSubclassProc);

    // Limit the text in the network # edit control
    ::SendMessage(hwndEdit, EM_LIMITTEXT, MAX_NETNUM_SIZE, 0L);

    // Center the dialog over the listview of the parent
    CenterChildOverListView(m_hWnd, m_hwndLV);

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CASEditDialog::OnOk
//
//  Purpose:    Process the Apply request for the Edit Network Number dialog
//
//  Parameters:
//      wNotifyCode [in]
//      wID         [in]
//      pnmh        [in] See the ATL documentation for params.
//      bHandled    [in]
//
//  Returns:    See the ATL documentation for return results.
//
LRESULT
CASEditDialog::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    DWORD dw;
    WCHAR szBuf[12];
    HWND hwndEdit = GetDlgItem(EDT_IPXAS_NETNUM);

    ::GetWindowText(hwndEdit, szBuf, sizeof(szBuf)/sizeof(WCHAR));
    if (0 == lstrlenW(szBuf))
    {
        // Tell the user they must enter a number
        NcMsgBox(m_hWnd, IDS_MANUAL_FRAME_DETECT, IDS_INCORRECT_NETNUM,
                     MB_OK | MB_ICONEXCLAMATION);
        return 0L;
    }

    // Normalize the return value
    dw = DwFromSz(szBuf, 16);
    HexSzFromDw(szBuf, dw);

    // If the network number was changed, verify it's uniqueness
    if ((0 != lstrcmpW(szBuf, m_strNetworkNumber.c_str())) &&
        m_pASCD->FIsNetNumberInUse(m_dwFrameType, szBuf))
    {
        // Warn the user that the network number specified
        // was already in use.
        NcMsgBox(m_hWnd, IDS_GENERAL, IDS_NETNUM_INUSE,
                 MB_OK | MB_ICONEXCLAMATION);
        return 0L;
    }

    // Persist the return value
    m_strNetworkNumber = szBuf;

    EndDialog(IDOK);
    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CASEditDlg::OnContextMenu
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CASEditDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnContextMenu(m_hWnd, g_aHelpIDs_DLG_IPXAS_FRAME_EDIT);
}

//+---------------------------------------------------------------------------
//
//  Member:     CASEditDlg::OnHelp
//
//  Purpose:    Context sensitive help support.
//
//  Author:     jeffspr   13 Apr 1999
//
//  Notes:
//
LRESULT CASEditDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    return ::CommonIPXOnHelp(lParam, g_aHelpIDs_DLG_IPXAS_FRAME_EDIT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwclicfg\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
//#define NOGDI
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>

#include <stdio.h>
#include <wchar.h>

#include "ncmem.h"

#include "list"
#include "vector"
using namespace std;

#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\nwlnkhlp.h ===
// Copyright (c) 1999, Microsoft Corporation, all rights reserved.
//
// Ipxcfg.h is used by nwlnkcfg.rc
// Help context IDs and Help map
//
// Created in Dev Studio
// 4-22-99 Melissa Simmons


#define IDH_BTN_IPXAS_ADD           17000030
#define IDH_BTN_IPXAS_AUTO          17000027
#define IDH_BTN_IPXAS_EDIT          17000031
#define IDH_BTN_IPXAS_MANUAL        17000028
#define IDH_BTN_IPXAS_REMOVE        17000032
#define IDH_CMB_IPXAS_DEST          17000050
#define IDH_CMB_IPXPP_FRAMETYPE     17000001
#define IDH_EDT_IPXAS_INTERNAL      17000000
#define IDH_EDT_IPXPP_NETWORKNUMBER 17000002
#define IDH_LVC_IPXAS_DEST          17000029

#define IDH_DISABLE_HELP            (DWORD(-1))

const DWORD g_aHelpIDs_DLG_IPX_CONFIG[]=
{
    IDC_STATIC, IDH_DISABLE_HELP,
    EDT_IPXAS_INTERNAL,IDH_EDT_IPXAS_INTERNAL,
    GB_IPXPP_ADAPTER, IDH_DISABLE_HELP,
    IDC_IPXPP_ADAPTER_TEXT, IDH_DISABLE_HELP,
    IDC_STATIC_FRAMETYPE, IDH_CMB_IPXPP_FRAMETYPE,
    CMB_IPXPP_FRAMETYPE,IDH_CMB_IPXPP_FRAMETYPE,
    IDC_STATIC_NETNUM, IDH_EDT_IPXPP_NETWORKNUMBER,
    EDT_IPXPP_NETWORKNUMBER,IDH_EDT_IPXPP_NETWORKNUMBER,
    IDC_IPXPP_TEXT,IDH_DISABLE_HELP,
    0,0
};

const DWORD g_aHelpIDs_DLG_IPXAS_CONFIG[]=
{
    IDC_STATIC, IDH_DISABLE_HELP,
    EDT_IPXAS_INTERNAL,IDH_EDT_IPXAS_INTERNAL,
    IDC_IPXAS_GROUP, IDH_DISABLE_HELP,
    BTN_IPXAS_AUTO,IDH_BTN_IPXAS_AUTO,
    BTN_IPXAS_MANUAL,IDH_BTN_IPXAS_MANUAL,
    LVC_IPXAS_DEST,IDH_LVC_IPXAS_DEST,
    BTN_IPXAS_ADD,IDH_BTN_IPXAS_ADD,
    BTN_IPXAS_EDIT,IDH_BTN_IPXAS_EDIT,
    BTN_IPXAS_REMOVE,IDH_BTN_IPXAS_REMOVE,
    IDC_IPXPP_TEXT,IDH_DISABLE_HELP,
    0,0
};

const DWORD g_aHelpIDs_DLG_IPXAS_FRAME_ADD[]=
{
    IDC_STATIC, IDH_DISABLE_HELP,
    CMB_IPXAS_DEST,IDH_CMB_IPXAS_DEST,
    EDT_IPXAS_NETNUM, IDH_EDT_IPXPP_NETWORKNUMBER,
    0,0
};

const DWORD g_aHelpIDs_DLG_IPXAS_FRAME_EDIT[]=
{
    EDT_IPXAS_NETNUM, IDH_EDT_IPXPP_NETWORKNUMBER,
    0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\nwlnkipx.cpp ===
// nwlnkipx.cpp : Implementation of CNwlnkIPX

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <netconp.h>
#include "ncmisc.h"
#include "ncnetcfg.h"
#include "ncpnp.h"
#include "ncreg.h"
#include "nwlnkipx.h"

extern const WCHAR c_szAdapterSections[];
extern const WCHAR c_szAdapters[];
extern const WCHAR c_szSpecificTo[];
extern const WCHAR c_szSvcNwlnkIpx[];
extern const WCHAR c_szInfId_MS_NWNB[];
extern const WCHAR c_szInfId_MS_NWSPX[];


static const WCHAR c_szProviderOrderVal[]      = L"ProviderOrder";
static const WCHAR c_szSrvProvOrderKey[]       = L"System\\CurrentControlSet\\Control\\ServiceProvider\\Order";

const WCHAR c_sz0xPrefix[]                   = L"0x";
const WCHAR c_sz8Zeros[]                     = L"00000000";
const DWORD c_dwPktTypeDefault               = AUTO;
const WCHAR c_szMediaType[]                  = L"MediaType";

static const WCHAR c_szIpxParameters[]       = L"System\\CurrentControlSet\\Services\\NwlnkIpx\\Parameters";
static const WCHAR c_szPktType[]             = L"PktType";
static const WCHAR c_szNetworkNumber[]       = L"NetworkNumber";
static const WCHAR c_szDedicatedRouter[]     = L"DedicatedRouter";
static const WCHAR c_szEnableWANRouter[]     = L"EnableWANRouter";
static const WCHAR c_szInitDatagrams[]       = L"InitDatagrams";
static const WCHAR c_szMaxDatagrams[]        = L"MaxDatagrams";
static const WCHAR c_szReplaceConfigDialog[] = L"ReplaceConfigDialog";
static const WCHAR c_szRipCount[]            = L"RipCount";
static const WCHAR c_szRipTimeout[]          = L"RipTimeout";
static const WCHAR c_szRipUsageTime[]        = L"RipUsageTime";
static const WCHAR c_szSocketEnd[]           = L"SocketEnd";
static const WCHAR c_szSocketStart[]         = L"SocketStart";
static const WCHAR c_szSocketUniqueness[]    = L"SocketUniqueness";
static const WCHAR c_szSourceRouteUsageTime[]= L"SourceRouteUsageTime";
static const WCHAR c_szVirtualNetworkNumber[]= L"VirtualNetworkNumber";

static const DWORD c_dwBindSap            = 0x8137;
static const DWORD c_dwEnableFuncaddr     = 1;
static const DWORD c_dwMaxPktSize         = 0;
static const DWORD c_dwSourceRouteBCast   = 0;
static const DWORD c_dwSourceRouteMCast   = 0;
static const DWORD c_dwSourceRouteDef     = 0;
static const DWORD c_dwSourceRouting      = 1;

static const WCHAR c_szBindSap[]          = L"BindSap";
static const WCHAR c_szEnableFuncaddr[]   = L"EnableFuncaddr";
static const WCHAR c_szMaxPktSize[]       = L"MaxPktSize";
static const WCHAR c_szSourceRouteBCast[] = L"SourceRouteBCast";
static const WCHAR c_szSourceRouteMCast[] = L"SourceRouteMCast";
static const WCHAR c_szSourceRouteDef[]   = L"SourceRouteDef";
static const WCHAR c_szSourceRouting[]    = L"SourceRouting";

static const DWORD c_dwDedicatedRouter      = 0;
static const DWORD c_dwEnableWANRouter      = 0;
static const DWORD c_dwInitDatagrams        = 0xa;
static const DWORD c_dwMaxDatagrams         = 0x32;
static const DWORD c_dwReplaceConfigDialog  = 0;
static const DWORD c_dwRipCount             = 0x5;
static const DWORD c_dwRipTimeout           = 0x1;
static const DWORD c_dwRipUsageTime         = 0xf;
static const DWORD c_dwSocketEnd            = 0x5fff;
static const DWORD c_dwSocketStart          = 0x4000;
static const DWORD c_dwSocketUniqueness     = 0x8;
static const DWORD c_dwSourceRouteUsageTime = 0xf;
static const DWORD c_dwVirtualNetworkNumber = 0;

static const REGBATCH regbatchIpx[] = {
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szDedicatedRouter, REG_DWORD,
         offsetof(IpxParams,dwDedicatedRouter), (BYTE *)&c_dwDedicatedRouter},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szEnableWANRouter, REG_DWORD,
         offsetof(IpxParams,dwEnableWANRouter), (BYTE *)&c_dwEnableWANRouter},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szInitDatagrams, REG_DWORD,
         offsetof(IpxParams,dwInitDatagrams), (BYTE *)&c_dwInitDatagrams},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szMaxDatagrams, REG_DWORD,
         offsetof(IpxParams,dwMaxDatagrams), (BYTE *)&c_dwMaxDatagrams},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szReplaceConfigDialog, REG_DWORD,
         offsetof(IpxParams,dwReplaceConfigDialog), (BYTE *)&c_dwReplaceConfigDialog},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szRipCount, REG_DWORD,
         offsetof(IpxParams,dwRipCount), (BYTE *)&c_dwRipCount},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szRipTimeout, REG_DWORD,
         offsetof(IpxParams,dwRipTimeout), (BYTE *)&c_dwRipTimeout},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szRipUsageTime, REG_DWORD,
         offsetof(IpxParams,dwRipUsageTime), (BYTE *)&c_dwRipUsageTime},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szSocketEnd, REG_DWORD,
         offsetof(IpxParams,dwSocketEnd), (BYTE *)&c_dwSocketEnd},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szSocketStart, REG_DWORD,
         offsetof(IpxParams,dwSocketStart), (BYTE *)&c_dwSocketStart},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szSocketUniqueness, REG_DWORD,
         offsetof(IpxParams,dwSocketUniqueness), (BYTE *)&c_dwSocketUniqueness},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szSourceRouteUsageTime, REG_DWORD,
         offsetof(IpxParams,dwSourceRouteUsageTime), (BYTE *)&c_dwSourceRouteUsageTime},
        {HKEY_LOCAL_MACHINE, c_szIpxParameters, c_szVirtualNetworkNumber, REG_DWORD,
         offsetof(IpxParams,dwVirtualNetworkNumber), (BYTE *)&c_dwVirtualNetworkNumber}};


CNwlnkIPX::CNwlnkIPX() :
    m_pnccMe(NULL),
    m_pNetCfg(NULL),
    m_fNetworkInstall(FALSE),
    m_fAdapterListChanged(FALSE),
    m_fPropertyChanged(FALSE),
    m_eInstallAction(eActUnknown),
    m_pspObj1(NULL),
    m_pspObj2(NULL),
    m_pIpxEnviroment(NULL),
    m_pUnkPropContext(NULL)
{
}

CNwlnkIPX::~CNwlnkIPX()
{
    ReleaseObj(m_pUnkPropContext);
    ReleaseObj(m_pNetCfg);
    ReleaseObj(m_pnccMe);

    delete m_pIpxEnviroment;

    CleanupPropPages();
}


// INetCfgNotify

STDMETHODIMP CNwlnkIPX::Initialize (
    INetCfgComponent* pncc,
    INetCfg* pNetCfg,
    BOOL fInstalling)
{
    HRESULT hr;

    Validate_INetCfgNotify_Initialize(pncc, pNetCfg, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pNetCfg = pNetCfg);

    //
    // Determine if the Netware stack is installed, if so DO NOT
    // install over it.
    //
    if (FIsNetwareIpxInstalled())
    {
        //TODO: EventLog(Novell Netware already installed);
        //$REVIEW: Do we just want to silently proceed an do nothing?
    }

    // Query current settings
    hr = CIpxEnviroment::HrCreate(this, &m_pIpxEnviroment);

    TraceError("CNwlnkIPX::Initialize",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::Upgrade(DWORD, DWORD)
{
    return S_FALSE;
}

STDMETHODIMP CNwlnkIPX::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    HRESULT hr = S_OK;

    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile, pszAnswerSection );

    // Record the fact that this is a network installation
    m_fNetworkInstall = TRUE;
    m_eInstallAction = eActInstall;

    // Only process answer file and install sub-components if the answer file
    // is present.  If the answer file is not present we should already be installed.
    if (NULL == pszAnswerFile)
    {
        goto Error;     // Success case
    }

    // Read the Answer file contents
    hr = HrProcessAnswerFile(pszAnswerFile,
                             pszAnswerSection);
    if (FAILED(hr))
    {
        goto Error;
    }

Error:
    TraceError("CNwlnkIPX::ReadAnswerFile",hr);
    return hr;
}

//
// Function:    CNwlnkIPX::HrProcessAnswerFile
//
// Purpose:     Process the answer file information, merging
//              its contents into the internal information
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CNwlnkIPX::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    CSetupInfFile   csif;
    DWORD           dwData;
    BOOL            fValue;
    HRESULT         hr = S_OK;
    INFCONTEXT      infctx;

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Release all of the adapter specific info
    Assert(NULL != m_pIpxEnviroment);
    m_pIpxEnviroment->ReleaseAdapterInfo();

    // Read the DedicatedRouter parameter
    hr = csif.HrGetStringAsBool(pszAnswerSection, c_szDedicatedRouter,
                                &fValue);
    if (SUCCEEDED(hr))
    {
        m_pIpxEnviroment->SetDedicatedRouter(fValue);
    }

    // Read the EnableWANRouter parameter
    hr = csif.HrGetStringAsBool(pszAnswerSection, c_szEnableWANRouter,
                                &fValue);
    if (SUCCEEDED(hr))
    {
        m_pIpxEnviroment->SetEnableWANRouter(fValue);
    }

    // Read the virtual network number
    hr = csif.HrGetDword(pszAnswerSection, c_szVirtualNetworkNumber, &dwData);
    if (SUCCEEDED(hr))
    {
        m_pIpxEnviroment->SetVirtualNetworkNumber(dwData);
    }

    // Read the property containing the list of adapter sections
    hr = ::HrSetupFindFirstLine(csif.Hinf(), pszAnswerSection,
                                c_szAdapterSections, &infctx);
    if (SUCCEEDED(hr))
    {
        DWORD dwIdx;
        DWORD dwCnt = SetupGetFieldCount(&infctx);
        tstring str;

        // For each adapter in the list read the adapter information
        for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
        {
            hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
            if (FAILED(hr))
            {
                TraceError("CNwlnkIPX::HrProcessAnswerFile - Failed to read adapter section name",hr);
                break;
            }

            hr = HrReadAdapterAnswerFileSection(&csif, str.c_str());
            if (FAILED(hr))
            {
                goto Error;
            }
        }
    }

    hr = S_OK;

Error:
    TraceError("CNwlnkIpx::HrProcessAnswerFile", hr);
    return hr;
}

//
// Function:    CNwlnkIPX::HrReadAdapterAnswerFileSection
//
// Purpose:     Read the adapter answer file section and create
//              the adapter info section if successful
//
// Parameters:
//
// Returns:
//
HRESULT
CNwlnkIPX::HrReadAdapterAnswerFileSection(CSetupInfFile * pcsif,
                                          PCWSTR pszSection)
{
    HRESULT           hr = S_OK;
    CIpxAdapterInfo * pAI = NULL;
    INetCfgComponent* pncc = NULL;
    tstring           str;

    // Read the SpecificTo adapter name
    hr = pcsif->HrGetString(pszSection, c_szSpecificTo, &str);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Search for the specified adapter in the set of existing adapters
    hr = ::HrAnswerFileAdapterToPNCC(m_pNetCfg, str.c_str(), &pncc);
    if (FAILED(hr))
    {
        goto Error;
    }

    // if we found the adapter component object (pncc != NULL) process
    // the adapter section
    if (pncc)
    {
        DWORD       dwIdx;
        DWORD       dwCnt;
        INFCONTEXT  infctx;

        pAI = new CIpxAdapterInfo;
        Assert(NULL != pAI);

        // Query the adapter component info
        hr = ::HrQueryAdapterComponentInfo(pncc, pAI);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Read the PktType (Failure is usually just "not found")
        hr = ::HrSetupFindFirstLine(pcsif->Hinf(), pszSection, c_szPktType,
                                    &infctx);
        if (SUCCEEDED(hr))
        {
            dwCnt = ::SetupGetFieldCount(&infctx);

            // For each adapter in the list read the adapter information
            for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
            {
                hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
                if (FAILED(hr))
                {
                    TraceError("CNwlnkIPX::HrProcessAnswerFile - Failed to read adapter section name",hr);
                    goto Error;
                }

                Assert(!str.empty());

                // Raid # 205831 - Trim any leading "0x"
                //
                if (0 == _wcsnicmp(str.c_str(), c_sz0xPrefix, wcslen(c_sz0xPrefix)))
                {
                    str.erase(0, wcslen(c_sz0xPrefix));
                }

                pAI->PFrmTypeList()->push_back(new tstring(str));
            }
        }

        // Default PktType?
        if (0 == pAI->PFrmTypeList()->size())
        {
            WCHAR szBuf[10];

            // If the info was not found or contained no elements, add the
            // default value.
            wsprintfW(szBuf,L"%X",c_dwPktTypeDefault);
            pAI->PFrmTypeList()->push_back(new tstring(szBuf));
        }

        // Read the NetworkNumber
        hr = ::HrSetupFindFirstLine(pcsif->Hinf(), pszSection, c_szNetworkNumber,
                                    &infctx);
        if (SUCCEEDED(hr))
        {
            dwCnt = SetupGetFieldCount(&infctx);

            // For each adapter in the list read the adapter information
            for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
            {
                hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
                if (FAILED(hr))
                {
                    TraceError("CNwlnkIPX::HrProcessAnswerFile - Failed to read adapter section name",hr);
                    goto Error;
                }

                Assert(!str.empty());
                pAI->PNetworkNumList()->push_back(new tstring(str));
            }
        }

        // Default Network Number?
        if (0 == pAI->PNetworkNumList()->size())
        {
            // If the info was not found or contained no elements, add the
            // default value.
            pAI->PNetworkNumList()->push_back(new tstring(c_sz8Zeros));
        }

        // Ensure that the network number list has the same number of
        // elements as the frame type list.  This can happen when the user
        // configures multiple frame types on 3.51 but only one network
        // number is used.  We'll extend the last network number used
        // and pad it to make the network number list the same size.
        //
        Assert (pAI->PNetworkNumList()->size());

        while (pAI->PNetworkNumList()->size() < pAI->PFrmTypeList()->size())
        {
            pAI->PNetworkNumList()->push_back(
                    new tstring(*pAI->PNetworkNumList()->back()));
        }

        pAI->SetDirty(TRUE);
        m_pIpxEnviroment->AdapterInfoList().push_back(pAI);
        MarkAdapterListChanged();
    }
#ifdef ENABLETRACE
    else
    {
        TraceTag(ttidDefault, "CNwlnkIPX::HrReadAdapterAnswerFileSection - "
            "Adapter \"%S\" not yet installed.",str.c_str());
    }
#endif

    // Normalize return
    hr = S_OK;

Done:
    ReleaseObj(pncc);
    return hr;

Error:
    delete pAI;
    TraceError("CNwlnkIpx::HrReadAdapterAnswerFileSection",hr);
    goto Done;
}

STDMETHODIMP CNwlnkIPX::Install (DWORD)
{
    HRESULT hr;
    CIpxAdapterInfo * pAI;
    ADAPTER_INFO_LIST::iterator iter;

    m_eInstallAction = eActInstall;

    // Mark all the initially detected adapters as dirty
    for (iter = m_pIpxEnviroment->AdapterInfoList().begin();
         iter != m_pIpxEnviroment->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;
        pAI->SetDirty(TRUE);
    }

    // Install NwlnkNb.
    hr = ::HrInstallComponentOboComponent (m_pNetCfg, NULL,
                                           GUID_DEVCLASS_NETTRANS,
                                           c_szInfId_MS_NWNB,
                                           m_pnccMe,
                                           NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Install NwlnkSpx.
    hr = ::HrInstallComponentOboComponent (m_pNetCfg, NULL,
                                           GUID_DEVCLASS_NETTRANS,
                                           c_szInfId_MS_NWSPX,
                                           m_pnccMe,
                                           NULL);

Error:
    TraceError("CNwlnkIPX::Install",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::Removing ()
{
    HRESULT hr;

    m_eInstallAction = eActRemove;

    // Remove NwlnkNb.
    hr = ::HrRemoveComponentOboComponent(m_pNetCfg, GUID_DEVCLASS_NETTRANS,
                                         c_szInfId_MS_NWNB, m_pnccMe);
    if (FAILED(hr))
        goto Error;

    // Remove NwlnkSpx.
    hr = ::HrRemoveComponentOboComponent(m_pNetCfg, GUID_DEVCLASS_NETTRANS,
                                         c_szInfId_MS_NWSPX, m_pnccMe);

Error:
    TraceError("CNwlnkIPX::Removing",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::Validate ( )
{
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::ApplyRegistryChanges ()
{
    HRESULT hr = E_INVALIDARG;

    switch(m_eInstallAction)
    {
    case eActInstall:
        hr = HrCommitInstall();
        break;

    case eActRemove:
        hr = HrCommitRemove();
        break;

    default:    // eActUnknown (Configuration)
        if (m_fAdapterListChanged || m_fPropertyChanged)
        {
            // Update the registry if the adapter list changed
            Assert(m_pIpxEnviroment);
            hr = m_pIpxEnviroment->HrUpdateRegistry();
            if (SUCCEEDED(hr))
            {
                // Send change notification
                hr = HrReconfigIpx();
            }
        }
        break;
    }

    TraceError("CNwlnkIPX::ApplyRegistryChanges",hr);
    return hr;
}


// INetCfgComponentPropertyUi
STDMETHODIMP CNwlnkIPX::SetContext(IUnknown * pUnk)
{
    ReleaseObj(m_pUnkPropContext);
    m_pUnkPropContext = pUnk;
    if (m_pUnkPropContext)
    {
        AddRefObj(m_pUnkPropContext);
    }

    return S_OK;
}


STDMETHODIMP CNwlnkIPX::MergePropPages (
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    HRESULT           hr = S_OK;
    HPROPSHEETPAGE *  ahpsp = NULL;
    PRODUCT_FLAVOR    pf;
    int               nPages = 0;
    CIpxAdapterInfo * pAI = NULL;

    Assert(pahpspPrivate);
    Assert(*pahpspPrivate == NULL);    // Out param init done via Validate above
    *pcPages = 0;

    // Start with new property pages each time.
    CleanupPropPages();

    // Get the current Adapter
    if (NULL != m_pUnkPropContext)
    {
        CIpxAdapterInfo *   pAITmp;
        INetLanConnectionUiInfo * pLanConn = NULL;
        ADAPTER_INFO_LIST::iterator iter;

        hr = m_pUnkPropContext->QueryInterface(IID_INetLanConnectionUiInfo,
                                               reinterpret_cast<LPVOID *>(&pLanConn));
        if (SUCCEEDED(hr))
        {
            GUID guid;
            hr = pLanConn->GetDeviceGuid(&guid);
            ReleaseObj(pLanConn);
            if (FAILED(hr))
            {
                goto Error;
            }

            // Find the adapter in our adapter list
            for (iter = m_pIpxEnviroment->AdapterInfoList().begin();
                 iter != m_pIpxEnviroment->AdapterInfoList().end();
                 iter++)
            {
                pAITmp = *iter;

                if (guid == *pAITmp->PInstanceGuid())
                {
                    pAI = pAITmp;
                    break;
                }
            }

            Assert(SUCCEEDED(hr));

            // If we have an adapter but it's
            // disabled/hidden/deleted we show no pages
            if ((NULL != pAI) && (pAI->FDeletePending() ||
                                  pAI->FDisabled() || pAI->FHidden()))
            {
                Assert(0 == *pcPages);
                hr = S_FALSE;
                goto cleanup;
            }
        }
        else if (E_NOINTERFACE == hr)
        {
            // RAS doesn't have the notion of a current adapter
            hr = S_OK;
        }
    }
    else
    {
        // m_pUnkPropContext should have been set first
        hr = E_UNEXPECTED;
    }

    if (FAILED(hr))
    {
        goto Error;
    }

    // If the product is not workstation (therefore NTAS)
    GetProductFlavor(NULL, &pf);
    if ((PF_WORKSTATION != pf) && (NULL != pAI))
    {
        // Server
#ifdef INCLUDE_RIP_ROUTING
        nPages = 2;
#else
        nPages = 1;
#endif

        // Allocate a buffer large enough to hold the handle to the IPX config.
        // property page.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE) * nPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;       // Alloc failed to no need to free ahpsp
        }

        // Allocate the CPropSheetPage objects
        m_pspObj1 = new CIpxASConfigDlg(this, m_pIpxEnviroment, pAI);
#ifdef INCLUDE_RIP_ROUTING
        m_pspObj2 = new CIpxASInternalDlg(this, m_pIpxEnviroment, pAI);
#endif

        // Create the actual PROPSHEETPAGE for each object.
        // This needs to be done regardless of whether the classes existed before.
        ahpsp[0] = m_pspObj1->CreatePage(DLG_IPXAS_CONFIG, 0);
#ifdef INCLUDE_RIP_ROUTING
        ahpsp[1] = m_pspObj2->CreatePage(DLG_IPXAS_INTERNAL, 0);
#endif
    }
    else
    {
        // Workstation
        nPages = 1;

        // Allocate a buffer large enough to hold the handle to the IPX config.
        // property page.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE) * nPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;       // Alloc failed to no need to free ahpsp
        }

        // Allocate the CPropSheetPage object
        m_pspObj1 = new CIpxConfigDlg(this, m_pIpxEnviroment, pAI);

        // Create the actual PROPSHEETPAGE for each object.
        // This needs to be done regardless of whether the classes existed before.
        ahpsp[0] = m_pspObj1->CreatePage(DLG_IPX_CONFIG, 0);
    }

    if (NULL != ahpsp[0])
    {
        *pahpspPrivate = (LPBYTE)ahpsp;
        *pcPages = nPages;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

cleanup:
    TraceError("CNwlnkIPX::MergePropPages", hr);
    return hr;

Error:
    CoTaskMemFree(ahpsp);
    goto cleanup;
}

VOID CNwlnkIPX::CleanupPropPages()
{
    delete m_pspObj1;
    m_pspObj1 = NULL;

#ifdef INCLUDE_RIP_ROUTING
    delete m_pspObj2;
    m_pspObj2 = NULL;
#endif
}
STDMETHODIMP CNwlnkIPX::ValidateProperties (HWND)
{
    m_fPropertyChanged = TRUE;
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::CancelProperties ()
{
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::ApplyProperties ()
{
    return S_OK;
}


// INetCfgComponentNotifyBinding

STDMETHODIMP CNwlnkIPX::QueryBindingPath ( DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem )
{
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::NotifyBindingPath ( DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem )
{
    HRESULT hr = S_OK;
    INetCfgComponent *pnccFound = NULL;

    Validate_INetCfgBindNotify_NotifyBindingPath( dwChangeFlag, pncbpItem );

    Assert(NULL != m_pIpxEnviroment);

    // Only Interested in lower binding Add's and Remove's
    if (dwChangeFlag & (NCN_ADD | NCN_REMOVE | NCN_ENABLE | NCN_DISABLE))
    {
        CIterNetCfgBindingInterface ncbiIter(pncbpItem);
        INetCfgBindingInterface *pncbi;

        // Enumerate the binding interfaces looking for an Adapter
        while (SUCCEEDED(hr) &&
               (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            INetCfgComponent *pncc;

            hr = pncbi->GetLowerComponent(&pncc);
            if (S_OK == hr)
            {
                GUID guidClass;
                hr = pncc->GetClassGuid(&guidClass);
                if ((S_OK == hr) && (GUID_DEVCLASS_NET == guidClass))
                {
                    ReleaseObj(pnccFound);
                    pnccFound = pncc;   // Transfer Ownership
                    pncc = NULL;
                }
                else
                {
                    ReleaseObj(pncc);
                }
            }

            ReleaseObj(pncbi);
        }

        if (FAILED(hr))
            goto Error;

        // Did we find the Adapter?
        if (pnccFound)
        {
            BOOL                            fFound = FALSE;
            PWSTR                           pszBindName = NULL;
            CIpxAdapterInfo *               pAI;
            ADAPTER_INFO_LIST::iterator     iterAdapterInfo;

            Assert(m_pIpxEnviroment);

            hr = pnccFound->GetBindName(&pszBindName);
            if (S_OK != hr)
            {
                goto Error;
            }

            // Search the adapter list
            for (iterAdapterInfo  = m_pIpxEnviroment->AdapterInfoList().begin();
                 iterAdapterInfo != m_pIpxEnviroment->AdapterInfoList().end();
                 iterAdapterInfo++)
            {
                pAI = *iterAdapterInfo;
                Assert (pAI);

                if (0 == lstrcmpiW(pszBindName, pAI->SzBindName()))
                {
                    fFound = TRUE;
                    break;
                }
            }

            Assert(pszBindName);
            CoTaskMemFree(pszBindName);

            // Apply the appropriate delta to the adapter list
            if (fFound && (dwChangeFlag & NCN_REMOVE))
            {
                // Mark the adapter as Delete Pending
                pAI->SetDeletePending(TRUE);
                m_fAdapterListChanged = TRUE;
            }
            else if (!fFound && (dwChangeFlag & NCN_ADD))
            {
                // Add the adapter to the list
                hr = m_pIpxEnviroment->HrAddAdapter(pnccFound);
                m_fAdapterListChanged = TRUE;
            }
            else if (fFound && (dwChangeFlag & NCN_ADD))
            {
                // Re-enable the adapters existance
                pAI->SetDeletePending(FALSE);
            }

            if (fFound)
            {
                if (dwChangeFlag & NCN_ENABLE)
                {
                    pAI->SetDisabled(FALSE);
                    m_fAdapterListChanged = TRUE;
                }
                else if (dwChangeFlag & NCN_DISABLE)
                {
                    pAI->SetDisabled(TRUE);
                    m_fAdapterListChanged = TRUE;
                }
            }
        }

        if (SUCCEEDED(hr))
            hr = S_OK;      // Normailze return value
    }

Error:
    ReleaseObj(pnccFound);
    TraceError("CNwlnkIPX::NotifyBindingPath",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::GetFrameTypesForAdapter(PCWSTR pszAdapterBindName,
                                                DWORD   cFrameTypesMax,
                                                DWORD*  anFrameTypes,
                                                DWORD*  pcFrameTypes)
{
    Assert(pszAdapterBindName);
    Assert(cFrameTypesMax);
    Assert(anFrameTypes);
    Assert(pcFrameTypes);

    *pcFrameTypes = 0;

    ADAPTER_INFO_LIST::iterator iterAI;

    for (iterAI = m_pIpxEnviroment->AdapterInfoList().begin();
         iterAI != m_pIpxEnviroment->AdapterInfoList().end();
         iterAI++)
    {
        CIpxAdapterInfo *pAI = *iterAI;
        if (0 == lstrcmpW(pszAdapterBindName, pAI->SzBindName()))
        {
            list<tstring *>::iterator iterFrmType;
            for (iterFrmType = pAI->PFrmTypeList()->begin();
                 (iterFrmType != pAI->PFrmTypeList()->end()) &&
                 (*pcFrameTypes < cFrameTypesMax);
                 iterFrmType++)
            {
                // Copy the Frame Type
                tstring *pstr1 = *iterFrmType;
                anFrameTypes[(*pcFrameTypes)++] = DwFromSz(pstr1->c_str(), 16);
            }
            break;
        }
    }
    return S_OK;
}

STDMETHODIMP CNwlnkIPX::GetVirtualNetworkNumber(DWORD* pdwVNetworkNumber)
{
    HRESULT hr = S_OK;

    if (NULL == pdwVNetworkNumber)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    Assert(NULL != m_pIpxEnviroment);
    *pdwVNetworkNumber = m_pIpxEnviroment->DwVirtualNetworkNumber();

Error:
    TraceError("CNwlnkIPX::GetVirtualNetworkNumber",hr);
    return hr;
}

STDMETHODIMP CNwlnkIPX::SetVirtualNetworkNumber(DWORD dwVNetworkNumber)
{
    HRESULT hr;
    Assert(NULL != m_pIpxEnviroment);
    m_pIpxEnviroment->SetVirtualNetworkNumber(dwVNetworkNumber);
    m_fPropertyChanged = TRUE;

    // Tell INetCfg that our component is dirty
    INetCfgComponentPrivate* pinccp = NULL;
    Assert(NULL != m_pnccMe);
    hr = m_pnccMe->QueryInterface(IID_INetCfgComponentPrivate,
                                reinterpret_cast<void**>(&pinccp));
    if (SUCCEEDED(hr))
    {
        hr = pinccp->SetDirty();
        pinccp->Release();
    }

    return hr;
}

//
// Function:    CNwlnkIPX::HrCommitInstall
//
// Purpose:     Commit Installation registry changes to the registry
//
// Parameters:  None
//
// Returns:     HRESULT, S_OK on success
//
//
STDMETHODIMP CNwlnkIPX::HrCommitInstall()
{
    HRESULT hr;

    Assert(m_pIpxEnviroment);
    hr = m_pIpxEnviroment->HrUpdateRegistry();

    TraceError("CNwlnkIPX::HrCommitInstall",hr);
    return hr;
}

//
// Function:    CNwlnkIPX::HrCommitRemove
//
// Purpose:     Remove from the registry settings which were created by this
//              component's installation.
//
// Parameters:  None
//
// Returns:     HRESULT, S_OK on success
//
//
STDMETHODIMP CNwlnkIPX::HrCommitRemove()
{
    // Remove "NwlnkIpx" from the:
    //    System\CurrentControlSet\Control\ServiceProvider\Order\ProviderOrder value
    (void) HrRegRemoveStringFromMultiSz(c_szSvcNwlnkIpx, HKEY_LOCAL_MACHINE,
                                        c_szSrvProvOrderKey,
                                        c_szProviderOrderVal,
                                        STRING_FLAG_REMOVE_ALL);

    return S_OK;
}

CIpxAdapterInfo::CIpxAdapterInfo() : m_dwMediaType(ETHERNET_MEDIA),
                                     m_fDeletePending(FALSE),
                                     m_fDisabled(FALSE),
                                     m_fDirty(FALSE),
                                     m_dwCharacteristics(0L)
{
    ZeroMemory(&m_guidInstance, sizeof(m_guidInstance));
}

CIpxAdapterInfo::~CIpxAdapterInfo()
{
    DeleteColString(&m_lstpstrFrmType);
    DeleteColString(&m_lstpstrNetworkNum);
}

CIpxEnviroment::CIpxEnviroment(CNwlnkIPX *pno)
{
    Assert(NULL != pno);
    m_pno = pno;            // Retain the Notification object

    m_fRipInstalled = FALSE;
    m_fEnableRip = FALSE;
    m_dwRipValue = 0;
    ZeroMemory(&m_IpxParams, sizeof(m_IpxParams));
}

CIpxEnviroment::~CIpxEnviroment()
{
    ReleaseAdapterInfo();

    // Note: Do nothing with the m_pno notification object, we just borrowed it
}

//
//  Member:     CIpxEnviroment::ReleaseAdapterInfo
//
//  Purpose:    Release the adapter info
//
//  Arguments:  none
//
//  Returns:    nothing
//
void CIpxEnviroment::ReleaseAdapterInfo()
{
    CIpxAdapterInfo *pAI;

    while (!m_lstpAdapterInfo.empty())
    {
        pAI = m_lstpAdapterInfo.front();
        m_lstpAdapterInfo.pop_front();
        delete pAI;
    }
}

//
//  Member:     CIpxEnviroment::DwCountValidAdapters
//
//  Purpose:    Return the count of adapters not marked as delete pending,
//              disabled, or hidden.
//
//  Arguments:  none
//
//  Returns:    nothing
//
DWORD CIpxEnviroment::DwCountValidAdapters()
{
    DWORD dwCount = 0;
    ADAPTER_INFO_LIST::iterator iterAI;

    for (iterAI = AdapterInfoList().begin();
         iterAI != AdapterInfoList().end();
         iterAI++)
    {
        CIpxAdapterInfo *pAI = *iterAI;

        if (pAI->FDeletePending() || pAI->FDisabled() || pAI->FHidden())
            continue;

        dwCount++;
    }

    return dwCount;
}

HRESULT CIpxEnviroment::HrOpenIpxAdapterSubkey(HKEY *phkey, BOOL fCreateIfMissing)
{
    DWORD   dwDisposition;
    HRESULT hr;
    tstring str;

    // Open the NetCard key
    str = c_szIpxParameters;
    str += L"\\";
    str += c_szAdapters;
    if (fCreateIfMissing)
    {
        hr = ::HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, str.c_str(),
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                phkey, &dwDisposition);
    }
    else
    {
        hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, str.c_str(), KEY_READ, phkey );
    }
    if (S_OK != hr)
        goto Error;

Error:
    TraceError("CIpxEnviroment::HrOpenIpxAdapterSubkey",
                HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr ? S_OK : hr);
    return hr;
}

HRESULT CIpxEnviroment::HrOpenIpxAdapterSubkeyEx(PCWSTR pszKeyName,
                                                 DWORD dwAccess,
                                                 BOOL fCreateIfMissing,
                                                 HKEY *phkey)
{
    HRESULT hr;
    HKEY    hkeyRoot = NULL;

    Assert(pszKeyName);
    Assert(0 < lstrlenW(pszKeyName));

    // Open the NetCard key
    hr = HrOpenIpxAdapterSubkey(&hkeyRoot, fCreateIfMissing);
    if (S_OK != hr)
    {
        goto Error;
    }

    // Open the adapter specific subkey (creating if requested and required)
    if (fCreateIfMissing)
    {
        DWORD dwDisposition;

        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKeyName,
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                phkey, &dwDisposition);
    }
    else
    {
        // Try exact match first, it's faster
        hr = HrRegOpenKeyEx( hkeyRoot, pszKeyName, dwAccess, phkey );
    }

Error:
    RegSafeCloseKey(hkeyRoot);
    TraceError("CIpxEnviroment::HrOpenIpxAdapterSubkeyEx",
                HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr ? S_OK : hr);
    return hr;
}

HRESULT CIpxEnviroment::HrGetIpxParams()
{
    RegReadValues(celems(regbatchIpx), regbatchIpx, (BYTE *)&m_IpxParams,
                  KEY_READ);
    return S_OK;
}

HRESULT CIpxEnviroment::HrGetOneAdapterInfo(INetCfgComponent *pNCC,
                                            CIpxAdapterInfo **ppAI)
{
    HKEY              hkeyCard = NULL;
    HRESULT           hr = S_OK;
    CIpxAdapterInfo * pAI = NULL;

    Assert(NULL != pNCC);

    // Init the return value
    *ppAI = NULL;

    pAI = (CIpxAdapterInfo *)new CIpxAdapterInfo;
    Assert(NULL != pAI);

    if (pAI == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Query the adapter component info
    hr = ::HrQueryAdapterComponentInfo(pNCC, pAI);
    if (FAILED(hr))
        goto Error;

    // Open the IPX subkey specific to this adapter
    hr = HrOpenIpxAdapterSubkeyEx(pAI->SzBindName(), KEY_READ, FALSE,
                                  &hkeyCard);
    if (S_OK == hr)
    {
        // Get the packet types
        //
        hr = HrRegQueryColString(hkeyCard, c_szPktType,
                &pAI->m_lstpstrFrmType);
        if (S_OK != hr)
        {
            goto Error;
        }

        // Get the network numbers
        //
        hr = HrRegQueryColString(hkeyCard, c_szNetworkNumber,
                &pAI->m_lstpstrNetworkNum);
        if (S_OK != hr)
        {
            goto Error;
        }
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // Normalize any ERROR_FILE_NOT_FOUND errors
        hr = S_OK;
    }
    else if (FAILED(hr))
    {
        goto Error;
    }

    // Default PktType?
    if (0 == pAI->PFrmTypeList()->size())
    {
        WCHAR szBuf[10];

        // If the info was not found or contained no elements, add the
        // default value.
        wsprintfW(szBuf,L"%X",c_dwPktTypeDefault);
        pAI->PFrmTypeList()->push_back(new tstring(szBuf));
    }

    // Default Network Number?
    if (0 == pAI->PNetworkNumList()->size())
    {
        // If the info was not found or contained no elements, add the
        // default value.
        pAI->PNetworkNumList()->push_back(new tstring(c_sz8Zeros));
    }

    // Update the return value with the new object
    *ppAI = pAI;

Done:
    ::RegSafeCloseKey(hkeyCard);
    TraceError("CIpxEnviroment::HrGetOneAdapterInfo",hr);
    return hr;

Error:
    delete pAI;
    goto Done;
}

HRESULT CIpxEnviroment::HrGetAdapterInfo()
{
    HRESULT                hr = S_OK;
    CIpxAdapterInfo *      pAI = NULL;
    INetCfgComponent*      pncc = NULL;
    INetCfgComponent*      pnccUse = NULL;

    // Find each netcard, to do so, trace the bindings to their end
    // If the endpoint is a netcard then add it to the list
    CIterNetCfgBindingPath ncbpIter(m_pno->m_pnccMe);
    INetCfgBindingPath*    pncbp;

    while (SUCCEEDED(hr) && (S_OK == (hr = ncbpIter.HrNext (&pncbp))))
    {
        // Iterate the binding interfaces of this path.
        CIterNetCfgBindingInterface ncbiIter(pncbp);
        INetCfgBindingInterface* pncbi;

        while (SUCCEEDED(hr) && (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            // Retrieve the lower component
            hr = pncbi->GetLowerComponent(&pncc);
            if (S_OK == hr)
            {
                GUID guidClass;

                // Is it an Adapter?
                hr = pncc->GetClassGuid(&guidClass);
                if ((S_OK == hr) && (guidClass == GUID_DEVCLASS_NET))
                {
                    ReleaseObj(pnccUse);
                    pnccUse = pncc;
                    pncc = NULL;
                }
                else
                {
                    // Release the lower component
                    ReleaseObj(pncc);
                }
            }

            // Release the binding interface
            ReleaseObj (pncbi);
        }

        if (NULL != pnccUse)
        {
            // Query the Adapter information
            hr = HrGetOneAdapterInfo(pnccUse, &pAI);
            if (SUCCEEDED(hr))
            {
                if (S_FALSE == pncbp->IsEnabled())
                    pAI->SetDisabled(TRUE);

                // Add this Adapter to the list
                m_lstpAdapterInfo.push_back(pAI);
            }

            ReleaseObj(pnccUse);
            pnccUse = NULL;
        }

        // Release the binding path
        ReleaseObj (pncbp);
    }

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceError("CIpxEnviroment::HrGetNetCardInfo",hr);
    return hr;
}

HRESULT CIpxEnviroment::HrWriteOneAdapterInfo(HKEY hkeyAdapters,
                                              CIpxAdapterInfo* pAI)
{
    DWORD           dwDisposition;
    HRESULT         hr;
    HKEY            hkeyCard = NULL;
    PWSTR           psz = NULL;

    // Open the IPX subkey for this specific adapter
    hr = ::HrRegCreateKeyEx(hkeyAdapters, pAI->SzBindName(), REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL, &hkeyCard, &dwDisposition);
    if (S_OK != hr)
        goto Error;

    // Write the packet info
    // Generate the data to write
    AssertSz(pAI->m_lstpstrFrmType.size(),"Did not expect an empty list, default value missing");
    ColStringToMultiSz(pAI->m_lstpstrFrmType, &psz);
    if (psz)
    {
        hr = ::HrRegSetMultiSz(hkeyCard, c_szPktType, psz);
        if (S_OK != hr)
            goto Error;

        delete [] psz;
        psz = NULL;
    }
#ifdef DBG
    else
    {
        AssertSz(0,"PacketType value is NULL?");
    }
#endif

    // Write the network number
    AssertSz(pAI->m_lstpstrNetworkNum.size(),"Did not expect an empty list, default value missing");
    ColStringToMultiSz(pAI->m_lstpstrNetworkNum, &psz);
    if (psz)
    {
        hr = ::HrRegSetMultiSz(hkeyCard, c_szNetworkNumber, psz);
        if (S_OK != hr)
            goto Error;

        delete [] psz;
        psz = NULL;
    }
#ifdef DBG
    else
    {
        AssertSz(0,"NetworkNumber value is NULL?");
    }
#endif

    // If the key for this adapter didn't exist previously
    // write the base set of values
    if (REG_CREATED_NEW_KEY == dwDisposition)
    {
        struct
        {
            PCWSTR pszProp;
            DWORD  dwValue;
        } rgAdapterSettings[] = {{c_szBindSap,c_dwBindSap},
                                 {c_szEnableFuncaddr,c_dwEnableFuncaddr},
                                 {c_szMaxPktSize,c_dwMaxPktSize},
                                 {c_szSourceRouteBCast,c_dwSourceRouteBCast},
                                 {c_szSourceRouteMCast,c_dwSourceRouteMCast},
                                 {c_szSourceRouteDef,c_dwSourceRouteDef},
                                 {c_szSourceRouting,c_dwSourceRouting}};

        for (int nIdx=0; nIdx<celems(rgAdapterSettings); nIdx++)
        {
            hr = ::HrRegSetDword(hkeyCard, rgAdapterSettings[nIdx].pszProp,
                                 rgAdapterSettings[nIdx].dwValue);
            if (FAILED(hr))
            {
                goto Error;
            }
        }
    }

Error:
    delete [] psz;
    ::RegSafeCloseKey(hkeyCard);
    TraceError("CIpxEnviroment::HrWriteOneAdapterInfo",hr);
    return hr;
}

HRESULT CIpxEnviroment::HrWriteAdapterInfo()
{
    HRESULT                         hr = S_OK;
    HKEY                            hkeyAdapters = NULL;
    ADAPTER_INFO_LIST::iterator     iterAdapterInfo;
    CIpxAdapterInfo *               pAI;

    // Create the IPX Adapter Subkey
    hr = HrOpenIpxAdapterSubkey(&hkeyAdapters, TRUE);
    if (S_OK != hr)
        goto Error;

    // Now commit the contents of the adapter list to the registry
    for (iterAdapterInfo = m_lstpAdapterInfo.begin();
         iterAdapterInfo != m_lstpAdapterInfo.end();
         iterAdapterInfo++)
    {
        pAI = *iterAdapterInfo;

        // Write out all adapter's not marked with delete pending
        if (pAI->FDeletePending())
        {
            // Remove the NwlnkIpx\Adapter\{bindname} tree
            (VOID)::HrRegDeleteKeyTree(hkeyAdapters, pAI->SzBindName());
        }
        else if (pAI->IsDirty())
        {
            hr = HrWriteOneAdapterInfo(hkeyAdapters, pAI);
            if (S_OK != hr)
                goto Error;
        }
    }

Error:
    ::RegSafeCloseKey(hkeyAdapters);
    TraceError("CIpxEnviroment::HrWriteAdapterInfo",hr);
    return hr;
}

HRESULT CIpxEnviroment::HrCreate(CNwlnkIPX *pno, CIpxEnviroment ** ppIpxEnviroment)
{
    HRESULT          hr;
    CIpxEnviroment * pIpxEnviroment = (CIpxEnviroment *)new CIpxEnviroment(pno);

    if (pIpxEnviroment == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    *ppIpxEnviroment = NULL;

    // Get the Ipx Parameter Key info
    hr = pIpxEnviroment->HrGetIpxParams();
    if (FAILED(hr))
        goto Error;

    // Collect the Adapter Info for all cards installed
    hr = pIpxEnviroment->HrGetAdapterInfo();
    if (FAILED(hr))
        goto Error;

    *ppIpxEnviroment = pIpxEnviroment;

Complete:
    TraceError("CIpxEnviroment::HrCreate",hr);
    return hr;

Error:
    delete pIpxEnviroment;
    goto Complete;
}

HRESULT CIpxEnviroment::HrUpdateRegistry()
{
    HRESULT hr;

    // Commit the registry changes
    hr = ::HrRegWriteValues(celems(regbatchIpx), regbatchIpx,
                            (BYTE *)&m_IpxParams, REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS);
    if (S_OK != hr)
        goto Error;

    // Write adapter info to registry
    hr = HrWriteAdapterInfo();

Error:
    TraceError("CIpxEnviroment::HrUpdateRegistry",hr);
    return hr;
}

VOID CIpxEnviroment::RemoveAdapter(CIpxAdapterInfo * pAI)
{
    Assert(NULL != pAI);
    m_lstpAdapterInfo.remove(pAI);
    delete pAI;
}

HRESULT CIpxEnviroment::HrAddAdapter(INetCfgComponent * pncc)
{
    HRESULT hr = S_OK;
    CIpxAdapterInfo * pAI = NULL;

    hr = HrGetOneAdapterInfo(pncc, &pAI);
    if (FAILED(hr))
        goto Error;

    if (SUCCEEDED(hr))
        hr = S_OK;      // Normalize return

    // Add the Adapter to the list
    pAI->SetDirty(TRUE);
    m_lstpAdapterInfo.push_back(pAI);

Error:
    TraceError("CIpxEnviroment::HrAddAdapter",hr);
    return hr;
}

//$ REVIEW - Start - This is moving to windows\inc\ipxpnp.h
#define IPX_RECONFIG_VERSION        0x1

#define RECONFIG_AUTO_DETECT        1
#define RECONFIG_MANUAL             2
#define RECONFIG_PREFERENCE_1       3
#define RECONFIG_NETWORK_NUMBER_1   4
#define RECONFIG_PREFERENCE_2       5
#define RECONFIG_NETWORK_NUMBER_2   6
#define RECONFIG_PREFERENCE_3       7
#define RECONFIG_NETWORK_NUMBER_3   8
#define RECONFIG_PREFERENCE_4       9
#define RECONFIG_NETWORK_NUMBER_4   10

#define RECONFIG_PARAMETERS         10

//
// Main configuration structure.
//

struct RECONFIG
{
   ULONG    ulVersion;
   BOOLEAN  InternalNetworkNumber;
   BOOLEAN  AdapterParameters[RECONFIG_PARAMETERS];
};

//$ REVIEW - End - This is moving to windows\inc\ipxpnp.h

//+---------------------------------------------------------------------------
//
//  Member:     CNwlnkIPX::HrReconfigIpx
//
//  Purpose:    Notify Ipx of configuration changes
//
//  Arguments:  none
//
//  Returns:    HRESULT, S_OK on success, NETCFG_S_REBOOT on failure
//
HRESULT CNwlnkIPX::HrReconfigIpx()
{
    HRESULT           hrRet;
    HRESULT           hr = S_OK;
    INT               nIdx;
    RECONFIG          Config;
    CIpxAdapterInfo * pAI;
    PRODUCT_FLAVOR    pf;
    ADAPTER_INFO_LIST::iterator iter;
    ULONG             ulConfigSize;

    if (0 == m_pIpxEnviroment->DwCountValidAdapters())
    {
        return S_OK;     // Nothing to configure
    }

    ZeroMemory(&Config, sizeof(Config));
    Config.ulVersion = IPX_RECONFIG_VERSION;

    // Workstation or server?
    GetProductFlavor(NULL, &pf);
    if (PF_WORKSTATION != pf)
    {
        Config.InternalNetworkNumber = TRUE;
        // Now submit the global reconfig notification
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szSvcNwlnkIpx, c_szEmpty,
                                      &Config, sizeof(RECONFIG));
        if (FAILED(hrRet) &&
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    Config.InternalNetworkNumber = FALSE;

    // For each adapter...
    for (nIdx=0, iter = m_pIpxEnviroment->AdapterInfoList().begin();
         iter != m_pIpxEnviroment->AdapterInfoList().end();
         nIdx++, iter++)
    {
        pAI = *iter;

        if (pAI->FDeletePending() || pAI->FDisabled() || !pAI->IsDirty())
            continue;

        ZeroMemory(&Config.AdapterParameters, sizeof(Config.AdapterParameters));

        if (AUTO == pAI->DwFrameType())
            Config.AdapterParameters[RECONFIG_AUTO_DETECT] = TRUE;
        else
            Config.AdapterParameters[RECONFIG_MANUAL] = TRUE;

        // We are performing a shortcut here by setting a range to TRUE
        // based on the number of frames in use.  For example if there is
        // only one frame in use we need to set both:
        // RECONFIG_PREFERENCE_1 and RECONFIG_NETWORK_NUMBER_1 to TRUE
        Assert(RECONFIG_PREFERENCE_1 + 1 == RECONFIG_NETWORK_NUMBER_1);
        Assert(RECONFIG_NETWORK_NUMBER_1 + 1 == RECONFIG_PREFERENCE_2);
        Assert(RECONFIG_PREFERENCE_2 + 1 == RECONFIG_NETWORK_NUMBER_2);
        Assert(RECONFIG_NETWORK_NUMBER_2 + 1 == RECONFIG_PREFERENCE_3);
        Assert(RECONFIG_PREFERENCE_3 + 1 == RECONFIG_NETWORK_NUMBER_3);
        Assert(RECONFIG_NETWORK_NUMBER_3 + 1 == RECONFIG_PREFERENCE_4);
        Assert(RECONFIG_PREFERENCE_4 + 1 == RECONFIG_NETWORK_NUMBER_4);

        INT nCntFrms = pAI->PFrmTypeList()->size();
        if ((0 < nCntFrms) && (4 >= nCntFrms))
        {
            memset(&Config.AdapterParameters[RECONFIG_PREFERENCE_1],
                   TRUE, sizeof(BOOLEAN) * nCntFrms * 2);
        }

        Assert(lstrlenW(pAI->SzBindName()));

        // Now submit the reconfig notification
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szSvcNwlnkIpx, pAI->SzBindName(),
                                      &Config, sizeof(RECONFIG));
        if (FAILED(hrRet) &&
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    TraceError("CNwlnkIPX::HrReconfigIpx",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\nwlnkutl.h ===
#pragma once


BOOL FIsNetwareIpxInstalled(
    VOID);

DWORD DwFromSz(PCWSTR sz, int nBase);

DWORD DwFromLstPtstring(const list<tstring *> & lstpstr, DWORD dwDefault,
                        int nBase);

void UpdateLstPtstring(list<tstring *> & lstpstr, DWORD dw);

void HexSzFromDw(PWSTR sz, DWORD dw);

class CIpxAdapterInfo;

HRESULT HrQueryAdapterComponentInfo(INetCfgComponent *pncc,
                                    CIpxAdapterInfo * pAI);

// Note this prototype is used privately also by atlkcfg in atlkobj.cpp
// update there if this api changes
HRESULT HrAnswerFileAdapterToPNCC(INetCfg *pnc, PCWSTR szAdapterId,
                                  INetCfgComponent** ppncc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\nwlnknb.cpp ===
// nwlnknb.cpp : Implementation of CNwlnkNB

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "ncreg.h"
#include "ncsvc.h"
#include "nwlnknb.h"
#include "nwlnkipx.h"

CNwlnkNB::CNwlnkNB() :
    m_pnccMe(NULL),
    m_pNetCfg(NULL),
    m_eInstallAction(eActUnknown),
    m_eNbState(eStateNoChange)
{
}

CNwlnkNB::~CNwlnkNB()
{
    ReleaseObj(m_pNetCfg);
    ReleaseObj(m_pnccMe);
}

// INetCfgNotify

STDMETHODIMP CNwlnkNB::Initialize (
    INetCfgComponent* pncc,
    INetCfg* pNetCfg,
    BOOL fInstalling)
{
    Validate_INetCfgNotify_Initialize(pncc, pNetCfg, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pNetCfg = pNetCfg);

    // See if DNS is already installed.  If it is we need to be disabled
    if (fInstalling &&
        (S_OK == m_pNetCfg->FindComponent(L"MS_DNSServer", NULL)))
    {
        m_eNbState = eStateDisable;
    }

    return S_OK;
}

STDMETHODIMP CNwlnkNB::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile, pszAnswerSection);
    return S_OK;
}

STDMETHODIMP CNwlnkNB::Install (
    DWORD dwSetupFlags)
{
    m_eInstallAction = eActInstall;
    return S_OK;
}

STDMETHODIMP CNwlnkNB::Removing ()
{
    m_eInstallAction = eActRemove;
    return S_OK;
}

STDMETHODIMP CNwlnkNB::Validate ()
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::ApplyRegistryChanges ()
{
    UpdateBrowserDirectHostBinding ();

    if ((eActRemove != m_eInstallAction) &&
        (eStateNoChange != m_eNbState))
    {
        UpdateNwlnkNbStartType();
    }

    return S_OK;
}

// INetCfgSystemNotify

STDMETHODIMP CNwlnkNB::GetSupportedNotifications (
    DWORD* pdwSupportedNotifications )
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications(pdwSupportedNotifications);

    // Want to know when DNS comes and goes
    *pdwSupportedNotifications = NCN_NETSERVICE | NCN_ADD | NCN_REMOVE;
    return S_OK;
}

STDMETHODIMP CNwlnkNB::SysQueryBindingPath (
    DWORD dwChangeFlag,
    INetCfgBindingPath* pIPath)
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::SysQueryComponent (
    DWORD dwChangeFlag,
    INetCfgComponent* pIComp)
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::SysNotifyBindingPath (
    DWORD dwChangeFlag,
    INetCfgBindingPath* pIPath)
{
    return S_OK;
}

STDMETHODIMP CNwlnkNB::SysNotifyComponent (
    DWORD dwChangeFlag,
    INetCfgComponent* pnccItem)
{
    Validate_INetCfgSystemNotify_SysNotifyComponent(dwChangeFlag, pnccItem);

    // Assume we won't be dirty as a result of this notification.
    //
    HRESULT hr = S_FALSE;

    // If this component does not identify itself as DNS then skip it...
    if (FIsComponentId(L"MS_DNSServer", pnccItem))
    {
        // Disable/Enable NetBIOS when DNS is Added/Removed
        if (dwChangeFlag & NCN_ADD)
        {
            // Disable and shutdown NwlnkNb
            m_eNbState = eStateDisable;
            hr = S_OK;
        }
        else if (dwChangeFlag & NCN_REMOVE)
        {
            // Re-enable NwlnkNb
            m_eNbState = eStateEnable;
            hr = S_OK;
        }
    }

    return hr;
}


//
// Function:    CNwlnkNB::UpdateNwlnkNbStartType
//
// Purpose:     Enable or disable NwlnkNb
//
//
VOID
CNwlnkNB::UpdateNwlnkNbStartType(
    VOID)
{
    HRESULT hr;
    CServiceManager scm;
    CService        svc;

    hr = scm.HrOpenService(&svc, L"NwlnkNb");
    if (S_OK == hr)
    {
        if (eStateDisable == m_eNbState)
        {
            (VOID) svc.HrSetStartType(SERVICE_DISABLED);
            svc.Close();

            (VOID) scm.HrStopServiceNoWait(L"NwlnkNb");
        }
        else if (eStateEnable == m_eNbState)
        {
            (VOID) svc.HrSetStartType(SERVICE_DEMAND_START);
        }
    }
}

VOID
CNwlnkNB::UpdateBrowserDirectHostBinding(
    VOID)
{
    HRESULT hr;
    BOOL fBound = FALSE;

    // We don't need to check if client is bound to us if we are being
    // removed.
    //
    if (eActRemove != m_eInstallAction)
    {
        INetCfgComponent* pMsClient;

        hr = m_pNetCfg->FindComponent (L"ms_msclient", &pMsClient);
        if (S_OK == hr)
        {
            INetCfgComponentBindings* pMsClientBindings;
            hr = pMsClient->QueryInterface (IID_INetCfgComponentBindings,
                                (VOID**)&pMsClientBindings);
            if (S_OK == hr)
            {
                fBound = (S_OK == pMsClientBindings->IsBoundTo (m_pnccMe));

                ReleaseObj (pMsClientBindings);
            }

            ReleaseObj (pMsClient);
        }
    }

    HKEY hkey;

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\Browser\\Parameters",
            KEY_ALL_ACCESS, &hkey);

    if (S_OK == hr)
    {
        static const WCHAR c_szDirectHostBinding[] = L"DirectHostBinding";

        if (fBound)
        {
            // Write the DirectHostBinding info since we are directly bound
            //
            hr = HrRegSetMultiSz (hkey,
                    c_szDirectHostBinding,
                    L"\\Device\\NwlnkIpx\0\\Device\\NwlnkNb\0");
        }
        else
        {
            // Remove the DirectHostBinding value
            //
            (VOID) HrRegDeleteValue (hkey, c_szDirectHostBinding);
        }

        RegCloseKey (hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\nwlnknb.h ===
#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"


class ATL_NO_VTABLE CNwlnkNB :
    public CComObjectRoot,
    public CComCoClass<CNwlnkNB, &CLSID_CNwlnkNB>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal
{
public:
    CNwlnkNB();
    ~CNwlnkNB();

    BEGIN_COM_MAP(CNwlnkNB)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNwlnkNB)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NWLNKNB)

    // Enable/Disable Action
    enum NBSTATE      {eStateNoChange, eStateDisable, eStateEnable};

    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};


// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

private:
    VOID UpdateNwlnkNbStartType(VOID);
    VOID UpdateBrowserDirectHostBinding(VOID);

private:
    INetCfgComponent* m_pnccMe;
    INetCfg*          m_pNetCfg;
    INSTALLACTION     m_eInstallAction;
    NBSTATE           m_eNbState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\nwlnkipx.h ===
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <notifval.h>
#include <ncsetup.h>
#include "nwlnkutl.h"
#include "resource.h"
#include "nwlnkhlp.h"

// Forward references
class CIpxAdapterInfo;
class CNwlnkIPX;
class CIpxConfigDlg;
class CIpxASConfigDlg;

typedef list<tstring *> TSTRING_LIST;


/////////////////////////////////////////////////////////////////////////////
// nwlnkcfg

// Prototype shared constants
extern const WCHAR c_sz8Zeros[];
extern const DWORD c_dwPktTypeDefault;
extern const WCHAR c_szMediaType[];

// Maximum length of a network number
#define MAX_NETNUM_SIZE 8

// Frame Types
#define ETHERNET    0x0
#define F802_3      0x1
#define F802_2      0x2
#define SNAP        0x3
#define ARCNET      0x4
#define AUTO        0xff

// Media Types
#define ETHERNET_MEDIA  0x1
#define TOKEN_MEDIA     0x2
#define FDDI_MEDIA      0x3
#define ARCNET_MEDIA    0x8

class CIpxAdapterInfo
{
    friend class CIpxEnviroment;
    friend class CIpxConfigDlg;
    friend class CIpxASConfigDlg;
public:
    CIpxAdapterInfo();
    ~CIpxAdapterInfo();

    void              SetDeletePending(BOOL f) {m_fDeletePending = f;}
    BOOL              FDeletePending() {return m_fDeletePending;}

    void              SetDisabled(BOOL f) {m_fDisabled = f;}
    BOOL              FDisabled() {return m_fDisabled;}

    void              SetCharacteristics(DWORD dw) {m_dwCharacteristics = dw;}
    BOOL              FHidden() {return !!(NCF_HIDDEN & m_dwCharacteristics);}

    void              AdapterChanged();

    DWORD             DwMediaType() {return m_dwMediaType;}
    void              SetMediaType(DWORD dw) {m_dwMediaType=dw;}

    PCWSTR            SzAdapterDesc() {return m_strAdapterDesc.c_str();}
    void              SetAdapterDesc(PCWSTR psz) {m_strAdapterDesc = psz;}
    PCWSTR            SzBindName() {return m_strBindName.c_str();}
    void              SetBindName(PCWSTR psz) {m_strBindName = psz;}

    DWORD             DwFrameType()
                                {return DwFromLstPtstring(m_lstpstrFrmType,
                                                          AUTO, 16);}
    DWORD             DwNetworkNumber()
                                {return DwFromLstPtstring(m_lstpstrNetworkNum,
                                                          0, 16);}

    TSTRING_LIST *    PFrmTypeList() {return &m_lstpstrFrmType;}
    TSTRING_LIST *    PNetworkNumList() {return &m_lstpstrNetworkNum;}

    GUID *            PInstanceGuid() {return &m_guidInstance;}

    BOOL              IsDirty() {return m_fDirty;}
    VOID              SetDirty(BOOL f) {m_fDirty = f;}

private:
    BOOL              m_fDirty;

    // m_fDisabled is a boolean that, when TRUE, indicates this adapter
    // is currently disabled
    BOOL              m_fDisabled;

    // m_fDeletePending is a boolean that, when TRUE, indicates this adapter
    // is being removed from the adapter list (eventually)
    BOOL              m_fDeletePending;

    // m_dwCharacteristics contains the adapter's characteristic settings
    DWORD             m_dwCharacteristics;

    DWORD             m_dwMediaType;
    GUID              m_guidInstance;
    tstring           m_strAdapterDesc;
    tstring           m_strBindName;
    TSTRING_LIST      m_lstpstrFrmType;
    TSTRING_LIST      m_lstpstrNetworkNum;
};

typedef list<CIpxAdapterInfo *> ADAPTER_INFO_LIST;

typedef struct _tagIpxParams
{
    DWORD dwDedicatedRouter;
    DWORD dwEnableWANRouter;
    DWORD dwInitDatagrams;
    DWORD dwMaxDatagrams;
    DWORD dwReplaceConfigDialog;
    DWORD dwRipCount;
    DWORD dwRipTimeout;
    DWORD dwRipUsageTime;
    DWORD dwSocketEnd;
    DWORD dwSocketStart;
    DWORD dwSocketUniqueness;
    DWORD dwSourceRouteUsageTime;
    DWORD dwVirtualNetworkNumber;
} IpxParams;

class CIpxEnviroment
{
private:
    CIpxEnviroment(CNwlnkIPX *);
    HRESULT HrGetIpxParams();
    HRESULT HrGetAdapterInfo();
    HRESULT HrWriteAdapterInfo();
    HRESULT HrOpenIpxAdapterSubkey(HKEY *phkey, BOOL fCreate);
    HRESULT HrOpenIpxAdapterSubkeyEx(PCWSTR pszKeyName,
                                            DWORD dwAccess,
                                            BOOL fCreate, HKEY *phkey);

public:
    ~CIpxEnviroment();

    // Create and initialize a CIpxEnviroment instance
    static HRESULT   HrCreate(CNwlnkIPX *, CIpxEnviroment **);

    // Call to update registry
    HRESULT          HrUpdateRegistry();

    // Return a reference to the Adapter list
    ADAPTER_INFO_LIST & AdapterInfoList() {return m_lstpAdapterInfo;}

    // Create an CIpxAdapterInfo instance from settings in the registry
    HRESULT   HrGetOneAdapterInfo(INetCfgComponent * pNCC,
                                         CIpxAdapterInfo ** ppAI);

    // Write one CIpxAdapterInfo to the registry
    HRESULT   HrWriteOneAdapterInfo(HKEY hkey, CIpxAdapterInfo* pAI);

    // Remove an adapter from the list
    VOID RemoveAdapter(CIpxAdapterInfo * pAI);

    // Add an adapter to the list
    HRESULT HrAddAdapter(INetCfgComponent * pncc);

    DWORD DwCountValidAdapters();

    DWORD DwVirtualNetworkNumber() {return m_IpxParams.dwVirtualNetworkNumber;}
    void  SetVirtualNetworkNumber(DWORD dw) {m_IpxParams.dwVirtualNetworkNumber = dw;}

    BOOL  FRipInstalled() {return m_fRipInstalled;}
    BOOL  FRipEnabled()   {return m_fEnableRip;}
    void  ChangeRipEnabling(BOOL fEnable, DWORD dwRipVal)
                          { m_fEnableRip = fEnable;
                            m_dwRipValue = dwRipVal; }

    void  SetDedicatedRouter(BOOL f) {m_IpxParams.dwDedicatedRouter = (f ? 1 : 0);}
    void  SetEnableWANRouter(BOOL f) {m_IpxParams.dwEnableWANRouter = (f ? 1 : 0);}

    void  ReleaseAdapterInfo();

private:
    CNwlnkIPX *         m_pno;

    BOOL                m_fRipInstalled;    // NwlnkRip\Parameters
    BOOL                m_fEnableRip;       // NwlnkRip\Parameters

    DWORD               m_dwRipValue;       // NetbiosRouting = {1,0}

    IpxParams           m_IpxParams;        // NwlnkIpx\Parameters
    ADAPTER_INFO_LIST   m_lstpAdapterInfo;  // list of Adapters
};

// Pair Specific Sets of FRAME ID Strings with FRAME ID Values
typedef struct
{
    UINT    nFrameIds;
    DWORD   dwFrameType;
} FRAME_TYPE;

// Pairs Specific Media Types with sets Valid Frame Types
typedef struct
{
    DWORD              dwMediaType;
    const FRAME_TYPE * aFrameType;
} MEDIA_TYPE;

typedef struct
{
    CIpxAdapterInfo *pAI;
    DWORD dwMediaType;
    DWORD dwFrameType;
    DWORD dwNetworkNumber;
} WRKSTA_DIALOG_INFO;

//
// Ipx Workstation Configuration Dialog
//
class CIpxConfigDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CIpxConfigDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(EDT_IPXPP_NETWORKNUMBER,HandleNetworkNumber)
        COMMAND_ID_HANDLER(CMB_IPXPP_FRAMETYPE, HandleFrameCombo)
    END_MSG_MAP()

    CIpxConfigDlg(CNwlnkIPX *pmsc, CIpxEnviroment * pIpxEnviroment,
                  CIpxAdapterInfo * pAI);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT HandleNetworkNumber(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& bHandled);

    const FRAME_TYPE *GetFrameType(DWORD dwMediaType);

    void AdapterChanged();
    void FrameTypeChanged();
    void SetNetworkNumber(DWORD *pdw);
    void UpdateNetworkNumber(DWORD dwNetworkNumber, DWORD dwFrameType);

    LRESULT HandleFrameCombo(WORD wNotifyCode, WORD wID,
                             HWND hWndCtl, BOOL& bHandled);
private:
    CNwlnkIPX *         m_pmsc;
    CIpxEnviroment *    m_pIpxEnviroment;
    CIpxAdapterInfo *   m_pAICurrent;   // The current adapter
    WRKSTA_DIALOG_INFO  m_WrkstaDlgInfo;
};

typedef struct
{
    CIpxAdapterInfo *   pAI;
    UINT                nRadioBttn;
    DWORD               dwMediaType;
    list<tstring *>     lstpstrFrmType;
    list<tstring *>     lstpstrNetworkNum;
} SERVER_DIALOG_INFO;

// Dialog class to handle Add Frame feature
//
class CASAddDialog : public CDialogImpl<CASAddDialog>
{
public:
    enum { IDD = DLG_IPXAS_FRAME_ADD };

    BEGIN_MSG_MAP(CASAddDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDOK, OnOk);
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel);
    END_MSG_MAP()

public:
    CASAddDialog(CIpxASConfigDlg * pASCD, HWND hwndLV, DWORD dwMediaType,
                 DWORD dwFrame, PCWSTR pszNetworkNum);
    ~CASAddDialog() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
                    {EndDialog(IDCANCEL); return 0;}

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    int     IdsGetFrameType()    {return m_idsFrameType;}
    DWORD   DwGetFrameType()     {return m_dwFrameType;}
    PCWSTR SzGetNetworkNumber() {return m_strNetworkNumber.c_str();}

private:
    HWND                m_hwndLV;
    DWORD               m_dwMediaType;
    DWORD               m_dwFrameType;
    int                 m_idsFrameType;
    tstring             m_strNetworkNumber;
    CIpxASConfigDlg *   m_pASCD;
};

// Dialog class to handle Edit Network Number feature
//
class CASEditDialog : public CDialogImpl<CASEditDialog>
{
public:
    enum { IDD = DLG_IPXAS_FRAME_EDIT };

    BEGIN_MSG_MAP(CASEditDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDOK, OnOk);
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel);
    END_MSG_MAP()

public:
    CASEditDialog(CIpxASConfigDlg * pASCD, HWND hwndLV,
                  DWORD dwFrameType, PCWSTR pszNetworkNum) :
                m_strNetworkNumber(pszNetworkNum),
                m_dwFrameType(dwFrameType),
                m_hwndLV(hwndLV),
                m_pASCD(pASCD) {}
    ~CASEditDialog() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
                    {EndDialog(IDCANCEL); return 0;}
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    PCWSTR SzGetNetworkNumber() {return m_strNetworkNumber.c_str();}

private:
    DWORD               m_dwFrameType;
    tstring             m_strNetworkNumber;
    HWND                m_hwndLV;
    CIpxASConfigDlg *   m_pASCD;
};

//
// Ipx Server Configuration Dialog
//
class CIpxASConfigDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CIpxASConfigDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(EDT_IPXAS_INTERNAL,HandleInternalNetworkNumber)
        COMMAND_ID_HANDLER(BTN_IPXAS_ADD, OnAdd)
        COMMAND_ID_HANDLER(BTN_IPXAS_EDIT, OnEdit)
        COMMAND_ID_HANDLER(BTN_IPXAS_REMOVE, OnRemove)
        COMMAND_ID_HANDLER(BTN_IPXAS_AUTO, HandleRadioButton)
        COMMAND_ID_HANDLER(BTN_IPXAS_MANUAL, HandleRadioButton)
    END_MSG_MAP()

    CIpxASConfigDlg(CNwlnkIPX *, CIpxEnviroment *, CIpxAdapterInfo *);
    ~CIpxASConfigDlg();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    BOOL    FIsNetNumberInUse(DWORD dwFrameType, PCWSTR pszNetNum);

private:
    void UpdateRadioButtons();
    void UpdateButtons();
    void InitGeneralPage();
    int  DetermineMaxNumFrames();
    LRESULT HandleInternalNetworkNumber(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT HandleRadioButton(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    HRESULT HrUpdateListView();
    HRESULT HrAddItemToList(int idsFrameName, PCWSTR pszNetNum);
    BOOL FGetSelectedRowIdx(int *pnIdx);

private:
    CNwlnkIPX *         m_pmsc;
    CIpxEnviroment *    m_pIpxEnviroment;
    CIpxAdapterInfo *   m_pAICurrent;   // The current adapter

    HWND                m_hwndLV;

    UINT                m_nRadioBttn;
    DWORD               m_dwMediaType;
    list<tstring *>     m_lstpstrFrmType;
    list<tstring *>     m_lstpstrNetworkNum;
};

#ifdef INCLUDE_RIP_ROUTING
//
// Ipx Server Routing Dialog
//
class CIpxASInternalDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CIpxASInternalDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(BTN_IPXAS_RIP, OnRip)
    END_MSG_MAP()

    CIpxASInternalDlg(CNwlnkIPX *pmsc, CIpxEnviroment * pIpxEnviroment);
    ~CIpxASInternalDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnRip(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    CNwlnkIPX *         m_pmsc;
    CIpxEnviroment *    m_pIpxEnviroment;

    DWORD               m_dwRipValue;
};
#endif

class ATL_NO_VTABLE CNwlnkIPX :
    public CComObjectRoot,
    public CComCoClass<CNwlnkIPX, &CLSID_CNwlnkIPX>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding,
    public IIpxAdapterInfo
{
public:
    CNwlnkIPX();
    ~CNwlnkIPX();

    BEGIN_COM_MAP(CNwlnkIPX)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(IIpxAdapterInfo)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNwlnkIPX)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NWLNKIPX)

    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};


// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Upgrade)             (DWORD, DWORD);
    STDMETHOD (Removing)            ();

// INetCfgComponentPropertyUi
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// INetCfgComponentNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// IIpxAdapterInfo
    STDMETHOD (GetFrameTypesForAdapter)   (PCWSTR pszAdapterBindName,
                                           DWORD   cFrameTypesMax,
                                           DWORD*  anFrameTypes,
                                           DWORD*  pcFrameTypes);
    STDMETHOD (GetVirtualNetworkNumber)   (DWORD* pdwVNetworkNumber);
    STDMETHOD (SetVirtualNetworkNumber)   (DWORD dwVNetworkNumber);

private:
    STDMETHOD(HrCommitInstall)();
    STDMETHOD(HrCommitRemove)();

    HRESULT HrReconfigIpx();
    VOID    CleanupPropPages();
    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                PCWSTR pszAnswerSection);
    HRESULT HrReadAdapterAnswerFileSection(CSetupInfFile * pcsif,
                                           PCWSTR pszSection);

public:
    VOID MarkAdapterListChanged() {m_fAdapterListChanged = TRUE;};

private:
    INetCfgComponent*   m_pnccMe;
    INetCfg*            m_pNetCfg;
    BOOL                m_fNetworkInstall;
    BOOL                m_fAdapterListChanged;
    BOOL                m_fPropertyChanged;
    INSTALLACTION       m_eInstallAction;
    CPropSheetPage*     m_pspObj1;
    CPropSheetPage*     m_pspObj2;
    CIpxEnviroment*     m_pIpxEnviroment;
    IUnknown*           m_pUnkPropContext;

friend class CIpxEnviroment;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\nwlnkutl.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "ncreg.h"
#include "nwlnkipx.h"


#define ChLowX     L'x'
#define ChUpX      L'X'


//
// Function:    FIsNetwareIpxInstalled
//
// Purpose:     Check for the existance of the IPXSPSII key in the
//              HKLM\SYSTEM\...\Services hive
//

BOOL FIsNetwareIpxInstalled(
    VOID)
{
    HRESULT hr;
    HKEY hkey;
    BOOL fRet;

    fRet = FALSE;

    hr = HrRegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\IPXSPXII",
            KEY_READ,
            &hkey);
    if (S_OK == hr)
    {
        fRet = TRUE;
        RegCloseKey(hkey);
    }

    return fRet;
}

DWORD DwFromSz(PCWSTR sz, int nBase)
{
    PCWSTR psz = sz;
    WCHAR *pszStop;
    WCHAR szBuf[12];

    Assert(NULL != psz);

    if ((16 == nBase) && (ChLowX != sz[1]) && (ChUpX != sz[1]))
    {
        psz = szBuf;
        wcscpy(szBuf,L"0x");
        wcsncpy(szBuf+2, sz, 8);
        szBuf[10]=L'\0';
    }

    return wcstoul(psz, &pszStop, nBase);
}

DWORD DwFromLstPtstring(const list<tstring *> & lstpstr, DWORD dwDefault,
                        int nBase)
{
    if (lstpstr.empty())
        return dwDefault;
    else
        return DwFromSz(lstpstr.front()->c_str(), nBase);
}

void UpdateLstPtstring(TSTRING_LIST & lstpstr, DWORD dw)
{
    WCHAR szBuf[12];

    DeleteColString(&lstpstr);

    // Stringize the supplied dword as a hex with no "0x" prefix
    wsprintfW(szBuf,L"%0.8lX",dw);

    // Set as first item in the list
    lstpstr.push_front(new tstring(szBuf));
}

// Apply our special Hex Format to a DWORD.  Assumes adequately sized 'sz'
void HexSzFromDw(PWSTR sz, DWORD dw)
{
    wsprintfW(sz,L"%0.8lX",dw);
}

HRESULT HrQueryAdapterComponentInfo(INetCfgComponent *pncc,
                                    CIpxAdapterInfo * pAI)
{
    HRESULT           hr;
    PWSTR            pszwDesc = NULL;
    PWSTR            pszwBindName = NULL;
    DWORD             dwCharacteristics = 0L;

    Assert(NULL != pAI);
    Assert(NULL != pncc);

    // Get Description
    hr = pncc->GetDisplayName(&pszwDesc);
    if (FAILED(hr))
        goto Error;

    if (*pszwDesc)
        pAI->SetAdapterDesc(pszwDesc);
    else
        pAI->SetAdapterDesc(SzLoadIds(IDS_UNKNOWN_NETWORK_CARD));

    CoTaskMemFree(pszwDesc);

    // Get the Component's Instance Guid
    hr = pncc->GetInstanceGuid(pAI->PInstanceGuid());
    if (S_OK != hr)
        goto Error;

    // Get the Component's Bind Name
    hr = pncc->GetBindName(&pszwBindName);
    if (S_OK != hr)
        goto Error;

    Assert(NULL != pszwBindName);
    Assert(0 != lstrlenW(pszwBindName));
    pAI->SetBindName(pszwBindName);
    CoTaskMemFree(pszwBindName);

    // Failure is non-fatal
    hr = pncc->GetCharacteristics(&dwCharacteristics);
    if (SUCCEEDED(hr))
    {
        pAI->SetCharacteristics(dwCharacteristics);
    }

    // Get the media type (Optional key)
    {
        DWORD dwMediaType = ETHERNET_MEDIA;
        INetCfgComponentBindings* pnccBindings = NULL;

        hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                  reinterpret_cast<void**>(&pnccBindings));
        if (SUCCEEDED(hr))
        {
            struct
            {
                PCWSTR pszInterface;
                DWORD   dwInterface;
            } InterfaceMap[] = {{L"ethernet", ETHERNET_MEDIA},
                                {L"tokenring", TOKEN_MEDIA},
                                {L"arcnet", ARCNET_MEDIA},
                                {L"fddi", FDDI_MEDIA}};

            for (UINT nIdx=0; nIdx < celems(InterfaceMap); nIdx++)
            {
                hr = pnccBindings->SupportsBindingInterface(NCF_LOWER,
                                        InterfaceMap[nIdx].pszInterface);
                if (S_OK == hr)
                {
                    dwMediaType = InterfaceMap[nIdx].dwInterface;
                    break;
                }
            }

            ReleaseObj(pnccBindings);
        }

        pAI->SetMediaType(dwMediaType);
        hr = S_OK;
    }

Error:
    TraceError("HrQueryAdapterComponentInfo",hr);
    return hr;
}

// Note: Can successfully return *ppncc = NULL
HRESULT HrAnswerFileAdapterToPNCC(INetCfg *pnc, PCWSTR szAdapterId,
                                  INetCfgComponent** ppncc)
{
    GUID    guidAdapter;
    GUID    guidInstance;
    HRESULT hr = S_FALSE;   // assume we don't find it.

    Assert(NULL != szAdapterId);
    Assert(NULL != ppncc);
    Assert(lstrlenW(szAdapterId));

    *ppncc = NULL;

    // Get the Instance ID for the specified adapter
    if (FGetInstanceGuidOfComponentInAnswerFile(szAdapterId,
                                                pnc, &guidAdapter))
    {
        // Search for the specified adapter in the set of existing adapters
        CIterNetCfgComponent nccIter(pnc, &GUID_DEVCLASS_NET);
        INetCfgComponent* pncc;
        while (SUCCEEDED(hr) &&
               (S_OK == (hr = nccIter.HrNext (&pncc))))
        {
            hr = pncc->GetInstanceGuid(&guidInstance);
            if (SUCCEEDED(hr))
            {
                if (guidInstance == guidAdapter)
                {
                    // Found the adapter.  Transfer ownership and get out.
                    *ppncc = pncc;
                    break;
                }
            }
            ReleaseObj(pncc);
        }
    }

    TraceError("HrAnswerFileAdapterToPNCC", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nwlnkcfg\resource.h ===
#include <ncres.h>

#define IDS_INFORMATION_MESSAGE         (IDS_NC_NWLNKCFG +  2)  // "Informational Message"
#define IDS_IPXPP_TEXT_1                (IDS_NC_NWLNKCFG +  3)
#define IDS_IPXPP_TEXT_2                (IDS_NC_NWLNKCFG +  4)
#define IDS_VIRTUAL_WARNING             (IDS_NC_NWLNKCFG + 11)
#define IDS_AUTO                        (IDS_NC_NWLNKCFG + 12)
#define IDS_ETHERNET                    (IDS_NC_NWLNKCFG + 13)
#define IDS_802_2                       (IDS_NC_NWLNKCFG + 14)
#define IDS_802_3                       (IDS_NC_NWLNKCFG + 15)
#define IDS_SNAP                        (IDS_NC_NWLNKCFG + 16)
#define IDS_ARCNET                      (IDS_NC_NWLNKCFG + 17)
#define IDS_802_5                       (IDS_NC_NWLNKCFG + 18)
#define IDS_TK                          (IDS_NC_NWLNKCFG + 19)
#define IDS_MANUAL_FRAME_DETECT         (IDS_NC_NWLNKCFG + 20)
#define IDS_INCORRECT_NETNUM            (IDS_NC_NWLNKCFG + 22)
#define IDS_FDDI                        (IDS_NC_NWLNKCFG + 23)
#define IDS_FDDI_SNAP                   (IDS_NC_NWLNKCFG + 24)
#define IDS_FDDI_802_3                  (IDS_NC_NWLNKCFG + 25)
#define IDS_IPXAS_FRAME_TYPE            (IDS_NC_NWLNKCFG + 26)
#define IDS_IPXAS_NETWORK_NUM           (IDS_NC_NWLNKCFG + 27)
#define IDS_GENERAL                     (IDS_NC_NWLNKCFG + 28)
#define IDS_NETNUM_INUSE                (IDS_NC_NWLNKCFG + 29)
#define IDS_INSTALL_RIP                 (IDS_NC_NWLNKCFG + 30)
#define IDS_ROUTING                     (IDS_NC_NWLNKCFG + 31)
#define IDS_NETBIOS_BROADCAST           (IDS_NC_NWLNKCFG + 32)

#define DLG_IPX_CONFIG                  17000
#define DLG_IPXAS_CONFIG                17001
#define DLG_IPXAS_INTERNAL              17002
#define DLG_IPXAS_FRAME_ADD             17003
#define DLG_IPXAS_FRAME_EDIT            17004


// IPX Workstation Property Page - Control IDs
#define IDC_IPXPP_TEXT                  200
#define CMB_IPXPP_FRAMETYPE             201
#define EDT_IPXPP_NETWORKNUMBER         202
#define IDC_STATIC_NETNUM               203
#define IDC_STATIC_FRAMETYPE            204
#define GB_IPXPP_ADAPTER                205
#define IDC_IPXPP_ADAPTER_TEXT          206

// IPX Server Property Pages - Control IDs
#define EDT_IPXAS_INTERNAL              207
#define IDC_IPXAS_GROUP                 208
#define BTN_IPXAS_AUTO                  209
#define BTN_IPXAS_MANUAL                210
#define LVC_IPXAS_DEST                  211
#define BTN_IPXAS_ADD                   212
#define BTN_IPXAS_EDIT                  213
#define BTN_IPXAS_REMOVE                214
#define BTN_IPXAS_RIP                   215
#define CMB_IPXAS_DEST                  216
#define EDT_IPXAS_NETNUM                217
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\bindcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       B I N D C F G . C P P
//
//  Contents:   Exposes control for creating and removing RAS bindings.
//
//  Notes:      The exported methods are called by RAS when endpoints
//              need to be created or removed for the purpose of making
//              calls.
//
//  Author:     shaunco   16 Oct 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcfg.h"
#include "ncutil.h"
#include "netcfgn.h"
#include <rasapip.h>

extern const WCHAR c_szInfId_MS_NdisWanIp[];
extern const WCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const WCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const WCHAR c_szInfId_MS_NetBEUI[];
extern const WCHAR c_szInfId_MS_TCPIP[];

class CRasBindingConfig
{
public:
    INetCfg*    m_pNetCfg;
    BOOL        m_fInitCom;

    enum NEEDED_COMPONENTS
    {
        INDEX_IP = 0,
        INDEX_NBF,
        INDEX_IPADAPTER,
        COUNT_COMPONENTS,
    };
    INetCfgComponent*   m_apComponents  [COUNT_COMPONENTS];

public:
#if DBG
    CRasBindingConfig ()
    {
        m_pNetCfg = NULL;
    }
    ~CRasBindingConfig ()
    {
        AssertH (!m_pNetCfg);
    }
#endif

public:
    HRESULT
    HrAddOrRemoveBindings (
        IN     DWORD        dwFlags,
        IN OUT UINT*        pcIpOut,
        IN     const GUID*  pguidIpOutBindings,
        IN OUT UINT*        pcNbfIn,
        IN OUT UINT*        pcNbfOut);

    HRESULT
    HrCountBindings (
        OUT UINT*   pcIpOut,
        OUT UINT*   pcNbfIn,
        OUT UINT*   pcNbfOut);

    HRESULT
    HrLoadINetCfg (
        IN REGSAM samDesired);

    HRESULT
    HrLoadINetCfgAndAddOrRemoveBindings (
        IN     DWORD        dwFlags,
        IN OUT UINT*        pcIpOut,
        IN     const GUID*  pguidIpOutBindings,
        IN OUT UINT*        pcNbfIn,
        IN OUT UINT*        pcNbfOut);

    VOID
    UnloadINetCfg ();

    INetCfgComponent*
    PnccIp ()
    {
        AssertH (m_pNetCfg);
        return m_apComponents [INDEX_IP];
    }

    INetCfgComponent*
    PnccIpAdapter ()
    {
        AssertH (m_pNetCfg);
        return m_apComponents [INDEX_IPADAPTER];
    }

    INetCfgComponent*
    PnccNbf ()
    {
        AssertH (m_pNetCfg);
        return m_apComponents [INDEX_NBF];
    }
};


HRESULT
CRasBindingConfig::HrCountBindings (
    UINT* pcIpOut,
    UINT* pcNbfIn,
    UINT* pcNbfOut)
{
    Assert (pcIpOut);
    Assert (pcNbfIn);
    Assert (pcNbfOut);

    HRESULT hr = S_OK;

    // Initialize output parameters.
    //
    *pcIpOut = *pcNbfIn = *pcNbfOut = 0;

    if (PnccIp() && PnccIpAdapter())
    {
        INetCfgComponentUpperEdge* pUpperEdge;
        hr = HrQueryNotifyObject (
                        PnccIp(),
                        IID_INetCfgComponentUpperEdge,
                        reinterpret_cast<VOID**>(&pUpperEdge));

        if (SUCCEEDED(hr))
        {
            DWORD dwNumInterfaces;
            GUID* pguidInterfaceIds;

            hr = pUpperEdge->GetInterfaceIdsForAdapter (
                    PnccIpAdapter(),
                    &dwNumInterfaces,
                    &pguidInterfaceIds);
            if (SUCCEEDED(hr))
            {
                *pcIpOut = dwNumInterfaces;

                CoTaskMemFree (pguidInterfaceIds);
            }

            ReleaseObj (pUpperEdge);
        }
    }

    if (PnccNbf())
    {
        // Iterate adapters in the system.
        //
        CIterNetCfgComponent nccIter(m_pNetCfg, &GUID_DEVCLASS_NET);
        INetCfgComponent* pnccAdapter;
	
        while (S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
        {
          // Quickly discard non-hidden adapters to avoid unneccesary
          // string compares.
          //
          DWORD dwCharacter;
          if (   SUCCEEDED(pnccAdapter->GetCharacteristics (&dwCharacter))
             	   && (dwCharacter & NCF_HIDDEN))
          {
             PWSTR pszId;
             if (SUCCEEDED(pnccAdapter->GetId (&pszId)))
             {
            	if (FEqualComponentId (c_szInfId_MS_NdisWanNbfIn,
                                pszId))
                 {
                       	(*pcNbfIn)++;
                 }
                 else if (FEqualComponentId (c_szInfId_MS_NdisWanNbfOut,
                                pszId))
                 {
                       	(*pcNbfOut)++;
                 }

	         CoTaskMemFree (pszId);
             }
           }
	            ReleaseObj (pnccAdapter);
        }
	
    }

    TraceTag (ttidRasCfg,
              "Current RAS bindings: "
              "%u IP dial-out, %u NBF dial-in, %u NBF dial-out",
              *pcIpOut, *pcNbfIn, *pcNbfOut);

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::HrCountBindings");
    return hr;
}

HRESULT
CRasBindingConfig::HrAddOrRemoveBindings (
    IN     DWORD        dwFlags,
    IN OUT UINT*        pcIpOut,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut)
{
    HRESULT hr = S_OK;

    // Safe off the input parameters.
    //
    UINT cIpOut  = *pcIpOut;
    UINT cNbfIn  = *pcNbfIn;
    UINT cNbfOut = *pcNbfOut;

    if (cIpOut && PnccIp() && PnccIpAdapter())
    {
        INetCfgComponentUpperEdge* pUpperEdge;
        hr = HrQueryNotifyObject (
                        PnccIp(),
                        IID_INetCfgComponentUpperEdge,
                        reinterpret_cast<VOID**>(&pUpperEdge));

        if (SUCCEEDED(hr))
        {
            if (dwFlags & ARA_ADD)
            {
                TraceTag (ttidRasCfg,
                    "Adding %d TCP/IP interfaces to the ndiswanip adapter",
                    cIpOut);

                hr = pUpperEdge->AddInterfacesToAdapter (
                        PnccIpAdapter(),
                        cIpOut);
            }
            else
            {
                TraceTag (ttidRasCfg,
                    "Removing %d TCP/IP interfaces from the ndiswanip adapter",
                    cIpOut);

                hr = pUpperEdge->RemoveInterfacesFromAdapter (
                        PnccIpAdapter(),
                        cIpOut,
                        pguidIpOutBindings);
            }

            ReleaseObj (pUpperEdge);
        }
    }

    if (PnccNbf() && SUCCEEDED(hr))
    {
        if (cNbfIn)
        {
            TraceTag (ttidRasCfg,
                "%s %d %S adapters",
                (dwFlags & ARA_ADD) ? "Adding" : "Removing",
                cNbfIn,
                c_szInfId_MS_NdisWanNbfIn);

            hr = HrAddOrRemoveAdapter (
                    m_pNetCfg,
                    c_szInfId_MS_NdisWanNbfIn,
                    dwFlags, NULL, cNbfIn, NULL);
        }

        if (cNbfOut && SUCCEEDED(hr))
        {
            TraceTag (ttidRasCfg,
                "%s %d %S adapters",
                (dwFlags & ARA_ADD) ? "Adding" : "Removing",
                cNbfOut,
                c_szInfId_MS_NdisWanNbfOut);

            hr = HrAddOrRemoveAdapter (
                    m_pNetCfg,
                    c_szInfId_MS_NdisWanNbfOut,
                    dwFlags, NULL, cNbfOut, NULL);
        }
    }

    HRESULT hrT = HrCountBindings(pcIpOut, pcNbfIn, pcNbfOut);
    if (SUCCEEDED(hr))
    {
        hr = hrT;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::HrAddOrRemoveBindings");
    return hr;
}

HRESULT
CRasBindingConfig::HrLoadINetCfg (
    IN REGSAM samDesired)
{
    HRESULT hr;

    Assert (!m_pNetCfg);

    // Get INetCfg and lock it for write.
    //
    m_fInitCom = TRUE;
    hr = HrCreateAndInitializeINetCfg (
            &m_fInitCom,
            &m_pNetCfg,
            (KEY_WRITE == samDesired),  // get the write lock if needed
            0,                          // don't wait for it
            L"RAS Binding Configuration",
            NULL);

    if (SUCCEEDED(hr))
    {
        ZeroMemory (m_apComponents, sizeof(m_apComponents));

        // Find the following components and hold on to their INetCfgComponent
        // interface pointers in m_apComponents.  UnloadINetCfg will release
        // these.  HrFindComponents will zero the array so it is safe to
        // call UnloadINetCfg if HrFindComponents fails.
        //
        const GUID* c_apguidComponentClasses [COUNT_COMPONENTS] =
        {
            &GUID_DEVCLASS_NETTRANS,        // Ip
            &GUID_DEVCLASS_NETTRANS,        // NetBEUI
            &GUID_DEVCLASS_NET,             // IpAdapter
        };

        const PCWSTR c_apszComponentIds [COUNT_COMPONENTS] =
        {
            c_szInfId_MS_TCPIP,
            c_szInfId_MS_NetBEUI,
            c_szInfId_MS_NdisWanIp,
        };

        if (SUCCEEDED(hr))
        {
            hr = HrFindComponents (
                    m_pNetCfg,
                    COUNT_COMPONENTS,
                    c_apguidComponentClasses,
                    c_apszComponentIds,
                    m_apComponents);
        }

        if (FAILED(hr))
        {
            // If we have a failure while trying to find these components
            // we're going to fail this method call, so be sure to cleanup
            // m_pNetCfg.
            //
            UnloadINetCfg ();
            Assert (!m_pNetCfg);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::HrLoadINetCfg");
    return hr;
}

HRESULT
CRasBindingConfig::HrLoadINetCfgAndAddOrRemoveBindings (
    IN     DWORD        dwFlags,
    IN OUT UINT*        pcIpOut,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut)
{
    Assert (!m_pNetCfg);

    HRESULT hr;

    hr = HrLoadINetCfg (KEY_WRITE);

    if (SUCCEEDED(hr))
    {
        try
        {
            hr = HrAddOrRemoveBindings (
                    dwFlags,
                    pcIpOut,
                    pguidIpOutBindings,
                    pcNbfIn,
                    pcNbfOut);

            if (SUCCEEDED(hr))
            {
                (VOID) m_pNetCfg->Apply();
            }
            else
            {
                (VOID) m_pNetCfg->Cancel();
            }
        }
        catch (bad_alloc)
        {
            hr = E_OUTOFMEMORY;
        }

        UnloadINetCfg ();
    }

    // We shouldn't ever leave with an un-released INetCfg.
    //
    Assert (!m_pNetCfg);

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "CRasBindingConfig::HrLoadINetCfgAndAddOrRemoveBindings");
    return hr;
}

VOID
CRasBindingConfig::UnloadINetCfg ()
{
    // Must call HrLoadINetCfg before calling this.
    //
    Assert (m_pNetCfg);

    ReleaseIUnknownArray (COUNT_COMPONENTS, (IUnknown**)m_apComponents);

    (VOID) HrUninitializeAndReleaseINetCfg (m_fInitCom, m_pNetCfg, TRUE);
    m_pNetCfg = NULL;
}


//+---------------------------------------------------------------------------
// Exported functions
//

EXTERN_C
HRESULT
WINAPI
RasAddBindings (
    IN OUT UINT*    pcIpOut,
    IN OUT UINT*    pcNbfIn,
    IN OUT UINT*    pcNbfOut)
{
    HRESULT hr;

#if 0
    RtlValidateProcessHeaps ();
#endif

    // Validate parameters.
    //
    if (!pcIpOut || !pcNbfIn || !pcNbfOut)
    {
        hr = E_POINTER;
    }
    else if (!*pcIpOut && !*pcNbfIn && !*pcNbfOut)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CRasBindingConfig Config;

        hr = Config.HrLoadINetCfgAndAddOrRemoveBindings (
                ARA_ADD,
                pcIpOut,
                NULL,
                pcNbfIn,
                pcNbfOut);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::RasAddBindings");
    return hr;
}

EXTERN_C
HRESULT
WINAPI
RasCountBindings (
    OUT UINT*   pcIpOut,
    OUT UINT*   pcNbfIn,
    OUT UINT*   pcNbfOut)
{
    HRESULT hr;

#if 0
    RtlValidateProcessHeaps ();
#endif

    // Validate parameters.
    //
    if (!pcIpOut || !pcNbfIn || !pcNbfOut)
    {
        hr = E_POINTER;
    }
    else
    {
        CRasBindingConfig Config;

        hr = Config.HrLoadINetCfg (KEY_READ);
        if (SUCCEEDED(hr))
        {
            try
            {
                hr = Config.HrCountBindings (
                        pcIpOut,
                        pcNbfIn,
                        pcNbfOut);
            }
            catch (bad_alloc)
            {
                hr = E_OUTOFMEMORY;
            }

            Config.UnloadINetCfg ();
        }
        // We shouldn't ever leave with an un-released INetCfg.
        //
        Assert (!Config.m_pNetCfg);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::RasCountBindings");
    return hr;
}

EXTERN_C
HRESULT
WINAPI
RasRemoveBindings (
    IN OUT UINT*        pcIpOutBindings,
    IN     const GUID*  pguidIpOutBindings,
    IN OUT UINT*        pcNbfIn,
    IN OUT UINT*        pcNbfOut)
{
    HRESULT hr;

#if 0
    RtlValidateProcessHeaps ();
#endif

    // Validate parameters.
    //
    if (!pcIpOutBindings || !pcNbfIn || !pcNbfOut)
    {
        hr = E_POINTER;
    }
    else if (!*pcIpOutBindings && !*pcNbfIn && !*pcNbfOut)
    {
        hr = E_INVALIDARG;
    }
    else if (*pcIpOutBindings && !pguidIpOutBindings)
    {
        hr = E_POINTER;
    }
    else
    {
        CRasBindingConfig Config;

        hr = Config.HrLoadINetCfgAndAddOrRemoveBindings (
                ARA_REMOVE,
                pcIpOutBindings,
                pguidIpOutBindings,
                pcNbfIn,
                pcNbfOut);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasBindingConfig::RasRemoveBindings");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\bindobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       B I N D O B J . H
//
//  Contents:   Declaration of base class for RAS binding objects.
//
//  Notes:
//
//  Author:     shaunco   11 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <notifval.h>
#include "resource.h"
#include "rasaf.h"
#include "rasdata.h"
#include "ncutil.h"


enum RAS_BINDING_ID
{
    RBID_INVALID = 0,
    RBID_NDISATM,
    RBID_NDISCOWAN,
    RBID_NDISWAN,
    RBID_NDISWANASYNC,
};

enum RAS_PROTOCOL_IDS
{
    RPI_IP      = 0x00000001,
    RPI_IPX     = 0x00000002,
    RPI_NBF     = 0x00000004,
    RPI_ATALK   = 0x00000008,
    RPI_NETMON  = 0x00000010,
    RPI_ALL     = 0xFFFFFFFF,
};

struct RAS_ENDPOINT_INFO
{
    UINT    cDialIn;
    UINT    cDialOut;
    UINT    cEndpoints;
};


class CRasBindObject
{
public:
    // Make these members public for now. Since this object
    // is instantiated from the modem class installer. We
    // need to set the INetCfg member.
    //
    INetCfg*                m_pnc;
    CRasBindObject          ();

    ~CRasBindObject         ()
    {
        ReleaseObj (m_pnc);
    }

    // You must call ReleaseOtherComponents after calling this.
    HRESULT HrFindOtherComponents   ();

    // You can only call this once per call to HrFindOtherComponents.
    NOTHROW VOID ReleaseOtherComponents  ();

    HRESULT HrProcessEndpointChange ();

    NOTHROW   INetCfgComponent* PnccNdisWan ();

protected:
    // We keep an array of INetCfgComponent pointers.  This enum
    // defines the indicies of the array.  The static arrays of
    // class guids and component ids identify the respecitive components.
    // HrFindOtherComonents initializes the array of component pointers
    // and ReleaseOtherComponents releases them.  Note, however, that this
    // action is refcounted.  This is because we are re-entrant.
    // HrFindOtherComponents only finds the components if the refcount is
    // zero.  After every call, it increments the refcount.
    // ReleaseOtherComponents always decrements the refcount and only
    // releases the components if the refcount is zero.
    //
    enum OTHER_COMPONENTS
    {
        c_ipnccRasCli = 0,
        c_ipnccRasSrv,
        c_ipnccIp,
        c_ipnccIpx,
        c_ipnccNbf,
        c_ipnccAtalk,
        c_ipnccNetMon,
        c_ipnccNdisWan,
        c_ipnccIpAdapter,
        c_cOtherComponents,
    };
    static const GUID*      c_apguidComponentClasses [c_cOtherComponents];
    static const PCWSTR     c_apszComponentIds       [c_cOtherComponents];
    INetCfgComponent*       m_apnccOther             [c_cOtherComponents];
    ULONG                   m_ulOtherComponents;

protected:
    BOOL    FIsRasBindingInterface  (INetCfgBindingInterface* pncbi,
                                     RAS_BINDING_ID* pRasBindId);

    HRESULT HrCountInstalledMiniports   (UINT* pcIpOut,
                                         UINT* pcNbfIn,
                                         UINT* pcNbfOut);

    HRESULT HrCountWanAdapterEndpoints  (INetCfgComponent* pncc,
                                         RAS_BINDING_ID RasBindId,
                                         UINT* pcEndpoints);

    HRESULT HrAddOrRemoveAtalkInOut (DWORD dwFlags);
    HRESULT HrAddOrRemoveIpAdapter  (DWORD dwFlags);
    HRESULT HrAddOrRemoveIpOut      (INT nInstances);
    HRESULT HrAddOrRemoveIpxInOut   (DWORD dwFlags);
    HRESULT HrAddOrRemoveNbfIn      (INT nInstances);
    HRESULT HrAddOrRemoveNbfOut     (INT nInstances);
    HRESULT HrAddOrRemoveNetMonInOut(DWORD dwFlags);
    HRESULT HrAddOrRemovePti        (DWORD dwFlags);

    NOTHROW INetCfgComponent*   PnccRasCli      ();
    NOTHROW INetCfgComponent*   PnccRasSrv      ();
    NOTHROW INetCfgComponent*   PnccRasRtr      ();
    NOTHROW INetCfgComponent*   PnccIp          ();
    NOTHROW INetCfgComponent*   PnccIpx         ();
    NOTHROW INetCfgComponent*   PnccNbf         ();
    NOTHROW INetCfgComponent*   PnccAtalk       ();
    NOTHROW INetCfgComponent*   PnccNetMon      ();
    NOTHROW INetCfgComponent*   PnccIpAdapter   ();
};

extern const WCHAR c_szInfId_MS_NdisWanAtalk[];
extern const WCHAR c_szInfId_MS_NdisWanIp[];
extern const WCHAR c_szInfId_MS_NdisWanIpx[];
extern const WCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const WCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const WCHAR c_szInfId_MS_NdisWanBh[];
extern const WCHAR c_szInfId_MS_PtiMiniport[];


inline
HRESULT
CRasBindObject::HrAddOrRemoveAtalkInOut (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_NdisWanAtalk, dwFlags);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveIpAdapter (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_NdisWanIp, dwFlags);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveIpxInOut (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_NdisWanIpx, dwFlags);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveNbfIn (
    INT     nInstances)
{
    DWORD dwFlags   = (nInstances > 0) ? ARA_ADD    : ARA_REMOVE;
    UINT cInstances = (nInstances > 0) ? nInstances : 0 - nInstances;

    TraceTag (ttidRasCfg, "%s %d %S adapters",
              (nInstances > 0) ? "Adding" : "Removing",
              cInstances,
              c_szInfId_MS_NdisWanNbfIn);

    return HrAddOrRemoveAdapter (m_pnc, c_szInfId_MS_NdisWanNbfIn,
                                    dwFlags, NULL, cInstances, NULL);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveNbfOut (
    INT     nInstances)
{
    DWORD dwFlags   = (nInstances > 0) ? ARA_ADD    : ARA_REMOVE;
    UINT cInstances = (nInstances > 0) ? nInstances : 0 - nInstances;

    TraceTag (ttidRasCfg, "%s %d %S adapters",
              (nInstances > 0) ? "Adding" : "Removing",
              cInstances,
              c_szInfId_MS_NdisWanNbfOut);

    return HrAddOrRemoveAdapter (m_pnc, c_szInfId_MS_NdisWanNbfOut,
                                    dwFlags, NULL, cInstances, NULL);
}

inline
HRESULT
CRasBindObject::HrAddOrRemoveNetMonInOut (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_NdisWanBh, dwFlags);
}

inline
HRESULT
CRasBindObject::HrAddOrRemovePti (
    DWORD   dwFlags)
{
    return HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PtiMiniport, dwFlags);
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccRasCli ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccRasCli];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccRasSrv ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccRasSrv];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccIp ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccIp];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccIpx ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccIpx];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccNbf ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccNbf];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccAtalk ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccAtalk];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccNetMon ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccNetMon];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccIpAdapter ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    return m_apnccOther [c_ipnccIpAdapter];
}

inline
NOTHROW
INetCfgComponent*
CRasBindObject::PnccNdisWan ()
{
    AssertSzH (m_ulOtherComponents, "You have not called HrFindOtherComponents yet.");
    //AssertSzH (m_apnccOther [c_ipnccNdisWan], "The NdisWan component was not found, but we installed it!");
    return m_apnccOther [c_ipnccNdisWan];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\l2tp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L 2 T P . C P P
//
//  Contents:   Implementation of L2TP configuration object.
//
//  Notes:
//
//  Author:     shaunco   15 Jul 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncui.h"
#include "ndiswan.h"
#include "rasobj.h"

extern const WCHAR c_szInfId_MS_L2tpMiniport[];

CL2tp::CL2tp () : CRasBindObject ()
{
    m_pnccMe = NULL;
    m_fSaveAfData = FALSE;
}

CL2tp::~CL2tp ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CL2tp::Initialize (
        INetCfgComponent*   pncc,
        INetCfg*            pnc,
        BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    //
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    return S_OK;
}

STDMETHODIMP
CL2tp::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CL2tp::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CL2tp::ApplyRegistryChanges ()
{
    if (m_fSaveAfData)
    {
        m_AfData.SaveToRegistry (m_pnc);
        m_fSaveAfData = FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CL2tp::ReadAnswerFile (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    // Read data from the answer file.
    // Don't let this affect the HRESULT we return.
    //
    if (SUCCEEDED(m_AfData.HrOpenAndRead (pszAnswerFile, pszAnswerSection)))
    {
        m_fSaveAfData = TRUE;
    }

    return S_OK;
}

STDMETHODIMP
CL2tp::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install the L2TP miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_L2tpMiniport, ARA_ADD);

    TraceError ("CL2tp::Install", hr);
    return hr;
}

STDMETHODIMP
CL2tp::Removing ()
{
    HRESULT hr;

    // Install the L2TP miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_L2tpMiniport, ARA_REMOVE);

    TraceError ("CL2tp::Removing", hr);
    return hr;
}

STDMETHODIMP
CL2tp::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\bindobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       B I N D O B J . C P P
//
//  Contents:   Implementation of base class for RAS binding objects.
//
//  Notes:
//
//  Author:     shaunco   11 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "bindobj.h"
#include "ncmisc.h"
#include "ncsvc.h"

extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szBiNdisCoWan[];
extern const WCHAR c_szBiNdisWan[];
extern const WCHAR c_szBiNdisWanAsync[];

extern const WCHAR c_szInfId_MS_AppleTalk[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_NdisWan[];
extern const WCHAR c_szInfId_MS_NetBEUI[];
extern const WCHAR c_szInfId_MS_NetMon[];
extern const WCHAR c_szInfId_MS_RasCli[];
extern const WCHAR c_szInfId_MS_RasSrv[];
extern const WCHAR c_szInfId_MS_TCPIP[];


//----------------------------------------------------------------------------
// Data used for finding the other components we have to deal with.
//
const GUID* CRasBindObject::c_apguidComponentClasses [c_cOtherComponents] =
{
    &GUID_DEVCLASS_NETSERVICE,      // RasCli
    &GUID_DEVCLASS_NETSERVICE,      // RasSrv
    &GUID_DEVCLASS_NETTRANS,        // Ip
    &GUID_DEVCLASS_NETTRANS,        // Ipx
    &GUID_DEVCLASS_NETTRANS,        // Nbf
    &GUID_DEVCLASS_NETTRANS,        // Atalk
    &GUID_DEVCLASS_NETTRANS,        // NetMon
    &GUID_DEVCLASS_NETTRANS,        // NdisWan
    &GUID_DEVCLASS_NET,             // IpAdapter
};

const PCWSTR CRasBindObject::c_apszComponentIds [c_cOtherComponents] =
{
    c_szInfId_MS_RasCli,
    c_szInfId_MS_RasSrv,
    c_szInfId_MS_TCPIP,
    c_szInfId_MS_NWIPX,
    c_szInfId_MS_NetBEUI,
    c_szInfId_MS_AppleTalk,
    c_szInfId_MS_NetMon,
    c_szInfId_MS_NdisWan,
    c_szInfId_MS_NdisWanIp,
};

CRasBindObject::CRasBindObject ()
{
    m_ulOtherComponents = 0;
    m_pnc               = NULL;
}

HRESULT
CRasBindObject::HrCountInstalledMiniports (
    UINT* pcIpOut,
    UINT* pcNbfIn,
    UINT* pcNbfOut)
{
    Assert (pcIpOut);
    Assert (pcNbfIn);
    Assert (pcNbfOut);

    // Initialize output parameters.
    //
    *pcIpOut = *pcNbfIn = *pcNbfOut = 0;

    if (PnccIp() && PnccIpAdapter())
    {
        INetCfgComponentUpperEdge* pUpperEdge;
        HRESULT hr = HrQueryNotifyObject (
                        PnccIp(),
                        IID_INetCfgComponentUpperEdge,
                        reinterpret_cast<VOID**>(&pUpperEdge));

        if (SUCCEEDED(hr))
        {
            DWORD dwNumInterfaces;
            GUID* pguidInterfaceIds;

            hr = pUpperEdge->GetInterfaceIdsForAdapter (
                    PnccIpAdapter(),
                    &dwNumInterfaces,
                    &pguidInterfaceIds);
            if (SUCCEEDED(hr))
            {
                *pcIpOut = dwNumInterfaces;

                CoTaskMemFree (pguidInterfaceIds);
            }

            ReleaseObj (pUpperEdge);
        }
    }

    // Iterate adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter(m_pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent* pnccAdapter;
    while(S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        // Quickly discard non-hidden adapters to avoid unneccesary string
        // compares.
        //
        DWORD dwCharacter;
        if (   SUCCEEDED(pnccAdapter->GetCharacteristics (&dwCharacter))
            && (dwCharacter & NCF_HIDDEN))
        {
            PWSTR pszId;
            if (SUCCEEDED(pnccAdapter->GetId (&pszId)))
            {
                if (FEqualComponentId (c_szInfId_MS_NdisWanNbfIn, pszId))
                {
                    (*pcNbfIn)++;
                }
                else if (FEqualComponentId (c_szInfId_MS_NdisWanNbfOut, pszId))
                {
                    (*pcNbfOut)++;
                }

                CoTaskMemFree (pszId);
            }
        }
        ReleaseObj (pnccAdapter);
    }

    TraceTag (ttidRasCfg,
              "Current ndiswan miniports: "
              "%u IP dial-out, %u NBF dial-in, %u NBF dial-out",
              *pcIpOut, *pcNbfIn, *pcNbfOut);

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }
    TraceError ("CRasBindObject::HrCountInstalledMiniports", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::HrFindOtherComponents
//
//  Purpose:    Find the components listed in our OTHER_COMPONENTS enum.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:      We ref-count this action.  If called again (before
//              ReleaseOtherComponents) we increment a refcount.
//
//
HRESULT
CRasBindObject::HrFindOtherComponents ()
{
    AssertSz (c_cOtherComponents == celems(c_apguidComponentClasses),
              "Uhh...you broke something.");
    AssertSz (c_cOtherComponents == celems(c_apszComponentIds),
              "Uhh...you broke something.");
    AssertSz (c_cOtherComponents == celems(m_apnccOther),
              "Uhh...you broke something.");

    HRESULT hr = S_OK;

    if (!m_ulOtherComponents)
    {
        hr = HrFindComponents (
                m_pnc, c_cOtherComponents,
                c_apguidComponentClasses,
                c_apszComponentIds,
                m_apnccOther);
    }
    if (SUCCEEDED(hr))
    {
        m_ulOtherComponents++;
    }
    TraceError ("CRasBindObject::HrFindOtherComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::ReleaseOtherComponents
//
//  Purpose:    Releases the components found by a previous call to
//              HrFindOtherComponents.  (But only if the refcount is zero.)
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
NOTHROW
void
CRasBindObject::ReleaseOtherComponents ()
{
    AssertSz (m_ulOtherComponents,
              "You have not called HrFindOtherComponents yet or you have "
              "called ReleaseOtherComponents too many times.");

    if (0 == --m_ulOtherComponents)
    {
        ReleaseIUnknownArray (c_cOtherComponents, (IUnknown**)m_apnccOther);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasBindObject::FIsRasBindingInterface
//
//  Purpose:    Return TRUE if an INetCfgBindingInterface represents
//              a RAS binding interface.  If it is, return the corresponding
//              RAS_BINDING_ID.
//
//  Arguments:
//      pncbi      [in]     INetCfgBindingInterface to check.
//      pRasBindId [out]    Returned RAS_BINDING_ID if the method returns
//                          TRUE.
//
//  Returns:    TRUE if the INetCfgBindingInterface represents a RAS binding
//              interface.  FALSE if not.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
BOOL
CRasBindObject::FIsRasBindingInterface (
    INetCfgBindingInterface*    pncbi,
    RAS_BINDING_ID*             pRasBindId)
{
    Assert (pRasBindId);

    // Initialize the output parameter.
    *pRasBindId = RBID_INVALID;

    PWSTR pszName;
    if (SUCCEEDED(pncbi->GetName (&pszName)))
    {
        if (0 == lstrcmpW (c_szBiNdisAtm, pszName))
        {
            *pRasBindId = RBID_NDISATM;
        }
        else if (0 == lstrcmpW (c_szBiNdisCoWan, pszName))
        {
            *pRasBindId = RBID_NDISCOWAN;
        }
        else if (0 == lstrcmpW (c_szBiNdisWan, pszName))
        {
            *pRasBindId = RBID_NDISWAN;
        }
        else if (0 == lstrcmpW (c_szBiNdisWanAsync, pszName))
        {
            *pRasBindId = RBID_NDISWANASYNC;
        }

        CoTaskMemFree (pszName);
    }

    return (RBID_INVALID != *pRasBindId);
}

HRESULT
CRasBindObject::HrAddOrRemoveIpOut (
    INT     nInstances)
{
    if ((nInstances > 0) && PnccIp() && PnccIpAdapter())
    {
        INetCfgComponentUpperEdge* pUpperEdge;
        HRESULT hr = HrQueryNotifyObject (
                        PnccIp(),
                        IID_INetCfgComponentUpperEdge,
                        reinterpret_cast<VOID**>(&pUpperEdge));

        if (SUCCEEDED(hr))
        {
            TraceTag (ttidRasCfg,
                "Adding %d TCP/IP interfaces to the ndiswanip adapter",
                nInstances);

            hr = pUpperEdge->AddInterfacesToAdapter (
                    PnccIpAdapter(),
                    nInstances);

            ReleaseObj (pUpperEdge);
        }
    }
    return S_OK;
}

HRESULT
CRasBindObject::HrProcessEndpointChange ()
{
    Assert (m_pnc);

    HRESULT hr = HrFindOtherComponents ();
    if (SUCCEEDED(hr))
    {
        // These will be the number of miniports we add(+) or remove(-) for
        // the in and out directions.  ('d' is hungarian for 'difference'.)
        //
        INT dIpOut, dNbfIn, dNbfOut;
        dIpOut = dNbfIn = dNbfOut = 0;

        UINT cCurIpOut, cCurNbfIn, cCurNbfOut;
        hr = HrCountInstalledMiniports (&cCurIpOut, &cCurNbfIn, &cCurNbfOut);
        if (SUCCEEDED(hr))
        {
            PRODUCT_FLAVOR pf;
            (VOID) GetProductFlavor (NULL, &pf);

            // This is the number of miniports we want to end up with
            // without normalizing the number within the max range.
            //
            INT cDesiredIpOut  = 2;
            INT cDesiredNbfIn  = 0;
            INT cDesiredNbfOut = 1;

            if (PF_SERVER == pf)
            {
                cDesiredNbfIn  = 2;
            }

            dIpOut  = ((PnccIp())  ? cDesiredIpOut  : 0) - cCurIpOut;
            dNbfIn  = ((PnccNbf()) ? cDesiredNbfIn  : 0) - cCurNbfIn;
            dNbfOut = ((PnccNbf()) ? cDesiredNbfOut : 0) - cCurNbfOut;
        }

        if (SUCCEEDED(hr) && dIpOut)
        {
            hr = HrAddOrRemoveIpOut (dIpOut);
        }

        if (SUCCEEDED(hr) && dNbfIn)
        {
            hr = HrAddOrRemoveNbfIn (dNbfIn);
        }

        if (SUCCEEDED(hr) && dNbfOut)
        {
            hr = HrAddOrRemoveNbfOut (dNbfOut);
        }

        // Normalize the HRESULT.  (i.e. don't return S_FALSE)
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }

        ReleaseOtherComponents ();
    }
    TraceError ("CRasBindObject::HrProcessEndpointChange", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\modemdi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M O D E M D I . H
//
//  Contents:   Modem coclass device installer hook.
//
//  Notes:
//
//  Author:     shaunco   7 May 1997
//
//----------------------------------------------------------------------------

#pragma once

extern const WCHAR c_szModemAttachedTo [];

HRESULT
HrModemClassCoInstaller (
        DI_FUNCTION                 dif,
        HDEVINFO                    hdi,
        PSP_DEVINFO_DATA            pdeid,
        PCOINSTALLER_CONTEXT_DATA   pContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\ncutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       N C U T I L . H
//
//  Contents:   INetCfg utilities.  Some of these could to be moved into
//              nccommon\src\ncnetcfg.cpp.
//
//  Notes:
//
//  Author:     shaunco   28 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "ncstring.h"
#include "netcfgx.h"

inline
BOOL
FIsAdapterInstalled (
    INetCfg*    pnc,
    PCWSTR     pszComponentId)
{
    return (S_OK == pnc->FindComponent (pszComponentId, NULL));
}

HRESULT
HrEnsureZeroOrOneAdapter (
    INetCfg*    pnc,
    PCWSTR     pszComponentId,
    DWORD       dwFlags);

HRESULT
HrGetInstanceGuidAsString (
    INetCfgComponent*   pncc,
    PWSTR              pszGuid,
    INT                 cchGuid);


HRESULT
HrMapComponentIdToDword (
    INetCfgComponent*   pncc,
    const MAP_SZ_DWORD* aMapSzDword,
    UINT                cMapSzDword,
    DWORD*              pdwValue);

HRESULT
HrOpenComponentParamKey (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszComponentId,
    HKEY*       phkey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\ncutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       N C U T I L . C P P
//
//  Contents:   INetCfg utilities.  This is all a candidate to be moved into
//              nccommon\src\ncnetcfg.cpp.
//
//  Notes:
//
//  Author:     shaunco   28 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcfg.h"
#include "ncutil.h"

extern const WCHAR c_szInfId_MS_NdisWanIp[];

//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureZeroOrOneAdapter
//
//  Purpose:
//
//  Arguments:
//      pnc            []
//      pszComponentId []
//      dwFlags        []
//
//  Returns:
//
//  Author:     shaunco   5 Dec 1997
//
//  Notes:
//
HRESULT
HrEnsureZeroOrOneAdapter (
    INetCfg*    pnc,
    PCWSTR     pszComponentId,
    DWORD       dwFlags)
{
    HRESULT hr = S_OK;

    if (dwFlags & ARA_ADD)
    {
        // Make sure we have one present.
        //
        if (!FIsAdapterInstalled (pnc, pszComponentId))
        {
            TraceTag (ttidRasCfg, "Adding %S", pszComponentId);

            hr = HrAddOrRemoveAdapter (pnc, pszComponentId,
                             ARA_ADD, NULL, 1, NULL);
        }
    }
    else
    {
        // Make sure we have none present.
        //
        TraceTag (ttidRasCfg, "Removing %S", pszComponentId);

        hr = HrFindAndRemoveAllInstancesOfAdapter (pnc, pszComponentId);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrEnsureZeroOrOneAdapter");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuidAsString
//
//  Purpose:
//
//  Arguments:
//      pncc    []
//      pszGuid []
//      cchGuid []
//
//  Returns:
//
//  Author:     shaunco   14 Jun 1997
//
//  Notes:
//
HRESULT
HrGetInstanceGuidAsString (
    INetCfgComponent*   pncc,
    PWSTR              pszGuid,
    INT                 cchGuid)
{
    GUID guid;
    HRESULT hr = pncc->GetInstanceGuid (&guid);
    if(SUCCEEDED(hr))
    {
        if (0 == StringFromGUID2(guid, pszGuid, cchGuid))
        {
            hr = E_INVALIDARG;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrGetInstanceGuidAsString");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMapComponentIdToDword
//
//  Purpose:    Maps a component's id to a DWORD value.  The mapping is
//              specified by the caller through an array of pointers to
//              string values and their associated DWORD values.
//
//  Arguments:
//      pncc        [in]    pointer to component.
//      aMapSzDword [in]    array of elements mapping a string to a DWORD.
//      cMapSzDword [in]    count of elements in the array.
//      pdwValue    [out]   the returned value.
//
//  Returns:    S_OK if a match was found.  If a match wasn't found,
//              S_FALSE is returned.
//              Other Win32 error codes.
//
//  Author:     shaunco   17 May 1997
//
//  Notes:
//
HRESULT
HrMapComponentIdToDword (
    INetCfgComponent*   pncc,
    const MAP_SZ_DWORD* aMapSzDword,
    UINT                cMapSzDword,
    DWORD*              pdwValue)
{
    Assert (pncc);
    Assert (aMapSzDword);
    Assert (cMapSzDword);
    Assert (pdwValue);

    // Initialize output parameter.
    *pdwValue = 0;

    PWSTR pszwId;
    HRESULT hr = pncc->GetId (&pszwId);
    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;
        while (cMapSzDword--)
        {
            if (FEqualComponentId (pszwId, aMapSzDword->pszValue))
            {
                *pdwValue = aMapSzDword->dwValue;
                hr = S_OK;
                break;
            }
            aMapSzDword++;
        }
        CoTaskMemFree (pszwId);
    }
    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
            "HrMapComponentIdToDword");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenComponentParamKey
//
//  Purpose:    Find a component and open its parameter key.
//
//  Arguments:
//      pnc            [in]
//      rguidClass     [in]
//      pszComponentId [in]
//      phkey          [out]
//
//  Returns:    S_OK if the component was found the key was opened.
//              S_FALSE if the compoennt was not found.
//              error code.
//
//  Author:     shaunco   13 Apr 1997
//
//  Notes:
//
HRESULT
HrOpenComponentParamKey (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszComponentId,
    HKEY*       phkey)
{
    Assert (pnc);
    Assert (pszComponentId);
    Assert (phkey);

    // Initialize the output parameter.
    *phkey = NULL;

    // Find the component.
    INetCfgComponent* pncc;
    HRESULT hr = pnc->FindComponent ( pszComponentId, &pncc);
    if (S_OK == hr)
    {
        // Open its param key.
        hr = pncc->OpenParamKey (phkey);
        ReleaseObj (pncc);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
            "HrOpenComponentParamKey");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\modemdi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M O D E M D I . C P P
//
//  Contents:   Modem coclass device installer hook.
//
//  Notes:
//
//  Author:     shaunco   7 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncsetup.h"

HRESULT
HrUpdateLegacyRasTapiDevices ();


//+---------------------------------------------------------------------------
//
//  Function:   HrModemClassCoInstaller
//
//  Purpose:    Responds to co-class installer messages to install and remove
//              net modem adapters.
//
//  Arguments:
//      dif      [in] See SetupApi.
//      hdi      [in]
//      pdeid    [in]
//      pContext [inout]
//
//  Returns:    S_OK, SPAPI_E_DI_POSTPROCESSING_REQUIRED, or an error code.
//
//  Author:     shaunco   3 Aug 1997
//
//  Notes:
//
HRESULT
HrModemClassCoInstaller (
    IN     DI_FUNCTION                  dif,
    IN     HDEVINFO                     hdi,
    IN     PSP_DEVINFO_DATA             pdeid,
    IN OUT PCOINSTALLER_CONTEXT_DATA    pContext)
{
    HRESULT hr = S_OK;

    if (DIF_INSTALLDEVICE == dif)
    {
        // When we're called during preprocessing, indicated
        // we require postprocessing.
        //
        if (!pContext->PostProcessing)
        {
            // Documentation indicates it, so we'll assert it.
            AssertSz (NO_ERROR == pContext->InstallResult,
                      "HrModemClassCoInstaller: Bug in SetupApi!  "
                      "InstallResult should be NO_ERROR.");

            // Make sure they wouldn't loose our context info
            // even if we used it.
#ifdef DBG
            pContext->PrivateData = NULL;
#endif // DBG

            hr = SPAPI_E_DI_POSTPROCESSING_REQUIRED;
        }
        else
        {


            // Check out "context info" to make sure they didn't
            // touch it.
            //
            AssertSz (!pContext->PrivateData, "HrModemClassCoInstaller: "
                      "Bug in SetupApi!  You sunk my battleship!  "
                      "(I mean, you trashed my PrivateData)");

            // We are now in the postprocessing phase.
            // We will install a virtual network adapter for
            // the modem that was just installed but only if
            // it was installed successfully.
            //

            // We should have handled this case back in ModemClassCoInstaller.
            //
            AssertSz (NO_ERROR == pContext->InstallResult,
                      "HrModemClassCoInstaller: Bug in ModemClassCoInstaller!  "
                      "InstallResult should be NO_ERROR or we would have "
                      "returned immediately.");


            hr = S_OK;
        }
    }

    else if (DIF_REMOVE == dif)
    {
        // We're not going to fail remove operations.  It's bad enough
        // when a user can't add a modem.  It pisses them off to no end
        // if they can't remove them.
        //
        hr = S_OK;
    }

    else if (DIF_DESTROYPRIVATEDATA == dif)
    {
        (VOID) HrUpdateLegacyRasTapiDevices ();
    }

    TraceError ("HrModemClassCoInstaller",
            (SPAPI_E_DI_POSTPROCESSING_REQUIRED == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUpdateLegacyRasTapiDevices
//
//  Purpose:    Legacy applications such as HPC Explorer 1.1 require
//              that modems that are "enabled" for RAS use be specified
//              under HKLM\Software\Microsoft\Ras\Tapi Devices\Unimodem.
//              The values that exist under these keys are multi-sz's of
//              COM ports, Friendly names, and Usage.  This routine sets
//              those keys corresponding to all modems present on the
//              machine (and active in this HW profile).
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   19 Mar 1998
//
//  Notes:
//
HRESULT
HrUpdateLegacyRasTapiDevices ()
{
    // Keep lists of strings that we will write as multi-sz to
    // HKLM\Software\Microsoft\Ras\Tapi Devices\Unimodem.
    //
    list<tstring*>  lstrAddress;
    list<tstring*>  lstrFriendlyName;
    list<tstring*>  lstrUsage;

    // Get all of the installed modems.
    //
    HDEVINFO hdi;
    HRESULT hr = HrSetupDiGetClassDevs (&GUID_DEVCLASS_MODEM, NULL,
                    NULL, DIGCF_PRESENT | DIGCF_PROFILE, &hdi);
    if (SUCCEEDED(hr))
    {
        // Declare these outside the while loop to avoid construction
        // destruction at each iteration.
        //
        tstring strAttachedTo;
        tstring strFriendlyName;

        // Enumerate the devices and open their dev reg key.
        //
        DWORD dwIndex = 0;
        SP_DEVINFO_DATA deid;
        while (SUCCEEDED(hr = HrSetupDiEnumDeviceInfo (hdi, dwIndex++, &deid)))
        {
            // Try to open the registry key for this modem.  If it fails,
            // ignore and move on to the next.
            //
            HKEY hkey;
            hr = HrSetupDiOpenDevRegKey(hdi, &deid,
                            DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                            KEY_READ, &hkey);
            if (SUCCEEDED(hr))
            {
                // Get the AttachedTo and FriendlyName values for the modem.
                // PnPAttachedTo will be present for PnP modems.
                //
                static const WCHAR c_szModemAttachedTo   [] = L"AttachedTo";
                static const WCHAR c_szModemPnPAttachedTo[] = L"PnPAttachedTo";
                static const WCHAR c_szModemFriendlyName [] = L"FriendlyName";
                static const WCHAR c_szUsage             [] = L"ClientAndServer";

                // Look for PnPAttached to first, then fallback to AttachedTo
                // if it failed.
                //
                hr = HrRegQueryString (hkey, c_szModemPnPAttachedTo,
                            &strAttachedTo);
                if (FAILED(hr))
                {
                    hr = HrRegQueryString (hkey, c_szModemAttachedTo,
                                &strAttachedTo);
                }
                if (SUCCEEDED(hr))
                {
                    hr = HrRegQueryString (hkey, c_szModemFriendlyName,
                                &strFriendlyName);
                    if (SUCCEEDED(hr))
                    {
                        // Add them to our lists.
                        lstrAddress     .push_back (new tstring (strAttachedTo));
                        lstrFriendlyName.push_back (new tstring (strFriendlyName));
                        lstrUsage       .push_back (new tstring (c_szUsage));
                    }
                }

                RegCloseKey (hkey);
            }
        }
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }


        SetupDiDestroyDeviceInfoList (hdi);
    }

    // Now save the lists as multi-sz's.
    //
    static const WCHAR c_szRegKeyLegacyRasUnimodemTapiDevices[]
        = L"Software\\Microsoft\\Ras\\Tapi Devices\\Unimodem";
    HKEY hkey;
    hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE,
            c_szRegKeyLegacyRasUnimodemTapiDevices,
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, NULL);
    if (SUCCEEDED(hr))
    {
        static const WCHAR c_szRegValAddress      [] = L"Address";
        static const WCHAR c_szRegValFriendlyName [] = L"Friendly Name";
        static const WCHAR c_szRegValUsage        [] = L"Usage";

        (VOID) HrRegSetColString (hkey, c_szRegValAddress,      lstrAddress);
        (VOID) HrRegSetColString (hkey, c_szRegValFriendlyName, lstrFriendlyName);
        (VOID) HrRegSetColString (hkey, c_szRegValUsage,        lstrUsage);


        static const WCHAR c_szRegValMediaType    [] = L"Media Type";
        static const WCHAR c_szRegValModem        [] = L"Modem";

        (VOID) HrRegSetSz (hkey, c_szRegValMediaType, c_szRegValModem);

        RegCloseKey (hkey);
    }

    FreeCollectionAndItem (lstrUsage);
    FreeCollectionAndItem (lstrFriendlyName);
    FreeCollectionAndItem (lstrAddress);

    TraceError ("HrUpdateLegacyRasTapiDevices", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\pptp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P P T P . C P P
//
//  Contents:   Implementation of PPTP configuration object.
//
//  Notes:
//
//  Author:     shaunco   10 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ndiswan.h"
#include "rasobj.h"

extern const WCHAR c_szInfId_MS_PptpMiniport[];

CPptp::CPptp () : CRasBindObject ()
{
    m_pnccMe = NULL;
    m_fSaveAfData = FALSE;
}

CPptp::~CPptp ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CPptp::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    //
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    return S_OK;
}

STDMETHODIMP
CPptp::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CPptp::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CPptp::ApplyRegistryChanges ()
{
    if (m_fSaveAfData)
    {
        m_AfData.SaveToRegistry (m_pnc);
        m_fSaveAfData = FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CPptp::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile (pszAnswerFile, pszAnswerSection);

    // Read data from the answer file.
    // Don't let this affect the HRESULT we return.
    //
    if (SUCCEEDED(m_AfData.HrOpenAndRead (pszAnswerFile, pszAnswerSection)))
    {
        m_fSaveAfData = TRUE;
    }

    return S_OK;
}

STDMETHODIMP
CPptp::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install the PPTP miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PptpMiniport, ARA_ADD);

    TraceError ("CPptp::Install", hr);
    return hr;
}

STDMETHODIMP
CPptp::Removing ()
{
    HRESULT hr;

    // Remove the PPTP miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PptpMiniport, ARA_REMOVE);

    TraceError ("CPptp::Removing", hr);
    return hr;
}

STDMETHODIMP
CPptp::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\ndiswan.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000.
//
//  File:       N D I S W A N . C P P
//
//  Contents:   Implementation of NdisWan configuration object.
//
//  Notes:
//
//  Author:     shaunco   28 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ndiswan.h"
#include "ncreg.h"
#include "mprerror.h"
#include "rtutils.h"

extern const WCHAR c_szInfId_MS_AppleTalk[];
extern const WCHAR c_szInfId_MS_L2TP[];
extern const WCHAR c_szInfId_MS_L2tpMiniport[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_NdisWanAtalk[];
extern const WCHAR c_szInfId_MS_NdisWanBh[];
extern const WCHAR c_szInfId_MS_NdisWanIp[];
extern const WCHAR c_szInfId_MS_NdisWanIpx[];
extern const WCHAR c_szInfId_MS_NdisWanNbfIn[];
extern const WCHAR c_szInfId_MS_NdisWanNbfOut[];
extern const WCHAR c_szInfId_MS_NetBEUI[];
extern const WCHAR c_szInfId_MS_NetMon[];
extern const WCHAR c_szInfId_MS_PPTP[];
extern const WCHAR c_szInfId_MS_PptpMiniport[];
extern const WCHAR c_szInfId_MS_RasMan[];
extern const WCHAR c_szInfId_MS_TCPIP[];
extern const WCHAR c_szInfId_MS_PPPOE[];
extern const WCHAR c_szInfId_MS_PppoeMiniport[];

extern const WCHAR c_szRegValWanEndpoints[]    = L"WanEndpoints";
static const WCHAR c_szRegValMinWanEndpoints[] = L"MinWanEndpoints";
static const WCHAR c_szRegValMaxWanEndpoints[] = L"MaxWanEndpoints";

//$ TODO (shaunco) 3 Feb 1998: rasman has no notify object so just
// merge its services into ndiswan's and eliminate c_apguidInstalledOboNdiswan

//----------------------------------------------------------------------------
// Data used for installing other components.
//
static const GUID* c_apguidInstalledOboNdiswan [] =
{
    &GUID_DEVCLASS_NETSERVICE,  // RasMan
};

static const PCWSTR c_apszInstalledOboNdiswan [] =
{
    c_szInfId_MS_RasMan,
};


static const GUID* c_apguidInstalledOboUser [] =
{
    &GUID_DEVCLASS_NETTRANS,    // L2TP
    &GUID_DEVCLASS_NETTRANS,    // PPTP
    &GUID_DEVCLASS_NETTRANS,    // PPPOE
};

static const PCWSTR c_apszInstalledOboUser [] =
{
    c_szInfId_MS_L2TP,
    c_szInfId_MS_PPTP,
    c_szInfId_MS_PPPOE,
};


CNdisWan::CNdisWan () : CRasBindObject ()
{
    m_fInstalling        = FALSE;
    m_fRemoving          = FALSE;
    m_pnccMe             = NULL;
}

CNdisWan::~CNdisWan ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CNdisWan::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    //
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    m_fInstalling = fInstalling;

    return S_OK;
}

STDMETHODIMP
CNdisWan::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::ApplyRegistryChanges ()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CNdisWan::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install rasman.
    //
    hr = HrInstallComponentsOboComponent (m_pnc, NULL,
            celems (c_apguidInstalledOboNdiswan),
            c_apguidInstalledOboNdiswan,
            c_apszInstalledOboNdiswan,
            m_pnccMe);

//$ TODO (shaunco) 28 Dec 1997: Install L2TP, PPTP, PPPOE obo ndiswan.
//  But, this creates an upgrade problem.

    if (SUCCEEDED(hr))
    {
        hr = HrInstallComponentsOboUser (m_pnc, NULL,
                celems (c_apguidInstalledOboUser),
                c_apguidInstalledOboUser,
                c_apszInstalledOboUser);
    }

    if (SUCCEEDED(hr))
    {
        hr = HrAddOrRemovePti (ARA_ADD);
    }

    if (SUCCEEDED(hr))
    {
        hr = HrFindOtherComponents ();
        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr) && PnccAtalk())
            {
                hr = HrAddOrRemoveAtalkInOut (ARA_ADD);
            }

            if (SUCCEEDED(hr) && PnccIp())
            {
                hr = HrAddOrRemoveIpAdapter (ARA_ADD);
            }

            if (SUCCEEDED(hr) && PnccIpx())
            {
                hr = HrAddOrRemoveIpxInOut (ARA_ADD);
            }

            if (SUCCEEDED(hr) && PnccNetMon())
            {
                hr = HrAddOrRemoveNetMonInOut (ARA_ADD);
            }

            ReleaseOtherComponents ();
        }
    }

    // Recompute (and adjust if needed) the number of ndiswan miniports.
    //
    hr = HrProcessEndpointChange ();
    TraceError ("CNdisWan::Install: HrProcessEndpointChange failed. "
        "(not propagating error)", hr);

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if ((NSF_WINNT_WKS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SBS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SVR_UPGRADE & dwSetupFlags))
    {
        HKEY    hkeyMd5;

        if (SUCCEEDED(HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\Rasman\\PPP\\CHAP\\MD5",
            KEY_READ, &hkeyMd5)))
        {
            HANDLE  hLog;

            // MD5 key was found. Need to log something to the eventlog.
            hLog = RouterLogRegister(L"RemoteAccess");
            if (hLog)
            {
                RouterLogWarning(hLog, WARNING_NO_MD5_MIGRATION, 0,
                                 NULL, NO_ERROR);

                RouterLogDeregister(hLog);
            }

            RegCloseKey (hkeyMd5);
        }
    }

    //  Check to see if Connection Manager is installed and
    //  if there are any profiles to migrate.  We do this
    //  by opening the CM mappings key and checking to see if it contains any
    //  values.  and if so then write a run-once setup key so that
    //  we can migrate profiles when the user logs in for the first time.
    //  Note that this only works for NT to NT upgrades.  The win9x registry
    //  hasn't been filled in by the time that this runs.  Thus our win9x
    //  migration dll (cmmgr\migration.dll) takes care of the win9x case.
    //

    static const WCHAR c_CmdString[] = L"cmstp.exe /m";
    static const WCHAR c_ValueString[] = L"Connection Manager Profiles Upgrade";
    static const WCHAR c_szRegCmMappings[] = L"SOFTWARE\\Microsoft\\Connection Manager\\Mappings";
    static const WCHAR c_szRegRunKey[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
    static const WCHAR c_szRegCmUninstallKey[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Connection Manager";

    static const WCHAR c_szRegSysCompValue[] = L"SystemComponent";

    // dwTemp is used as temp DWORD.  Used as Disposition DWORD for RegCreateKey, and
    // as a value holder for RegSetValueEx
    //
    DWORD dwTemp;

    HKEY hKey;
    HRESULT hrT;

    //  Set the Connection Manager key as a system component.  This will prevent 1.0 installs
    //  from writing this key and having it show up in Add/Remove Programs (the syscomp flags
    //  tells ARP not to display the key).
    //
    hrT = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           c_szRegCmUninstallKey,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKey,
                           &dwTemp);

    if (SUCCEEDED(hrT))
    {
        dwTemp = 1;
        hrT = HrRegSetDword(hKey, c_szRegSysCompValue, dwTemp);
        RegCloseKey(hKey);
    }

    //  Now try to migrate profiles
    //
    hrT = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         c_szRegCmMappings,
                         KEY_READ,
                         &hKey);

    if (SUCCEEDED(hrT))
    {
        dwTemp = 0;
        hrT = HrRegQueryInfoKey (hKey, NULL, NULL, NULL, NULL, NULL,
                                 &dwTemp, NULL, NULL, NULL, NULL);

        if ((SUCCEEDED(hrT)) && (dwTemp > 0))
        {
            //  Then we have mappings values, so we need to migrate them.
            //

            RegCloseKey(hKey);

            hrT = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  c_szRegRunKey,
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE | KEY_READ,
                                  NULL,
                                  &hKey,
                                  &dwTemp);

            if (SUCCEEDED(hrT))
            {
                hrT = HrRegSetSz (hKey, c_ValueString, c_CmdString);
                RegCloseKey(hKey);
            }
        }
        else
        {
            RegCloseKey(hKey);
        }
    }

    TraceError ("CNdisWan::Install", hr);
    return hr;
}

STDMETHODIMP
CNdisWan::Removing ()
{
    static const PCWSTR c_apszInfIdRemove [] =
    {
        c_szInfId_MS_L2tpMiniport,
        c_szInfId_MS_NdisWanAtalk,
        c_szInfId_MS_NdisWanBh,
        c_szInfId_MS_NdisWanIp,
        c_szInfId_MS_NdisWanIpx,
        c_szInfId_MS_NdisWanNbfIn,
        c_szInfId_MS_NdisWanNbfOut,
        c_szInfId_MS_PptpMiniport,
        c_szInfId_MS_PtiMiniport,
        c_szInfId_MS_PppoeMiniport,
    };

    m_fRemoving = TRUE;

    HRESULT hr = S_OK;

    // Remove wanarp and rasman.
    //
    HRESULT hrT = HrFindAndRemoveComponentsOboComponent (m_pnc,
                    celems (c_apguidInstalledOboNdiswan),
                    c_apguidInstalledOboNdiswan,
                    c_apszInstalledOboNdiswan,
                    m_pnccMe);

    hr = hrT;

    // Remove L2TP, PPTP and PPPOE on behalf of the user.
    //
    hrT = HrFindAndRemoveComponentsOboUser (m_pnc,
            celems (c_apguidInstalledOboUser),
            c_apguidInstalledOboUser,
            c_apszInstalledOboUser);
    if (SUCCEEDED(hr))
    {
        hr = hrT;
    }

    // Remove all of the adapters we may have created.
    //
    hrT = HrFindAndRemoveAllInstancesOfAdapters (m_pnc,
            celems(c_apszInfIdRemove),
            c_apszInfIdRemove);
    if (SUCCEEDED(hr))
    {
        hr = hrT;
    }

    // Don't return S_FALSE or NETCFG_S_STILL_REFERENCED
    //
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    Validate_INetCfgNotify_Removing_Return (hr);

    TraceError ("CNdisWan::Removing", hr);
    return hr;
}

STDMETHODIMP
CNdisWan::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    HRESULT hr;

    hr= HrInstallComponentsOboUser (m_pnc, NULL,
                    celems (c_apguidInstalledOboUser),
                    c_apguidInstalledOboUser,
                    c_apszInstalledOboUser);
    TraceError ("CNdisWan::Upgrade: HrInstallComponentsOboUser failed. "
        "(not propagating error)", hr);

    HKEY hkeyNew;
    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters",
            KEY_WRITE,
            &hkeyNew);

    if (SUCCEEDED(hr))
    {
        HKEY hkeyCurrent;
        DWORD dwValue;

        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Services\\Rasman\\PPP",
                    KEY_READ,
                    &hkeyCurrent);
        if (SUCCEEDED(hr))
        {
            // Move 'ServerFlags' value to new location.  This is for
            // interim NT5 builds.  This can go away after Beta3 ships.
            //
            hr = HrRegQueryDword (hkeyCurrent, L"ServerFlags", &dwValue);
            if (SUCCEEDED(hr))
            {
                hr = HrRegSetDword (hkeyNew, L"ServerFlags", dwValue);

                (VOID) HrRegDeleteValue (hkeyCurrent, L"ServerFlags");
            }

            RegCloseKey (hkeyCurrent);
        }

        // Copy 'RouterType' value to new location.
        //
        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    L"Software\\Microsoft\\Ras\\Protocols",
                    KEY_READ,
                    &hkeyCurrent);
        if (SUCCEEDED(hr))
        {
            hr = HrRegQueryDword (hkeyCurrent, L"RouterType", &dwValue);
            if (SUCCEEDED(hr))
            {
                hr = HrRegSetDword (hkeyNew, L"RouterType", dwValue);
            }

            RegCloseKey (hkeyCurrent);
        }

        RegCloseKey (hkeyNew);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgSystemNotify
//
STDMETHODIMP
CNdisWan::GetSupportedNotifications (
    DWORD*  pdwNotificationFlag)
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications (pdwNotificationFlag);

    *pdwNotificationFlag = NCN_BINDING_PATH |
                           NCN_NETTRANS | NCN_NETSERVICE |
                           NCN_ADD | NCN_REMOVE;

    return S_OK;
}

STDMETHODIMP
CNdisWan::SysQueryBindingPath (
    DWORD               dwChangeFlag,
    INetCfgBindingPath* pncbp)
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::SysQueryComponent (
    DWORD               dwChangeFlag,
    INetCfgComponent*   pncc)
{
    return S_OK;
}

STDMETHODIMP
CNdisWan::SysNotifyBindingPath (
    DWORD               dwChangeFlag,
    INetCfgBindingPath* pncbp)
{
    HRESULT hr;
    HKEY hkey;

    Validate_INetCfgSystemNotify_SysNotifyBindingPath (dwChangeFlag, pncbp);

    hkey = NULL;

    // ndisatm miniports don't write WanEndpoints to their instance key.
    // We default it and write WanEndpoints for them.
    //
    if (dwChangeFlag & NCN_ADD)
    {
        CIterNetCfgBindingInterface ncbiIter(pncbp);
        INetCfgBindingInterface* pncbi;

        hr = S_OK;

        while (!hkey && SUCCEEDED(hr) &&
               (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            RAS_BINDING_ID RasBindId;

            if (FIsRasBindingInterface (pncbi, &RasBindId) &&
                (RBID_NDISATM == RasBindId))
            {
                INetCfgComponent* pnccLower;

                hr = pncbi->GetLowerComponent (&pnccLower);
                if (SUCCEEDED(hr))
                {
                    TraceTag (ttidRasCfg, "New ATM adapter");
                    hr = pnccLower->OpenParamKey (&hkey);

                    ReleaseObj (pnccLower);
                }
            }
            ReleaseObj(pncbi);
        }
    }

    if (hkey)
    {
        DWORD dwEndpoints;
        DWORD dwValue;

        hr = HrRegQueryDword (hkey, c_szRegValWanEndpoints, &dwEndpoints);
        if (FAILED(hr))
        {
            TraceTag (ttidRasCfg, "Defaulting WanEndpoints");

            dwEndpoints = 5;

            // Validate the default between the min and max
            // specified by the driver (if specified).
            //
            if (SUCCEEDED(HrRegQueryDword (hkey,
                                c_szRegValMaxWanEndpoints,
                                &dwValue)))
            {
                if ((dwValue < INT_MAX) && (dwEndpoints > dwValue))
                {
                    dwEndpoints = dwValue;
                }
            }
            else
            {
                (VOID) HrRegSetDword(hkey, c_szRegValMaxWanEndpoints, 500);
            }

            if (SUCCEEDED(HrRegQueryDword (hkey,
                                c_szRegValMinWanEndpoints,
                                &dwValue)))
            {
                if ((dwValue < INT_MAX) && (dwEndpoints < dwValue))
                {
                    dwEndpoints = dwValue;
                }
            }
            else
            {
                (VOID) HrRegSetDword(hkey, c_szRegValMinWanEndpoints, 0);
            }

            (VOID) HrRegSetDword (hkey, c_szRegValWanEndpoints, dwEndpoints);
        }

        RegCloseKey (hkey);
    }

    return S_FALSE;
}

STDMETHODIMP
CNdisWan::SysNotifyComponent (
    DWORD               dwChangeFlag,
    INetCfgComponent*   pncc)
{
    HRESULT hr = S_OK;

    Validate_INetCfgSystemNotify_SysNotifyComponent (dwChangeFlag, pncc);

    // If a protocol is coming or going, add or remove the
    // ndiswanXXX miniports.
    //
    DWORD dwAraFlags = 0;
    if (dwChangeFlag & NCN_ADD)
    {
        dwAraFlags = ARA_ADD;
    }
    else if (dwChangeFlag & NCN_REMOVE)
    {
        dwAraFlags = ARA_REMOVE;
    }
    if (dwAraFlags)
    {
        BOOL fProcessEndpoingChange = FALSE;

        PWSTR pszId;
        hr = pncc->GetId (&pszId);
        if (SUCCEEDED(hr))
        {
            if (FEqualComponentId (c_szInfId_MS_TCPIP, pszId))
            {
                hr = HrAddOrRemoveIpAdapter (dwAraFlags);
                fProcessEndpoingChange = TRUE;
            }
            else if (FEqualComponentId (c_szInfId_MS_NWIPX, pszId))
            {
                hr = HrAddOrRemoveIpxInOut (dwAraFlags);
            }
            else if (FEqualComponentId (c_szInfId_MS_NetBEUI, pszId))
            {
                fProcessEndpoingChange = TRUE;
            }
            else if (FEqualComponentId (c_szInfId_MS_AppleTalk, pszId))
            {
                hr = HrAddOrRemoveAtalkInOut (dwAraFlags);
            }
            else if (FEqualComponentId (c_szInfId_MS_NetMon, pszId))
            {
                hr = HrAddOrRemoveNetMonInOut (dwAraFlags);
            }

            CoTaskMemFree (pszId);
        }

        if (SUCCEEDED(hr) && fProcessEndpoingChange)
        {
            hr = HrProcessEndpointChange ();
        }
    }

    TraceError ("CNdisWan::SysNotifyComponent", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\pppoe.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P P T P . C P P
//
//  Contents:   Implementation of PPPOE configuration object.
//
//  Notes:
//
//  Author:     shaunco   10 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ndiswan.h"
#include "rasobj.h"

extern const WCHAR c_szInfId_MS_PppoeMiniport[];

CPppoe::CPppoe () : CRasBindObject ()
{
    m_pnccMe = NULL;
    m_fSaveAfData = FALSE;
}

CPppoe::~CPppoe ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CPppoe::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    //
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    return S_OK;
}

STDMETHODIMP
CPppoe::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CPppoe::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CPppoe::ApplyRegistryChanges ()
{
    if (m_fSaveAfData)
    {
        m_AfData.SaveToRegistry (m_pnc);
        m_fSaveAfData = FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CPppoe::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile (pszAnswerFile, pszAnswerSection);

    // Read data from the answer file.
    // Don't let this affect the HRESULT we return.
    //
    if (SUCCEEDED(m_AfData.HrOpenAndRead (pszAnswerFile, pszAnswerSection)))
    {
        m_fSaveAfData = TRUE;
    }

    return S_OK;
}

STDMETHODIMP
CPppoe::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install the PPPOE miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PppoeMiniport, ARA_ADD);

    TraceError ("CPppoe::Install", hr);
    return hr;
}

STDMETHODIMP
CPppoe::Removing ()
{
    HRESULT hr;

    // Remove the PPPOE miniport driver.
    //
    hr = HrEnsureZeroOrOneAdapter (m_pnc, c_szInfId_MS_PppoeMiniport, ARA_REMOVE);

    TraceError ("CPppoe::Removing", hr);
    return hr;
}

STDMETHODIMP
CPppoe::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\rasaf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S A F . C P P
//
//  Contents:   RAS Answer File objects.
//
//  Notes:
//
//  Author:     shaunco   19 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncipaddr.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "rasaf.h"
#include "rasobj.h"

extern const WCHAR c_szAfAppleTalk[];
extern const WCHAR c_szAfAutoNetworkNumbers[];
extern const WCHAR c_szAfClientCanReqIpaddr[];
extern const WCHAR c_szAfClientReqNodeNumber[];
extern const WCHAR c_szAfDialinProtocols[];
extern const WCHAR c_szAfForceEncryptedData[];
extern const WCHAR c_szAfForceStrongEncryption[];
extern const WCHAR c_szAfForceEncryptedPassword[];
extern const WCHAR c_szAfWanNetPoolSize[];
extern const WCHAR c_szAfIpAddressStart[];
extern const WCHAR c_szAfIpAddressEnd[];
extern const WCHAR c_szAfIpxClientAccess[];
extern const WCHAR c_szAfIpx[];
extern const WCHAR c_szAfL2tpMaxVcs[];
extern const WCHAR c_szAfL2tpEndpoints[];
extern const WCHAR c_szAfMultilink[];
extern const WCHAR c_szAfNetNumberFrom[];
extern const WCHAR c_szAfNetbeuiClientAccess[];
extern const WCHAR c_szAfNetbeui[];
extern const WCHAR c_szAfNetwork[];
extern const WCHAR c_szAfParamsSection[];
extern const WCHAR c_szAfPptpEndpoints[];
extern const WCHAR c_szAfRouterType[];
extern const WCHAR c_szAfSecureVPN[];
extern const WCHAR c_szAfSetDialinUsage[];
extern const WCHAR c_szAfSameNetworkNumber[];
extern const WCHAR c_szAfTcpipClientAccess[];
extern const WCHAR c_szAfTcpip[];
extern const WCHAR c_szAfThisComputer[];
extern const WCHAR c_szAfUseDhcp[];

extern const WCHAR c_szInfId_MS_L2tpMiniport[];
extern const WCHAR c_szInfId_MS_PptpMiniport[];
extern const WCHAR c_szInfId_MS_PppoeMiniport[];


//+---------------------------------------------------------------------------
// CRasSrvAnswerFileData
//
HRESULT
CRasSrvAnswerFileData::HrOpenAndRead (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    // Open the answer file.  It will close itself in it's destructor.
    CSetupInfFile inf;
    UINT unErrorLine;

    HRESULT hr = inf.HrOpen (
                    pszAnswerFile, NULL,
                    INF_STYLE_OLDNT | INF_STYLE_WIN4,
                    &unErrorLine);

    if (SUCCEEDED(hr))
    {
        m_fRouterTypeSpecified = FALSE;
        m_fSetUsageToDialin = FALSE;

        // Prepare the default values for use when we fail to read.
        // Initializing with defaults also helps to gaurantee that bogus
        // values aren't used when we add items to the structure but fail
        // to provide answer file support for them.
        //
        m_dataSrvCfg.GetDefault ();
        m_dataSrvIp .GetDefault ();
        m_dataSrvIpx.GetDefault ();
        m_dataSrvNbf.GetDefault ();

        DATA_SRV_CFG defSrvCfg  = m_dataSrvCfg;
        DATA_SRV_IP  defSrvIp   = m_dataSrvIp;
        DATA_SRV_IPX defSrvIpx  = m_dataSrvIpx;
        DATA_SRV_NBF defSrvNbf  = m_dataSrvNbf;

        // Get the real parameter section.
        //
        tstring strSection;
        hr = inf.HrGetString (pszAnswerSection,
                              c_szAfParamsSection, &strSection);
        if (FAILED(hr))
        {
            // If we failed to find the parameter section, just try
            // this one.
            //
            strSection = pszAnswerSection;
        }

        static const MAP_SZ_DWORD c_mapProtocols [] =
        {
            { c_szAfTcpip,      RPI_IP    },
            { c_szAfIpx,        RPI_IPX   },
            { c_szAfNetbeui,    RPI_NBF   },
            { c_szAfAppleTalk,  RPI_ATALK },
        };
        // Read the list of dial-in protocols.
        //
        hr = inf.HrGetMultiSzMapToDword (strSection.c_str(),
                                         c_szAfDialinProtocols,
                                         c_mapProtocols,
                                         celems (c_mapProtocols),
                                         &m_dwDialInProtocolIds);
        if (FAILED(hr) || !m_dwDialInProtocolIds)
        {
            // If its not there, use all possible.
            m_dwDialInProtocolIds = RPI_ALL;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfMultilink,
                                    &m_dataSrvCfg.fMultilink);
        if (FAILED(hr))
        {
            m_dataSrvCfg.fMultilink = defSrvCfg.fMultilink;
        }

        hr = inf.HrGetDword(strSection.c_str(),
                            c_szAfRouterType,
                            (DWORD*)&m_dataSrvCfg.dwRouterType);
        if (FAILED(hr))
        {
            m_dataSrvCfg.dwRouterType = defSrvCfg.dwRouterType;
        }
        else
        {
            m_fRouterTypeSpecified = TRUE;
        }

        hr = inf.HrGetDword (strSection.c_str(),
                                    c_szAfForceEncryptedPassword,
                                    &m_dataSrvCfg.dwAuthLevel);
        if (FAILED(hr))
        {
            m_dataSrvCfg.dwAuthLevel = defSrvCfg.dwAuthLevel;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfForceEncryptedData,
                                    &m_dataSrvCfg.fDataEnc);
        if (FAILED(hr))
        {
            m_dataSrvCfg.fDataEnc = defSrvCfg.fDataEnc;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfForceStrongEncryption,
                                    &m_dataSrvCfg.fStrongDataEnc);
        if (FAILED(hr))
        {
            m_dataSrvCfg.fStrongDataEnc = defSrvCfg.fStrongDataEnc;
        }

        hr = inf.HrGetDword (strSection.c_str(),
                                    c_szAfSecureVPN,
                                    &m_dataSrvCfg.dwSecureVPN);
        if (FAILED(hr))
        {
            m_dataSrvCfg.dwSecureVPN = defSrvCfg.dwSecureVPN;
        }

        // pmay: 251736
        // Discover whether we are to set all port usage to 'dialin'
        //
        DWORD dwSetUsageToDialin;

        hr = inf.HrGetDword(strSection.c_str(),
                            c_szAfSetDialinUsage,
                            &dwSetUsageToDialin);
        if (SUCCEEDED(hr))
        {
            m_fSetUsageToDialin = !!dwSetUsageToDialin;
        }

        static const MAP_SZ_DWORD c_mapNetworkAccess [] =
        {
            { c_szAfNetwork,        TRUE    },
            { c_szAfThisComputer,   FALSE   },
        };

        // Read the IP values.
        //
        m_dataSrvIp.fEnableIn =
            (m_dwDialInProtocolIds & RPI_IP) ? TRUE : FALSE;

        hr = inf.HrGetStringMapToDword (strSection.c_str(),
                                        c_szAfTcpipClientAccess,
                                        c_mapNetworkAccess,
                                        celems (c_mapNetworkAccess),
                                        (DWORD*)&m_dataSrvIp.fAllowNetworkAccess);
        if (FAILED(hr))
        {
            m_dataSrvIp.fAllowNetworkAccess = defSrvIp.fAllowNetworkAccess;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfUseDhcp,
                                    &m_dataSrvIp.fUseDhcp);
        if (FAILED(hr))
        {
            m_dataSrvIp.fUseDhcp = defSrvIp.fUseDhcp;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfClientCanReqIpaddr,
                                    &m_dataSrvIp.fAllowClientAddr);
        if (FAILED(hr))
        {
            m_dataSrvIp.fAllowClientAddr = defSrvIp.fAllowClientAddr;
        }

        tstring strIpAddress;
        hr = inf.HrGetString (strSection.c_str(),
                             c_szAfIpAddressStart,
                             &strIpAddress);
        if (SUCCEEDED(hr))
        {
            m_dataSrvIp.dwIpStart = IpPszToHostAddr(strIpAddress.c_str());
        }
        else
        {
            m_dataSrvIp.dwIpStart = defSrvIp.dwIpStart;
        }

        hr = inf.HrGetString (strSection.c_str(),
                             c_szAfIpAddressEnd,
                             &strIpAddress);
        if (SUCCEEDED(hr))
        {
            m_dataSrvIp.dwIpEnd = IpPszToHostAddr(strIpAddress.c_str());
        }
        else
        {
            m_dataSrvIp.dwIpEnd = defSrvIp.dwIpEnd;
        }


        // Read the IPX values.
        //
        m_dataSrvIpx.fEnableIn =
            (m_dwDialInProtocolIds & RPI_IPX) ? TRUE : FALSE;

        hr = inf.HrGetStringMapToDword (strSection.c_str(),
                                        c_szAfIpxClientAccess,
                                        c_mapNetworkAccess,
                                        celems (c_mapNetworkAccess),
                                        (DWORD*)&m_dataSrvIpx.fAllowNetworkAccess);
        if (FAILED(hr))
        {
            m_dataSrvIpx.fAllowNetworkAccess = defSrvIpx.fAllowNetworkAccess;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfAutoNetworkNumbers,
                                    &m_dataSrvIpx.fUseAutoAddr);
        if (FAILED(hr))
        {
            m_dataSrvIpx.fUseAutoAddr = defSrvIpx.fUseAutoAddr;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfSameNetworkNumber,
                                    &m_dataSrvIpx.fUseSameNetNum);
        if (FAILED(hr))
        {
            m_dataSrvIpx.fUseSameNetNum = defSrvIpx.fUseSameNetNum;
        }

        hr = inf.HrGetStringAsBool (strSection.c_str(),
                                    c_szAfClientReqNodeNumber,
                                    &m_dataSrvIpx.fAllowClientNetNum);
        if (FAILED(hr))
        {
            m_dataSrvIpx.fAllowClientNetNum = defSrvIpx.fAllowClientNetNum;
        }

        hr = inf.HrGetDword (strSection.c_str(),
                             c_szAfNetNumberFrom,
                             &m_dataSrvIpx.dwIpxNetFirst);
        if (FAILED(hr))
        {
            m_dataSrvIpx.dwIpxNetFirst = defSrvIpx.dwIpxNetFirst;
        }

        hr = inf.HrGetDword (strSection.c_str(),
                             c_szAfWanNetPoolSize,
                             &m_dataSrvIpx.dwIpxWanPoolSize);
        if (FAILED(hr))
        {
            m_dataSrvIpx.dwIpxWanPoolSize = defSrvIpx.dwIpxWanPoolSize;
        }

        // Read the NBF values.
        //
        m_dataSrvNbf.fEnableIn =
            (m_dwDialInProtocolIds & RPI_NBF) ? TRUE : FALSE;

        hr = inf.HrGetStringMapToDword (strSection.c_str(),
                                        c_szAfNetbeuiClientAccess,
                                        c_mapNetworkAccess,
                                        celems (c_mapNetworkAccess),
                                        (DWORD*)&m_dataSrvNbf.fAllowNetworkAccess);
        if (FAILED(hr))
        {
            m_dataSrvNbf.fAllowNetworkAccess = defSrvNbf.fAllowNetworkAccess;
        }

        // Default anything bogus.
        //
        m_dataSrvCfg.CheckAndDefault ();
        m_dataSrvIp .CheckAndDefault ();
        m_dataSrvIpx.CheckAndDefault ();
        m_dataSrvNbf.CheckAndDefault ();

        hr = S_OK;
    }
    TraceError ("CRasSrvAnswerFileData::HrOpenAndRead", hr);
    return hr;
}

VOID
CRasSrvAnswerFileData::SaveToRegistry (
    VOID) const
{
    m_dataSrvCfg.SaveToReg();
    m_dataSrvIp .SaveToReg();
    m_dataSrvIpx.SaveToReg();
    m_dataSrvNbf.SaveToReg();
}

//+---------------------------------------------------------------------------
// CL2tpAnswerFileData
//
const DWORD c_MaxMaxVcs       = 1000;
const DWORD c_DefMaxVcs       = 1000;
const DWORD c_MaxEndpoints    = 1000;
const DWORD c_DefEndpoints    = 5;

VOID
CL2tpAnswerFileData::CheckAndDefault ()
{
    if (m_cMaxVcs > c_MaxMaxVcs)
    {
        m_cMaxVcs = c_DefMaxVcs;
    }

    if (m_cEndpoints > c_MaxEndpoints)
    {
        m_cEndpoints = c_DefEndpoints;
    }
}

HRESULT
CL2tpAnswerFileData::HrOpenAndRead (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    ZeroMemory (this, sizeof(*this));

    // Open the answer file.  It will close itself in it's destructor.
    CSetupInfFile inf;
    UINT unErrorLine;

    HRESULT hr = inf.HrOpen (
                    pszAnswerFile, NULL,
                    INF_STYLE_OLDNT | INF_STYLE_WIN4,
                    &unErrorLine);

    if (SUCCEEDED(hr))
    {
        // Read the number of VPNs.
        //
        hr = inf.HrGetDword (pszAnswerSection,
                             c_szAfL2tpMaxVcs,
                             &m_cMaxVcs);
        if (FAILED(hr))
        {
            m_cMaxVcs = c_DefMaxVcs;
        }

        hr = inf.HrGetDword (pszAnswerSection,
                             c_szAfL2tpEndpoints,
                             &m_cEndpoints);
        if (FAILED(hr))
        {
            m_cEndpoints = c_DefEndpoints;
            m_fWriteEndpoints = FALSE;
        }
        else
        {
            m_fWriteEndpoints = TRUE;
        }

        // Default anything bogus.
        //
        CheckAndDefault ();

        hr = S_OK;
    }
    TraceError ("CL2tpAnswerFileData::HrOpenAndRead", hr);
    return hr;
}

VOID
CL2tpAnswerFileData::SaveToRegistry (
    INetCfg* pnc) const
{
    Assert (pnc);

    HKEY hkey;
    HRESULT hr;

    // Update the L2TP miniport's parameter key.
    //
    hr = HrOpenComponentParamKey (
            pnc,
            GUID_DEVCLASS_NET,
            c_szInfId_MS_L2tpMiniport,
            &hkey);

    if (S_OK == hr)
    {
        (VOID) HrRegSetDword (hkey, L"MaxVcs", m_cMaxVcs);

        if (m_fWriteEndpoints)
        {
            (VOID) HrRegSetDword (hkey, L"WanEndpoints", m_cEndpoints);
        }

        RegCloseKey (hkey);
    }
}


//+---------------------------------------------------------------------------
// CPptpAnswerFileData
//

// Minimum and maximum number of Virtual Private Networks
// allowed by PPTP.
const DWORD c_cPptpVpnsMin = 0;
const DWORD c_cPptpVpnsMax = 1000;

static const DWORD c_cDefPptpVpnsWorkstation = 2;
static const DWORD c_cDefPptpVpnsServer      = 5;


DWORD
CPptpAnswerFileData::GetDefaultNumberOfVpns ()
{
    PRODUCT_FLAVOR pf;
    GetProductFlavor(NULL, &pf);

    DWORD cVpns;

    // On the server product, default to 5 VPNs, otherwise, default to 2 VPNs.
    //
    if (PF_SERVER == pf)
    {
        cVpns = c_cDefPptpVpnsServer;
    }
    else
    {
        cVpns = c_cDefPptpVpnsWorkstation;
    }

    return cVpns;
}

#pragma warning(push)
#pragma warning(disable:4296)
VOID
CPptpAnswerFileData::CheckAndDefault ()
{
    if ((m_cVpns < c_cPptpVpnsMin) || (m_cVpns > c_cPptpVpnsMax))
    {
        m_cVpns = GetDefaultNumberOfVpns ();
    }
}
#pragma warning(pop)

HRESULT
CPptpAnswerFileData::HrOpenAndRead (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    ZeroMemory (this, sizeof(*this));

    // Open the answer file.  It will close itself in it's destructor.
    CSetupInfFile inf;
    UINT unErrorLine;

    HRESULT hr = inf.HrOpen (
                    pszAnswerFile, NULL,
                    INF_STYLE_OLDNT | INF_STYLE_WIN4,
                    &unErrorLine);

    if (SUCCEEDED(hr))
    {
        // Read the number of VPNs.
        //
        hr = inf.HrGetDword (pszAnswerSection,
                             c_szAfPptpEndpoints,
                             &m_cVpns);
        if (FAILED(hr))
        {
            m_cVpns = GetDefaultNumberOfVpns ();
        }

        // Default anything bogus.
        //
        CheckAndDefault ();

        hr = S_OK;
    }
    TraceError ("CPptpAnswerFileData::HrOpenAndRead", hr);
    return hr;
}

VOID
CPptpAnswerFileData::SaveToRegistry (
    INetCfg* pnc) const
{
    Assert (pnc);

    HKEY hkey;
    HRESULT hr;

    // Update the PPTP miniport's parameter key.
    //
    hr = HrOpenComponentParamKey (
            pnc,
            GUID_DEVCLASS_NET,
            c_szInfId_MS_PptpMiniport,
            &hkey);

    if (S_OK == hr)
    {
        (VOID) HrRegSetDword (hkey, L"WanEndpoints", m_cVpns);

        RegCloseKey (hkey);
    }
}


VOID
CPppoeAnswerFileData::CheckAndDefault ()
{
    m_cVpns = 1;
}

HRESULT
CPppoeAnswerFileData::HrOpenAndRead (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    ZeroMemory (this, sizeof(*this));

    // Open the answer file.  It will close itself in it's destructor.
    CSetupInfFile inf;
    UINT unErrorLine;

    HRESULT hr = inf.HrOpen (
                    pszAnswerFile, NULL,
                    INF_STYLE_OLDNT | INF_STYLE_WIN4,
                    &unErrorLine);

    if (SUCCEEDED(hr))
    {
        // Read the number of VPNs.
        //
        hr = inf.HrGetDword (pszAnswerSection,
                             c_szAfL2tpEndpoints,
                             &m_cVpns);
        if (FAILED(hr))
        {
            m_cVpns = 1;
        }

        // Default anything bogus.
        //
        CheckAndDefault ();

        hr = S_OK;
    }
    TraceError ("CPppoeAnswerFileData::HrOpenAndRead", hr);
    return hr;
}

VOID
CPppoeAnswerFileData::SaveToRegistry (
    INetCfg* pnc) const
{
    Assert (pnc);

    HKEY hkey;
    HRESULT hr;

    // Update the PPTP miniport's parameter key.
    //
    hr = HrOpenComponentParamKey (
            pnc,
            GUID_DEVCLASS_NET,
            c_szInfId_MS_PppoeMiniport,
            &hkey);

    if (S_OK == hr)
    {
        (VOID) HrRegSetDword (hkey, L"WanEndpoints", m_cVpns);

        RegCloseKey (hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\rasaf.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S A F . H
//
//  Contents:   RAS Answer File object.
//
//  Notes:
//
//  Author:     shaunco   19 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "rasdata.h"


struct CRasSrvAnswerFileData
{
    HRESULT
    HrOpenAndRead (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection);

    VOID
    SaveToRegistry (
        VOID) const;

    BOOL            m_fRouterTypeSpecified;
    DWORD           m_dwDialInProtocolIds;
    BOOL            m_fSetUsageToDialin;
    DATA_SRV_CFG    m_dataSrvCfg;
    DATA_SRV_IP     m_dataSrvIp;
    DATA_SRV_IPX    m_dataSrvIpx;
    DATA_SRV_NBF    m_dataSrvNbf;
};

struct CL2tpAnswerFileData
{
    VOID
    CheckAndDefault ();

    HRESULT
    HrOpenAndRead (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection);

    VOID
    SaveToRegistry (
        INetCfg* pnc) const;

    DWORD   m_cMaxVcs;
    DWORD   m_cEndpoints;
    BOOL    m_fWriteEndpoints;
};

struct CPptpAnswerFileData
{
    VOID
    CheckAndDefault ();

    DWORD
    GetDefaultNumberOfVpns ();

    HRESULT
    HrOpenAndRead (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection);

    VOID
    SaveToRegistry (
        INetCfg* pnc) const;

    DWORD   m_cVpns;
};

struct CPppoeAnswerFileData
{
    VOID
    CheckAndDefault ();

    HRESULT
    HrOpenAndRead (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection);

    VOID
    SaveToRegistry (
        INetCfg* pnc) const;

    DWORD   m_cVpns;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\ndiswan.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       B I N D A G N T . H
//
//  Contents:   Declaration of NdisWan configuration object.
//
//  Notes:
//
//  Author:     shaunco   28 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "bindobj.h"
#include "resource.h"
#include "rasaf.h"
#include "rasdata.h"
#include "ncutil.h"


class ATL_NO_VTABLE CNdisWan :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CNdisWan, &CLSID_CNdisWan>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal
{
protected:
    // This is our in-memory state.
    BOOL    m_fInstalling;
    BOOL    m_fRemoving;

    // These are handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

public:
    CNdisWan  ();
    ~CNdisWan ();

    BEGIN_COM_MAP(CNdisWan)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNdisWan)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it.

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NDISWAN)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\rascli.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S C L I . C P P
//
//  Contents:   Implementation of RAS Client configuration object.
//
//  Notes:
//
//  Author:     shaunco   21 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncmisc.h"
#include "rasobj.h"

extern const WCHAR c_szInfId_MS_NdisWan[];

CRasCli::CRasCli ()
{
    m_pnc       = NULL;
    m_pnccMe    = NULL;
}

CRasCli::~CRasCli ()
{
    ReleaseObj (m_pnc);
    ReleaseObj (m_pnccMe);
}

//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CRasCli::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    return S_OK;
}

STDMETHODIMP
CRasCli::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CRasCli::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CRasCli::ApplyRegistryChanges ()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CRasCli::ReadAnswerFile (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP
CRasCli::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install(dwSetupFlags);

    // Install NdisWan.
    //
    hr = HrInstallComponentOboComponent (m_pnc, NULL,
            GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NdisWan,
            m_pnccMe,
            NULL);

    TraceHr (ttidError, FAL, hr, FALSE, "CRasCli::Install");
    return hr;
}

STDMETHODIMP
CRasCli::Removing ()
{
    HRESULT hr;

    // Remove NdisWan.
    //
    hr = HrRemoveComponentOboComponent (m_pnc,
            GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NdisWan,
            m_pnccMe);

    TraceHr (ttidError, FAL, hr, FALSE, "CRasCli::Removing");
    return hr;
}

STDMETHODIMP
CRasCli::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\rasdata.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S D A T A . C P P
//
//  Contents:   Implementation of data structure persistence.
//
//  Notes:
//
//  Author:     shaunco   13 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "bindobj.h"
#include "ncreg.h"
#include "ncutil.h"
#include "rasdata.h"
#include "mprapip.h"

static const BOOL c_fDefAllowNetworkAccess  = TRUE;
static const BOOL c_fDefEnableIn            = TRUE;

//------------------------------------------------------------------------
//
// DATA_SRV_CFG
//

static const BOOL     c_fDefMultilink           = TRUE;
static const DWORD    c_fDefAuthLevel           = 2;
static const DWORD    c_fDefDataEnc             = FALSE;
static const DWORD    c_fDefStrongDataEnc       = FALSE;
static const DWORD    c_fDefSecureVPN           = 0;

// server flags copied from routing\ras\inc\rasppp.h
//
#define PPPCFG_NegotiateSPAP            0x00000040
#define PPPCFG_RequireEncryption        0x00000080
#define PPPCFG_NegotiateMSCHAP          0x00000100
#define PPPCFG_NegotiateMultilink       0x00000400
#define PPPCFG_RequireStrongEncryption  0x00001000
#define PPPCFG_NegotiatePAP             0x00010000
#define PPPCFG_NegotiateMD5CHAP         0x00020000
#define PPPCFG_NegotiateStrongMSCHAP    0x00800000
#define PPPCFG_DisableEncryption        0x00080000

VOID DATA_SRV_CFG::SaveToReg () const
{
    HRESULT hr;
    HKEY    hkey;
    DWORD   dwServerFlags = 0;

    // Save off the router type
    //
    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\RemoteAccess\\Parameters",
            KEY_ALL_ACCESS,
            &hkey);
    if (SUCCEEDED(hr))
    {
        (VOID) HrRegSetDword (hkey, L"RouterType", dwRouterType);

        hr = HrRegQueryDword (hkey, L"ServerFlags", &dwServerFlags);
        if (SUCCEEDED(hr))
        {
            if (fMultilink)
            {
                dwServerFlags |= PPPCFG_NegotiateMultilink;
            }
            else
            {
                dwServerFlags &= ~PPPCFG_NegotiateMultilink;
            }

            dwServerFlags &= ~PPPCFG_RequireEncryption;
            dwServerFlags &= ~PPPCFG_RequireStrongEncryption;
            if (fDataEnc)
            {
                dwServerFlags |= PPPCFG_RequireEncryption;
            }
            if (fStrongDataEnc)
            {
                dwServerFlags |= PPPCFG_RequireStrongEncryption;
            }

            if (dwSecureVPN)
            {
                dwServerFlags |= PPPCFG_NegotiateStrongMSCHAP;
                dwServerFlags &= ~PPPCFG_NegotiateSPAP;
                dwServerFlags &= ~PPPCFG_NegotiateMSCHAP;
                dwServerFlags &= ~PPPCFG_NegotiatePAP;
                dwServerFlags &= ~PPPCFG_NegotiateMD5CHAP;
            }
            else
            {
                dwServerFlags |= PPPCFG_NegotiateMSCHAP;
                dwServerFlags |= PPPCFG_NegotiateStrongMSCHAP;
                dwServerFlags &= ~PPPCFG_NegotiateSPAP;
                dwServerFlags &= ~PPPCFG_NegotiatePAP;
                dwServerFlags &= ~PPPCFG_NegotiateMD5CHAP;

                if (dwAuthLevel < 2)
                {
                    dwServerFlags |= PPPCFG_NegotiateSPAP;
                    dwServerFlags |= PPPCFG_NegotiateMD5CHAP;
                }
                if (dwAuthLevel < 1)
                {
                    dwServerFlags |= PPPCFG_NegotiatePAP;
                }
            }

            // pmay: 382389
            //
            // Part of the fix to this should be to clear the disable encryption
            // flag
            //
            dwServerFlags &= ~PPPCFG_DisableEncryption;
       
            (VOID) HrRegSetDword (hkey, L"ServerFlags", dwServerFlags);
        }

        RegCloseKey (hkey);
    }

    // Read in the
}

VOID DATA_SRV_CFG::CheckAndDefault ()
{
    DATA_SRV_CFG def;
    def.GetDefault();

    if (dwRouterType >= RT_INVALID)
    {
        dwRouterType = def.dwRouterType;
    }
}

VOID DATA_SRV_CFG::GetDefault ()
{
    dwRouterType = RT_RAS;
    fMultilink   = c_fDefMultilink;
    dwAuthLevel  = c_fDefAuthLevel;
    fDataEnc     = c_fDefDataEnc;
    fStrongDataEnc = c_fDefStrongDataEnc;
    dwSecureVPN  = c_fDefSecureVPN;
}


//------------------------------------------------------------------------
//
// DATA_SRV_IP
//

static const WCHAR    c_szSubkeySrvIp []        = L"RemoteAccess\\Parameters\\Ip";
static const WCHAR    c_szSubkeySrvIpPool []    = L"RemoteAccess\\Parameters\\Ip\\StaticAddressPool\\0";
static const BOOL     c_fDefUseDhcp             = TRUE;
static const BOOL     c_fDefAllowClientAddr     = FALSE;
static const DWORD    c_dwDefIpAddr             = 0;
static const REGBATCH c_rbDataSrvIp []          =
{
    { HKLM_SVCS, c_szSubkeySrvIp, L"EnableIn",               REG_BOOL, offsetof(DATA_SRV_IP, fEnableIn),           (BYTE*)&c_fDefEnableIn },
    { HKLM_SVCS, c_szSubkeySrvIp, L"AllowNetworkAccess",     REG_BOOL, offsetof(DATA_SRV_IP, fAllowNetworkAccess), (BYTE*)&c_fDefAllowNetworkAccess },
    { HKLM_SVCS, c_szSubkeySrvIp, L"UseDhcpAddressing",      REG_BOOL, offsetof(DATA_SRV_IP, fUseDhcp),            (BYTE*)&c_fDefUseDhcp },
    { HKLM_SVCS, c_szSubkeySrvIp, L"AllowClientIpAddresses", REG_BOOL, offsetof(DATA_SRV_IP, fAllowClientAddr),    (BYTE*)&c_fDefAllowClientAddr },
    { HKLM_SVCS, c_szSubkeySrvIpPool, L"From",               REG_DWORD,offsetof(DATA_SRV_IP, dwIpStart),           (BYTE*)&c_dwDefIpAddr },
    { HKLM_SVCS, c_szSubkeySrvIpPool, L"To",                 REG_DWORD,offsetof(DATA_SRV_IP, dwIpEnd),             (BYTE*)&c_dwDefIpAddr },
};

VOID DATA_SRV_IP::SaveToReg () const
{
    (VOID) HrRegWriteValues (celems(c_rbDataSrvIp), c_rbDataSrvIp,
                             (const BYTE*)this,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
}

VOID DATA_SRV_IP::CheckAndDefault ()
{
}

VOID DATA_SRV_IP::GetDefault ()
{
    fEnableIn           = c_fDefEnableIn;
    fAllowNetworkAccess = c_fDefAllowNetworkAccess;
    fUseDhcp            = c_fDefUseDhcp;
    fAllowClientAddr    = c_fDefAllowClientAddr;
    dwIpStart           = 0;
    dwIpEnd             = 0;
};


//------------------------------------------------------------------------
//
// DATA_SRV_IPX
//

static const WCHAR    c_szSubkeySrvIpx []       = L"RemoteAccess\\Parameters\\Ipx";
static const BOOL     c_fDefUseAutoAddr         = TRUE;
static const BOOL     c_fDefUseSameNetNum       = TRUE;
static const BOOL     c_fDefAllowClientNetNum   = TRUE;
static const DWORD    c_dwDefIpxNetFirst        = 0;
static const DWORD    c_dwDefIpxWanPoolSize     = 1000;
static const REGBATCH c_rbDataSrvIpx   []       =
{
    { HKLM_SVCS, c_szSubkeySrvIpx, L"EnableIn",               REG_BOOL,  offsetof(DATA_SRV_IPX, fEnableIn),           (BYTE*)&c_fDefEnableIn },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"AllowNetworkAccess",     REG_BOOL,  offsetof(DATA_SRV_IPX, fAllowNetworkAccess), (BYTE*)&c_fDefAllowNetworkAccess },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"AutoWanNetAllocation",   REG_BOOL,  offsetof(DATA_SRV_IPX, fUseAutoAddr),        (BYTE*)&c_fDefUseAutoAddr },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"GlobalWanNet",           REG_BOOL,  offsetof(DATA_SRV_IPX, fUseSameNetNum),      (BYTE*)&c_fDefUseSameNetNum },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"AcceptRemoteNodeNumber", REG_BOOL,  offsetof(DATA_SRV_IPX, fAllowClientNetNum),  (BYTE*)&c_fDefAllowClientNetNum },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"FirstWanNet",            REG_DWORD, offsetof(DATA_SRV_IPX, dwIpxNetFirst),       (BYTE*)&c_dwDefIpxNetFirst },
    { HKLM_SVCS, c_szSubkeySrvIpx, L"WanNetPoolSize",         REG_DWORD, offsetof(DATA_SRV_IPX, dwIpxWanPoolSize),        (BYTE*)&c_dwDefIpxWanPoolSize },
};

VOID DATA_SRV_IPX::SaveToReg () const
{
    (VOID) HrRegWriteValues (celems(c_rbDataSrvIpx), c_rbDataSrvIpx,
                             (const BYTE*)this,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
}

VOID DATA_SRV_IPX::CheckAndDefault ()
{
}

VOID DATA_SRV_IPX::GetDefault ()
{
    fEnableIn           = c_fDefEnableIn;
    fAllowNetworkAccess = c_fDefAllowNetworkAccess;
    fUseAutoAddr        = c_fDefUseAutoAddr;
    fUseSameNetNum      = c_fDefUseSameNetNum;
    fAllowClientNetNum  = c_fDefAllowClientNetNum;
    dwIpxNetFirst       = c_dwDefIpxNetFirst;
    dwIpxWanPoolSize    = c_dwDefIpxWanPoolSize;
};

//------------------------------------------------------------------------
//
// DATA_SRV_NBF
//

static const WCHAR    c_szSubkeySrvNbf [] = L"RemoteAccess\\Parameters\\Nbf";
static const REGBATCH c_rbDataSrvNbf   [] =
{
    { HKLM_SVCS, c_szSubkeySrvNbf, L"EnableIn",           REG_BOOL, offsetof(DATA_SRV_NBF, fEnableIn),           (BYTE*)&c_fDefEnableIn },
    { HKLM_SVCS, c_szSubkeySrvNbf, L"AllowNetworkAccess", REG_BOOL, offsetof(DATA_SRV_NBF, fAllowNetworkAccess), (BYTE*)&c_fDefAllowNetworkAccess },
};

VOID DATA_SRV_NBF::SaveToReg () const
{
    (VOID) HrRegWriteValues (celems(c_rbDataSrvNbf), c_rbDataSrvNbf,
                             (const BYTE*)this,
                             REG_OPTION_NON_VOLATILE, KEY_WRITE);
}

VOID DATA_SRV_NBF::CheckAndDefault ()
{
}

VOID DATA_SRV_NBF::GetDefault ()
{
    fEnableIn           = c_fDefEnableIn;
    fAllowNetworkAccess = c_fDefAllowNetworkAccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\sapcfg\resource.h ===
#include <ncres.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\resource.h ===
#include <ncres.h>

#define IDS_RAS_INTERNAL_ADAPTER    (IDS_NC_RASCFG + 0)
#define IDS_RAS_LOOPBACK_ADAPTER    (IDS_NC_RASCFG + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\rasdata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S D A T A . H
//
//  Contents:   Declaration of data structures used by RAS configuration.
//
//  Notes:
//
//  Author:     shaunco   13 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgx.h"

//+---------------------------------------------------------------------------
// DATA_SRV_CFG
//

enum SRV_ROUTER_TYPE
{
    RT_RAS      = 0x01,
    RT_LAN      = 0x02,
    RT_WAN      = 0x04,
    RT_INVALID  = 0x08
};

struct DATA_SRV_CFG
{
    DWORD   dwRouterType;
    BOOL    fMultilink;
    DWORD   dwAuthLevel;
    BOOL    fDataEnc;
    BOOL    fStrongDataEnc;
    DWORD   dwSecureVPN;

    VOID    SaveToReg       () const;
    VOID    CheckAndDefault ();
    VOID    GetDefault      ();
};


//+---------------------------------------------------------------------------
// DATA_SRV_IP
//

struct DATA_SRV_IP
{
    BOOL    fEnableIn;
    BOOL    fAllowNetworkAccess;
    BOOL    fUseDhcp;
    BOOL    fAllowClientAddr;
    DWORD   dwIpStart;
    DWORD   dwIpEnd;

    VOID    SaveToReg       () const;
    VOID    CheckAndDefault ();
    VOID    GetDefault      ();
};


//+---------------------------------------------------------------------------
// DATA_SRV_IPX
//

struct DATA_SRV_IPX
{
    BOOL    fEnableIn;
    BOOL    fAllowNetworkAccess;
    BOOL    fUseAutoAddr;
    BOOL    fUseSameNetNum;
    BOOL    fAllowClientNetNum;
    DWORD   dwIpxNetFirst;
    DWORD   dwIpxWanPoolSize;

    VOID    SaveToReg       () const;
    VOID    CheckAndDefault ();
    VOID    GetDefault      ();
};


//+---------------------------------------------------------------------------
// DATA_SRV_NBF
//

struct DATA_SRV_NBF
{
    BOOL    fEnableIn;
    BOOL    fAllowNetworkAccess;

    VOID    SaveToReg       () const;
    VOID    CheckAndDefault ();
    VOID    GetDefault      ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\rasobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S O B J . H
//
//  Contents:   Declaration of RAS configuration objects.
//
//  Notes:
//
//  Author:     shaunco   21 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include <mprapi.h>
#include "ndiswan.h"
#include "resource.h"
#include "rasaf.h"
#include "rasdata.h"
#include "ncutil.h"


HRESULT
HrModemClassCoInstaller (
    DI_FUNCTION                 dif,
    HDEVINFO                    hdi,
    PSP_DEVINFO_DATA            pdeid,
    PCOINSTALLER_CONTEXT_DATA   pContext);


//+---------------------------------------------------------------------------
// L2TP
//
class ATL_NO_VTABLE CL2tp :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CL2tp, &CLSID_CL2tp>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    CL2tpAnswerFileData m_AfData;
    BOOL                m_fSaveAfData;

public:
    CL2tp  ();
    ~CL2tp ();

    BEGIN_COM_MAP(CL2tp)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_L2TP)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};



//+---------------------------------------------------------------------------
// PPTP
//
class ATL_NO_VTABLE CPptp :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CPptp, &CLSID_CPptp>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    CPptpAnswerFileData m_AfData;
    BOOL                m_fSaveAfData;

public:
    CPptp  ();
    ~CPptp ();

    BEGIN_COM_MAP(CPptp)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_PPTP)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};

//+---------------------------------------------------------------------------
// PPPOE
//
class ATL_NO_VTABLE CPppoe :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CPppoe, &CLSID_CPppoe>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    CPppoeAnswerFileData m_AfData;
    BOOL                m_fSaveAfData;

public:
    CPppoe  ();
    ~CPppoe ();

    BEGIN_COM_MAP(CPppoe)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_PPPOE)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};



//+---------------------------------------------------------------------------
// RAS Client
//
class ATL_NO_VTABLE CRasCli :
    public CComObjectRoot,
    public CComCoClass<CRasCli, &CLSID_CRasCli>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // These are handed to us during INetCfgComponentControl::Initialize.
    INetCfg*            m_pnc;
    INetCfgComponent*   m_pnccMe;

public:
    CRasCli ();
    ~CRasCli ();

    BEGIN_COM_MAP(CRasCli)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_RASCLI)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup

    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};



//+---------------------------------------------------------------------------
// RAS Server
//
class ATL_NO_VTABLE CRasSrv :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CRasSrv, &CLSID_CRasSrv>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    // This is our in-memory state.
    BOOL                    m_fInstalling;
    BOOL                    m_fRemoving;
    BOOL                    m_fNt4ServerUpgrade;
    CRasSrvAnswerFileData   m_AfData;
    BOOL                    m_fSaveAfData;

public:
    CRasSrv  ();
    ~CRasSrv ();

    BEGIN_COM_MAP(CRasSrv)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_RASSRV)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();
};


//+---------------------------------------------------------------------------
// Steelhead
//
typedef void (WINAPI* PFN_MAKE_INTERFACE_INFO)(PCWSTR pszwAdapterName,
                                               DWORD   dwPacketType,
                                               LPBYTE* ppb);
typedef void (WINAPI* PFN_MAKE_TRANSPORT_INFO)(LPBYTE* ppbGlobal,
                                               LPBYTE* ppbClient);

struct ROUTER_MANAGER_INFO
{
    DWORD                   dwTransportId;
    DWORD                   dwPacketType;
    PCWSTR                 pszwTransportName;
    PCWSTR                 pszwDllPath;
    PFN_MAKE_INTERFACE_INFO pfnMakeInterfaceInfo;
    PFN_MAKE_TRANSPORT_INFO pfnMakeTransportInfo;
};

class ATL_NO_VTABLE CSteelhead :
    public CRasBindObject,
    public CComObjectRoot,
    public CComCoClass<CSteelhead, &CLSID_CSteelhead>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal
{
protected:
    // This is handed to us during INetCfgComponentControl::Initialize.
    INetCfgComponent*   m_pnccMe;

    HANDLE              m_hMprConfig;
    HANDLE              m_hMprAdmin;
    BOOL                m_fRemoving;
    BOOL                m_fUpdateRouterConfiguration;

    BOOL    FAdapterExistsWithMatchingBindName  (PCWSTR pszwAdapterName,
                                                 INetCfgComponent** ppnccAdapter);
    BOOL    FIpxFrameTypeInUseOnAdapter         (DWORD dwwFrameType,
                                                 PCWSTR pszwAdapterName);
    BOOL    FIpxFrameTypeInUseOnAdapter         (PCWSTR pszwFrameType,
                                                 PCWSTR pszwAdapterName);

    HRESULT HrEnsureRouterInterfaceForAdapter   (ROUTER_INTERFACE_TYPE dwIfType,
                                                 DWORD dwPacketType,
                                                 PCWSTR pszwAdapterName,
                                                 PCWSTR pszwInterfaceName,
                                                 const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureIpxRouterInterfacesForAdapter   (PCWSTR pszwAdapterName);
    HRESULT HrEnsureRouterInterface             (ROUTER_INTERFACE_TYPE dwIfType,
                                                 PCWSTR pszwInterfaceName,
                                                 HANDLE* phConfigInterface,
                                                 HANDLE* phAdminInterface);
    HRESULT HrEnsureRouterInterfaceTransport    (PCWSTR pszwAdapterName,
                                                 DWORD dwPacketType,
                                                 HANDLE hConfigInterface,
                                                 HANDLE hAdminInterface,
                                                 const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureRouterManager               (const ROUTER_MANAGER_INFO& rmi);
    HRESULT HrEnsureRouterManagerDeleted        (const ROUTER_MANAGER_INFO& rmi);

    HRESULT HrPassToAddInterfaces               ();
    HRESULT HrPassToRemoveInterfaces            (BOOL fFromRunningRouter);
    HRESULT HrPassToRemoveInterfaceTransports   (MPR_INTERFACE_0* pri0,
                                                 PCWSTR pszwAdapterName,
                                                 INetCfgComponent* pnccAdapter);

    HRESULT HrUpdateRouterConfiguration         ();

#if (WINVER >= 0x0501)
    HRESULT HrRemoveIPXRouterConfiguration      (BOOL fRouter);
#endif

public:
    CSteelhead  ();
    ~CSteelhead ();

    BEGIN_COM_MAP(CSteelhead)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_STEELHEAD)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo);
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Removing)            ();

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\router.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R O U T E R . H
//
//  Contents:   Declaration of functions used to setup the router.
//
//  Notes:
//
//  Author:     shaunco   12 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once

void WINAPI MakeIpInterfaceInfo     (PCWSTR pszwAdapterName,
                                     DWORD   dwPacketType,
                                     LPBYTE* ppBuff);
void WINAPI MakeIpTransportInfo     (LPBYTE* ppBuffGlobal,
                                     LPBYTE* ppBuffClient);
void WINAPI MakeIpxInterfaceInfo    (PCWSTR pszwAdapterName,
                                     DWORD   dwPacketType,
                                     LPBYTE* ppBuff);
void WINAPI MakeIpxTransportInfo    (LPBYTE* ppBuffGlobal,
                                     LPBYTE* ppBuffClient);

HRESULT
HrMprAdminServerConnect(
    IN      PWSTR                  lpwsServerName      OPTIONAL,
    OUT     MPR_SERVER_HANDLE *     phMprServer
);

HRESULT
HrMprAdminInterfaceGetHandle(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      PWSTR                  lpwsInterfaceName,
    OUT     HANDLE *                phInterface,
    IN      BOOL                    fIncludeClientInterfaces
);

HRESULT
HrMprAdminInterfaceCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE *                phInterface
);

HRESULT
HrMprAdminInterfaceEnum(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle        OPTIONAL
);

HRESULT
HrMprAdminInterfaceTransportAdd(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize
);

HRESULT
HrMprAdminInterfaceTransportRemove(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId
);

HRESULT
HrMprAdminTransportCreate(
    IN      HANDLE                  hMprAdmin,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      PWSTR                  lpwsDLLPath
);

HRESULT
HrMprConfigServerConnect(
    IN      PWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
);

HRESULT
HrMprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
);

HRESULT
HrMprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      PWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
);

HRESULT
HrMprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
);

HRESULT
HrMprConfigInterfaceTransportRemove(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport
);

HRESULT
HrMprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
);

HRESULT
HrMprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
);

HRESULT
HrMprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
);

HRESULT
HrMprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      PWSTR                  lpwsDLLPath,
    OUT     HANDLE*                 phRouterTransport
);

HRESULT
HrMprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport
);

HRESULT
HrMprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
);

HRESULT
HrMprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT PWSTR*                 lplpwsDLLPath               OPTIONAL
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\router.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R O U T E R . C P P
//
//  Contents:   Implementation of functions used to setup the router.
//
//  Notes:
//
//  Author:     shaunco   13 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <fltdefs.h>    // must include for iprtinfo.h
#include <ipinfoid.h>
#include <iprtinfo.h>
#include <iprtrmib.h>
#include <ipxrtdef.h>
#include <mprerror.h>
#include <tdi.h>        // must include for isnkrnl.h
#include <isnkrnl.h>
#include <rtinfo.h>
#include <routprot.h>
#include "router.h"


#define PAD8(_p)    (((ULONG_PTR)(_p) + ALIGN_SHIFT) & ALIGN_MASK)


//+---------------------------------------------------------------------------
//
//  Function:   MakeIpInterfaceInfo
//
//  Purpose:    Create the router interface block for IP.
//
//  Arguments:
//      pszwAdapterName [in]    The adapter name
//      dwPacketType    [in]    The packet type
//      ppBuff          [out]   Pointer to the returned info.
//                              Free with delete.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpInterfaceInfo (
        PCWSTR pszwAdapterName,
        DWORD   dwPacketType,
        LPBYTE* ppBuff)
{
    UNREFERENCED_PARAMETER (pszwAdapterName);
    UNREFERENCED_PARAMETER (dwPacketType);
    Assert (ppBuff);

    const int c_cTocEntries = 3;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof( INTERFACE_STATUS_INFO )
                    + sizeof( RTR_DISC_INFO )
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) MemAlloc(dwSize);
    if (!pIBH)
    {
        *ppBuff = NULL;
        return;
    }

    ZeroMemory (pIBH, dwSize);
    *ppBuff                     = (LPBYTE) pIBH;

    // Initialize infobase fields.
    //
    pIBH->Version               = RTR_INFO_BLOCK_VERSION;
    pIBH->Size                  = dwSize;
    pIBH->TocEntriesCount       = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH-> TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Create empty route info block
    //
    pTocEntry->InfoType         = IP_ROUTE_INFO;
    pTocEntry->InfoSize         = sizeof( MIB_IPFORWARDROW );
    pTocEntry->Count            = 0;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (LPBYTE)pIBH);

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Create interface status block.
    //
    pTocEntry->InfoType         = IP_INTERFACE_STATUS_INFO;
    pTocEntry->InfoSize         = sizeof( INTERFACE_STATUS_INFO );
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (LPBYTE)pIBH);

    PINTERFACE_STATUS_INFO pifStat = (PINTERFACE_STATUS_INFO)pbDataPtr;
    pifStat->dwAdminStatus      = MIB_IF_ADMIN_STATUS_UP;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Create Router Disc. Info.
    //
    pTocEntry->InfoType         = IP_ROUTER_DISC_INFO;
    pTocEntry->InfoSize         = sizeof( RTR_DISC_INFO );
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (LPBYTE)pIBH);

    PRTR_DISC_INFO pRtrDisc     = (PRTR_DISC_INFO)pbDataPtr;
    pRtrDisc->bAdvertise        = FALSE;
    pRtrDisc->wMaxAdvtInterval  = DEFAULT_MAX_ADVT_INTERVAL;
    pRtrDisc->wMinAdvtInterval  = (WORD)(DEFAULT_MIN_ADVT_INTERVAL_RATIO * DEFAULT_MAX_ADVT_INTERVAL);
    pRtrDisc->wAdvtLifetime     = DEFAULT_ADVT_LIFETIME_RATIO * DEFAULT_MAX_ADVT_INTERVAL;
    pRtrDisc->lPrefLevel        = DEFAULT_PREF_LEVEL;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpTransportInfo
//
//  Purpose:    Create the router transport blocks for IP.  Free with delete.
//
//  Arguments:
//      ppBuffGlobal [out]  Pointer to the returned global block.
//      ppBuffClient [out]  Pointer to the returned client block.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpTransportInfo (LPBYTE* ppBuffGlobal, LPBYTE* ppBuffClient)
{
    Assert (ppBuffGlobal);
    Assert (ppBuffClient);

    *ppBuffClient = NULL;

    const int c_cTocEntries = 2;
    const int c_cProtocols  = 7;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(GLOBAL_INFO)
                    + SIZEOF_PRIORITY_INFO(c_cProtocols)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) MemAlloc(dwSize);
    if (!pIBH)
    {
        *ppBuffGlobal = NULL;
        return;
    }

    ZeroMemory (pIBH, dwSize);
    *ppBuffGlobal = (LPBYTE) pIBH;

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IP router manager global info.
    //
    pTocEntry->InfoType         = IP_GLOBAL_INFO;
    pTocEntry->InfoSize         = sizeof(GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PGLOBAL_INFO pGlbInfo       = (PGLOBAL_INFO) pbDataPtr;
    pGlbInfo->bFilteringOn      = FALSE;
    pGlbInfo->dwLoggingLevel    = IPRTR_LOGGING_ERROR;

    pbDataPtr += pTocEntry->Count * pTocEntry-> InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make IP router manager priority info.
    //
    pTocEntry->InfoType         = IP_PROT_PRIORITY_INFO;
    pTocEntry->InfoSize         = SIZEOF_PRIORITY_INFO(c_cProtocols);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PPRIORITY_INFO pPriorInfo   = (PPRIORITY_INFO) pbDataPtr;
    pPriorInfo->dwNumProtocols  = c_cProtocols;

    pPriorInfo->ppmProtocolMetric[ 0 ].dwProtocolId   = PROTO_IP_LOCAL;
    pPriorInfo->ppmProtocolMetric[ 0 ].dwMetric       = 1;

    pPriorInfo->ppmProtocolMetric[ 1 ].dwProtocolId   = PROTO_IP_NETMGMT;
    pPriorInfo->ppmProtocolMetric[ 1 ].dwMetric       = 10;

    pPriorInfo->ppmProtocolMetric[ 2 ].dwProtocolId   = PROTO_IP_NT_STATIC;
    pPriorInfo->ppmProtocolMetric[ 2 ].dwMetric       = 3;

    pPriorInfo->ppmProtocolMetric[ 3 ].dwProtocolId   = PROTO_IP_NT_STATIC_NON_DOD;
    pPriorInfo->ppmProtocolMetric[ 3 ].dwMetric       = 5;

    pPriorInfo->ppmProtocolMetric[ 4 ].dwProtocolId   = PROTO_IP_NT_AUTOSTATIC;
    pPriorInfo->ppmProtocolMetric[ 4 ].dwMetric       = 7;

    pPriorInfo->ppmProtocolMetric[ 5 ].dwProtocolId   = PROTO_IP_OSPF;
    pPriorInfo->ppmProtocolMetric[ 5 ].dwMetric       = 110;

    pPriorInfo->ppmProtocolMetric[ 6 ].dwProtocolId   = PROTO_IP_RIP;
    pPriorInfo->ppmProtocolMetric[ 6 ].dwMetric       = 120;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpxInterfaceInfo
//
//  Purpose:    Create the router interface block for IPX.
//
//  Arguments:
//      pszwAdapterName [in]    The adapter name
//      dwPacketType    [in]    The packet type
//      ppBuff          [out]   Pointer to the returned info.
//                              Free with delete.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpxInterfaceInfo (
        PCWSTR pszwAdapterName,
        DWORD   dwPacketType,
        LPBYTE* ppBuff)
{
    Assert (ppBuff);

    const BOOL fDialInInterface = (NULL == pszwAdapterName);

    const int c_cTocEntries = 5;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(IPX_IF_INFO)
                    + sizeof(IPX_ADAPTER_INFO)
                    + sizeof(IPXWAN_IF_INFO)
                    + sizeof(RIP_IF_CONFIG)
                    + sizeof(SAP_IF_CONFIG)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) MemAlloc(dwSize);
    if (!pIBH)
    {
        *ppBuff = NULL;
        return;
    }

    ZeroMemory (pIBH, dwSize);
    *ppBuff = (LPBYTE) pIBH;

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IPX router manager interface info.
    //
    pTocEntry->InfoType         = IPX_INTERFACE_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_IF_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PIPX_IF_INFO pIfInfo        = (PIPX_IF_INFO) pbDataPtr;
    pIfInfo->AdminState         = ADMIN_STATE_ENABLED;
    pIfInfo->NetbiosAccept      = ADMIN_STATE_ENABLED;
    pIfInfo->NetbiosDeliver     = (fDialInInterface) ? ADMIN_STATE_DISABLED
                                                     : ADMIN_STATE_ENABLED;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make adapter info.
    //
    pTocEntry->InfoType         = IPX_ADAPTER_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_ADAPTER_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PIPX_ADAPTER_INFO pAdInfo   = (PIPX_ADAPTER_INFO) pbDataPtr;
    if (ISN_FRAME_TYPE_AUTO == dwPacketType)
    {
        dwPacketType = AUTO_DETECT_PACKET_TYPE;
    }
    pAdInfo->PacketType         = dwPacketType;
    if (pszwAdapterName)
    {
        AssertSz (lstrlen (pszwAdapterName) < celems (pAdInfo->AdapterName),
                  "Bindname too big for pAdInfo->AdapterName buffer.");
        lstrcpyW (pAdInfo->AdapterName, pszwAdapterName);
    }
    else
    {
        AssertSz (0 == pAdInfo->AdapterName[0],
                    "Who removed the ZeroMemory call above?");
    }

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make wan info.
    //
    pTocEntry->InfoType         = IPXWAN_INTERFACE_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPXWAN_IF_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PIPXWAN_IF_INFO pWanInfo    = (PIPXWAN_IF_INFO) pbDataPtr;
    pWanInfo->AdminState        = ADMIN_STATE_DISABLED;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make RIP interface info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_RIP;
    pTocEntry->InfoSize         = sizeof(RIP_IF_CONFIG);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PRIP_IF_CONFIG pRipInfo     = (PRIP_IF_CONFIG) pbDataPtr;
    pRipInfo->RipIfInfo.AdminState              = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.UpdateMode              = (fDialInInterface)
                                                    ? IPX_NO_UPDATE
                                                    : IPX_STANDARD_UPDATE;
    pRipInfo->RipIfInfo.PacketType              = IPX_STANDARD_PACKET_TYPE;
    pRipInfo->RipIfInfo.Supply                  = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.Listen                  = ADMIN_STATE_ENABLED;
    pRipInfo->RipIfInfo.PeriodicUpdateInterval  = 60;
    pRipInfo->RipIfInfo.AgeIntervalMultiplier   = 3;
    pRipInfo->RipIfFilters.SupplyFilterAction   = IPX_ROUTE_FILTER_DENY;
    pRipInfo->RipIfFilters.SupplyFilterCount    = 0;
    pRipInfo->RipIfFilters.ListenFilterAction   = IPX_ROUTE_FILTER_DENY;
    pRipInfo->RipIfFilters.ListenFilterCount    = 0;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make SAP interface info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_SAP;
    pTocEntry->InfoSize         = sizeof(SAP_IF_CONFIG);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PSAP_IF_CONFIG pSapInfo     = (PSAP_IF_CONFIG) pbDataPtr;
    pSapInfo->SapIfInfo.AdminState              = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.UpdateMode              = (fDialInInterface)
                                                    ? IPX_NO_UPDATE
                                                    : IPX_STANDARD_UPDATE;
    pSapInfo->SapIfInfo.PacketType              = IPX_STANDARD_PACKET_TYPE;
    pSapInfo->SapIfInfo.Supply                  = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.Listen                  = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.GetNearestServerReply   = ADMIN_STATE_ENABLED;
    pSapInfo->SapIfInfo.PeriodicUpdateInterval  = 60;
    pSapInfo->SapIfInfo.AgeIntervalMultiplier   = 3;
    pSapInfo->SapIfFilters.SupplyFilterAction   = IPX_SERVICE_FILTER_DENY;
    pSapInfo->SapIfFilters.SupplyFilterCount    = 0;
    pSapInfo->SapIfFilters.ListenFilterAction   = IPX_SERVICE_FILTER_DENY;
    pSapInfo->SapIfFilters.ListenFilterCount    = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeIpxTransportInfo
//
//  Purpose:    Create the router transport blocks for IPX.  Free with delete.
//
//  Arguments:
//      ppBuffGlobal [out]  Pointer to the returned global block.
//      ppBuffClient [out]  Pointer to the returned client block.
//
//  Returns:    nothing
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
void MakeIpxTransportInfo (LPBYTE* ppBuffGlobal, LPBYTE* ppBuffClient)
{
    Assert (ppBuffGlobal);
    Assert (ppBuffClient);

    MakeIpxInterfaceInfo (NULL, ISN_FRAME_TYPE_AUTO, ppBuffClient);

    const int c_cTocEntries = 3;

    // Alocate for minimal global Information.
    //
    DWORD dwSize =  sizeof( RTR_INFO_BLOCK_HEADER )
                // header contains one TOC_ENTRY already
                    + ((c_cTocEntries - 1) * sizeof( RTR_TOC_ENTRY ))
                    + sizeof(IPX_GLOBAL_INFO)
                    + sizeof(RIP_GLOBAL_INFO)
                    + sizeof(SAP_GLOBAL_INFO)
                    + (c_cTocEntries * ALIGN_SIZE);

    PRTR_INFO_BLOCK_HEADER pIBH = (PRTR_INFO_BLOCK_HEADER) MemAlloc(dwSize);
    if (!pIBH)
    {
        *ppBuffGlobal = NULL;
        return;
    }

    ZeroMemory (pIBH, dwSize);
    *ppBuffGlobal = (LPBYTE) pIBH;

    // Initialize infobase fields.
    //
    pIBH->Version           = RTR_INFO_BLOCK_VERSION;
    pIBH->Size              = dwSize;
    pIBH->TocEntriesCount   = c_cTocEntries;

    LPBYTE pbDataPtr = (LPBYTE) &( pIBH->TocEntry[ pIBH->TocEntriesCount ] );
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    PRTR_TOC_ENTRY pTocEntry    = pIBH->TocEntry;

    // Make IPX router manager global info.
    //
    pTocEntry->InfoType         = IPX_GLOBAL_INFO_TYPE;
    pTocEntry->InfoSize         = sizeof(IPX_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PIPX_GLOBAL_INFO pGlbInfo       = (PIPX_GLOBAL_INFO) pbDataPtr;
    pGlbInfo->RoutingTableHashSize  = IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE;
    pGlbInfo->EventLogMask          = EVENTLOG_ERROR_TYPE;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make RIP global info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_RIP;
    pTocEntry->InfoSize         = sizeof(RIP_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PRIP_GLOBAL_INFO pRipInfo   = (PRIP_GLOBAL_INFO) pbDataPtr;
    pRipInfo->EventLogMask      = EVENTLOG_ERROR_TYPE;

    pbDataPtr += pTocEntry->Count * pTocEntry->InfoSize;
    pbDataPtr = (LPBYTE)PAD8(pbDataPtr);
    pTocEntry++;

    // Make SAP global info.
    //
    pTocEntry->InfoType         = IPX_PROTOCOL_SAP;
    pTocEntry->InfoSize         = sizeof(SAP_GLOBAL_INFO);
    pTocEntry->Count            = 1;
    pTocEntry->Offset           = (ULONG)(pbDataPtr - (PBYTE)pIBH);

    PSAP_GLOBAL_INFO pSapInfo   = (PSAP_GLOBAL_INFO) pbDataPtr;
    pSapInfo->EventLogMask      = EVENTLOG_ERROR_TYPE;
}



//+---------------------------------------------------------------------------
//
// mprapi.h wrappers to return HRESULTs and obey rules of COM in regard
// to output parameters.
//
HRESULT
HrMprAdminServerConnect(
    IN      PWSTR                  lpwsServerName      OPTIONAL,
    OUT     MPR_SERVER_HANDLE *     phMprServer
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminServerConnect (lpwsServerName, phMprServer);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phMprServer = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) == hr),
        "HrMprAdminServerConnect");
    return hr;
}

HRESULT
HrMprAdminInterfaceCreate(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE *                phInterface
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceCreate (hMprServer,
                    dwLevel, lpbBuffer, phInterface);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phInterface = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprAdminInterfaceCreate");
    return hr;
}

HRESULT
HrMprAdminInterfaceEnum(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      DWORD                   dwLevel,
    OUT     LPBYTE *                lplpbBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN      LPDWORD                 lpdwResumeHandle        OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceEnum (hMprServer, dwLevel, lplpbBuffer,
                    dwPrefMaxLen, lpdwEntriesRead,
                    lpdwTotalEntries, lpdwResumeHandle);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *lpdwEntriesRead = 0;
        *lpdwTotalEntries = 0;
    }
    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_INVALID_BINDING) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) == hr),
        "HrMprAdminInterfaceEnum");
    return hr;
}

HRESULT
HrMprAdminInterfaceGetHandle(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      PWSTR                  lpwsInterfaceName,
    OUT     HANDLE *                phInterface,
    IN      BOOL                    fIncludeClientInterfaces
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceGetHandle (hMprServer, lpwsInterfaceName,
                    phInterface, fIncludeClientInterfaces);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phInterface = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_INVALID_BINDING) == hr) ||
        (HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) == hr),
        "HrMprAdminInterfaceGetHandle");
    return hr;
}

HRESULT
HrMprAdminInterfaceTransportAdd(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceTransportAdd (hMprServer, hInterface,
                    dwTransportId, pInterfaceInfo, dwInterfaceInfoSize);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_INTERFACE_ALREADY_EXISTS) == hr,
        "HrMprAdminInterfaceTransportAdd");
    return hr;
}

HRESULT
HrMprAdminInterfaceTransportRemove(
    IN      MPR_SERVER_HANDLE       hMprServer,
    IN      HANDLE                  hInterface,
    IN      DWORD                   dwTransportId
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminInterfaceTransportRemove(hMprServer, hInterface,
                    dwTransportId);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr,
        FALSE,
        "HrMprAdminInterfaceTransportRemove");
    return hr;
}


HRESULT
HrMprAdminTransportCreate(
    IN      HANDLE                  hMprAdmin,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      PWSTR                  lpwsDLLPath
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprAdminTransportCreate (hMprAdmin, dwTransportId,
                    lpwsTransportName, pGlobalInfo, dwGlobalInfoSize,
                    pClientInterfaceInfo, dwClientInterfaceInfoSize,
                    lpwsDLLPath);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprAdminTransportCreate");
    return hr;
}


HRESULT
HrMprConfigServerConnect(
    IN      PWSTR                  lpwsServerName,
    OUT     HANDLE*                 phMprConfig
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigServerConnect (lpwsServerName, phMprConfig);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phMprConfig = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigServerConnect");
    return hr;
}

HRESULT
HrMprConfigInterfaceCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN      LPBYTE                  lpbBuffer,
    OUT     HANDLE*                 phRouterInterface
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceCreate (hMprConfig, dwLevel, lpbBuffer,
                                         phRouterInterface);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterInterface = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigInterfaceCreate");
    return hr;
}

HRESULT
HrMprConfigInterfaceEnum(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceEnum (hMprConfig, dwLevel, lplpBuffer,
                    dwPrefMaxLen, lpdwEntriesRead,
                    lpdwTotalEntries, lpdwResumeHandle);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *lpdwEntriesRead = 0;
        *lpdwTotalEntries = 0;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr,
        "HrMprConfigInterfaceEnum");
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportEnum(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwLevel,
    IN  OUT LPBYTE*                 lplpBuffer,     // MPR_IFTRANSPORT_0
    IN      DWORD                   dwPrefMaxLen,
    OUT     LPDWORD                 lpdwEntriesRead,
    OUT     LPDWORD                 lpdwTotalEntries,
    IN  OUT LPDWORD                 lpdwResumeHandle            OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportEnum (hMprConfig, hRouterInterface,
                    dwLevel, lplpBuffer,
                    dwPrefMaxLen, lpdwEntriesRead,
                    lpdwTotalEntries, lpdwResumeHandle);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *lpdwEntriesRead = 0;
        *lpdwTotalEntries = 0;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr,
        "HrMprConfigInterfaceTransportEnum");
    return hr;
}

HRESULT
HrMprConfigInterfaceGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      PWSTR                  lpwsInterfaceName,
    OUT     HANDLE*                 phRouterInterface
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceGetHandle (hMprConfig, lpwsInterfaceName,
                                            phRouterInterface);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterInterface = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr,
        "HrMprConfigInterfaceGetHandle");
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportAdd(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pInterfaceInfo,
    IN      DWORD                   dwInterfaceInfoSize,
    OUT     HANDLE*                 phRouterIfTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportAdd (hMprConfig, hRouterInterface,
                                               dwTransportId, lpwsTransportName,
                                               pInterfaceInfo, dwInterfaceInfoSize,
                                               phRouterIfTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterIfTransport = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigInterfaceTransportAdd");
    return hr;
}


HRESULT
HrMprConfigInterfaceTransportRemove(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      HANDLE                  hRouterIfTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportRemove(hMprConfig, hRouterInterface,
                                                 hRouterIfTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigInterfaceTransportRemove");
    return hr;
}

HRESULT
HrMprConfigInterfaceTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterInterface,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterIfTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigInterfaceTransportGetHandle (hMprConfig,
                                                     hRouterInterface,
                                                     dwTransportId,
                                                     phRouterIfTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterIfTransport = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NO_SUCH_INTERFACE) == hr,
        "HrMprConfigInterfaceTransportGetHandle");
    return hr;
}

HRESULT
HrMprConfigTransportCreate(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    IN      PWSTR                  lpwsTransportName           OPTIONAL,
    IN      LPBYTE                  pGlobalInfo,
    IN      DWORD                   dwGlobalInfoSize,
    IN      LPBYTE                  pClientInterfaceInfo        OPTIONAL,
    IN      DWORD                   dwClientInterfaceInfoSize   OPTIONAL,
    IN      PWSTR                  lpwsDLLPath,
    OUT     HANDLE*                 phRouterTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportCreate (hMprConfig, dwTransportId,
                    lpwsTransportName, pGlobalInfo, dwGlobalInfoSize,
                    pClientInterfaceInfo, dwClientInterfaceInfoSize,
                    lpwsDLLPath, phRouterTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterTransport = NULL;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigTransportCreate");
    return hr;
}

HRESULT
HrMprConfigTransportDelete(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportDelete (hMprConfig, hRouterTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigTransportDelete");
    return hr;
}

HRESULT
HrMprConfigTransportGetHandle(
    IN      HANDLE                  hMprConfig,
    IN      DWORD                   dwTransportId,
    OUT     HANDLE*                 phRouterTransport
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportGetHandle (hMprConfig, dwTransportId,
                                            phRouterTransport);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
        *phRouterTransport = NULL;
    }
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr,
        "HrMprConfigTransportGetHandle");
    return hr;
}

HRESULT
HrMprConfigTransportGetInfo(
    IN      HANDLE                  hMprConfig,
    IN      HANDLE                  hRouterTransport,
    IN  OUT LPBYTE*                 ppGlobalInfo                OPTIONAL,
    OUT     LPDWORD                 lpdwGlobalInfoSize          OPTIONAL,
    IN  OUT LPBYTE*                 ppClientInterfaceInfo       OPTIONAL,
    OUT     LPDWORD                 lpdwClientInterfaceInfoSize OPTIONAL,
    IN  OUT PWSTR*                 lplpwsDLLPath               OPTIONAL
)
{
    HRESULT hr = S_OK;
    DWORD dw = MprConfigTransportGetInfo (hMprConfig, hRouterTransport,
                                          ppGlobalInfo, lpdwGlobalInfoSize,
                                          ppClientInterfaceInfo,
                                          lpdwClientInterfaceInfoSize,
                                          lplpwsDLLPath);
    if (dw)
    {
        hr = HRESULT_FROM_WIN32 (dw);
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMprConfigTransportGetInfo");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\steelhead.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S T E E L H E A D . C P P
//
//  Contents:   Implementation of Steelhead configuration object.
//
//  Notes:
//
//  Author:     shaunco   15 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <mprerror.h>
#include <tdi.h>        // must include for isnkrnl.h
#include <isnkrnl.h>
#include <rtinfo.h>
#include <rasman.h>
#include "ncreg.h"
#include "rasobj.h"
#include "ncsvc.h"
#include "netcfgp.h"
#include "router.h"

extern const WCHAR c_szBiNdis5[];

extern const WCHAR c_szInfId_MS_NdisWan[];

//+---------------------------------------------------------------------------
// Static data for adding router managers.
//
static const WCHAR c_szRtrMgrIp    []  = L"Ip";
static const WCHAR c_szRtrMgrDllIp []  = L"%SystemRoot%\\System32\\iprtrmgr.dll";
static const WCHAR c_szRtrMgrIpx   []  = L"Ipx";
static const WCHAR c_szRtrMgrDllIpx[]  = L"%SystemRoot%\\System32\\ipxrtmgr.dll";

static const ROUTER_MANAGER_INFO c_rmiIp =
{
    PID_IP,
    0,
    c_szRtrMgrIp,
    c_szRtrMgrDllIp,
    MakeIpInterfaceInfo,
    MakeIpTransportInfo,
};

static const ROUTER_MANAGER_INFO c_rmiIpx =
{
    PID_IPX,
    ISN_FRAME_TYPE_AUTO,
    c_szRtrMgrIpx,
    c_szRtrMgrDllIpx ,
    MakeIpxInterfaceInfo,
    MakeIpxTransportInfo,
};

// These guids are defined in sdk\inc\ifguid.h
// We need the string versions.
//
// DEFINE_GUID(GUID_IpLoopbackInterface,  0xca6c0780, 0x7526, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);
// DEFINE_GUID(GUID_IpRasServerInterface, 0x6e06f030, 0x7526, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);
// DEFINE_GUID(GUID_IpxInternalInterface, 0xa571ba70, 0x7527, 0x11d2, 0xba, 0xf4, 0x00, 0x60, 0x08, 0x15, 0xa4, 0xbd);

//static const WCHAR c_szIpLoopbackInterface  [] = L"ca6c0780-7526-11d2-00600815a4bd";
//static const WCHAR c_szIpRasServerInterface [] = L"6e06f030-7526-11d2-00600815a4bd";
//static const WCHAR c_szIpxInternalInterface [] = L"a571ba70-7527-11d2-00600815a4bd";

// For Ipx, the adapter name is the bind name.
// We need to create an interface per frame type.
// The interface name is the adapter name followed
// by these strings.
//

#pragma BEGIN_CONST_SECTION
static const MAP_SZ_DWORD c_mapFrameType [] =
{
    L"/EthII",  MISN_FRAME_TYPE_ETHERNET_II,
    L"/802.3",  MISN_FRAME_TYPE_802_3,
    L"/802.2",  MISN_FRAME_TYPE_802_2,
    L"/SNAP",   MISN_FRAME_TYPE_SNAP,
};
#pragma END_CONST_SECTION

NOTHROW
BOOL
FMapFrameTypeToString (
    DWORD       dwFrameType,
    PCWSTR*    ppszFrameType)
{
    Assert (ppszFrameType);

    for (int i = 0; i < celems (c_mapFrameType); i++)
    {
        if (dwFrameType == c_mapFrameType[i].dwValue)
        {
            *ppszFrameType = c_mapFrameType[i].pszValue;
            return TRUE;
        }
    }

    TraceTag (ttidRasCfg, "FMapFrameTypeToString: Unknown frame type %d!",
            dwFrameType);

    *ppszFrameType = NULL;
    return FALSE;
}

NOTHROW
BOOL
FMapStringToFrameType (
    PCWSTR pszFrameType,
    DWORD*  pdwFrameType)
{
    Assert (pszFrameType);
    Assert (pdwFrameType);

    for (int i = 0; i < celems (c_mapFrameType); i++)
    {
        if (0 == lstrcmpW (pszFrameType, c_mapFrameType[i].pszValue))
        {
            *pdwFrameType = c_mapFrameType[i].dwValue;
            return TRUE;
        }
    }

    TraceTag (ttidRasCfg, "FMapStringToFrameType: Unknown frame type %S!",
            pszFrameType);

    *pdwFrameType = NULL;
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrShouldRouteOverAdapter
//
//  Purpose:    Indicate if we should router over the adapter or not.
//
//  Arguments:
//      pnccAdapter     [in]  Adapter to test.
//      ppszBindName   [out] Returned bindname if S_OK is returned.
//
//  Returns:    S_OK if we should router over the adapter, S_FALSE if not.
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//

HRESULT
HrShouldRouteOverAdapter (
    INetCfgComponent*   pnccAdapter,
    PWSTR*             ppszBindName)
{
    Assert (pnccAdapter);

    // Initialize the output parameter.
    //
    if (ppszBindName)
    {
        *ppszBindName = NULL;
    }

    // We should return S_OK if the adapter is physical or it supports
    // a binding interface of ndis5.  S_FALSE otherwise.
    //
    DWORD dwCharacter;
    HRESULT hr = pnccAdapter->GetCharacteristics (&dwCharacter);
    if (SUCCEEDED(hr) && !(dwCharacter & NCF_PHYSICAL))
    {
        INetCfgComponentBindings* pnccBindings;
        hr = pnccAdapter->QueryInterface (
                IID_INetCfgComponentBindings,
                reinterpret_cast<VOID**>(&pnccBindings));

        if (SUCCEEDED(hr))
        {
            hr = pnccBindings->SupportsBindingInterface (
                    NCF_UPPER, c_szBiNdis5);

            ReleaseObj (pnccBindings);
        }

        if (S_OK == hr)
        {
            // Only consider devices which are present.
            //
            // This check is made *after* the check for binding interface
            // match above for two reasons. 1) It's much more expensive
            // 2) for ndiswan devices which do not come online when they
            // are installed (e.g. ndiswannbfout), GetDeviceStatus will
            // fail.  For this case we don't want to route over ndiswannbf
            // anyhow so we should just return S_FALSE and not a failure.
            //
            DWORD dwStatus;
            hr = pnccAdapter->GetDeviceStatus(&dwStatus);
            if (SUCCEEDED(hr) && (CM_PROB_DEVICE_NOT_THERE == dwStatus))
            {
                hr = S_FALSE;
            }
        }
    }

    // SupportsBindingInterface may return S_OK or S_FALSE.
    // We only want the bind name if we're going to return S_OK.
    //
    if ((S_OK == hr) && ppszBindName)
    {
        hr = pnccAdapter->GetBindName (ppszBindName);
    }

    TraceError ("HrShouldRouteOverAdapter", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}


#if (WINVER >= 0x0501)

BOOL 
InitializeDialInRestriction();

#endif
//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::CSteelhead
//
//  Purpose:    Constructor
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
CSteelhead::CSteelhead () : CRasBindObject ()
{
    m_hMprConfig                    = NULL;
    m_hMprAdmin                     = NULL;
    m_fRemoving                     = FALSE;
    m_fUpdateRouterConfiguration    = FALSE;
    m_pnccMe                        = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::~CSteelhead
//
//  Purpose:    Destructor
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
CSteelhead::~CSteelhead ()
{
    Assert (!m_hMprConfig);
    Assert (!m_hMprAdmin);

    ReleaseObj (m_pnccMe);
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FAdapterExistsWithMatchingBindName
//
//  Purpose:
//
//  Arguments:
//      pszAdapterName [in]
//      ppnccAdapter    [out]
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FAdapterExistsWithMatchingBindName (
    PCWSTR             pszAdapterName,
    INetCfgComponent**  ppnccAdapter)
{
    Assert (pszAdapterName);
    Assert (ppnccAdapter);

    *ppnccAdapter = NULL;

    BOOL fFound = FALSE;

    // Enumerate physical adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter (m_pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent* pnccAdapter;
    while (!fFound &&  S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        // Only consider this adapter if we should router over it.
        //
        PWSTR pszBindName;
        hr = HrShouldRouteOverAdapter (pnccAdapter, &pszBindName);
        if (S_OK == hr)
        {
            if (0 == lstrcmpW (pszAdapterName, pszBindName))
            {
                fFound = TRUE;

                *ppnccAdapter = pnccAdapter;
                AddRefObj (pnccAdapter);
            }

            CoTaskMemFree (pszBindName);
        }

        ReleaseObj (pnccAdapter);
    }
    return fFound;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FIpxFrameTypeInUseOnAdapter
//
//  Purpose:
//
//  Arguments:
//      dwFrameType   []
//      pszAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FIpxFrameTypeInUseOnAdapter (
    DWORD  dwFrameType,
    PCWSTR pszAdapterName)
{
    // Assume its not in use.  If PnccIpx() is NULL, it means IPX is not
    // installed and the frame type is definately not in use on the adapter.
    //
    BOOL fRet = FALSE;
    if (PnccIpx())
    {
        // Get the private interface off of the INetCfgComponent for IPX
        // then we can query for a notify object interface
        //
        INetCfgComponentPrivate* pinccp;
        HRESULT hr = PnccIpx()->QueryInterface(
                                IID_INetCfgComponentPrivate,
                                reinterpret_cast<VOID**>(&pinccp));

        if (SUCCEEDED(hr))
        {
            IIpxAdapterInfo* pIpxAdapterInfo;
            hr = pinccp->QueryNotifyObject(
                                 IID_IIpxAdapterInfo,
                                 reinterpret_cast<VOID**>(&pIpxAdapterInfo));
            if (SUCCEEDED(hr))
            {
                // Get the frametypes in use for this adapter.
                //
                DWORD adwFrameType [MISN_FRAME_TYPE_MAX + 1];
                DWORD cdwFrameType;
                hr = pIpxAdapterInfo->GetFrameTypesForAdapter (
                        pszAdapterName,
                        celems (adwFrameType),
                        adwFrameType,
                        &cdwFrameType);
                if (SUCCEEDED(hr))
                {
                    for (DWORD i = 0; i < cdwFrameType; i++)
                    {
                        if (dwFrameType == adwFrameType[i])
                        {
                            fRet = TRUE;
                            break;
                        }
                    }
                }

                ReleaseObj (pIpxAdapterInfo);
            }

            ReleaseObj (pinccp);
        }
    }
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::FIpxFrameTypeInUseOnAdapter
//
//  Purpose:
//
//  Arguments:
//      pszFrameType   []
//      pszAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
BOOL
CSteelhead::FIpxFrameTypeInUseOnAdapter (
    PCWSTR pszFrameType,
    PCWSTR pszAdapterName)
{
    // Assume its not in use.  If PnccIpx() is NULL, it means IPX is not
    // installed and the frame type is definately not in use on the adapter.
    //
    BOOL    fRet = FALSE;
    DWORD   dwFrameType;
    if (PnccIpx() && FMapStringToFrameType (pszFrameType, &dwFrameType))
    {
        fRet = FIpxFrameTypeInUseOnAdapter (dwFrameType, pszAdapterName);
    }
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterfaceForAdapter
//
//  Purpose:    Ensures the router interface block for the specified
//              interface (adapter) is present and that the specified router
//              manger is configured for that interface.
//
//  Arguments:
//      dwIfType          [in] Interface type
//      dwPacketType      [in] The packet type (IPX only, ignored othewise)
//      pszAdapterName   [in] The adapter name
//      pszInterfaceName [in] The interface name
//      rmi               [in] The router manager
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterfaceForAdapter (
    ROUTER_INTERFACE_TYPE      dwIfType,
    DWORD                      dwPacketType,
    PCWSTR                     pszAdapterName,
    PCWSTR                     pszInterfaceName,
    const ROUTER_MANAGER_INFO& rmi)
{
    // Make sure the interface is created.
    //
    HANDLE hConfigInterface;
    HANDLE hAdminInterface;

    HRESULT hr = HrEnsureRouterInterface (
                    dwIfType,
                    pszInterfaceName,
                    &hConfigInterface,
                    &hAdminInterface);

    if (SUCCEEDED(hr))
    {
        // Ensure the router manager is added to the interface.
        //
        hr = HrEnsureRouterInterfaceTransport (
                pszAdapterName,
                dwPacketType,
                hConfigInterface,
                hAdminInterface,
                rmi);
    }
    TraceError ("CSteelhead::HrEnsureRouterInterfaceForAdapter", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureIpxRouterInterfacesForAdapter
//
//  Purpose:
//
//  Arguments:
//      pszAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureIpxRouterInterfacesForAdapter (
    PCWSTR pszAdapterName)
{
    AssertSz (PnccIpx(), "Why is this being called if IPX isn't installed?");

    // Get the IIpxAdapterInfo interface from the IPX notify object.
    // We'll use it to find out how adapters are configured under IPX.
    //
    IIpxAdapterInfo* pIpxAdapterInfo;
    HRESULT hr = HrQueryNotifyObject (
                    PnccIpx(),
                    IID_IIpxAdapterInfo,
                    reinterpret_cast<VOID**>(&pIpxAdapterInfo));

    if (SUCCEEDED(hr))
    {
        // Get the frametypes in use for this adapter.
        //
        DWORD adwFrameType [MISN_FRAME_TYPE_MAX + 1];
        DWORD cdwFrameType;
        hr = pIpxAdapterInfo->GetFrameTypesForAdapter (
                pszAdapterName,
                celems (adwFrameType),
                adwFrameType,
                &cdwFrameType);
        if (SUCCEEDED(hr) && cdwFrameType)
        {
            // If more than one frame type is in use, or if there is only
            // one and it isn't auto, then we'll be creating interfaces
            // for those frame types explicitly.
            //
            if ((cdwFrameType > 1) ||
                ((1 == cdwFrameType) &&
                 (ISN_FRAME_TYPE_AUTO != adwFrameType[0])))
            {
                for (DWORD i = 0; SUCCEEDED(hr) && (i < cdwFrameType); i++)
                {
                    PCWSTR pszFrameType;
                    if (FMapFrameTypeToString (adwFrameType[i], &pszFrameType))
                    {
                        // Make the interface name by catenating the
                        // adapter (bind) name with the frame type.
                        //
                        WCHAR szInterfaceName [512];
                        lstrcpyW (szInterfaceName, pszAdapterName);
                        lstrcatW (szInterfaceName, pszFrameType);

                        hr = HrEnsureRouterInterfaceForAdapter (
                                ROUTER_IF_TYPE_DEDICATED,
                                adwFrameType[i],
                                pszAdapterName,
                                szInterfaceName,
                                c_rmiIpx);
                    }
                }
            }

            // Otherwise, we'll create the interface for the auto frame
            // type case.
            //
            else
            {
#ifdef DBG
                AssertSz (1 == cdwFrameType,
                        "IPX should report at least one frame type.  "
                        "You may continue without a problem.");
                if (1 == cdwFrameType)
                {
                    AssertSz (ISN_FRAME_TYPE_AUTO == adwFrameType[0],
                            "Frame type should be auto here.  "
                            "You may continue without a problem.");
                }
#endif
                hr = HrEnsureRouterInterfaceForAdapter (
                        ROUTER_IF_TYPE_DEDICATED,
                        ISN_FRAME_TYPE_AUTO,
                        pszAdapterName,
                        pszAdapterName,
                        c_rmiIpx);
            }
        }

        ReleaseObj (pIpxAdapterInfo);
    }

    TraceError ("CSteelhead::HrEnsureIpxRouterInterfacesForAdapter", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterface
//
//  Purpose:    Ensures the specified router interface is present and
//              returns a handle to it.
//
//  Arguments:
//      pszInterfaceName [in]  The interface (adapter) name
//      phConfigInterface       [out] Returned handle to the interface
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterface (
    ROUTER_INTERFACE_TYPE   dwIfType,
    PCWSTR                 pszInterfaceName,
    HANDLE*                 phConfigInterface,
    HANDLE*                 phAdminInterface)
{
    Assert (pszInterfaceName);
    Assert (phConfigInterface);
    Assert (phAdminInterface);

    // Initialize the output parameters.
    //
    *phConfigInterface = NULL;
    *phAdminInterface = NULL;

    HRESULT hrConfig;
    HRESULT hrAdmin;

    hrConfig = HrMprConfigInterfaceGetHandle (m_hMprConfig,
                        const_cast<PWSTR>(pszInterfaceName),
                        phConfigInterface);

    hrAdmin  = HrMprAdminInterfaceGetHandle (m_hMprAdmin,
                        const_cast<PWSTR>(pszInterfaceName),
                        phAdminInterface, FALSE);

    if ((HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE ) == hrConfig) ||
        (HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE ) == hrAdmin))
    {
        // It's not installed, so we'll create it.
        //

        MPR_INTERFACE_0 ri0;
        ZeroMemory (&ri0, sizeof(ri0));
        ri0.hInterface = INVALID_HANDLE_VALUE;
        ri0.fEnabled   = TRUE;  // thanks gibbs
        ri0.dwIfType   = dwIfType;

        // Copy the interface name into the buffer.
        //
        AssertSz (lstrlenW (pszInterfaceName) < celems (ri0.wszInterfaceName),
                  "Bindname too big for MPR_INTERFACE_0 buffer.");
        lstrcpyW (ri0.wszInterfaceName, pszInterfaceName);

        // Create the interface.
        //
        if (HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE) == hrConfig)
        {
            hrConfig = HrMprConfigInterfaceCreate (
                            m_hMprConfig, 0, (LPBYTE)&ri0, phConfigInterface);

            TraceTag (ttidRasCfg, "MprConfigInterfaceCreate for %S",
                pszInterfaceName);
        }

        if (HRESULT_FROM_WIN32 (ERROR_NO_SUCH_INTERFACE) == hrAdmin)
        {
            hrAdmin = HrMprAdminInterfaceCreate (
                            m_hMprAdmin, 0, (LPBYTE)&ri0, phAdminInterface);

            TraceTag (ttidRasCfg, "MprAdminInterfaceCreate for %S",
                pszInterfaceName);
        }
    }

    TraceError ("CSteelhead::HrEnsureRouterInterface", hrConfig);
    return hrConfig;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterInterfaceTransport
//
//  Purpose:    Ensures the specified router manager is configured over
//              the specified interface.
//
//  Arguments:
//      pszAdapterName     [in] The adapter name
//      dwPacketType        [in] The packet type (IPX only, ignored otherwise)
//      hInterface          [in] Handle to the interface
//      rmi                 [in] The router manager
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterInterfaceTransport (
    PCWSTR                     pszAdapterName,
    DWORD                       dwPacketType,
    HANDLE                      hConfigInterface,
    HANDLE                      hAdminInterface,
    const ROUTER_MANAGER_INFO&  rmi)
{
    Assert (hConfigInterface);
    // hAdminInterface may be NULL if the router is not running.

    HRESULT hrConfig;

    // See if the router manager is present on the interface.
    //
    HANDLE hIfTransport;

    hrConfig = HrMprConfigInterfaceTransportGetHandle (
                    m_hMprConfig, hConfigInterface,
                    rmi.dwTransportId, &hIfTransport);

    if (FAILED(hrConfig))
    {
        // Ensure the router manager is present.
        //
        hrConfig = HrEnsureRouterManager (rmi);

        if (SUCCEEDED(hrConfig))
        {
            // Create the interface info and add the router manager to
            // the interface.
            //
            PRTR_INFO_BLOCK_HEADER  pibh;

            Assert (rmi.pfnMakeInterfaceInfo);
            rmi.pfnMakeInterfaceInfo (pszAdapterName,
                                      dwPacketType,
                                      (LPBYTE*)&pibh);

            hrConfig = HrMprConfigInterfaceTransportAdd (
                            m_hMprConfig,
                            hConfigInterface,
                            rmi.dwTransportId,
                            const_cast<PWSTR>(rmi.pszwTransportName),
                            (LPBYTE)pibh,
                            pibh->Size,
                            &hIfTransport);

            TraceTag (ttidRasCfg, "MprConfigInterfaceTransportAdd for "
                "%S on %S",
                rmi.pszwTransportName,
                pszAdapterName);

            if (SUCCEEDED(hrConfig) && hAdminInterface)
            {
                Assert (m_hMprAdmin);
                (VOID) HrMprAdminInterfaceTransportAdd (
                                m_hMprAdmin,
                                hAdminInterface,
                                rmi.dwTransportId,
                                (LPBYTE)pibh,
                                pibh->Size);

                TraceTag (ttidRasCfg, "MprAdminInterfaceTransportAdd for "
                    "%S on %S",
                    rmi.pszwTransportName,
                    pszAdapterName);
            }

            MemFree (pibh);
        }
    }
    TraceError ("CSteelhead::HrEnsureRouterInterfaceTransport", hrConfig);
    return hrConfig;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterManager
//
//  Purpose:    Ensures that the specified router manager is installed.
//
//  Arguments:
//      rmi [in] The router manager.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrEnsureRouterManager (
    const ROUTER_MANAGER_INFO& rmi)
{
    PRTR_INFO_BLOCK_HEADER  pibhGlobal;
    BOOL                    fCreate = FALSE;

    // See if the router manager is installed.
    //
    HANDLE hTransport;
    HRESULT hr = HrMprConfigTransportGetHandle (m_hMprConfig,
                                                rmi.dwTransportId,
                                                &hTransport);
    if (HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr)
    {
        // It's not installed, we'll create it.
        //
        fCreate = TRUE;
    }
    else if (SUCCEEDED(hr))
    {
        // Its installed, see if its transport info is available.
        //
        DWORD dwSize;
        hr = HrMprConfigTransportGetInfo (m_hMprConfig, hTransport,
                                          (LPBYTE*)&pibhGlobal, &dwSize,
                                          NULL, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            if (!pibhGlobal)
            {
                // Global info is missing, we'll create it.
                //
                fCreate = TRUE;
            }
            else
            {
                MprConfigBufferFree (pibhGlobal);
            }
        }
    }

    if (fCreate)
    {
        // Install the router manager.
        //
        Assert (rmi.pfnMakeTransportInfo);
        PRTR_INFO_BLOCK_HEADER  pibhClient;
        rmi.pfnMakeTransportInfo ((LPBYTE*)&pibhGlobal,
                                  (LPBYTE*)&pibhClient);

        hr = HrMprConfigTransportCreate (
                     m_hMprConfig,
                     rmi.dwTransportId,
                     const_cast<PWSTR>(rmi.pszwTransportName),
                     (LPBYTE)pibhGlobal, (pibhGlobal) ? pibhGlobal->Size : 0,
                     (LPBYTE)pibhClient, (pibhClient) ? pibhClient->Size : 0,
                     const_cast<PWSTR>(rmi.pszwDllPath),
                     &hTransport);

        (VOID) HrMprAdminTransportCreate (
                     m_hMprAdmin,
                     rmi.dwTransportId,
                     const_cast<PWSTR>(rmi.pszwTransportName),
                     (LPBYTE)pibhGlobal, (pibhGlobal) ? pibhGlobal->Size : 0,
                     (LPBYTE)pibhClient, (pibhClient) ? pibhClient->Size : 0,
                     const_cast<PWSTR>(rmi.pszwDllPath));

        MemFree (pibhGlobal);
        MemFree (pibhClient);
    }
    TraceError ("CSteelhead::HrEnsureRouterManager", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrEnsureRouterManagerDeleted
//
//  Purpose:    Ensures that the specified router manager is not installed.
//
//  Arguments:
//      rmi [in] The router manager.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   6 Sep 1997
//
//  Notes:
//
HRESULT CSteelhead::HrEnsureRouterManagerDeleted (
    const ROUTER_MANAGER_INFO& rmi)
{
    // See if the router manager is installed.
    //
    HANDLE hTransport;
    HRESULT hr = HrMprConfigTransportGetHandle (m_hMprConfig,
                                                rmi.dwTransportId,
                                                &hTransport);
    if (SUCCEEDED(hr))
    {
        // It is installed, so we need to delete it.
        //
        (VOID) HrMprConfigTransportDelete (m_hMprConfig, hTransport);
    }
    TraceError ("CSteelhead::HrEnsureRouterManagerDeleted",
                (HRESULT_FROM_WIN32 (ERROR_UNKNOWN_PROTOCOL_ID) == hr)
                ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToAddInterfaces
//
//  Purpose:
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToAddInterfaces ()
{
    HRESULT hr = S_OK;

    // Enumerate physical adapters in the system.
    //
    CIterNetCfgComponent nccIter(m_pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent* pnccAdapter;
    while (S_OK == (hr = nccIter.HrNext(&pnccAdapter)))
    {
        // Only consider this adapter if we should router over it.
        //
        PWSTR pszBindName;
        hr = HrShouldRouteOverAdapter (pnccAdapter, &pszBindName);
        if (S_OK == hr)
        {
            INetCfgComponentBindings* pnccBindingsIp = NULL;
            INetCfgComponentBindings* pnccBindingsIpx = NULL;

            // If Ip is bound to the adapter, create and interface
            // for it.
            //
            if (PnccIp())
            {
                hr = PnccIp()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<VOID**>(&pnccBindingsIp) );
            }
            if (PnccIp() && SUCCEEDED(hr) &&
                (S_OK == (hr = pnccBindingsIp->IsBoundTo (pnccAdapter))))
            {
                // Interface name is the same as the adapter name
                // is the same as the bind name.
                //
                hr = HrEnsureRouterInterfaceForAdapter (
                        ROUTER_IF_TYPE_DEDICATED,
                        0,
                        pszBindName,
                        pszBindName,
                        c_rmiIp);

            }
            ReleaseObj (pnccBindingsIp);

            // If Ipx is bound to the adapter, create the interface(s)
            // for it.
            if (PnccIpx())
            {
                hr = PnccIpx()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<VOID**>(&pnccBindingsIpx));
            }
            if (PnccIpx() &&
                (S_OK == (hr = pnccBindingsIpx->IsBoundTo( pnccAdapter )) ))
            {
#if (WINVER < 0x0501)
                hr = HrEnsureIpxRouterInterfacesForAdapter (pszBindName);
#endif
            }
            ReleaseObj (pnccBindingsIpx);

            CoTaskMemFree (pszBindName);
        }

        ReleaseObj (pnccAdapter);
    }
    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError ("CSteelhead::HrPassToAddInterfaces", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToRemoveInterfaces
//
//  Purpose:
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToRemoveInterfaces (
    BOOL fFromRunningRouter)
{
    // Enumerate all of the installed router interfaces.
    //
    MPR_INTERFACE_0*    ari0;
    DWORD               dwEntriesRead;
    DWORD               dwTotalEntries;
    HRESULT             hr;

    if (fFromRunningRouter)
    {
        Assert (m_hMprAdmin);
        hr = HrMprAdminInterfaceEnum (m_hMprAdmin, 0,
                        reinterpret_cast<LPBYTE*>(&ari0),
                        -1, &dwEntriesRead, &dwTotalEntries, NULL);
    }
    else
    {
        hr = HrMprConfigInterfaceEnum (m_hMprConfig, 0,
                        reinterpret_cast<LPBYTE*>(&ari0),
                        -1, &dwEntriesRead, &dwTotalEntries, NULL);
    }
    if (SUCCEEDED(hr))
    {
        // By passing -1, we want everything, so we should get everything.
        Assert (dwEntriesRead == dwTotalEntries);

        // Iterate all of the interfaces.
        //
        for (MPR_INTERFACE_0* pri0 = ari0; dwEntriesRead--; pri0++)
        {
            BOOL fDeleteInterface = FALSE;
            PCWSTR pszInternalAdapter = SzLoadIds (IDS_RAS_INTERNAL_ADAPTER);

            // If its the internal interface and IP and IPX are no longer
            // installed delete the interface.
            //
            if ((ROUTER_IF_TYPE_INTERNAL == pri0->dwIfType) &&
                !PnccIpx() && !PnccIp() &&
                (0 == lstrcmpW (pri0->wszInterfaceName, pszInternalAdapter)))
            {
                fDeleteInterface = TRUE;
            }
            else if (ROUTER_IF_TYPE_DEDICATED != pri0->dwIfType)
            {
                // Skip non-dedicated interfaces.
                //
                continue;
            }

            BOOL                fSpecialIpxInterface = FALSE;
            INetCfgComponent*   pnccAdapter          = NULL;

            // Get the name of the interface and look for a '/' separator.
            // If present, it means this is a special IPX interface where
            // the first substring is the adapter name, and the second
            // substring is the frame type.
            //
            WCHAR* pchwSep = wcschr (pri0->wszInterfaceName, L'/');
            if (!fDeleteInterface && pchwSep)
            {
                fSpecialIpxInterface = TRUE;

                // Point to the frame type string.
                //
                PCWSTR pszFrameType = pchwSep;

                // Copy the adapter name into its own buffer.
                //
                WCHAR   szAdapterName [MAX_INTERFACE_NAME_LEN+1];
                lstrcpynW (szAdapterName, pri0->wszInterfaceName,
                            (int)(pchwSep - pri0->wszInterfaceName + 1));

                // If the frame type is not in use for the adapter, we need
                // to delete this interface.  This condition happens when
                // IPX configuration is changed and the frame type is removed
                // from the adapter.
                //
                if (!FIpxFrameTypeInUseOnAdapter (pszFrameType,
                        szAdapterName))
                {
                    fDeleteInterface = TRUE;
                    TraceTag (ttidRasCfg, "%S no longer in use on %S. "
                            "Deleting the router interface.",
                            pszFrameType, szAdapterName);
                }
            }

            // It's not a special interface, so just make sure an adapter
            // exists with a matching bind name.  If not, we will delete
            // the interface.
            //
            else if (!fDeleteInterface)
            {
                if (!FAdapterExistsWithMatchingBindName (
                        pri0->wszInterfaceName,
                        &pnccAdapter))
                {
                    fDeleteInterface = TRUE;
                    TraceTag (ttidRasCfg, "%S no longer present. "
                            "Deleting the router interface.",
                            pri0->wszInterfaceName);
                }
            }

            // Delete the interface if we need to.
            //
            if (fDeleteInterface)
            {
                if (fFromRunningRouter)
                {
                    MprAdminInterfaceDelete (m_hMprAdmin, pri0->hInterface);
                }
                else
                {
                    MprConfigInterfaceDelete (m_hMprConfig, pri0->hInterface);
                }
            }

            // If we don't need to delete the entire interface, check
            // for transports on the interface that we may need to delete.
            // Don't do this for the running router because there is
            // no MprAdminInterfaceTransportEnum API.
            //
            else if (!fFromRunningRouter)
            {
                // If its not an IPX special interface, the adapter
                // is the interface name.  If it is an IPX special
                // interface, then we would have already remove the entire
                // interface above if it were invalid.
                //
                (VOID) HrPassToRemoveInterfaceTransports (
                        pri0,
                        (!fSpecialIpxInterface) ? pri0->wszInterfaceName
                                                : NULL,
                        pnccAdapter);
            }

            ReleaseObj (pnccAdapter);
        }

        MprConfigBufferFree (ari0);
    }
    else if ((HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr) ||
             (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr) ||
             (HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) == hr))
    {
        hr = S_OK;
    }
    TraceError ("CSteelhead::HrPassToRemoveInterfaces", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrPassToRemoveInterfaceTransports
//
//  Purpose:
//
//  Arguments:
//      hInterface      []
//      pszAdapterName []
//
//  Returns:
//
//  Author:     shaunco   27 Aug 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrPassToRemoveInterfaceTransports (
    MPR_INTERFACE_0*   pri0,
    PCWSTR             pszAdapterName,
    INetCfgComponent*  pnccAdapter)
{
    Assert (FImplies(pnccAdapter, pszAdapterName));

    // Enumerate all of the transports active on the router interface.
    //
    MPR_IFTRANSPORT_0*  arit0;
    DWORD               dwEntriesRead;
    DWORD               dwTotalEntries;
    HRESULT hr = HrMprConfigInterfaceTransportEnum (m_hMprConfig,
                    pri0->hInterface, 0,
                    reinterpret_cast<LPBYTE*>(&arit0),
                    -1, &dwEntriesRead, &dwTotalEntries, NULL);
    if (SUCCEEDED(hr))
    {
        // By passing -1, we want everything, so we should get everything.
        Assert (dwEntriesRead == dwTotalEntries);

        INetCfgComponentBindings* pnccBindingsIpx = NULL;
        INetCfgComponentBindings* pnccBindingsIp  = NULL;

        if (PnccIp())
        {
            hr = PnccIp()->QueryInterface (IID_INetCfgComponentBindings,
                    reinterpret_cast<VOID**>(&pnccBindingsIp));
        }
        if (SUCCEEDED(hr))
        {
            if (PnccIpx())
            {
                hr = PnccIpx()->QueryInterface (IID_INetCfgComponentBindings,
                        reinterpret_cast<VOID**>(&pnccBindingsIpx));
            }
            if (SUCCEEDED(hr))
            {
                // Iterate all of the transports.
                //
                for (MPR_IFTRANSPORT_0* prit0 = arit0; dwEntriesRead--; prit0++)
                {
                    BOOL fDeleteInterfaceTransport = FALSE;

                    if (prit0->dwTransportId == c_rmiIp.dwTransportId)
                    {
                        if (!PnccIp())
                        {
                            fDeleteInterfaceTransport = TRUE;
                            TraceTag (ttidRasCfg, "TCP/IP no longer present.  "
                                    "Deleting this transport from interface %S.",
                                    pri0->wszInterfaceName);
                        }
                        else if (pnccAdapter &&
                                 (S_OK != (hr = pnccBindingsIp->IsBoundTo (pnccAdapter))))
                        {
                            fDeleteInterfaceTransport = TRUE;
                            TraceTag (ttidRasCfg, "TCP/IP no longer bound.  "
                                    "Deleting this transport from interface %S.",
                                    pri0->wszInterfaceName);
                        }
                    }
                    else if (prit0->dwTransportId == c_rmiIpx.dwTransportId)
                    {
                        if (!PnccIpx())
                        {
                            fDeleteInterfaceTransport = TRUE;
                            TraceTag (ttidRasCfg, "IPX no longer present.  "
                                    "Deleting this transport from interface %S.",
                                    pri0->wszInterfaceName);
                        }
                        else if (pnccAdapter &&
                                 (S_OK != (hr = pnccBindingsIpx->IsBoundTo (pnccAdapter))))
                        {
                            fDeleteInterfaceTransport = TRUE;
                            TraceTag (ttidRasCfg, "IPX no longer bound.  "
                                    "Deleting this transport from interface %S.",
                                    pri0->wszInterfaceName);
                        }
                        else if (pszAdapterName)
                        {
                            Assert (PnccIpx());

                            // if frame type is not auto on this adapter, delete
                            // the transport
                            if (!FIpxFrameTypeInUseOnAdapter (ISN_FRAME_TYPE_AUTO,
                                    pszAdapterName))
                            {
                                fDeleteInterfaceTransport = TRUE;
                                TraceTag (ttidRasCfg, "IPX Auto frame type no longer "
                                        "in use on %S.  "
                                        "Deleting this transport from interface %S.",
                                        pszAdapterName, pri0->wszInterfaceName);
                            }
                        }
                    }

                    if (fDeleteInterfaceTransport)
                    {
                        MprConfigInterfaceTransportRemove (
                            m_hMprConfig,
                            pri0->hInterface,
                            prit0->hIfTransport);
                    }

                }
                MprConfigBufferFree (arit0);

                ReleaseObj (pnccBindingsIpx);
            }

            ReleaseObj (pnccBindingsIp);
        }
    }
    else if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        // If there are no transports for this interface, that's okay.
        //
        hr = S_OK;
    }

    TraceError ("CSteelhead::HrPassToRemoveInterfaceTransports", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSteelhead::HrUpdateRouterConfiguration
//
//  Purpose:    Updates the router configuration by ensuring router managers
//              are installed for the protocols present on the system (IP and
//              IPX).  Further, router interfaces are created for each
//              physical netcard present on the system.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   28 Jul 1997
//
//  Notes:
//
HRESULT
CSteelhead::HrUpdateRouterConfiguration ()
{
    HKEY hKey;
    
    Assert (!m_hMprConfig);

    HRESULT hr = HrMprConfigServerConnect (NULL, &m_hMprConfig);
    if (SUCCEEDED(hr))
    {
        PCWSTR pszInternalAdapter = SzLoadIds (IDS_RAS_INTERNAL_ADAPTER);
        PCWSTR pszLoopbackAdapter = SzLoadIds (IDS_RAS_LOOPBACK_ADAPTER);

        // Connect to the running router if able.
        // (m_hMprAdmin will be non-NULL if we do.)
        //
        Assert (!m_hMprAdmin);
        (VOID) HrMprAdminServerConnect (NULL, &m_hMprAdmin);

        // Ensure router managers are installed for the protocols
        // we know about.  Good to do this in case no physical adapters.
        // are found below.  We actually do this by ensuring the internal
        // interface exists.  This will implicitly ensure the router
        // manger is created.
        //
        if (PnccIp())
        {
            (VOID) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_LOOPBACK,
                    c_rmiIp.dwPacketType,
                    pszLoopbackAdapter,
                    pszLoopbackAdapter,
                    c_rmiIp);

            (VOID) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_INTERNAL,
                    c_rmiIp.dwPacketType,
                    pszInternalAdapter,
                    pszInternalAdapter,
                    c_rmiIp);
        }
        else
        {
            (VOID) HrEnsureRouterManagerDeleted (c_rmiIp);
        }

        if (PnccIpx())
        {
            (VOID) HrEnsureRouterInterfaceForAdapter (
                    ROUTER_IF_TYPE_INTERNAL,
                    c_rmiIpx.dwPacketType,
                    pszInternalAdapter,
                    pszInternalAdapter,
                    c_rmiIpx);
        }
        else
        {
            (VOID) HrEnsureRouterManagerDeleted (c_rmiIpx);
        }

        (VOID) HrPassToAddInterfaces ();

        (VOID) HrPassToRemoveInterfaces (FALSE);

        // If we have a connection to the running router, make a pass
        // to remove interfaces from it.
        //
        if (m_hMprAdmin)
        {
            (VOID) HrPassToRemoveInterfaces (TRUE);
#if (WINVER >= 0x0501)
            (VOID) HrRemoveIPXRouterConfiguration(TRUE);
#endif
            MprAdminServerDisconnect (m_hMprAdmin);
            m_hMprAdmin = NULL;
        }

#if (WINVER >= 0x0501)
        (VOID) HrRemoveIPXRouterConfiguration(FALSE);

        //
        // Remove IPX router Manager configuration
        //

        (VOID) HrEnsureRouterManagerDeleted(c_rmiIpx);

        //
        // Remove IPX keys under HKLM\Software\Microsoft\Router\CurrentVersion
        //

        hr = HrRegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Router\\CurrentVersion\\RouterManagers",
                KEY_ALL_ACCESS,
                &hKey
                );

        if (SUCCEEDED(hr))
        {
            (VOID) SHDeleteKey(hKey, L"Ipx");
            RegCloseKey(hKey);
            hKey = NULL;
        }

        //
        // Remove IPX keys under HKLM\Software\Microsoft\IPXMibAgent
        //

        hr = HrRegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft",
                KEY_ALL_ACCESS,
                &hKey
                );

        if (SUCCEEDED(hr))
        {
            (VOID) SHDeleteKey(hKey, L"IPXMibAgent");
            RegCloseKey(hKey);
            hKey = NULL;
        }

        //
        // Remove keys for NWLNKFWD and NWLNKFLT
        //

        hr = HrRegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services",
                KEY_ALL_ACCESS,
                &hKey
                );

        if (SUCCEEDED(hr))
        {
            (VOID) SHDeleteKey(hKey, L"NwlnkFwd");
            (VOID) SHDeleteKey(hKey, L"NwlnkFlt");
            RegCloseKey(hKey);
            hKey = NULL;
        }

        //
        // Restrict ports on non-Enterprise/non-datacenter SKU to
        //      100 per media type
        //
        
        //
        // Check server version.
        //

        hr = S_OK;
        
        if (InitializeDialInRestriction())
        {
            //
            // For standard version, limit ports for all media types to a 100
            //

            //
            // Open key "System\\CurrentControlSet\\Control
            //              \\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
            //

            hr = HrRegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    L"System\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}",
                    KEY_ALL_ACCESS,
                    &hKey
                    );

            if (SUCCEEDED(hr))
            {
                // Enumerate subkeys
                //  - for each key check value of WanEndpoints
                //  -   if value greater than MAX_DIALIN restrict it to that.
                //
                // 

                DWORD       dwIndex = 0;
                WCHAR       wcKeyName[MAX_PATH + 1];
                DWORD       dwSize = MAX_PATH + 1, dwValue;
                HKEY        hEnumKey = NULL;
                FILETIME    ft;
                
                do 
                {
                    dwSize = MAX_PATH + 1;
                    
                    hr = HrRegEnumKeyEx(
                            hKey,
                            dwIndex,
                            wcKeyName,
                            &dwSize,
                            NULL,
                            NULL,
                            &ft
                            );
                            
                    if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_SUCCESS);
                        break;
                    }

                    if ((HRESULT_CODE(hr) != ERROR_MORE_DATA) &&
                        (HRESULT_CODE(hr) != ERROR_SUCCESS))
                    {
                        dwIndex++;
                        continue;
                    }

                    hr = HrRegOpenKeyEx(
                            hKey,
                            wcKeyName,
                            KEY_ALL_ACCESS,
                            &hEnumKey
                            );

                    if (FAILED(hr))
                    {
                        //
                        // Move to next key
                        //

                        dwIndex++;
                        continue;
                    }

                    dwValue = 0;
                    
                    hr = HrRegQueryDword(
                            hEnumKey,
                            L"WanEndPoints",
                            &dwValue
                            );

                    if (SUCCEEDED(hr) && (dwValue > MAX_ALLOWED_DIALIN))
                    {
                        HrRegSetDword(
                            hEnumKey, 
                            L"WanEndPoints", 
                            MAX_ALLOWED_DIALIN
                            );
                    }

                    RegCloseKey(hEnumKey);
                    hEnumKey = NULL;
                    dwIndex++;
                    
                } while( TRUE );

                RegCloseKey(hKey);
                hKey = NULL;
            }

            if (FAILED(hr))
            {
                //
                // Since this code may be invoked by non-admin, e.g NetCfgop,
                //  when IP addresses etc. are changed, access denied can be
                //  ignored in those cases
                //
                
                if (HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)
                {
                    TraceError ("CSteelhead::HrUpdateRouterConfiguration, "
                        "ignoring ", hr);
                    hr = HRESULT_FROM_WIN32(ERROR_SUCCESS);
                }
            }
        }
#endif

        MprConfigServerDisconnect (m_hMprConfig);
        m_hMprConfig = NULL;
    }

    TraceError ("CSteelhead::HrUpdateRouterConfiguration", hr);
    return hr;
}

#if (WINVER >= 0x0501)
//+---------------------------------------------------------------------------
//
//  Member :    CSteelhead::HrRemoveIPXRouterConfiguration
//
//  Purpose:    Updates the router configuration to remove all the IPX related 
//              configuration
//
//  Arguments:
//      fRouter -   Remove from running instance of router
//
//  Returns:    S_OK or an error code.
//
//  Author:     vraman 17 April 2002
//
//  Notes:
//

HRESULT
CSteelhead::HrRemoveIPXRouterConfiguration(
    BOOL                fRouter)
{

    HRESULT             hr = S_OK;
    MPR_INTERFACE_0     *ari0;
    DWORD               dwIfRead, dwIfTotal, dwIfTransRead, dwIfTransTotal;
    HANDLE              hIfTransport;

    //
    // Enumerate interfaces
    //

    if (fRouter)
    {
        Assert (m_hMprAdmin);
        hr = HrMprAdminInterfaceEnum(
                m_hMprAdmin, 
                0,
                reinterpret_cast<LPBYTE*>(&ari0),
                -1, 
                &dwIfRead, 
                &dwIfTotal, 
                NULL
                );
    }
    else
    {
        hr = HrMprConfigInterfaceEnum(
                m_hMprConfig, 
                0,
                reinterpret_cast<LPBYTE*>(&ari0),
                -1, 
                &dwIfRead, 
                &dwIfTotal, 
                NULL
                );
    }

    if (SUCCEEDED(hr))
    {
        for (MPR_INTERFACE_0 *pri0 = ari0; dwIfRead--; pri0++)
        {
            //
            // For each interface, remove RRAS IPX config
            //

            if (fRouter)
            {
                hr = HrMprAdminInterfaceTransportRemove(
                        m_hMprAdmin,
                        pri0->hInterface,
                        PID_IPX
                        );
            }
            else
            {
                hr = HrMprConfigInterfaceTransportGetHandle(
                        m_hMprConfig,
                        pri0->hInterface,
                        PID_IPX,
                        &hIfTransport
                        );

                if (SUCCEEDED(hr))
                {
                    hr = HrMprConfigInterfaceTransportRemove(
                            m_hMprConfig,
                            pri0->hInterface,
                            hIfTransport
                            );
                }
            }
        }
    }

    TraceError ("CSteelhead::HrRemoveIPXRouterConfiguration", hr);
    return hr;
}

#endif

//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CSteelhead::Initialize (
    INetCfgComponent*   pncc,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    m_fUpdateRouterConfiguration = fInstalling;

    return S_OK;
}

STDMETHODIMP
CSteelhead::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    if (!m_fRemoving && m_fUpdateRouterConfiguration)
    {
        m_fUpdateRouterConfiguration = FALSE;

        TraceTag (ttidRasCfg, "Updating Steelhead configuration.");

        hr = HrFindOtherComponents ();
        if (SUCCEEDED(hr))
        {
            hr = HrUpdateRouterConfiguration ();

            ReleaseOtherComponents ();
        }

        if (FAILED(hr))
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    Validate_INetCfgNotify_Apply_Return (hr);

    TraceError ("CSteelhead::ApplyRegistryChanges",
        (NETCFG_S_REBOOT == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CSteelhead::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    // Install NdisWan.
    hr = HrInstallComponentOboComponent (m_pnc, NULL,
             GUID_DEVCLASS_NETTRANS,
             c_szInfId_MS_NdisWan,
             m_pnccMe,
             NULL);

    TraceError ("CSteelhead::Install", hr);
    return hr;
}

STDMETHODIMP
CSteelhead::Removing ()
{
    HRESULT hr;

    m_fRemoving = TRUE;

    // Remove NdisWan.
    hr = HrRemoveComponentOboComponent (m_pnc,
            GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NdisWan,
            m_pnccMe);

    TraceError ("CSteelhead::Removing", hr);
    return hr;
}

STDMETHODIMP
CSteelhead::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}

//+---------------------------------------------------------------------------
// INetCfgSystemNotify
//
STDMETHODIMP
CSteelhead::GetSupportedNotifications (
    DWORD*  pdwNotificationFlag)
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications (pdwNotificationFlag);

    *pdwNotificationFlag = NCN_NET | NCN_NETTRANS |
                           NCN_ADD | NCN_REMOVE |
                           NCN_PROPERTYCHANGE;

    return S_OK;
}

STDMETHODIMP
CSteelhead::SysQueryBindingPath (
    DWORD               dwChangeFlag,
    INetCfgBindingPath* pncbp)
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::SysQueryComponent (
    DWORD               dwChangeFlag,
    INetCfgComponent*   pncc)
{
    return S_OK;
}

STDMETHODIMP
CSteelhead::SysNotifyBindingPath (
    DWORD               dwChangeFlag,
    INetCfgBindingPath* pncbp)
{
    return S_FALSE;
}

STDMETHODIMP
CSteelhead::SysNotifyComponent (
    DWORD               dwChangeFlag,
    INetCfgComponent*   pncc)
{
    HRESULT hr;

    Validate_INetCfgSystemNotify_SysNotifyComponent (dwChangeFlag, pncc);

    // Assume we won't be dirty as a result of this notification.
    //
    hr = S_FALSE;

    if (!m_fUpdateRouterConfiguration)
    {
        // If we're being called for a change to a net device, make sure
        // its physical before deciding we need to update our configuration.
        //
        GUID guidClass;
        hr = pncc->GetClassGuid (&guidClass);
        if (S_OK == hr)
        {
            if (GUID_DEVCLASS_NET == guidClass)
            {
                hr = HrShouldRouteOverAdapter (pncc, NULL);
                if (S_OK == hr)
                {
                    TraceTag (ttidRasCfg, "CSteelhead::SysNotifyComponent: "
                        "called for adapter install/remove.");

                    m_fUpdateRouterConfiguration = TRUE;
                    Assert (S_OK == hr);
                }
            }
            else
            {
                TraceTag (ttidRasCfg, "CSteelhead::SysNotifyComponent: "
                    "called for protocol add/remove/change.");

                // If we're called for non-net devices, we want to
                // update our configuration.  (GetSupportedNotifications
                // controls how often we fall into this.)
                //
                m_fUpdateRouterConfiguration = TRUE;
                Assert (S_OK == hr);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CSteelhead::SysNotifyComponent", hr);
    return hr;
}


#if (WINVER >= 0x0501)
//+---------------------------------------------------------------------------
//
//  Member :    InitializeDialInRestriction
//
//  Purpose:    Checks if the upgrade is to the enterprise or datacenter
//              edition of server.  If so there is no restriction on the
//              number of dialin ports.  Otherwise the max number should
//              be restricted to a 100.
//
//  Arguments:
//
//  Returns:    TRUE if dailin restriction is required, false otherwise
//
//  Author:     vraman, 30 August 2002
//
//  Notes:
//


BOOL 
InitializeDialInRestriction()
{
    OSVERSIONINFOEX osvi;
    ULONGLONG ConditionMask;
    BOOL bRestrictDialIn = TRUE;

    //
    // if its a server and the flavour is not Enterprise (ads) or DataCenter
    // apply the restriction. Note his doesn't take care of various other
    // combinations like embedded/blade, etc.
    //

    ConditionMask = 0;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.wProductType        = (USHORT)VER_NT_SERVER;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);

    if(VerifyVersionInfo(&osvi, VER_PRODUCT_TYPE, ConditionMask))
    {
        //
        // Upgrade is to a server version
        //
        
        ConditionMask = 0;
        ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osvi.wSuiteMask          = VER_SUITE_ENTERPRISE 
                                 | VER_SUITE_DATACENTER
                                 | VER_SUITE_SECURITY_APPLIANCE;
            
        VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);

        if(VerifyVersionInfo(&osvi, VER_SUITENAME, ConditionMask))
        {
            //
            // Upgrade is to a enterprise or datacenter edition
            //  Do not restrict server edition
            //
            
            bRestrictDialIn = FALSE;
        }
    }

    return bRestrictDialIn;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\rascfg\rassrv.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S S R V . C P P
//
//  Contents:   Implementation of RAS Server configuration object.
//
//  Notes:
//
//  Author:     shaunco   21 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncreg.h>
#include <mprapip.h>
#include "rasobj.h"
#include "ncnetcfg.h"


extern const WCHAR c_szInfId_MS_Steelhead[];

//+---------------------------------------------------------------------------
// HrMprConfigServerUnattendedInstall
//
// This function dynamically links to the mprsnap.dll and calls the
// utility function for unattended install of RAS/Routing.
//

typedef HRESULT (APIENTRY *PFNMPRINSTALL)(PCWSTR, BOOL);
typedef DWORD (APIENTRY *PFSETPORTUSAGE)(IN DWORD dwUsage);
const WCHAR g_pszNotificationPackages[] = L"Notification Packages";

HRESULT HrMprConfigServerUnattendedInstall(PCWSTR pszServer, BOOL fInstall)
{
    HINSTANCE   hLib = NULL;
    PFNMPRINSTALL   pMprConfigServerUnattendedInstall = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwErr;

    hLib = LoadLibrary(L"mprsnap.dll");
    if (hLib == NULL)
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
    }

    if (SUCCEEDED(hr))
    {
        pMprConfigServerUnattendedInstall = (PFNMPRINSTALL) GetProcAddress(hLib,
            "MprConfigServerUnattendedInstall");
        if (pMprConfigServerUnattendedInstall == NULL)
        {
            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32( dwErr );
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = pMprConfigServerUnattendedInstall(pszServer, fInstall);
    }

    if (hLib)
    {
        FreeLibrary(hLib);
    }

    TraceError("HrMprConfigServerUnattendedInstall", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// HrSetUsageOnAllRasPorts
//
// This function dynamically links to rtrupg.dll and calls the
// utility function for setting port usage.
//

HRESULT HrSetUsageOnAllRasPorts(IN DWORD dwUsage)
{
    HINSTANCE   hLib = NULL;
    PFSETPORTUSAGE pSetPortUsage = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwErr;

    hLib = ::LoadLibrary(L"mprapi.dll");
    if (hLib == NULL)
    {
        dwErr = ::GetLastError();
        hr = HRESULT_FROM_WIN32( dwErr );
    }

    if (SUCCEEDED(hr))
    {
        pSetPortUsage = (PFSETPORTUSAGE) ::GetProcAddress(hLib,
            "MprPortSetUsage");
        if (pSetPortUsage == NULL)
        {
            dwErr = ::GetLastError();
            hr = HRESULT_FROM_WIN32( dwErr );
        }
    }

    if (SUCCEEDED(hr))
        hr = pSetPortUsage(dwUsage);

    if (hLib)
        ::FreeLibrary(hLib);

    TraceError("HrSetUsageOnAllRasPorts", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// HrSetLsaNotificationPackage
//
// Installs the given package as an LSA notification package if it is not
// already installed.
//

HRESULT
HrSetLsaNotificationPackage(
    IN PWCHAR pszPackage)
{
    HRESULT hr = S_OK;
    HKEY hkLsa = NULL;
    DWORD dwErr = NO_ERROR, dwType, dwSize, dwLen, dwTotalLen;
    WCHAR pszPackageList[1024];
    PWCHAR pszCur = NULL;
    BOOL bFound = FALSE;
    
    do
    {
        // Open the Lsa key
        //
        hr = HrRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Control\\Lsa",
                KEY_ALL_ACCESS,
                &hkLsa);
        if (FAILED(hr))
        {
            break;
        }

        // Query the value for the notification packages
        //
        dwType = REG_MULTI_SZ;
        dwSize = sizeof(pszPackageList);
        hr = HrRegQueryValueEx(
                hkLsa,
                g_pszNotificationPackages,
                &dwType,
                (LPBYTE)pszPackageList,
                &dwSize);
        if (FAILED(hr))
        {
            break;
        }

        // See if the given package is already installed
        //
        pszCur = (PWCHAR)pszPackageList;
        dwTotalLen = 0;
        while (*pszCur)
        {
            if (lstrcmpi(pszCur, pszPackage) == 0)
            {
                bFound = TRUE;
            }
            dwLen = (wcslen(pszCur) + 1);
            pszCur += dwLen;
            dwTotalLen += dwLen;
        }

        // If the package isn't already installed, add it.
        //
        if (!bFound)
        {
            dwLen = wcslen(pszPackage) + 1;
            wcscpy(pszCur, pszPackage);
            pszCur[dwLen] = L'\0';
            dwTotalLen += (dwLen + 1);

            hr = HrRegSetValueEx(
                    hkLsa,
                    g_pszNotificationPackages,
                    REG_MULTI_SZ,
                    (CONST BYTE*)pszPackageList,
                    dwTotalLen * sizeof(WCHAR));
            if (FAILED(hr))
            {
                break;
            }
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hkLsa)
        {
            RegCloseKey(hkLsa);
        }
    }

    return hr;
}

CRasSrv::CRasSrv () : CRasBindObject ()
{
    m_pnccMe            = NULL;
    m_fRemoving         = FALSE;
    m_fNt4ServerUpgrade = FALSE;
    m_fSaveAfData       = FALSE;
}

CRasSrv::~CRasSrv ()
{
    ReleaseObj (m_pnccMe);
}


//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
STDMETHODIMP
CRasSrv::Initialize (
        INetCfgComponent*   pncc,
        INetCfg*            pnc,
        BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize (pncc, pnc, fInstalling);

    // Hold on to our the component representing us and our host
    // INetCfg object.
    AddRefObj (m_pnccMe = pncc);
    AddRefObj (m_pnc = pnc);

    m_fInstalling = fInstalling;

    return S_OK;
}

STDMETHODIMP
CRasSrv::Validate ()
{
    return S_OK;
}

STDMETHODIMP
CRasSrv::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP
CRasSrv::ApplyRegistryChanges ()
{
    if (!m_fRemoving)
    {
        if (m_fSaveAfData)
        {
            m_AfData.SaveToRegistry ();
            m_fSaveAfData = FALSE;

            if (m_AfData.m_fRouterTypeSpecified)
            {
                HRESULT hr = HrMprConfigServerUnattendedInstall(NULL, TRUE);
                TraceError("CRasSrv::ApplyRegistryChanges unattend inst (ignoring)", hr);

                if (m_AfData.m_dataSrvCfg.dwRouterType & 4)
                {
                    hr = HrSetUsageOnAllRasPorts(MPRFLAG_PORT_Router);
                    TraceError("CRasSrv::ApplyRegistryChanges set router usage (ignoring)", hr);
                }
            }

            // pmay: 251736
            //
            // On NTS, we set all usage to dialin
            //
            if (m_fNt4ServerUpgrade)
            {
                HRESULT hr = HrSetUsageOnAllRasPorts(MPRFLAG_PORT_Dialin);
                TraceError("CRasSrv::ApplyRegistryChanges set dialin usage (ignoring)", hr);
            }

            // On professional, we set non-vpn port usage to to dialin if 
            // a flag in the af tells us to do so.
            //
            else if (m_AfData.m_fSetUsageToDialin)
            {
                HRESULT hr = HrSetUsageOnAllRasPorts(MPRFLAG_PORT_NonVpnDialin);
                TraceError("CRasSrv::ApplyRegistryChanges set dialin usage (ignoring)", hr);
            }
        }

        if (m_fInstalling)
        {
            NT_PRODUCT_TYPE ProductType;

            if (RtlGetNtProductType (&ProductType))
            {
                // Upgrade local RAS user objects.  Do not do this if we are
                // a domain controller as local RAS user objects translates to
                // all domain users.  For the domain controller case, Dcpromo
                // handles upgrading the objects in a much more efficient
                // manner.
                //
                if (NtProductLanManNt != ProductType)
                {
                    DWORD dwErr = MprAdminUpgradeUsers (NULL, TRUE);
                    TraceError ("MprAdminUpgradeUsers", HRESULT_FROM_WIN32(dwErr));
                }

                // pmay: 407019
                //
                // Make sure that rassfm is installed as a notification package on all 
                // flavors of nt servers
                //
                if ((NtProductServer == ProductType) || (NtProductLanManNt == ProductType))
                {
                    HRESULT hr = HrSetLsaNotificationPackage(L"RASSFM");
                    TraceError("CRasSrv::ApplyRegistryChanges set lsa not package usage (ignoring)", hr);
                }
            }
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
// INetCfgComponentSetup
//
STDMETHODIMP
CRasSrv::ReadAnswerFile (
        PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    Validate_INetCfgNotify_ReadAnswerFile (pszAnswerFile, pszAnswerSection);

    // Read data from the answer file.
    // Don't let this affect the HRESULT we return.
    //
    if (SUCCEEDED(m_AfData.HrOpenAndRead (pszAnswerFile, pszAnswerSection)))
    {
        m_fSaveAfData = TRUE;
    }

    return S_OK;
}

STDMETHODIMP
CRasSrv::Install (DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    if (NSF_WINNT_SVR_UPGRADE & dwSetupFlags)
    {
        m_fNt4ServerUpgrade = TRUE;
    }

    // Install Steelhead.
    //
    hr = HrInstallComponentOboComponent (m_pnc, NULL,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_Steelhead,
            m_pnccMe,
            NULL);

    TraceHr (ttidError, FAL, hr, FALSE, "CRasSrv::Install");
    return hr;
}

STDMETHODIMP
CRasSrv::Removing ()
{
    HRESULT hr;

    m_fRemoving = TRUE;

    // Remove Steelhead.
    //
    hr = HrRemoveComponentOboComponent (m_pnc,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_Steelhead,
            m_pnccMe);

    TraceHr (ttidError, FAL, hr, FALSE, "CRasSrv::Removing");
    return hr;
}

STDMETHODIMP
CRasSrv::Upgrade (
    DWORD dwSetupFlags,
    DWORD dwUpgradeFromBuildNo)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\sapcfg\sapobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S A P O B J . C P P
//
//  Contents:   Implementation of the CSAPCfg notify object
//
//  Notes:
//
//  Author:     jeffspr   31 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "sapobj.h"
#include "ncreg.h"

extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szRegKeyRefCounts[];
extern const WCHAR c_szRegValueComponentId[];

const WCHAR c_szProtoPath[] = L"System\\CurrentControlSet\\Control\\Network\\{4D36E975-E325-11CE-BFC1-08002BE10318}";
const WCHAR c_szOcSapRef[] = L"%Msft%nwsapagent";

CSAPCfg::CSAPCfg()
{
    m_pnc   = NULL;
    m_pncc  = NULL;
}

CSAPCfg::~CSAPCfg()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);
}


STDMETHODIMP
CSAPCfg::Initialize (
    INetCfgComponent*   pnccItem,
    INetCfg*            pnc,
    BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "m_pncc NULL in CSAPCfg::Initialize");
    AssertSz(m_pnc, "m_pnc NULL in CSAPCfg::Initialize");

    // Addref the config objects
    //
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    return S_OK;
}

STDMETHODIMP
CSAPCfg::Validate()
{
    return S_OK;
}

STDMETHODIMP
CSAPCfg::CancelChanges()
{
    return S_OK;
}

STDMETHODIMP
CSAPCfg::ApplyRegistryChanges()
{
    return S_OK;
}

STDMETHODIMP
CSAPCfg::ReadAnswerFile (
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP
CSAPCfg::Upgrade(DWORD, DWORD)
{
    // Raid 266650 - Need to clean up the registry as in Beta 2 SAP was an optional component.
    //               Cleanup is done by deleting the NetOC OBO Install ref-count on IPX.
    //
    HRESULT hr;
    HKEY    hkeyProto;

    // Open the protocol list
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szProtoPath, KEY_ALL_ACCESS, &hkeyProto);
    if (SUCCEEDED(hr))
    {
        BOOL        fDone = FALSE;
        WCHAR       szValueName [_MAX_PATH];
        DWORD       cchBuffSize = _MAX_PATH;
        FILETIME    ft;
        DWORD       dwKeyIndex = 0;

        // Enum the keys children, search for ms_nwipx
        //
        while (SUCCEEDED(hr = HrRegEnumKeyEx(hkeyProto, dwKeyIndex, szValueName,
                                             &cchBuffSize, NULL, NULL, &ft)) &&
               !fDone)
        {
            HKEY hkeyComponent;

            // Open the key that was enumerated
            //
            hr = HrRegOpenKeyEx(hkeyProto, szValueName, KEY_ALL_ACCESS, &hkeyComponent);
            if (SUCCEEDED(hr))
            {
                tstring str;

                // Is this ms_nwipx?
                //
                hr = HrRegQueryString(hkeyComponent, c_szRegValueComponentId, &str);
                if (SUCCEEDED(hr) && (0 == _wcsicmp(str.c_str(), c_szInfId_MS_NWIPX)))
                {
                    HKEY hkeyRefCounts;

                    // Open the "RefCounts" subkey
                    //
                    hr = HrRegOpenKeyEx(hkeyComponent, c_szRegKeyRefCounts,
                                        KEY_ALL_ACCESS, &hkeyRefCounts);
                    if (SUCCEEDED(hr))
                    {
                        // Enumerate the values under here searching for %Msft%nwsapagent
                        //
                        for (DWORD dwIndex = 0; SUCCEEDED(hr); dwIndex++)
                        {
                            WCHAR pszValueName [_MAX_PATH];
                            DWORD cchValueName = celems (pszValueName);
                            DWORD dwType;
                            DWORD dwRefCount = 0;
                            DWORD cbData = sizeof (dwRefCount);

                            hr = HrRegEnumValue (hkeyRefCounts, dwIndex,
                                                 pszValueName, &cchValueName,
                                                 &dwType, (LPBYTE)&dwRefCount, &cbData);
                            if (SUCCEEDED(hr) && (0 == _wcsicmp(pszValueName, c_szOcSapRef)))
                            {
                                // Delete the value and exit the loop
                                //
                                hr = HrRegDeleteValue (hkeyRefCounts, pszValueName);
                                break;
                            }
                        }

                        RegCloseKey(hkeyRefCounts);
                    }

                    fDone = TRUE;
                }

                RegCloseKey(hkeyComponent);
            }

            cchBuffSize = _MAX_PATH;
            dwKeyIndex++;
        }

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkeyProto);
    }


    return S_OK;
}

STDMETHODIMP
CSAPCfg::Install (
    DWORD   dw)
{
    Validate_INetCfgNotify_Install(dw);

    // Install IPX
    //
    HRESULT hr = HrInstallComponentOboComponent(m_pnc, NULL,
                    GUID_DEVCLASS_NETTRANS,
                    c_szInfId_MS_NWIPX,
                    m_pncc, NULL);

    TraceError("CSAPCfg::Install", hr);
    return hr;
}

STDMETHODIMP
CSAPCfg::Removing()
{
    // Remove IPX
    //
    HRESULT hr = HrRemoveComponentOboComponent (m_pnc,
                    GUID_DEVCLASS_NETTRANS,
                    c_szInfId_MS_NWIPX,
                    m_pncc);

    // Normalize the HRESULT. (NETCFG_S_STILL_REFERENCED or NETCFG_S_REBOOT
    // may have been returned.)
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    Validate_INetCfgNotify_Removing_Return (hr);

    TraceError ("CSAPCfg::Removing", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\srvrcfg\resource.h ===
#include <ncres.h>

#define DLG_ServerConfig                2200

#define CHK_Announce                    200
#define RDB_Balance                     201
#define RDB_FileSharing                 202
#define RDB_Minimize                    203
#define RDB_NetApps                     204
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\srvrcfg\confgdlg.cpp ===
//
// C O N F G D L G . C P P
//
// Dialog box handling for Server configuration
//
// Author:  danielwe
// Created: 5 Mar 1997
//

#include "pch.h"
#pragma hdrstop

#include "resource.h"
#include "srvrdlg.h"
#include "srvrhlp.h"

extern const WCHAR c_szNetCfgHelpFile[];

LRESULT CServerConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& bHandled)
{
    const SERVER_DLG_DATA * psdd;
    INT                     idd = 0;

    psdd = m_psc->DlgData();
    Assert(psdd);

    switch (psdd->dwSize)
    {
    case 1:
        idd = RDB_Minimize;
        break;
    case 2:
        idd = RDB_Balance;
        break;
    case 3:
        if (psdd->fLargeCache)
        {
            idd = RDB_FileSharing;
        }
        else
        {
            idd = RDB_NetApps;
        }
        break;
    default:
        AssertSz(FALSE, "Invalid Size parameter!");
        break;
    }

    CheckDlgButton(idd, TRUE);
    CheckDlgButton(CHK_Announce, psdd->fAnnounce);

    return TRUE;
}

LRESULT CServerConfigDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    SERVER_DLG_DATA *   psdd;
    static const INT aidd[] =
    {
        RDB_Minimize,
        RDB_Balance,
        RDB_FileSharing,
        RDB_NetApps,
    };
    static const INT cidd = celems(aidd);
    INT         iidd;

    psdd = m_psc->DlgDataRW();
    Assert(psdd);

    // figure out which radio button was selected
    for (iidd = 0; iidd < cidd; iidd++)
    {
        if (IsDlgButtonChecked(aidd[iidd]))
            break;
    }

    AssertSz(iidd < cidd, "Umm. How could a button NOT be selected??");

    // make it 1-based instead of 0-based
    iidd++;

    psdd->fLargeCache = (iidd == 3);
    psdd->dwSize = min(iidd, 3);
    psdd->fAnnounce = IsDlgButtonChecked(CHK_Announce);
    m_psc->SetDirty();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method: CServerConfigDlg::OnContextMenu
//
//  Desc:   Bring up context-sensitive help
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
LRESULT
CServerConfigDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (g_aHelpIDs_DLG_ServerConfig != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)g_aHelpIDs_DLG_ServerConfig);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method: CServerConfigDlg::OnHelp
//
//  Desc:   Bring up context-sensitive help when dragging ? icon over a control
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
//
LRESULT
CServerConfigDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((g_aHelpIDs_DLG_ServerConfig != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_DLG_ServerConfig);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\sapcfg\sapobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S A P O B J . H
//
//  Contents:   Declaration of SAP Agent configuration object.
//
//  Notes:
//
//  Author:     jeffspr   31 May 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"


class ATL_NO_VTABLE CSAPCfg :
    public CComObjectRoot,
    public CComCoClass<CSAPCfg, &CLSID_CSAPCfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
public:
    CSAPCfg();
    ~CSAPCfg();

    BEGIN_COM_MAP(CSAPCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CSAPCfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_SAPCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Upgrade)             (DWORD,DWORD);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

// Private state info
private:
    INetCfgComponent *  m_pncc;             // Place to keep my component
    INetCfg *           m_pnc;              // Place to keep my component
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\srvrcfg\srvrhlp.h ===
//This file is used by srvrcfg.rc
//
// Generated by Melissa Simmons, 4-6-99

#define IDH_CHK_Announce 80000104
#define IDH_RDB_Balance 80000101
#define IDH_RDB_FileSharing 80000102
#define IDH_RDB_Minimize 80000100
#define IDH_RDB_NetApps 80000103
#define IDH_DISABLEHELP ((DWORD)-1)



const DWORD g_aHelpIDs_DLG_ServerConfig[]=
{
	IDC_STATIC, IDH_DISABLEHELP,
	CHK_Announce,IDH_CHK_Announce,
	RDB_NetApps,IDH_RDB_NetApps,
	RDB_FileSharing,IDH_RDB_FileSharing,
	RDB_Balance,IDH_RDB_Balance,
	RDB_Minimize,IDH_RDB_Minimize,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\srvrcfg\srvrdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S R V R D L G . H
//
//  Contents:   Dialog box handling for the Server object.
//
//  Notes:
//
//  Author:     danielwe   5 Mar 1997
//
//----------------------------------------------------------------------------

#ifndef _SRVRDLG_H
#define _SRVRDLG_H
#pragma once
#include "srvrobj.h"

//
// Server Configuration Dialog
//
class CServerConfigDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CServerConfigDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(RDB_Minimize, OnChange)
        COMMAND_ID_HANDLER(RDB_Balance, OnChange)
        COMMAND_ID_HANDLER(RDB_FileSharing, OnChange)
        COMMAND_ID_HANDLER(RDB_NetApps, OnChange)
        COMMAND_ID_HANDLER(CHK_Announce, OnChange)
    END_MSG_MAP()

    CServerConfigDlg(CSrvrcfg *psc): m_psc(psc) {}

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& Handled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);                        
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnChange(WORD wNotifyCode, WORD wID,
                    HWND hWndCtl, BOOL& bHandled)
    {
        // Simply tell the page changes were made
        SetChangedFlag();
        return 0;
    }

private:
    CSrvrcfg *m_psc;
};

#endif //!_SRVRDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\srvrcfg\srvrobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S R V R O B J . C P P
//
//  Contents:   Implementation of CSrvrcfg and helper functions.
//
//  Notes:
//
//  Author:     danielwe   5 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "srvrobj.h"
#include "ncerror.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "afilestr.h"

static const WCHAR c_szRegKeyServerParams[]     = L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
static const WCHAR c_szRegKeyServerShares[]     = L"System\\CurrentControlSet\\Services\\LanmanServer\\Shares";
static const WCHAR c_szRegKeyServerAutoTuned[]  = L"System\\CurrentControlSet\\Services\\LanmanServer\\AutotunedParameters";

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::CSrvrcfg
//
//  Purpose:    Constructs the CSrvrcfg object.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
CSrvrcfg::CSrvrcfg()
:
    m_hkeyMM(NULL),
    m_fDirty(FALSE),
    m_pncc(NULL),
    m_fOneTimeInstall(FALSE),
    m_fRestoredRegistry(FALSE),
    m_fUpgradeFromWks(FALSE),
    m_fUpgrade(FALSE)
{
    ZeroMemory(&m_apspObj, sizeof(m_apspObj));
    ZeroMemory(&m_sdd, sizeof(m_sdd));
}

//
// INetCfgComponentControl
//

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::Initialize
//
//  Purpose:    Called when we are initialized.
//
//  Arguments:
//      pnccItem    [in]    Component we belong to.
//      pnc         [in]    INetCfg master object if we need it.
//      fInstalling [in]    TRUE if we are being installed, FALSE otherwise.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   22 Mar 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::Initialize(INetCfgComponent* pnccItem, INetCfg *pnc,
                                  BOOL fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    AddRefObj(m_pncc);
    GetProductFlavor(NULL, &m_pf);

    HRESULT hr = HrOpenRegKeys(pnc);
    if (SUCCEEDED(hr))
    {
        hr = HrGetRegistryInfo(fInstalling);
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CSrvrcfg::Initialize", hr);
    return hr;
}

STDMETHODIMP CSrvrcfg::Validate()
{
    return S_OK;
}

STDMETHODIMP CSrvrcfg::CancelChanges()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::Apply
//
//  Purpose:    Called when changes to this component should be applied.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::ApplyRegistryChanges()
{
    HRESULT     hr = S_OK;

    static const WCHAR c_szLicenseSvc[] = L"LicenseService";

    if (m_fUpgrade)
    {
        TraceTag(ttidSrvrCfg, "Upgrading MS_SERVER");

        if (!m_fRestoredRegistry)
        {
            TraceTag(ttidSrvrCfg, "Restoring registry");

            hr = HrRestoreRegistry();
            if (FAILED(hr))
            {
                TraceError("CSrvrcfg::ApplyRegistryChanges - HrRestoreRegistry - non-fatal",
                           hr);
                hr = S_OK;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        if (m_fDirty)
        {
            hr = HrSetRegistryInfo();
        }

        if (SUCCEEDED(hr))
        {
            if (m_fOneTimeInstall)
            {
/*
                hr = HrChangeServiceStartTypeOptional(c_szLicenseSvc,
                                                      SERVICE_AUTO_START);
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;

                    m_fDirty = FALSE;
                    m_fOneTimeInstall = FALSE;
                }
*/
            }
        }
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CSrvrcfg::ApplyRegistryChanges",
        (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//
// INetCfgComponentSetup
//

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::Install
//
//  Purpose:    Called when this component is being installed
//
//  Arguments:
//      dwSetupFlags [in]   Flags that describe the type of setup
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::Install(DWORD dwSetupFlags)
{
    m_fDirty = TRUE;
    m_fOneTimeInstall = TRUE;

    if (dwSetupFlags & NSF_WINNT_WKS_UPGRADE)
    {
        m_fUpgrade = TRUE;
        m_fUpgradeFromWks = TRUE;
    }
    else if ((dwSetupFlags & NSF_WINNT_SVR_UPGRADE) ||
             (dwSetupFlags & NSF_WINNT_SBS_UPGRADE))
    {
        m_fUpgrade = TRUE;
    }

    return S_OK;
}

STDMETHODIMP CSrvrcfg::Upgrade(DWORD dwSetupFlags,
                               DWORD dwUpgradeFomBuildNo)
{
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::ReadAnswerFile
//
//  Purpose:    Reads the appropriate fields from the given answer file into
//              our in-memory state.
//
//  Arguments:
//      pszAnswerFile     [in] File name of answer file
//      pszAnswerSection [in] Section of answer file to look in
//
//  Returns:    S_OK if successful, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::ReadAnswerFile(PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection)
{
    HRESULT     hr = S_OK;

    if (pszAnswerSection && pszAnswerFile)
    {
        // There's an answer file. We must process it now.
        hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
        if (FAILED(hr))
        {
            TraceError("CSrvrcfg::ReadAnswerFile- Answer file has "
                       "errors. Defaulting all information as if "
                       "answer file did not exist.",
                       NETSETUP_E_ANS_FILE_ERROR);
            hr = S_OK;
        }
    }

    TraceError("CSrvrcfg::ReadAnswerFile", hr);
    return hr;
}

STDMETHODIMP CSrvrcfg::Removing()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrRestoreRegistry
//
//  Purpose:    Restores the contents of the registry for this component
//
//  Arguments:
//      (none)
//
//  Returns:    Win32 error if failed, otherwise S_OK
//
//  Author:     danielwe   8 Aug 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrRestoreRegistry()
{
    HRESULT             hr = S_OK;
    HKEY                hkey;
    TOKEN_PRIVILEGES *  ptpRestore = NULL;
    BOOL                fRestoreSucceeded = FALSE;

    if (!m_strParamsRestoreFile.empty() ||
        !m_strSharesRestoreFile.empty() ||
        !m_strAutoTunedRestoreFile.empty())
    {
        hr = HrEnableAllPrivileges(&ptpRestore);
        if (SUCCEEDED(hr))
        {
            if (!m_strParamsRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServerParams,
                                      KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey, m_strParamsRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CSrvrcfg::HrRestoreRegistry - HrRestoreRegistry for "
                                   "Parameters", hr);
                        hr = S_OK;
                    }
                    else
                    {
                        fRestoreSucceeded = TRUE;

                    }

                    RegCloseKey(hkey);
                }
            }

            if (fRestoreSucceeded)
            {
                // if the restore succeeded, rewrite the values that were blown
                // away by the restore

                static const WCHAR c_szSvcDLLName[]     = L"%SystemRoot%\\System32\\srvsvc.dll";
                static const WCHAR c_szServiceDll[]     = L"ServiceDll";

                HKEY hkResult = NULL;
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServerParams, KEY_ALL_ACCESS, &hkResult);
                if SUCCEEDED(hr)
                {
                    hr = HrRegSetValueEx(hkResult, c_szServiceDll, REG_EXPAND_SZ, (const BYTE *)c_szSvcDLLName, CbOfMultiSzAndTermSafe(c_szSvcDLLName));
                }

                if FAILED(hr)
                {
                    TraceError("CSrvrcfg::HrRestoreRegistry - HrRestoreRegistry for "
                            "ServiceDll", hr);
                    hr = S_OK;
                }

				//
				// The following key has to be set here because of new changes introduced
				// by SCE (Security Configuration Engine). SCE runs early in GUI mode setup to 
				// set out-of-the-box security by setting some registry values. During NT4 
				// upgrades we don't see those registry values set because during NT4 upgrades, 
				// some services including Lanmanserver and Netlogon gets deleted and reinstalled 
				// for PnP requirements. To maintain the services configuration between deleting 
				// and reinstalling, some of their Keys including the "Parameters" keys for 
				// LanManServer and Netlogon get backed up early during upgrade and restored 
				// later with the service installation. This backing up and restoring action 
				// happens through the services own notify objects (like this one). The problem 
				// is, backing up of the Keys happens before SCE sets the values in those keys and
				// they get restored after SCE sets the values. So we lose the values set. So, we 
				// are setting those keys here separately to the secure values.
				// See Windows Raid bug #691952 for more details.
				//

				static const WCHAR  c_szRestrictNullSessAccess[]  = L"RestrictNullSessAccess";
				DWORD				value = 1;
				
				hr = HrRegSetValueEx(hkey, c_szRestrictNullSessAccess, REG_DWORD, (const BYTE *)&value, 4);

				if (FAILED(hr)) 
				{
					TraceError("CSrvrcfg::HrRestoreRegistry - setting RestrictNullSessAccess to DWORD 1 failed", hr);
					hr = S_OK;
				}
				
				RegSafeCloseKey(hkResult);
                
				static const WCHAR c_szTrkWks[]         = L"TrkWks";
                static const WCHAR c_szTrkSrv[]         = L"TrkSrv";
                static const WCHAR c_szNullSession[]    = L"NullSessionPipes";

                hr = HrRegAddStringToMultiSz(c_szTrkWks,
                                             HKEY_LOCAL_MACHINE,
                                             c_szRegKeyServerParams,
                                             c_szNullSession,
                                             STRING_FLAG_ENSURE_AT_END,
                                             0);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegAddStringToMultiSz(c_szTrkSrv,
                                                 HKEY_LOCAL_MACHINE,
                                                 c_szRegKeyServerParams,
                                                 c_szNullSession,
                                                 STRING_FLAG_ENSURE_AT_END,
                                                 0);
                }

                if (FAILED(hr))
                {
                    TraceError("CSrvrcfg::HrRestoreRegistry - Error replacing "
                               "values for Parameters", hr);
                    hr = S_OK;
                }
            }

            if (!m_strSharesRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServerShares,
                                    KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey, m_strSharesRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CSrvrcfg::HrRestoreRegistry - HrRestoreRegistry for "
                                   "Shares", hr);
                        hr = S_OK;
                    }

                    RegCloseKey(hkey);
                }
            }

            if (!m_strAutoTunedRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyServerAutoTuned,
                                    KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey, m_strAutoTunedRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CSrvrcfg::HrRestoreRegistry - HrRestoreRegistry for "
                                   "AutotunedParameters", hr);
                        hr = S_OK;
                    }

                    RegCloseKey(hkey);
                }
            }

            hr = HrRestorePrivileges(ptpRestore);

            delete [] reinterpret_cast<BYTE *>(ptpRestore);

            // Set a flag so we don't do this again if we are applied again
            m_fRestoredRegistry = TRUE;
        }
    }
    else
    {
        TraceTag(ttidSrvrCfg, "WARNING: HrRestoreRegistry() was called without"
                 " ReadAnswerFile() being called!");
    }

    TraceError("CSrvrcfg::HrRestoreRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrProcessAnswerFile
//
//  Purpose:    Handles necessary processing of contents of the answer file.
//
//  Arguments:
//      pszAnswerFile       [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Comma-separated list of sections in the
//                                  file appropriate to this component.
//
//  Returns:    S_OK if successful, setup API error otherwise.
//
//  Author:     danielwe   8 May 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection)
{
    HRESULT         hr = S_OK;
    tstring         strOpt;
    PCWSTR         szOptDefault;
    CSetupInfFile   csif;

    if (m_pf == PF_SERVER)
    {
        szOptDefault = c_szAfMaxthroughputforfilesharing;
    }
    else
    {
        szOptDefault = c_szAfMinmemoryused;
    }

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        hr = S_OK;
        goto err;
    }

    if (m_fUpgrade)
    {
        // Restore portions of the registry based on file names from the answer
        // file

        // Get restore file for "Parameters" key
        hr = csif.HrGetString(pszAnswerSection, c_szAfLmServerParameters,
                              &m_strParamsRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CSrvrcfg::HrProcessAnswerFile - Error restoring "
                       "Parameters key", hr);

            // oh well, just continue
            hr = S_OK;
        }

        // Get restore file for "Shares" key
        hr = csif.HrGetString(pszAnswerSection, c_szAfLmServerShares,
                              &m_strSharesRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CSrvrcfg::HrProcessAnswerFile - Error restoring "
                       "Shares key", hr);

            // oh well, just continue
            hr = S_OK;
        }

        // Get restore file for "AutotunedParameters" key
        hr = csif.HrGetString(pszAnswerSection,
                              c_szAfLmServerAutotunedParameters,
                              &m_strAutoTunedRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CSrvrcfg::HrProcessAnswerFile - Error restoring "
                       "AutotunedParameters key", hr);

            // oh well, just continue
            hr = S_OK;
        }
    }

    // Read contents Opimitzation key
    hr = csif.HrGetString(pszAnswerSection, c_szAfLmServerOptimization,
                          &strOpt);
    if (SUCCEEDED(hr))
    {
		m_fDirty = TRUE;

        if (!lstrcmpiW(strOpt.c_str(), c_szAfMinmemoryused))
        {
            m_sdd.dwSize = 1;
        }
        else if (!lstrcmpiW(strOpt.c_str(), c_szAfBalance))
        {
            m_sdd.dwSize = 2;
        }
        else if (!lstrcmpiW(strOpt.c_str(), c_szAfMaxthroughputforfilesharing))
        {
            m_sdd.dwSize = 3;
            m_sdd.fLargeCache = TRUE;
        }
        else if (!lstrcmpiW(strOpt.c_str(), c_szAfMaxthrouputfornetworkapps))
        {
            m_sdd.dwSize = 3;
            m_sdd.fLargeCache = FALSE;
        }
#ifdef DBG
        else
        {
            // NOTE: Default values for dwSize and fLargeCache will have been set
            // already by registry reading function.

            TraceTag(ttidSrvrCfg, "Unknown Optimization value '%S'. Using default "
                     "'%S'.", strOpt.c_str(), szOptDefault);
        }
#endif
    }

    // Read contents of BroadcastsToLanman2Clients key.
    hr = csif.HrGetStringAsBool(pszAnswerSection, c_szAfBroadcastToClients,
                                &m_sdd.fAnnounce);
    if (FAILED(hr))
    {
        TraceError("CSrvrcfg::HrProcessAnswerFile - Error restoring "
                   "BroadcastsToLanman2Clients key. Using default value"
                   " of FALSE.", hr);

        // oh well, just continue
        hr = S_OK;
    }

err:
    TraceError("CSrvrcfg::HrProcessAnswerFile", hr);
    return hr;
}

//
// INetCfgProperties
//

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::MergePropPages
//
//  Purpose:    Called when this component's properties are about to be
//              brought up.
//
//  Arguments:
//      pdwDefPages   [out] Number of default pages to show.
//      pahpspPrivate [out] Array of property sheet handles to pages that this
//                          component will show.
//      pcPrivate     [out] Number of pages in array.
//      hwndParent    [in]  Parent window for any UI.
//      pszStartPage  [out] Pointer to start page.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
STDMETHODIMP CSrvrcfg::MergePropPages(DWORD *pdwDefPages,
                                      LPBYTE *pahpspPrivate,
                                      UINT *pcPrivate, HWND hwndParent,
                                      PCWSTR *pszStartPage)
{
    HRESULT         hr = S_OK;
    HPROPSHEETPAGE *ahpsp = NULL;

    Validate_INetCfgProperties_MergePropPages(pdwDefPages, pahpspPrivate,
                                              pcPrivate, hwndParent,
                                              pszStartPage);

    // We don't want any default pages to be shown
    *pdwDefPages = 0;

    if (m_pf == PF_WORKSTATION)
    {
        // On workstation product, UI is not shown.
        *pcPrivate = 0;
    }
    else
    {
        hr = HrSetupPropSheets(&ahpsp, c_cPages);
        if (SUCCEEDED(hr))
        {
            *pahpspPrivate = (LPBYTE)ahpsp;
            *pcPrivate = c_cPages;
        }
    }

    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CSrvrcfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CSrvrcfg::ValidateProperties(HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CSrvrcfg::CancelProperties()
{
    return S_OK;
}

STDMETHODIMP CSrvrcfg::ApplyProperties()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::~CSrvrcfg
//
//  Purpose:    Destroys the CSrvrcfg object.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
CSrvrcfg::~CSrvrcfg()
{
    ReleaseObj(m_pncc);

    RegSafeCloseKey(m_hkeyMM);

    CleanupPropPages();

#ifdef DBG
    {
        INT     ipage;

        for (ipage = 0; ipage < c_cPages; ipage++)
        {
            AssertSz(!m_apspObj[ipage], "Prop page object should be NULL!");
        }
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\srvrcfg\srvrobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S R V R O B J . H
//
//  Contents:   Declaration of CSrvrcfg and helper functions.
//
//  Notes:
//
//  Author:     danielwe   5 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <notifval.h>
#include "ncmisc.h"
#include "resource.h"

struct SERVER_DLG_DATA
{
    DWORD       dwSize;         // corresponds to Size value in registry
    BOOL        fAnnounce;      // corresponds to Lmannounce value
    BOOL        fLargeCache;    // LargeSystemCache in Control\SessionManager
                                // \MemoryManagement
};

/////////////////////////////////////////////////////////////////////////////
// Srvrcfg

class ATL_NO_VTABLE CSrvrcfg :
    public CComObjectRoot,
    public CComCoClass<CSrvrcfg, &CLSID_CSrvrcfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi
{
public:
    CSrvrcfg();
    ~CSrvrcfg();

    BEGIN_COM_MAP(CSrvrcfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CSrvrcfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_SRVRCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFomBuildNo);
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Removing)            ();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

    // Accessors for Server dialog data
    const SERVER_DLG_DATA *DlgData() const
        {return (const SERVER_DLG_DATA *)&m_sdd;};
    SERVER_DLG_DATA *DlgDataRW() {return &m_sdd;};
    VOID SetDirty() {m_fDirty = TRUE;};

    SERVER_DLG_DATA     m_sdd;

private:
    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection);
    HRESULT HrOpenRegKeys(INetCfg *);
    HRESULT HrGetRegistryInfo(BOOL fInstalling);
    HRESULT HrSetRegistryInfo(VOID);
    HRESULT HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages);
    VOID CleanupPropPages(VOID);
    HRESULT HrRestoreRegistry(VOID);

    INetCfgComponent    *m_pncc;            // Place to keep my component

    // number of property sheet pages
    enum PAGES
    {
        c_cPages = 1
    };

    // Generic dialog data
    CPropSheetPage *    m_apspObj[c_cPages];// pointer to each of the prop
                                            // sheet page objects
    BOOL                m_fDirty;

    HKEY                m_hkeyMM;           // Memory Management key
    BOOL                m_fOneTimeInstall;  // TRUE if we're in install mode
    BOOL                m_fUpgrade;         // TRUE if we are upgrading with
                                            // an answer file
    BOOL                m_fUpgradeFromWks;  // TRUE if we are upgrading from
                                            // workstation product
    BOOL                m_fRestoredRegistry;// TRUE if registry has been
                                            // restored on upgrade

    PRODUCT_FLAVOR      m_pf;

    tstring             m_strAutoTunedRestoreFile;
    tstring             m_strSharesRestoreFile;
    tstring             m_strParamsRestoreFile;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\srvrcfg\srvrdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S R V R D L G . C P P
//
//  Contents:   Dialog box handling for the Server object.
//
//  Notes:
//
//  Author:     danielwe   5 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "srvrdlg.h"
#include "ncreg.h"

static const WCHAR c_szServerParams[] = L"System\\CurrentControlSet\\Services\\LanmanServer\\Parameters";
static const WCHAR c_szLmAnnounce[] = L"Lmannounce";
static const WCHAR c_szSize[] = L"Size";
static const WCHAR c_szMemoryManagement[] = L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management";
static const WCHAR c_szLargeCache[] = L"LargeSystemCache";

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrSetupPropSheets
//
//  Purpose:    Inits the prop sheet page objects and creates the pages to be
//              returned to the installer object.
//
//  Arguments:
//      pahpsp [out]    Array of handles to property sheet pages.
//      cPages [in]     Number of pages.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages)
{
    HRESULT         hr = S_OK;
    HPROPSHEETPAGE *ahpsp = NULL;

    Assert(pahpsp);

    *pahpsp = NULL;

    // Allocate a buffer large enough to hold the handles to all of our
    // property pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                             * cPages);
    if (!ahpsp)
    {
        hr = E_OUTOFMEMORY;
        goto err;
    }

    if (!m_apspObj[0])
    {
        // Allocate each of the CPropSheetPage objects
        m_apspObj[0] = new CServerConfigDlg(this);
    }

    // Create the actual PROPSHEETPAGE for each object.
    ahpsp[0] = m_apspObj[0]->CreatePage(DLG_ServerConfig, 0);

    Assert(SUCCEEDED(hr));

    *pahpsp = ahpsp;

cleanup:
    TraceError("HrSetupPropSheets", hr);
    return hr;

err:
    CoTaskMemFree(ahpsp);
    goto cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::CleanupPropPages
//
//  Purpose:    Loop thru each of the pages and free the objects associated
//              with them.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
VOID CSrvrcfg::CleanupPropPages()
{
    INT     ipage;

    for (ipage = 0; ipage < c_cPages; ipage++)
    {
        delete m_apspObj[ipage];
        m_apspObj[ipage] = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrOpenRegKeys
//
//  Purpose:    Open the various registry keys we'll be working with for the
//              lifetime of our object.
//
//  Arguments:  pnc - An INetCfg interface
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrOpenRegKeys(INetCfg *pnc)
{
    HRESULT     hr = S_OK;

    hr = HrRegOpenKeyBestAccess(HKEY_LOCAL_MACHINE, c_szMemoryManagement,
                                &m_hkeyMM);
    if (FAILED(hr))
        goto err;

err:
    TraceError("CSrvrcfg::HrOpenRegKeys", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrGetRegistryInfo
//
//  Purpose:    Fill our in-memory state with data from the registry.
//
//  Arguments:
//      fInstalling [in]    TRUE if component is being installed, FALSE if
//                          it is just being initialized (already installed)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrGetRegistryInfo(BOOL fInstalling)
{
    HRESULT         hr = S_OK;
    HKEY            hkeyParams;

    // Set reasonable defaults in case the key is missing
    m_sdd.fAnnounce = FALSE;

    if (m_pf == PF_SERVER)
    {
        m_sdd.dwSize = 3;
        m_sdd.fLargeCache = TRUE;
    }
    else
    {
        m_sdd.dwSize = 1;
        m_sdd.fLargeCache = FALSE;
    }

    if (!m_fUpgradeFromWks)
    {
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szServerParams, KEY_READ,
                            &hkeyParams);
        if (SUCCEEDED(hr))
        {
            DWORD   dwSize;

            hr = HrRegQueryDword(hkeyParams, c_szLmAnnounce,
                                 (DWORD *)&m_sdd.fAnnounce);
            if (FAILED(hr))
            {
                if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                {
                    hr = S_OK;
                }
                else
                {
                    goto err;
                }
            }

            hr = HrRegQueryDword(hkeyParams, c_szSize, &dwSize);
            if (FAILED(hr))
            {
                if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                {
                    hr = S_OK;
                }
                else
                {
                    goto err;
                }
            }
            else
            {
                AssertSz(dwSize != 0, "This shouldn't be 0!");
                m_sdd.dwSize = dwSize;
            }

            RegCloseKey(hkeyParams);
        }

        if (!fInstalling)
        {
            // RAID #94442
            // Only read old value if this is not an initial install.
            // We want our default to be written when this is a first time install.

            AssertSz(m_hkeyMM, "No MM registry key??");

            hr = HrRegQueryDword(m_hkeyMM, c_szLargeCache,
                                 (DWORD *) &m_sdd.fLargeCache);
            if (FAILED(hr))
            {
                if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                {
                    hr = S_OK;
                }
                else
                {
                    goto err;
                }
            }
        }
    }
    else
    {
        TraceTag(ttidSrvrCfg, "Upgrading from workstation product so we're "
                 "ignoring the registry read code.");
    }

err:
    TraceError("CSrvrcfg::HrGetRegistryInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSrvrcfg::HrSetRegistryInfo
//
//  Purpose:    Save out our in-memory state to the registry.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   5 Mar 1997
//
//  Notes:
//
HRESULT CSrvrcfg::HrSetRegistryInfo()
{
    HRESULT     hr = S_OK;
    HKEY        hkeyParams;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szServerParams,
                        KEY_ALL_ACCESS, &hkeyParams);
    if (SUCCEEDED(hr))
    {
        hr = HrRegSetDword(hkeyParams, c_szLmAnnounce, m_sdd.fAnnounce);
        if (SUCCEEDED(hr))
        {
            hr = HrRegSetDword(hkeyParams, c_szSize, m_sdd.dwSize);
        }

        RegCloseKey(hkeyParams);
    }

    if (SUCCEEDED(hr))
    {
        AssertSz(m_hkeyMM, "Why is this not open?");

        hr = HrRegSetDword(m_hkeyMM, c_szLargeCache, m_sdd.fLargeCache);
    }

    TraceError("CSrvrcfg::HrSetRegistryInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgaddr.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A D D R . C P P
//
//  Contents:   CTcpAddrPage implementation
//
//  Notes:  CTcpAddrPage is the IP Address page
//
//  Author: tongl   5 Nov, 1997
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "dlgaddr.h"

#include "resource.h"
#include "tcpconst.h"
#include "tcperror.h"
#include "tcphelp.h"
#include "tcputil.h"

#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"
#include "ncsvc.h"
#include "ncperms.h"

#include "dlgaddrm.h"
#include "dlgdns.h"
#include "dlgwins.h"
#include "dlgatm.h"
#include "dlgopt.h"
#include "dlgras.h"

CTcpAddrPage::CTcpAddrPage(CTcpipcfg * ptcpip, const DWORD * adwHelpIDs) :
m_pageBackup(ptcpip, g_aHelpIDS_IDD_BACK_UP),
m_hBackupPage(NULL)
{
    Assert(ptcpip);
    m_ptcpip = ptcpip;
    m_adwHelpIDs = adwHelpIDs;
    m_pAdapterInfo = ptcpip->GetConnectionAdapterInfo();

    m_fModified = FALSE;
    m_fWarnedDisjointGw = FALSE;
    m_fWarnedMismatchIPandGw = FALSE;

    m_fPropShtOk = FALSE;
    m_fPropShtModified = FALSE;
    m_fLmhostsFileReset = FALSE;

//IPSec is removed from connection UI       
//    m_fIpsecPolicySet = FALSE;

    m_ConnType = m_ptcpip->GetConnectionType();
    Assert(m_ConnType != CONNECTION_UNSET);

    m_fRasNotAdmin = m_ptcpip->IsRasNotAdmin();

    m_pIpSettingsPage = NULL;
    m_pTcpDnsPage     = NULL;
    m_pTcpWinsPage    = NULL;
    m_pAtmArpcPage    = NULL;
    m_pTcpOptionsPage = NULL;
    m_pTcpRasPage     = NULL;
}

CTcpAddrPage::~CTcpAddrPage()
{
    FreeCollectionAndItem(m_vstrWarnedDupIpList);
}

LRESULT CTcpAddrPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    // limit the field ranges for the address fields
    m_ipAddress.Create(m_hWnd, IDC_IPADDR_IP);
    m_ipAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    m_ipDnsPrimary.Create(m_hWnd, IDC_DNS_PRIMARY);
    m_ipDnsPrimary.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    m_ipDnsSecondary.Create(m_hWnd, IDC_DNS_SECONDARY);
    m_ipDnsSecondary.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    if (m_ConnType == CONNECTION_LAN)
    {
        // these are for Lan connections only
        m_ipSubnetMask.Create(m_hWnd, IDC_IPADDR_SUB);

        m_ipDefGateway.Create(m_hWnd, IDC_IPADDR_GATE);
        m_ipDefGateway.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);
    }

    if (!FHasPermission(NCPERM_AllowAdvancedTCPIPConfig))
    {
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADVANCED), FALSE);
    }

    return 0;
}

LRESULT CTcpAddrPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpAddrPage::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CTcpAddrPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    m_fSetInitialValue = TRUE;
    SetInfo();
    m_fSetInitialValue = FALSE;

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, 0);
    return 0;
}

LRESULT CTcpAddrPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // All error values are loaded and then checked here
    // while all non-error values are checked in OnApply

    BOOL fError = FALSE; // Allow page to lose active status
    HWND hWndFocus = 0;


    // If the ip address and subnet mask on this page mismatch,
    // just raise error and do not update the UI

    if (m_ConnType == CONNECTION_LAN)
    {
        if (m_ipAddress.IsBlank() && !m_ipSubnetMask.IsBlank())
        {

            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                   MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            hWndFocus = (HWND) m_ipAddress;
            fError = TRUE;
        }
        else if (!m_ipAddress.IsBlank() && m_ipSubnetMask.IsBlank())
        {
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NOSUBNET,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            hWndFocus = (HWND) m_ipSubnetMask;
            fError = TRUE;
        }
    }

    if (!m_ipDnsPrimary.IsBlank() && !m_ipDnsSecondary.IsBlank())
    {
        tstring strPrimaryDns;
        tstring strSecondDns;

        m_ipDnsPrimary.GetAddress(&strPrimaryDns);
        m_ipDnsSecondary.GetAddress(&strSecondDns);
        if (strPrimaryDns == strSecondDns)
        {
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_DUP_SECOND_DNS,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            hWndFocus = (HWND) m_ipDnsSecondary;
            fError = TRUE;
        }
    }
    

    // Now, update in memory structure
    if (!fError)
    {
        UpdateInfo();

        if (m_ConnType != CONNECTION_LAN)
        {
            if (!m_pAdapterInfo->m_fEnableDhcp)
            {
                // simply make sure ip address is not empty for RAS connections
                if (!m_pAdapterInfo->m_vstrIpAddresses.size())
                {
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    fError = TRUE;
                }
                else
                {
                    DWORD ardwIp[4];
                    GetNodeNum(m_pAdapterInfo->m_vstrIpAddresses[0]->c_str(), ardwIp);
                    if (ardwIp[0] > c_iIPADDR_FIELD_1_HIGH || ardwIp[0] < c_iIPADDR_FIELD_1_LOW)
                    {
                        IPAlertPrintf(m_hWnd, IDS_INCORRECT_IP_FIELD_1,
                                ardwIp[0],
                                c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

                        hWndFocus = (HWND) m_ipAddress;
                        fError = TRUE;
                    }
                }

            }
        }
        else // for Lan connections
        {
            // Check validate IP address and duplication on each card before
            // allowing the page to lose focus

            IP_VALIDATION_ERR err;
            
            // Validate IP Address for adapter used in this connection
            if ((err = ValidateIp(m_pAdapterInfo)) != ERR_NONE)
            {
                switch(err)
                {
                case ERR_HOST_ALL0:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_HOST_ALL_0,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    break;
                case ERR_HOST_ALL1:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_HOST_ALL_1,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    break;

                case ERR_SUBNET_ALL0:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_SUBNET_ALL_0,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipSubnetMask;
                    break;
                case ERR_NO_IP:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    break;

                case ERR_NO_SUBNET:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NOSUBNET,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipSubnetMask;
                    break;

                case ERR_UNCONTIGUOUS_SUBNET:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_ERROR_UNCONTIGUOUS_SUBNET,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipSubnetMask;
                    break;

                default:
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INCORRECT_IPADDRESS,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    hWndFocus = (HWND) m_ipAddress;
                    break;
                }

                fError = TRUE;
            }

            if ((!fError) && (!m_pAdapterInfo->m_fEnableDhcp))
            {
                // Check ip address duplicates between this adapter and any other
                // enabled LAN adapters in our first memory list

                // same adapter
                if (FHasDuplicateIp(m_pAdapterInfo))
                {
                    // duplicate IP address on same adapter is an error
                    NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_DUPLICATE_IP_ERROR,
                             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                    fError = TRUE;
                }

                // check the IP address and the static gateway are in the same subnet
                // Multip IP and multiple gateways will show up on both general page
                // and the advanced page.
                // To avoid confusing error messages, we only do this validation when
                // there is only one IP address and one gateway.
                if (!fError && !m_fWarnedMismatchIPandGw &&
                    1 == m_pAdapterInfo->m_vstrIpAddresses.size() &&
                    1 == m_pAdapterInfo->m_vstrDefaultGateway.size() &&
                    1 == m_pAdapterInfo->m_vstrSubnetMask.size())
                {
                    if (!FIpAndGatewayInSameSubNet(m_pAdapterInfo->m_vstrIpAddresses[0]->c_str(),
                        m_pAdapterInfo->m_vstrSubnetMask[0]->c_str(),
                        m_pAdapterInfo->m_vstrDefaultGateway[0]->c_str()))
                    {
                        // duplicate IP address on same adapter is an error
                        if (NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_ERROR_IP_GW_MISMATH,
                            MB_APPLMODAL | MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2) == IDNO)
                        {
                            fError = TRUE;
                        }
                        else
                        {
                            m_fWarnedMismatchIPandGw = TRUE;
                        }
                    }
                    
                }

                // The pvcard is a readonly version of the first memory state
                const VCARD * pvcard = m_ptcpip->GetConstAdapterInfoVector();

                // different adapter
                if (!fError)
                {
                    int iDupCard;

                    VSTR_ITER iterIpBegin = m_pAdapterInfo->m_vstrIpAddresses.begin();
                    VSTR_ITER iterIpEnd = m_pAdapterInfo->m_vstrIpAddresses.end();
                    VSTR_ITER iterIp = iterIpBegin;

                    for( ; iterIp != iterIpEnd ; ++iterIp)
                    {
                        if ((iDupCard=CheckForDuplicates(pvcard, m_pAdapterInfo, **iterIp)) >=0)
                        {
                            Assert((*pvcard)[iDupCard]->m_guidInstanceId != m_pAdapterInfo->m_guidInstanceId);

                            // duplicate IP address between different adapters is not necessarily an error
                            // we raise a warning(requested by bug# 158578)
                            if (!FAlreadyWarned(**iterIp))
                            {
                                UINT    uIdMsg = IDS_DUPLICATE_IP_WARNING;

                                if (FIsCardNotPresentOrMalFunctioning(&((*pvcard)[iDupCard]->m_guidInstanceId)))
                                {
                                    // bug 286379, if the dup card is malfunctioning or not physically present,
                                    // we should give a more specific error
                                    uIdMsg = IDS_DUP_MALFUNCTION_IP_WARNING;
                                }

                                //here is the normal case: both cards are functioning
                                if (NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, uIdMsg,
                                         MB_APPLMODAL | MB_ICONINFORMATION | MB_YESNO,
                                         (*iterIp)->c_str(),
                                         (*pvcard)[iDupCard]->m_strDescription.c_str()) == IDYES)
                                {
                                    fError = TRUE; // NOT ok to leave the UI
                                }
                                else
                                {
                                    // user said the dup is ok, don't warn them again
                                    m_vstrWarnedDupIpList.push_back(new tstring((*iterIp)->c_str()));
                                }

                            }
                        }

                        if (fError)
                            break;
                    }

                }

                //if we have static gateway, check whether other cards also have
                //static gateway. If yes, then the computer may not work properly
                //as a router or edge box. Warn user about this configuration
                if (!fError && !m_fWarnedDisjointGw &&
                    0 < m_pAdapterInfo->m_vstrDefaultGateway.size())
                {
                    for(UINT i = 0; i < pvcard->size(); ++i)
                    {
                        if (0 < (*pvcard)[i]->m_vstrDefaultGateway.size() &&
                            (*pvcard)[i]->m_guidInstanceId != m_pAdapterInfo->m_guidInstanceId &&
                            !FIsCardNotPresentOrMalFunctioning(&((*pvcard)[i]->m_guidInstanceId)))
                        {
                            if (NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_WRN_DISJOINT_NET,
                                        MB_APPLMODAL | MB_ICONINFORMATION | 
                                        MB_YESNO | MB_DEFBUTTON2) == IDNO)
                            {
                                fError = TRUE;
                            }
                            else
                            {
                                //if the user want to have gateways on multiple nics on purpose,
                                //don't warn the user any more
                                m_fWarnedDisjointGw = TRUE;
                            }
                            
                            //In either case of accepting or not-accepting, there is 
                            //no need for additional check for this
                            break;
                        }
                    }
                }
            }
        }

        if (fError) // page not going away, we should update the Ui with what's in memory
            SetInfo();
    }

    //we need to change focus to the control that contains invalidate data
    if (fError && hWndFocus)
        ::SetFocus(hWndFocus);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

LRESULT CTcpAddrPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if(m_fLmhostsFileReset) // if lmhosts has been reset
    {
        m_ptcpip->SetSecondMemoryLmhostsFileReset();
    }

//IPSec is removed from connection UI   
/*  
    if (m_fIpsecPolicySet)
    {
        m_ptcpip->SetSecondMemoryIpsecPolicySet();
    }
*/  

    //Bug 232011, warning the user that the local IP address will be set as the primary DNS
    // server address if DHCP is disabled and DNS server list is empty, if DNS server service
    // is installed.
    if((!m_pAdapterInfo->m_fEnableDhcp) && (m_pAdapterInfo->m_vstrDnsServerList.size() == 0))
    {
        CServiceManager scm;
        CService        svc;
        HRESULT hr = scm.HrOpenService (&svc, c_szSvcDnsServer, NO_LOCK,
                        SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);

        if(SUCCEEDED(hr))
        {
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_TCPIP_DNS_EMPTY,
            MB_OK | MB_APPLMODAL | MB_ICONEXCLAMATION);
        }
    }

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    m_ptcpip->SetSecondMemoryModified();
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CTcpAddrPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpAddrPage::OnDhcpButton(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (!m_pAdapterInfo->m_fEnableDhcp) // if Dhcp was disabled
        {
            // turn on DHCP button and disable the ip and subnet controls
            m_pAdapterInfo->m_fEnableDhcp = TRUE;
            EnableGroup(m_pAdapterInfo->m_fEnableDhcp);

            PageModified();

            FreeCollectionAndItem(m_pAdapterInfo->m_vstrIpAddresses);
            m_ipAddress.ClearAddress();

            if (m_ConnType == CONNECTION_LAN)
            {
                FreeCollectionAndItem(m_pAdapterInfo->m_vstrSubnetMask);
                FreeCollectionAndItem(m_pAdapterInfo->m_vstrDefaultGateway);
                FreeCollectionAndItem(m_pAdapterInfo->m_vstrDefaultGatewayMetric);

                m_ipSubnetMask.ClearAddress();
                m_ipDefGateway.ClearAddress();
            }

        } // if !m_pAdapterInfo->m_fEnableDhcp

        break;
    } // switch

    return 0;
}

LRESULT CTcpAddrPage::OnFixedButton(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                   BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (m_pAdapterInfo->m_fEnableDhcp)
        {
            PageModified();

            // turn off DHCP button and enable the ip and subnet controls
            m_pAdapterInfo->m_fEnableDhcp = FALSE;
            EnableGroup(m_pAdapterInfo->m_fEnableDhcp);
        }
        break;
    } // switch

    return 0;
}

LRESULT CTcpAddrPage::OnDnsDhcp(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        PageModified();

        FreeCollectionAndItem(m_pAdapterInfo->m_vstrDnsServerList);
        m_ipDnsPrimary.ClearAddress();
        m_ipDnsSecondary.ClearAddress();

        EnableStaticDns(FALSE);

        break;
    } // switch

    return 0;
}

LRESULT CTcpAddrPage::OnDnsFixed(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        PageModified();
        EnableStaticDns(TRUE);

        ::SetFocus(GetDlgItem(IDC_DNS_PRIMARY));

        break;
    } // switch

    return 0;
}

LRESULT CTcpAddrPage::OnAdvancedButton(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        BOOL fErr = FALSE;

        if (m_ConnType == CONNECTION_LAN)
        {
            // check inconsistency between ip address & subnet mask
            if (m_ipAddress.IsBlank() && !m_ipSubnetMask.IsBlank())
            {
                NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                ::SetFocus(m_ipAddress);
                fErr = TRUE;
            }
            else if (!m_ipAddress.IsBlank() && m_ipSubnetMask.IsBlank())
            {
                NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NOSUBNET,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                ::SetFocus(m_ipSubnetMask);
                fErr = TRUE;
            }
        }

        if (!m_ipDnsPrimary.IsBlank() && !m_ipDnsSecondary.IsBlank())
        {
            tstring strPrimaryDns;
            tstring strSecondDns;

            m_ipDnsPrimary.GetAddress(&strPrimaryDns);
            m_ipDnsSecondary.GetAddress(&strSecondDns);
            if (strPrimaryDns == strSecondDns)
            {
                NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_DUP_SECOND_DNS,
                                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
                ::SetFocus(m_ipDnsSecondary);
                fErr = TRUE;
            }
        }

        if (!fErr)
        {
            // update our in memory structure with what's in the controls
            UpdateInfo();

            // Bring up the advanced pages
            ADAPTER_INFO adapterInfo;
            adapterInfo = *m_pAdapterInfo;

            GLOBAL_INFO glbInfo;
            glbInfo = *(m_ptcpip->GetGlobalInfo());

            INT_PTR iRet = DoPropertySheet(&adapterInfo, &glbInfo);

            if (iRet != -1)
            {
                if (m_fPropShtOk && m_fPropShtModified)
                {
                    // Something changed, so mark the page as modified
                    PageModified();

                    // Reset values
                    m_fPropShtOk = FALSE;
                    m_fPropShtModified = FALSE;

                    // Update second memory info structure
                    *m_pAdapterInfo = adapterInfo;

                    GLOBAL_INFO * pGlbInfo = m_ptcpip->GetGlobalInfo();
                    *pGlbInfo = glbInfo;
                }
            }

            // Update the controls with new data
            SetInfo();
        }
        break;
    }

    return 0;
}

//Show or Hide the backup configuration page depend on the 
//current settings of dhcp vs static
void CTcpAddrPage::ShowOrHideBackupPage()
{
    if (IsDlgButtonChecked(IDC_IP_DHCP) || IsDlgButtonChecked(IDC_DNS_DHCP)) 
    {
        //show the backup configuration page
        if (NULL == m_hBackupPage)
        {
            m_hBackupPage = m_pageBackup.CreatePage(IDD_BACK_UP, 0);
            Assert(m_hBackupPage);

            if (m_hBackupPage)
            {
                ::SendMessage(GetParent(), PSM_ADDPAGE, 0, (LPARAM) m_hBackupPage);
            }
        }
    }
    else
    {
        //hide the backup configuration page
        if (NULL != m_hBackupPage)
        {
            ::SendMessage(GetParent(), PSM_REMOVEPAGE, 1, (LPARAM) m_hBackupPage);
            m_hBackupPage = NULL;
        }
    }
}


INT_PTR CTcpAddrPage::DoPropertySheet(ADAPTER_INFO * pAdapterDlg,
                                      GLOBAL_INFO  * pGlbDlg)
{
    Assert(pAdapterDlg);
    Assert(pGlbDlg);

    HRESULT hr = S_OK;
    INT_PTR iRet = -1;

    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    // Create property pages
    // ahpsp is allocated memory by CoTaskMemAlloc
    hr = HrSetupPropPages(pAdapterDlg, pGlbDlg, &ahpsp, &cPages);

    if (SUCCEEDED(hr))
    {
        // Show the property sheet
        PROPSHEETHEADER psh = {0};

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_NOAPPLYNOW;
        psh.hwndParent = ::GetActiveWindow();
        psh.hInstance = _Module.GetModuleInstance();
        psh.pszIcon = NULL;
        psh.pszCaption = (PWSTR)SzLoadIds(IDS_TCP_ADV_HEADER);
        psh.nPages = cPages;
        psh.phpage = ahpsp;

        iRet = PropertySheet(&psh);

        if (-1 == iRet)
        {
            DWORD dwError = GetLastError();
            TraceError("CTcpAddrPage::DoPropertySheet", HRESULT_FROM_WIN32(dwError));
        }
    }

    if (m_pIpSettingsPage)
    {
        delete m_pIpSettingsPage;
        m_pIpSettingsPage = NULL;
    }

    if (m_pTcpDnsPage)
    {
        delete m_pTcpDnsPage;
        m_pTcpDnsPage = NULL;
    }

    if (m_pTcpWinsPage)
    {
        delete m_pTcpWinsPage;
        m_pTcpWinsPage = NULL;
    }

    if (m_pAtmArpcPage)
    {
        delete m_pAtmArpcPage;
        m_pAtmArpcPage = NULL;
    }

    if (m_pTcpOptionsPage)
    {
        delete m_pTcpOptionsPage;
        m_pTcpOptionsPage = NULL;
    }
    
    if (m_pTcpRasPage)
    {
        delete m_pTcpRasPage;
        m_pTcpRasPage = NULL;
    }

    if (ahpsp)
        CoTaskMemFree(ahpsp);

    return iRet;
}

HRESULT CTcpAddrPage::HrSetupPropPages( ADAPTER_INFO * pAdapterDlg,
                                        GLOBAL_INFO * pGlbDlg,
                                        HPROPSHEETPAGE ** pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;

    // initialize output parameters
    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    // Set up the property pages
    cPages = 4;
    if (m_ConnType == CONNECTION_LAN)
    {
        m_pIpSettingsPage = new CIpSettingsPage(this, pAdapterDlg,
                                                g_aHelpIDs_IDD_IPADDR_ADV);
        if (m_pIpSettingsPage == NULL)
        {
            CORg(E_OUTOFMEMORY);
        }
    }
    else
    {
        m_pTcpRasPage = new CTcpRasPage(this, pAdapterDlg, g_aHelpIDs_IDD_OPT_RAS);

        if (m_pTcpRasPage == NULL)
        {
            CORg(E_OUTOFMEMORY);
        }
    }

    m_pTcpDnsPage = new CTcpDnsPage(this, pAdapterDlg,
                                    pGlbDlg, g_aHelpIDs_IDD_TCP_DNS);

    m_pTcpWinsPage = new CTcpWinsPage(m_ptcpip, this, pAdapterDlg,
                                      pGlbDlg, g_aHelpIDs_IDD_TCP_WINS);

    if ((m_pTcpDnsPage == NULL) ||
        (m_pTcpWinsPage == NULL))
    {
        CORg(E_OUTOFMEMORY);
    }

    if (pAdapterDlg->m_fIsAtmAdapter)
    {
        m_pAtmArpcPage = new CAtmArpcPage(this, pAdapterDlg,
                                          g_aHelpIDs_IDD_ATM_ARPC);
        if (m_pAtmArpcPage == NULL)
        {
            CORg(E_OUTOFMEMORY);
        }

        cPages++;
    }

    //After removing the IPSec connection UI, there are no options to
    //put in the option tab. So we just go ahead remove it.
    if (!pAdapterDlg->m_fIsRasFakeAdapter)
    {
        m_pTcpOptionsPage = new CTcpOptionsPage(this, pAdapterDlg, pGlbDlg,
                                            g_aHelpIDs_IDD_TCP_OPTIONS);

        if (m_pTcpOptionsPage == NULL)
        {
            CORg(E_OUTOFMEMORY);
        }
    }
    else
    {
        //we remove the option tab for the ras connections
        cPages--;
    }

    // Allocate a buffer large enough to hold the handles to all of our
    // property pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                             * cPages);

    if (!ahpsp)
    {
        CORg(E_OUTOFMEMORY);
    }

    cPages =0;

    if (m_ConnType == CONNECTION_LAN)
    {
        ahpsp[cPages++] = m_pIpSettingsPage->CreatePage(IDD_IPADDR_ADV, 0);
    }
    else
    {
        ahpsp[cPages++] = m_pTcpRasPage->CreatePage(IDD_OPT_RAS, 0);
    }

    ahpsp[cPages++] = m_pTcpDnsPage->CreatePage(IDD_TCP_DNS, 0);
    ahpsp[cPages++] = m_pTcpWinsPage->CreatePage(IDD_TCP_WINS, 0);

    if (pAdapterDlg->m_fIsAtmAdapter)
    {
        ahpsp[cPages++] = m_pAtmArpcPage->CreatePage(IDD_ATM_ARPC, 0);
    }

    if (!pAdapterDlg->m_fIsRasFakeAdapter && m_pTcpOptionsPage)
    {
        ahpsp[cPages++] = m_pTcpOptionsPage->CreatePage(IDD_TCP_OPTIONS, 0);
    }

    *pahpsp = ahpsp;
    *pcPages = cPages;

Error:
    if (FAILED(hr))
    {
        if (m_pIpSettingsPage)
        {
            delete m_pIpSettingsPage;
            m_pIpSettingsPage = NULL;
        }

        if (m_pTcpDnsPage)
        {
            delete m_pTcpDnsPage;
            m_pTcpDnsPage = NULL;
        }

        if (m_pTcpWinsPage)
        {
            delete m_pTcpWinsPage;
            m_pTcpWinsPage = NULL;
        }

        if (m_pAtmArpcPage)
        {
            delete m_pAtmArpcPage;
            m_pAtmArpcPage = NULL;
        }

        if (m_pTcpOptionsPage)
        {
            delete m_pTcpOptionsPage;
            m_pTcpOptionsPage = NULL;
        }

        if (m_pTcpRasPage)
        {
            delete m_pTcpRasPage;
            m_pTcpRasPage = NULL;
        }
        
    }

    return hr;
}

LRESULT CTcpAddrPage::OnIpAddrIp(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnIpAddrSub(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;

    case EN_SETFOCUS:

        // if the subnet mask is blank, create a mask and insert it into
        // the control
        if (!m_ipAddress.IsBlank() && m_ipSubnetMask.IsBlank())
        {
            tstring strSubnetMask;
            tstring strIpAddress;

            m_ipAddress.GetAddress(&strIpAddress);

            // generate the mask and update the control, and internal structure
            GenerateSubnetMask(m_ipAddress, &strSubnetMask);
            m_ipSubnetMask.SetAddress(strSubnetMask.c_str());

            ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrSubnetMask),
                                strSubnetMask.c_str());
        }
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnIpAddrGateway(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnDnsPrimary(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnDnsSecondary(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpAddrPage::OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    switch(idCtrl)
    {
    case IDC_IPADDR_IP:
    case IDC_IPADDR_GATE:
    case IDC_DNS_PRIMARY:
    case IDC_DNS_SECONDARY:

        lpnmipa = (LPNMIPADDRESS) pnmh;

        if (0==lpnmipa->iField)
        {
            iLow  = c_iIPADDR_FIELD_1_LOW;
            iHigh = c_iIPADDR_FIELD_1_HIGH;
        };

        IpCheckRange(lpnmipa, 
                     m_hWnd, 
                     iLow, 
                     iHigh, 
                     (IDC_IPADDR_IP == idCtrl || IDC_IPADDR_GATE == idCtrl));
        break;

    case IDC_IPADDR_SUB:

        lpnmipa = (LPNMIPADDRESS) pnmh;
        IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);
        break;

    default:
        break;
    }

    return 0;
}

void CTcpAddrPage::EnableGroup(BOOL fEnableDhcp)
{
    BOOL fStaticIp = !fEnableDhcp;

    CheckDlgButton(IDC_IP_DHCP,  fEnableDhcp);
    CheckDlgButton(IDC_IP_FIXED, fStaticIp);

    ::EnableWindow(GetDlgItem(IDC_IPADDR_IPTEXT), fStaticIp);
    ::EnableWindow(GetDlgItem(IDC_IPADDR_IP), fStaticIp);

    if (m_ConnType == CONNECTION_LAN)
    {
        ::EnableWindow(GetDlgItem(IDC_IPADDR_SUBTEXT), fStaticIp);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_SUB), fStaticIp);

        ::EnableWindow(GetDlgItem(IDC_IPADDR_GATE), fStaticIp);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_GATETEXT), fStaticIp);
    }

    if (!fEnableDhcp) // enforce DNS address option
    {
        CheckDlgButton(IDC_DNS_DHCP,  FALSE);
        CheckDlgButton(IDC_DNS_FIXED, TRUE);

        ::EnableWindow(GetDlgItem(IDC_DNS_DHCP), FALSE);
        EnableStaticDns(TRUE);
    }
    else
    {
        ::EnableWindow(GetDlgItem(IDC_DNS_DHCP), TRUE);
    }

    if (CONNECTION_LAN == m_ConnType)
    {
        ShowOrHideBackupPage();
    }
}

void CTcpAddrPage::EnableStaticDns(BOOL fUseStaticDns)
{
    ::EnableWindow(GetDlgItem(IDC_DNS_PRIMARY), fUseStaticDns);
    ::EnableWindow(GetDlgItem(IDC_DNS_PRIMARY_TEXT), fUseStaticDns);
    ::EnableWindow(GetDlgItem(IDC_DNS_SECONDARY), fUseStaticDns);
    ::EnableWindow(GetDlgItem(IDC_DNS_SECONDARY_TEXT), fUseStaticDns);
}

// Set info to controls using the data in m_pAdapterInfo
void CTcpAddrPage::SetInfo()
{
    Assert(m_pAdapterInfo);

    // Dhcp Ip address is not allowed when Dhcp server is installed or
    // it is a SLIP connection

    // const GLOBAL_INFO * pglb = m_ptcpip->GetConstGlobalInfo();
    // if ((pglb->m_fDhcpServerInstalled) || (m_ConnType == CONNECTION_RAS_SLIP))

    if (m_ConnType == CONNECTION_RAS_SLIP)
    {
        ::EnableWindow(GetDlgItem(IDC_IP_DHCP), FALSE);
        m_pAdapterInfo->m_fEnableDhcp = 0;
    }

    EnableGroup(m_pAdapterInfo->m_fEnableDhcp);

    // Set Ip address
    if(m_pAdapterInfo->m_fEnableDhcp == 0) //Dhcp disabled, static IP
    {
        tstring strTmp;
        if (fQueryFirstAddress(m_pAdapterInfo->m_vstrIpAddresses, &strTmp))
            m_ipAddress.SetAddress(strTmp.c_str());
        else
            m_ipAddress.ClearAddress();
    }
    else //Dhcp enabled
    {
        m_ipAddress.ClearAddress();
        FreeCollectionAndItem(m_pAdapterInfo->m_vstrIpAddresses);
    }

    // Set Subnet mask and default gateway if Lan connection
    if (m_ConnType == CONNECTION_LAN)
    {
        if(m_pAdapterInfo->m_fEnableDhcp == 0) //Dhcp disabled, static IP
        {
            tstring strTmp;

            if (fQueryFirstAddress(m_pAdapterInfo->m_vstrSubnetMask, &strTmp))
                m_ipSubnetMask.SetAddress(strTmp.c_str());
            else
                m_ipSubnetMask.ClearAddress();

            if (fQueryFirstAddress(m_pAdapterInfo->m_vstrDefaultGateway, &strTmp))
                m_ipDefGateway.SetAddress(strTmp.c_str());
            else
                m_ipDefGateway.ClearAddress();
        }
        else //Dhcp enabled
        {
            m_ipSubnetMask.ClearAddress();
            FreeCollectionAndItem(m_pAdapterInfo->m_vstrSubnetMask);

            tstring strGateway;

            if (fQueryFirstAddress(m_pAdapterInfo->m_vstrDefaultGateway, &strGateway))
                m_ipDefGateway.SetAddress(strGateway.c_str());
            else
                m_ipDefGateway.ClearAddress();
        }
    }

    // Set Dns addresses
    BOOL fUseStaticDns = ((!m_pAdapterInfo->m_fEnableDhcp) ||
                          (m_pAdapterInfo->m_vstrDnsServerList.size() >0));

    CheckDlgButton(IDC_DNS_DHCP,  !fUseStaticDns);
    CheckDlgButton(IDC_DNS_FIXED, fUseStaticDns);

    EnableStaticDns(fUseStaticDns);

    if (fUseStaticDns)
    {
        tstring strTmp;

        if (fQueryFirstAddress(m_pAdapterInfo->m_vstrDnsServerList, &strTmp))
            m_ipDnsPrimary.SetAddress(strTmp.c_str());
        else
            m_ipDnsPrimary.ClearAddress();

        if (fQuerySecondAddress(m_pAdapterInfo->m_vstrDnsServerList, &strTmp))
            m_ipDnsSecondary.SetAddress(strTmp.c_str());
        else
            m_ipDnsSecondary.ClearAddress();
    }
    else
    {
        m_ipDnsPrimary.ClearAddress();
        m_ipDnsSecondary.ClearAddress();
    }
}

// Update info in m_pAdapterInfo with what's in the controls
void CTcpAddrPage::UpdateInfo()
{
    Assert(m_pAdapterInfo);

    if (!m_pAdapterInfo->m_fEnableDhcp) // If DHCP disabled
    {
        tstring strNewAddress;

        // ip address & subnet mask
        if (!m_ipAddress.IsBlank())
        {
            m_ipAddress.GetAddress(&strNewAddress);
            ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrIpAddresses),
                                strNewAddress.c_str());

            if (m_ConnType == CONNECTION_LAN)
            {
                if (m_ipSubnetMask.IsBlank())
                {
                    SendDlgItemMessage(IDC_IPADDR_SUB, WM_SETFOCUS, 0, 0);
                }
                else
                {
                    m_ipSubnetMask.GetAddress(&strNewAddress);
                    ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrSubnetMask),
                                        strNewAddress.c_str());
                }
            }
        }
        else // no ip address
        {
            if (m_ConnType == CONNECTION_LAN)
            {
                if (m_ipSubnetMask.IsBlank())
                {
                    // delete the first ip address and subnet mask
                    if (m_pAdapterInfo->m_vstrIpAddresses.size())
                    {
                        FreeVectorItem(m_pAdapterInfo->m_vstrIpAddresses, 0);

                        if (!m_pAdapterInfo->m_vstrIpAddresses.empty())
                            m_ipAddress.SetAddress(m_pAdapterInfo->m_vstrIpAddresses[0]->c_str());

                        if (m_pAdapterInfo->m_vstrSubnetMask.size())
                        {
                            FreeVectorItem(m_pAdapterInfo->m_vstrSubnetMask, 0);

                            if (!m_pAdapterInfo->m_vstrSubnetMask.empty())
                                m_ipSubnetMask.SetAddress(m_pAdapterInfo->m_vstrSubnetMask[0]->c_str());
                        }
                    }
                }
                else
                {
                    AssertSz(FALSE, "No ip address.");
                }
            }
            else // RAS connection, simply delete IP address
            {
                if (m_pAdapterInfo->m_vstrIpAddresses.size())
                {
                    FreeVectorItem(m_pAdapterInfo->m_vstrIpAddresses, 0);
                }
            }
        }

        // default gateway
        if (m_ConnType == CONNECTION_LAN)
        {
            if (!m_ipDefGateway.IsBlank())
            {
                m_ipDefGateway.GetAddress(&strNewAddress);
                ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrDefaultGateway),
                                    strNewAddress.c_str());
                int iSize = m_pAdapterInfo->m_vstrDefaultGatewayMetric.size();
                if (m_pAdapterInfo->m_vstrDefaultGatewayMetric.size() == 0)
                {
                    WCHAR buf[IP_LIMIT];
                    //if there is no default gateway before (that's the reason metric list is
                    //empty), we add the default metric for it
                    _ltot(c_dwDefaultMetricOfGateway, buf, 10);
                    m_pAdapterInfo->m_vstrDefaultGatewayMetric.push_back(new tstring(buf));
                }
            }
            else
            {
                if (m_pAdapterInfo->m_vstrDefaultGateway.size() >0)
                {
                    FreeVectorItem(m_pAdapterInfo->m_vstrDefaultGateway, 0);

                    if (!m_pAdapterInfo->m_vstrDefaultGateway.empty())
                        m_ipDefGateway.SetAddress(m_pAdapterInfo->m_vstrDefaultGateway[0]->c_str());

                    if (m_pAdapterInfo->m_vstrDefaultGatewayMetric.size() >0)
                        FreeVectorItem(m_pAdapterInfo->m_vstrDefaultGatewayMetric, 0);
                }
            }
        }
    }

    // DNS addresses
    UpdateAddressList(&(m_pAdapterInfo->m_vstrDnsServerList),
                        m_ipDnsPrimary, m_ipDnsSecondary);
}

// Update a vector of strings with values from two IP address
// controls
void CTcpAddrPage::UpdateAddressList(VSTR * pvstrList,
                                     IpControl& ipPrimary,
                                     IpControl& ipSecondary)
{
    tstring str;
    if (pvstrList->size()<=2) // if the list did not have more than two addresses
    {
        // Free the list
        FreeCollectionAndItem(*pvstrList);

        // Insert new addresses if any
        if (!ipPrimary.IsBlank())
        {
            ipPrimary.GetAddress(&str);
            pvstrList->push_back(new tstring(str.c_str()));
        }

        if (!ipSecondary.IsBlank())
        {
            ipSecondary.GetAddress(&str);
            pvstrList->push_back(new tstring(str.c_str()));
        }
    }
    else
    {
        // Replace addresses if they exists
        if (!ipSecondary.IsBlank())
        {
            ipSecondary.GetAddress(&str);
            ReplaceSecondAddress(pvstrList, str.c_str());
        }
        else
        {
            FreeVectorItem(*pvstrList, 1);
        }

        if (!ipPrimary.IsBlank())
        {
            ipPrimary.GetAddress(&str);
            ReplaceFirstAddress(pvstrList, str.c_str());
        }
        else
        {
            FreeVectorItem(*pvstrList, 0);
        }

        //fix Bug 425112: Update the UI if either of the IP control
        //is blank because sometimes UpdateInfo get called twice (which 
        // will make us delete the address twice if we dont update the UI)
        if (ipPrimary.IsBlank() || ipSecondary.IsBlank())
        {   
            if (!pvstrList->empty())
            {
                ipPrimary.SetAddress((*pvstrList)[0]->c_str());
            }

            if (pvstrList->size() >= 2)
            {
                ipSecondary.SetAddress((*pvstrList)[1]->c_str());
            }
        }
    }
}


BOOL CTcpAddrPage::FIsCardNotPresentOrMalFunctioning(GUID * pguidCard)
{
    Assert(pguidCard);
    BOOL fRet = FALSE;
    FARPROC pfnHrGetPnpDeviceStatus = NULL;
    HMODULE hNetman = NULL;
    
    HRESULT hrTmp = S_OK;
    NETCON_STATUS   ncStatus = NCS_CONNECTED;
    
    hrTmp = HrLoadLibAndGetProc(L"netman.dll", "HrGetPnpDeviceStatus",
        &hNetman, &pfnHrGetPnpDeviceStatus);
    
    if (SUCCEEDED(hrTmp))
    {
        hrTmp = (*(PHRGETPNPDEVICESTATUS)pfnHrGetPnpDeviceStatus)(
                                                            pguidCard,
                                                            &ncStatus);
        FreeLibrary(hNetman);
    }
    
    if (SUCCEEDED(hrTmp) &&
        (NCS_HARDWARE_MALFUNCTION == ncStatus || 
         NCS_HARDWARE_NOT_PRESENT == ncStatus))
    {
        fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgaddr.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A D D R . H
//
//  Contents:   CTcpAddrPage declaration
//
//  Notes:  CTcpAddrPage is the IP Address page
//
//  Author: tongl   5 Nov 1997
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"
#include "dlgbkup.h"

class CTcpAddrPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpAddrPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Control message handlers

        // Mesg handler for the DHCP Radio button
        COMMAND_ID_HANDLER(IDC_IP_DHCP, OnDhcpButton)

        // Mesg handler for the "specify IP address" Radio button
        COMMAND_ID_HANDLER(IDC_IP_FIXED, OnFixedButton)

        // Mesg handler for the DHCP Radio button
        COMMAND_ID_HANDLER(IDC_DNS_DHCP, OnDnsDhcp)

        // Mesg handler for the "specify IP address" Radio button
        COMMAND_ID_HANDLER(IDC_DNS_FIXED, OnDnsFixed)

        // Mesg handler for the "Advanced" push button
        COMMAND_ID_HANDLER(IDC_IPADDR_ADVANCED, OnAdvancedButton)

        // Notification handlers for the IP address edit boxes
        COMMAND_ID_HANDLER(IDC_IPADDR_IP,    OnIpAddrIp)
        COMMAND_ID_HANDLER(IDC_IPADDR_SUB,   OnIpAddrSub)
        COMMAND_ID_HANDLER(IDC_IPADDR_GATE,  OnIpAddrGateway)

        COMMAND_ID_HANDLER(IDC_DNS_PRIMARY,    OnDnsPrimary)
        COMMAND_ID_HANDLER(IDC_DNS_SECONDARY,  OnDnsSecondary)

        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)

    END_MSG_MAP()

    // Constructors/Destructors
    CTcpAddrPage(CTcpipcfg * ptcpip, const DWORD * phelpIDs = NULL);
    ~CTcpAddrPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // command ID handlers
    LRESULT OnDhcpButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnFixedButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnDnsDhcp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDnsFixed(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnAdvancedButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // notify code hanlders for the IP edit controls
    LRESULT OnIpAddrIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpAddrSub(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpAddrGateway(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnDnsPrimary(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDnsSecondary(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    friend class CIpSettingsPage;
    friend class CTcpDnsPage;
    friend class CTcpWinsPage;
    friend class CAtmArpcPage;
    friend class CTcpOptionsPage;
    friend class CTcpRasPage;

// Implementation
private:

    // initializes control state and values
    void SetInfo();

    // update values in m_pAdapterInfo with what's in the controls
    void UpdateInfo();
    void UpdateAddressList(VSTR * pvstrList,IpControl& ipPrimary,IpControl& ipSecondary);

    INT_PTR DoPropertySheet(ADAPTER_INFO * pAdapterDlg, GLOBAL_INFO * pGlbDlg);
    HRESULT HrSetupPropPages(ADAPTER_INFO * pAdapterDlg,
                             GLOBAL_INFO * pGlbDlg,
                             HPROPSHEETPAGE ** pahpsp, INT * pcPages);

    void EnableGroup(BOOL fEnableDhcp);
    void EnableStaticDns(BOOL fUseStaticDns);

    void SetSubnetMask();

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { 
                            if (!m_fSetInitialValue)
                            {
                                m_fModified = TRUE; 
                                PropSheet_Changed(GetParent(), m_hWnd);
                            }
                        }

    BOOL FAlreadyWarned(tstring strIp)
    {
        BOOL fRet = FALSE;

        VSTR_ITER iterIpBegin = m_vstrWarnedDupIpList.begin();
        VSTR_ITER iterIpEnd = m_vstrWarnedDupIpList.end();
        VSTR_ITER iterIp = iterIpBegin;

        for( ; iterIp != iterIpEnd; iterIp++)
        {
            if (strIp == **iterIp)
            {
                fRet = TRUE;
                break;
            }
        }
        return fRet;
    }

    void ShowOrHideBackupPage();
    BOOL FIsCardNotPresentOrMalFunctioning(GUID * pguidCard);

    // data members
    CTcpipcfg *     m_ptcpip;
    ConnectionType  m_ConnType;
    ADAPTER_INFO *  m_pAdapterInfo;
    const DWORD*    m_adwHelpIDs;

    BOOL    m_fModified;
    BOOL    m_fWarnedDisjointGw;
    BOOL    m_fWarnedMismatchIPandGw;

    BOOL    m_fPropShtOk;
    BOOL    m_fPropShtModified;
    BOOL    m_fLmhostsFileReset;
//IPSec is removed from connection UI		
//    BOOL    m_fIpsecPolicySet;

    BOOL            m_fSetInitialValue;

    BOOL    m_fRasNotAdmin;

    IpControl       m_ipAddress;
    IpControl       m_ipSubnetMask;
    IpControl       m_ipDefGateway;
    IpControl       m_ipDnsPrimary;
    IpControl       m_ipDnsSecondary;

    VSTR    m_vstrWarnedDupIpList;

    class CIpSettingsPage  * m_pIpSettingsPage;
    class CTcpDnsPage     * m_pTcpDnsPage;
    class CTcpWinsPage    * m_pTcpWinsPage;
    class CAtmArpcPage    * m_pAtmArpcPage;
    class CTcpOptionsPage * m_pTcpOptionsPage;
    class CTcpRasPage     * m_pTcpRasPage;

    CIpBackUpDlg         m_pageBackup;
    HPROPSHEETPAGE       m_hBackupPage;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgaddrm.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A D D R M . C P P
//
//  Contents:   Implementation of CIpsSettingPage, CAddressDialog and
//              CGatewayDialog
//
//  Notes:  CIpSettingsPage is the Advanced IP Addressing dialog
//
//  Author: tongl   5 Nov 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "dlgaddrm.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "resource.h"
#include "tcpconst.h"
#include "tcperror.h"
#include "dlgaddr.h"
#include "tcphelp.h"
#include "tcputil.h"

// CIpSettingsPage
CIpSettingsPage::CIpSettingsPage(CTcpAddrPage * pTcpAddrPage,
                                   ADAPTER_INFO * pAdapterInfo,
                                   const DWORD * adwHelpIDs)
{
    m_pParentDlg = pTcpAddrPage;
    Assert(pTcpAddrPage != NULL);

    Assert(pAdapterInfo != NULL);
    m_pAdapterInfo = pAdapterInfo;

    m_adwHelpIDs = adwHelpIDs;

    m_uiRemovedMetric = c_dwDefaultMetricOfGateway;

    // Initialize internal states
    m_fModified = FALSE;
    m_fEditState = FALSE;
}

CIpSettingsPage::~CIpSettingsPage()
{
}

LRESULT CIpSettingsPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL & fHandled)
{
    WCHAR   szAdd[16];

    // Get the IP address Add and Edit button Text and remove ellipse
    GetDlgItemText(IDC_IPADDR_ADDIP, szAdd, celems(szAdd));
    szAdd[lstrlen(szAdd) - c_cchRemoveCharatersFromEditOrAddButton] = 0;
    m_strAdd = szAdd;

    // Repos the windows relative to the static text at top
    HWND hText = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_IPADDR_TEXT);
    RECT rect;

    if (hText)
    {
        ::GetWindowRect(hText, &rect);
        SetWindowPos(NULL,  rect.left, rect.top-16, 0,0,
                     SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
    }

    m_hIpListView = GetDlgItem(IDC_IPADDR_ADVIP);

    LV_COLUMN lvCol;        // list view column structure
    int index, iNewItem;

    // Calculate column width
    ::GetClientRect(m_hIpListView, &rect);
    int colWidth = (rect.right/c_nColumns);

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column
    lvCol.cx = colWidth;       // width of column in pixels

    // Add the two columns and header text.
    for (index = 0; index < c_nColumns; index++)
    {
        // column header text
        if (0==index) // first column
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_IPADDRESS_TEXT);
        }
        else
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_SUBNET_TXT);
        }

        iNewItem = ListView_InsertColumn(m_hIpListView, index, &lvCol);

        AssertSz((iNewItem == index), "Invalid item inserted to list view !");
    }

    // assign hwnds for controls
    m_hAddIp = GetDlgItem(IDC_IPADDR_ADDIP);
    m_hEditIp = GetDlgItem(IDC_IPADDR_EDITIP);
    m_hRemoveIp = GetDlgItem(IDC_IPADDR_REMOVEIP);

    m_hGatewayListView = GetDlgItem(IDC_IPADDR_GATE);

    // Calculate column width
    ::GetClientRect(m_hGatewayListView, &rect);
    colWidth = (rect.right/c_nColumns);

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column
    lvCol.cx = colWidth;       // width of column in pixels

    // Add the two columns and header text.
    for (index = 0; index < c_nColumns; index++)
    {
        // column header text
        if (0==index) // first column
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_GATEWAY_TEXT);
        }
        else
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_METRIC_TEXT);
        }

        iNewItem = ListView_InsertColumn(m_hGatewayListView, index, &lvCol);
    }
    m_hAddGateway = GetDlgItem(IDC_IPADDR_ADDGATE);
    m_hEditGateway = GetDlgItem(IDC_IPADDR_EDITGATE);
    m_hRemoveGateway = GetDlgItem(IDC_IPADDR_REMOVEGATE);

    SendDlgItemMessage(IDC_IPADDR_METRIC, EM_LIMITTEXT, MAX_METRIC_DIGITS, 0);

    // do this last
    UINT uiMetric = m_pAdapterInfo->m_dwInterfaceMetric;
    if (c_dwDefaultIfMetric == uiMetric)
    {
        CheckDlgButton(IDC_AUTO_METRIC, TRUE);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_METRIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_STATIC_IF_METRIC), FALSE);
    }
    else
    {
        if (uiMetric > MAX_METRIC)
        {
            uiMetric = MAX_METRIC;
        }
        SetDlgItemInt(IDC_IPADDR_METRIC, uiMetric, FALSE);
    }

    SetIpInfo();  // do this before SetGatewayInfo
    SetIpButtons();

    SetGatewayInfo();
    SetGatewayButtons();

    return 0;
}


LRESULT CIpSettingsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CIpSettingsPage::OnHelp(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CIpSettingsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CIpSettingsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    UpdateIpList(); // update the info for the current adapter
    UpdateGatewayList();

    //Validate IP address
    BOOL fError = FALSE;
    UINT uiMetric;
    HWND hFocus = NULL;

    if (IsDlgButtonChecked(IDC_AUTO_METRIC))
    {
        if (m_pAdapterInfo->m_dwInterfaceMetric != c_dwDefaultIfMetric)
        {
            m_pAdapterInfo->m_dwInterfaceMetric = c_dwDefaultIfMetric;
            PageModified();
        }
    }
    else
    {
        uiMetric = GetDlgItemInt(IDC_IPADDR_METRIC, &fError, FALSE);
        if (fError && uiMetric >= 1 && uiMetric <= MAX_METRIC)
        {
            if (m_pAdapterInfo->m_dwInterfaceMetric != uiMetric)
            {
                m_pAdapterInfo->m_dwInterfaceMetric = uiMetric;
                PageModified();
            }
            fError = FALSE;
        }
        else
        {
            TCHAR szBuf[32] = {0};
            wsprintf(szBuf, L"%u", MAX_METRIC);
            
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_METRIC,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK, szBuf);
            hFocus = GetDlgItem(IDC_IPADDR_METRIC);
            fError = TRUE;
        }
    }

    IP_VALIDATION_ERR err = ERR_NONE;
    if ((err = ValidateIp(m_pAdapterInfo)) != ERR_NONE)
    {
        NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, GetIPValidationErrorMessageID(err),
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
        fError = TRUE;
    }


    if ((!fError) && (!m_pAdapterInfo->m_fEnableDhcp))
    {
        // Check ip address duplicates between this adapter and any other
        // enabled LAN adapters in our first memory list

        // same adapter
        if (FHasDuplicateIp(m_pAdapterInfo))
        {
            // duplicate IP address on same adapter is an error
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_DUPLICATE_IP_ERROR,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            fError = TRUE;
        }
    }

    if (fError)
    {
        SetIpInfo();  // do this before SetGatewayInfo due to cache'd data
        SetIpButtons();

        SetGatewayInfo();
        SetGatewayButtons();
    }

    if (fError && hFocus)
    {
        ::SetFocus(hFocus);
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

LRESULT CIpSettingsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    SetModifiedTo(FALSE);  // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CIpSettingsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CIpSettingsPage::OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

void CIpSettingsPage::UpdateIpList()
{
    // update the IP addresses list for the specified adapter
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrIpAddresses);
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrSubnetMask);

    if (m_pAdapterInfo->m_fEnableDhcp)
    {
        TraceTag(ttidTcpip, "[UpdateIpList] adapter %S has Dhcp enabled",
                 m_pAdapterInfo->m_strDescription.c_str());
        return;
    }

    int nlvCount = ListView_GetItemCount(m_hIpListView);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT;

    for (int j=0; j< nlvCount; j++)
    {
        WCHAR buf[IP_LIMIT];
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);

        lvItem.iItem = j;
        lvItem.iSubItem = 0;
        ListView_GetItem(m_hIpListView, &lvItem);

        Assert(buf);
        m_pAdapterInfo->m_vstrIpAddresses.push_back(new tstring(buf));

        lvItem.iItem = j;
        lvItem.iSubItem = 1;
        ListView_GetItem(m_hIpListView, &lvItem);

        Assert(buf);
        m_pAdapterInfo->m_vstrSubnetMask.push_back(new tstring(buf));
    }
}

LRESULT CIpSettingsPage::OnAddIp(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CAddressDialog * pDlgAddr = new CAddressDialog(this, g_aHelpIDs_IDD_IPADDR_ADV_CHANGEIP);

    if (pDlgAddr == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pDlgAddr->m_strNewIpAddress = m_strRemovedIpAddress;
    pDlgAddr->m_strNewSubnetMask = m_strRemovedSubnetMask;

    // See if the address is added
    if (pDlgAddr->DoModal() == IDOK)
    {
        int nCount = ListView_GetItemCount(m_hIpListView);

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.lParam =0;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;

        // IP address
        lvItem.iItem=nCount;
        lvItem.iSubItem=0;
        lvItem.pszText= (PWSTR)(pDlgAddr->m_strNewIpAddress.c_str());
        SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

        // Subnet mask
        lvItem.iItem=nCount;
        lvItem.iSubItem=1;
        lvItem.pszText= (PWSTR)(pDlgAddr->m_strNewSubnetMask.c_str());
        SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_SETITEMTEXT, nCount, (LPARAM)&lvItem);

        SetIpButtons();

        // empty strings, this removes the saved address from RemoveIP
        pDlgAddr->m_strNewIpAddress = L"";
        pDlgAddr->m_strNewSubnetMask = L"";

    }
    m_strRemovedIpAddress = pDlgAddr->m_strNewIpAddress;
    m_strRemovedSubnetMask = pDlgAddr->m_strNewSubnetMask;

    delete pDlgAddr;
    return 0;
}

LRESULT CIpSettingsPage::OnEditIp(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    // get the user selection and allow the user to edit the ip/subnet pair
    int itemSelected = ListView_GetNextItem(m_hIpListView, -1, LVNI_SELECTED);
    
    CAddressDialog * pDlgAddr = new CAddressDialog(this, 
                                        g_aHelpIDs_IDD_IPADDR_ADV_CHANGEIP,
                                        itemSelected);

    pDlgAddr->m_strNewIpAddress = m_strRemovedIpAddress;
    pDlgAddr->m_strNewSubnetMask = m_strRemovedSubnetMask;

    
    if (itemSelected != -1)
    {
        WCHAR buf[IP_LIMIT];

        // save off the removed address and delete if from the listview
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        // Get IP address
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        ListView_GetItem(m_hIpListView, &lvItem);

        pDlgAddr->m_strNewIpAddress = buf;

        // Get Subnet mask
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        ListView_GetItem(m_hIpListView, &lvItem);

        pDlgAddr->m_strNewSubnetMask = buf;

        // See if the address is added
        if (pDlgAddr->DoModal() == IDOK)
        {
            int nCount = ListView_GetItemCount(m_hIpListView);
            Assert(nCount>0);

            LV_ITEM lvItem;

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = itemSelected;

            // IP address
            lvItem.pszText = (PWSTR) pDlgAddr->m_strNewIpAddress.c_str();
            lvItem.iSubItem = 0;
            SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_SETITEM, 0, (LPARAM)&lvItem);

            // Subnet mask
            lvItem.pszText = (PWSTR) pDlgAddr->m_strNewSubnetMask.c_str();
            lvItem.iSubItem = 1;
            SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_SETITEM, 0, (LPARAM)&lvItem);
        }
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT, IDS_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    // don't save this ip/sub pair
    m_strRemovedIpAddress = L"";;
    m_strRemovedSubnetMask = L"";;

    delete pDlgAddr;
    return 0;
}

LRESULT CIpSettingsPage::OnRemoveIp(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    // get the current selected item and remove it
    int itemSelected = ListView_GetNextItem(m_hIpListView, -1,
                                            LVNI_SELECTED);

    if (itemSelected != -1)
    {
        WCHAR buf[IP_LIMIT];

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);

        // save off the removed address and delete it from the listview
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        ListView_GetItem(m_hIpListView, &lvItem);

        m_strRemovedIpAddress = buf;

        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        ListView_GetItem(m_hIpListView, &lvItem);

        m_strRemovedSubnetMask = buf;

        SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_DELETEITEM,
                           (WPARAM)itemSelected, 0);

        ListView_SetItemState(m_hIpListView, 0, LVIS_SELECTED,
                             LVIS_SELECTED);

        SetIpButtons();
        PageModified();
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT,
                 IDS_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    return 0;
}

INT CALLBACK GatewayCompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lSort)
{
    return (INT)lParam1 - (INT)lParam2;
}

LRESULT CIpSettingsPage::OnAddGate(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CGatewayDialog * pDlgGate = new CGatewayDialog(this, g_aHelpIDs_IDD_IPADDR_ADV_CHANGEGATE);

    if (pDlgGate == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pDlgGate->m_strNewGate = m_strRemovedGateway;
    pDlgGate->m_uiNewMetric = m_uiRemovedMetric;

    if (pDlgGate->DoModal() == IDOK)
    {
        WCHAR buf[256] = {0};
        LV_ITEM lvItem;

        int cItem = ListView_GetItemCount(m_hGatewayListView);

        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.lParam = (LPARAM)pDlgGate->m_uiNewMetric;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;

        lvItem.iItem = cItem;
        lvItem.iSubItem = 0;
        lvItem.pszText = (PWSTR)(pDlgGate->m_strNewGate.c_str());
        lvItem.iItem = (int)SendDlgItemMessage(IDC_IPADDR_GATE, LVM_INSERTITEM,
                                          0, (LPARAM)&lvItem);

        lvItem.iSubItem=1;
        lvItem.pszText = buf;
        
        if (0 == lvItem.lParam)
        {
            lstrcpynW(buf, SzLoadIds(IDS_AUTO_GW_METRIC), celems(buf));
        }
        else
        {
            _ltot((INT)lvItem.lParam, buf, 10);
        }
        
        SendDlgItemMessage(IDC_IPADDR_GATE, LVM_SETITEMTEXT,
                           lvItem.iItem, (LPARAM)&lvItem);
        ListView_SetItemState(m_hGatewayListView, lvItem.iItem, LVIS_SELECTED,
                              LVIS_SELECTED);

        SetGatewayButtons();

        pDlgGate->m_strNewGate = L"";
        pDlgGate->m_uiNewMetric = c_dwDefaultMetricOfGateway;

        ListView_SortItems(m_hGatewayListView, GatewayCompareProc, 0);
    }
    m_strRemovedGateway = pDlgGate->m_strNewGate;
    m_uiRemovedMetric = pDlgGate->m_uiNewMetric;

    delete pDlgGate;
    return TRUE;
}

LRESULT CIpSettingsPage::OnEditGate(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    int itemSelected = ListView_GetNextItem(m_hGatewayListView, -1, LVNI_SELECTED);

    CGatewayDialog * pDlgGate = new CGatewayDialog(this, 
                                        g_aHelpIDs_IDD_IPADDR_ADV_CHANGEGATE,
                                        itemSelected
                                        );

    pDlgGate->m_strNewGate = m_strRemovedGateway;
    pDlgGate->m_uiNewMetric = m_uiRemovedMetric;

    // get the user selection and allow the user to edit the ip/subnet pair
    if (itemSelected != -1)
    {
        WCHAR buf[256] = {0};
        LV_ITEM lvItem;

        // Get gateway
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        ListView_GetItem(m_hGatewayListView, &lvItem);

        pDlgGate->m_strNewGate = buf;
        pDlgGate->m_uiNewMetric = (UINT)lvItem.lParam;

        if (pDlgGate->DoModal() == IDOK)
        {
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.iItem = itemSelected;
            lvItem.lParam = pDlgGate->m_uiNewMetric;

            lvItem.iSubItem = 0;
            lvItem.pszText = (PWSTR) pDlgGate->m_strNewGate.c_str();
            SendDlgItemMessage(IDC_IPADDR_GATE, LVM_SETITEM, 0,
                               (LPARAM)&lvItem);

            lvItem.iSubItem = 1;
            lvItem.pszText = buf;
            if (0 == lvItem.lParam)
            {
                lstrcpynW(buf, SzLoadIds(IDS_AUTO_GW_METRIC), celems(buf));
            }
            else
            {
                _ltot((INT)lvItem.lParam, buf, 10);
            }

            SendDlgItemMessage(IDC_IPADDR_GATE, LVM_SETITEMTEXT, itemSelected,
                               (LPARAM)&lvItem);
            ListView_SetItemState(m_hGatewayListView, itemSelected,
                                  LVIS_SELECTED, LVIS_SELECTED);
            ListView_SortItems(m_hGatewayListView, GatewayCompareProc, 0);
        }
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT, IDS_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    // don't save this ip/sub pair
    m_strRemovedGateway = L"";;
    m_uiRemovedMetric = c_dwDefaultMetricOfGateway;

    delete pDlgGate;
    return 0;
}

LRESULT CIpSettingsPage::OnRemoveGate(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    // get the current selected item and remove it
    int itemSelected = ListView_GetNextItem(m_hGatewayListView, -1,
                                            LVNI_SELECTED);

    if (itemSelected != -1)
    {
        WCHAR buf[IP_LIMIT];

        LV_ITEM lvItem;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);

        // save off the removed address and delete it from the listview
        lvItem.mask = LVIF_TEXT;
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        ListView_GetItem(m_hGatewayListView, &lvItem);

        m_strRemovedGateway = buf;

        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        ListView_GetItem(m_hGatewayListView, &lvItem);

        m_uiRemovedMetric = (UINT)lvItem.lParam;

        SendDlgItemMessage(IDC_IPADDR_GATE, LVM_DELETEITEM,
                           (WPARAM)itemSelected, 0);
        ListView_SetItemState(m_hGatewayListView, 0, LVIS_SELECTED,
                              LVIS_SELECTED);

        SetGatewayButtons();
        PageModified();
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT,
                 IDS_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    return 0;
}

LRESULT CIpSettingsPage::OnAutoMetric(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    BOOL fEnable = FALSE;
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:
        fEnable = !IsDlgButtonChecked(IDC_AUTO_METRIC);
        ::EnableWindow(GetDlgItem(IDC_STATIC_IF_METRIC), fEnable);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_METRIC), fEnable);

        if (!fEnable)
        {
            ::SetWindowText(GetDlgItem(IDC_IPADDR_METRIC), _T(""));
        }

        PageModified();
        break;
    }

    return 0;
}

void CIpSettingsPage::SetIpInfo()
{
    Assert(m_hIpListView);

    BOOL ret = ListView_DeleteAllItems(m_hIpListView);
    Assert(ret);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    // if DHCP is enabled, show it in the listview
    if (m_pAdapterInfo->m_fEnableDhcp)
    {
        EnableIpButtons(FALSE);

        lvItem.iItem=0;
        lvItem.iSubItem=0;
        lvItem.pszText=(PWSTR)SzLoadIds(IDS_DHCPENABLED_TEXT);

        SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

    }
    else
    {
        EnableIpButtons(TRUE);

        VSTR_ITER iterIpAddress = m_pAdapterInfo->m_vstrIpAddresses.begin();
        VSTR_ITER iterSubnetMask = m_pAdapterInfo->m_vstrSubnetMask.begin();

        int item=0;

        for(; iterIpAddress != m_pAdapterInfo->m_vstrIpAddresses.end() ;
            ++iterIpAddress, ++iterSubnetMask)
        {
            if(**iterIpAddress == L"")
                continue;

            // Add the IP address to the list box
            lvItem.iItem=item;
            lvItem.iSubItem=0;
            lvItem.pszText=(PWSTR)(*iterIpAddress)->c_str();

            SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_INSERTITEM,
                               item, (LPARAM)&lvItem);

            // Add the subnet and increment the item
            tstring strSubnetMask;

            if (iterSubnetMask == m_pAdapterInfo->m_vstrSubnetMask.end())
                strSubnetMask = L"0.0.0.0";
            else
                strSubnetMask = **iterSubnetMask;

            lvItem.iItem=item;
            lvItem.iSubItem=1;
            lvItem.pszText=(PWSTR)strSubnetMask.c_str();

            SendDlgItemMessage(IDC_IPADDR_ADVIP, LVM_SETITEMTEXT,
                               item, (LPARAM)&lvItem);
            ++item;
        }
    }
}

void CIpSettingsPage::SetIpButtons()
{
    if (!m_pAdapterInfo->m_fEnableDhcp)
    {
        Assert(m_hRemoveIp);
        Assert(m_hEditIp);
        Assert(m_hAddIp);
        Assert(m_hIpListView);

        int nCount = ListView_GetItemCount(m_hIpListView);

        ::EnableWindow(m_hRemoveIp, nCount);
        ::EnableWindow(m_hEditIp, nCount);

        if (nCount == 0)
        {
            // remove the default on the remove button
            ::SendMessage(m_hRemoveIp, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

            ::SetFocus(m_hIpListView);
        }
    }
}

void CIpSettingsPage::SetGatewayButtons()
{
    int nCount = ListView_GetItemCount(m_hGatewayListView);

    ::EnableWindow(m_hAddGateway, nCount < MAX_GATEWAY);
    ::EnableWindow(m_hRemoveGateway, nCount);
    ::EnableWindow(m_hEditGateway, nCount);

    if (nCount == 0)
    {
        // remove the default on the remove button
        ::SendMessage(m_hRemoveGateway, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

        ::SetFocus(m_hGatewayListView);
    }
    else if (nCount == MAX_GATEWAY)
    {
        ::SetFocus(m_hEditGateway);
    }
}

void CIpSettingsPage::UpdateGatewayList()
{
    // update the gateway address list for the specified adapter
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrDefaultGateway);
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrDefaultGatewayMetric);

    int nCount = ListView_GetItemCount(m_hGatewayListView);

    for (int j=0; j< nCount; j++)
    {
        WCHAR buf[IP_LIMIT];
        LV_ITEM lvItem;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        lvItem.iItem = j;

        lvItem.mask = LVIF_TEXT;
        lvItem.iSubItem = 0;
        ListView_GetItem(m_hGatewayListView, &lvItem);
        m_pAdapterInfo->m_vstrDefaultGateway.push_back(new tstring(buf));

        lvItem.mask = LVIF_PARAM;
        lvItem.iSubItem = 1;
        ListView_GetItem(m_hGatewayListView, &lvItem);
        _ltot((INT)lvItem.lParam, buf, 10);
        m_pAdapterInfo->m_vstrDefaultGatewayMetric.push_back(new tstring(buf));
    }
}

void CIpSettingsPage::SetGatewayInfo()
{
    Assert(m_hGatewayListView);

    BOOL ret = ListView_DeleteAllItems(m_hGatewayListView);
    Assert(ret);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    VSTR_ITER iterGateway = m_pAdapterInfo->m_vstrDefaultGateway.begin();
    VSTR_ITER iterMetric = m_pAdapterInfo->m_vstrDefaultGatewayMetric.begin();

    WCHAR buf[256] = {0};

    int cItem = 0;
    for(; iterGateway != m_pAdapterInfo->m_vstrDefaultGateway.end() ;
        ++iterGateway )
    {
        if(**iterGateway == L"")
            continue;

        lvItem.iItem=cItem;
        lvItem.iSubItem=0;
        lvItem.pszText=(PWSTR)(*iterGateway)->c_str();
        if (iterMetric == m_pAdapterInfo->m_vstrDefaultGatewayMetric.end())
        {
            lvItem.lParam = (LPARAM)c_dwDefaultMetricOfGateway;
        }
        else
        {
            PWSTR pszEnd;
            lvItem.lParam = wcstoul((*iterMetric)->c_str(), &pszEnd, 0);
            if (!lvItem.lParam)
                lvItem.lParam = (LPARAM)c_dwDefaultMetricOfGateway;
            ++iterMetric;
        }

        cItem = (int)SendDlgItemMessage(IDC_IPADDR_GATE, LVM_INSERTITEM,
                                          0, (LPARAM)&lvItem);
        lvItem.iItem = cItem;
        lvItem.iSubItem=1;
        lvItem.pszText = buf;

        if (0 == lvItem.lParam)
        {
            lstrcpynW(buf, SzLoadIds(IDS_AUTO_GW_METRIC), celems(buf));
        }
        else
        {
            _ltot((INT)lvItem.lParam, buf, 10);
        }

        
        SendDlgItemMessage(IDC_IPADDR_GATE, LVM_SETITEMTEXT,
                           lvItem.iItem, (LPARAM)&lvItem);
        cItem++;
    }

    ListView_SortItems(m_hGatewayListView, GatewayCompareProc, 0);
    ListView_SetItemState(m_hGatewayListView, 0, LVIS_SELECTED, LVIS_SELECTED);
}

void CIpSettingsPage::EnableIpButtons(BOOL fState)
{
    Assert(m_hAddIp);
    Assert(m_hEditIp);
    Assert(m_hRemoveIp);

    if (m_hAddIp && m_hEditIp && m_hRemoveIp)
    {
        ::EnableWindow(m_hAddIp, fState);
        ::EnableWindow(m_hEditIp, fState);
        ::EnableWindow(m_hRemoveIp, fState);
    }
}

////////////////////////////////////////////////////////////////////
/// Add, Edit, and Remove dialog for IP address
/// Dialog creation overides
//
//  iIndex - the index of the IP address in the list view of the parent dlg
//              -1 if this is a new address
CAddressDialog::CAddressDialog(CIpSettingsPage * pDlgAdv,
                               const DWORD* adwHelpIDs,
                               int iIndex)
{
    m_pParentDlg = pDlgAdv;
    m_hButton = 0;

    m_adwHelpIDs = adwHelpIDs;
    m_iIndex = iIndex;
}

LRESULT CAddressDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    // replace the "Text" button with the add or edit
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAdd.c_str());

    m_ipAddress.Create(m_hWnd,IDC_IPADDR_ADV_CHANGEIP_IP);
    m_ipAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    m_ipSubnetMask.Create(m_hWnd, IDC_IPADDR_ADV_CHANGEIP_SUB);

    // if editing an ip address fill the controls with the current information
    // if removing an ip address save it and fill the add dialog with it next time

    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_IPADDR_ADVIP);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                 SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_hButton = GetDlgItem(IDOK);

    // add the address that was just removed
    if (m_strNewIpAddress.size())
    {
        m_ipAddress.SetAddress(m_strNewIpAddress.c_str());
        m_ipSubnetMask.SetAddress(m_strNewSubnetMask.c_str());
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_strNewIpAddress = L"";
        m_strNewSubnetMask = L"";
        // the ip and subnet are blank, so there's nothing to add
        ::EnableWindow(m_hButton, FALSE);
    }

    return 0;
}

LRESULT CAddressDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAddressDialog::OnHelp(UINT uMsg, WPARAM wParam,
                               LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CAddressDialog::OnChangeIp(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case EN_CHANGE:
        OnIpChange();
        break;

    case EN_SETFOCUS:
        OnEditSetFocus(IDC_IPADDR_ADV_CHANGEIP_IP);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAddressDialog::OnChangeSub(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case EN_CHANGE:
        OnSubnetChange();
        break;

    case EN_SETFOCUS:
        OnEditSetFocus(IDC_IPADDR_ADV_CHANGEIP_SUB);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAddressDialog::OnIpFieldChange(int idCtrl, LPNMHDR pnmh,
                                        BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    switch(idCtrl)
    {
    case IDC_IPADDR_ADV_CHANGEIP_IP:
        lpnmipa = (LPNMIPADDRESS) pnmh;

        if (0==lpnmipa->iField)
        {
            iLow  = c_iIPADDR_FIELD_1_LOW;
            iHigh = c_iIPADDR_FIELD_1_HIGH;
        };

        IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh, TRUE);

        break;

    case IDC_IPADDR_ADV_CHANGEIP_SUB:

        lpnmipa = (LPNMIPADDRESS) pnmh;
        IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);
        break;

    default:
        break;
    }

    return 0;
}


void CAddressDialog::OnIpChange()
{
    Assert(m_hButton);

    if (m_ipAddress.IsBlank())
        ::EnableWindow(m_hButton, FALSE);
    else
        ::EnableWindow(m_hButton, TRUE);
}

void CAddressDialog::OnSubnetChange()
{
    OnIpChange();
}

void CAddressDialog::OnEditSetFocus(WORD nId)
{
    if (nId != IDC_IPADDR_ADV_CHANGEIP_SUB)
        return;

    tstring strSubnetMask;
    tstring strIpAddress;

    // if the subnet mask is blank, create a mask and insert it into the control
    if (!m_ipAddress.IsBlank() && m_ipSubnetMask.IsBlank())
    {
        m_ipAddress.GetAddress(&strIpAddress);

        // generate the mask and update the control, and internal structure
        GenerateSubnetMask(m_ipAddress, &strSubnetMask);
        m_ipSubnetMask.SetAddress(strSubnetMask.c_str());
    }
}

LRESULT CAddressDialog::OnOk(WORD wNotifyCode, WORD wID,
                             HWND hWndCtl, BOOL& fHandled)
{
    // set the subnet Mask
    OnEditSetFocus(IDC_IPADDR_ADV_CHANGEIP_SUB);
    tstring strIp;
    tstring strSubnetMask;

    // Get the current address from the control and add them to the adapter if valid
    m_ipAddress.GetAddress(&strIp);
    m_ipSubnetMask.GetAddress(&strSubnetMask);

    if (!IsContiguousSubnet(strSubnetMask.c_str()))
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 IDS_ERROR_UNCONTIGUOUS_SUBNET,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        ::SetFocus(m_ipSubnetMask);
        return 0;
    }

    IP_VALIDATION_ERR err = IsValidIpandSubnet(strIp.c_str(), strSubnetMask.c_str());

    if (ERR_NONE != err)
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 GetIPValidationErrorMessageID(err),
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        ::SetFocus(m_ipAddress);
        return 0;
    }
    

    int     iIndex = SearchListViewItem(m_pParentDlg->m_hIpListView, 0, strIp.c_str());
    if (-1 != iIndex && iIndex != m_iIndex)
    {
        NcMsgBox(::GetActiveWindow(),
                IDS_MSFT_TCP_TEXT,
                IDS_DUP_IPADDRESS,
                MB_APPLMODAL | MB_ICONSTOP | MB_OK,
                strIp.c_str());
        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE)
    {
        // Get the current address from the control and add them to the adapter if valid
        m_strNewIpAddress = strIp;
        m_strNewSubnetMask = strSubnetMask;
        m_pParentDlg->m_fModified = TRUE;

        EndDialog(IDOK);
    }
    else // see if either changed
    {
        if (strIp != m_strNewIpAddress || strSubnetMask != m_strNewSubnetMask)
        {
            m_strNewIpAddress = strIp; // update save addresses
            m_strNewSubnetMask = strSubnetMask;
            m_pParentDlg->m_fModified = TRUE;

            EndDialog(IDOK);
        }
        else
        {
            EndDialog(IDCANCEL);
        }
    }

    return 0;
}

LRESULT CAddressDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CAddressDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
    
    return 0;
}
///////////////////////////////////////////////////////////////////////////////
/// Add, Edit, and Remove dialog for Gateway address
/// Dialog creation overides

CGatewayDialog::CGatewayDialog(CIpSettingsPage * pDlgAdv,
                               const DWORD* adwHelpIDs,
                               int  iIndex) :
    m_fValidMetric(TRUE),
    m_iIndex (iIndex)
{
    m_pParentDlg = pDlgAdv;
    m_hButton = 0;

    m_adwHelpIDs = adwHelpIDs;
}

LRESULT CGatewayDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    // replace the "Text" button with the add or edit

    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAdd.c_str());

    m_ipGateAddress.Create(m_hWnd,IDC_IPADDR_ADV_CHANGE_GATEWAY);
    m_ipGateAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);
    SendDlgItemMessage(IDC_IPADDR_ADV_CHANGE_METRIC, EM_LIMITTEXT, MAX_METRIC_DIGITS, 0);

    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_IPADDR_GATE);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_hButton = GetDlgItem(IDOK);

    // add the address that was just removed
    if (m_strNewGate.size())
    {
        m_ipGateAddress.SetAddress(m_strNewGate.c_str());
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_strNewGate = L"";
        ::EnableWindow(m_hButton, FALSE);
    }

    //initialize the metric controls
    BOOL fAutoMetric = (0 == m_uiNewMetric);
    CheckDlgButton(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC, fAutoMetric);
    if (fAutoMetric)
    {
        SetDlgItemText(IDC_IPADDR_ADV_CHANGE_METRIC, L"");
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC), FALSE);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC_STATIC), FALSE);
    }
    else
    {
        SetDlgItemInt(IDC_IPADDR_ADV_CHANGE_METRIC, m_uiNewMetric);
    }
    m_fValidMetric = TRUE;

    return TRUE;
}

LRESULT CGatewayDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CGatewayDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CGatewayDialog::OnGatewayChange(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:

        Assert(m_hButton);

        if (m_ipGateAddress.IsBlank() || !m_fValidMetric)
            ::EnableWindow(m_hButton, FALSE);
        else
            ::EnableWindow(m_hButton, TRUE);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CGatewayDialog::OnMetricChange(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:

        if (!IsDlgButtonChecked(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC))
        {
            BOOL bTranslated;
            UINT nValue;

            nValue = GetDlgItemInt(IDC_IPADDR_ADV_CHANGE_METRIC, &bTranslated,
                               FALSE);
            m_fValidMetric = bTranslated;
            if (!m_fValidMetric || m_ipGateAddress.IsBlank())
                ::EnableWindow(m_hButton, FALSE);
            else
                ::EnableWindow(m_hButton, TRUE);
        }
       
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CGatewayDialog::OnIpFieldChange(int idCtrl, LPNMHDR pnmh,
                                        BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa = (LPNMIPADDRESS) pnmh;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    if (0==lpnmipa->iField)
    {
        iLow  = c_iIPADDR_FIELD_1_LOW;
        iHigh = c_iIPADDR_FIELD_1_HIGH;
    };


    IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh, TRUE);

    return 0;
}

LRESULT CGatewayDialog::OnOk(WORD wNotifyCode, WORD wID,
                             HWND hWndCtl, BOOL& fHandled)
{
    tstring strGateway;
    m_ipGateAddress.GetAddress(&strGateway);

    // Validate
    if (!FIsIpInRange(strGateway.c_str()))
    {
        // makes ip address lose focus so the control gets
        // IPN_FIELDCHANGED notification
        // also makes it consistent for when short-cut is used
        ::SetFocus(m_hButton);

        return 0;
    }

    int iIndex = -1;
    iIndex = SearchListViewItem(m_pParentDlg->m_hGatewayListView, 0, strGateway.c_str());
    if (-1 != iIndex && iIndex != m_iIndex)
    {
        NcMsgBox(::GetActiveWindow(),
                IDS_MSFT_TCP_TEXT,
                IDS_DUP_GATEWAY,
                MB_APPLMODAL | MB_ICONSTOP | MB_OK,
                strGateway.c_str());

        return 0;
    }

    BOOL bTranslated;

    UINT uiMetric = 0;
    //Get the metric. If auto-metric is selected, the metric valud is 0.
    //Otherwise get the metric value from the edit control
    if (!IsDlgButtonChecked(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC))
    {
        uiMetric = GetDlgItemInt(IDC_IPADDR_ADV_CHANGE_METRIC, 
                                    &bTranslated,
                                    FALSE);
        if (uiMetric < 1 || uiMetric > MAX_METRIC)
        {
            HWND hFocus = NULL;
            TCHAR szBuf[32] = {0};
            wsprintf(szBuf, L"%u", MAX_METRIC);
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_METRIC,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK, szBuf);
            hFocus = GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC);
            if (hFocus)
            {
                ::SetFocus(hFocus);
            }
            return 0;
        }
    }
    
    if (m_pParentDlg->m_fEditState == FALSE)
    {
        // Get the current address from the control and add them to the adapter if valid
        m_strNewGate = strGateway;
        m_uiNewMetric = uiMetric;
        m_pParentDlg->m_fModified = TRUE;

        EndDialog(IDOK);
    }
    else // see if either changed
    {
        if (strGateway != m_strNewGate || uiMetric != m_uiNewMetric)
        {
            m_pParentDlg->m_fModified = TRUE;
            m_strNewGate = strGateway;
            m_uiNewMetric = uiMetric;

            EndDialog(IDOK);
        }
        else
        {
            EndDialog(IDCANCEL);
        }
    }

    return 0;
}

LRESULT CGatewayDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CGatewayDialog::OnAutoMetric(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    BOOL fEnable = FALSE;
    BOOL bTranslated;
    UINT nValue;
    
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:
        fEnable = !IsDlgButtonChecked(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC_STATIC), fEnable);
        ::EnableWindow(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC), fEnable);

        if (!fEnable)
        {
            ::SetWindowText(GetDlgItem(IDC_IPADDR_ADV_CHANGE_METRIC), _T(""));
            m_fValidMetric = TRUE;
        }
        else
        {
            nValue = GetDlgItemInt(IDC_IPADDR_ADV_CHANGE_METRIC, &bTranslated,
                               FALSE);

            m_fValidMetric = bTranslated;
        }


        if (m_ipGateAddress.IsBlank())
        {
            ::EnableWindow(m_hButton, FALSE);
        }
        else if (!fEnable)
        {
            //if the ip address has been filled in and we are using auto-metric,
            //enable the "OK" button
            ::EnableWindow(m_hButton, TRUE);
        }
        else
        {
            //if the address has been fileed in and we are using manual metric,
            //disable the "OK" button when the metric edit box doesn't contain
            //valid number
            
            ::EnableWindow(m_hButton, m_fValidMetric);
        }

        
        break;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CGatewayDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgatm.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A T M . C P P
//
//  Contents:   CTcpArpcPage and CATMAddressDialog implementation
//
//  Notes:  The "ARP Client" page and dialog
//
//  Author: tongl  1 July 1997  Created
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "tcpconst.h"
#include "tcpmacro.h"
#include "tcputil.h"
#include "tcphelp.h"

#include "atmcommon.h"

#include "dlgatm.h"
#include "dlgaddr.h"

/////////////////////////////////////////////////////////////////
//
// CAtmArpcPage
//
/////////////////////////////////////////////////////////////////

// Message map functions
LRESULT CAtmArpcPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    m_hMTUEditBox = GetDlgItem(IDC_EDT_ATM_MaxTU);
    Assert(m_hMTUEditBox);

    // ARP Server
    m_hArps.m_hList      = GetDlgItem(IDC_LBX_ATM_ArpsAddrs);
    m_hArps.m_hAdd       = GetDlgItem(IDC_PSB_ATM_ArpsAdd);
    m_hArps.m_hEdit      = GetDlgItem(IDC_PSB_ATM_ArpsEdt);
    m_hArps.m_hRemove    = GetDlgItem(IDC_PSB_ATM_ArpsRmv);
    m_hArps.m_hUp        = GetDlgItem(IDC_PSB_ATM_ArpsUp);
    m_hArps.m_hDown      = GetDlgItem(IDC_PSB_ATM_ArpsDown);

    // MAR Server
    m_hMars.m_hList       = GetDlgItem(IDC_LBX_ATM_MarsAddrs);
    m_hMars.m_hAdd        = GetDlgItem(IDC_PSB_ATM_MarsAdd);
    m_hMars.m_hEdit       = GetDlgItem(IDC_PSB_ATM_MarsEdt);
    m_hMars.m_hRemove     = GetDlgItem(IDC_PSB_ATM_MarsRmv);
    m_hMars.m_hUp         = GetDlgItem(IDC_PSB_ATM_MarsUp);
    m_hMars.m_hDown       = GetDlgItem(IDC_PSB_ATM_MarsDown);

    // Set the up\down arrow icons
    SendDlgItemMessage(IDC_PSB_ATM_ArpsUp, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_PSB_ATM_ArpsDown, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    SendDlgItemMessage(IDC_PSB_ATM_MarsUp, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_PSB_ATM_MarsDown, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    // Set MTU edit box length
    ::SendMessage(m_hMTUEditBox, EM_SETLIMITTEXT, MAX_MTU_LENGTH, 0);

    return 0;
}

LRESULT CAtmArpcPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAtmArpcPage::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// Notify handlers for the property page
LRESULT CAtmArpcPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    SetInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, 0);
    return 0;
}

LRESULT CAtmArpcPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // All error values are loaded and then checked here
    // while all non-error values are checked in OnApply
    BOOL err = FALSE; // Allow page to lose active status

    // In non-PVC only mode, if either of the list boxes (ARPS or MARS)
    // is empty for any bound atm card, we can't leave the page.
    if (BST_UNCHECKED == IsDlgButtonChecked(IDC_CHK_ATM_PVCONLY))
    {
        int nArps = Tcp_ListBox_GetCount(m_hArps.m_hList);
        int nMars = Tcp_ListBox_GetCount(m_hMars.m_hList);

        if ((nArps==0) || (nMars ==0))
        {
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_ATMSERVERLIST,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            err = TRUE;
        }
    }

    // MTU value
    WCHAR szData[MAX_MTU_LENGTH+1];
    szData[0]= 0;
    ::GetWindowText(GetDlgItem(IDC_EDT_ATM_MaxTU), szData, MAX_MTU_LENGTH+1);

    // check the range of the number
    PWSTR pStr;
    unsigned long num = wcstoul(szData, &pStr, 10);

    int nId = IDS_MTU_RANGE_WORD;

    if (num < MIN_MTU || num > MAX_MTU)
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 nId,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
        ::SetFocus(m_hMTUEditBox);

        err = TRUE;
    }

    if (!err)
    {
        UpdateInfo();
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CAtmArpcPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    UpdateInfo();

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    // reset status
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CAtmArpcPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CAtmArpcPage::OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

// Control message handlers

// PVC Only
LRESULT CAtmArpcPage::OnPVCOnly(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    BOOL fChecked = (BST_CHECKED == IsDlgButtonChecked(IDC_CHK_ATM_PVCONLY));
    if (fChecked != m_pAdapterInfo->m_fPVCOnly)
    {
        PageModified();
    }

    EnableGroup(!fChecked);

    return 0;
}

// ARP server controls
LRESULT CAtmArpcPage::OnArpServer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hArps, NUM_ATMSERVER_LIMIT);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAtmArpcPage::OnAddArps(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    m_hAddressList = m_hArps.m_hList;
    OnServerAdd(m_hArps, SzLoadIds(IDS_TCPATM_ARP_SERVER));
    return 0;
}

LRESULT CAtmArpcPage::OnEditArps(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    m_hAddressList = m_hArps.m_hList;
    OnServerEdit(m_hArps, SzLoadIds(IDS_TCPATM_ARP_SERVER));
    return 0;
}

LRESULT CAtmArpcPage::OnRemoveArps(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    BOOL fRemoveArps = TRUE;
    OnServerRemove(m_hArps, fRemoveArps);
    return 0;
}

LRESULT CAtmArpcPage::OnArpsUp(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    OnServerUp(m_hArps);
    return 0;
}

LRESULT CAtmArpcPage::OnArpsDown(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    OnServerDown(m_hArps);
    return 0;
}

// MAR server controls
LRESULT CAtmArpcPage::OnMarServer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hMars, NUM_ATMSERVER_LIMIT);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAtmArpcPage::OnAddMars(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    m_hAddressList = m_hMars.m_hList;
    OnServerAdd(m_hMars, SzLoadIds(IDS_TCPATM_MAR_SERVER));
    return 0;
}

LRESULT CAtmArpcPage::OnEditMars(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    m_hAddressList = m_hMars.m_hList;
    OnServerEdit(m_hMars, SzLoadIds(IDS_TCPATM_MAR_SERVER));
    return 0;
}

LRESULT CAtmArpcPage::OnRemoveMars(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    BOOL fRemoveArps = FALSE;
    OnServerRemove(m_hMars, fRemoveArps);
    return 0;
}

LRESULT CAtmArpcPage::OnMarsUp(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    OnServerUp(m_hMars);
    return 0;
}

LRESULT CAtmArpcPage::OnMarsDown(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    OnServerDown(m_hMars);
    return 0;
}

LRESULT CAtmArpcPage::OnMaxTU(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case EN_CHANGE:
            PageModified();
            break;
    }
    return 0;
}
//
// Helper functions
//

// Update the server addresses and MTU of the deselected card
void CAtmArpcPage::UpdateInfo()
{
    // PVC Only
    m_pAdapterInfo->m_fPVCOnly =
        (BST_CHECKED == IsDlgButtonChecked(IDC_CHK_ATM_PVCONLY));

    // Update ARP server address
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrARPServerList);
    int nCount = Tcp_ListBox_GetCount(m_hArps.m_hList);

    WCHAR szARPS[MAX_ATM_ADDRESS_LENGTH+1];
    for (int i=0; i< nCount; i++)
    {
        Tcp_ListBox_GetText(m_hArps.m_hList, i, szARPS);
        m_pAdapterInfo->m_vstrARPServerList.push_back(new tstring(szARPS));
    }

    // Update MAR server address
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrMARServerList);
    nCount = Tcp_ListBox_GetCount(m_hMars.m_hList);

    WCHAR szMARS[MAX_ATM_ADDRESS_LENGTH+1];
    for (i=0; i< nCount; i++)
    {
        Tcp_ListBox_GetText(m_hMars.m_hList, i, szMARS);
        m_pAdapterInfo->m_vstrMARServerList.push_back(new tstring(szMARS));
    }

    // MTU
    WCHAR szMTU[MAX_MTU_LENGTH+1];
    GetDlgItemText(IDC_EDT_ATM_MaxTU, szMTU, MAX_MTU_LENGTH+1);
    m_pAdapterInfo->m_dwMTU = _wtoi(szMTU);
}

// Set the other controls according to the current adapter
void CAtmArpcPage::SetInfo()
{
    Assert(m_pAdapterInfo);

    if (m_pAdapterInfo != NULL)
    {
        Assert (m_pAdapterInfo->m_fIsAtmAdapter);

        if (m_pAdapterInfo->m_fIsAtmAdapter)
        {
            // ARP server IDC_LBX_ATM_ArpsAddrs
            int nResult;

            Tcp_ListBox_ResetContent(m_hArps.m_hList);

            for(VSTR_ITER iterARPServer = m_pAdapterInfo->m_vstrARPServerList.begin();
                iterARPServer != m_pAdapterInfo->m_vstrARPServerList.end() ;
                ++iterARPServer)
            {
                nResult = Tcp_ListBox_InsertString(m_hArps.m_hList, -1,
                                                   (*iterARPServer)->c_str());
            }

            // set slection to first item
            if (nResult >= 0)
                Tcp_ListBox_SetCurSel(m_hArps.m_hList, 0);

            // MAR server IDC_LBX_ATM_MarsAddrs
            Tcp_ListBox_ResetContent(m_hMars.m_hList);

            for(VSTR_ITER iterMARServer = m_pAdapterInfo->m_vstrMARServerList.begin();
                iterMARServer != m_pAdapterInfo->m_vstrMARServerList.end() ;
                ++iterMARServer)
            {
                nResult = Tcp_ListBox_InsertString(m_hMars.m_hList, -1,
                                                   (*iterMARServer)->c_str());
            }

            // set slection to first item
            if (nResult >= 0)
                Tcp_ListBox_SetCurSel(m_hMars.m_hList, 0);

            // MTU
            WCHAR szBuf[MAX_MTU_LENGTH];
            wsprintfW(szBuf, c_szItoa, m_pAdapterInfo->m_dwMTU);
            SetDlgItemText(IDC_EDT_ATM_MaxTU, szBuf);

            // Set push buttons state
            SetButtons(m_hArps, NUM_ATMSERVER_LIMIT);
            SetButtons(m_hMars, NUM_ATMSERVER_LIMIT);

            // Set PVC Only check box
            CheckDlgButton(IDC_CHK_ATM_PVCONLY, m_pAdapterInfo->m_fPVCOnly);
            if(m_pAdapterInfo->m_fPVCOnly)
            {
                EnableGroup(FALSE);
            }
        }
    }
    return;
}

void CAtmArpcPage::EnableGroup(BOOL fEnable)
{
    ::EnableWindow(GetDlgItem(IDC_LBX_ATM_ArpsAddrs), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsAdd), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsEdt), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsRmv), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsUp), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_ArpsDown), fEnable);

    ::EnableWindow(GetDlgItem(IDC_LBX_ATM_MarsAddrs), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsAdd), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsEdt), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsRmv), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsUp), fEnable);
    ::EnableWindow(GetDlgItem(IDC_PSB_ATM_MarsDown), fEnable);

    if (fEnable)
    {
        // Set push buttons state
        SetButtons(m_hArps, NUM_ATMSERVER_LIMIT);
        SetButtons(m_hMars, NUM_ATMSERVER_LIMIT);
    }
}

void CAtmArpcPage::OnServerAdd(HANDLES hGroup, PCTSTR pszTitle)
{
    m_fEditState = FALSE;
    CAtmAddressDialog * pDlgSrv = new CAtmAddressDialog(this, g_aHelpIDs_IDD_ATM_ADDR);

    pDlgSrv->SetTitle(pszTitle);

    if (pDlgSrv->DoModal() == IDOK)
    {
        tstring strNewAddress;
        if (!lstrcmpW(pszTitle, SzLoadIds(IDS_TCPATM_ARP_SERVER)))
        {
            strNewAddress = m_strNewArpsAddress;

            // empty strings, this removes the saved address
            m_strNewArpsAddress = c_szEmpty;
        }
        else
        {
            Assert(!lstrcmpW(pszTitle, SzLoadIds(IDS_TCPATM_MAR_SERVER)));
            strNewAddress = m_strNewMarsAddress;

            // empty strings, this removes the saved address
            m_strNewMarsAddress = c_szEmpty;
        }
        int idx = Tcp_ListBox_InsertString(hGroup.m_hList,
                                           -1,
                                           strNewAddress.c_str());

        PageModified();

        Assert(idx >= 0);
        if (idx >= 0)
        {
            Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
            SetButtons(hGroup, NUM_ATMSERVER_LIMIT);
        }
    }

    // release dialog object
    delete pDlgSrv;
}

void CAtmArpcPage::OnServerEdit(HANDLES hGroup, PCWSTR pszTitle)
{
    m_fEditState = TRUE;
    Assert(Tcp_ListBox_GetCount(hGroup.m_hList));

    int idx = Tcp_ListBox_GetCurSel(hGroup.m_hList);
    Assert(idx >= 0);

    // save off the removed address and delete it from the listview
    if (idx >= 0)
    {
        WCHAR buf[MAX_ATM_ADDRESS_LENGTH+1];

        Assert(Tcp_ListBox_GetTextLen(hGroup.m_hList, idx) <= celems(buf));
        Tcp_ListBox_GetText(hGroup.m_hList, idx, buf);

        BOOL fEditArps = !lstrcmpW(pszTitle, SzLoadIds(IDS_TCPATM_ARP_SERVER));

        // used by dialog to display what to edit
        if (fEditArps)
        {
            m_strNewArpsAddress = buf;
        }
        else
        {
           m_strNewMarsAddress = buf;
        }

        CAtmAddressDialog * pDlgSrv = new CAtmAddressDialog(this, g_aHelpIDs_IDD_ATM_ADDR);

        pDlgSrv->SetTitle(pszTitle);

        if (pDlgSrv->DoModal() == IDOK)
        {
            // replace the item in the listview with the new information
            Tcp_ListBox_DeleteString(hGroup.m_hList, idx);

            PageModified();

            if (fEditArps)
            {
                m_strMovingEntry = m_strNewArpsAddress;

                // restore the original removed address
                m_strNewArpsAddress = buf;
            }
            else
            {
                m_strMovingEntry = m_strNewMarsAddress;

                // restore the original removed address
                m_strNewMarsAddress = buf;
            }

            ListBoxInsertAfter(hGroup.m_hList, idx, m_strMovingEntry.c_str());
            Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
        }
        else
        {
            // empty strings, this removes the saved address
            if (fEditArps)
            {
                m_strNewArpsAddress = c_szEmpty;
            }
            else
            {
                m_strNewMarsAddress = c_szEmpty;
            }
        }

        delete pDlgSrv;
    }
}

void CAtmArpcPage::OnServerRemove(HANDLES hGroup, BOOL fRemoveArps)
{
    int idx = Tcp_ListBox_GetCurSel(hGroup.m_hList);
    Assert(idx >=0);

    if (idx >=0)
    {
        WCHAR buf[MAX_ATM_ADDRESS_LENGTH+1];
        Assert(Tcp_ListBox_GetTextLen(hGroup.m_hList, idx) <= celems(buf));

        Tcp_ListBox_GetText(hGroup.m_hList, idx, buf);

        if (fRemoveArps)
        {
            m_strNewArpsAddress = buf;
        }
        else
        {
            m_strNewMarsAddress = buf;
        }
        Tcp_ListBox_DeleteString(hGroup.m_hList, idx);

        PageModified();

        // select a new item
        int nCount;
        if ((nCount = Tcp_ListBox_GetCount(hGroup.m_hList)) != LB_ERR)
        {
            // select the previous item in the list
            if (idx)
                --idx;

            Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
        }
        SetButtons(hGroup, NUM_ATMSERVER_LIMIT);
    }
}

void CAtmArpcPage::OnServerUp(HANDLES hGroup)
{
    Assert(m_hArps.m_hList);

    int  nCount = Tcp_ListBox_GetCount(hGroup.m_hList);
    Assert(nCount);

    int idx = Tcp_ListBox_GetCurSel(hGroup.m_hList);
    Assert(idx != 0);

    if (ListBoxRemoveAt(hGroup.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return;
    }

    --idx;
    PageModified();
    ListBoxInsertAfter(hGroup.m_hList, idx, m_strMovingEntry.c_str());

    Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
    SetButtons(hGroup, NUM_ATMSERVER_LIMIT);
}

void CAtmArpcPage::OnServerDown(HANDLES hGroup)
{
    Assert(hGroup.m_hList);

    int nCount = Tcp_ListBox_GetCount(hGroup.m_hList);
    Assert(nCount);

    int idx = Tcp_ListBox_GetCurSel(hGroup.m_hList);
    --nCount;

    Assert(idx != nCount);

    if (ListBoxRemoveAt(hGroup.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return;
    }

    ++idx;
    PageModified();

    ListBoxInsertAfter(hGroup.m_hList, idx, m_strMovingEntry.c_str());
    Tcp_ListBox_SetCurSel(hGroup.m_hList, idx);
    SetButtons(hGroup, NUM_ATMSERVER_LIMIT);
}

/////////////////////////////////////////////////////////////////
//
// CAtmAddressDialog
//
/////////////////////////////////////////////////////////////////

CAtmAddressDialog::CAtmAddressDialog(CAtmArpcPage * pAtmArpcPage, const DWORD* adwHelpIDs)
{
    m_pParentDlg   = pAtmArpcPage;
    m_adwHelpIDs   = adwHelpIDs;
    m_hOkButton    = 0;
};

CAtmAddressDialog::~CAtmAddressDialog(){};

LRESULT CAtmAddressDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& fHandled)
{
    // set title
    SetDlgItemText(IDCST_ATM_AddrName, m_szTitle);

    BOOL fEditArps = !lstrcmpW(m_szTitle, SzLoadIds(IDS_TCPATM_ARP_SERVER));

    // change the "Ok" button to "Add" if we are not editing

    if (FALSE == m_pParentDlg->m_fEditState)
        SetDlgItemText(IDOK, SzLoadIds(IDS_TCPATM_ADD));

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog

    RECT rect;

    Assert(m_pParentDlg->m_hAddressList);
    ::GetWindowRect(m_pParentDlg->m_hAddressList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                                SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handles to the "Ok" button and the edit box
    m_hOkButton =  GetDlgItem(IDOK);
    m_hEditBox  =  GetDlgItem(IDC_EDT_ATM_Address);

    // ATM addresses have a 40 character limit + separaters
    ::SendMessage(m_hEditBox, EM_SETLIMITTEXT, (WPARAM)(MAX_ATM_ADDRESS_LENGTH*1.5), 0);

    // add the address that was just removed
    tstring strNewAddress = fEditArps ? m_pParentDlg->m_strNewArpsAddress : m_pParentDlg->m_strNewMarsAddress;
    if (strNewAddress.size())
    {
        ::SetWindowText(m_hEditBox, strNewAddress.c_str());
        ::SendMessage(m_hEditBox, EM_SETSEL, 0, -1);
        ::EnableWindow(m_hOkButton, TRUE);
    }
    else
    {
        if (fEditArps)
        {
            m_pParentDlg->m_strNewArpsAddress = c_szEmpty;
        }
        else
        {
            m_pParentDlg->m_strNewMarsAddress = c_szEmpty;
        }
        ::EnableWindow(m_hOkButton, FALSE);
    }

    ::SetFocus(m_hEditBox);
    return 0;
}

LRESULT CAtmAddressDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAtmAddressDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// If the "Ok button is pushed
LRESULT CAtmAddressDialog::OnOk(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szAtmAddress[MAX_ATM_ADDRESS_LENGTH+1];
    int i =0;
    int nId =0;

    // Get the current address from the control and
    // add them to the adapter if valid
    ::GetWindowText(m_hEditBox, szAtmAddress, MAX_ATM_ADDRESS_LENGTH+1);

    if (! FIsValidAtmAddress(szAtmAddress, &i, &nId))
    {   // If invalid ATM address, we pop up a message box and set focus
        // back to the edit box

        // REVIEW(tongl): report first invalid character in mesg box
        NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INCORRECT_ATM_ADDRESS,
                                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(GetDlgItem(IDC_EDT_ATM_Address));

        return 0;
    }

    // We check if the newly added or modified string is already in the list,
    // if so, we do not add a duplicate address

    // m_hCurrentAddressList is the handle to either ARPS list or MARS list
    int nCount = Tcp_ListBox_GetCount(m_pParentDlg->m_hAddressList);
    if (nCount) // if the list is not empty
    {
        int i;
        WCHAR szBuff[MAX_ATM_ADDRESS_LENGTH+1];
        for (i=0; i<nCount; i++)
        {
            Tcp_ListBox_GetText(m_pParentDlg->m_hAddressList, i, szBuff);

            if (lstrcmpW(szAtmAddress, szBuff) ==0) // If string is already on the list
            {
                EndDialog(IDCANCEL);
            }
        }
    }

    BOOL fArpsDialog = !lstrcmpW(m_szTitle, SzLoadIds(IDS_TCPATM_ARP_SERVER));
    if (m_pParentDlg->m_fEditState == FALSE) // Add new address
    {
        if (fArpsDialog)
        {
            m_pParentDlg->m_strNewArpsAddress = szAtmAddress;
        }
        else
        {
            m_pParentDlg->m_strNewMarsAddress = szAtmAddress;
        }
    }
    else // if edit, see if string is having a diferent value now
    {
        if (fArpsDialog)
        {
            if(m_pParentDlg->m_strNewArpsAddress != szAtmAddress)
                m_pParentDlg->m_strNewArpsAddress = szAtmAddress; // update save addresses
            else
                EndDialog(IDCANCEL);
        }
        else
        {
            if(m_pParentDlg->m_strNewMarsAddress != szAtmAddress)
                m_pParentDlg->m_strNewMarsAddress = szAtmAddress; // update save addresses
            else
                EndDialog(IDCANCEL);
        }
    }

    EndDialog(IDOK);

    return 0;
}

// If the "Cancel" button is pushed
LRESULT CAtmAddressDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

// If the edit box contents is changed
LRESULT CAtmAddressDialog::OnChange(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    WCHAR buf[2];

    // Enable or disable the "Ok" button
    // based on whether the edit box is empty

    if (::GetWindowText(m_hEditBox, buf, celems(buf)) == 0)
        ::EnableWindow(m_hOkButton, FALSE);
    else
        ::EnableWindow(m_hOkButton, TRUE);

    return 0;
}

void CAtmAddressDialog::SetTitle(PCWSTR pszTitle)
{
    Assert(pszTitle);
    lstrcpyW(m_szTitle, pszTitle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgbkup.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       DLBBKUP.CPP
//
//  Contents:   Implementation for CIpBackUpDlg
//
//  Notes:  CIpBackUpDlg is the modal dialog to handle the fallback static
//			TCP/IP settings
//
//  Author: nsun	02/15/2000
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"
#include "ncreg.h"
#include "resource.h"
#include "tcpconst.h"
//#include "tcphelp.h"
#include "tcpmacro.h"
#include "tcputil.h"

#include "ncbase.h"

#include "dlgbkup.h"
#include "tcperror.h"


//
// CIpBackUpDlg
//
CIpBackUpDlg::CIpBackUpDlg (CTcpipcfg * ptcpip,
							const DWORD* adwHelpIDs) :
m_ptcpip(ptcpip),
m_fModified(FALSE)
{
	m_pAdapterInfo = ptcpip->GetConnectionAdapterInfo();
    m_adwHelpIDs  = adwHelpIDs;
}

CIpBackUpDlg::~CIpBackUpDlg()
{
}

LRESULT CIpBackUpDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{

    // limit the field ranges for the address fields
    m_ipAddr.Create(m_hWnd, IDC_BKUP_IPADDR);
    m_ipAddr.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipMask.Create(m_hWnd, IDC_BKUP_SUBNET);
    
	m_ipDefGw.Create(m_hWnd, IDC_BKUP_GATEWAY);
    m_ipDefGw.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipPrefferredDns.Create(m_hWnd, IDC_BKUP_PREF_DNS);
    m_ipPrefferredDns.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipAlternateDns.Create(m_hWnd, IDC_BKUP_ALT_DNS);
    m_ipAlternateDns.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipPrefferredWins.Create(m_hWnd, IDC_BKUP_WINS1);
    m_ipPrefferredWins.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	m_ipAlternateWins.Create(m_hWnd, IDC_BKUP_WINS2);
    m_ipAlternateWins.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

	int nIdRdbutton;
	if (m_pAdapterInfo->m_BackupInfo.m_fAutoNet)
	{
		nIdRdbutton = IDC_BKUP_RD_AUTO;
	}
	else
	{
		nIdRdbutton = IDC_BKUP_RD_USER;
	}

	CheckDlgButton(IDC_BKUP_RD_AUTO, 
		m_pAdapterInfo->m_BackupInfo.m_fAutoNet ? BST_CHECKED : BST_UNCHECKED);

	CheckDlgButton(IDC_BKUP_RD_USER, 
		m_pAdapterInfo->m_BackupInfo.m_fAutoNet ? BST_UNCHECKED : BST_CHECKED);

	if (!m_pAdapterInfo->m_BackupInfo.m_fAutoNet)
	{
		m_ipAddr.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strIpAddr.c_str());
		m_ipMask.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strSubnetMask.c_str());
		m_ipDefGw.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strDefGw.c_str());
		m_ipPrefferredDns.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strPreferredDns.c_str());
		m_ipAlternateDns.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strAlternateDns.c_str());
		m_ipPrefferredWins.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strPreferredWins.c_str());
		m_ipAlternateWins.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strAlternateWins.c_str());
	}

	EnableControls();

	m_fModified = FALSE;
    return 0;
}

LRESULT CIpBackUpDlg::OnDestroyDialog(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{

    return 0;
}

LRESULT CIpBackUpDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);

    return 0;
}

LRESULT CIpBackUpDlg::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}


LRESULT CIpBackUpDlg::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CIpBackUpDlg::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

	BOOL fError = FALSE; // Allow page to lose active status
    HWND hWndFocus = 0;


    // If the ip address and subnet mask on this page mismatch,
    // just raise error and do not update the UI

    if (m_ipAddr.IsBlank() && !m_ipMask.IsBlank())
    {
        NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_IP,
                   MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        hWndFocus = (HWND) m_ipAddr;
        fError = TRUE;
    }
    else if (!m_ipAddr.IsBlank() && m_ipMask.IsBlank())
    {
        NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NOSUBNET,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        hWndFocus = (HWND) m_ipMask;
        fError = TRUE;
    }

    // Now, update in memory structure
    if (!fError && m_fModified)
    {
        UpdateInfo();

		if (!m_pAdapterInfo->m_BackupInfo.m_fAutoNet)
		{
			IP_VALIDATION_ERR err = IsValidIpandSubnet(m_pAdapterInfo->m_BackupInfo.m_strIpAddr.c_str(),
									m_pAdapterInfo->m_BackupInfo.m_strSubnetMask.c_str());

	        // validate IP address and subnet mask
			if (ERR_NONE != err)
			{
				
	            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, GetIPValidationErrorMessageID(err),
	                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

				fError = TRUE;
	            hWndFocus = (HWND) m_ipMask;
			}

			if (!fError && !IsContiguousSubnet(m_pAdapterInfo->m_BackupInfo.m_strSubnetMask.c_str()))
			{
				NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_ERROR_UNCONTIGUOUS_SUBNET,
	                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

				fError = TRUE;
	            hWndFocus = (HWND) m_ipMask;			
			}
		}
    }

    //we need to change focus to the control that contains invalidate data
    if (fError && hWndFocus)
        ::SetFocus(hWndFocus);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

LRESULT CIpBackUpDlg::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
	BOOL nResult = PSNRET_NOERROR;
	if (m_fModified)
    {
		m_pAdapterInfo->m_fBackUpSettingChanged = TRUE;
		m_ptcpip->SetSecondMemoryModified();
		m_fModified = FALSE;   // this page is no longer modified
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}


LRESULT CIpBackUpDlg::OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    switch(idCtrl)
    {
    case IDC_BKUP_IPADDR:
    case IDC_BKUP_GATEWAY:
    case IDC_BKUP_PREF_DNS:
    case IDC_BKUP_ALT_DNS:
	case IDC_BKUP_WINS1:
	case IDC_BKUP_WINS2:

        lpnmipa = (LPNMIPADDRESS) pnmh;

        if (0==lpnmipa->iField)
        {
            iLow  = c_iIPADDR_FIELD_1_LOW;
            iHigh = c_iIPADDR_FIELD_1_HIGH;
        };

        IpCheckRange(lpnmipa, 
					m_hWnd, 
					iLow, 
					iHigh, 
					(IDC_BKUP_IPADDR == idCtrl || IDC_BKUP_GATEWAY == idCtrl)
					);
        break;

    case IDC_BKUP_SUBNET:

        lpnmipa = (LPNMIPADDRESS) pnmh;
        IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);
        break;

    default:
        break;
    }

    return 0;
}

void CIpBackUpDlg::UpdateInfo()
{
	m_pAdapterInfo->m_BackupInfo.m_fAutoNet = IsDlgButtonChecked(IDC_BKUP_RD_AUTO);
	if (!m_pAdapterInfo->m_BackupInfo.m_fAutoNet)
	{
		GetIpCtrlAddress(m_ipAddr, &m_pAdapterInfo->m_BackupInfo.m_strIpAddr);
		GetIpCtrlAddress(m_ipMask, &m_pAdapterInfo->m_BackupInfo.m_strSubnetMask);
		GetIpCtrlAddress(m_ipDefGw, &m_pAdapterInfo->m_BackupInfo.m_strDefGw);
		GetIpCtrlAddress(m_ipPrefferredDns, &m_pAdapterInfo->m_BackupInfo.m_strPreferredDns);
		GetIpCtrlAddress(m_ipAlternateDns, &m_pAdapterInfo->m_BackupInfo.m_strAlternateDns);
		GetIpCtrlAddress(m_ipPrefferredWins, &m_pAdapterInfo->m_BackupInfo.m_strPreferredWins);
		GetIpCtrlAddress(m_ipAlternateWins, &m_pAdapterInfo->m_BackupInfo.m_strAlternateWins);
	}
}

LRESULT CIpBackUpDlg::OnAutoNet(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case BN_CLICKED:
        case BN_DOUBLECLICKED:
			EnableControls();
            break;
    }

    return 0;
}

LRESULT CIpBackUpDlg::OnUseConfig(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {

        case BN_CLICKED:
        case BN_DOUBLECLICKED:
			EnableControls();
            break;
    }
    return 0;
}

LRESULT CIpBackUpDlg::OnIpctrl(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;
    }

    return 0;
}

LRESULT CIpBackUpDlg::OnIpAddrSub(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        PageModified();
        break;

    case EN_SETFOCUS:

        // if the subnet mask is blank, create a mask and insert it into
        // the control
        if (!m_ipAddr.IsBlank() && m_ipMask.IsBlank())
        {
            tstring strSubnetMask;
            tstring strIpAddress;

            m_ipAddr.GetAddress(&strIpAddress);

            // generate the mask and update the control, and internal structure
            GenerateSubnetMask(m_ipAddr, &strSubnetMask);
            m_ipMask.SetAddress(strSubnetMask.c_str());

            ReplaceFirstAddress(&(m_pAdapterInfo->m_vstrSubnetMask),
                                strSubnetMask.c_str());
        }
        break;
    }

    return 0;
}


void CIpBackUpDlg::EnableControls()
{
	BOOL fEnableUserConfig = !IsDlgButtonChecked(IDC_BKUP_RD_AUTO);

	::EnableWindow(GetDlgItem(IDC_BKUP_IPADDR_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_IPADDR), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_SUBNET_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_SUBNET), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_GATEWAY_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_GATEWAY), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_PREF_DNS_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_PREF_DNS), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_ALT_DNS_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_ALT_DNS), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_WINS1_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_WINS1), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_WINS2_TEXT), fEnableUserConfig);
	::EnableWindow(GetDlgItem(IDC_BKUP_WINS2), fEnableUserConfig);

	if (fEnableUserConfig)
	{
		m_ipAddr.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strIpAddr.c_str());
		m_ipMask.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strSubnetMask.c_str());
		m_ipDefGw.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strDefGw.c_str());
		m_ipPrefferredDns.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strPreferredDns.c_str());
		m_ipAlternateDns.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strAlternateDns.c_str());
		m_ipPrefferredWins.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strPreferredWins.c_str());
		m_ipAlternateWins.SetAddress(m_pAdapterInfo->m_BackupInfo.m_strAlternateWins.c_str());
	}
	else
	{
		m_ipAddr.ClearAddress();
		m_ipMask.ClearAddress();
		m_ipDefGw.ClearAddress();
		m_ipPrefferredDns.ClearAddress();
		m_ipAlternateDns.ClearAddress();
		m_ipPrefferredWins.ClearAddress();
		m_ipAlternateWins.ClearAddress();
	}
}

void CIpBackUpDlg::GetIpCtrlAddress(IpControl & IpCtrl, tstring * pstr)
{
	Assert(pstr);

	if (IpCtrl.IsBlank())
	{
		*pstr = c_szEmpty;
	}
	else
	{
		IpCtrl.GetAddress(pstr);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgbkup.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       DLGBKUP.H
//
//  Contents:   Declaration for CIpBackUpDlg
//
//  Notes:  CIpBackUpDlg is the modal dialog to handle the fallback static
//			TCP/IP settings
//
//  Author: nsun	02/15/2000
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"

// The IP Back up setting dialog
class CIpBackUpDlg : public CPropSheetPage
{
public:

    BEGIN_MSG_MAP(CIpBackUpDlg)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_DESTROY, OnDestroyDialog);

        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
		NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)

        // command handlers
        COMMAND_ID_HANDLER(IDC_BKUP_RD_AUTO, OnAutoNet)
        COMMAND_ID_HANDLER(IDC_BKUP_RD_USER, OnUseConfig)

        COMMAND_ID_HANDLER(IDC_BKUP_IPADDR,    OnIpctrl)
        COMMAND_ID_HANDLER(IDC_BKUP_SUBNET,   OnIpAddrSub)
        COMMAND_ID_HANDLER(IDC_BKUP_GATEWAY,  OnIpctrl)

        COMMAND_ID_HANDLER(IDC_BKUP_PREF_DNS,    OnIpctrl)
        COMMAND_ID_HANDLER(IDC_BKUP_ALT_DNS,  OnIpctrl)

		COMMAND_ID_HANDLER(IDC_BKUP_WINS1,    OnIpctrl)
        COMMAND_ID_HANDLER(IDC_BKUP_WINS2,  OnIpctrl)

		NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)


    END_MSG_MAP()
//
public:
    CIpBackUpDlg(CTcpipcfg * ptcpip, 
				 const DWORD* pamhidsHelp = NULL
				);

    ~CIpBackUpDlg();

// Dialog creation overides
public:
    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
	LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

	// message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnDestroyDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // command ID handlers
	LRESULT OnAutoNet(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUseConfig(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnIpctrl(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpAddrSub(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

	LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

private:
	void EnableControls();
	void GetIpCtrlAddress(IpControl & IpCtrl, tstring * pstr);		
	void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd); }
	void UpdateInfo();

private:

    BOOL m_fModified;
    const DWORD *	m_adwHelpIDs;
	CTcpipcfg *     m_ptcpip;
	ADAPTER_INFO *	m_pAdapterInfo;

	IpControl       m_ipAddr;
    IpControl       m_ipMask;
    IpControl       m_ipDefGw;
    IpControl       m_ipPrefferredDns;
    IpControl       m_ipAlternateDns;
	IpControl       m_ipPrefferredWins;
    IpControl       m_ipAlternateWins;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgaddrm.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A D D R M . H
//
//  Contents:   Declaration of CAdvIPAddrPage, CAddressDialog and
//              CGatewayDialog
//
//  Notes:  CAdvIPAddrPage is the IP setting page
//
//  Author: tongl   5 Nov 1997
//
//-----------------------------------------------------------------------
#pragma once
#include "ipctrl.h"
#include "tcperror.h"

#include <ncxbase.h>
#include <ncatlps.h>

// Number of columns in the IDS_IPADDRESS_TEXT listview
const int c_nColumns = 2;

class CIpSettingsPage : public CPropSheetPage
{
public:

    BEGIN_MSG_MAP(CIpSettingsPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnQueryCancel)

        COMMAND_ID_HANDLER(IDC_IPADDR_ADDIP,            OnAddIp);
        COMMAND_ID_HANDLER(IDC_IPADDR_EDITIP,           OnEditIp);
        COMMAND_ID_HANDLER(IDC_IPADDR_REMOVEIP,         OnRemoveIp);

        COMMAND_ID_HANDLER(IDC_IPADDR_ADDGATE,          OnAddGate);
        COMMAND_ID_HANDLER(IDC_IPADDR_EDITGATE,         OnEditGate);
        COMMAND_ID_HANDLER(IDC_IPADDR_REMOVEGATE,       OnRemoveGate);

        COMMAND_ID_HANDLER(IDC_AUTO_METRIC,           OnAutoMetric)

    END_MSG_MAP()

public:

    CIpSettingsPage(CTcpAddrPage * pTcpAddrPage, 
                    ADAPTER_INFO * pAdapterInfo, 
                    const DWORD* pamhidsHelp = NULL);
    ~CIpSettingsPage();

// Dialog creation overrides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    LRESULT OnAddIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnAddGate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditGate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveGate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAutoMetric(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnGatewaySelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CAddressDialog;
    friend class CGatewayDialog;

private:

    // functions
    void    SetIpInfo();
    void    SetIpButtons();
    void    UpdateIpList();

    void    SetGatewayInfo();
    void    SetGatewayButtons();
    void    UpdateGatewayList();

    void    EnableIpButtons(BOOL fState);

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}

    // data members
    CTcpAddrPage *  m_pParentDlg;
    ADAPTER_INFO *  m_pAdapterInfo;
    const  DWORD *  m_adwHelpIDs;

    BOOL m_fModified;

    // are we adding or editting
    BOOL        m_fEditState;  
    tstring     m_strAdd;

    HWND        m_hIpListView;      // IP/Subnet list view
    HWND        m_hAddIp;           // IP buttons
    HWND        m_hEditIp;
    HWND        m_hRemoveIp;

    HWND        m_hGatewayListView;
    HWND        m_hAddGateway;
    HWND        m_hEditGateway;
    HWND        m_hRemoveGateway;

    tstring     m_strRemovedIpAddress;
    tstring     m_strRemovedSubnetMask;
    tstring     m_strRemovedGateway;
    UINT        m_uiRemovedMetric;
};

class CAddressDialog : public CDialogImpl<CAddressDialog>
{
public:

    enum { IDD = IDD_IPADDR_ADV_CHANGEIP };

    BEGIN_MSG_MAP(CAddressDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGEIP_IP, OnChangeIp)
        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGEIP_SUB, OnChangeSub)
        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)

    END_MSG_MAP()
//
public:
    CAddressDialog( CIpSettingsPage * pDlgAdvanced, 
                    const DWORD* pamhidsHelp = NULL,
                    int iIndex = -1);
    ~CAddressDialog(){};

// Dialog creation overides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChangeIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnChangeSub(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

// Command Handlers
public:
    
    void    OnIpChange();
    void    OnSubnetChange();
    void    OnEditSetFocus(WORD nId);

public:
    IpControl   m_ipAddress;
    IpControl   m_ipSubnetMask;
    tstring     m_strNewIpAddress;     // either the one added, or edited
    tstring     m_strNewSubnetMask;    // either the one added, or edited

private:

    // this is the IDOK button, the text of the button changes
    // with the context.
    HWND m_hButton;     

    CIpSettingsPage * m_pParentDlg;

    const   DWORD * m_adwHelpIDs;

    int     m_iIndex;
};

class CGatewayDialog : public CDialogImpl<CGatewayDialog>
{
public:

    enum { IDD = IDD_IPADDR_ADV_CHANGEGATE };

    BEGIN_MSG_MAP(CAddressDialog)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK, OnOk);
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel);

        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGE_GATEWAY, OnGatewayChange);
        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGE_METRIC, OnMetricChange);
        COMMAND_ID_HANDLER(IDC_IPADDR_ADV_CHANGE_AUTOMETRIC, OnAutoMetric)
        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)
    END_MSG_MAP()

public:
    CGatewayDialog( CIpSettingsPage * pDlgAdvanced,
                    const DWORD* pamhidsHelp = NULL,
                    int iIndex = -1);
    ~CGatewayDialog(){};

public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnGatewayChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnMetricChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAutoMetric(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);  

// Dialog creation overides
public:
   
    IpControl   m_ipGateAddress;
    tstring     m_strNewGate;          // either the one added, or edited
    UINT        m_uiNewMetric;

private:

    // this is the IDOK button, the text of the button changes
    // with the context.
    HWND m_hButton;     

    CIpSettingsPage * m_pParentDlg;

    const   DWORD * m_adwHelpIDs;

    BOOL    m_fValidMetric;

    int     m_iIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgdns.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P D N S . H
//
//  Contents:   CTcpDnsPage, CServerDialog and CSuffixDialog declaration
//
//  Notes:  The DNS page and related dialogs
//
//  Author: tongl   11 Nov 1997
//
//-----------------------------------------------------------------------
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"

// maximum number of characters in the suffix edit control
const int SUFFIX_LIMIT = 255; 

//maximum length of domain name 
const int DOMAIN_LIMIT = 255; 

class CTcpDnsPage : public CPropSheetPage
{

public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpDnsPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Control message handlers
        // Push button message handlers
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_ADD,     OnAddServer)
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_EDIT,    OnEditServer)
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_REMOVE,  OnRemoveServer)
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_UP,      OnServerUp)
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_DOWN,    OnServerDown)

        COMMAND_ID_HANDLER(IDC_DNS_DOMAIN, OnDnsDomain)

        COMMAND_ID_HANDLER(IDC_DNS_SEARCH_DOMAIN,           OnSearchDomain)
        COMMAND_ID_HANDLER(IDC_DNS_SEARCH_PARENT_DOMAIN,    OnSearchParentDomain)
        COMMAND_ID_HANDLER(IDC_DNS_USE_SUFFIX_LIST,         OnUseSuffix)

        COMMAND_ID_HANDLER(IDC_DNS_ADDR_REG,     OnAddressRegister)
        COMMAND_ID_HANDLER(IDC_DNS_NAME_REG,     OnDomainNameRegister)

        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_ADD,      OnAddSuffix)
        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_EDIT,     OnEditSuffix)
        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_REMOVE,   OnRemoveSuffix)
        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_UP,       OnSuffixUp)
        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_DOWN,     OnSuffixDown)

        // Notification handlers
        COMMAND_ID_HANDLER(IDC_DNS_SERVER_LIST,     OnServerList)

        COMMAND_ID_HANDLER(IDC_DNS_SUFFIX_LIST,     OnSuffixList)

    END_MSG_MAP()

// Constructors/Destructors
    CTcpDnsPage(CTcpAddrPage * pTcpAddrPage,
                ADAPTER_INFO * pAdapterDlg,
                GLOBAL_INFO * pGlbDlg,
                const DWORD * adwHelpIDs = NULL);

    ~CTcpDnsPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // DNS server list
    LRESULT OnAddServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // DNS domain
    LRESULT OnDnsDomain(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // Search order radio buttons
    LRESULT OnSearchDomain(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSearchParentDomain(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUseSuffix(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // DNS suffix list
    LRESULT OnAddSuffix(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditSuffix(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveSuffix(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSuffixUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSuffixDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnServerList(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSuffixList(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // ip address and name dynamic registration
    LRESULT OnAddressRegister(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDomainNameRegister(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

// Handlers
public:

    void OnServerChange();
    void OnSuffixChange();


// Attributes
public:
    tstring         m_strNewIpAddress; // server: either the one added, or edited
    tstring         m_strNewSuffix;

    // server: used as work space for moving entries in the listboxes
    tstring         m_strMovingEntry;  

    tstring         m_strAddServer; // OK or Add button server dialog
    tstring         m_strAddSuffix; // OK or Add button suffix dialog
    BOOL            m_fEditState;

    HANDLES         m_hServers;
    HANDLES         m_hSuffix;

private:
    CTcpAddrPage *   m_pParentDlg;
    ADAPTER_INFO *          m_pAdapterInfo;
    GLOBAL_INFO *           m_pglb;

    BOOL            m_fModified;

    const DWORD*    m_adwHelpIDs;

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}

    // help functions
    void EnableSuffixGroup(BOOL fEnable);
};

class CServerDialog : public CDialogImpl<CServerDialog>
{
public:

    enum { IDD = IDD_DNS_SERVER };

    BEGIN_MSG_MAP(CServerDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK,                    OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,                OnCancel);

        COMMAND_ID_HANDLER(IDC_DNS_CHANGE_SERVER,   OnChange);

        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)

    END_MSG_MAP()

public:
    CServerDialog(CTcpDnsPage * pTcpDnsPage, const DWORD* pamhidsHelp = NULL, int iIndex = -1);
    ~CServerDialog(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

// Dialog creation overides
public:

    IpControl m_ipAddress;

private:
    HWND m_hButton;     // this is the IDOK button, the text of the button changes
                        // with the context.

    CTcpDnsPage * m_pParentDlg;
    const DWORD * m_adwHelpIDs;
    int m_iIndex;
};

class CSuffixDialog : public CDialogImpl<CSuffixDialog>
{
public:

    enum { IDD = IDD_DNS_SUFFIX };

    BEGIN_MSG_MAP(CSuffixDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_DNS_CHANGE_SUFFIX,   OnChange);
    END_MSG_MAP()

//
public:
    CSuffixDialog(CTcpDnsPage * pTcpDnsPage, const DWORD* pamhidsHelp = NULL, int iIndex = -1);
    ~CSuffixDialog(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:
    HWND m_hEdit;       //
    HWND m_hButton;     // this is the IDOK button, the text of the button changes
                        // with the context.

    CTcpDnsPage *   m_pParentDlg;
    const DWORD *   m_adwHelpIDs;
    int             m_iIndex;       
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgatm.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G A T M . H
//
//  Contents:   CTcpArpcPage and CATMAddressDialog declaration
//
//  Notes:  The "ATM ARP Client" page and dialog
//
//  Author: tongl   1 July 1997  Created
//
//-----------------------------------------------------------------------
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>

// maximum number of characters in the ARPS and MARS edit control
const int MAX_MTU_LENGTH = 5;
const int MAX_TITLE_LENGTH = 12;

const int NUM_ATMSERVER_LIMIT = 12;

const int MAX_MTU = 65527;
const int MIN_MTU = 9180;


class CAtmArpcPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CAtmArpcPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnQueryCancel)

        // Control message handlers
        COMMAND_ID_HANDLER(IDC_CHK_ATM_PVCONLY,     OnPVCOnly)

        COMMAND_ID_HANDLER(IDC_LBX_ATM_ArpsAddrs,   OnArpServer)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsAdd,     OnAddArps)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsEdt,     OnEditArps)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsRmv,     OnRemoveArps)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsUp,      OnArpsUp)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_ArpsDown,    OnArpsDown)

        COMMAND_ID_HANDLER(IDC_LBX_ATM_MarsAddrs,   OnMarServer)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsAdd,     OnAddMars)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsEdt,     OnEditMars)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsRmv,     OnRemoveMars)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsUp,      OnMarsUp)
        COMMAND_ID_HANDLER(IDC_PSB_ATM_MarsDown,    OnMarsDown)

        COMMAND_ID_HANDLER(IDC_EDT_ATM_MaxTU,       OnMaxTU)

    END_MSG_MAP()

// Constructors/Destructors
public:

    CAtmArpcPage(CTcpAddrPage * pTcpAddrPage,
                 ADAPTER_INFO * pAdapterDlg,
                 const DWORD * adwHelpIDs = NULL)
    {
        AssertH(pTcpAddrPage);
        AssertH(pAdapterDlg);

        m_pParentDlg = pTcpAddrPage;
        m_pAdapterInfo = pAdapterDlg;
        m_adwHelpIDs = adwHelpIDs;

        m_fModified = FALSE;
    }

    ~CAtmArpcPage(){};

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // Control message handlers
    LRESULT OnPVCOnly(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnArpServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAddArps(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditArps(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveArps(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnArpsUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnArpsDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnMarServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAddMars(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditMars(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveMars(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnMarsUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnMarsDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnMaxTU(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CAtmAddressDialog;

private:

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() {   m_fModified = TRUE;
                            PropSheet_Changed(GetParent(), m_hWnd);
                        }

    // Update the server addresses and MTU of the deselected card
    void UpdateInfo();
    void SetInfo();
    void EnableGroup(BOOL fEnable);

    void OnServerAdd(HANDLES hwndGroup, PCWSTR szTitle);
    void OnServerEdit(HANDLES hwndGroup, PCWSTR szTitle);
    void OnServerRemove(HANDLES hwndGroup, BOOL fRemoveArps);
    void OnServerUp(HANDLES hwndGroup);
    void OnServerDown(HANDLES hwndGroup);

    // data members

    CTcpAddrPage *  m_pParentDlg;
    ADAPTER_INFO *  m_pAdapterInfo;
    const DWORD *   m_adwHelpIDs;

    BOOL    m_fModified;

    BOOL    m_fEditState;
    HWND    m_hAddressList;

    tstring m_strNewArpsAddress; // either the one added, or edited
    tstring m_strNewMarsAddress;

    tstring m_strMovingEntry;

    HWND        m_hMTUEditBox;
    HANDLES     m_hArps;
    HANDLES     m_hMars;
};

class CAtmAddressDialog : public CDialogImpl<CAtmAddressDialog>
{
public:

    enum { IDD = IDD_ATM_ADDR };

    BEGIN_MSG_MAP(CServerDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_EDT_ATM_Address,     OnChange);
    END_MSG_MAP()

public:
    CAtmAddressDialog(CAtmArpcPage * pAtmArpcPage, const DWORD* pamhidsHelp = NULL);
    ~CAtmAddressDialog();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    void SetTitle(PCWSTR szTitle);

private:
    HWND m_hOkButton;     // this is the IDOK button, the text of the button changes
                          // with the context.
    HWND m_hEditBox;      // this is the edit box for the ATM address

    CAtmArpcPage * m_pParentDlg;

    WCHAR m_szTitle[MAX_TITLE_LENGTH];

    const   DWORD * m_adwHelpIDs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgdns.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P D N S . C P P
//
//  Contents:   CTcpDnsPage, CServerDialog and CSuffixDialog implementation
//
//  Notes:  The DNS page and related dialogs
//
//  Author: tongl   11 Nov 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "tcpconst.h"
#include "dlgaddr.h"
#include "dlgdns.h"

#include "tcphelp.h"
#include "tcpmacro.h"
#include "tcputil.h"
#include "dnslib.h"

#define MAX_RAS_DNS_SERVER          2
#define MAX_HOSTNAME_LENGTH         64
#define MAX_DOMAINNAME_LENGTH       255

CTcpDnsPage::CTcpDnsPage(CTcpAddrPage * pTcpAddrPage,
                         ADAPTER_INFO * pAdapterDlg,
                         GLOBAL_INFO * pGlbDlg,
                         const DWORD*  adwHelpIDs)
{
    // Save everything passed to us
    Assert(pTcpAddrPage != NULL);
    m_pParentDlg = pTcpAddrPage;

    Assert(pAdapterDlg != NULL);
    m_pAdapterInfo = pAdapterDlg;

    Assert(pGlbDlg != NULL);
    m_pglb = pGlbDlg;

    m_adwHelpIDs = adwHelpIDs;

    // Initialize internal states
    m_fModified = FALSE;
}

CTcpDnsPage::~CTcpDnsPage()
{
}

LRESULT CTcpDnsPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    m_fEditState = FALSE;

    // Cache hwnds
    // Server
    m_hServers.m_hList      = GetDlgItem(IDC_DNS_SERVER_LIST);
    m_hServers.m_hAdd       = GetDlgItem(IDC_DNS_SERVER_ADD);
    m_hServers.m_hEdit      = GetDlgItem(IDC_DNS_SERVER_EDIT);
    m_hServers.m_hRemove    = GetDlgItem(IDC_DNS_SERVER_REMOVE);
    m_hServers.m_hUp        = GetDlgItem(IDC_DNS_SERVER_UP);
    m_hServers.m_hDown      = GetDlgItem(IDC_DNS_SERVER_DOWN);

    // Suffix
    m_hSuffix.m_hList       = GetDlgItem(IDC_DNS_SUFFIX_LIST);
    m_hSuffix.m_hAdd        = GetDlgItem(IDC_DNS_SUFFIX_ADD);
    m_hSuffix.m_hEdit       = GetDlgItem(IDC_DNS_SUFFIX_EDIT);
    m_hSuffix.m_hRemove     = GetDlgItem(IDC_DNS_SUFFIX_REMOVE);
    m_hSuffix.m_hUp         = GetDlgItem(IDC_DNS_SUFFIX_UP);
    m_hSuffix.m_hDown       = GetDlgItem(IDC_DNS_SUFFIX_DOWN);


    // Set the up\down arrow icons
    SendDlgItemMessage(IDC_DNS_SERVER_UP, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_DNS_SERVER_DOWN, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    SendDlgItemMessage(IDC_DNS_SUFFIX_UP, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_DNS_SUFFIX_DOWN, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    // Get the Service address Add and Edit button Text and remove ellipse
    WCHAR   szAddServer[16];
    WCHAR   szAddSuffix[16];

    GetDlgItemText(IDC_DNS_SERVER_ADD, szAddServer, celems(szAddServer));
    GetDlgItemText(IDC_DNS_SERVER_ADD, szAddSuffix, celems(szAddSuffix));

    szAddServer[lstrlenW(szAddServer) - c_cchRemoveCharatersFromEditOrAddButton]= 0;
    szAddSuffix[lstrlenW(szAddSuffix) - c_cchRemoveCharatersFromEditOrAddButton]= 0;

    m_strAddServer = szAddServer;
    m_strAddSuffix = szAddSuffix;

    // Initialize controls on this page
    // DNS server list box
    int nResult= LB_ERR;
    for(VSTR_ITER iterNameServer = m_pAdapterInfo->m_vstrDnsServerList.begin() ;
        iterNameServer != m_pAdapterInfo->m_vstrDnsServerList.end() ;
        ++iterNameServer)
    {
        nResult = Tcp_ListBox_InsertString(m_hServers.m_hList, -1,
                                           (*iterNameServer)->c_str());
    }

    // set slection to first item
    if (nResult >= 0)
    {
        Tcp_ListBox_SetCurSel(m_hServers.m_hList, 0);
    }

    SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);


    // DNS domain edit box
    ::SendMessage(GetDlgItem(IDC_DNS_DOMAIN), EM_SETLIMITTEXT, DOMAIN_LIMIT, 0);
    ::SetWindowText(GetDlgItem(IDC_DNS_DOMAIN),
                    m_pAdapterInfo->m_strDnsDomain.c_str());

    // DNS dynamic registration
    CheckDlgButton(IDC_DNS_ADDR_REG, !m_pAdapterInfo->m_fDisableDynamicUpdate);
    CheckDlgButton(IDC_DNS_NAME_REG, m_pAdapterInfo->m_fEnableNameRegistration);

    // Bug #266461 need disable IDC_DNS_NAME_REG if IDC_DNS_ADDR_REG is unchecked
    if(m_pAdapterInfo->m_fDisableDynamicUpdate)
        ::EnableWindow(GetDlgItem(IDC_DNS_NAME_REG), FALSE);


    // DNS domain serach methods
    if (m_pglb->m_vstrDnsSuffixList.size() >0) //If suffix list not empty
    {
        CheckDlgButton(IDC_DNS_USE_SUFFIX_LIST, TRUE);
        CheckDlgButton(IDC_DNS_SEARCH_DOMAIN, FALSE);
        CheckDlgButton(IDC_DNS_SEARCH_PARENT_DOMAIN, FALSE);

        EnableSuffixGroup(TRUE);
        ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_PARENT_DOMAIN), FALSE);

        // DNS suffix list box
        nResult= LB_ERR;
        for(VSTR_CONST_ITER iterSearchList = (m_pglb->m_vstrDnsSuffixList).begin() ;
                            iterSearchList != (m_pglb->m_vstrDnsSuffixList).end() ;
                            ++iterSearchList)
        {
            nResult = Tcp_ListBox_InsertString(m_hSuffix.m_hList, -1,
                                              (*iterSearchList)->c_str());
        }

        // set slection to first item
        if (nResult >= 0)
        {
            Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, 0);
        }

        SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
    }
    else
    {
        CheckDlgButton(IDC_DNS_USE_SUFFIX_LIST, FALSE);
        CheckDlgButton(IDC_DNS_SEARCH_DOMAIN, TRUE);
        CheckDlgButton(IDC_DNS_SEARCH_PARENT_DOMAIN, m_pglb->m_fUseDomainNameDevolution);

        EnableSuffixGroup(FALSE);
    }

    //this is a ras connection and a non-admin user, disable all the controls 
    //for globl settings
    if (m_pAdapterInfo->m_fIsRasFakeAdapter && m_pParentDlg->m_fRasNotAdmin)
    {
        ::EnableWindow(GetDlgItem(IDC_DNS_STATIC_GLOBAL), FALSE);
        ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_DOMAIN), FALSE);
        ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_PARENT_DOMAIN), FALSE);
        ::EnableWindow(GetDlgItem(IDC_DNS_USE_SUFFIX_LIST), FALSE);
        EnableSuffixGroup(FALSE);
    }

    return 0;
}

LRESULT CTcpDnsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpDnsPage::OnHelp(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CTcpDnsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpDnsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    // server list
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrDnsServerList);

    WCHAR szServer[IP_LIMIT];

    int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    for (int i = 0; i < nCount; i++)
    {
        #ifdef DBG
            int len = Tcp_ListBox_GetTextLen(m_hServers.m_hList, i);
            Assert(len != LB_ERR && len < IP_LIMIT);
        #endif

        Tcp_ListBox_GetText(m_hServers.m_hList, i, szServer);
        m_pAdapterInfo->m_vstrDnsServerList.push_back(new tstring(szServer));
    }

    
    // DNS domain
    // update second memory with what's in the controls
    WCHAR szDomain[DOMAIN_LIMIT + 1];
    ::GetWindowText(GetDlgItem(IDC_DNS_DOMAIN), szDomain, celems(szDomain));
    m_pAdapterInfo->m_strDnsDomain = szDomain;

    m_pAdapterInfo->m_fDisableDynamicUpdate = !IsDlgButtonChecked(IDC_DNS_ADDR_REG);
    m_pAdapterInfo->m_fEnableNameRegistration = IsDlgButtonChecked(IDC_DNS_NAME_REG);
    

    // suffix list and radio button options
    FreeCollectionAndItem(m_pglb->m_vstrDnsSuffixList);

    WCHAR szSuffix[SUFFIX_LIMIT];
    if (IsDlgButtonChecked(IDC_DNS_USE_SUFFIX_LIST))
    {
        int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);
        AssertSz(nCount > 0, "Why isn't the error caught by OnKillActive?");

        for (int i = 0; i < nCount; i++)
        {
            #ifdef DBG
                int len = Tcp_ListBox_GetTextLen(m_hSuffix.m_hList, i);
                Assert(len != LB_ERR && len < SUFFIX_LIMIT);
            #endif

            Tcp_ListBox_GetText(m_hSuffix.m_hList, i, szSuffix);
            m_pglb->m_vstrDnsSuffixList.push_back(new tstring(szSuffix));
        }
    }
    else
    {
        m_pglb->m_fUseDomainNameDevolution =
            IsDlgButtonChecked(IDC_DNS_SEARCH_PARENT_DOMAIN);
    }

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    SetModifiedTo(FALSE);  // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CTcpDnsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}


LRESULT CTcpDnsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL fErr = FALSE;

    if (IsDlgButtonChecked(IDC_DNS_USE_SUFFIX_LIST))
    {
        int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);

        if (0 == nCount)
        {
            // If the list is empty
            NcMsgBox(m_hWnd, IDS_MSFT_TCP_TEXT, IDS_INVALID_NO_SUFFIX,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            fErr = TRUE;
        }
    }

    WCHAR szDomain[DOMAIN_LIMIT + 1];
    ::GetWindowText(GetDlgItem(IDC_DNS_DOMAIN), szDomain, celems(szDomain));
    if (lstrlenW(szDomain) > 0 && lstrcmpiW(m_pAdapterInfo->m_strDnsDomain.c_str(), szDomain) != 0)
    {

        DNS_STATUS status;

        status = DnsValidateName(szDomain, DnsNameDomain);
        if (ERROR_INVALID_NAME == status ||
            DNS_ERROR_INVALID_NAME_CHAR == status)
        {
            NcMsgBox(m_hWnd,
                     IDS_MSFT_TCP_TEXT,
                     IDS_INVALID_DOMAIN_NAME,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                     szDomain);
            ::SetFocus(GetDlgItem(IDC_DNS_DOMAIN));
            fErr = TRUE;
        }
        else if (DNS_ERROR_NON_RFC_NAME == status)
        {
            //the dns domain name is not RFC compaliant, should we give a warning here?
        }
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fErr);
    return fErr;
}

// DNS server related controls
LRESULT CTcpDnsPage::OnAddServer(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CServerDialog * pDlgSrv = new CServerDialog(this, g_aHelpIDs_IDD_DNS_SERVER);

    if (pDlgSrv->DoModal() == IDOK)
    {
        int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);
        int idx = Tcp_ListBox_InsertString(m_hServers.m_hList,
                                           -1,
                                           m_strNewIpAddress.c_str());
        Assert(idx>=0);
        if (idx >= 0)
        {
            PageModified();

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);
            SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);

            // empty strings, this removes the saved address from RemoveIP
            m_strNewIpAddress = L"";
        }
    }

    // release dialog object
    delete pDlgSrv;

    return 0;
}

LRESULT CTcpDnsPage::OnEditServer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    Assert(Tcp_ListBox_GetCount(m_hServers.m_hList));
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);
    Assert(idx >= 0);

    CServerDialog * pDlgSrv = new CServerDialog(this, 
                                        g_aHelpIDs_IDD_DNS_SERVER,
                                        idx);
  

    // save off the removed address and delete if from the listbox
    if (idx >= 0)
    {
        WCHAR buf[IP_LIMIT];

        Assert(Tcp_ListBox_GetTextLen(m_hServers.m_hList, idx) < celems(buf));
        Tcp_ListBox_GetText(m_hServers.m_hList, idx, buf);

        m_strNewIpAddress = buf;  // used by dialog to display what to edit

        if (pDlgSrv->DoModal() == IDOK)
        {
            // replace the item in the listview with the new information
            Tcp_ListBox_DeleteString(m_hServers.m_hList, idx);

            PageModified();

            m_strMovingEntry = m_strNewIpAddress;
            ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

            m_strNewIpAddress = buf;  // restore the original removed address
        }
        else
        {
            // empty strings, this removes the saved address from RemoveIP
            m_strNewIpAddress = L"";
        }
    }

    delete pDlgSrv;

    return 0;
}

LRESULT CTcpDnsPage::OnRemoveServer(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);

    Assert(idx >=0);

    if (idx >=0)
    {
        WCHAR buf[IP_LIMIT];

        Assert(Tcp_ListBox_GetTextLen(m_hServers.m_hList, idx) < celems(buf));
        Tcp_ListBox_GetText(m_hServers.m_hList, idx, buf);

        m_strNewIpAddress = buf;
        Tcp_ListBox_DeleteString(m_hServers.m_hList, idx);

        PageModified();

        // select a new item
        int nCount;

        if ((nCount = Tcp_ListBox_GetCount(m_hServers.m_hList)) != LB_ERR)
        {
            // select the previous item in the list
            if (idx)
                --idx;

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);
        }
        SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);
    }
    return 0;
}

LRESULT CTcpDnsPage::OnServerUp(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hServers.m_hList);
    int  nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    Assert(nCount);
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);

    Assert(idx != 0);

    if (ListBoxRemoveAt(m_hServers.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    --idx;
    PageModified();
    ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());

    Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

    SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);

    return 0;
}

LRESULT CTcpDnsPage::OnDnsDomain(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:
        // update second memory with what's in the controls
        WCHAR szBuf[DOMAIN_LIMIT + 1];
        ::GetWindowText(GetDlgItem(IDC_DNS_DOMAIN), szBuf, celems(szBuf));
        if (m_pAdapterInfo->m_strDnsDomain != szBuf)
            PageModified();

        break;

    default:
        break;
    }

    return 0;
}

LRESULT CTcpDnsPage::OnServerDown(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hServers.m_hList);
    int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    Assert(nCount);

    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);
    --nCount;

    Assert(idx != nCount);

    if (ListBoxRemoveAt(m_hServers.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    ++idx;
    PageModified();

    ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());
    Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

    SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);

    return 0;
}

// DNS domain search related controls
LRESULT CTcpDnsPage::OnSearchDomain(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (::IsWindowEnabled(m_hSuffix.m_hList))
        {
            PageModified();

            // Update in memory structure
            FreeCollectionAndItem(m_pglb->m_vstrDnsSuffixList);

            // delete all items from the list
            int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);
            while (nCount>0)
            {
                Tcp_ListBox_DeleteString(m_hSuffix.m_hList, 0);
                nCount --;
            }
            EnableSuffixGroup(FALSE);
            ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_PARENT_DOMAIN), TRUE);
        }
        break;
    } // switch

    return 0;
}

LRESULT CTcpDnsPage::OnSearchParentDomain(WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        PageModified();
        break;
    } // switch

    return 0;
}

LRESULT CTcpDnsPage::OnAddressRegister(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        // Bug #266461 need disable and uncheck IDC_DNS_NAME_REG
        //             if IDC_DNS_ADDR_REG is unchecked
        if(!IsDlgButtonChecked(IDC_DNS_ADDR_REG))
        {
            CheckDlgButton(IDC_DNS_NAME_REG, FALSE);
            ::EnableWindow(GetDlgItem(IDC_DNS_NAME_REG), FALSE);
        }
        else
            ::EnableWindow(GetDlgItem(IDC_DNS_NAME_REG), TRUE);

        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpDnsPage::OnDomainNameRegister(WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        PageModified();
        break;
    }

    return 0;
}

LRESULT CTcpDnsPage::OnUseSuffix(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (!::IsWindowEnabled(m_hSuffix.m_hList))
        {
            PageModified();
            EnableSuffixGroup(TRUE);
            CheckDlgButton(IDC_DNS_SEARCH_PARENT_DOMAIN, FALSE);
            ::EnableWindow(GetDlgItem(IDC_DNS_SEARCH_PARENT_DOMAIN), FALSE);
        }

        break;
    } // switch
    return 0;
}

LRESULT CTcpDnsPage::OnAddSuffix(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CSuffixDialog * pDlgSuffix = new CSuffixDialog(this, g_aHelpIDs_IDD_DNS_SUFFIX);

    int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);

    if (pDlgSuffix->DoModal() == IDOK)
    {
        nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);
        int idx = Tcp_ListBox_InsertString(m_hSuffix.m_hList,
                                           -1,
                                           m_strNewSuffix.c_str());

        PageModified();

        Assert(idx >= 0);

        if (idx >= 0)
        {
            Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);

            SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
            m_strNewSuffix =L"";
        }
    }

    delete pDlgSuffix;
    return 0;
}

LRESULT CTcpDnsPage::OnEditSuffix(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    Assert(Tcp_ListBox_GetCount(m_hSuffix.m_hList));

    int idx = Tcp_ListBox_GetCurSel(m_hSuffix.m_hList);
    Assert(idx >= 0);

    CSuffixDialog * pDlgSuffix = new CSuffixDialog(this, 
                                        g_aHelpIDs_IDD_DNS_SUFFIX,
                                        idx);

    // save off the removed address and delete if from the listview
    if (idx >= 0)
    {
        WCHAR buf[SUFFIX_LIMIT];

        if (Tcp_ListBox_GetTextLen(m_hSuffix.m_hList, idx) >= celems(buf))
        {
            Assert(FALSE);
            return 0;
        }

        Tcp_ListBox_GetText(m_hSuffix.m_hList, idx, buf);

        m_strNewSuffix = buf;

        if (pDlgSuffix->DoModal() == IDOK)
        {
            // replace the item in the listview with the new information

            Tcp_ListBox_DeleteString(m_hSuffix.m_hList, idx);
            PageModified();

            m_strMovingEntry = m_strNewSuffix;
            ListBoxInsertAfter(m_hSuffix.m_hList, idx, m_strMovingEntry.c_str());

            Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);

            m_strNewSuffix = buf; // save off old address
        }
        else
        {
            // empty strings, this removes the saved address from RemoveIP
            m_strNewSuffix = L"";
        }
    }

    delete pDlgSuffix;
    return 0;
}

LRESULT CTcpDnsPage::OnRemoveSuffix(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    int idx = Tcp_ListBox_GetCurSel(m_hSuffix.m_hList);

    Assert(idx >=0);

    if (idx >=0)
    {
        WCHAR buf[SUFFIX_LIMIT];

        if(Tcp_ListBox_GetTextLen(m_hSuffix.m_hList, idx) >= celems(buf))
        {
            Assert(FALSE);
            return 0;
        }

        Tcp_ListBox_GetText(m_hSuffix.m_hList, idx, buf);

        m_strNewSuffix = buf;
        Tcp_ListBox_DeleteString(m_hSuffix.m_hList, idx);
        PageModified();

        // select a new item
        int nCount;
        if ((nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList)) != LB_ERR)

        if(nCount != LB_ERR)
        {
            // select the previous item in the list
            if (idx)
                --idx;

            Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);
        }
        SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
    }

    return 0;
}

LRESULT CTcpDnsPage::OnSuffixUp(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hSuffix.m_hList);
    int  nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);

    Assert(nCount);
    int idx = Tcp_ListBox_GetCurSel(m_hSuffix.m_hList);

    Assert(idx != 0);

    if (ListBoxRemoveAt(m_hSuffix.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    --idx;
    PageModified();
    ListBoxInsertAfter(m_hSuffix.m_hList, idx, m_strMovingEntry.c_str());

    Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);

    SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);

    return 0;
}

LRESULT CTcpDnsPage::OnSuffixDown(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hSuffix.m_hList);
    int nCount = Tcp_ListBox_GetCount(m_hSuffix.m_hList);

    Assert(nCount);
    int idx = Tcp_ListBox_GetCurSel(m_hSuffix.m_hList);
    --nCount;

    Assert(idx != nCount);

    if (ListBoxRemoveAt(m_hSuffix.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    ++idx;
    PageModified();

    ListBoxInsertAfter(m_hSuffix.m_hList, idx, m_strMovingEntry.c_str());
    Tcp_ListBox_SetCurSel(m_hSuffix.m_hList, idx);

    SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);

    return 0;
}

LRESULT CTcpDnsPage::OnServerList(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hServers, (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_DNS_SERVER : -1);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CTcpDnsPage::OnSuffixList(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
        break;

    default:
        break;
    }

    return 0;
}

void CTcpDnsPage::EnableSuffixGroup(BOOL fEnable)
{
    ::EnableWindow(m_hSuffix.m_hList, fEnable);

    if (fEnable)
    {
        SetButtons(m_hSuffix, DNS_MAX_SEARCH_LIST_ENTRIES);
    }
    else
    {
        ::EnableWindow(m_hSuffix.m_hAdd, fEnable);
        ::EnableWindow(m_hSuffix.m_hEdit, fEnable);
        ::EnableWindow(m_hSuffix.m_hRemove, fEnable);
        ::EnableWindow(m_hSuffix.m_hUp, fEnable);
        ::EnableWindow(m_hSuffix.m_hDown, fEnable);
    }
}


//
// CServerDialog
//

CServerDialog::CServerDialog(CTcpDnsPage * pTcpDnsPage,
                             const DWORD * adwHelpIDs,
                             int iIndex)
{
    m_pParentDlg = pTcpDnsPage;
    m_hButton    = 0;
    m_adwHelpIDs = adwHelpIDs;
    m_iIndex = iIndex;
}

LRESULT CServerDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAddServer.c_str());

    m_ipAddress.Create(m_hWnd, IDC_DNS_CHANGE_SERVER);
    m_ipAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    // if editing an ip address fill the controls with the current information
    // if removing an ip address save it and fill the add dialog with it next time
    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_DNS_SERVER_LIST);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_hButton = GetDlgItem(IDOK);

    // add the address that was just removed
    if (m_pParentDlg->m_strNewIpAddress.size())
    {
        m_ipAddress.SetAddress(m_pParentDlg->m_strNewIpAddress.c_str());
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_pParentDlg->m_strNewIpAddress = L"";
        ::EnableWindow(m_hButton, FALSE);
    }

    ::SetFocus(m_ipAddress);
    return 0;
}

LRESULT CServerDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CServerDialog::OnHelp(UINT uMsg, WPARAM wParam,
                              LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CServerDialog::OnChange(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    if (m_ipAddress.IsBlank())
        ::EnableWindow(m_hButton, FALSE);
    else
        ::EnableWindow(m_hButton, TRUE);

    return 0;
}

LRESULT CServerDialog::OnOk(WORD wNotifyCode, WORD wID,
                            HWND hWndCtl, BOOL& fHandled)
{
    tstring strIp;
    m_ipAddress.GetAddress(&strIp);

    // Validate
    if (!FIsIpInRange(strIp.c_str()))
    {
        // makes ip address lose focus so the control gets
        // IPN_FIELDCHANGED notification
        // also makes it consistent for when short-cut is used
        ::SetFocus(m_hButton);

        return 0;
    }

    //check whether this is a duplicate
    int indexDup = Tcp_ListBox_FindStrExact(m_pParentDlg->m_hServers.m_hList, strIp.c_str());
    if (indexDup != LB_ERR && indexDup != m_iIndex)
    {
        NcMsgBox(m_hWnd,
                 IDS_MSFT_TCP_TEXT,
                 IDS_DUP_DNS_SERVER,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                 strIp.c_str());

        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE)
    {
        // Get the current address from the control and
        // add them to the adapter if valid
        m_pParentDlg->m_strNewIpAddress = strIp;

        EndDialog(IDOK);
    }
    else // see if either changed
    {
        if (strIp != m_pParentDlg->m_strNewIpAddress)
            m_pParentDlg->m_strNewIpAddress = strIp; // update save addresses
        else
            EndDialog(IDCANCEL);
    }

    EndDialog(IDOK);

    return 0;
}

LRESULT CServerDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CServerDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
	
    return 0;
}

LRESULT CServerDialog::OnIpFieldChange(int idCtrl, LPNMHDR pnmh,
                                        BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa = (LPNMIPADDRESS) pnmh;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    if (0==lpnmipa->iField)
    {
        iLow  = c_iIPADDR_FIELD_1_LOW;
        iHigh = c_iIPADDR_FIELD_1_HIGH;
    };

    IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);

    return 0;
}

//
// CSuffixDialog
//

// iIndex - the index of the current suffix in the suffix list, default value
//          is -1, which means new suffix
CSuffixDialog::CSuffixDialog(CTcpDnsPage * pTcpDnsPage,
                             const DWORD * adwHelpIDs,
                             int iIndex)
{
    m_pParentDlg = pTcpDnsPage;
    m_hButton    = 0;
    m_adwHelpIDs = adwHelpIDs;
    m_iIndex = iIndex;
}

LRESULT CSuffixDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAddSuffix.c_str());

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog
    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_DNS_SUFFIX_LIST);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                 SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handles to the "Ok" button and the edit box
    m_hButton = GetDlgItem(IDOK);
    m_hEdit   = GetDlgItem(IDC_DNS_CHANGE_SUFFIX);

    // suffixes have a 255 character limit
    ::SendMessage(m_hEdit, EM_SETLIMITTEXT, SUFFIX_LIMIT, 0);

    // add the address that was just removed
    if (m_pParentDlg->m_strNewSuffix.size())
    {
        ::SetWindowText(m_hEdit, m_pParentDlg->m_strNewSuffix.c_str());
        ::SendMessage(m_hEdit, EM_SETSEL, 0, -1);
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_pParentDlg->m_strNewSuffix = L"";
        ::EnableWindow(m_hButton, FALSE);
    }

    ::SetFocus(m_hEdit);
    return TRUE;
}

LRESULT CSuffixDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CSuffixDialog::OnHelp(UINT uMsg, WPARAM wParam,
                              LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CSuffixDialog::OnChange(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    WCHAR buf[2];

    // Enable or disable the "Ok" button
    // based on whether the edit box is empty
    if (::GetWindowText(m_hEdit, buf, celems(buf)) == 0)
        ::EnableWindow(m_hButton, FALSE);
    else
        ::EnableWindow(m_hButton, TRUE);

    return 0;
}

LRESULT CSuffixDialog::OnOk(WORD wNotifyCode, WORD wID,
                            HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szSuffix[SUFFIX_LIMIT];

    // Get the current address from the control and
    // add them to the adapter if valid
    ::GetWindowText(m_hEdit, szSuffix, SUFFIX_LIMIT);

    DNS_STATUS status;

    status = DnsValidateName(szSuffix, DnsNameDomain);

    if (ERROR_INVALID_NAME == status || 
        DNS_ERROR_INVALID_NAME_CHAR == status)
    {
        TraceTag(ttidTcpip,"Invalid Domain Suffix");

        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 IDS_INVALID_SUFFIX,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(m_hEdit);

        return 0;
    }

    //check whether this is a duplicate
    int indexDup = Tcp_ListBox_FindStrExact(m_pParentDlg->m_hSuffix.m_hList, szSuffix);
    if (indexDup != LB_ERR && indexDup != m_iIndex)
    {
        NcMsgBox(m_hWnd,
                 IDS_MSFT_TCP_TEXT,
                 IDS_DUP_DNS_SUFFIX,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                 szSuffix);

        ::SetFocus(m_hEdit);

        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE) // Add new address
    {
        m_pParentDlg->m_strNewSuffix = szSuffix;
    }
    else // see if either changed
    {
        if(m_pParentDlg->m_strNewSuffix != szSuffix)
            m_pParentDlg->m_strNewSuffix = szSuffix; // update save addresses
        else
            EndDialog(IDCANCEL);
    }

    EndDialog(IDOK);

    return 0;
}

LRESULT CSuffixDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CSuffixDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
	
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgfilt.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G F I L T. C P P
//
//  Contents:   Implementation of CFilteringDialog and CAddFilterDialog
//
//  Notes:  CFilterDialog is the TCP/IP filtering dialog
//
//  Author: tongl   6 Sept 1998
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncstl.h"
#include "resource.h"
#include "tcphelp.h"
#include "tcpmacro.h"
#include "tcputil.h"
#include "dlgopt.h"

int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    unsigned long a = (unsigned long)lParam1;
    unsigned long b = (unsigned long)lParam2;

    if (a < b)
        return -1;

    return a != b;
}

//
// CFilterDialog
//

CFilterDialog::CFilterDialog(CTcpOptionsPage * pOptionsPage,
                             GLOBAL_INFO * pGlbDlg,
                             ADAPTER_INFO * pAdapterDlg,
                             const DWORD* adwHelpIDs)
{
    Assert(pOptionsPage != NULL);
    Assert(pGlbDlg != NULL);
    Assert(pAdapterDlg != NULL);

    m_pParentDlg   = pOptionsPage;
    m_pGlobalInfo  = pGlbDlg;
    m_pAdapterInfo = pAdapterDlg;
    m_adwHelpIDs   = adwHelpIDs;

    m_fModified = FALSE;
}

CFilterDialog::~CFilterDialog()
{
}

LRESULT CFilterDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    m_hlistTcp = GetDlgItem(IDC_FILTERING_TCP);
    m_hlistUdp = GetDlgItem(IDC_FILTERING_UDP);
    m_hlistIp  = GetDlgItem(IDC_FILTERING_IP);

    // Label columns in the listviews
    LV_COLUMN lvCol;
    RECT rect;
    int iNewCol;

    lvCol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvCol.fmt = LVCFMT_LEFT;

    // TCP ports
    ::GetClientRect(m_hlistTcp, &rect);
    lvCol.pszText = (PWSTR)SzLoadIds(IDS_FILTERING_TCP_LABEL);
    lvCol.cx = rect.right;
    iNewCol = ListView_InsertColumn(m_hlistTcp, 0, &lvCol);
    Assert(iNewCol == 0);

    // UDP ports
    ::GetClientRect(m_hlistUdp, &rect);
    lvCol.pszText = (PWSTR)SzLoadIds(IDS_FILTERING_UDP_LABEL);
    lvCol.cx = rect.right;
    iNewCol = ListView_InsertColumn(m_hlistUdp, 0, &lvCol);
    Assert(iNewCol == 0);

    // IP protocols
    ::GetClientRect(m_hlistIp, &rect);
    lvCol.pszText = (PWSTR)SzLoadIds(IDS_FILTERING_IP_LABEL);
    lvCol.cx = rect.right;
    iNewCol = ListView_InsertColumn(m_hlistIp, 0, &lvCol);
    Assert(iNewCol == 0);

    SetInfo();
    SetButtons();

    m_fModified = FALSE;
    return 0;
}

LRESULT CFilterDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CFilterDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CFilterDialog::OnEnableFiltering( WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        m_fModified = TRUE;

        if (m_pGlobalInfo->m_fEnableFiltering) // if Filtering was enabled
        {
            // disable filtering
            NcMsgBox(::GetActiveWindow(),
                    IDS_MSFT_TCP_TEXT,
                    IDS_FILTERING_DISABLE,
                    MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            m_pGlobalInfo->m_fEnableFiltering = FALSE;
        }
        else
        {
            m_pGlobalInfo->m_fEnableFiltering = TRUE;
        }
    }

    return 0;
}

LRESULT CFilterDialog::OnTcpPermit( WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    m_fModified = TRUE;

    // check "Enable Filtering"
    CheckDlgButton(IDC_FILTERING_ENABLE, TRUE);
    m_pGlobalInfo->m_fEnableFiltering = TRUE;

    EnableGroup(wID, !IsDlgButtonChecked(IDC_FILTERING_FILTER_TCP));
    SetButtons();

    return 0;
}

LRESULT CFilterDialog::OnUdpPermit(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    m_fModified = TRUE;

    // check "Enable Filtering"
    CheckDlgButton(IDC_FILTERING_ENABLE, TRUE);
    m_pGlobalInfo->m_fEnableFiltering = TRUE;

    EnableGroup(wID, !IsDlgButtonChecked(IDC_FILTERING_FILTER_UDP));
    SetButtons();

    return 0;
}

LRESULT CFilterDialog::OnIpPermit(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    m_fModified = TRUE;

    // check "Enable Filtering"
    CheckDlgButton(IDC_FILTERING_ENABLE, TRUE);
    m_pGlobalInfo->m_fEnableFiltering = TRUE;

    EnableGroup(wID, !IsDlgButtonChecked(IDC_FILTERING_FILTER_IP));
    SetButtons();

    return 0;
}

LRESULT CFilterDialog::OnOk(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    if (m_fModified)
    {
        m_pParentDlg->m_fPropDlgModified = TRUE;
        UpdateInfo();
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CFilterDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fModified = FALSE;
    EndDialog(IDCANCEL);

    return 0;
}

LRESULT CFilterDialog::OnAdd(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    CAddFilterDialog * pDlgAddFilter = new CAddFilterDialog(this, 
                                                        wID, 
                                                        g_aHelpIDs_IDD_FILTER_ADD);
    if (pDlgAddFilter == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (pDlgAddFilter->DoModal() == IDOK)
        m_fModified = TRUE;

    SetButtons();

    delete pDlgAddFilter;

    return 0;
}

LRESULT CFilterDialog::OnRemove(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    HWND hList = NULL;
    HWND hAdd = NULL;

    switch (wID)
    {
    case IDC_FILTERING_TCP_REMOVE:
        hList = m_hlistTcp;
        hAdd = GetDlgItem(IDC_FILTERING_TCP_ADD);
        break;

    case IDC_FILTERING_UDP_REMOVE:
        hList = m_hlistUdp;
        hAdd = GetDlgItem(IDC_FILTERING_UDP_ADD);
        break;

    case IDC_FILTERING_IP_REMOVE:
        hList = m_hlistIp;
        hAdd = GetDlgItem(IDC_FILTERING_IP_ADD);
        break;

    default:
        Assert(FALSE);
        break;
    }

    Assert(hList);
    if (NULL == hList || NULL == hAdd)
    {
        return TRUE;
    }

    // see if an item is selected
    int i = (int)::SendMessage(hList, LVM_GETNEXTITEM, -1, MAKELPARAM(LVNI_SELECTED, 0));

    if (i == -1)
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT,
                 IDS_FILTERING_ITEM_NOT_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        return TRUE;
    }

    // remove the item and make item 0 selected
    ListView_DeleteItem(hList, i);
    ListView_GetItemCount(hList);

    m_fModified = TRUE;
    if (i)
    {
        LV_ITEM lvItem;
        lvItem.stateMask = LVIS_SELECTED;
        lvItem.state = LVIS_SELECTED;
        ::SendMessage(hList, LVM_SETITEMSTATE, 0, (LPARAM)&lvItem);
    }
    else // Force focus to the Add button
    {
        IsWindow(::SetFocus(hAdd));
    }

    SetButtons();
    return TRUE;
}

void CFilterDialog::UpdateInfo()
{
    m_pGlobalInfo->m_fEnableFiltering = IsDlgButtonChecked(IDC_FILTERING_ENABLE);

    FreeCollectionAndItem(m_pAdapterInfo->m_vstrTcpFilterList);
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrUdpFilterList);
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrIpFilterList);

    HWND list[3];
    VSTR * pvstr[3];
    int nId[3] = {IDC_FILTERING_FILTER_TCP, IDC_FILTERING_FILTER_UDP, IDC_FILTERING_FILTER_IP};

    // Initialize values
    list[0] = m_hlistTcp;
    list[1] = m_hlistUdp;
    list[2] = m_hlistIp;
    pvstr[0] = &m_pAdapterInfo->m_vstrTcpFilterList;
    pvstr[1] = &m_pAdapterInfo->m_vstrUdpFilterList;
    pvstr[2] = &m_pAdapterInfo->m_vstrIpFilterList;

    for(int iLists = 0; iLists < 3; ++iLists)
    {
        int nlvCount = ListView_GetItemCount(list[iLists]);

        // "" (Empty String) == All ports
        // "0" == No ports
        // "x y z" == ports x, y, x

        // if the All Filter button is checked, use Empty String
        if (IsDlgButtonChecked(nId[iLists]))
        {
            pvstr[iLists]->push_back(new tstring(L"0"));
            continue;
        }

        if (nlvCount == 0)
        {
            pvstr[iLists]->push_back(new tstring(L""));
            continue;
        }

        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iSubItem = 0;

        for (int iItem = 0; iItem < nlvCount; iItem++)
        {
            WCHAR szBuf[16];

            lvItem.iItem = iItem;
            ListView_GetItem(list[iLists], &lvItem);

            Assert(lvItem.lParam != 0);
            _itow((int)lvItem.lParam, szBuf, 10);

            Assert(szBuf);
            pvstr[iLists]->push_back(new tstring(szBuf));
        }
    }
}

void CFilterDialog::SetInfo()
{
    CheckDlgButton(IDC_FILTERING_ENABLE, m_pGlobalInfo->m_fEnableFiltering);

    int anId[3] = {IDC_FILTERING_FILTER_TCP, IDC_FILTERING_FILTER_UDP, IDC_FILTERING_FILTER_IP};
    int anIdSel[3] = {IDC_FILTERING_FILTER_TCP_SEL, IDC_FILTERING_FILTER_UDP_SEL, IDC_FILTERING_FILTER_IP_SEL};
    HWND aplist[3];
    VSTR * apvect[3];

    aplist[0] = m_hlistTcp;
    aplist[1] = m_hlistUdp;
    aplist[2] = m_hlistIp;

    ListView_DeleteAllItems(m_hlistTcp);
    ListView_DeleteAllItems(m_hlistUdp);
    ListView_DeleteAllItems(m_hlistIp);

    apvect[0] = &m_pAdapterInfo->m_vstrTcpFilterList;
    apvect[1] = &m_pAdapterInfo->m_vstrUdpFilterList;
    apvect[2] = &m_pAdapterInfo->m_vstrIpFilterList;

    int iItem;
    for (int iLists = 0; iLists < 3; ++iLists)
    {
        iItem = 0;

        //if the list is empty, that means no value is accepted
        if (apvect[iLists]->empty())
        {
            EnableGroup(anId[iLists], TRUE);
            CheckRadioButton(anId[iLists], anIdSel[iLists], anIdSel[iLists]);
            continue;
        }

        for(VSTR_ITER iter = apvect[iLists]->begin() ; iter != apvect[iLists]->end() ; ++iter)
        {
            if (**iter == L"0")
            {
                EnableGroup(anId[iLists], FALSE);
                CheckRadioButton(anId[iLists], anIdSel[iLists], anId[iLists]);
                break;
            }

            EnableGroup(anId[iLists], TRUE);
            CheckRadioButton(anId[iLists], anIdSel[iLists], anIdSel[iLists]);

            if (**iter == L"")
                break;

            unsigned long nNum = wcstoul((*iter)->c_str(), NULL, 10);

            LV_ITEM lvItem;

            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam = nNum;
            lvItem.iItem = iItem;
            lvItem.iSubItem = 0;
            lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
            lvItem.state =0;
            lvItem.pszText = (PWSTR)(*iter)->c_str();

            ::SendMessage(aplist[iLists], LVM_INSERTITEM, 0, (LPARAM)&lvItem);

            lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
            lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;
            :: SendMessage(aplist[iLists], LVM_SETITEMSTATE, iItem, (LPARAM)&lvItem);

            ++iItem;
        }
        ListView_SortItems(aplist[iLists], CompareFunc, 0);
    }

    // Update the RemoveButtons
    SetButtons();
}

void CFilterDialog::EnableGroup(int nId, BOOL fEnable)
{
    int nIdAdd = 0;
    int nIdRemove = 0;
    int nIdList = 0;

    switch (nId)
    {
    case IDC_FILTERING_FILTER_TCP:
    case IDC_FILTERING_FILTER_TCP_SEL:
        nIdAdd = IDC_FILTERING_TCP_ADD;
        nIdRemove = IDC_FILTERING_TCP_REMOVE;
        nIdList = IDC_FILTERING_TCP;
        break;

    case IDC_FILTERING_FILTER_UDP:
    case IDC_FILTERING_FILTER_UDP_SEL:
        nIdAdd = IDC_FILTERING_UDP_ADD;
        nIdRemove = IDC_FILTERING_UDP_REMOVE;
        nIdList = IDC_FILTERING_UDP;
        break;

    case IDC_FILTERING_FILTER_IP:
    case IDC_FILTERING_FILTER_IP_SEL:
        nIdAdd = IDC_FILTERING_IP_ADD;
        nIdRemove = IDC_FILTERING_IP_REMOVE;
        nIdList = IDC_FILTERING_IP;
        break;

    default:
        Assert(FALSE);
        break;
    }

    if (0 != nIdAdd && 0 != nIdRemove && 0 != nIdList)
    {
        ::EnableWindow(GetDlgItem(nIdAdd), fEnable);
        ::EnableWindow(GetDlgItem(nIdRemove), fEnable);
        ::EnableWindow(GetDlgItem(nIdList), fEnable);
    }
}

void CFilterDialog::SetButtons()
{
    if (ListView_GetItemCount(m_hlistTcp)>0)
    {
        ::EnableWindow(GetDlgItem(IDC_FILTERING_TCP_REMOVE),
                       !IsDlgButtonChecked(IDC_FILTERING_FILTER_TCP));
    }

    if (ListView_GetItemCount(m_hlistUdp)>0)
    {
        ::EnableWindow(GetDlgItem(IDC_FILTERING_UDP_REMOVE),
                       !IsDlgButtonChecked(IDC_FILTERING_FILTER_UDP));
    }

    if (ListView_GetItemCount(m_hlistIp)>0)
    {
        ::EnableWindow(GetDlgItem(IDC_FILTERING_IP_REMOVE),
                       !IsDlgButtonChecked(IDC_FILTERING_FILTER_IP));
    }

}

//
// CAddFilterDialog
//

CAddFilterDialog::CAddFilterDialog(CFilterDialog* pParentDlg, int ID, const DWORD* adwHelpIDs)
{
    Assert(pParentDlg != NULL);
    Assert(ID != 0);

    m_pParentDlg = pParentDlg;
    m_nId = ID;
    m_hList = NULL;

    m_adwHelpIDs = adwHelpIDs;
}

CAddFilterDialog::~CAddFilterDialog()
{
}

LRESULT CAddFilterDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    int nTextId = 0;

    Assert(m_pParentDlg != NULL);

    // Position the dialog
    RECT rect;
    switch (m_nId)
    {
    case IDC_FILTERING_TCP_ADD:
        m_hList = m_pParentDlg->m_hlistTcp;
        nTextId = IDS_FILTERING_TCP_TEXT;
        break;

    case IDC_FILTERING_UDP_ADD:
        m_hList =  m_pParentDlg->m_hlistUdp;
        nTextId = IDS_FILTERING_UDP_TEXT;
        break;

    case IDC_FILTERING_IP_ADD:
        m_hList =  m_pParentDlg->m_hlistIp;
        nTextId = IDS_FILTERING_IP_TEXT;
        break;

    default:
        Assert(FALSE);
        break;
    }

    Assert(IsWindow(m_hList));

    if (IsWindow(m_hList))
    {
        ::GetWindowRect(m_hList, &rect);
        SetWindowPos(NULL,  rect.left, rect.top-8, 0,0,
            SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);
    }

    // Set the static text and limit the edit control to 5 characters
    SetDlgItemText(IDC_FILTERING_TEXT, SzLoadIds(nTextId));
    SendDlgItemMessage(IDC_FILTERING_ADD_EDIT, EM_SETLIMITTEXT, FILTER_ADD_LIMIT, 0);
    ::EnableWindow(GetDlgItem(IDOK), FALSE);

    return TRUE;
}

LRESULT CAddFilterDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAddFilterDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CAddFilterDialog::OnFilterAddEdit(WORD wNotifyCode, WORD wID,
                                            HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case EN_CHANGE:

        ::EnableWindow(GetDlgItem(IDOK),
                       Tcp_Edit_LineLength(GetDlgItem(wID), -1));
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CAddFilterDialog::OnOk(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    WCHAR   szData[FILTER_ADD_LIMIT+1];

    szData[0] = 0;
    ::GetWindowText(GetDlgItem(IDC_FILTERING_ADD_EDIT), szData, FILTER_ADD_LIMIT+1);

    Assert(IsWindow(m_hList));

    // check the range of the number
    PWSTR pStr;
    unsigned long num = wcstoul(szData, &pStr, 10);
    unsigned long maxNum = 65535;
    int nId = IDS_FILTERING_RANGE_WORD;

    if (m_hList == m_pParentDlg->m_hlistIp)
    {
        maxNum = 255;
        nId = IDS_FILTERING_RANGE_BYTE;
    }

    if (num < 1 || num > maxNum)
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_TCP_TEXT,
                 nId,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        return 0;
    }

    // See if the item is in the list
    LV_FINDINFO info;
    info.flags = LVFI_PARAM;
    info.lParam = num;
    int i = ListView_FindItem(m_hList, -1, &info);

    if (i != -1)
    {
       NcMsgBox(::GetActiveWindow(),
                IDS_MSFT_TCP_TEXT,
                IDS_FILTERING_ITEM_IN_LIST,
                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

       return 0;
    }

    int index = ListView_GetItemCount(m_hList);

    LV_ITEM lvItem;

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = num;
    lvItem.iItem = index;
    lvItem.iSubItem = 0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state =0;
    lvItem.pszText = (PWSTR)szData;

    ::SendMessage(m_hList, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

    ListView_SortItems(m_hList, CompareFunc, 0);

    lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;

    ::SendMessage(m_hList, LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)&lvItem);

    EndDialog(IDOK);

    return 0;
}

LRESULT CAddFilterDialog::OnCancel(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDOK);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgopt.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G O P T. H
//
//  Contents:   Declaration for CTcpOptionsPage, CIpSecDialog
//
//  Notes:  CTcpOptionsPage is the Tcpip options page,
//          The other classes are pop-up dislogs for each option
//          on this page.
//
//  Author: tongl   29 Nov 1997
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"

#define FILTER_ADD_LIMIT  5

struct OPTION_ITEM_DATA
{
    INT         iOptionId;
    PWSTR      szName;
    PWSTR      szDesc;
};

// The options page
class CTcpOptionsPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpOptionsPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnQueryCancel)

        // Control message handlers
        COMMAND_ID_HANDLER(IDC_OPT_PROPERTIES, OnProperties)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)

    END_MSG_MAP()

    // Constructors/Destructors
    CTcpOptionsPage(CTcpAddrPage * pTcpAddrPage,
                    ADAPTER_INFO * pAdapterDlg,
                    GLOBAL_INFO  * pGlbDlg,
                    const DWORD  * adwHelpIDs = NULL);

    ~CTcpOptionsPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // command and notification handlers
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // Declare friend class
    friend class CIpSecDialog;
    friend class CFilterDialog;

// Implementation
private:

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}

    void LvProperties(HWND hwndList);

    // data members
    CTcpipcfg *     m_ptcpip;
    CTcpAddrPage *  m_pParentDlg;
    ADAPTER_INFO *  m_pAdapterInfo;
    GLOBAL_INFO  *  m_pGlbInfo;
    const DWORD*    m_adwHelpIDs;

    BOOL            m_fModified;

    // Has any of the property dialogs been modified ?
    BOOL    m_fPropDlgModified;

    BOOL    m_fIpsecPolicySet;
};

/* IP Security dialog is removed
// The IP Security dialog
class CIpSecDialog : public CDialogImpl<CIpSecDialog>
{
public:

    enum { IDD = IDD_IPSEC };

    BEGIN_MSG_MAP(CIpSecDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_DESTROY, OnDestroyDialog);

        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        // command handlers
        COMMAND_ID_HANDLER(IDC_RAD_IPSEC_NOIPSEC, OnNoIpsec);
        COMMAND_ID_HANDLER(IDC_RAD_IPSEC_CUSTOM, OnUseCustomPolicy);
        COMMAND_ID_HANDLER(IDC_CMB_IPSEC_POLICY_LIST, OnSelectCustomPolicy);

    END_MSG_MAP()
//
public:
    CIpSecDialog( CTcpOptionsPage * pOptionsPage,
                  GLOBAL_INFO * pGlbDlg,
                  const DWORD* pamhidsHelp = NULL);

    ~CIpSecDialog();

// Dialog creation overides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnDestroyDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnNoIpsec(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUseCustomPolicy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSelectCustomPolicy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:

    HRESULT HrGetDomainIpsecPolicy(BOOL * pfHasDomainIpsecPolicy,
                                   tstring * pszDomainIpsecPolicyName);

    HRESULT HrShowDomainIpsecPolicy(PCWSTR szDomainIpsecPolicyName);
    HRESULT HrShowLocalIpsecPolicy();
    HRESULT HrSelectActivePolicy(GUID * guidIpsecPol);

    BOOL m_fInInitDialog;

    CTcpOptionsPage * m_pParentDlg;
    GLOBAL_INFO *  m_pGlobalInfo;
    const DWORD *  m_adwHelpIDs;
};
*/

// Tcpip security (Trajon) dialogs
class CFilterDialog;

class CAddFilterDialog : public CDialogImpl<CAddFilterDialog>
{
public:

    enum { IDD = IDD_FILTER_ADD };

    BEGIN_MSG_MAP(CAddFilterDialog)

        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_FILTERING_ADD_EDIT,  OnFilterAddEdit);

    END_MSG_MAP()
//
public:
    CAddFilterDialog(CFilterDialog* pParentDlg, int ID, const DWORD* adwHelpIDs = NULL);
    ~CAddFilterDialog();

// Dialog creation overides
public:

// Command Handlers
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnFilterAddEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:
    CFilterDialog*    m_pParentDlg;
    int               m_nId;
    HWND              m_hList;
    const DWORD*      m_adwHelpIDs;
};

class CFilterDialog : public CNetCfgDebug<CFilterDialog>,
                      public CDialogImpl<CFilterDialog>
{
public:

    enum { IDD = IDD_FILTER };

    BEGIN_MSG_MAP(CFilterDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        // Enable Filtering checkbox
        COMMAND_ID_HANDLER(IDC_FILTERING_ENABLE,     OnEnableFiltering);

        // The TCP ports radio buttons
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_TCP,     OnTcpPermit);
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_TCP_SEL, OnTcpPermit);

        // The UDP ports radio buttons
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_UDP,     OnUdpPermit);
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_UDP_SEL, OnUdpPermit);

        // The IP Protocols radio buttons
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_IP,      OnIpPermit);
        COMMAND_ID_HANDLER(IDC_FILTERING_FILTER_IP_SEL,  OnIpPermit);

        // Add buttons for TCP, UDP and IP

        COMMAND_ID_HANDLER(IDC_FILTERING_TCP_ADD,  OnAdd);
        COMMAND_ID_HANDLER(IDC_FILTERING_UDP_ADD,  OnAdd);
        COMMAND_ID_HANDLER(IDC_FILTERING_IP_ADD,   OnAdd);

        // Remove buttons for TCP, UDP and IP

        COMMAND_ID_HANDLER(IDC_FILTERING_TCP_REMOVE,  OnRemove);
        COMMAND_ID_HANDLER(IDC_FILTERING_UDP_REMOVE,  OnRemove);
        COMMAND_ID_HANDLER(IDC_FILTERING_IP_REMOVE,   OnRemove);

    END_MSG_MAP()

    friend class CAddFilterDialog;

public:
    CFilterDialog(  CTcpOptionsPage * pOptionsPage,
                    GLOBAL_INFO * pGlbDlg,
                    ADAPTER_INFO * pAdapterDlg,
                    const DWORD* pamhidsHelp = NULL);

    ~CFilterDialog();

// Dialog creation overrides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnEnableFiltering(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnTcpPermit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUdpPermit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpPermit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:

    // help functions
    void    SetInfo();
    void    UpdateInfo();
    void    EnableGroup(int nId, BOOL state);
    void    SetButtons();

    // data members
    GLOBAL_INFO *       m_pGlobalInfo;
    ADAPTER_INFO *      m_pAdapterInfo;

    CTcpOptionsPage *   m_pParentDlg;
    BOOL                m_fModified;

    const   DWORD * m_adwHelpIDs;

    HWND    m_hlistTcp;
    HWND    m_hlistUdp;
    HWND    m_hlistIp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgras.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G R A S. C P P
//
//  Contents:   Implementation for CTcpRasPage
//
//  Notes:  CTcpRasPage is for setting PPP/SLIP specific parameters
//
//  Author: tongl   10 Apr 1998
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncstl.h"
#include "resource.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "dlgras.h"
#include "dlgaddr.h"

//
// CTcpRasPage
//

CTcpRasPage::CTcpRasPage( CTcpAddrPage * pTcpAddrPage,
                          ADAPTER_INFO * pAdapterDlg,
                          const DWORD  * adwHelpIDs )
{
    Assert(pTcpAddrPage);
    Assert(pAdapterDlg);

    m_pParentDlg = pTcpAddrPage;
    m_pAdapterInfo = pAdapterDlg;
    m_adwHelpIDs = adwHelpIDs;

    m_fModified = FALSE;
}

CTcpRasPage::~CTcpRasPage()
{
}

LRESULT CTcpRasPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    AssertSz(((CONNECTION_RAS_PPP == m_pParentDlg->m_ConnType)||
              (CONNECTION_RAS_SLIP == m_pParentDlg->m_ConnType)||
              (CONNECTION_RAS_VPN == m_pParentDlg->m_ConnType)),
              "Why bring up the RAS property on a non-RAS connection?");

	// Fix bug 381870, If the interface is demand dial, then disable 
	// the "Use default gateway on the remote network" checkbox
	if (m_pAdapterInfo->m_fIsDemandDialInterface)
	{
		::EnableWindow(GetDlgItem(IDC_STATIC_REMOTE_GATEWAY), FALSE);
		::EnableWindow(GetDlgItem(IDC_REMOTE_GATEWAY), FALSE);
	}
	

	// Set the "Use default gateway on the remote network" checkbox
	CheckDlgButton(IDC_REMOTE_GATEWAY, m_pAdapterInfo->m_fUseRemoteGateway);
	
    if (CONNECTION_RAS_PPP == m_pParentDlg->m_ConnType)
    {
        ::ShowWindow(GetDlgItem(IDC_GRP_SLIP), SW_HIDE);

        // if PPP connection, hide "Frame Size" control
        ::ShowWindow(GetDlgItem(IDC_CMB_FRAME_SIZE), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_STATIC_FRAME_SIZE), SW_HIDE);
    }
    else if (CONNECTION_RAS_VPN == m_pParentDlg->m_ConnType)
    {
        //if VPN connection, hide the group box and the "Frame Size" control
        ::ShowWindow(GetDlgItem(IDC_GRP_PPP), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_GRP_SLIP), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_CHK_USE_COMPRESSION), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_CMB_FRAME_SIZE), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_STATIC_FRAME_SIZE), SW_HIDE);
    }
    else
    {
        ::ShowWindow(GetDlgItem(IDC_GRP_PPP), SW_HIDE);

        // initialize the combo box & show current selection
        int idx;

        idx = (int)SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_ADDSTRING, 0,
                                      (LPARAM)(c_szFrameSize1006));
        if (idx != CB_ERR)
        {
            SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_SETITEMDATA,
                               idx, (LPARAM)c_dwFrameSize1006);

            if (1006 == m_pParentDlg->m_pAdapterInfo->m_dwFrameSize)
                SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_SETCURSEL, idx, 0);
        }

        idx = (int)SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_ADDSTRING, 0,
                                      (LPARAM)(c_szFrameSize1500));
        if (idx != CB_ERR)
        {
           SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_SETITEMDATA,
                               idx, (LPARAM)c_dwFrameSize1500);

           if (1500 == m_pParentDlg->m_pAdapterInfo->m_dwFrameSize)
            {
                SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_SETCURSEL, idx, 0);
            }
        }
    }

    // initialize the checkbox
    CheckDlgButton(IDC_CHK_USE_COMPRESSION,
                   m_pParentDlg->m_pAdapterInfo->m_fUseIPHeaderCompression);

    return 0;
}

LRESULT CTcpRasPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpRasPage::OnHelp(UINT uMsg, WPARAM wParam,
                            LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CTcpRasPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpRasPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpRasPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpRasPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    // update value in second memory

    // Add remote gateway stuff
    BOOL fUseRemoteGateway = IsDlgButtonChecked(IDC_REMOTE_GATEWAY);
    if (fUseRemoteGateway != m_pAdapterInfo->m_fUseRemoteGateway)
    {
        m_pAdapterInfo->m_fUseRemoteGateway = fUseRemoteGateway;
        PageModified();
    }

    // header compression
    BOOL fUseHeaderCompression = IsDlgButtonChecked(IDC_CHK_USE_COMPRESSION);
    if (fUseHeaderCompression != m_pAdapterInfo->m_fUseIPHeaderCompression)
    {
        m_pAdapterInfo->m_fUseIPHeaderCompression = fUseHeaderCompression;
        PageModified();
    }

    // frame size
    if (CONNECTION_RAS_SLIP == m_pParentDlg->m_ConnType)
    {
        int idx = (int)SendDlgItemMessage(IDC_CMB_FRAME_SIZE, CB_GETCURSEL, 0L, 0L);
        if (idx != CB_ERR)
        {
            DWORD dwFrameSize = (DWORD)SendDlgItemMessage(IDC_CMB_FRAME_SIZE, 
                                                          CB_GETITEMDATA, idx, 0L);

            if ((dwFrameSize != CB_ERR) && (dwFrameSize != m_pAdapterInfo->m_dwFrameSize))
            {
                PageModified();
                m_pAdapterInfo->m_dwFrameSize = dwFrameSize;
            }
        }
    }

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    // reset status
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgopt.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G O P T. C P P
//
//  Contents:   Implementation for CTcpOptionsPage
//
//  Notes:  CTcpOptionsPage is the Tcpip options page,
//          The other classes are pop-up dislogs for each option
//          on this page.
//
//  Author: tongl   29 Nov 1997
//-----------------------------------------------------------------------
//
// CTcpOptionsPage
//

#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncstl.h"
#include "resource.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "dlgopt.h"
#include "dlgaddr.h"
#include "tcphelp.h"

//Whistler bug 123164, we remove the ipsec from the connection UI
const int c_rgsLanOptions[] = { c_iIpFilter };

//
// CTcpOptionsPage
//

CTcpOptionsPage::CTcpOptionsPage(CTcpAddrPage * pTcpAddrPage,
                                 ADAPTER_INFO * pAdapterDlg,
                                 GLOBAL_INFO  * pGlbDlg,
                                 const DWORD  * adwHelpIDs)
{
    Assert(pTcpAddrPage);
    Assert(pAdapterDlg);
    Assert(pGlbDlg);

    m_pParentDlg = pTcpAddrPage;
    m_pAdapterInfo = pAdapterDlg;
    m_pGlbInfo = pGlbDlg;
    m_adwHelpIDs = adwHelpIDs;

    m_fModified = FALSE;
    m_fPropDlgModified = FALSE;

    //IPSec is removed from connection UI   
    //m_fIpsecPolicySet = FALSE;
}

CTcpOptionsPage::~CTcpOptionsPage()
{
}

// message map functions
LRESULT CTcpOptionsPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    // Initialize the list view
    HWND hwndList = GetDlgItem(IDC_LVW_OPTIONS);

    RECT      rc;
    LV_COLUMN lvc = {0};

    ::GetClientRect(hwndList, &rc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(GetDlgItem(IDC_LVW_OPTIONS), 0, &lvc);

    // Insert options and description text
    LV_ITEM lvi = {0};
    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    int iMaxOptions = 0;
    const int * pOptions = NULL;

    // RAS connections don't have option tab at all
    ASSERT(!m_pAdapterInfo->m_fIsRasFakeAdapter);
    if (!m_pAdapterInfo->m_fIsRasFakeAdapter)
    {
        iMaxOptions = celems(c_rgsLanOptions);
        pOptions = c_rgsLanOptions;
    }

    for (int i = 0; i < iMaxOptions; i++)
    {
        lvi.iItem = i;

        OPTION_ITEM_DATA * pItemData = new OPTION_ITEM_DATA;

        if (NULL == pItemData)
            continue;

        ASSERT(pOptions);
        
        switch (pOptions[i])
        {
        case c_iIpFilter:
            pItemData->iOptionId = c_iIpFilter;
            pItemData->szName = (PWSTR) SzLoadIds(IDS_IP_FILTERING);
            pItemData->szDesc = (PWSTR) SzLoadIds(IDS_IP_FILTERING_DESC);
            break;

        default:
            AssertSz(FALSE, "Invalid option");
        }

        lvi.lParam = reinterpret_cast<LPARAM>(pItemData);
        lvi.pszText = pItemData->szName;

        INT ret;
        ret = ListView_InsertItem(hwndList, &lvi);
    }

    // set the top item as the current selection
    ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);

    //this is a ras connection and a non-admin user, disable all the controls 
    //for globl settings
    if (m_pAdapterInfo->m_fIsRasFakeAdapter && m_pParentDlg->m_fRasNotAdmin)
    {
        ::EnableWindow(GetDlgItem(IDC_OPT_PROPERTIES), FALSE);
    }
    
    return 0;
}

LRESULT CTcpOptionsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpOptionsPage::OnHelp(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CTcpOptionsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    //IPSec is removed from connection UI   
    //if (!m_pParentDlg->m_fIpsecPolicySet)
    //    m_pParentDlg->m_fIpsecPolicySet = m_fIpsecPolicySet;

    // reset status
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CTcpOptionsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpOptionsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpOptionsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpOptionsPage::OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpOptionsPage::OnProperties(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& fHandled)
{
    HWND hwndList = GetDlgItem(IDC_LVW_OPTIONS);
    Assert(hwndList);

    LvProperties(hwndList);

    return 0;
}

LRESULT CTcpOptionsPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
    HWND hwndList = GetDlgItem(IDC_LVW_OPTIONS);

    Assert(pnmlv);

    // Check if selection changed
    if ((pnmlv->uNewState & LVIS_SELECTED) &&
        (!(pnmlv->uOldState & LVIS_SELECTED)))
    {
        // enable Property button if valid and update description text
        INT iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

        if (iSelected == -1) // Nothing selected or list empty
        {
            // if list is empty
            ::EnableWindow(GetDlgItem(IDC_OPT_PROPERTIES), FALSE);
            ::SetWindowText(GetDlgItem(IDC_OPT_DESC), c_szEmpty);
        }
        else
        {
            LV_ITEM lvItem;
            lvItem.mask = LVIF_PARAM;
            lvItem.iItem = iSelected;
            lvItem.iSubItem = 0;

            if (ListView_GetItem(hwndList, &lvItem))
            {
                OPTION_ITEM_DATA * pItemData = NULL;
                pItemData = reinterpret_cast<OPTION_ITEM_DATA *>(lvItem.lParam);
                if (pItemData)
                {
                    //this is a ras connection and a non-admin user, Dont enable the 
                    // "properties" button
                    if (!(m_pAdapterInfo->m_fIsRasFakeAdapter && m_pParentDlg->m_fRasNotAdmin))
                    {
                        ::EnableWindow(GetDlgItem(IDC_OPT_PROPERTIES), TRUE);
                    }

                    ::SetWindowText(GetDlgItem(IDC_OPT_DESC), (PCWSTR)pItemData->szDesc);
                }
            }
        }
    }

    return 0;
}

LRESULT CTcpOptionsPage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    INT iItem;
    DWORD dwpts;
    RECT rc;
    LV_HITTESTINFO lvhti;

    //don't bring up the propeties of the selected option if the user is not admin
    if (m_pAdapterInfo->m_fIsRasFakeAdapter && m_pParentDlg->m_fRasNotAdmin)
        return 0;

    HWND hwndList = GetDlgItem(IDC_LVW_OPTIONS);

    // we have the location
    dwpts = GetMessagePos();

    // translate it relative to the listview
    ::GetWindowRect( hwndList, &rc );

    lvhti.pt.x = LOWORD( dwpts ) - rc.left;
    lvhti.pt.y = HIWORD( dwpts ) - rc.top;

    // get currently selected item
    iItem = ListView_HitTest( hwndList, &lvhti );

    // if valid selection
    if (-1 != iItem)
    {
        LvProperties(hwndList);
    }

    return 0;
}

void CTcpOptionsPage::LvProperties(HWND hwndList)
{
    INT iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    if (iSelected != -1)
    {
        LV_ITEM     lvItem = {0};

        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            OPTION_ITEM_DATA * pItemData = NULL;

            pItemData = reinterpret_cast<OPTION_ITEM_DATA *>(lvItem.lParam);

            if (pItemData)
            {
                // bring up the proper dialog
                switch(pItemData->iOptionId)
                {
                    case c_iIpFilter:
                    {
                        // make a copy of the global and adapter info & pass to the filter dialog
                        GLOBAL_INFO  glbInfo;
                        
                        glbInfo = *m_pGlbInfo;

                        ADAPTER_INFO adapterInfo;
                        adapterInfo = *m_pAdapterInfo;

                        CFilterDialog * pDlgFilter = new CFilterDialog(this, 
                                                            &glbInfo, 
                                                            &adapterInfo, 
                                                            g_aHelpIDs_IDD_FILTER);
                        if (NULL == pDlgFilter)
                            return;

                        if (pDlgFilter->DoModal() == IDOK)
                        {
                            if (m_fPropDlgModified)
                            {
                                // Something changed,
                                // so copy the changes and mark the page as modified
                                *m_pGlbInfo = glbInfo;
                                *m_pAdapterInfo = adapterInfo;

                                PageModified();
                                m_fPropDlgModified = FALSE;
                            }
                        }
                        delete pDlgFilter;
                    }
                    break;

                    default:
                        AssertSz(FALSE, "Invalid option");
                        break;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgras.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L G R A S. H
//
//  Contents:   Declaration for CTcpRasPage
//
//  Notes:  CTcpRasPage is for setting PPP/SLIP specific parameters
//
//  Author: tongl   10 Apr 1998
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>

class CTcpRasPage : public CPropSheetPage
{

public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpRasPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

    END_MSG_MAP()

// Constructors/Destructors
    CTcpRasPage(CTcpAddrPage * pTcpAddrPage,
                ADAPTER_INFO * pAdapterDlg,
                const DWORD * adwHelpIDs = NULL);

    ~CTcpRasPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

private:
    CTcpAddrPage *   m_pParentDlg;
    ADAPTER_INFO *   m_pAdapterInfo;

    BOOL            m_fModified;
    const DWORD*    m_adwHelpIDs;

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgwins.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P W I N S . C P P
//
//  Contents:   CTcpWinsPage implementation
//
//  Notes:  The "WINS Address" page
//
//  Author: tongl   12 Nov 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"
#include "ncmisc.h"
#include "tcpconst.h"
#include "tcpipobj.h"
#include "resource.h"
#include "tcpmacro.h"
#include "dlgaddr.h"
#include "dlgwins.h"

#include "tcpconst.h"
#include "tcputil.h"
#include "tcphelp.h"

#define MAX_WINS_SERVER     12
#define MAX_RAS_WINS_SERVER 2

CTcpWinsPage::CTcpWinsPage( CTcpipcfg * ptcpip,
                            CTcpAddrPage * pTcpAddrPage,
                            ADAPTER_INFO * pAdapterDlg,
                            GLOBAL_INFO  * pGlbDlg,
                            const DWORD  * adwHelpIDs)
{
    // Save everything passed to us
    Assert(ptcpip != NULL);
    m_ptcpip = ptcpip;

    Assert(pTcpAddrPage != NULL);
    m_pParentDlg = pTcpAddrPage;

    Assert(pAdapterDlg != NULL);
    m_pAdapterInfo = pAdapterDlg;

    Assert(pGlbDlg != NULL);
    m_pglb = pGlbDlg;

    m_adwHelpIDs = adwHelpIDs;

    // Initialize internal states
    m_fModified = FALSE;
    m_fLmhostsFileReset = FALSE;

    WCHAR* pch;

    // gives double NULL by default
    ZeroMemory(m_szFilter, sizeof(m_szFilter));
    ZeroMemory(&m_ofn, sizeof(m_ofn));
    wsprintfW(m_szFilter, L"%s|%s", (PCWSTR)SzLoadIds(IDS_COMMONDLG_TEXT),  L"*.*");

    // replace '|' with NULL, required by common dialog
    pch = m_szFilter;
    while ((pch = wcschr(pch, '|')) != NULL)
            *pch++ = L'\0';

    m_ofn.lStructSize = sizeof(OPENFILENAME);
    m_ofn.hInstance = _Module.GetModuleInstance();
    m_ofn.lpstrFilter = m_szFilter;
    m_ofn.nFilterIndex = 1L;
}

LRESULT CTcpWinsPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    // Initialize the Wins address listbox
    m_fEditState = FALSE;

    // Cache hwnds
    m_hServers.m_hList      = GetDlgItem(IDC_WINS_SERVER_LIST);
    m_hServers.m_hAdd       = GetDlgItem(IDC_WINS_ADD);
    m_hServers.m_hEdit      = GetDlgItem(IDC_WINS_EDIT);
    m_hServers.m_hRemove    = GetDlgItem(IDC_WINS_REMOVE);
    m_hServers.m_hUp        = GetDlgItem(IDC_WINS_UP);
    m_hServers.m_hDown      = GetDlgItem(IDC_WINS_DOWN);

    // Set the up\down arrow icons
    SendDlgItemMessage(IDC_WINS_UP, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconUpArrow));
    SendDlgItemMessage(IDC_WINS_DOWN, BM_SETIMAGE, IMAGE_ICON,
                       reinterpret_cast<LPARAM>(g_hiconDownArrow));

    // Get the Service address Add and Edit button Text and remove ellipse
    WCHAR   szAddServer[16];

    GetDlgItemText(IDC_WINS_ADD, szAddServer, celems(szAddServer));

    szAddServer[lstrlenW(szAddServer) - c_cchRemoveCharatersFromEditOrAddButton] = 0;
    m_strAddServer = szAddServer;

    // Initialize controls on this page
    // WINS server list box
    int nResult= LB_ERR;
    for(VSTR_ITER iterWinsServer = m_pAdapterInfo->m_vstrWinsServerList.begin() ;
        iterWinsServer != m_pAdapterInfo->m_vstrWinsServerList.end() ;
        ++iterWinsServer)
    {
        nResult = Tcp_ListBox_InsertString(m_hServers.m_hList, -1,
                                           (*iterWinsServer)->c_str());
    }

    // set slection to first item
    if (nResult >= 0)
    {
        Tcp_ListBox_SetCurSel(m_hServers.m_hList, 0);
    }

    SetButtons(m_hServers,
        (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);

    // Enable LMHosts lookup ?
    CheckDlgButton(IDC_WINS_LOOKUP, m_pglb->m_fEnableLmHosts);
    ::EnableWindow(GetDlgItem(IDC_WINS_LMHOST), m_pglb->m_fEnableLmHosts);

    // Enable NetBt ?
    CheckDlgButton( IDC_RAD_ENABLE_NETBT,
                    (c_dwEnableNetbios == m_pAdapterInfo->m_dwNetbiosOptions));

    CheckDlgButton( IDC_RAD_DISABLE_NETBT,
                    (c_dwDisableNetbios == m_pAdapterInfo->m_dwNetbiosOptions));

    CheckDlgButton( IDC_RAD_UNSET_NETBT,
                    (c_dwUnsetNetbios == m_pAdapterInfo->m_dwNetbiosOptions));
    
    if (m_pAdapterInfo->m_fIsRasFakeAdapter)
    {
        //if this is a ras connection, disable the default Netbt option since it
        //doesn't apply to RAS connections
        ::EnableWindow(GetDlgItem(IDC_RAD_UNSET_NETBT), FALSE);
        ::EnableWindow(GetDlgItem(IDC_STATIC_DEFALUT_NBT), FALSE);

        //this is a ras connection and a non-admin user, disable all the controls 
        //for globl settings
        if (m_pParentDlg->m_fRasNotAdmin)
        {
            ::EnableWindow(GetDlgItem(IDC_WINS_STATIC_GLOBAL), FALSE);
            ::EnableWindow(GetDlgItem(IDC_WINS_LOOKUP), FALSE);
            ::EnableWindow(GetDlgItem(IDC_WINS_LMHOST), FALSE);
        }

    }
    

    return 0;
}

LRESULT CTcpWinsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CTcpWinsPage::OnHelp(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CTcpWinsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpWinsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, 0);
    return 0;
}

LRESULT CTcpWinsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    // server list
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrWinsServerList);
    int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    WCHAR szBuf[IP_LIMIT];

    for (int i = 0; i < nCount; i++)
    {
        #ifdef DBG
            int len = Tcp_ListBox_GetTextLen(m_hServers.m_hList, i);
            Assert(len != LB_ERR && len < IP_LIMIT);
        #endif

        Tcp_ListBox_GetText(m_hServers.m_hList, i, szBuf);
        m_pAdapterInfo->m_vstrWinsServerList.push_back(new tstring(szBuf));
    }

    // save checkbox states
    m_pglb->m_fEnableLmHosts = IsDlgButtonChecked(IDC_WINS_LOOKUP);

    // pass the info back to its parent dialog
    m_pParentDlg->m_fPropShtOk = TRUE;

    if(!m_pParentDlg->m_fPropShtModified)
        m_pParentDlg->m_fPropShtModified = IsModified();

    m_pParentDlg->m_fLmhostsFileReset = m_fLmhostsFileReset;

    // reset status
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CTcpWinsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CTcpWinsPage::OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, FALSE);
    return 0;
}

// WINS server related controls
LRESULT CTcpWinsPage::OnAddServer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CWinsServerDialog DlgSrv(this, g_aHelpIDs_IDD_WINS_SERVER);

    if (DlgSrv.DoModal() == IDOK)
    {
        int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);
        int idx = Tcp_ListBox_InsertString(m_hServers.m_hList,
                                           -1,
                                           m_strNewIpAddress.c_str());
        Assert(idx>=0);
        if (idx >= 0)
        {
            PageModified();

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);
            SetButtons(m_hServers,
                (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);

            // empty strings, this removes the saved address from RemoveIP
            m_strNewIpAddress = L"";
        }
    }

    return 0;
}

LRESULT CTcpWinsPage::OnEditServer(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;


    Assert(Tcp_ListBox_GetCount(m_hServers.m_hList));

    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);
    Assert(idx >= 0);

    CWinsServerDialog DlgSrv(this, g_aHelpIDs_IDD_WINS_SERVER, idx);

    // save off the removed address and delete if from the listbox
    if (idx >= 0)
    {
        WCHAR buf[IP_LIMIT];

        Assert(Tcp_ListBox_GetTextLen(m_hServers.m_hList, idx) < celems(buf));
        Tcp_ListBox_GetText(m_hServers.m_hList, idx, buf);

        m_strNewIpAddress = buf;  // used by dialog to display what to edit

        if (DlgSrv.DoModal() == IDOK)
        {
            // replace the item in the listview with the new information
            Tcp_ListBox_DeleteString(m_hServers.m_hList, idx);

            PageModified();

            m_strMovingEntry = m_strNewIpAddress;
            ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

            m_strNewIpAddress = buf;  // restore the original removed address
        }
        else
        {
            // empty strings, this removes the saved address from RemoveIP
            m_strNewIpAddress = L"";
        }
    }

    return 0;
}

LRESULT CTcpWinsPage::OnRemoveServer(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);

    Assert(idx >=0);

    if (idx >=0)
    {
        WCHAR buf[IP_LIMIT];

        Assert(Tcp_ListBox_GetTextLen(m_hServers.m_hList, idx) < celems(buf));
        Tcp_ListBox_GetText(m_hServers.m_hList, idx, buf);

        m_strNewIpAddress = buf;
        Tcp_ListBox_DeleteString(m_hServers.m_hList, idx);

        PageModified();

        // select a new item
        int nCount;

        if ((nCount = Tcp_ListBox_GetCount(m_hServers.m_hList)) != LB_ERR)
        {
            // select the previous item in the list
            if (idx)
                --idx;

            Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);
        }
        SetButtons(m_hServers,
            (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);
    }
    return 0;
}

LRESULT CTcpWinsPage::OnServerUp(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hServers.m_hList);
    int  nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    Assert(nCount);
    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);

    Assert(idx != 0);

    if (ListBoxRemoveAt(m_hServers.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    --idx;
    PageModified();
    ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());

    Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

    SetButtons(m_hServers,
        (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);

    return 0;
}


LRESULT CTcpWinsPage::OnServerDown(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    Assert(m_hServers.m_hList);
    int nCount = Tcp_ListBox_GetCount(m_hServers.m_hList);

    Assert(nCount);

    int idx = Tcp_ListBox_GetCurSel(m_hServers.m_hList);
    --nCount;

    Assert(idx != nCount);

    if (ListBoxRemoveAt(m_hServers.m_hList, idx, &m_strMovingEntry) == FALSE)
    {
        Assert(FALSE);
        return 0;
    }

    ++idx;
    PageModified();

    ListBoxInsertAfter(m_hServers.m_hList, idx, m_strMovingEntry.c_str());
    Tcp_ListBox_SetCurSel(m_hServers.m_hList, idx);

    SetButtons(m_hServers,
        (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);

    return 0;
}

LRESULT CTcpWinsPage::OnServerList(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case LBN_SELCHANGE:
        SetButtons(m_hServers,
            (m_pAdapterInfo->m_fIsRasFakeAdapter) ? MAX_RAS_WINS_SERVER : MAX_WINS_SERVER);
        break;

    default:
        break;
    }

    return 0;
}

LRESULT CTcpWinsPage::OnLookUp(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{

    ::EnableWindow(GetDlgItem(IDC_WINS_LMHOST),
                   IsDlgButtonChecked(IDC_WINS_LOOKUP) == BST_CHECKED);


    PageModified();
    return 0;
}

LRESULT CTcpWinsPage::OnLMHost(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szFileName[MAX_PATH] = {NULL}; // initialize first character
    WCHAR szFileTitle[MAX_PATH] = {NULL}; // initialize first character

    // see if the Lookup check-box is checked
    Assert(IsDlgButtonChecked(IDC_WINS_LOOKUP) == BST_CHECKED);

    // add runtime info
    m_ofn.hwndOwner         = m_hWnd;
    m_ofn.lpstrFile         = szFileName;
    m_ofn.nMaxFile          = celems(szFileName);
    m_ofn.lpstrFileTitle    = szFileTitle;
    m_ofn.nMaxFileTitle     = celems(szFileTitle);

    //if we are in GUI setup mode, explorer is not registered yet.
    //we need to use the old style of File Open dialog
    m_ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
    if (!FInSystemSetup())
    {
        m_ofn.Flags |= OFN_EXPLORER;
    }
    else
    {
        m_ofn.Flags |= OFN_ENABLEHOOK;
        m_ofn.lpfnHook = HookProcOldStyle;
    }

    WCHAR szSysPath[MAX_PATH];
    WCHAR szSysPathBackup[MAX_PATH];

    BOOL fSysPathFound = (GetSystemDirectory(szSysPath, MAX_PATH) != 0);

    if (fSysPathFound  && GetOpenFileName(&m_ofn)) // bring up common dialog
    {
        lstrcpyW(szSysPathBackup, szSysPath);
        wcscat(szSysPath, RGAS_LMHOSTS_PATH);

        // Backup the original lmhosts file if it hasn't been set dirty
        if (!m_ptcpip->FIsSecondMemoryLmhostsFileReset())
        {
            wcscat(szSysPathBackup, RGAS_LMHOSTS_PATH_BACKUP);

            WIN32_FIND_DATA FileData;
            if (FindFirstFile(szSysPath, &FileData) != INVALID_HANDLE_VALUE)
            {
                BOOL ret;

                // Copy lmhosts file to lmhosts.bak if it already exists
                ret = CopyFile(szSysPath, szSysPathBackup, FALSE);
                AssertSz(ret, "Failed to backup existing lmhosts file!");
            }
        }

        if (CopyFile(szFileName, szSysPath, FALSE) == 0) // overwrie lmhosts file
        {
            TraceError("CTcpWinsPage::OnLMHost", HrFromLastWin32Error());

            // cannot copy the file to the %system32%\drivers\etc dir
            NcMsgBox(::GetActiveWindow(),
                     IDS_MSFT_TCP_TEXT,
                     IDS_CANNOT_CREATE_LMHOST_ERROR,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK,
                     szSysPath);
            return 0;
        }
        else
        {
            // Set the flag so we can notify netbt of the change
            m_fLmhostsFileReset = TRUE;
        }

        TraceTag(ttidTcpip,"File Selected: %S", szSysPath);
    }
    else
    {
        // syspath failed
        if (fSysPathFound == FALSE)
            NcMsgBox(::GetActiveWindow(),
                     IDS_MSFT_TCP_TEXT,
                     IDS_WINS_SYSTEM_PATH,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
        else if (szFileName[0] != NULL) // get open failed
        {
            NcMsgBox(::GetActiveWindow(),
                     IDS_MSFT_TCP_TEXT,
                     IDS_WINS_LMHOSTS_FAILED,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                     szSysPath);
        }
    }

    return 0;
}

LRESULT CTcpWinsPage::OnEnableNetbios(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (m_pAdapterInfo->m_dwNetbiosOptions != c_dwEnableNetbios)
        {
            PageModified();

            // Update in memory structure
            m_pAdapterInfo->m_dwNetbiosOptions = c_dwEnableNetbios;
        }
        break;
    } // switch

    return 0;
}

LRESULT CTcpWinsPage::OnDisableNetbios(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (m_pAdapterInfo->m_dwNetbiosOptions != c_dwDisableNetbios)
        {
            PageModified();

            // Update in memory structure
            m_pAdapterInfo->m_dwNetbiosOptions = c_dwDisableNetbios;
        }
        break;
    } // switch

    return 0;
}

LRESULT CTcpWinsPage::OnUnsetNetBios(WORD wNotifyCode, WORD wID,
                                     HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        if (m_pAdapterInfo->m_dwNetbiosOptions != c_dwUnsetNetbios)
        {
            PageModified();

            // Update in memory structure
            m_pAdapterInfo->m_dwNetbiosOptions = c_dwUnsetNetbios;
        }
        break;
    } // switch

    return 0;
}

//
// CWinsServerDialog
//

CWinsServerDialog::CWinsServerDialog(CTcpWinsPage * pTcpWinsPage,
                                     const DWORD* adwHelpIDs,
                                     int iIndex)
{
    Assert(pTcpWinsPage);
    m_pParentDlg = pTcpWinsPage;
    m_hButton = 0;
    m_adwHelpIDs = adwHelpIDs;
    m_iIndex = iIndex;
}

LRESULT CWinsServerDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAddServer.c_str());

    m_ipAddress.Create(m_hWnd, IDC_WINS_CHANGE_SERVER);
    m_ipAddress.SetFieldRange(0, c_iIPADDR_FIELD_1_LOW, c_iIPADDR_FIELD_1_HIGH);

    // if editing an ip address fill the controls with the current information
    // if removing an ip address save it and fill the add dialog with it next time
    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_WINS_SERVER_LIST);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
        SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    m_hButton = GetDlgItem(IDOK);

    // add the address that was just removed
    if (m_pParentDlg->m_strNewIpAddress.size())
    {
        m_ipAddress.SetAddress(m_pParentDlg->m_strNewIpAddress.c_str());
        ::EnableWindow(m_hButton, TRUE);
    }
    else
    {
        m_pParentDlg->m_strNewIpAddress = L"";
        ::EnableWindow(m_hButton, FALSE);
    }

    ::SetFocus(m_ipAddress);
    return 0;
}

LRESULT CWinsServerDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                         LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CWinsServerDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CWinsServerDialog::OnChange(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    if (m_ipAddress.IsBlank())
        ::EnableWindow(m_hButton, FALSE);
    else
        ::EnableWindow(m_hButton, TRUE);

    return 0;
}

LRESULT CWinsServerDialog::OnOk(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    tstring strIp;
    m_ipAddress.GetAddress(&strIp);

    // Validate
    if (!FIsIpInRange(strIp.c_str()))
    {
        // makes ip address lose focus so the control gets
        // IPN_FIELDCHANGED notification
        // also makes it consistent for when short-cut is used
        ::SetFocus(m_hButton);

        return 0;
    }

    int indexDup = Tcp_ListBox_FindStrExact(m_pParentDlg->m_hServers.m_hList, strIp.c_str());
    if (indexDup != LB_ERR && indexDup != m_iIndex)
    {
        NcMsgBox(m_hWnd,
                 IDS_MSFT_TCP_TEXT,
                 IDS_DUP_WINS_SERVER,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK,
                 strIp.c_str());

        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE)
    {
        // Get the current address from the control and
        // add them to the adapter if valid
        m_pParentDlg->m_strNewIpAddress = strIp;

        EndDialog(IDOK);
    }
    else // see if either changed
    {
        if (strIp != m_pParentDlg->m_strNewIpAddress)
            m_pParentDlg->m_strNewIpAddress = strIp; // update save addresses
        else
            EndDialog(IDCANCEL);
    }

    EndDialog(IDOK);

    return 0;
}

LRESULT CWinsServerDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CWinsServerDialog::OnIpFieldChange(int idCtrl, LPNMHDR pnmh,
                                           BOOL& fHandled)
{
    LPNMIPADDRESS lpnmipa = (LPNMIPADDRESS) pnmh;
    int iLow = c_iIpLow;
    int iHigh = c_iIpHigh;

    if (0==lpnmipa->iField)
    {
        iLow  = c_iIPADDR_FIELD_1_LOW;
        iHigh = c_iIPADDR_FIELD_1_HIGH;
    };

    IpCheckRange(lpnmipa, m_hWnd, iLow, iHigh);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Purpose:    Ensure the mouse cursor over the dialog is an Arrow.
//
LRESULT CWinsServerDialog::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\dlgwins.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P W I N S . H
//
//  Contents:   CTcpWinsPage declaration
//
//  Notes:  The "WINS Address" page
//
//  Author: tongl   12 Nov 1997
//
//-----------------------------------------------------------------------
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include "ipctrl.h"
#include "tcpconst.h"

class CTcpWinsPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CTcpWinsPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnQueryCancel)

        // Control message handlers
        COMMAND_ID_HANDLER(IDC_WINS_ADD,            OnAddServer)
        COMMAND_ID_HANDLER(IDC_WINS_EDIT,           OnEditServer)
        COMMAND_ID_HANDLER(IDC_WINS_REMOVE,         OnRemoveServer)
        COMMAND_ID_HANDLER(IDC_WINS_UP,             OnServerUp)
        COMMAND_ID_HANDLER(IDC_WINS_DOWN,           OnServerDown)
        COMMAND_ID_HANDLER(IDC_WINS_SERVER_LIST,    OnServerList)

        COMMAND_ID_HANDLER(IDC_WINS_LOOKUP,     OnLookUp)
        COMMAND_ID_HANDLER(IDC_WINS_LMHOST,     OnLMHost)

        COMMAND_ID_HANDLER(IDC_RAD_ENABLE_NETBT,    OnEnableNetbios)
        COMMAND_ID_HANDLER(IDC_RAD_DISABLE_NETBT,   OnDisableNetbios)
        COMMAND_ID_HANDLER(IDC_RAD_UNSET_NETBT,     OnUnsetNetBios)

    END_MSG_MAP()

// Constructors/Destructors
public:

    CTcpWinsPage(CTcpipcfg * ptcpip,
                 CTcpAddrPage * pTcpAddrPage,
                 ADAPTER_INFO * pAdapterDlg,
                 GLOBAL_INFO * pGlbDlg,
                 const DWORD * phelpIDs = NULL);

public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& fHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam,
                          LPARAM lParam, BOOL& fHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam,
                   LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnQueryCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // control message handlers
    LRESULT OnAddServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnServerList(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnLookUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnLMHost(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnEnableNetbios(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDisableNetbios(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnUnsetNetBios(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

public:

    // This function adds card descriptions to the combo box
    BOOL InitPage();
    void UpdateIpInfo();
    static UINT_PTR CALLBACK HookProcOldStyle(
        HWND hdlg,      // handle to dialog box
        UINT uiMsg,      // message identifier
        WPARAM wParam,  // message parameter
        LPARAM lParam   // message parameter
        )
    {
        return 0;
    }
	

private:

    CTcpipcfg *     m_ptcpip;
    CTcpAddrPage *  m_pParentDlg;
    ADAPTER_INFO *  m_pAdapterInfo;
    GLOBAL_INFO *   m_pglb;

    BOOL            m_fModified;
    BOOL            m_fLmhostsFileReset;
    const DWORD*    m_adwHelpIDs;

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() { m_fModified = TRUE; PropSheet_Changed(GetParent(), m_hWnd);}

    OPENFILENAME        m_ofn;
    WCHAR               m_szFilter[IP_LIMIT];

public:
    // server: either the one added, or edited
    tstring         m_strNewIpAddress;

    // server: used as work space for moving entries in the listboxes
    tstring         m_strMovingEntry;

    tstring         m_strAddServer; // OK or Add button server dialog
    BOOL            m_fEditState;

    HANDLES             m_hServers;

};

class CWinsServerDialog : public CDialogImpl<CWinsServerDialog>
{
public:

    enum { IDD = IDD_WINS_SERVER };

    BEGIN_MSG_MAP(CWinsServerDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);

        COMMAND_ID_HANDLER(IDOK,                    OnOk)
        COMMAND_ID_HANDLER(IDCANCEL,                OnCancel)

        COMMAND_ID_HANDLER(IDC_WINS_CHANGE_SERVER,   OnChange)

        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)
    END_MSG_MAP()

public:
    CWinsServerDialog(CTcpWinsPage * pTcpWinsPage, 
                    const DWORD* pamhidsHelp = NULL,
                    int iIndex = -1);
    ~CWinsServerDialog(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

// Dialog creation overides
public:

    IpControl m_ipAddress;

private:
    HWND m_hButton;     // this is the IDOK button, the text of the button changes
                        // with the context.

    CTcpWinsPage * m_pParentDlg;
    const  DWORD * m_adwHelpIDs;
    int            m_iIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\ipctrl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I P C T R L . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ipctrl.h"
#include "tcpip.h"

///////////////////////////////////////////////////////////////////////
//
// IP Address control helpers

IpControl::IpControl()
{
    m_hIpAddress = 0;
}

IpControl::~IpControl()
{
}

BOOL IpControl::Create(HWND hParent, UINT nId)
{
    Assert(IsWindow(hParent));

    if (hParent)
        m_hIpAddress = GetDlgItem(hParent, nId);

    return m_hIpAddress != NULL;
}

LRESULT IpControl::SendMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    Assert(IsWindow(m_hIpAddress));

    return ::SendMessage(m_hIpAddress, uMsg, wParam, lParam);
}

BOOL IpControl::IsBlank()
{
    return (BOOL)SendMessage(IPM_ISBLANK, 0, 0);
}

void IpControl::SetAddress(DWORD ardwAddress[4])
{
    SendMessage(IPM_SETADDRESS, 0,
                MAKEIPADDRESS(ardwAddress[0], ardwAddress[1],
                              ardwAddress[2], ardwAddress[3]));
}

void IpControl::SetAddress(DWORD a1, DWORD a2, DWORD a3, DWORD a4)
{
    SendMessage(IPM_SETADDRESS, 0, MAKEIPADDRESS(a1,a2,a3,a4));
}

void IpControl::SetAddress(PCWSTR pszString)
{
    Assert(pszString != NULL);
    SendMessage(WM_SETTEXT, 0, (LPARAM)pszString);
}

void IpControl::GetAddress(DWORD *a1, DWORD *a2, DWORD *a3, DWORD *a4)
{
    DWORD dwAddress;

    Assert(a1 && a2 && a3 && a4);

    if (SendMessage(IPM_GETADDRESS,0,(LPARAM)&dwAddress)== 0)
    {
        *a1 = 0;
        *a2 = 0;
        *a3 = 0;
        *a4 = 0;
    }
    else
    {
        *a1 = FIRST_IPADDRESS( dwAddress );
        *a2 = SECOND_IPADDRESS( dwAddress );
        *a3 = THIRD_IPADDRESS( dwAddress );
        *a4 = FOURTH_IPADDRESS( dwAddress );
    }
}

void IpControl::GetAddress(DWORD ardwAddress[4])
{
    DWORD dwAddress;

    if (SendMessage(IPM_GETADDRESS, 0, (LPARAM)&dwAddress ) == 0)
    {
        ardwAddress[0] = 0;
        ardwAddress[1] = 0;
        ardwAddress[2] = 0;
        ardwAddress[3] = 0;
    }
    else
    {
        ardwAddress[0] = FIRST_IPADDRESS( dwAddress );
        ardwAddress[1] = SECOND_IPADDRESS( dwAddress );
        ardwAddress[2] = THIRD_IPADDRESS( dwAddress );
        ardwAddress[3] = FOURTH_IPADDRESS( dwAddress );
    }
}

void IpControl::GetAddress(tstring * pstrAddress)
{
    WCHAR szIpAddress[1000];

    if (SendMessage(WM_GETTEXT, celems(szIpAddress), (LPARAM)&szIpAddress) == 0)
    {
        *pstrAddress = ZERO_ADDRESS;
    }
    else
    {
        *pstrAddress = szIpAddress;
    }
}

void IpControl::SetFocusField(DWORD dwField)
{
    SendMessage(IPM_SETFOCUS, dwField, 0);
}

void IpControl::ClearAddress()
{
    SendMessage(IPM_CLEARADDRESS, 0, 0);
}

void IpControl::SetFieldRange(DWORD dwField, DWORD dwMin, DWORD dwMax)
{
    SendMessage(IPM_SETRANGE, dwField, MAKEIPRANGE(dwMin,dwMax));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\regkysec.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E G K Y S E C . H
//
//  Contents:   CRegKeySecurity class and related data types
//
//  Notes:
//
//  Author:     ckotze   6 July 2000
//
//---------------------------------------------------------------------------

#pragma once
#include <ncstl.h>

typedef BYTE KEY_APPLY_MASK;

const KEY_APPLY_MASK KEY_CURRENT = 1;
const KEY_APPLY_MASK KEY_CHILDREN = 2;
const KEY_APPLY_MASK KEY_ALL = KEY_CURRENT | KEY_CHILDREN;

typedef LPCVOID PCSID;

class CAccessControlEntry
{
public:
    CAccessControlEntry();
    CAccessControlEntry(const ACCESS_ALLOWED_ACE& aaAllowed);
    CAccessControlEntry(const BYTE AceType, const ACCESS_MASK amMask, const BYTE AceFlags, PCSID psidUserOrGroup);
    ~CAccessControlEntry();

    HRESULT AddToACL(PACL* pAcl, ACL_REVISION_INFORMATION AclRevisionInfo);
    BOOL HasExactRights(const ACCESS_MASK amRightsRequired) const;
    BOOL HasExactInheritFlags(BYTE AceFlags);
    DWORD GetLengthSid() const;
    BOOL IsEqualSid(PCSID psidUserOrGroup) const;

private:
    BYTE m_cAceType;
    ACCESS_MASK m_amMask;
    tstring m_strSid;
    DWORD m_dwLengthSid;
    BYTE m_cAceFlags;
};

typedef list<CAccessControlEntry> LISTACE;
typedef LISTACE::iterator ACEITER;

class CRegKeySecurity
{
public:
    CRegKeySecurity();
    ~CRegKeySecurity();

    HRESULT RegOpenKey(const HKEY hkeyRoot, LPCTSTR strKeyName);
    HRESULT RegCloseKey();
    HRESULT GetSecurityDescriptorDacl();
    HRESULT SetSecurityDescriptorDacl(PACL paclDacl, DWORD dwNumEntries);
    HRESULT BuildAndApplyACLFromList(DWORD cbAcl, ACL_REVISION_INFORMATION AclRevisionInfo);
    HRESULT GetAccessControlEntriesFromAcl();
    HRESULT GrantRightsOnRegKey(PCSID psidUserOrGroup, ACCESS_MASK amPermissionsMask, KEY_APPLY_MASK kamMask);
    HRESULT RevokeRightsOnRegKey(PCSID psidUserOrGroup, ACCESS_MASK amPermissionsMask, KEY_APPLY_MASK kamMask);
    HRESULT GetKeySecurity();
    HRESULT SetKeySecurity();

protected:
    PSECURITY_DESCRIPTOR m_psdRegKey;
    BOOL m_bDaclDefaulted;
    HKEY m_hkeyCurrent;
    PACL m_paclDacl;
    BOOL m_bHasDacl;
    PSID m_psidGroup;
    PSID m_psidOwner;
    PACL m_paclSacl;
    BOOL m_bHasSacl;
    LISTACE m_listAllAce;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <commdlg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>
#include <wchar.h>
#include <winsock2.h>
#include <dnsapi.h>

#include "ncmem.h"

#include <algorithm>
#include <list>
#include <vector>
using namespace std;

#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\regkysec.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       RegKeySecurity.cpp
//
//  Contents:   Provides code for changes to Regkey Security
//
//
//  Notes:
//
//  Author:     ckotze   4 July 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include <ncreg.h>
#include <regkysec.h>
#include <ncdebug.h>
#include <sddl.h>

HRESULT SidToString(PCSID pSid, tstring &strSid)
{
    HRESULT hr = S_OK;

    LPTSTR pSidString = NULL;
    BOOL bSuccess = ConvertSidToStringSid(const_cast<PSID>(pSid), &pSidString);
    if (bSuccess)
    {
        hr = S_OK;
        strSid = pSidString;
        LocalFree(pSidString);
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    return hr;
}

HRESULT StringToSid(const tstring strSid, PSID &pSid)
{
    HRESULT hr = S_OK;

    BOOL bSuccess = ConvertStringSidToSid(strSid.c_str(), &pSid);
    if (bSuccess)
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    return hr;
}
//+---------------------------------------------------------------------------
//
//  Function:   CRegKeySecurity constructor
//
//  Purpose:
//
//  Arguments:
//
//  Returns:
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
CRegKeySecurity::CRegKeySecurity() : m_psdRegKey(NULL), m_bDaclDefaulted(FALSE), m_hkeyCurrent(0),
m_paclDacl(NULL), m_bHasDacl(FALSE), m_psidGroup(NULL), m_psidOwner(NULL), m_paclSacl(NULL), m_bHasSacl(FALSE)
{

}

//+---------------------------------------------------------------------------
//
//  Function:   CRegKeySecurity destructor
//
//  Purpose:
//
//  Arguments:
//
//  Returns:
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
CRegKeySecurity::~CRegKeySecurity()
{
    if (m_psdRegKey)
    {
        delete[] m_psdRegKey;
    }

    RegCloseKey();

    m_listAllAce.clear();
}

//+---------------------------------------------------------------------------
//
//  Function:   RegOpenKey
//
//  Purpose:    Opens the Registry Key with enough privileges to set the
//              permission on the Key.
//
//  Arguments:
//          hkeyRoot    - the root key from which to open the subkey
//
//          strKeyName  - the subkey to open.
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::RegOpenKey(const HKEY hkeyRoot, LPCTSTR strKeyName)
{
    LONG lResult = 0;
    DWORD dwRightsRequired = KEY_ALL_ACCESS;

    if (m_hkeyCurrent)
    {
        RegCloseKey();
    }

    if ((lResult = HrRegOpenKeyEx(hkeyRoot, strKeyName, dwRightsRequired, &m_hkeyCurrent)) != ERROR_SUCCESS)
    {
        return HRESULT_FROM_WIN32(lResult);
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetKeySecurity
//
//  Purpose:    Retrieves the Security Descriptor for the currently open
//              Registry key.
//
//  Arguments:  None
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::GetKeySecurity()
{
    HRESULT hr = S_OK;
    DWORD cbSD = 1;  // try a size that won't be large enough
    LONG lResult;

    if (!m_hkeyCurrent)
    {
        TraceError("CRegKeySecurity::GetKeySecurity", E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    // First call should get the correct size.

    if ((hr = HrRegGetKeySecurity(m_hkeyCurrent, OWNER_SECURITY_INFORMATION |
        GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
        &m_psdRegKey, &cbSD)) != S_OK)
    {
        if (m_psdRegKey)
        {
            delete[] m_psdRegKey;
        }

        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {

            m_psdRegKey = reinterpret_cast<PSECURITY_DESCRIPTOR>(new BYTE[cbSD]);

            hr = HrRegGetKeySecurity(m_hkeyCurrent, OWNER_SECURITY_INFORMATION |
                GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                m_psdRegKey, &cbSD);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetKeySecurity
//
//  Purpose:    Updates the Security Descriptor of the currently open key.
//
//
//  Arguments:  None
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::SetKeySecurity()
{
    HRESULT hr = S_OK;

    if ((hr = HrRegSetKeySecurity(m_hkeyCurrent, OWNER_SECURITY_INFORMATION
        | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, m_psdRegKey)) != S_OK)
    {
        TraceError("CRegKeySecurity::SetKeySecurity", hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegCloseKey
//
//  Purpose:    Closes the currently open registry key.
//
//
//  Arguments:  None
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::RegCloseKey()
{
    HRESULT hr = S_OK;

    if (m_hkeyCurrent)
    {
        LONG err;

        err = ::RegCloseKey(m_hkeyCurrent);

        hr = HRESULT_FROM_WIN32(err);

        m_hkeyCurrent = 0;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityDescriptorDacl
//
//  Purpose:    Retrieve the Discretionary Access Control List from the SD
//
//
//  Arguments:
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::GetSecurityDescriptorDacl()
{
    HRESULT hr = S_OK;

    if (!m_psdRegKey)
    {
        return E_UNEXPECTED;
    }

    if (!::GetSecurityDescriptorDacl(m_psdRegKey,
        (LPBOOL)&m_bHasDacl,
        (PACL *)&m_paclDacl,
        (LPBOOL)&m_bDaclDefaulted))
    {
        DWORD dwErr;

        dwErr = GetLastError();

        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityDescriptorDacl
//
//  Purpose:    Update the Discretionary Access Control List in the SD
//
//
//  Arguments:
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::SetSecurityDescriptorDacl(PACL paclDacl, DWORD dwNumEntries)
{
    HRESULT hr = E_FAIL;
    DWORD dwErr = 0;
    SECURITY_DESCRIPTOR psdSD = {0};

    SECURITY_DESCRIPTOR_CONTROL pSDCControl;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    PSID psidOwner = NULL;
    PSID psidGroup = NULL;
    DWORD dwSDSize = sizeof(psdSD);
    DWORD dwOwnerSIDSize = 0;
    DWORD dwGroupSIDSize = 0;
    DWORD cbDacl = 0;
    DWORD cbSacl = 0;
    DWORD dwRevision = 0;

    if (!paclDacl)
    {
        return E_INVALIDARG;
    }

    if (GetSecurityDescriptorControl(m_psdRegKey, &pSDCControl, &dwRevision))
    {
        if (SE_SELF_RELATIVE & pSDCControl)
        {
            if (!MakeAbsoluteSD(m_psdRegKey, &psdSD, &dwSDSize, pDacl, &cbDacl, pSacl, &cbSacl, psidOwner, &dwOwnerSIDSize, psidGroup, &dwGroupSIDSize))
            {
                pDacl = reinterpret_cast<PACL>(new BYTE[cbDacl]);

                if (!pDacl)
                {
                    return E_OUTOFMEMORY;
                }

                psidOwner = new BYTE[dwOwnerSIDSize];

                if (!psidOwner)
                {
                    delete[] pDacl;

                    return E_OUTOFMEMORY;
                }

                psidGroup = new BYTE[dwGroupSIDSize];

                if (!psidGroup)
                {
                    delete[] pDacl;
                    delete[] psidOwner;

                    return E_OUTOFMEMORY;
                }
                else if (MakeAbsoluteSD(m_psdRegKey, &psdSD, &dwSDSize, pDacl, &cbDacl, pSacl, &cbSacl, psidOwner, &dwOwnerSIDSize, psidGroup, &dwGroupSIDSize))
                {
                    if (!::SetSecurityDescriptorDacl(&psdSD, m_bHasDacl, paclDacl, m_bDaclDefaulted))
                    {
                        dwErr = GetLastError();
                    }
                    if (!MakeSelfRelativeSD(&psdSD, m_psdRegKey, &dwSDSize) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        if (m_psdRegKey)
                        {
                            delete[] m_psdRegKey;
                        }

                        m_psdRegKey = reinterpret_cast<PSECURITY_DESCRIPTOR>(new BYTE[dwSDSize]);

                        if (MakeSelfRelativeSD(&psdSD, m_psdRegKey, &dwSDSize))
                        {
                            hr = S_OK;
                            SetLastError(0);
                            m_paclDacl = NULL;
                        }
                    }
                }

                delete[] pDacl;
                delete[] psidOwner;
                delete[] psidGroup;

            }
        }
    }
    else
    {
        DWORD dwErr;

        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GrantRightsOnRegKey
//
//  Purpose:    Add the specified account to the ACL with the permissions
//              required and the inheritance information.
//
//  Arguments:
//          psidUserOrGroup     - The sid (Security Identifier) of the user to
//                                be added.
//          amPermissionMask    - The permissions to be granted.
//
//          kamMask             - Applies to this key or child keys or both?
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::GrantRightsOnRegKey(PCSID psidUserOrGroup, ACCESS_MASK amPermissionsMask, KEY_APPLY_MASK kamMask)
{
    HRESULT hr = E_FAIL;
    PACCESS_ALLOWED_ACE                 paaAllowedAce = NULL;
    PACCESS_DENIED_ACE                  paaDeniedAce = NULL;
    BOOL                                bAceMatch = FALSE;
    BYTE                                cAceFlags = 0;
    DWORD                               cbAcl = 0;
    DWORD                               cbAce = 0;

    if (!IsValidSid(const_cast<PSID>(psidUserOrGroup)))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }

    hr = GetAccessControlEntriesFromAcl();

    if (FAILED(hr))
    {
        return hr;
    }

    cbAcl = sizeof(ACL);

    for (ACEITER i = m_listAllAce.begin(); i != m_listAllAce.end() ; i++)
    {
        CAccessControlEntry paEntry(*i);

        cbAcl += sizeof(ACCESS_ALLOWED_ACE) + 8 +
            paEntry.GetLengthSid()- sizeof(DWORD);

        // Assert(kamMask)

        switch (kamMask)
        {
        case KEY_CURRENT:
            {
                cAceFlags = 0;  // Do not allow this to be inherited by children.
                break;
            }
        case KEY_CHILDREN:
            {
                cAceFlags = CONTAINER_INHERIT_ACE;
                cAceFlags |= INHERIT_ONLY_ACE;
                break;
            }
        case KEY_ALL:
            {
                cAceFlags = CONTAINER_INHERIT_ACE;
                break;
            }
        default:
            return E_INVALIDARG;
        }

        if (paEntry.HasExactRights(amPermissionsMask) && paEntry.HasExactInheritFlags(cAceFlags) && paEntry.IsEqualSid(psidUserOrGroup))
        {
            bAceMatch = TRUE;
            break;
        }
    }

    if (!bAceMatch)
    {
        ACCESS_ALLOWED_ACE paEntry = {NULL};
        ACL_REVISION_INFORMATION AclRevisionInfo;
        PACL pNewDACL = NULL;
        CAccessControlEntry AccessControlEntry(ACCESS_ALLOWED_ACE_TYPE, amPermissionsMask, cAceFlags, psidUserOrGroup);

        // subtract ACE.SidStart from the size
        cbAce = sizeof (paEntry) - sizeof (DWORD);
        // add this ACE's SID length
        cbAce += 8 + GetLengthSid(const_cast<PSID>(psidUserOrGroup));
        // add the length of each ACE to the total ACL length
        cbAcl += cbAce;

        m_listAllAce.insert(m_listAllAce.begin(), AccessControlEntry);

        AclRevisionInfo.AclRevision = ACL_REVISION;

        hr = BuildAndApplyACLFromList(cbAcl, AclRevisionInfo);

        if (SUCCEEDED(hr))
        {
            hr = SetKeySecurity();
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RevokeRightsOnRegKey
//
//  Purpose:    Remove the specified account to the ACL with the permissions
//              required and the inheritance information.
//
//  Arguments:
//          psidUserOrGroup     - The sid (Security Identifier) of the user to
//                                be added.
//          amPermissionMask    - The permissions to be granted.
//
//          kamMask             - Applies to this key or child keys or both?
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:  This is designed to only remove the exact combination of user
//          rights and sid and key apply mask.  This is to stop us from
//          accidentally deleting a key that was put there for the user/group
//          by an administrator.
//
HRESULT CRegKeySecurity::RevokeRightsOnRegKey(PCSID psidUserOrGroup, ACCESS_MASK amPermissionsMask, KEY_APPLY_MASK kamMask)
{
    HRESULT hr = S_OK;
    PACCESS_ALLOWED_ACE                 paaAllowedAce = NULL;
    PACCESS_DENIED_ACE                  paaDeniedAce = NULL;
    BOOL                                bAceMatch = FALSE;
    BYTE                                cAceFlags = 0;
    DWORD                               cbAcl = 0;
    DWORD                               cbAce = 0;

    if (!IsValidSid(const_cast<PSID>(psidUserOrGroup)))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SID);
    }

    hr = GetAccessControlEntriesFromAcl();

    if (FAILED(hr))
    {
        return hr;
    }

    cbAcl = sizeof(ACL);

    for (ACEITER i = m_listAllAce.begin(); i != m_listAllAce.end() ; i++)
    {
        CAccessControlEntry paEntry(*i);

        // Assert(kamMask)

        switch (kamMask)
        {
        case KEY_CURRENT:
            {
                cAceFlags = 0; // Do not allow this to be inherited by children.
                break;
            }
        case KEY_CHILDREN:
            {
                cAceFlags = CONTAINER_INHERIT_ACE;
                cAceFlags |= INHERIT_ONLY_ACE;
                break;
            }
        case KEY_ALL:
            {
                cAceFlags = CONTAINER_INHERIT_ACE;
                break;
            }
        default:
            return E_INVALIDARG;
        }

        if (paEntry.HasExactRights(amPermissionsMask) && paEntry.HasExactInheritFlags(cAceFlags) && paEntry.IsEqualSid(psidUserOrGroup))
        {
            ACEITER j = i;
            i = m_listAllAce.erase(j);
            bAceMatch = TRUE;
        }
        else
        {
            cbAcl += sizeof(ACCESS_ALLOWED_ACE) + 8 +
                paEntry.GetLengthSid()- sizeof(DWORD);

        }
    }

    if (bAceMatch)
    {
        ACCESS_ALLOWED_ACE paEntry = {NULL};
        ACL_REVISION_INFORMATION AclRevisionInfo;
        PACL pNewDACL = NULL;

        // subtract ACE.SidStart from the size
        cbAce = sizeof (paEntry) - sizeof (DWORD);
        // add this ACE's SID length
        cbAce += 8 + GetLengthSid(const_cast<PSID>(psidUserOrGroup));
        // add the length of each ACE to the total ACL length
        cbAcl += cbAce;

        AclRevisionInfo.AclRevision = ACL_REVISION;

        hr = BuildAndApplyACLFromList(cbAcl, AclRevisionInfo);

        if (SUCCEEDED(hr))
        {
            hr = SetKeySecurity();
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetAccessControlEntriesFromAcl
//
//  Purpose:    Retrieves all the ACE's from the ACL and stores them in an
//              STL list for easier manipulation.
//
//  Arguments:
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CRegKeySecurity::GetAccessControlEntriesFromAcl()
{
    ACL_SIZE_INFORMATION                asiAclSize;
    ACL_REVISION_INFORMATION            ariAclRevision;
    DWORD                               dwBufLength;
    DWORD                               dwAcl;
    DWORD                               dwTotalEntries = 0;
    HRESULT                             hr = S_OK;
    PACCESS_ALLOWED_ACE                 paaAllowedAce = NULL;
    PACCESS_DENIED_ACE                  paaDeniedAce = NULL;
    ACCESS_MASK                         amAccessAllowedMask = 0;
    ACCESS_MASK                         amAccessDeniedMask = 0;

    if (!m_paclDacl)
    {
        hr = GetSecurityDescriptorDacl();
        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (!IsValidAcl(m_paclDacl))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_ACL);
    }

    dwBufLength = sizeof(asiAclSize);

    if (!GetAclInformation(m_paclDacl,
        &asiAclSize,
        dwBufLength,
        AclSizeInformation))
    {
        return(FALSE);
    }

    dwBufLength = sizeof(ariAclRevision);

    if (!GetAclInformation(m_paclDacl,
        &ariAclRevision,
        dwBufLength,
        AclRevisionInformation))
    {
        return(FALSE);
    }

    switch (ariAclRevision.AclRevision)
    {
    case      ACL_REVISION1 :
        {
            break;
        }
    case      ACL_REVISION2 :
        {
            break;
        }
    default :
        {
            return(FALSE);
        }
    }

    if (asiAclSize.AceCount <= 0)
    {
        return E_INVALIDARG;
    }

    m_listAllAce.clear();

    for (dwAcl = 0;dwAcl < asiAclSize.AceCount; dwAcl++)
    {
        if (!GetAce(m_paclDacl,
            dwAcl,
            reinterpret_cast<LPVOID *>(&paaAllowedAce)))
        {
            return HRESULT_FROM_WIN32(ERROR_INVALID_ACL);
        }

        if (paaAllowedAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            CAccessControlEntry pEntry(*paaAllowedAce);

            m_listAllAce.insert(m_listAllAce.end(), pEntry);
        }
        else
        {
            CAccessControlEntry pEntry(*paaAllowedAce);

            m_listAllAce.insert(m_listAllAce.begin(), pEntry);
        }
    }

    return S_OK;

}


HRESULT CRegKeySecurity::BuildAndApplyACLFromList(DWORD cbAcl, ACL_REVISION_INFORMATION AclRevisionInfo)
{
    HRESULT hr = S_OK;
    DWORD cbAce = 0;
    PACL pNewDACL = NULL;

    pNewDACL = reinterpret_cast<PACL>(new BYTE[cbAcl]);

    if (!pNewDACL)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pNewDACL, cbAcl);

    if (InitializeAcl(pNewDACL, cbAcl, AclRevisionInfo.AclRevision))
    {
        for (ACEITER i = m_listAllAce.begin(); i != m_listAllAce.end(); i++)
        {
            CAccessControlEntry Ace = *i;

            if (IsValidAcl(pNewDACL))
            {
                hr = Ace.AddToACL(&pNewDACL, AclRevisionInfo);

                if (FAILED(hr))
                {
                    break;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACL);
                break;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = SetSecurityDescriptorDacl(pNewDACL, m_listAllAce.size());
        }
        delete[] pNewDACL;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlEntry constructor
//
//  Purpose:
//
//
//  Arguments:
//
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
CAccessControlEntry::CAccessControlEntry()
{

}

//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlEntry copy constructor
//
//  Purpose:    To contruct a new CAccessControEntry based on the supplied
//              Access Control Entry for storage in an STL list.
//
//  Arguments:
//          aaAllowed   - An ACCESS_ALLOWED_ACE or ACCESS_DENIED_ACE
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:      Since STL doesn't know how to work with Sids we get the string
//              representation of the sid and then store that inside the list.
//
CAccessControlEntry::CAccessControlEntry(const ACCESS_ALLOWED_ACE& aaAllowed)
{
    m_cAceType = aaAllowed.Header.AceType;
    m_amMask = aaAllowed.Mask;
    m_cAceFlags = aaAllowed.Header.AceFlags;

    SidToString(&aaAllowed.SidStart, m_strSid);
    m_dwLengthSid = ::GetLengthSid(reinterpret_cast<PSID>(const_cast<LPDWORD>(&aaAllowed.SidStart)));
}

//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlEntry copy constructor
//
//  Purpose:    To contruct a new CAccessControEntry based on the supplied
//              Access Control Entry fields for storage in an STL list.
//
//
//  Arguments:
//          AceType         - The type of ACE (allowed or denied or audit etc)
//
//          amMask          - Permissions Mask
//
//          AceFlags        - AceFlags
//
//          psidUserOrGroup - The User or Group we're interested in
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:      Since STL doesn't know how to work with Sids we get the string
//              representation of the sid and then store that inside the list.
//
CAccessControlEntry::CAccessControlEntry(const BYTE AceType, const ACCESS_MASK amMask, const BYTE AceFlags, PCSID psidUserOrGroup)
{
    m_cAceType = AceType;
    m_amMask = amMask;
    m_cAceFlags = AceFlags;

    SidToString(psidUserOrGroup, m_strSid);
    m_dwLengthSid = ::GetLengthSid(const_cast<PSID>(psidUserOrGroup));
}

//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlEntry destructor
//
//  Purpose:
//
//
//  Arguments:
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
CAccessControlEntry::~CAccessControlEntry()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   AddToACL
//
//  Purpose:    Adds this current AccessControlEntry to the specified ACL
//
//
//  Arguments:
//          pAcl            - Access Control List to Add to
//
//          AclRevisionInfo - Version of ACL
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
HRESULT CAccessControlEntry::AddToACL(PACL* pAcl, ACL_REVISION_INFORMATION AclRevisionInfo)
{
    HRESULT hr;
    PSID pSid = NULL;

    hr = StringToSid(m_strSid, pSid);

    if (FAILED(hr))
    {
        return hr;
    }

    if (m_cAceType == ACCESS_ALLOWED_ACE_TYPE)
    {
        if (!::AddAccessAllowedAceEx(*pAcl, AclRevisionInfo.AclRevision, m_cAceFlags, m_amMask, pSid))
        {
            DWORD dwErr;

            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }
    else
    {
        if (!::AddAccessDeniedAceEx(*pAcl, AclRevisionInfo.AclRevision, m_cAceFlags, m_amMask, pSid))
        {
            DWORD dwErr;

            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }

    if (pSid)
    {
        FreeSid(pSid);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   HasExactRights
//
//  Purpose:    Checks to see if this ACE has the exact same rights that we
//              are looking for
//
//
//  Arguments:
//          amRightsRequired    - The AccessMask in question
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
BOOL CAccessControlEntry::HasExactRights(ACCESS_MASK amRightsRequired) const
{
    return (amRightsRequired == m_amMask);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetLengthSid
//
//  Purpose:    returns the length of the sid in this AccessControlEntry
//
//  Arguments:
//
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
DWORD CAccessControlEntry::GetLengthSid() const
{
    return m_dwLengthSid;
}

//+---------------------------------------------------------------------------
//
//  Function:   HasExactRights
//
//  Purpose:    Checks to see if this ACE has the exact same inherit flags
//              that we are looking for
//
//
//  Arguments:
//          amRightsRequired    - The AccessMask in question
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
BOOL CAccessControlEntry::HasExactInheritFlags(BYTE AceFlags)
{
    return (m_cAceFlags == AceFlags);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEqualSid
//
//  Purpose:    Is this the same Sid as the one we're looking for?
//
//
//  Arguments:
//          psidUserOrGroup - Sid in question
//
//
//
//  Returns:    An S_OK if the key was successfully opened, and error code
//              otherwise
//
//  Author:     ckotze   4 July 2000
//
//  Notes:
//
BOOL CAccessControlEntry::IsEqualSid(PCSID psidUserOrGroup) const
{
    HRESULT hr;
    BOOL bEqualSid = FALSE;
    PSID pSid = NULL;

    hr = StringToSid(m_strSid, pSid);

    if (SUCCEEDED(hr))
    {
        bEqualSid = ::EqualSid(pSid, const_cast<PSID>(psidUserOrGroup));
    }

    if (pSid)
    {
        FreeSid(pSid);
    }

    return bEqualSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\ipsysprp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I P S Y S P R P . C P P
//
//  Contents:   Handle the TCP/IP parameters in the sysprep 
//
//  Notes:
//
//  Author:     nsun
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "ncsetup.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "ncreg.h"
#include "afilestr.h"

typedef struct {
    LPCWSTR pszRegValName;
    LPCWSTR pszFileValName;
    DWORD dwType;
} SysprepValueNameTypeMapping;

SysprepValueNameTypeMapping c_TcpipValueTypeMapping [] =
{
    {c_szDefaultGateway, c_szAfDefaultGateway, REG_MULTI_SZ},
    {RGAS_DEFAULTGATEWAYMETRIC, RGAS_DEFAULTGATEWAYMETRIC, REG_MULTI_SZ},
    {c_szDomain, c_szAfDnsDomain, REG_SZ},
    {RGAS_ENABLE_DHCP, c_szAfDhcp, REG_BOOL},
    {c_szInterfaceMetric, c_szInterfaceMetric, REG_DWORD},
    {RGAS_IPADDRESS, c_szAfIpaddress, REG_MULTI_SZ},
    {RGAS_NAMESERVER, c_szAfDnsServerSearchOrder, REG_SZ},
    {RGAS_FILTERING_IP, c_szAfIpAllowedProtocols, REG_MULTI_SZ},
    {RGAS_SUBNETMASK, c_szAfSubnetmask, REG_MULTI_SZ},
    {RGAS_FILTERING_TCP, c_szAfTcpAllowedPorts, REG_MULTI_SZ},
    {RGAS_FILTERING_UDP, c_szAfUdpAllowedPorts, REG_MULTI_SZ}
};

SysprepValueNameTypeMapping c_NetBTValueTypeMapping [] =
{
    {RGAS_NETBT_NAMESERVERLIST, c_szAfWinsServerList, REG_MULTI_SZ},
    {RGAS_NETBT_NETBIOSOPTIONS, c_szAfNetBIOSOptions, REG_DWORD}
};

HRESULT HrSysPrepSaveInterfaceParams(
                    INetCfgSysPrep* pncsp,
                    LPCWSTR pszSection,
                    HKEY hkey,
                    const SysprepValueNameTypeMapping * prgVtpParams,
                    UINT  cParams
                    );

HRESULT HrSysPrepLoadInterfaceParams(
                    HINF hinf,
                    PCWSTR pszSection,
                    HKEY    hkeyParam,
                    const SysprepValueNameTypeMapping * prgVtpParams,
                    UINT    cParams
                    );

HRESULT CTcpipcfg::HrOpenTcpipInterfaceKey(
                                const GUID & guidInterface,
                                HKEY * phKey,
                                REGSAM sam
                    )
{
    if (NULL == phKey)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    *phKey = NULL;

    if (NULL == m_pnccTcpip)
        return E_FAIL;

    HKEY hkeyTcpipParam = NULL;
    HKEY hkeyInterface = NULL;
    tstring strInterfaceRegPath;

    WCHAR szGuid [c_cchGuidWithTerm];
    StringFromGUID2(
                guidInterface,
                szGuid,
                c_cchGuidWithTerm
                );

    CORg(m_pnccTcpip->OpenParamKey(&hkeyTcpipParam));

    Assert(hkeyTcpipParam);
    strInterfaceRegPath = c_szInterfacesRegKey;
    strInterfaceRegPath += L"\\";

        
    strInterfaceRegPath += szGuid;
        
    CORg(HrRegOpenKeyEx(
                    hkeyTcpipParam,
                    strInterfaceRegPath.c_str(),
                    sam,
                    &hkeyInterface
                    ));

Error:
    if (SUCCEEDED(hr))
    {
        *phKey = hkeyInterface;
    }

    RegSafeCloseKey(hkeyTcpipParam);

    return hr;
}

HRESULT CTcpipcfg::HrOpenNetBtInterfaceKey(
                                const GUID & guidInterface,
                                HKEY * phKey,
                                REGSAM sam
                    )
{
    if (NULL == phKey)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    *phKey = NULL;

    if (NULL == m_pnccWins)
        return E_FAIL;

    HKEY hkeyNetBtParam = NULL;
    HKEY hkeyInterface = NULL;
    tstring strInterfaceRegPath;

    WCHAR szGuid [c_cchGuidWithTerm];
    StringFromGUID2(
                guidInterface,
                szGuid,
                c_cchGuidWithTerm
                );

    CORg(m_pnccWins->OpenParamKey(&hkeyNetBtParam));

    Assert(hkeyNetBtParam);
    strInterfaceRegPath = c_szInterfacesRegKey;
    strInterfaceRegPath += L"\\";
    strInterfaceRegPath += c_szTcpip_;
    strInterfaceRegPath += szGuid;
        
    CORg(HrRegOpenKeyEx(
                    hkeyNetBtParam,
                    strInterfaceRegPath.c_str(),
                    sam,
                    &hkeyInterface
                    ));

Error:
    if (SUCCEEDED(hr))
    {
        *phKey = hkeyInterface;
    }

    RegSafeCloseKey(hkeyNetBtParam);

    return hr;
}


STDMETHODIMP CTcpipcfg::SaveAdapterParameters(
                            INetCfgSysPrep* pncsp,
                            LPCWSTR pszwAnswerSections,
                            GUID* pAdapterInstanceGuid
                            )
{
    if (NULL == pncsp || NULL == pAdapterInstanceGuid)
        return E_INVALIDARG;

    Assert(m_pnccTcpip);
    Assert(m_pnccWins);

    if (NULL == m_pnccTcpip || NULL == m_pnccWins)
        return E_FAIL;

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    HKEY hkeyTcpipParam = NULL;
    HKEY hkeyNetBtParam = NULL;

    //Write the TCP/IP settings
    hr = HrOpenTcpipInterfaceKey(*pAdapterInstanceGuid, &hkeyTcpipParam, KEY_READ);
    if (SUCCEEDED(hr))
    {
        Assert(hkeyTcpipParam);
        hr = HrSysPrepSaveInterfaceParams(
                            pncsp, 
                            pszwAnswerSections,
                            hkeyTcpipParam,
                            c_TcpipValueTypeMapping,
                            celems(c_TcpipValueTypeMapping)
                            );

        RegSafeCloseKey(hkeyTcpipParam);
    }

    //Write the DNS update settings
    WCHAR szGuid [c_cchGuidWithTerm] = {0};
    BOOL fTemp = FALSE;
    
    StringFromGUID2(
                *pAdapterInstanceGuid,
                szGuid,
                c_cchGuidWithTerm
                );

    fTemp = !DnsIsDynamicRegistrationEnabled(szGuid);
    hrTmp = pncsp->HrSetupSetFirstStringAsBool(
                                        pszwAnswerSections,
                                        c_szAfDisableDynamicUpdate,
                                        fTemp
                                        );
    if (SUCCEEDED(hr))
        hr = hrTmp;

    fTemp = DnsIsAdapterDomainNameRegistrationEnabled(szGuid);
    hrTmp = pncsp->HrSetupSetFirstStringAsBool(
                                        pszwAnswerSections,
                                        c_szAfEnableAdapterDomainNameRegistration,
                                        fTemp
                                        );
    if (SUCCEEDED(hr))
        hr = hrTmp;


    //Write the NetBT settings
    hrTmp = HrOpenNetBtInterfaceKey(*pAdapterInstanceGuid, &hkeyNetBtParam, KEY_READ);
    if (SUCCEEDED(hrTmp))
    {
        hrTmp = HrSysPrepSaveInterfaceParams(
                        pncsp, 
                        pszwAnswerSections,
                        hkeyNetBtParam,
                        c_NetBTValueTypeMapping,
                        celems(c_NetBTValueTypeMapping)
                        );

        RegSafeCloseKey(hkeyNetBtParam);
    }

    if (SUCCEEDED(hr))
        hr = hrTmp;

    return hr;
}


STDMETHODIMP CTcpipcfg::RestoreAdapterParameters(
                            LPCWSTR pszwAnswerFile, 
                            LPCWSTR pszwAnswerSection,
                            GUID*   pAdapterInstanceGuid
                            )
{
    AssertSz(pszwAnswerFile, "Answer file string is NULL!");
    AssertSz(pszwAnswerSection, "Answer file sections string is NULL!");

    if (NULL == pszwAnswerFile || 
        NULL == pszwAnswerSection ||
        NULL == pAdapterInstanceGuid)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CSetupInfFile   caf;    // Class to process answer file

    // Open the answer file.
    hr = caf.HrOpen(pszwAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
        return hr;

    HKEY hkeyTcpipParam = NULL;
    HKEY hkeyNetBtParam = NULL;
    
    hr = HrOpenTcpipInterfaceKey(*pAdapterInstanceGuid, &hkeyTcpipParam, KEY_READ_WRITE);
    if (SUCCEEDED(hr))
    {
        Assert(hkeyTcpipParam);
        hr = HrSysPrepLoadInterfaceParams(
                        caf.Hinf(),
                        pszwAnswerSection,
                        hkeyTcpipParam,
                        c_TcpipValueTypeMapping,
                        celems(c_TcpipValueTypeMapping)
                        );
    }

    HRESULT hrTmp = S_OK;
    
    hrTmp = HrOpenNetBtInterfaceKey(*pAdapterInstanceGuid, &hkeyNetBtParam, KEY_READ_WRITE);
    if (SUCCEEDED(hrTmp))
    {
        Assert(hkeyNetBtParam);
        hrTmp = HrSysPrepLoadInterfaceParams(
                        caf.Hinf(),
                        pszwAnswerSection,
                        hkeyNetBtParam,
                        c_NetBTValueTypeMapping,
                        celems(c_NetBTValueTypeMapping)
                        );
    }

    if (SUCCEEDED(hr))
        hr = hrTmp;
        
    caf.Close();
    
    return hr;
}


HRESULT HrSysPrepSaveInterfaceParams(
                    INetCfgSysPrep* pncsp,
                    LPCWSTR pszSection,
                    HKEY hkey,
                    const SysprepValueNameTypeMapping * prgVtpParams,
                    UINT  cParams
                    )
{
    Assert(pncsp);
    Assert(pszSection);
    Assert(hkey);

    if (NULL == pncsp || NULL == pszSection || NULL == hkey || NULL == prgVtpParams)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    BOOL fTmp;
    DWORD dwTmp;
    tstring strTmp;
    WCHAR * mszTmp;
    UINT i = 0;
    for (i = 0; i < cParams; i++)
    {
        hrTmp = S_OK;
        switch(prgVtpParams[i].dwType)
        {
        case REG_BOOL:
            if (SUCCEEDED(HrRegQueryDword(
                                hkey,
                                prgVtpParams[i].pszRegValName,
                                &dwTmp
                                )))
            {
                fTmp = !!dwTmp;
                hrTmp = pncsp->HrSetupSetFirstStringAsBool(
                                        pszSection,
                                        prgVtpParams[i].pszFileValName,
                                        fTmp
                                        );
            }
            break;

        case REG_DWORD:
            if (SUCCEEDED(HrRegQueryDword(
                                hkey,
                                prgVtpParams[i].pszRegValName,
                                &dwTmp
                                )))
            {
                hrTmp = pncsp->HrSetupSetFirstDword(
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    dwTmp
                                    );
            }

            break;

        case REG_SZ:
            if (SUCCEEDED(HrRegQueryString(
                                hkey,
                                prgVtpParams[i].pszRegValName,
                                &strTmp
                                )))
            {
                hrTmp = pncsp->HrSetupSetFirstString(
                                        pszSection,
                                        prgVtpParams[i].pszFileValName,
                                        strTmp.c_str()
                                        );
            }
            break;

        case REG_MULTI_SZ:
            if (SUCCEEDED(HrRegQueryMultiSzWithAlloc(
                                hkey,
                                prgVtpParams[i].pszRegValName,
                                &mszTmp
                                )))
            {
                hrTmp = pncsp->HrSetupSetFirstMultiSzField(
                                       pszSection,
                                       prgVtpParams[i].pszFileValName,
                                       mszTmp
                                       );
                delete [] mszTmp;
            }
            break;
        }

        //we dont pass the error of hrTmp out of this function because
        //there is not much we can do with this error
#ifdef ENABLETRACE
        if (FAILED(hrTmp))
        {
            TraceTag(ttidError, "Tcpip: HrSysPrepSaveInterfaceParams: failed to set %S to the registry. hr = %x.",
                prgVtpParams[i].pszFileValName, hrTmp);
        }
#endif

    }

    return hr;
}


HRESULT HrSysPrepLoadInterfaceParams(
                    HINF    hinf,
                    PCWSTR  pszSection,
                    HKEY    hkeyParam,
                    const SysprepValueNameTypeMapping * prgVtpParams,
                    UINT    cParams
                    )
{
    Assert(prgVtpParams);

    if (NULL == hinf || NULL == pszSection || NULL == hkeyParam || NULL == prgVtpParams)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HRESULT hrReg = S_OK;
    BOOL fTmp;
    DWORD dwTmp;
    tstring strTmp;
    WCHAR * mszTmp;

    for(UINT i = 0; i < cParams; i++)
    {
        hrReg = S_OK;
        hrTmp = S_OK;

        switch(prgVtpParams[i].dwType)
        {
        case REG_BOOL:
            hrTmp = HrSetupGetFirstStringAsBool(
                                    hinf, 
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    &fTmp
                                    );
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetDword(hkeyParam,
                                      prgVtpParams[i].pszRegValName,
                                      fTmp);
            break;

        case REG_DWORD:
            hrTmp = HrSetupGetFirstDword(
                                    hinf, 
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    &dwTmp
                                    );
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetDword(hkeyParam,
                                      prgVtpParams[i].pszRegValName,
                                      dwTmp);

            break;

        case REG_SZ:
            hrTmp = HrSetupGetFirstString(
                                    hinf, 
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    &strTmp
                                    );
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetString(hkeyParam,
                                       prgVtpParams[i].pszRegValName,
                                       strTmp);
            break;

        case REG_MULTI_SZ:
            hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc( 
                                    hinf,
                                    pszSection,
                                    prgVtpParams[i].pszFileValName,
                                    &mszTmp
                                    );

            if (SUCCEEDED(hrTmp))
            {
                hrReg = HrRegSetMultiSz(hkeyParam,
                                        prgVtpParams[i].pszRegValName,
                                        mszTmp);
                delete [] mszTmp;
            }
            break;
        }

        if(FAILED(hrTmp))
        {
            if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                hrTmp = S_OK;
            else
            {
                TraceTag(ttidError,
                    "Tcpip: HrSysPrepLoadInterfaceParams: failed to load %S from the answer file. hr = %x.",
                    prgVtpParams[i].pszFileValName, 
                    hrTmp
                    );
            }
        }

#ifdef ENABLETRACE
        if(FAILED(hrReg))
        {
            TraceTag(ttidError,
                "HrSysPrepLoadInterfaceParams: failed to set %S to the registry. hr = %x.",
                prgVtpParams[i].pszRegValName, 
                hrReg);
        }
#endif

        //we dont pass the error of hrTmp out of this function because
        //there is not much we can do with this error
    }

    TraceError("CTcpipcfg::HrSysPrepLoadInterfaceParams", hr);
    return hr;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\resource.h ===
#include "ncres.h"

#define IDD_ATM_ADDR                    2300
#define IDD_ATM_ARPC                    2301
#define IDD_DNS_SERVER                  2304
#define IDD_DNS_SUFFIX                  2305
#define IDD_IPADDR_ADV                  2308
#define IDD_IPADDR_ADV_CHANGEGATE       2309
#define IDD_IPADDR_ADV_CHANGEIP         2310
#define IDD_TCP_DNS                     2322
#define IDD_TCP_IPADDR                  2323
#define IDD_TCP_WINS                    2324
#define IDD_TCP_NAMESVC                 2325
#define IDD_WINS_SERVER                 2326
#define IDD_TCP_OPTIONS                 2327
#define IDD_DHCP_CLSID                  2328
//#define IDD_IPSEC                       2329
#define IDD_OPT_RAS                     2330
#define IDD_TCP_IPADDR_RAS              2331
#define IDD_FILTER                      2332
#define IDD_FILTER_ADD                  2333
#define IDD_BACK_UP                     2334

#define IDI_UP_ARROW                    101
#define IDI_DOWN_ARROW                  102
#define IDI_IPADDR                      103
#define IDI_IPADV                       104
#define IDI_IPNAME                      105

// IP address page
#define IDC_IP_DHCP             1000
#define IDC_IP_FIXED            1001
#define IDC_IPADDR_IP           1002
#define IDC_IPADDR_SUB          1003
#define IDC_IPADDR_GATE         1004
#define IDC_IPADDR_IPTEXT       1005
#define IDC_IPADDR_SUBTEXT      1006
#define IDC_IPADDR_GATETEXT     1007

#define IDC_IPADDR_TEXT         1008

#define IDC_DNS_DHCP            1009
#define IDC_DNS_FIXED           1010
#define IDC_DNS_PRIMARY         1011
#define IDC_DNS_SECONDARY       1012
#define IDC_DNS_PRIMARY_TEXT    1013
#define IDC_DNS_SECONDARY_TEXT  1014

#define IDC_IPADDR_ADVANCED     1015

// Advanced IP address dialog
#define IDC_IPADDR_ADVIP            1016
#define IDC_IPADDR_ADDIP            1017
#define IDC_IPADDR_EDITIP           1018
#define IDC_IPADDR_REMOVEIP         1019

#define IDC_IPADDR_ADDGATE      1020
#define IDC_IPADDR_EDITGATE     1021
#define IDC_IPADDR_REMOVEGATE   1022
#define IDC_IPADDR_UP           1023
#define IDC_IPADDR_DOWN         1024
#define IDC_IPADDR_ADV_CHANGEIP_IP      1025
#define IDC_IPADDR_ADV_CHANGEIP_SUB     1026
#define IDC_IPADDR_ADV_CHANGE_GATEWAY   1027
#define IDC_IPADDR_ADV_CHANGE_METRIC    1028
#define IDC_IPADDR_METRIC       1029
#define IDC_AUTO_METRIC         1030

// DNS page
#define IDC_DNS_DOMAIN          1031
#define IDC_DNS_DOMAIN_STATIC   1032
#define IDC_DNS_SERVER_LIST     1040
#define IDC_DNS_SERVER_ADD      1041
#define IDC_DNS_SERVER_EDIT     1042
#define IDC_DNS_SERVER_REMOVE   1043
#define IDC_DNS_SERVER_UP       1044
#define IDC_DNS_SERVER_DOWN     1045


#define IDC_DNS_SEARCH_DOMAIN           1046
#define IDC_DNS_SEARCH_PARENT_DOMAIN    1047
#define IDC_DNS_USE_SUFFIX_LIST         1048
#define IDC_DNS_SUFFIX_LIST             1049
#define IDC_DNS_SUFFIX_ADD              1050
#define IDC_DNS_SUFFIX_EDIT             1051
#define IDC_DNS_SUFFIX_REMOVE           1052
#define IDC_DNS_SUFFIX_UP               1053
#define IDC_DNS_SUFFIX_DOWN             1054

#define IDC_DNS_CHANGE_SERVER           1055
#define IDC_DNS_CHANGE_SUFFIX           1056

#define IDC_DNS_ADDR_REG                1057
#define IDC_DNS_NAME_REG                1058
#define IDC_DNS_STATIC_GLOBAL           1059

// WINS page
#define IDC_WINS_SERVER_LIST    1060
#define IDC_WINS_ADD            1061
#define IDC_WINS_EDIT           1062
#define IDC_WINS_REMOVE         1063
#define IDC_WINS_UP             1064
#define IDC_WINS_DOWN           1065

#define IDC_WINS_LOOKUP         1066
#define IDC_WINS_LMHOST         1067

#define IDC_RAD_ENABLE_NETBT    1068
#define IDC_RAD_DISABLE_NETBT   1069
#define IDC_RAD_UNSET_NETBT     1070

#define IDC_WINS_CHANGE_SERVER  1071
#define IDC_WINS_STATIC_GLOBAL  1072

#define IDC_STATIC_IF_METRIC    1073
#define IDC_STATIC_DEFALUT_NBT  1074

// Atm arp client page
#define IDC_CHK_ATM_PVCONLY     1080
#define IDC_LBX_ATM_ArpsAddrs   1081
#define IDC_PSB_ATM_ArpsAdd     1082
#define IDC_PSB_ATM_ArpsEdt     1083
#define IDC_PSB_ATM_ArpsRmv     1084
#define IDC_PSB_ATM_ArpsUp      1085
#define IDC_PSB_ATM_ArpsDown    1086
#define IDC_LBX_ATM_MarsAddrs   1087
#define IDC_PSB_ATM_MarsAdd     1088
#define IDC_PSB_ATM_MarsEdt     1089
#define IDC_PSB_ATM_MarsRmv     1090
#define IDC_PSB_ATM_MarsUp      1091
#define IDC_PSB_ATM_MarsDown    1092
#define IDC_EDT_ATM_MaxTU       1093
#define IDC_EDT_ATM_Address     1094
#define IDCST_ATM_AddrName      1095

// Options page
#define IDC_LVW_OPTIONS         1100
#define IDC_OPT_PROPERTIES      1001
#define IDC_OPT_DESC            1002

// IPsec dialog
/* IP Security dialog is removed
#define IDC_RAD_IPSEC_NOIPSEC       1020
#define IDC_RAD_IPSEC_CUSTOM        1021
#define IDC_CMB_IPSEC_POLICY_LIST   1022
#define IDC_EDT_POLICY_DESC         1023
*/

// PPP/SLIP dialog
#define IDC_REMOTE_GATEWAY          1030
#define IDC_CHK_USE_COMPRESSION     1031
#define IDC_CMB_FRAME_SIZE          1032
#define IDC_STATIC_FRAME_SIZE       1033
#define IDC_GRP_PPP                 1034
#define IDC_GRP_SLIP                1035
#define IDC_STATIC_REMOTE_GATEWAY   1036

// IP Filtering Dialog
#define IDC_FILTERING_ENABLE         1040
#define IDC_FILTERING_FILTER_TCP     1041
#define IDC_FILTERING_FILTER_TCP_SEL 1042
#define IDC_FILTERING_TCP            1043
#define IDC_FILTERING_TCP_ADD        1044
#define IDC_FILTERING_TCP_REMOVE     1045
#define IDC_FILTERING_FILTER_UDP     1046
#define IDC_FILTERING_FILTER_UDP_SEL 1047
#define IDC_FILTERING_UDP            1048
#define IDC_FILTERING_UDP_ADD        1049
#define IDC_FILTERING_UDP_REMOVE     1050
#define IDC_FILTERING_FILTER_IP      1051
#define IDC_FILTERING_FILTER_IP_SEL  1052
#define IDC_FILTERING_IP             1053
#define IDC_FILTERING_IP_ADD         1054
#define IDC_FILTERING_IP_REMOVE      1055

// IP Filtering Add Dialog
#define IDC_FILTERING_TEXT           1060
#define IDC_FILTERING_ADD_EDIT       1061

// IP Back up Dialog
#define IDC_BKUP_RD_AUTO             1070
#define IDC_BKUP_RD_USER             1071
#define IDC_BKUP_IPADDR_TEXT         1072
#define IDC_BKUP_IPADDR              1073
#define IDC_BKUP_SUBNET_TEXT         1074
#define IDC_BKUP_SUBNET              1075
#define IDC_BKUP_GATEWAY_TEXT        1076
#define IDC_BKUP_GATEWAY             1077
#define IDC_BKUP_PREF_DNS_TEXT       1078
#define IDC_BKUP_PREF_DNS            1079
#define IDC_BKUP_ALT_DNS_TEXT        1080
#define IDC_BKUP_ALT_DNS             1081
#define IDC_BKUP_WINS1_TEXT          1082
#define IDC_BKUP_WINS1               1083
#define IDC_WINS2_TEXT               1084
#define IDC_BKUP_WINS2               1085

#define IDC_IPADDR_ADV_CHANGE_AUTOMETRIC 1090
#define IDC_IPADDR_ADV_CHANGE_METRIC_STATIC 1091


// Strings

#define IDS_MSFT_TCP_TEXT           23001

#define IDS_INVALID_SUBNET          23002
#define IDS_INVALID_NO_IP           23003
#define IDS_INVALID_NOSUBNET        23004
#define IDS_INCORRECT_IPADDRESS     23005
#define IDS_INCORRECT_IP_LOOPBACK   23006
#define IDS_INCORRECT_IP_FIELD_1    23007
#define IDS_TCPIP_DHCP_ENABLE       23008
#define IDS_IPADDRESS_TEXT          23009
#define IDS_SUBNET_TXT              23010

#define IDS_ITEM_NOT_SELECTED       23011
#define IDS_DHCPENABLED_TEXT        23012

#define IDS_INVALID_ATMSERVERLIST   23013
#define IDS_MTU_RANGE_WORD          23014
#define IDS_INCORRECT_ATM_ADDRESS   23015
#define IDS_ATM_INVALID_CHAR        23016
#define IDS_ATM_EMPTY_ADDRESS       23017

#define IDS_ATM_INVALID_LENGTH      23019

#define IDS_INVALID_DOMAIN          23020
#define IDS_INVALID_NO_SUFFIX       23021
#define IDS_INVALID_SUFFIX          23022

//IPSec is removed from connection UI   
//#define IDS_IPSEC_DOMAIN_POLICY     23023

#define IDS_TCP_ADV_HEADER          23024
#define IDS_IP_SECURITY             23027
#define IDS_IP_SECURITY_DESC        23028
#define IDS_PPP                     23029
#define IDS_PPP_DESC                23030
#define IDS_SLIP                    23031
#define IDS_SLIP_DESC               23032

#define IDS_CANNOT_CREATE_LMHOST_ERROR  23036
#define IDS_WINS_SYSTEM_PATH        23037
#define IDS_WINS_LMHOSTS_FAILED     23038

#define IDS_DUP_NETIP               23039
#define IDS_NO_BOUND_CARDS          23040

#define IDS_IPBAD_FIELD_VALUE       23041

#define IDS_IPNOMEM                 23042
#define IDS_IPMBCAPTION             23043

//IPSec is removed from connection UI   
//#define IDS_UNKNOWN_POLICY          23044
//#define IDS_DS_POLICY_PREFIX        23045

#define IDS_DUPLICATE_IP_ERROR      23046
#define IDS_DUPLICATE_IP_WARNING    23047

#define IDS_FILTERING_IP_LABEL           23048
#define IDS_FILTERING_IP_TEXT            23049
#define IDS_FILTERING_ITEM_IN_LIST       23050
#define IDS_FILTERING_ITEM_NOT_SELECTED  23051
#define IDS_FILTERING_RANGE_BYTE         23052
#define IDS_FILTERING_RANGE_WORD         23053
#define IDS_FILTERING_TCP_LABEL          23054
#define IDS_FILTERING_TCP_TEXT           23055
#define IDS_FILTERING_UDP_LABEL          23056
#define IDS_FILTERING_UDP_TEXT           23057

#define IDS_IP_FILTERING                 23058
#define IDS_IP_FILTERING_DESC            23059
#define IDS_FILTERING_DISABLE            23060
#define IDS_TCPIP_DNS_EMPTY              23061
#define IDS_METRIC_TEXT                  23062
#define IDS_INVALID_METRIC               23063
#define IDS_GATEWAY_TEXT                 23064

#define IDS_DUP_MALFUNCTION_IP_WARNING   23065
#define IDS_ERROR_UNCONTIGUOUS_SUBNET    23066

#define IDS_INVALID_DOMAIN_NAME     23067

#define IDS_TCP_AF_INVALID_DNS_SUFFIX   23068
#define IDS_TCP_AF_INVALID_SUBNET       23069
#define IDS_TCP_AF_NO_IP                23070
#define IDS_TCP_AF_NO_SUBNET            23071
#define IDS_TCP_AF_INVALID_DNS_DOMAIN   23072
#define IDS_TCP_AF_INVALID_IP_FIELDS    23073
#define IDS_TCP_AF_INVALID_GLOBAL_DNS_DOMAIN    23074
#define IDS_WIN32_ERROR_FORMAT          23075
//IPSec is removed from connection UI   
//#define IDS_SET_IPSEC_FAILED            23076
#define IDS_TCP_AF_INVALID_FIELDS       23077
#define IDS_DUP_DNS_SERVER              23078
#define IDS_DUP_DNS_SUFFIX              23079
#define IDS_DUP_WINS_SERVER             23080
#define IDS_DUP_IPADDRESS               23081
#define IDS_DUP_GATEWAY                 23082
#define IDS_DUP_SECOND_DNS              23083

#define IDS_INVALID_HOST_ALL_1          23084
#define IDS_INVALID_HOST_ALL_0          23085
#define IDS_INVALID_SUBNET_ALL_0        23086
#define IDS_AUTO_GW_METRIC              23087

#define IDS_WRN_DISJOINT_NET            23088
#define IDS_ERROR_IP_GW_MISMATH         23089

#define IDS_TCPATM_ARP_SERVER           23090
#define IDS_TCPATM_MAR_SERVER           23091
#define IDS_TCPATM_ADD                  23092
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpdhcp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P D H C P . C P P
//
//  Contents:   Functions related to Calling Dhcpcsvc.dll entry point
//              called from HrSetMisc
//
//              HrNotifyDhcp, HrCallDhcpConfig
//
//  Notes:      These functions are based on what was in ncpa1.1
//
//              HrNotifyDHCP is from CTcpGenPage::NotifyDHCP
//              HrCallDhcpConfig is from CallDHCPConfig
//
//  Author:     tongl   11 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "atmcommon.h"

#define ConvertIpDword(dwIpOrSubnet) ((dwIpOrSubnet[3]<<24) | (dwIpOrSubnet[2]<<16) | (dwIpOrSubnet[1]<<8) | (dwIpOrSubnet[0]))

//
//  CTcpipcfg::HrNotifyDhcp
//
//  Makes on the fly IP Address changes for all cards in the system
//
//  hkeyTcpipParam      Handle to \CCS\Services\Tcpip\Parameters reg key

HRESULT CTcpipcfg::HrNotifyDhcp()
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    ADAPTER_INFO* pAdapter;

    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter ++)
    {
        pAdapter = *iterAdapter;

        if((pAdapter->m_BindingState == BINDING_ENABLE) &&
           (pAdapter->m_InitialBindingState != BINDING_DISABLE) &&
           (!pAdapter->m_fIsWanAdapter))
        {
            // 1) Static IP-> Dhcp
            // The new value is enable DHCP,
            // but the old value was disable DHCP
            if(pAdapter->m_fEnableDhcp &&
               !pAdapter->m_fOldEnableDhcp)
            {
                TraceTag(ttidTcpip,"[HrNotifyDhcp] adapter:%S: Static IP->DHCP",
                         pAdapter->m_strBindName.c_str());

                HKEY hkeyTcpipParam = NULL;
                hrTmp = m_pnccTcpip->OpenParamKey(&hkeyTcpipParam);

                if SUCCEEDED(hrTmp)
                {
                    // Enable Dhcp
                    HKEY    hkeyInterfaces = NULL;
                    DWORD   dwGarbage;

                    // Open the interfaces key
                    hrTmp = HrRegCreateKeyEx(hkeyTcpipParam,
                                             c_szInterfacesRegKey,
                                             REG_OPTION_NON_VOLATILE,
                                             KEY_READ,
                                             NULL,
                                             &hkeyInterfaces,
                                             &dwGarbage);

                    if(SUCCEEDED(hrTmp))
                    {
                        Assert(hkeyInterfaces);
                        HKEY    hkeyInterfaceParam = NULL;

                        // Open the interface key for the specified interface
                        hrTmp = HrRegCreateKeyEx(
                                hkeyInterfaces,
                                pAdapter->m_strTcpipBindPath.c_str(),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ_WRITE,
                                NULL,
                                &hkeyInterfaceParam,
                                &dwGarbage);

                        if (SUCCEEDED(hrTmp))
                        {
                            // Clear up the IP address and subnet registry entries
                            Assert(hkeyInterfaceParam);

                            hrTmp = HrRegSetString(hkeyInterfaceParam,
                                                   RGAS_DHCP_IPADDRESS,
                                                   tstring(ZERO_ADDRESS));

                            if(SUCCEEDED(hrTmp))
                            {
                                hrTmp = HrRegSetString(hkeyInterfaceParam,
                                                       RGAS_DHCP_SUBNETMASK,
                                                       tstring(FF_ADDRESS));

                                if(SUCCEEDED(hrTmp))
                                {
                                    // Enable Dhcp & remove first static IP address
                                    hrTmp = HrCallDhcpConfig(
                                    NULL,
                                    (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                    pAdapter->m_guidInstanceId,
                                    FALSE, // static->dhcp
                                    0,  // index
                                    0,  // IP address
                                    0,  // Subnet mask
                                    DhcpEnable); //Flag: enable Dhcp
                                }
                            }
                        }
                        RegSafeCloseKey(hkeyInterfaceParam);
                    }
                    RegSafeCloseKey(hkeyInterfaces);
                }
                RegSafeCloseKey(hkeyTcpipParam);
            }

            // 2) Static IP change
            // DHCP is disabled now, and also used to be disabled before
            if(!pAdapter->m_fEnableDhcp &&
               !pAdapter->m_fOldEnableDhcp)
            {
                TraceTag(ttidTcpip,"[HrNotifyDhcp] adapter:%S: Static IP change.",
                         pAdapter->m_strBindName.c_str());

                HRESULT hrTmp2 = S_OK;
                BOOL  fStaticIpChanged = FALSE;

                // We should have equal number of IP addresses & subnet masks
                Assert(pAdapter->m_vstrIpAddresses.size() ==
                           pAdapter->m_vstrSubnetMask.size());

                Assert(pAdapter->m_vstrOldIpAddresses.size() ==
                       pAdapter->m_vstrOldSubnetMask.size());

                // We need to check if individual IP addresses are different
                // and call HrCallDhcpConfig once for each difference

                int iCountNew = pAdapter->m_vstrIpAddresses.size();
                int iCountOld = pAdapter->m_vstrOldIpAddresses.size();

                int iCount = iCountNew>iCountOld ? iCountOld :iCountNew;
                Assert(iCount>0);

                int iIp;

                // For each static IP address index in both old and new
                // Update IP
                for (iIp=0; iIp<iCount; iIp++)
                {
                    // Change address if mismatch
                    if((*pAdapter->m_vstrIpAddresses[iIp] !=
                        *pAdapter->m_vstrOldIpAddresses[iIp]) ||
                       (*pAdapter->m_vstrSubnetMask[iIp] !=
                        *pAdapter->m_vstrOldSubnetMask[iIp]))
                    {
                        // if a mismatch found, change it
                        fStaticIpChanged = TRUE;
                        break;
                    }
                }

                if (fStaticIpChanged)
                {
                    int i;

                    // blow away the rest of the old addresses in reverse order
                    for (i= iCountOld-1; i>=iIp; i--)
                    {
                        // Remove IP address on the fly
                        hrTmp2= HrCallDhcpConfig(
                                NULL,
                                (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                pAdapter->m_guidInstanceId,
                                TRUE,   // IsNewIpAddress: TRUE in static->static
                                i,      // Index of old IP address
                                0,      // Ip Address: remove
                                0,      // Subnetmask: remove
                                IgnoreFlag); // Flag: static->static

                        TraceError("Ctcpipcfg::HrNotifyDhcp - remove static IP address", hrTmp2);

                        if SUCCEEDED(hrTmp)
                            hrTmp = hrTmp2;
                    }

                    // add the rest of the new addresses in order
                    for (i= iIp; i< iCountNew; i++)
                    {
                        // Ip Address
                        DWORD dwIp[4];
                        GetNodeNum(pAdapter->m_vstrIpAddresses[i]->c_str(),dwIp);
                        DWORD dwNewIp = ConvertIpDword(dwIp);

                        // Subnet mask
                        DWORD dwSubnet[4];
                        GetNodeNum(pAdapter->m_vstrSubnetMask[i]->c_str(),dwSubnet);
                        DWORD dwNewSubnet = ConvertIpDword(dwSubnet);

                        if (0 == i)
                        {
                            // $REVIEW(tongl 6/3/98): the first address has to be added differently,
                            // yet another requirement by the api to change static ip list (bug #180015).
                            // Bug #180617 had my request to change the API to allow reconfigure whole
                            // static ip list instead of requiring caller to figure out everything needed
                            // for the internal data structure change for ip.

                            // must call "replace" instead of "add"
                            hrTmp2= HrCallDhcpConfig(
                                        NULL,
                                        (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                        pAdapter->m_guidInstanceId,
                                        TRUE,   // IsNewIpAddress: TRUE in static->static
                                        0,      // Replace first address
                                        dwNewIp,
                                        dwNewSubnet,
                                        IgnoreFlag); // Flag: static->static
                        }
                        else
                        {
                            // Add IP address on the fly
                            hrTmp2= HrCallDhcpConfig(
                                        NULL,
                                        (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                        pAdapter->m_guidInstanceId,
                                        TRUE,   // IsNewIpAddress: TRUE in static->static
                                        0xFFFF, // New IP address
                                        dwNewIp,
                                        dwNewSubnet,
                                        IgnoreFlag); // Flag: static->static
                        }

                        TraceError("Ctcpipcfg::HrNotifyDhcp - add static IP address", hrTmp2);

                        if SUCCEEDED(hrTmp)
                            hrTmp = hrTmp2;
                    }
                }
                else
                {
                    // existing addresses all match
                    if (iIp<iCountNew) // We ust get more new addresses to add
                    {
                        fStaticIpChanged = TRUE;

                        while (iIp<iCountNew)
                        {
                            DWORD dwIp[4];
                            Assert(!pAdapter->m_vstrIpAddresses.empty());

                            GetNodeNum(pAdapter->m_vstrIpAddresses[iIp]->c_str(),
                                       dwIp);
                            DWORD dwNewIp = ConvertIpDword(dwIp);

                            // Subnet mask
                            DWORD dwSubnet[4];
                            Assert(!pAdapter->m_vstrSubnetMask.empty());
                            GetNodeNum(pAdapter->m_vstrSubnetMask[iIp]->c_str(),
                                       dwSubnet);
                            DWORD dwNewSubnet = ConvertIpDword(dwSubnet);

                            // Add IP address on the fly
                            hrTmp2= HrCallDhcpConfig(
                                    NULL,
                                    (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                    pAdapter->m_guidInstanceId,
                                    TRUE,   // IsNewIpAddress: TRUE in static->static
                                    0xFFFF, // New IP address
                                    dwNewIp,
                                    dwNewSubnet,
                                    IgnoreFlag); // Flag: static->static

                            TraceError("Ctcpipcfg::HrNotifyDhcp - add static IP address", hrTmp2);

                            if SUCCEEDED(hrTmp)
                                hrTmp = hrTmp2;

                            iIp++;
                        }
                    }
                    else if (iIp<iCountOld) // We just get more old addresses to remove
                    {
                        fStaticIpChanged = TRUE;

                        int iIp2 = iCountOld-1;

                        while (iIp2 >= iIp)
                        {
                            // Remove IP address on the fly
                            hrTmp2= HrCallDhcpConfig(
                                    NULL,
                                    (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                    pAdapter->m_guidInstanceId,
                                    TRUE,   // IsNewIpAddress: TRUE in static->static
                                    iIp2,    // Index of old IP address
                                    0,      // Ip Address: remove
                                    0,      // Subnetmask: remove
                                    IgnoreFlag); // Flag: static->static

                            TraceError("Ctcpipcfg::HrNotifyDhcp - remove static IP address", hrTmp2);

                            if SUCCEEDED(hrTmp)
                                hrTmp = hrTmp2;

                            iIp2--;
                        }
                    }
                }
            }

            // 3) Dhcp->Static
            // DHCP is disabled now, but used to be enabled
            if(!pAdapter->m_fEnableDhcp &&
               pAdapter->m_fOldEnableDhcp)
            {
                TraceTag(ttidTcpip,"[HrNotifyDhcp] adapter:%S: DHCP->Static IP",
                         pAdapter->m_strBindName.c_str());

                // Disable Dhcp & add first static Ip address
                Assert(!pAdapter->m_vstrIpAddresses.empty());

                // Ip Address
                DWORD dwIp[4];
                GetNodeNum(pAdapter->m_vstrIpAddresses[0]->c_str(),
                           dwIp);
                DWORD dwNewIp = ConvertIpDword(dwIp);

                // Subnet Mask
                DWORD dwSubnet[4];
                Assert(!pAdapter->m_vstrSubnetMask.empty());
                GetNodeNum(pAdapter->m_vstrSubnetMask[0]->c_str(),
                           dwSubnet);
                DWORD dwNewSubnet = ConvertIpDword(dwSubnet);

                // change IP address on the fly
                hrTmp = HrCallDhcpConfig(
                        NULL,
                        (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                        pAdapter->m_guidInstanceId,
                        TRUE,
                        0, // index: update dhcp address to first static address
                        dwNewIp,
                        dwNewSubnet,
                        DhcpDisable); // Flag: disable Dhcp

                if SUCCEEDED(hrTmp)
                {
                    HRESULT hrTmp2 = S_OK;

                    // Add the rest of new static IP addresses
                    for (size_t iIp = 1;
                         iIp < pAdapter->m_vstrIpAddresses.size();
                         iIp++)
                    {
                        // Ip Address
                        DWORD dwIp[4];
                        Assert(!pAdapter->m_vstrIpAddresses.empty());
                        GetNodeNum(pAdapter->m_vstrIpAddresses[iIp]->c_str(),
                                   dwIp);
                        DWORD dwNewIp = ConvertIpDword(dwIp);

                        // Subnet Mask
                        DWORD dwSubnet[4];
                        Assert(!pAdapter->m_vstrSubnetMask.empty());
                        GetNodeNum(pAdapter->m_vstrSubnetMask[iIp]->c_str(),
                                   dwSubnet);
                        DWORD dwNewSubnet = ConvertIpDword(dwSubnet);

                        // change IP address on the fly
                        hrTmp2= HrCallDhcpConfig(
                                NULL,
                                (PWSTR)pAdapter->m_strTcpipBindPath.c_str(),
                                pAdapter->m_guidInstanceId,
                                TRUE,
                                0xFFFF, // index: new address
                                dwNewIp,
                                dwNewSubnet,
                                IgnoreFlag ); // Flag: static->static

                         TraceError("CTcpipcfg::HrNotifyDhcp - add static IP address", hrTmp2);

                        if SUCCEEDED(hrTmp)
                            hrTmp = hrTmp2;
                    }
                }
            }

            if (SUCCEEDED(hr))
                hr = hrTmp;

            // 4) Dhcp Class ID, DNS server list and domain change
            // $REVIEW(tongl 6/12): Notify DNS server list and domain changes
            // here (Raid #175766)

            DHCP_PNP_CHANGE DhcpPnpChange;
            ZeroMemory(&DhcpPnpChange, sizeof(DHCP_PNP_CHANGE));

            DhcpPnpChange.Version = DHCP_PNP_CHANGE_VERSION_0;
            DhcpPnpChange.HostNameChanged = FALSE;
            DhcpPnpChange.MaskChanged = FALSE;

            //Bug 257868 If there is user specified default gateway, notify dhcp client
            DhcpPnpChange.GateWayChanged = !fIsSameVstr(pAdapter->m_vstrDefaultGateway,
                                            pAdapter->m_vstrOldDefaultGateway) ||
                                           !fIsSameVstr(pAdapter->m_vstrDefaultGatewayMetric,
                                            pAdapter->m_vstrOldDefaultGatewayMetric);
            DhcpPnpChange.RouteChanged = FALSE;
            DhcpPnpChange.OptsChanged = FALSE;
            DhcpPnpChange.OptDefsChanged = FALSE;

            DhcpPnpChange.DnsListChanged = !fIsSameVstr(pAdapter->m_vstrDnsServerList,
                                                        pAdapter->m_vstrOldDnsServerList);
            DhcpPnpChange.DomainChanged = pAdapter->m_strDnsDomain != pAdapter->m_strOldDnsDomain;
            DhcpPnpChange.ClassIdChanged = FALSE;
            DhcpPnpChange.DnsOptionsChanged = 
                        ((!!pAdapter->m_fDisableDynamicUpdate) != 
                            (!!pAdapter->m_fOldDisableDynamicUpdate))
                        ||
                        ((!!pAdapter->m_fEnableNameRegistration) !=
                            (!!pAdapter->m_fOldEnableNameRegistration));
  

            if(DhcpPnpChange.DnsListChanged || 
               DhcpPnpChange.DnsOptionsChanged ||
               DhcpPnpChange.DomainChanged  ||
               (DhcpPnpChange.GateWayChanged && pAdapter->m_fEnableDhcp))
            {
                hrTmp = HrCallDhcpHandlePnPEvent(pAdapter, &DhcpPnpChange);
                if (FAILED(hrTmp))
                {
                    TraceError("HrCallDhcpHandlePnPEvent returns failure, requesting reboot...", hrTmp);
                    hr = NETCFG_S_REBOOT;
                }
            }

            if (pAdapter->m_fBackUpSettingChanged)
            {
                hrTmp = HrDhcpRefreshFallbackParams(pAdapter);
                if (FAILED(hrTmp))
                {
                    TraceError("HrDhcpRefreshFallbackParams returns failure, requesting reboot...", hrTmp);
                    hr = NETCFG_S_REBOOT;
                }
            }
        }
    }

    if (NETCFG_S_REBOOT != hr)
        hr = hrTmp;

    TraceError("CTcpipcfg::HrNotifyDhcp", hr);
    return hr;
}

// Define the export function prototype from dhcpcsvc.dll

typedef DWORD (APIENTRY *T_DhcpNotifyConfigChange)(PWSTR ServerName,
                                                   PWSTR AdapterName,
                                                   BOOL IsNewIpAddress,
                                                   DWORD IpIndex,
                                                   DWORD IpAddress,
                                                   DWORD SubnetMask,
                                                   SERVICE_ENABLE DhcpServiceEnabled);

//
//  CTcpipcfg::HrCallDhcpConfig
//
//  Sets the IP address on the fly (without re-booting)
//
//  ServerName             always set to NULL
//  AdapterName            the adapter BindPathName to tcpip
//  IsNewIpAddress         set to TRUE if Dhcp->Static or Statis->Static changes
//                         set to FALSE if Static->Dhcp changes
//
//
//  IpIndex                the index of the IP Address for the card
//                         adapters can have more than 1 IP Address
//                         (as seen in the Advanced dialog)
//                         (this is causing problem for Munil
//                         because the use of this index is buggy in his code
//                         index is always set to 0 if there is only one IP Address
//                         for the card
//
//  IpAddress               the new IP Address
//  SubnetMask              the new SubnetMask
//
//  DhcpServiceEnabled      enum type, can be set to :
//                          DhcpEnable      -> if DHCP was disabled,
//                                             but now being changed to enabled
//                          IgnoreFlag      -> DHCP was disabled and is still disabled
//                          DhcpDisable     -> DHCP was enabled, but now being changed
//                                             to disabled
//
// For extra reference talk to Munil -> these parameters correspond to the
// DhcpNotifyConfigChange API of the dhcpcsvc.dll file
//

HRESULT CTcpipcfg::HrCallDhcpConfig(PWSTR ServerName,
                         PWSTR AdapterName,
                         GUID & guidAdaputer,
                         BOOL IsNewIpAddress,
                         DWORD IpIndex,
                         DWORD IpAddress,
                         DWORD SubnetMask,
                         SERVICE_ENABLE DhcpServiceEnabled)
{

    HRESULT hr = S_OK;

    // Make sure TCP/IP is running.
    // Scoping brackets cause service and service controller to be
    // closed when we don't need them anymore.
    {
        CServiceManager smng;
        CService        serv;

        hr = smng.HrOpenService(&serv, c_szTcpip, NO_LOCK,
                        SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);
        if(SUCCEEDED(hr))
        {
            DWORD dwState;

            hr = serv.HrQueryState(&dwState);
            if(SUCCEEDED(hr))
            {
                if(dwState != SERVICE_RUNNING)
                {
                    //TCPIP must always be running if installed!!!
                    AssertSz(FALSE, "Tcpip service must always be running if installed!");
                    hr = E_FAIL;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        HMODULE hDll;
        FARPROC pDhcpConfig;
        hr = HrLoadLibAndGetProc (L"dhcpcsvc.dll",
                "DhcpNotifyConfigChange",
                &hDll, &pDhcpConfig);
        if (SUCCEEDED(hr))
        {
            TraceTag(ttidTcpip,"Begin calling DhcpNotifyConfigChange...");

            // Parameter dump for debugging
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] ServerName:%S", ServerName);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] AdapterName:%S", AdapterName);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] IsNewIpAddress:%d", IsNewIpAddress);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] IpIndex:%d", IpIndex);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] IpAddress:%d", IpAddress);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] SubnetMask:%d", SubnetMask);
            TraceTag(ttidTcpip, "[DhcpNotifyConfigChange] DhcpServiceEnabled:%d", DhcpServiceEnabled);

            DWORD dwError;

            dwError = (*(T_DhcpNotifyConfigChange)pDhcpConfig)(
                                    ServerName,
                                    AdapterName,
                                    IsNewIpAddress,
                                    IpIndex,
                                    IpAddress,
                                    SubnetMask,
                                    DhcpServiceEnabled);

            TraceTag(ttidTcpip,"Finished calling DhcpNotifyConfigChange...");
            hr = HRESULT_FROM_WIN32(dwError);

            if FAILED(hr)
            {
                // Added as part of fix for #107373
                if (ERROR_DUP_NAME == dwError)
                {
                    //if popups are allowed during PnP, warn the user about the Dup IP address
                    if (!m_fNoPopupsDuringPnp)
                    {
                        // Warn the user about duplicate IP address
                        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT,
                                 IDS_DUP_NETIP, MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                        hr = S_OK;    
                    }
                    else
                    {
                        //if doesn't popup error, return NETCFG_S_REBOOT to indicate PnP error
                        hr = NETCFG_S_REBOOT;
                    }
                }
                else if (ERROR_FILE_NOT_FOUND == dwError)
                {
                    // The adapter we want to reconfig is not connected
                    TraceTag(ttidTcpip, "The adater is disconnected or not bound to TCP/IP.");
                    hr = S_OK;
                }
                else if (STATUS_DUPLICATE_OBJECTID == dwError)
                {
                    // fix for 320797
                    TraceTag(ttidTcpip, "The address is already configured for the adapter");
                    hr = S_OK;
                }
                else if (ERROR_INVALID_DRIVE == dwError)
                {
                    // fix for 320797
                    TraceTag(ttidTcpip, "The address has already been deleted from the stack");
                    hr = S_OK;
                }
                else
                {
                    TraceError("Error on DhcpNotifyConfigChange from dhcpcsvc.dll", hr);

                    FARPROC pfnHrGetPnpDeviceStatus = NULL;
                    HRESULT hrTmp = S_OK;
                    HMODULE hNetman = NULL;
                    NETCON_STATUS   ncStatus = NCS_CONNECTED;
                    hrTmp = HrLoadLibAndGetProc(L"netman.dll", "HrGetPnpDeviceStatus",
                                                &hNetman, &pfnHrGetPnpDeviceStatus);

                    if (SUCCEEDED(hrTmp))
                    {
                        Assert(pfnHrGetPnpDeviceStatus);
                        hrTmp = (*(PHRGETPNPDEVICESTATUS)pfnHrGetPnpDeviceStatus)(
                                        &guidAdaputer,
                                        &ncStatus);
                        FreeLibrary(hNetman);
                    }

                    if (SUCCEEDED(hrTmp) && NCS_MEDIA_DISCONNECTED == ncStatus)
                    {
                        TraceTag(ttidTcpip, "The connection is media disconnected. Do not need to reboot");
                        hr = S_OK;
                    }
                    else
                    {
                        // Mask the specific error so NCPA does not fail.
                        hr = NETCFG_S_REBOOT;
                    }

                }
            }

            FreeLibrary (hDll);
        }
    }


    TraceError("CTcpipcfg::HrCallDhcpConfig", hr);
    return hr;
}

typedef DWORD (WINAPI * PFNDhcpHandlePnPEvent) (
                                                IN  DWORD               Flags,
                                                IN  DWORD               Caller,
                                                IN  PWSTR              AdapterName,
                                                IN  LPDHCP_PNP_CHANGE   Changes,
                                                IN  LPVOID              Reserved
                                                );

HRESULT CTcpipcfg::HrCallDhcpHandlePnPEvent(ADAPTER_INFO * pAdapterInfo,
                                         LPDHCP_PNP_CHANGE pDhcpPnpChange)
{
    // load the dll and get function pointer
    HMODULE hDll;
    FARPROC pDhcpHandlePnPEvent;
    HRESULT hr = HrLoadLibAndGetProc (L"dhcpcsvc.dll",
                                      "DhcpHandlePnPEvent",
                                      &hDll, &pDhcpHandlePnPEvent);
    if (SUCCEEDED(hr))
    {
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Flags: 0");
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Caller: DHCP_CALLER_TCPUI");
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] AdapterName: %S", pAdapterInfo->m_strBindName.c_str());
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Changes.DnsListChanged: %d", pDhcpPnpChange->DnsListChanged);
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Changes.DomainChanged: %d", pDhcpPnpChange->DomainChanged);
        TraceTag(ttidTcpip, "[DhcpHandlePnPEvent] Changes.ClassIdChanged: %d", pDhcpPnpChange->ClassIdChanged);

        DWORD dwRet = (*(PFNDhcpHandlePnPEvent)pDhcpHandlePnPEvent)(
                            0,
                            DHCP_CALLER_TCPUI,
                            (PWSTR)pAdapterInfo->m_strBindName.c_str(),
                            pDhcpPnpChange,
                            NULL);

        hr = HRESULT_FROM_WIN32(dwRet);

        if (ERROR_FILE_NOT_FOUND == dwRet)
        {
            // The adapter we want to reconfig is not connected
            TraceTag(ttidTcpip, "DhcpHandlePnPEvent returns ERROR_FILE_NOT_FOUND. The adater is disconnected or not bound to TCP/IP.");
            hr = S_OK;
        }

        FreeLibrary (hDll);
    }

    TraceError("CTcpipcfg::HrCallDhcpHandlePnPEvent", hr);
    return hr;
}

typedef DWORD (WINAPI * PFDhcpFallbackRefreshParams) (
                                                IN  LPWSTR              AdapterName
                                                );

HRESULT CTcpipcfg::HrDhcpRefreshFallbackParams(ADAPTER_INFO * pAdapterInfo)
{
    // load the dll and get function pointer
    HMODULE hDll;
    FARPROC pDhcpFallbackRefreshParams;
    HRESULT hr = HrLoadLibAndGetProc (L"dhcpcsvc.dll",
                                      "DhcpFallbackRefreshParams",
                                      &hDll, &pDhcpFallbackRefreshParams);
    if (SUCCEEDED(hr))
    {
        TraceTag(ttidTcpip, "[DhcpFallbackRefreshParams] AdapterName: %S", pAdapterInfo->m_strBindName.c_str());
        DWORD dwRet = (*(PFDhcpFallbackRefreshParams)pDhcpFallbackRefreshParams)(
                            (LPWSTR)pAdapterInfo->m_strBindName.c_str()
                            );

        hr = HRESULT_FROM_WIN32(dwRet);

        if (ERROR_FILE_NOT_FOUND == dwRet)
        {
            // The adapter we want to reconfig is not connected
            TraceTag(ttidTcpip, "DhcpFallbackRefreshParams returns ERROR_FILE_NOT_FOUND. The adater is disconnected or not bound to TCP/IP.");
            hr = S_OK;
        }

        FreeLibrary (hDll);
    }
    
    TraceError("CTcpipcfg::HrDhcpRefreshFallbackParams", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpaf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P A F . C P P
//
//  Contents:   TCP/IP answer file processing
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcpipobj.h"
#include "ncsetup.h"
#include "tcpconst.h"
#include "tcperror.h"
#include "tcputil.h"
#include "ncreg.h"
#include "ncperms.h"
#include "afilestr.h"
#include "ipafval.h"


extern const WCHAR c_szAdapterSections[];

BOOL FValidateIpFieldsFromAnswerFile(VSTR & vstrIpAddr, PCWSTR pszValueName,
                                    PCWSTR szAdapterName, BOOL fIsIpAddr = TRUE);

BOOL FValidateAdapterParametersFromAnswerFile(ADAPTER_INFO* pAdapter,
                                              PCWSTR pszAdapterName);
BOOL FValidateGlobalParametersFromAnswerFile(GLOBAL_INFO* pGlobalInfo);

HRESULT HrLoadUnConfigurableParamFromAnswerFile(HINF hinf,
                                                PCWSTR pszSection,
                                                const ValueTypePair * prgVtpParams,
                                                UINT    cParams,
                                                HKEY    hkeyParam);


HRESULT CTcpipcfg::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    HRESULT     hr = S_OK;
    HRESULT     hrTmp = S_OK;

    CSetupInfFile   caf;    // Class to process answer file

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = caf.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (SUCCEEDED(hr))
    {
        hrTmp = HrLoadGlobalParamFromAnswerFile(caf.Hinf(), pszAnswerSection);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // Get the adapter specific Tcpip and NetBT parameters
        WCHAR * mszAdapterList;
        hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(caf.Hinf(),
                                                     pszAnswerSection,
                                                     c_szAdapterSections,
                                                     &mszAdapterList);
        if (SUCCEEDED(hrTmp) && NULL != mszAdapterList)
        {
            hrTmp = HrLoadAdapterParameterFromAnswerFile(caf.Hinf(),
                                                      mszAdapterList);
            delete [] mszAdapterList;
        }

        if (SUCCEEDED(hr))
            hr = hrTmp;

        caf.Close();
    }

    TraceErrorOptional("CTcpipcfg::HrProcessAnswerFile", hr,
                       SPAPI_E_LINE_NOT_FOUND == hr);

    // Mask the errors since we will be using the defaults
    if FAILED(hr)
        hr = S_OK;

    return hr;
}

// Load Global parameters from answerfile to memory structure
HRESULT  CTcpipcfg::HrLoadGlobalParamFromAnswerFile(HINF hinf,
                                                    PCWSTR pszTcpipMainSection)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp;

    BOOL    fTmp;
    DWORD   dwTmp;

    hr = m_glbGlobalInfo.HrSetDefaults();

    if SUCCEEDED(hr)
    {
        // $REVIEW(tongl 3/22/98): per Stuart Kwan, I'm reading global
        // DNS server list just for the upgrade case
        // DNSDomain -> m_strDnsDomain
        tstring strDnsDomain;
        hrTmp = HrSetupGetFirstString(  hinf,
                                        pszTcpipMainSection,
                                        c_szAfDnsDomain,
                                        &strDnsDomain);

        if SUCCEEDED(hrTmp)
        {
            m_fUpgradeGlobalDnsDomain = TRUE;
            if (!strDnsDomain.empty())
            {
                DNS_STATUS status;
                status = DnsValidateName(strDnsDomain.c_str(), DnsNameDomain);

                //validate the global dns domain name
                if (ERROR_INVALID_NAME == status || 
                    DNS_ERROR_INVALID_NAME_CHAR == status)
                {
                    WriteTcpSetupErrorLog(IDS_TCP_AF_INVALID_GLOBAL_DNS_DOMAIN, strDnsDomain.c_str());
                    m_fUpgradeGlobalDnsDomain = FALSE;
                }
            }

            if (m_fUpgradeGlobalDnsDomain)
                m_strUpgradeGlobalDnsDomain = strDnsDomain;
        }
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParameterFromAnswerFile: DNSDomain", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // DNSHostName -> m_strHostNameFromAnswerFile
        hrTmp = HrSetupGetFirstString(hinf,
                                      pszTcpipMainSection,
                                      c_szAfDnsHostname,
                                      &m_glbGlobalInfo.m_strHostNameFromAnswerFile);
        if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: DNSHostName", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // DNSSuffixSearchOrder -> m_strSearchList
        WCHAR * mszSearchList;
        hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc( hinf,
                                                      pszTcpipMainSection,
                                                      c_szAfDnsSuffixSearchOrder,
                                                      &mszSearchList);

        if SUCCEEDED(hrTmp)
        {
            MultiSzToColString( mszSearchList,
                                &m_glbGlobalInfo.m_vstrDnsSuffixList);
            delete [] mszSearchList;
        }
        if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: DNSSuffixSearchOrder", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // EnableLMHosts -> m_fEnableLmHosts
        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfEnableLmhosts,
                                            &fTmp);

        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fEnableLmHosts = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: EnableLMHosts", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // Per AmritanR, drop the upgrade support of IpEnableRouter to fix bug 345700
        // EnableIPForwarding -> m_fEnableRouter (BOOL)
        

        //(nsun 11/03/98) parameters for RRAS during unattended install
        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfEnableICMPRedirect,
                                            &fTmp);
        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fEnableIcmpRedirect = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: EnableICMPRedirect", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        //(nsun 09/20/99) PerformRouterDiscoveryDefault was removed to fix bug 405636

        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfDeadGWDetectDefault,
                                            &fTmp);
        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fDeadGWDetectDefault = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: DeadGWDetectDefault", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfDontAddDefaultGatewayDefault,
                                            &fTmp);
        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: DontAddDefaultGatewayDefault", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;


        // EnableSecurity -> m_fEnableFiltering
        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfEnableSecurity,
                                            &fTmp);

        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fEnableFiltering = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: EnableSecurity", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;


        // 8/10/98 nsun: added to support UseDomainNameDevolution value in unattended install
        hrTmp = HrSetupGetFirstStringAsBool(hinf, pszTcpipMainSection,
                                            c_szAfUseDomainNameDevolution,
                                            &fTmp);
        if SUCCEEDED(hrTmp)
            m_glbGlobalInfo.m_fUseDomainNameDevolution = fTmp;
        else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
            hrTmp = S_OK;
        else
            TraceError("HrLoadGlobalParamFromAnswerFile: UseDomainNameDevolution", hrTmp);

        if (SUCCEEDED(hr))
            hr = hrTmp;

        //$REVIEW (nsun 12/11/98) directly save the unconfigurable parameters
        // right after reading it from the answer file.
        HKEY hkeyTcpipParam = NULL;
        Assert(m_pnccTcpip);

        if(m_pnccTcpip)
        {
            hrTmp = m_pnccTcpip->OpenParamKey(&hkeyTcpipParam);
            if (SUCCEEDED(hrTmp))
            {
                Assert(hkeyTcpipParam);
                hrTmp = HrLoadUnConfigurableParamFromAnswerFile(hinf,
                                                    pszTcpipMainSection,
                                                    rgVtpIp,
                                                    sizeof(rgVtpIp)/sizeof(rgVtpIp[0]),
                                                    hkeyTcpipParam);
                RegSafeCloseKey(hkeyTcpipParam);
            }

            if (SUCCEEDED(hr))
                hr = hrTmp;
        }

        HKEY hkeyWinsParam = NULL;
        Assert(m_pnccWins);
        if(m_pnccWins)
        {
            hrTmp = m_pnccWins->OpenParamKey(&hkeyWinsParam);
            if (SUCCEEDED(hrTmp))
            {
                Assert(hkeyWinsParam);
                hrTmp = HrLoadUnConfigurableParamFromAnswerFile(hinf,
                                                    pszTcpipMainSection,
                                                    rgVtpNetBt,
                                                    sizeof(rgVtpNetBt)/sizeof(rgVtpNetBt[0]),
                                                    hkeyWinsParam);
                RegSafeCloseKey(hkeyWinsParam);
            }

            if (SUCCEEDED(hr))
                hr = hrTmp;
        }

        if (!FValidateGlobalParametersFromAnswerFile(&m_glbGlobalInfo))
        {
            TraceError("FValidateGlobalParametersFromAnswerFile() got invalid tcp settings", E_FAIL);
        }
    }

    TraceError("CTcpipcfg::HrLoadGlobalParamFromAnswerFile", hr);
    return hr;
}

// Load adapter specific parameters from answerfile to memory structure
HRESULT CTcpipcfg::HrLoadAdapterParameterFromAnswerFile(HINF hinf,
                                                        PCWSTR mszTcpipAdapterSections)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HRESULT hrReg = S_OK;

    PCWSTR  pszAdapterSection = mszTcpipAdapterSections;
    tstring  strAdapterName;
    tstring  strInterfaceRegPath;

    //$REVIEW (nsun 12/11/98) bug #204145
    //directly save the unconfigurable parameters right after reading
    //it from the answer file.
    HKEY hkeyTcpipParam = NULL;
    hrReg = m_pnccTcpip->OpenParamKey(&hkeyTcpipParam);
    hr = hrReg;

    while (*pszAdapterSection)
    {
        // Get the card name "SpecificTo = ..."
        hrTmp = HrSetupGetFirstString(hinf, pszAdapterSection,
                                 c_szAfSpecificTo, &strAdapterName);
        if (SUCCEEDED(hrTmp))
        {
            GUID     guidNetCard;
            if (!FGetInstanceGuidOfComponentInAnswerFile(
                                                strAdapterName.c_str(),
                                                m_pnc,
                                                &guidNetCard))
            {
                TraceTag(ttidError, "FGetInstanceGuidOfComponentInAnswerFile failed to match GUID for adapter %S", strAdapterName.c_str());

                // Move to the next card
                pszAdapterSection += lstrlenW(pszAdapterSection) + 1;
                continue;
            }

            // Do we already have this adapter in our list ?
            ADAPTER_INFO * pAdapterInfo = PAdapterFromInstanceGuid(&guidNetCard);
            if (!pAdapterInfo)
            {
                pAdapterInfo = new ADAPTER_INFO;

                if (NULL == pAdapterInfo)
                {
                    hr = E_OUTOFMEMORY;
                    continue;
                }

                hrTmp = pAdapterInfo->HrSetDefaults(&guidNetCard, c_szEmpty,
                                            c_szEmpty, c_szEmpty);
                if (SUCCEEDED(hrTmp))
                {
                    m_vcardAdapterInfo.push_back(pAdapterInfo);

                    // Set the flag that we only got this card from answer file,
                    // not from binding path, i.e. it's not on the binding path yet.
                    pAdapterInfo->m_fIsFromAnswerFile = TRUE;
                }
                else
                {
                    delete pAdapterInfo;
                    pAdapterInfo = NULL;
                }
            }

            if (SUCCEEDED(hrTmp))
            {
                BOOL fWins;

                hrTmp = HrSetupGetFirstStringAsBool(hinf, pszAdapterSection,
                                                     c_szAfWins,
                                                     &fWins);

                if (FAILED(hrTmp))
                {
                    if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                    else
                        TraceError("HrLoadAdapterParamFormAnswerFile: fWins", hrTmp);
                }
                else if (fWins)
                {
                    // WinsServerList -> m_vstrWinsServerList
                    WCHAR * mszWinsServerList;
                    hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                                  pszAdapterSection,
                                                                  c_szAfWinsServerList,
                                                                  &mszWinsServerList);

                    if SUCCEEDED(hrTmp)
                    {
                        MultiSzToColString(mszWinsServerList,
                                           &pAdapterInfo->m_vstrWinsServerList);
                        delete [] mszWinsServerList;
                    }
                    else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                    else
                        TraceError("HrLoadAdapterParamFromAnswerFile: WinsServerList", hrTmp);

                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // DHCP -> m_fEnableDhcp
                BOOL fEnableDhcp;
                hrTmp = HrSetupGetFirstStringAsBool(hinf, pszAdapterSection,
                                                c_szAfDhcp,
                                                &fEnableDhcp);

                if SUCCEEDED(hrTmp)
                    pAdapterInfo->m_fEnableDhcp = fEnableDhcp;
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: DHCP", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // IPAddress -> m_vstrIpAddresses
                WCHAR * mszIPAddresses;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfIpaddress,
                                                              &mszIPAddresses);
                if SUCCEEDED(hrTmp)
                {
                    MultiSzToColString(mszIPAddresses,
                                       &pAdapterInfo->m_vstrIpAddresses);
                    delete [] mszIPAddresses;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: IPAddress", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // SubnetMask -> m_vstrSubnetMask
                WCHAR * mszSubnetMasks;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfSubnetmask,
                                                              &mszSubnetMasks);
                if SUCCEEDED(hrTmp)
                {
                    MultiSzToColString(mszSubnetMasks,
                                       &pAdapterInfo->m_vstrSubnetMask);
                    delete [] mszSubnetMasks;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: SubnetMask", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // Gateway -> m_vstrDefaultGateway
                WCHAR * mszDefaultGateways;

                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfDefaultGateway,
                                                              &mszDefaultGateways);
                if (SUCCEEDED(hrTmp))
                {
                    MultiSzToColString(mszDefaultGateways,
                                       &pAdapterInfo->m_vstrDefaultGateway);
                    delete [] mszDefaultGateways;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: Gateway", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // DNSDomain -> m_strDnsDomain
                tstring strDnsDomain;
                hrTmp = HrSetupGetFirstString(  hinf,
                                                pszAdapterSection,
                                                c_szAfDnsDomain,
                                                &strDnsDomain);

                if SUCCEEDED(hrTmp)
                    pAdapterInfo->m_strDnsDomain = strDnsDomain;
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParameterFromAnswerFile: DNSDomain", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // DNSServerSearchOrder -> m_vstrDnsServerList
                WCHAR * mszDnsServerList;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                             pszAdapterSection,
                                                             c_szAfDnsServerSearchOrder,
                                                             &mszDnsServerList);
                if SUCCEEDED(hrTmp)
                {
                    MultiSzToColString(mszDnsServerList,
                                       &pAdapterInfo->m_vstrDnsServerList);
                    delete [] mszDnsServerList;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParameterFromAnswerFile: DNSServerSearchOrder", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                BOOL fTmp = FALSE;
                hrTmp = HrSetupGetFirstStringAsBool(hinf, pszAdapterSection,
                                                c_szAfDisableDynamicUpdate,
                                                &fTmp);
                if (SUCCEEDED(hrTmp))
                {
                    pAdapterInfo->m_fDisableDynamicUpdate = fTmp;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError(
                        "HrLoadAdapterParameterFromAnswerFile: DisableDynamicUpdate", 
                        hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                hrTmp = HrSetupGetFirstStringAsBool(hinf, pszAdapterSection,
                                                c_szAfEnableAdapterDomainNameRegistration,
                                                &fTmp);
                if (SUCCEEDED(hrTmp))
                {
                    pAdapterInfo->m_fEnableNameRegistration = fTmp;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError(
                        "HrLoadAdapterParameterFromAnswerFile: EnableAdapterDomainNameRegistration", 
                        hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // NetBIOSOptions ->m_dwNetbiosOptions
                DWORD dwNetbiosOptions;
                hrTmp = HrSetupGetFirstDword(hinf,
                                             pszAdapterSection,
                                             c_szAfNetBIOSOptions,
                                             &dwNetbiosOptions);
                if SUCCEEDED(hrTmp)
                {
                    if ((dwNetbiosOptions == c_dwUnsetNetbios) ||
                        (dwNetbiosOptions == c_dwEnableNetbios) ||
                        (dwNetbiosOptions == c_dwDisableNetbios))
                    {
                        pAdapterInfo->m_dwNetbiosOptions = dwNetbiosOptions;
                    }
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                    hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParameterFromAnswerFile: NetBIOSOptions", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // TcpAllowedPorts -> m_vstrTcpFilterList
                WCHAR * mszTcpFilterList;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfTcpAllowedPorts,
                                                              &mszTcpFilterList);
                if (SUCCEEDED(hrTmp))
                {
                    MultiSzToColString(mszTcpFilterList,
                                       &pAdapterInfo->m_vstrTcpFilterList);
                    delete [] mszTcpFilterList;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: TcpAllowedPorts", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // UdpAllowedPorts -> m_vstrUdpFilterList
                WCHAR * mszUdpFilterList;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfUdpAllowedPorts,
                                                              &mszUdpFilterList);
                if (SUCCEEDED(hrTmp))
                {
                    MultiSzToColString(mszUdpFilterList,
                                       &pAdapterInfo->m_vstrUdpFilterList);
                    delete [] mszUdpFilterList;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: UdpAllowedPorts", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                // IpAllowedProtocols -> m_vstrIpFilterList
                WCHAR * mszIpFilterList;
                hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc(hinf,
                                                              pszAdapterSection,
                                                              c_szAfIpAllowedProtocols,
                                                              &mszIpFilterList);
                if (SUCCEEDED(hrTmp))
                {
                    MultiSzToColString(mszIpFilterList,
                                       &pAdapterInfo->m_vstrIpFilterList);
                    delete [] mszIpFilterList;
                }
                else if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                        hrTmp = S_OK;
                else
                    TraceError("HrLoadAdapterParamFromAnswerFile: IpAllowedProtocols", hrTmp);

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                //$REVIEW (nsun 12/11/98) bug #204145
                //directly save the unconfigurable parameters right after reading
                //it from the answer file.
                if (SUCCEEDED(hrReg))
                {
                    Assert(hkeyTcpipParam);
                    HKEY hkeyInterfaceParam = NULL;
                    strInterfaceRegPath = c_szInterfacesRegKey;
                    strInterfaceRegPath += L"\\";

                    WCHAR szGuid [c_cchGuidWithTerm];
                    StringFromGUID2(guidNetCard, szGuid, c_cchGuidWithTerm);
                    strInterfaceRegPath += szGuid;

                    DWORD   dwDisposition;
                    hrTmp = HrRegCreateKeyEx(hkeyTcpipParam, strInterfaceRegPath.c_str(),
                                         REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                                         &hkeyInterfaceParam, &dwDisposition);
                    if( SUCCEEDED(hrTmp))
                    {
                        Assert(hkeyInterfaceParam);
                        hrTmp = HrLoadUnConfigurableParamFromAnswerFile(
                                        hinf,
                                        pszAdapterSection,
                                        rgVtpIpAdapter,
                                        sizeof(rgVtpIpAdapter)/sizeof(rgVtpIpAdapter[0]),
                                        hkeyInterfaceParam
                                        );
                        RegSafeCloseKey(hkeyInterfaceParam);
                    }
                    else
                        TraceError("HrLoadAdapterParamFromAnswerFile: CreateTcpipParm Reg key", hrTmp);
                }

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                if (!FValidateAdapterParametersFromAnswerFile(pAdapterInfo, strAdapterName.c_str()))
                {
                    TraceError("FValidateAdapterParameterFromAnswerFile() got invalid tcp settings", E_FAIL);
                }
            }
        }

        if (SUCCEEDED(hr))
            hr = hrTmp;

        // Move to the next card
        pszAdapterSection += lstrlenW(pszAdapterSection)+1;

    } // end of while loop

    if (SUCCEEDED(hrReg))
        RegSafeCloseKey(hkeyTcpipParam);

    TraceError("CTcpipcfg::HrLoadAdapterParamFromAnswerFile", hr);
    return hr;
}


HRESULT HrLoadUnConfigurableParamFromAnswerFile(HINF hinf,
                                                PCWSTR pszSection,
                                                const ValueTypePair * prgVtpParams,
                                                UINT    cParams,
                                                HKEY    hkeyParam)
{
    Assert(prgVtpParams);

    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HRESULT hrReg = S_OK;
    BOOL fTmp;
    DWORD dwTmp;
    tstring strTmp;
    WCHAR * mszTmp;

    for(UINT i = 0; i < cParams; i++)
    {
        TraceTag(ttidTcpip, "HrLoadUnConfigurableParamFromAnswerFile: configuring '%S'...", prgVtpParams[i].pszValueName);

        switch(prgVtpParams[i].dwType)
        {
        case REG_BOOL:
            hrTmp = HrSetupGetFirstStringAsBool(hinf, pszSection,
                                                prgVtpParams[i].pszValueName,
                                                &fTmp);
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetDword(hkeyParam,
                                      prgVtpParams[i].pszValueName,
                                      fTmp);
            break;

        case REG_DWORD:
            hrTmp = HrSetupGetFirstDword(hinf, pszSection,
                                         prgVtpParams[i].pszValueName,
                                         &dwTmp);
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetDword(hkeyParam,
                                      prgVtpParams[i].pszValueName,
                                      dwTmp);

            break;

        case REG_SZ:
            hrTmp = HrSetupGetFirstString(hinf, pszSection,
                                        prgVtpParams[i].pszValueName,
                                        &strTmp);
            if (SUCCEEDED(hrTmp))
                hrReg = HrRegSetString(hkeyParam,
                                       prgVtpParams[i].pszValueName,
                                       strTmp);
            break;

        case REG_MULTI_SZ:
            hrTmp = HrSetupGetFirstMultiSzFieldWithAlloc( hinf,
                                                      pszSection,
                                                      prgVtpParams[i].pszValueName,
                                                      &mszTmp);

            if (SUCCEEDED(hrTmp))
            {
                hrReg = HrRegSetMultiSz(hkeyParam,
                                        prgVtpParams[i].pszValueName,
                                        mszTmp);
                delete [] mszTmp;
            }
            break;

        case REG_FILE:
            hrTmp = HrSetupGetFirstString(hinf, pszSection,
                                          prgVtpParams[i].pszValueName,
                                          &strTmp);
            if (SUCCEEDED(hrTmp) && (strTmp.length() > 0))
            {
                DWORD   dwDisposition=0;
                TOKEN_PRIVILEGES *  ptpRestore = NULL;
                HKEY hkeyRestore=NULL;

                hrReg = HrRegCreateKeyEx(hkeyParam,
                                         prgVtpParams[i].pszValueName,
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS, NULL,
                                         &hkeyRestore, &dwDisposition);
                if (S_OK == hr)
                {
                    hrReg = HrEnableAllPrivileges(&ptpRestore);
                    if (SUCCEEDED(hrReg))
                    {
                        TraceTag(ttidTcpip, "HrLoadUnConfigurableParamFromAnswerFile: trying to restore regkey from file '%S'..", strTmp.c_str());
                        hrReg = HrRegRestoreKey(hkeyRestore, strTmp.c_str(), 0);
                        (void) HrRestorePrivileges(ptpRestore);
                        delete [] reinterpret_cast<BYTE *>(ptpRestore);
                    }
                    RegCloseKey(hkeyRestore);
                }
            }
            break;
        }

        if(FAILED(hrTmp))
        {
            if(hrTmp == SPAPI_E_LINE_NOT_FOUND)
                hrTmp = S_OK;
            else
            {
                TraceTag(ttidError,
                    "HrLoadUnConfigurableParamFromAnswerFile: failed to load %S. hr = %x.",
                    prgVtpParams[i].pszValueName, hrTmp);
            }
        }

#ifdef ENABLETRACE
        if(FAILED(hrReg))
        {
            TraceTag(ttidError,
                "HrLoadUnConfigurableParamFromAnswerFile: failed to set %S to the registry. hr = %x.",
                prgVtpParams[i].pszValueName, hrReg);
        }
#endif

        if (SUCCEEDED(hr))
            hr = hrTmp;

        if (SUCCEEDED(hr))
            hr = hrReg;
    }

    TraceError("CTcpipcfg::HrLoadUnConfigurableParamFromAnswerFile", hr);
    return hr;
}


BOOL FValidateIpFieldsFromAnswerFile(VSTR & vstrIpAddr, PCTSTR pszValueName,
                                    PCWSTR pszAdapterName, BOOL fIsIpAddr)

{
    BOOL fRet = TRUE;

    for (VSTR::iterator iter = vstrIpAddr.begin(); iter != vstrIpAddr.end(); iter++)
    {
        tstring* pstrIpAddr = *iter;
        if (!FIsValidIpFields(pstrIpAddr->c_str(), fIsIpAddr))
        {
            WriteTcpSetupErrorLog(fIsIpAddr ? IDS_TCP_AF_INVALID_IP_FIELDS : IDS_TCP_AF_INVALID_FIELDS, 
                                  pszValueName,
                                  pszAdapterName, 
                                  pstrIpAddr->c_str());
            fRet = FALSE;
        }
    }

    return fRet;
}

BOOL FValidateGlobalParametersFromAnswerFile(GLOBAL_INFO* pGlobalInfo)
{
    BOOL fRet = TRUE;

    DNS_STATUS status;

    if (!pGlobalInfo->m_vstrDnsSuffixList.empty())
    {
        for (VSTR::iterator iter = pGlobalInfo->m_vstrDnsSuffixList.begin();
            iter != pGlobalInfo->m_vstrDnsSuffixList.end(); iter++)
        {
            status = DnsValidateName((*iter)->c_str(), DnsNameDomain);
            if (ERROR_INVALID_NAME == status ||
                DNS_ERROR_INVALID_NAME_CHAR == status)
            {
                WriteTcpSetupErrorLog(IDS_TCP_AF_INVALID_DNS_SUFFIX,
                                    c_szAfDnsSuffixSearchOrder,
                                    (*iter)->c_str());
                fRet = FALSE;
            }
        }
    }

    if (!fRet)
    {
        FreeCollectionAndItem(pGlobalInfo->m_vstrDnsSuffixList);
    }

    return fRet;
}

BOOL FValidateAdapterParametersFromAnswerFile(ADAPTER_INFO* pAdapter, PCWSTR pszAdapterName)
{
    BOOL fRet = TRUE;

    if (!pAdapter->m_fEnableDhcp)
    {
        if (!pAdapter->m_vstrIpAddresses.empty())
        {
            if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrIpAddresses,
                                                c_szAfIpaddress,
                                                pszAdapterName))
            {
                fRet = FALSE;
            }
        }

        if (!pAdapter->m_vstrSubnetMask.empty())
        {
            if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrSubnetMask,
                                                c_szAfSubnetmask,
                                                pszAdapterName,
                                                FALSE))
            {
                fRet = FALSE;
            }
        }

        if (fRet)
        {
            IP_VALIDATION_ERR err = ValidateIp(pAdapter);

            if (err != ERR_NONE)
            {
                fRet = FALSE;

                switch (err)
                {
                case ERR_INCORRECT_IP:
                    WriteTcpSetupErrorLog(IDS_TCP_AF_INVALID_SUBNET, pszAdapterName);
                    break;
                case ERR_NO_IP:
                    WriteTcpSetupErrorLog(IDS_TCP_AF_NO_IP, pszAdapterName);
                    break;
                case ERR_NO_SUBNET:
                    WriteTcpSetupErrorLog(IDS_TCP_AF_NO_SUBNET, pszAdapterName);
                    break;
                default:
                    //$REVIEW: we don't want to check other invalid settings at this time
                    // because the setting maybe is valid in NT4, for example: uncontiguous
                    // subnet mask
                    fRet = TRUE;
                    break;
                }
            }
        }

        if (!fRet)
        {
            //Invalid IP settings in the answer file. Set IP settings back to default
            pAdapter->m_fEnableDhcp = TRUE;
            FreeCollectionAndItem(pAdapter->m_vstrIpAddresses);
            FreeCollectionAndItem(pAdapter->m_vstrSubnetMask);
        }
    }

    if (!pAdapter->m_strDnsDomain.empty())
    {
        DNS_STATUS status;

        status = DnsValidateName(pAdapter->m_strDnsDomain.c_str(), DnsNameDomain);

        if (ERROR_INVALID_NAME == status ||
            DNS_ERROR_INVALID_NAME_CHAR == status)
        {
            WriteTcpSetupErrorLog(IDS_TCP_AF_INVALID_DNS_DOMAIN, pszAdapterName);
            pAdapter->m_strDnsDomain = c_szEmpty;

            fRet = FALSE;
        }
    }

    if (!pAdapter->m_vstrDnsServerList.empty())
    {
        if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrDnsServerList,
                                            c_szAfDnsServerSearchOrder,
                                            pszAdapterName))
        {
            FreeCollectionAndItem(pAdapter->m_vstrDnsServerList);
            fRet = FALSE;
        }
    }

    if (!pAdapter->m_vstrDefaultGateway.empty())
    {
        if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrDefaultGateway,
                                            c_szAfDefaultGateway,
                                            pszAdapterName))
        {
            FreeCollectionAndItem(pAdapter->m_vstrDefaultGateway);
            fRet = FALSE;
        }
    }

    if (!pAdapter->m_vstrWinsServerList.empty())
    {
        if (!FValidateIpFieldsFromAnswerFile(pAdapter->m_vstrWinsServerList,
                                            c_szAfWinsServerList,
                                            pszAdapterName))
        {
            FreeCollectionAndItem(pAdapter->m_vstrWinsServerList);
            fRet = FALSE;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpconst.h ===
//
// T C P C O N S T . H
//
// Constants used in tcpipcfg
//

#pragma once

#define TCH_QUESTION_MARK   L'?'
#define CH_DOT              L'.'
#define BACK_SLASH          L'\\'

static const WCHAR  c_chListSeparator  = L',';

// 0 - 9999 seconds
#define MIN_HOPSTHRESHOLD       0
#define MAX_HOPSTHRESHOLD       16
#define DEF_HOPSTHRESHOLD       4

#define MIN_SECSTHRESHOLD       0
#define MAX_SECSTHRESHOLD       0x270F
#define DEF_SECSTHRESHOLD       4

// Tcpip
#define RGAS_TCPIP_PARAM_INTERFACES     L"Tcpip\\Parameters\\Interfaces\\"

// Tcpip global Parameter
#define RGAS_NAMESERVER         L"NameServer"
#define RGAS_HOSTNAME           L"Hostname"
#define RGAS_NVHOSTNAME         L"NV Hostname"

#define RGAS_DOMAIN             L"Domain"
#define RGAS_SEARCHLIST         L"SearchList"
#define RGAS_SECURITY_ENABLE    L"EnableSecurityFilters"

// Tcpip adapter Parameter
#define RGAS_LLINTERFACE        L"LLInterface"
#define RGAS_IPCONFIG           L"IpConfig"
#define RGAS_IPINTERFACES       L"IpInterfaces"
#define RGAS_NUMINTERFACES      L"NumInterfaces"

// Tcpip interface Parameter

// NTEContextLists, used to preserve the value when a WAN card becomes
// support multiple interfaces
#define RGAS_NTECONTEXTLIST        L"NTEContextList"

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_ENABLE_DHCP        L"EnableDHCP"

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_DEFAULTGATEWAY     L"DefaultGateway"
#define RGAS_DEFAULTGATEWAYMETRIC   L"DefaultGatewayMetric"

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_IPADDRESS          L"IPAddress"

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_SUBNETMASK         L"SubnetMask"

#define RGAS_FILTERING_TCP       L"TCPAllowedPorts"
#define RGAS_FILTERING_UDP       L"UDPAllowedPorts"
#define RGAS_FILTERING_IP        L"RawIPAllowedProtocols"

#define RGAS_USEZEROBROADCAST   L"UseZeroBroadcast"

// Wins global parameter
#define RGAS_ENABLE_DNS         L"EnableDNS"
#define RGAS_ENABLE_LMHOSTS     L"EnableLMHOSTS"

// Wins interface parameter
#define RGAS_PRIMARY_WINS       L"NameServer"
#define RGAS_SECONDARY_WINS     L"NameServerBackup"

// DHCP options
#define RGAS_REG_LOCATION                   L"RegLocation"

// Notify RAS team to update Load\SaveTcpipInfo if this changes
#define RGAS_DHCP_IPADDRESS                 L"DhcpIPAddress"

// Notify RAS team to update Load\SaveTcpipInfo if this changes
#define RGAS_DHCP_SUBNETMASK                L"DhcpSubnetMask"

#define RGAS_DHCP_OPTIONS                   L"System\\CurrentControlSet\\Services\\DHCP\\Parameters\\Options"
#define RGAS_DHCP_OPTION_IPADDRESS          L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpIPAddress"
#define RGAS_DHCP_OPTION_SUBNETMASK         L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpSubnetMask"
#define RGAS_DHCP_OPTION_NAMESERVERBACKUP   L"System\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\?\\DhcpNameServerBackup"

// LmHosts
#define RGAS_LMHOSTS_PATH          L"\\drivers\\etc\\lmhosts"
#define RGAS_LMHOSTS_PATH_BACKUP   L"\\drivers\\etc\\lmhosts.bak"

// Components
const WCHAR c_szTcpip[] =       L"Tcpip";
const WCHAR c_szNetBt[] =       L"NetBT";
const WCHAR c_szDhcp[] =        L"DHCP";

// Constant strings
extern const WCHAR c_szEmpty[];

const WCHAR     c_mszNull[] = L"\0";
const WCHAR     c_szDisableFiltering[] = L"0";
const WCHAR     c_szAdaptersRegKey[] = L"Adapters";

// Notify RAS team to update Load\SaveTcpipInfo
const WCHAR     c_szInterfacesRegKey[] = L"Interfaces";

// Notify RAS team to update Load\SaveTcpipInfo
const WCHAR     c_szTcpip_[] = L"Tcpip_";

// LLInterface values ( for ARP modules )
const WCHAR     c_szWanArp[] = L"WANARP";
const WCHAR     c_szAtmArp[] = L"ATMARPC";
const WCHAR     c_sz1394Arp[] = L"ARP1394";
const WCHAR     c_szAtmarpc[] = L"AtmArpC";

// Other constants
const int c_cchRemoveCharatersFromEditOrAddButton = 3;

const WCHAR c_szBASE_SUBNET_MASK_1[] =  L"255.0.0.0";
const WCHAR c_szBASE_SUBNET_MASK_2[] =  L"255.255.0.0";
const WCHAR c_szBASE_SUBNET_MASK_3[] =  L"255.255.255.0";

const BYTE  SUBNET_RANGE_1_MAX   =   127;
const BYTE  SUBNET_RANGE_2_MAX   =   191;
const BYTE  SUBNET_RANGE_3_MAX   =   223;

// Default range for IP address fields
const int c_iIpLow =0;
const int c_iIpHigh = 255;
const int c_iEmptyIpField = -1;

// IP address field range
const int c_iIPADDR_FIELD_1_LOW = 1;
const int c_iIPADDR_FIELD_1_HIGH = 223;

// IP loopback address
const int c_iIPADDR_FIELD_1_LOOPBACK = 127;

// Ip address length
const int IP_LIMIT  = 32;

const WCHAR c_szItoa[] = L"%d";

// ATM ARP client parameters
// Configurable parameters
const WCHAR c_szREG_ARPServerList[] = L"ARPServerList";
const WCHAR c_szREG_MARServerList[] = L"MARServerList";
const WCHAR c_szREG_MTU[] = L"MTU";
const WCHAR c_szREG_PVCOnly[] = L"PVCOnly";

const WCHAR c_szDefaultAtmArpServer[] = L"4700790001020000000000000000A03E00000200";
const WCHAR c_szDefaultAtmMarServer[] = L"4700790001020000000000000000A03E00000200";
const DWORD c_dwDefaultAtmMTU = 9180;

// Static parameters
const WCHAR c_szREG_SapSelector[] = L"SapSelector";
const WCHAR c_szREG_AddressResolutionTimeout[] = L"AddressResolutionTimeout";
const WCHAR c_szREG_ARPEntryAgingTimeout[] = L"ARPEntryAgingTimeout";
const WCHAR c_szREG_InARPWaitTimeout[] = L"InARPWaitTimeout";
const WCHAR c_szREG_MaxRegistrationAttempts[] = L"MaxRegistrationAttempts";
const WCHAR c_szREG_MaxResolutionAttempts[] = L"MaxResolutionAttempts";
const WCHAR c_szREG_MinWaitAfterNak[] = L"MinWaitAfterNak";
const WCHAR c_szREG_ServerConnectInterval[] = L"ServerConnectInterval";
const WCHAR c_szREG_ServerRefreshTimeout[] = L"ServerRefreshTimeout";
const WCHAR c_szREG_ServerRegistrationTimeout[] = L"ServerRegistrationTimeout";
const WCHAR c_szREG_DefaultVcAgingTimeout[] = L"DefaultVcAgingTimeout";
const WCHAR c_szREG_MARSConnectInterval[] = L"MARSConnectInterval";
const WCHAR c_szREG_MARSRegistrationTimeout[] = L"MARSRegistrationTimeout";
const WCHAR c_szREG_JoinTimeout[] = L"JoinTimeout";
const WCHAR c_szREG_LeaveTimeout[] = L"LeaveTimeout";
const WCHAR c_szREG_MaxDelayBetweenMULTIs[] = L"MaxDelayBetweenMULTIs";

const DWORD c_dwSapSelector= 1;
const DWORD c_dwAddressResolutionTimeout= 3;
const DWORD c_dwARPEntryAgingTimeout= 900;
const DWORD c_dwInARPWaitTimeout= 5;
const DWORD c_dwMaxRegistrationAttempts= 5;
const DWORD c_dwMaxResolutionAttempts= 4;
const DWORD c_dwMinWaitAfterNak= 10;
const DWORD c_dwServerConnectInterval= 5;
const DWORD c_dwServerRefreshTimeout= 900;
const DWORD c_dwServerRegistrationTimeout= 3;
const DWORD c_dwDefaultVcAgingTimeout= 60;
const DWORD c_dwMARSConnectInterval= 5;
const DWORD c_dwMARSRegistrationTimeout= 3;
const DWORD c_dwJoinTimeout= 10;
const DWORD c_dwLeaveTimeout= 10;
const DWORD c_dwMaxDelayBetweenMULTIs= 10;

// Reg value
const WCHAR  c_szIpEnableRouter[] = L"IPEnableRouter";
const WCHAR  c_szPerformRouterDiscovery[] =  L"PerformRouterDiscovery";
const WCHAR  c_szInterfaceMetric[] = L"InterfaceMetric";

//(nsun) added to support unattended install for RRAS (global settings)
const WCHAR c_szEnableICMPRedirect[] = L"EnableICMPRedirect";
const WCHAR c_szPerformRouterDiscoveryDefault[] = L"PerformRouterDiscoveryDefault";
const WCHAR c_szDeadGWDetectDefault[] = L"DeadGWDetectDefault";
const WCHAR c_szDontAddDefaultGatewayDefault[] = L"DontAddDefaultGatewayDefault";

//(nsun) added to support unattended install for RRAS (per interface settings)
const WCHAR c_szDeadGWDetect[] = L"EnableDeadGWDetect";
const WCHAR c_szDontAddDefaultGateway[] = L"DontAddDefaultGateway";


const WCHAR  c_szSearchList[] = L"SearchList";
const WCHAR  c_szUseDomainNameDevolution[] = L"UseDomainNameDevolution";
const WCHAR  c_szSvcDnsServer[] = L"DNS";

// Notify RAS team to update Load\SaveTcpipInfo
#define RGAS_NETBT_NAMESERVERLIST   L"NameServerList"
#define RGAS_NETBT_NETBIOSOPTIONS   L"NetbiosOptions"

// Dhcp parameter key
const WCHAR c_szDhcpParam[] = L"SYSTEM\\CurrentControlSet\\Services\\Dhcp\\Parameters";

const WCHAR c_szRegServices[] = L"SYSTEM\\CurrentControlSet\\Services";
const WCHAR c_szRegParamsTcpip[] = L"\\Parameters\\Tcpip";

// ServiceProvider key
static const WCHAR c_szProviderOrderVal[]      = L"ProviderOrder";
static const WCHAR c_szSrvProvOrderKey[]       = L"System\\CurrentControlSet\\Control\\ServiceProvider\\Order";

// IsRasFakeGuid
static const WCHAR c_szIsRasFakeAdapter[] = L"IsRasFakeAdapter";
static const DWORD c_dwIsRasFakeAdapter = 0x01;

static const WCHAR c_szRasFakeAdapterDesc[] = L"Ras connection";

const WCHAR c_szREG_UseRemoteGateway[] = L"UseRemoteGateway";
const WCHAR c_szREG_UseIPHeaderCompression[] = L"UseIPHeaderCompression";
const WCHAR c_szREG_FrameSize[] = L"UseIPHeaderCompression";


// Tcpip options
const int c_iIpFilter = 0;


const DWORD c_dwUnsetNetbios   =0x0;
const DWORD c_dwEnableNetbios  =0x01;
const DWORD c_dwDisableNetbios =0x02;

// Ras connection: frame size
const WCHAR c_szFrameSize1500[] = L"1500";
const WCHAR c_szFrameSize1006[] = L"1006";

const DWORD c_dwFrameSize1500 = 1500;
const DWORD c_dwFrameSize1006 = 1006;

//IPSec is removed from connection UI	
// Constants for Ipsec policy
/*
const WCHAR c_szIpsecNoPol[] = L"IPSEC_NOPOL";
const WCHAR c_szIpsecUnset[] = L"IPSEC_UNSET";
const WCHAR c_szIpsecDefPol[]= L"IPSEC_DEFAULT_POLICIES";
*/

// Constants for metric
#define MAX_GATEWAY             5
#define MAX_METRIC_DIGITS       4       //maximum number of digits for metric
#define MAX_METRIC    9999

// Constants for identifiers in option list of REMOTE_IPINFO
const WCHAR c_chOptionSeparator = L';';
const WCHAR c_szIfMetric[] = L"IfMetric=";
const WCHAR c_szDefGw[] = L"DefGw=";
const WCHAR c_szGwMetric[] = L"GwMetric=";
const WCHAR c_szDNS[] = L"DNS=";
const WCHAR c_szWINS[] = L"WINS=";
const WCHAR c_szDynamicUpdate[] = L"DynamicUpdate=";
const WCHAR c_szNameRegistration[] = L"NameRegistration=";
const WCHAR c_szNoPopupsInPnp[] = L"NoPopupsInPnp=";

const DWORD c_dwDefaultMetricOfGateway = 0;  //default metric value for a gateway

// Multiple LAN configuration reg values
const WCHAR c_szActiveConfigurations[] = L"ActiveConfigurations";
const WCHAR c_szAlternate[] = L"Alternate_";
const WCHAR c_szConfigOptions[] = L"Options";
const WCHAR c_szDhcpConfigurations[] = L"SYSTEM\\CurrentControlSet\\Services\\Dhcp\\Configurations";

const DWORD c_dwDefaultIfMetric = 0; //default interface metric (auto metric)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcperror.h ===
#pragma once
#include "tcpip.h"

typedef enum _IP_VALIDATION_ERR
{
	ERR_NONE = 0,
	ERR_NO_IP,
	ERR_NO_SUBNET,
	ERR_UNCONTIGUOUS_SUBNET,
	ERR_HOST_ALL0,
	ERR_HOST_ALL1,
	ERR_SUBNET_ALL0,
	ERR_INCORRECT_IP
} IP_VALIDATION_ERR;

IP_VALIDATION_ERR IsValidIpandSubnet(PCWSTR szIp, PCWSTR szSubnet);
IP_VALIDATION_ERR ValidateIp(ADAPTER_INFO * const pvcardAdapterInfo);
int CheckForDuplicates(const VCARD * pvcardAdapterInfo, ADAPTER_INFO * pAdapterInfo, tstring& strIp);
BOOL FHasDuplicateIp(ADAPTER_INFO * pAdapterInfo);
BOOL FIsValidIpFields(PCWSTR szIp, BOOL fIsIpAddr = TRUE);
UINT GetIPValidationErrorMessageID(IP_VALIDATION_ERR err);
BOOL FIpAndGatewayInSameSubNet(PCWSTR szIp, PCWSTR szMask, PCWSTR szGateway);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcperror.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P E R R O R . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "tcperror.h"
#include "tcputil.h"
#include "tcpconst.h"
#include "resource.h"

IP_VALIDATION_ERR IsValidIpandSubnet(PCWSTR szIp, PCWSTR szSubnet)
{
    IP_VALIDATION_ERR ret = ERR_NONE;

    DWORD dwAddr = IPStringToDword(szIp);
    DWORD dwMask = IPStringToDword(szSubnet);

    //The host ID cannot contain all 1's
    if ((dwMask | dwAddr) == 0xFFFFFFFF)
    {
        return ERR_HOST_ALL1;
    }

    if (((~dwMask) & dwAddr) == 0)
    {
        return ERR_HOST_ALL0;
    }

    if ((dwMask & dwAddr) == 0)
    {
        return ERR_SUBNET_ALL0;
    }


    DWORD ardwNetID[4];
    DWORD ardwIp[4];
    DWORD ardwMask[4];

    GetNodeNum(szIp, ardwIp);
    GetNodeNum(szSubnet, ardwMask);



    INT nFirstByte = ardwIp[0] & 0xFF ;

    // setup Net ID
    ardwNetID[0] = ardwIp[0] & ardwMask[0] & 0xFF;
    ardwNetID[1] = ardwIp[1] & ardwMask[1] & 0xFF;
    ardwNetID[2] = ardwIp[2] & ardwMask[2] & 0xFF;
    ardwNetID[3] = ardwIp[3] & ardwMask[3] & 0xFF;

    // setup Host ID
    DWORD ardwHostID[4];

    ardwHostID[0] = ardwIp[0] & (~(ardwMask[0]) & 0xFF);
    ardwHostID[1] = ardwIp[1] & (~(ardwMask[1]) & 0xFF);
    ardwHostID[2] = ardwIp[2] & (~(ardwMask[2]) & 0xFF);
    ardwHostID[3] = ardwIp[3] & (~(ardwMask[3]) & 0xFF);

    // check each case
    if( ((nFirstByte & 0xF0) == 0xE0)  || // Class D
        ((nFirstByte & 0xF0) == 0xF0)  || // Class E
        (ardwNetID[0] == 127) ||          // NetID cannot be 127...
        ((ardwNetID[0] == 0) &&           // netid cannot be 0.0.0.0
         (ardwNetID[1] == 0) &&
         (ardwNetID[2] == 0) &&
         (ardwNetID[3] == 0)) ||
        // netid cannot be equal to sub-net mask
        ((ardwNetID[0] == ardwMask[0]) &&
         (ardwNetID[1] == ardwMask[1]) &&
         (ardwNetID[2] == ardwMask[2]) &&
         (ardwNetID[3] == ardwMask[3])) ||
        // hostid cannot be 255.255.255.255
        ((ardwHostID[0] == 0xFF) &&
         (ardwHostID[1] == 0xFF) &&
         (ardwHostID[2] == 0xFF) &&
         (ardwHostID[3] == 0xFF)) ||
        // test for all 255
        ((ardwIp[0] == 0xFF) &&
         (ardwIp[1] == 0xFF) &&
         (ardwIp[2] == 0xFF) &&
         (ardwIp[3] == 0xFF)))
    {
        ret = ERR_INCORRECT_IP;
    }

    return ret;
}


// return IP_VALIDATION_ERR

IP_VALIDATION_ERR ValidateIp(ADAPTER_INFO * const pAdapterInfo)
{
    IP_VALIDATION_ERR result = ERR_NONE;
    IP_VALIDATION_ERR tmp = ERR_NONE;
    
    Assert(pAdapterInfo != NULL);

    // if enable DHCP is false;
    if (!pAdapterInfo->m_fEnableDhcp)
    {
        DWORD dwIpCount = pAdapterInfo->m_vstrIpAddresses.size();
        DWORD dwSubnetCount = pAdapterInfo->m_vstrSubnetMask.size();

        // check the first pair of IP and subnet
        VSTR_ITER iterIpBegin = pAdapterInfo->m_vstrIpAddresses.begin();
        VSTR_ITER iterIpEnd = pAdapterInfo->m_vstrIpAddresses.end();
        VSTR_ITER iterIp = iterIpBegin;

        VSTR_ITER iterSubnetMaskBegin = pAdapterInfo->m_vstrSubnetMask.begin();
        VSTR_ITER iterSubnetMaskEnd = pAdapterInfo->m_vstrSubnetMask.end();
        VSTR_ITER iterSubnetMask = iterSubnetMaskBegin;

        BOOL fSwap = FALSE;

        // If ip address and subnet are both empty
        if((iterIp == iterIpEnd) && (iterSubnetMask == iterSubnetMaskEnd))
        {
            result = ERR_NO_IP;
        }
        else if (dwIpCount < dwSubnetCount)
        {
            //ensure count of IP is the same as count of subnet
            result = ERR_NO_IP;
        }
        else if (dwIpCount > dwSubnetCount)
        {
            result = ERR_NO_SUBNET;
        }
        else
        {
            for( ;
                 iterIp != iterIpEnd || iterSubnetMask != iterSubnetMaskEnd ;
                 ++iterIp, ++iterSubnetMask)
            {
                Assert(iterIp != iterIpEnd);
                if (iterIp == iterIpEnd)
                {
                    result = ERR_NO_IP;
                    break;
                }

                Assert(iterSubnetMask != iterSubnetMaskEnd);
                if (iterSubnetMask == iterSubnetMaskEnd)
                {
                    result = ERR_NO_SUBNET;
                    break;
                }

                if(**iterIp == L"" && !fSwap)
                {
                    result = ERR_NO_IP;
                    fSwap = TRUE;
                }
                else if(**iterSubnetMask == L"" && !fSwap)
                {
                    result = ERR_NO_SUBNET;
                    fSwap = TRUE;
                }
                else if(!IsContiguousSubnet((*iterSubnetMask)->c_str()))
                {
                    result = ERR_UNCONTIGUOUS_SUBNET;
                    fSwap = TRUE;
                }
                else if(ERR_NONE != (tmp = IsValidIpandSubnet((*iterIp)->c_str(), (*iterSubnetMask)->c_str())) && !fSwap)
                {
                    result = tmp;
                    fSwap = TRUE;
                }
                

                if(fSwap)
                {
                    tstring * pstrTmp;

                    pstrTmp = *iterIp;
                    *iterIp = *iterIpBegin;
                    *iterIpBegin = pstrTmp;

                    pstrTmp = *iterSubnetMask;
                    *iterSubnetMask = *iterSubnetMaskBegin;
                    *iterSubnetMaskBegin = pstrTmp;

                    break;
                }
            }
        }
    }

    return result;
}

// return >=0   : the adapter that has the duplicate address
// return -1    : all is ok

// Check from duplicate IP address between the adapter in pAdapterInfo and
// any different, enabled, LAN adapters in the pvcardAdapterInfo list
int CheckForDuplicates(const VCARD * pvcardAdapterInfo,
                       ADAPTER_INFO * pAdapterInfo,
                       tstring& strIp)
{
    int nResult = -1;

    Assert(pvcardAdapterInfo != NULL);
    Assert(pAdapterInfo != NULL);
    Assert(!pAdapterInfo->m_fEnableDhcp);

    for(size_t i = 0; ((i < pvcardAdapterInfo->size()) && (nResult == -1)) ; ++i)
    {
        VSTR_ITER iterCompareIpBegin;
        VSTR_ITER iterCompareIpEnd;

        if ((*pvcardAdapterInfo)[i]->m_guidInstanceId ==
            pAdapterInfo->m_guidInstanceId)
        {
            // same adapter
            continue;
        }
        else
        {
            // different adapter

            // Skip the following:
            // 1) disabled adapter
            // 2) ndiswan adapter
            // 3) Dhcp enabled adapter
            // 4) RAS Fake adapters
            if(((*pvcardAdapterInfo)[i]->m_BindingState != BINDING_ENABLE) ||
               ((*pvcardAdapterInfo)[i]->m_fIsWanAdapter) ||
               ((*pvcardAdapterInfo)[i]->m_fEnableDhcp) ||
               ((*pvcardAdapterInfo)[i]->m_fIsRasFakeAdapter))
                continue;

            iterCompareIpBegin = (*pvcardAdapterInfo)[i]->m_vstrIpAddresses.begin();
            iterCompareIpEnd = (*pvcardAdapterInfo)[i]->m_vstrIpAddresses.end();
        }

        VSTR_ITER iterCompareIp = iterCompareIpBegin;

        for ( ; iterCompareIp != iterCompareIpEnd; ++iterCompareIp)
        {
            if(**iterCompareIp == strIp) // if duplicate IP address found
            {
                nResult = i;
                break;

                /*
                nCompareCount++;
                if (nCompareCount >= 1)
                {
                    nResult = i;

                    tstring * pstrTmp;

                    // swap the Current Compared IP and Subnet Mask with the
                    // first IP and first subnetmask that are duplicates

                    pstrTmp = *iterIp;
                    *iterIp = *iterIpBegin;
                    *iterIpBegin = pstrTmp;

                    pstrTmp = *iterSubnetMask;
                    *iterSubnetMask = *iterSubnetMaskBegin;
                    *iterSubnetMaskBegin = pstrTmp;

                    break;
                }
                */
            }
        }
    }

    return nResult;
}

BOOL FHasDuplicateIp(ADAPTER_INFO * pAdapterInfo)
{
    Assert(pAdapterInfo);
    Assert(!pAdapterInfo->m_fEnableDhcp);

    BOOL fDup = FALSE;

    VSTR_ITER iterIpBegin = pAdapterInfo->m_vstrIpAddresses.begin();
    VSTR_ITER iterIpEnd = pAdapterInfo->m_vstrIpAddresses.end();

    VSTR_ITER iterIp = iterIpBegin;

    for( ; ((iterIp != iterIpEnd) && (!fDup)) ; ++iterIp)
    {
        // check only IP addresses one by one
        VSTR_ITER iterCompareIpBegin = iterIp+1;
        VSTR_ITER iterCompareIpEnd = pAdapterInfo->m_vstrIpAddresses.end();

        VSTR_ITER iterCompareIp = iterCompareIpBegin;

        for ( ; iterCompareIp != iterCompareIpEnd; ++iterCompareIp)
        {
            if(**iterCompareIp == **iterIp) // if duplicate IP address found
            {
                fDup = TRUE;
                break;
            }
        }
    }
    return fDup;
}

//Check if the IP and the Gateway are in the same subnet
BOOL FIpAndGatewayInSameSubNet(
                PCWSTR szIp,
                PCWSTR szMask,
                PCWSTR szGateway
                )
{
    Assert(szIp);
    Assert(szMask);
    Assert(szGateway);

    BOOL fRet = TRUE;
    DWORD dwIp = IPStringToDword(szIp);
    DWORD dwMask = IPStringToDword(szMask);
    DWORD dwGateway = IPStringToDword(szGateway);

    DWORD dwNetID = dwIp & dwMask;
    DWORD dwGwNetID = dwGateway & dwMask;

    return (dwNetID == dwGwNetID);
}

//Check if all the fields of the IP address are valid
//Arguments: szIp       the IP address
//           fIsIpAddr  whether the szIp is IP address (otherwise, it should be subnet mask)
//                      if szIp is IP address, it's first field should be between 1 and 223, 
//                       and cannot be 127 (loopback address)
BOOL FIsValidIpFields(PCWSTR szIp, BOOL fIsIpAddr)
{
    BOOL fRet = TRUE;

    DWORD ardwIp[4];
    GetNodeNum(szIp, ardwIp);

    // if the address is IP, there are some special rules for its first field
    if (fIsIpAddr && (ardwIp[0] < c_iIPADDR_FIELD_1_LOW || ardwIp[0] > c_iIPADDR_FIELD_1_HIGH ||
        ardwIp[0] == c_iIPADDR_FIELD_1_LOOPBACK))
    {
        fRet = FALSE;
    }
    else
    {
        //if the address is IP, then we have already validate the first field. Otherwise, we need
        // valid the first field here.
        for (INT i = (fIsIpAddr) ? 1 : 0; i < 4; i++)
        {
#pragma warning(push)
#pragma warning(disable:4296)
            if (ardwIp[i] < (DWORD)c_iIpLow || ardwIp[i] > c_iIpHigh)
            {
                fRet = FALSE;
                break;
            }
#pragma warning(pop)
        }
    }

    return fRet;
}

//Get the resource ID of the error message based on the IP validation err
UINT GetIPValidationErrorMessageID(IP_VALIDATION_ERR err)
{
    UINT uID = 0;
    switch(err)
    {
    case ERR_NONE:
        uID = 0;
        break;
    case ERR_HOST_ALL0:
        uID = IDS_INVALID_HOST_ALL_0;
        break;
    case ERR_HOST_ALL1:
        uID = IDS_INVALID_HOST_ALL_1;
        break;
    case ERR_SUBNET_ALL0:
        uID = IDS_INVALID_SUBNET_ALL_0;
        break;
    case ERR_INCORRECT_IP:
        uID = IDS_INCORRECT_IPADDRESS;
        break;
    case ERR_NO_IP:
        uID = IDS_INVALID_NO_IP;
        break;
    case ERR_NO_SUBNET:
        uID = IDS_INVALID_NOSUBNET;
        break;
    case ERR_UNCONTIGUOUS_SUBNET:
        uID = IDS_ERROR_UNCONTIGUOUS_SUBNET;
        break;
    default:
        uID = IDS_INCORRECT_IPADDRESS;
        break;
    }

    return uID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpip.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P . H
//
//  Contents:   Tcpip config memory structure definitions
//
//  Notes:
//
//  Author:     tongl 13 Nov, 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "ncstring.h"

#define ZERO_ADDRESS    L"0.0.0.0"
#define FF_ADDRESS      L"255.0.0.0"

typedef vector<tstring *>       VSTR;
typedef VSTR::iterator          VSTR_ITER;
typedef VSTR::const_iterator    VSTR_CONST_ITER;

//(08/18/98 nsun): for multiple interfaces of WAN adapters
typedef vector<GUID>            IFACECOL;   // interface collection
typedef IFACECOL::iterator      IFACEITER;  // interface iterator

struct HANDLES
{
    HWND    m_hList;
    HWND    m_hAdd;
    HWND    m_hEdit;
    HWND    m_hRemove;
    HWND    m_hUp;
    HWND    m_hDown;
};

//
// ADAPTER_INFO data strucut:
// contains adapter specific info for Tcpip
//

enum BindingState
{
    BINDING_ENABLE,
    BINDING_DISABLE,
    BINDING_UNSET
};

enum ConnectionType
{
    CONNECTION_LAN,
    CONNECTION_RAS_PPP,
    CONNECTION_RAS_SLIP,
    CONNECTION_RAS_VPN,
    CONNECTION_UNSET
};

struct BACKUP_CFG_INFO
{
    tstring m_strIpAddr;
    tstring m_strSubnetMask;
    tstring m_strDefGw;
    tstring m_strPreferredDns;
    tstring m_strAlternateDns;
    tstring m_strPreferredWins;
    tstring m_strAlternateWins;
    BOOL m_fAutoNet;
};

struct ADAPTER_INFO
{
private:
    ADAPTER_INFO(const& ADAPTER_INFO); // do not allow others to use!

public:
    ADAPTER_INFO() {}
    ~ADAPTER_INFO();

    ADAPTER_INFO &  operator=(const ADAPTER_INFO & info);  // copy operator
    HRESULT         HrSetDefaults(const GUID* pguid,
                                  PCWSTR szNetCardDescription,
                                  PCWSTR szNetCardBindName,
                                  PCWSTR szNetCardTcpipBindPath);
    void ResetOldValues();

public:
    //There is no Pnp for the backup config info
    BACKUP_CFG_INFO m_BackupInfo;

    // If the netcard has been unbound from NCPA (or anywhere else)
    BindingState    m_BindingState;

    // Remember the initial bind state of the adapter
    BindingState    m_InitialBindingState;

    // Inst Guid of net card ( we get the guid to identify cards from answer file )
    // tstring m_strServiceName;
    GUID    m_guidInstanceId;

    // Bindname of the net card, such as El59x1{inst guid}
    tstring m_strBindName;

    // Bind path name from Tcpip's linkage\Bind key to the adapter
    tstring m_strTcpipBindPath;

    // Bind path name from NetBt's linkage key to the adapter
    tstring m_strNetBtBindPath;

    // User viewable net card description
    tstring m_strDescription;

    tstring m_strDnsDomain;         // DNS -> Domain name
    tstring m_strOldDnsDomain;

    VSTR    m_vstrIpAddresses;      // IP Address
    VSTR    m_vstrOldIpAddresses;

    VSTR    m_vstrSubnetMask;       // SubnetMask
    VSTR    m_vstrOldSubnetMask;

    VSTR    m_vstrDefaultGateway;   // Default Gateways
    VSTR    m_vstrOldDefaultGateway;

    VSTR    m_vstrDefaultGatewayMetric;   // Default gateway metrics
    VSTR    m_vstrOldDefaultGatewayMetric;

    VSTR    m_vstrDnsServerList;    // DNS -> DNS server Search Order list
    VSTR    m_vstrOldDnsServerList;

    VSTR    m_vstrWinsServerList;   // WINS -> WINS server Serach Order list
    VSTR    m_vstrOldWinsServerList;

    // $REVIEW (tongl 9/6/98)Filter information (Added per bugs #109161, #216559)
    VSTR    m_vstrTcpFilterList;    // Options -> Filterng -> TCP Ports
    VSTR    m_vstrOldTcpFilterList;

    VSTR    m_vstrUdpFilterList;    // Options -> Filterng -> UDP Ports
    VSTR    m_vstrOldUdpFilterList;

    VSTR    m_vstrIpFilterList;     // Options -> Filterng -> IP Protocols
    VSTR    m_vstrOldIpFilterList;

    // ATMARP client configurable parameters ( all per adapter based )
    VSTR    m_vstrARPServerList;     // list of ARP server addresses
    VSTR    m_vstrOldARPServerList;

    VSTR    m_vstrMARServerList;     // list of MAR server addresses
    VSTR    m_vstrOldMARServerList;

    DWORD   m_dwMTU;                 // Maximum Transmission Unit
    DWORD   m_dwOldMTU;

    DWORD   m_dwInterfaceMetric;     // metric for interface-local routes
    DWORD   m_dwOldInterfaceMetric;

    DWORD   m_dwNetbiosOptions;     // (New, added inNT5 Beta2): Option to turn NetBt off
    DWORD   m_dwOldNetbiosOptions;

    // RAS connection specific parameters
    // No dynamic reconfig, so no need to remember old values
    DWORD   m_dwFrameSize;
    BOOL    m_fUseRemoteGateway : 1;
    BOOL    m_fUseIPHeaderCompression : 1;
    BOOL    m_fIsDemandDialInterface : 1;
    
    BOOL    m_fEnableDhcp : 1;        // DHCP Enable  -> Obtain an IP Address from a DHCP Server
    BOOL    m_fOldEnableDhcp : 1;

    BOOL    m_fDisableDynamicUpdate : 1;  // Disable Ip address dynamic update on DNS server
    BOOL    m_fOldDisableDynamicUpdate : 1;

    BOOL    m_fEnableNameRegistration : 1;
    BOOL    m_fOldEnableNameRegistration : 1;

    BOOL    m_fPVCOnly : 1;              // PVC only
    BOOL    m_fOldPVCOnly : 1;

    // Is this card only added from answerfile,
    // i.e. not on binding path to Tcpip yet
    BOOL    m_fIsFromAnswerFile : 1;

    // Is this an ATM card ?
    // ( ATM cards needs extra property page for ARP Client configuration)
    BOOL    m_fIsAtmAdapter : 1;

    // Is this a WanAdapter ?
    // ( Wan adapters only have static parameters and don't show in UI)
    BOOL    m_fIsWanAdapter : 1;


    // Is this a 1394 NET device?
    // (1394 devices currently do not need any special properties, 
    //  but they are associated with a specific arp module).
    BOOL   m_fIs1394Adapter : 1;


    // Is this an fake adapter that represents a RAS connection,
    // but is not an adapter and does not bind
    BOOL    m_fIsRasFakeAdapter : 1;

    // Is the card marked as for deletion
    BOOL    m_fDeleted : 1;

    // Has this card been newly added.  Valid only after calling
    // MarkNewlyAddedCards.
    // or Has the interfaces of the card been changed if it is a WAN adapter
    // Previously was m_fNewlyAdded
    BOOL    m_fNewlyChanged : 1;

    // (08/18/98 nsun) added for multiple interfaces of WAN adapters
    // m_IfaceIds: collection of interface IDs
    BOOL        m_fIsMultipleIfaceMode : 1;

    BOOL    m_fBackUpSettingChanged : 1;

    IFACECOL    m_IfaceIds;
};

typedef vector<ADAPTER_INFO *>  VCARD;


//
// GLOBAL_INFO - TCP/IP global information data structure.
struct GLOBAL_INFO
{
public:
    tstring m_strHostName;                  // DNS Host Name

    tstring m_strHostNameFromAnswerFile;    // DNS Host Name from the answerfile

    //IPSec is removed from connection UI   
    /*
    tstring m_strIpsecPol;                  // the ipsec local policy
    GUID    m_guidIpsecPol;
    */

    VSTR    m_vstrDnsSuffixList;            // DNS: domain search suffix list
    VSTR    m_vstrOldDnsSuffixList;

    BOOL    m_fEnableLmHosts : 1;           // WINS -> Enable LMHOSTS Lookup
    BOOL    m_fOldEnableLmHosts : 1;

    BOOL    m_fUseDomainNameDevolution : 1; // DNS: whether parent doamins should be searched
    BOOL    m_fOldUseDomainNameDevolution : 1;

    BOOL    m_fEnableRouter : 1;            // ROUTING -> Enable IP Forwarding

    // unattended install for RRAS
    BOOL    m_fEnableIcmpRedirect : 1;
    BOOL    m_fDeadGWDetectDefault : 1;
    BOOL    m_fDontAddDefaultGatewayDefault : 1;

    // $REVIEW (tongl 9/6/98)Filter information (Added per bugs #109161, #216559)
    BOOL    m_fEnableFiltering : 1;         // Options -> Filtering -> Enabled Filtering
    BOOL    m_fOldEnableFiltering : 1;

private:
    GLOBAL_INFO(const & GLOBAL_INFO); // no not allow others to use!

public:
    GLOBAL_INFO() {};
    ~GLOBAL_INFO();

    GLOBAL_INFO& operator=(GLOBAL_INFO& glb); // copy operator

    HRESULT HrSetDefaults();

    void    ResetOldValues();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcphelp.h ===
#define	IDH_CHK_ATM_PVCONLY	110000050
#define	IDH_CHK_USE_COMPRESSION	110000501
#define	IDH_CMB_FRAME_SIZE	110000502
//IPSec is removed from connection UI	
//#define	IDH_CMB_IPSEC_POLICY_LIST	110000452
#define	IDH_DNS_ADDR_REG	110000566
#define	IDH_DNS_CHANGE_SERVER	110000100
#define	IDH_DNS_CHANGE_SUFFIX	110000150
#define	IDH_DNS_DHCP	110000605
#define	IDH_DNS_DOMAIN	110000556
#define	IDH_DNS_FIXED	110000606
#define	IDH_DNS_NAME_REG	110000567
#define	IDH_DNS_PRIMARY	110000607
#define	IDH_DNS_SEARCH_DOMAIN	110000557
#define	IDH_DNS_SEARCH_PARENT_DOMAIN	110000558
#define	IDH_DNS_SECONDARY	110000608
#define	IDH_DNS_SERVER_ADD	110000553
#define	IDH_DNS_SERVER_DOWN	110000552
#define	IDH_DNS_SERVER_EDIT	110000554
#define	IDH_DNS_SERVER_LIST	110000550
#define	IDH_DNS_SERVER_REMOVE	110000555
#define	IDH_DNS_SERVER_UP	110000551
#define	IDH_DNS_SUFFIX_ADD	110000563
#define	IDH_DNS_SUFFIX_DOWN	110000562
#define	IDH_DNS_SUFFIX_EDIT	110000564
#define	IDH_DNS_SUFFIX_LIST	110000560
#define	IDH_DNS_SUFFIX_REMOVE	110000565
#define	IDH_DNS_SUFFIX_UP	110000561
#define	IDH_DNS_USE_SUFFIX_LIST	110000559
#define	IDH_EDT_ATM_Address	110000000
#define	IDH_EDT_ATM_MaxTU	110000063
//IPSec is removed from connection UI	
//#define	IDH_EDT_POLICY_DESC	110000453
#define	IDH_FILTERING_ADD_EDIT	110000250
#define	IDH_FILTERING_ENABLE	110000200
#define	IDH_FILTERING_FILTER_IP	110000211
#define	IDH_FILTERING_FILTER_IP_SEL	110000212
#define	IDH_FILTERING_FILTER_TCP	110000201
#define	IDH_FILTERING_FILTER_TCP_SEL	110000202
#define	IDH_FILTERING_FILTER_UDP	110000206
#define	IDH_FILTERING_FILTER_UDP_SEL	110000207
#define	IDH_FILTERING_IP	110000213
#define	IDH_FILTERING_IP_ADD	110000214
#define	IDH_FILTERING_IP_REMOVE	110000215
#define	IDH_FILTERING_TCP	110000203
#define	IDH_FILTERING_TCP_ADD	110000204
#define	IDH_FILTERING_TCP_REMOVE	110000205
#define	IDH_FILTERING_UDP	110000208
#define	IDH_FILTERING_UDP_ADD	110000209
#define	IDH_FILTERING_UDP_REMOVE	110000210
#define	IDH_IP_DHCP	110000600
#define	IDH_IP_FIXED	110000601
#define	IDH_IPADDR_ADDGATE	110000305
#define	IDH_IPADDR_ADDIP	110000301
#define	IDH_IPADDR_ADV_CHANGE_GATEWAY	110000350
#define	IDH_IPADDR_ADV_CHANGE_METRIC	110000351
#define	IDH_IPADDR_ADV_CHANGEIP_IP	110000400
#define	IDH_IPADDR_ADV_CHANGEIP_SUB	110000401
#define	IDH_IPADDR_ADVANCED	110000609
#define	IDH_IPADDR_ADVIP	110000300
#define	IDH_IPADDR_EDITGATE	110000306
#define	IDH_IPADDR_EDITIP	110000302
#define	IDH_IPADDR_GATE	110000304
#define	IDH_IPADDR_GATE_TCP	110000604
#define	IDH_IPADDR_IP	110000602
#define	IDH_IPADDR_METRIC	110000308
#define IDH_AUTO_METRIC 110000309
#define	IDH_IPADDR_REMOVEGATE	110000307
#define	IDH_IPADDR_REMOVEIP	110000303
#define	IDH_IPADDR_SUB	110000603
#define	IDH_LBX_ATM_ArpsAddrs	110000051
#define	IDH_LBX_ATM_MarsAddrs	110000057
#define	IDH_LVW_OPTIONS	110000700
#define	IDH_OPT_DESC	110000702
#define	IDH_OPT_PROPERTIES	110000701
#define	IDH_PSB_ATM_ArpsAdd	110000054
#define	IDH_PSB_ATM_ArpsDown	110000053
#define	IDH_PSB_ATM_ArpsEdt	110000055
#define	IDH_PSB_ATM_ArpsRmv	110000056
#define	IDH_PSB_ATM_ArpsUp	110000052
#define	IDH_PSB_ATM_MarsAdd	110000060
#define	IDH_PSB_ATM_MarsDown	110000059
#define	IDH_PSB_ATM_MarsEdt	110000061
#define	IDH_PSB_ATM_MarsRmv	110000062
#define	IDH_PSB_ATM_MarsUp	110000058
#define	IDH_RAD_DISABLE_NETBT	110000759
#define	IDH_RAD_ENABLE_NETBT	110000758
//IPSec is removed from connection UI	
//#define	IDH_RAD_IPSEC_CUSTOM	110000451
//#define	IDH_RAD_IPSEC_NOIPSEC	110000450
#define	IDH_RAD_UNSET_NETBT	110000760
#define	IDH_REMOTE_GATEWAY	110000500
#define	IDH_WINS_ADD	110000753
#define	IDH_WINS_CHANGE_SERVER	110000800
#define	IDH_WINS_DOWN	110000752
#define	IDH_WINS_EDIT	110000754
#define	IDH_WINS_LMHOST	110000757
#define	IDH_WINS_LOOKUP	110000756
#define	IDH_WINS_REMOVE	110000755
#define	IDH_WINS_SERVER_LIST	110000750
#define	IDH_WINS_UP	110000751

#define	IDH_AC_APIPA	110000850
#define	IDH_AC_USRCFG	110000851
#define	IDH_AC_IPADDR	110000852
#define	IDH_AC_SUBMASK	110000853
#define	IDH_AC_DG		110000854
#define	IDH_AC_DNS_PRE	110000855
#define	IDH_AC_DNS_ALT	110000856
#define	IDH_AC_WINS_PRE	110000857
#define	IDH_AC_WINS_ALT	110000858

const DWORD g_aHelpIDs_IDD_ATM_ADDR[]=
{
	IDC_EDT_ATM_Address,IDH_EDT_ATM_Address,
	0,0
};

const DWORD g_aHelpIDs_IDD_ATM_ARPC[]=
{
	IDC_PSB_ATM_MarsAdd,IDH_PSB_ATM_MarsAdd,
	IDC_EDT_ATM_MaxTU,IDH_EDT_ATM_MaxTU,
	IDC_PSB_ATM_MarsEdt,IDH_PSB_ATM_MarsEdt,
	IDC_PSB_ATM_MarsDown,IDH_PSB_ATM_MarsDown,
	IDC_PSB_ATM_MarsUp,IDH_PSB_ATM_MarsUp,
	IDC_LBX_ATM_MarsAddrs,IDH_LBX_ATM_MarsAddrs,
	IDC_PSB_ATM_ArpsEdt,IDH_PSB_ATM_ArpsEdt,
	IDC_PSB_ATM_ArpsAdd,IDH_PSB_ATM_ArpsAdd,
	IDC_PSB_ATM_ArpsDown,IDH_PSB_ATM_ArpsDown,
	IDC_PSB_ATM_MarsRmv,IDH_PSB_ATM_MarsRmv,
	IDC_PSB_ATM_ArpsUp,IDH_PSB_ATM_ArpsUp,
	IDC_LBX_ATM_ArpsAddrs,IDH_LBX_ATM_ArpsAddrs,
	IDC_CHK_ATM_PVCONLY,IDH_CHK_ATM_PVCONLY,
	IDC_PSB_ATM_ArpsRmv,IDH_PSB_ATM_ArpsRmv,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DNS_SERVER[]=
{
	IDC_DNS_CHANGE_SERVER,IDH_DNS_CHANGE_SERVER,
	0, 0
};

const DWORD g_aHelpIDs_IDD_DNS_SUFFIX[]=
{
	IDC_DNS_CHANGE_SUFFIX,IDH_DNS_CHANGE_SUFFIX,
	0, 0
};

const DWORD g_aHelpIDs_IDD_FILTER[]=
{
	IDC_FILTERING_FILTER_UDP,IDH_FILTERING_FILTER_UDP,
	IDC_FILTERING_IP_ADD,IDH_FILTERING_IP_ADD,
	IDC_FILTERING_IP,IDH_FILTERING_IP,
	IDC_FILTERING_FILTER_IP_SEL,IDH_FILTERING_FILTER_IP_SEL,
	IDC_FILTERING_FILTER_IP,IDH_FILTERING_FILTER_IP,
	IDC_FILTERING_UDP_REMOVE,IDH_FILTERING_UDP_REMOVE,
	IDC_FILTERING_UDP_ADD,IDH_FILTERING_UDP_ADD,
	IDC_FILTERING_IP_REMOVE,IDH_FILTERING_IP_REMOVE,
	IDC_FILTERING_TCP_REMOVE,IDH_FILTERING_TCP_REMOVE,
	IDC_FILTERING_TCP_ADD,IDH_FILTERING_TCP_ADD,
	IDC_FILTERING_TCP,IDH_FILTERING_TCP,
	IDC_FILTERING_FILTER_TCP_SEL,IDH_FILTERING_FILTER_TCP_SEL,
	IDC_FILTERING_FILTER_TCP,IDH_FILTERING_FILTER_TCP,
	IDC_FILTERING_ENABLE,IDH_FILTERING_ENABLE,
	IDC_FILTERING_FILTER_UDP_SEL,IDH_FILTERING_FILTER_UDP_SEL,
	IDC_FILTERING_UDP,IDH_FILTERING_UDP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_FILTER_ADD[]=
{
	IDC_FILTERING_TEXT, IDH_FILTERING_ADD_EDIT,
	IDC_FILTERING_ADD_EDIT,IDH_FILTERING_ADD_EDIT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPADDR_ADV[]=
{
	IDC_IPADDR_ADDIP,IDH_IPADDR_ADDIP,
    IDC_AUTO_METRIC, IDH_AUTO_METRIC,
	IDC_STATIC_IF_METRIC,IDH_IPADDR_METRIC,
	IDC_IPADDR_METRIC,IDH_IPADDR_METRIC,
	IDC_IPADDR_REMOVEGATE,IDH_IPADDR_REMOVEGATE,
	IDC_IPADDR_EDITGATE,IDH_IPADDR_EDITGATE,
	IDC_IPADDR_ADDGATE,IDH_IPADDR_ADDGATE,
	IDC_IPADDR_GATE,IDH_IPADDR_GATE,
	IDC_IPADDR_EDITIP,IDH_IPADDR_EDITIP,
	IDC_IPADDR_ADVIP,IDH_IPADDR_ADVIP,
	IDC_IPADDR_REMOVEIP,IDH_IPADDR_REMOVEIP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPADDR_ADV_CHANGEGATE[]=
{
	IDC_IPADDR_ADV_CHANGE_GATEWAY,IDH_IPADDR_ADV_CHANGE_GATEWAY,
	IDC_IPADDR_ADV_CHANGE_METRIC,IDH_IPADDR_ADV_CHANGE_METRIC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPADDR_ADV_CHANGEIP[]=
{
	IDC_IPADDR_ADV_CHANGEIP_IP,IDH_IPADDR_ADV_CHANGEIP_IP,
	IDC_IPADDR_ADV_CHANGEIP_SUB,IDH_IPADDR_ADV_CHANGEIP_SUB,
	0, 0
};

/* IP Security dialog is removed
const DWORD g_aHelpIDs_IDD_IPSEC[]=
{
	IDC_CMB_IPSEC_POLICY_LIST,IDH_CMB_IPSEC_POLICY_LIST,
	IDC_RAD_IPSEC_NOIPSEC,IDH_RAD_IPSEC_NOIPSEC,
	IDC_EDT_POLICY_DESC,IDH_EDT_POLICY_DESC,
	IDC_RAD_IPSEC_CUSTOM,IDH_RAD_IPSEC_CUSTOM,
	0, 0
};
*/

const DWORD g_aHelpIDs_IDD_OPT_RAS[]=
{
	IDC_REMOTE_GATEWAY,IDH_REMOTE_GATEWAY,
	IDC_CHK_USE_COMPRESSION,IDH_CHK_USE_COMPRESSION,
	IDC_STATIC_FRAME_SIZE,IDH_CMB_FRAME_SIZE,
	IDC_CMB_FRAME_SIZE,IDH_CMB_FRAME_SIZE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_DNS[]=
{
	IDC_DNS_SEARCH_DOMAIN,IDH_DNS_SEARCH_DOMAIN,
	IDC_DNS_ADDR_REG,IDH_DNS_ADDR_REG,
	IDC_DNS_SUFFIX_REMOVE,IDH_DNS_SUFFIX_REMOVE,
	IDC_DNS_SUFFIX_EDIT,IDH_DNS_SUFFIX_EDIT,
	IDC_DNS_SUFFIX_ADD,IDH_DNS_SUFFIX_ADD,
	IDC_DNS_SUFFIX_DOWN,IDH_DNS_SUFFIX_DOWN,
	IDC_DNS_SUFFIX_UP,IDH_DNS_SUFFIX_UP,
	IDC_DNS_SUFFIX_LIST,IDH_DNS_SUFFIX_LIST,
	IDC_DNS_SEARCH_PARENT_DOMAIN,IDH_DNS_SEARCH_PARENT_DOMAIN,
	IDC_DNS_NAME_REG,IDH_DNS_NAME_REG,
	IDC_DNS_DOMAIN_STATIC,IDH_DNS_DOMAIN,
	IDC_DNS_DOMAIN,IDH_DNS_DOMAIN,
	IDC_DNS_SERVER_REMOVE,IDH_DNS_SERVER_REMOVE,
	IDC_DNS_SERVER_EDIT,IDH_DNS_SERVER_EDIT,
	IDC_DNS_SERVER_ADD,IDH_DNS_SERVER_ADD,
	IDC_DNS_SERVER_DOWN,IDH_DNS_SERVER_DOWN,
	IDC_DNS_SERVER_UP,IDH_DNS_SERVER_UP,
	IDC_DNS_SERVER_LIST,IDH_DNS_SERVER_LIST,
	IDC_DNS_USE_SUFFIX_LIST,IDH_DNS_USE_SUFFIX_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_IPADDR[]=
{
	IDC_DNS_DHCP,IDH_DNS_DHCP,
	IDC_DNS_SECONDARY_TEXT,IDH_DNS_SECONDARY,
	IDC_DNS_SECONDARY,IDH_DNS_SECONDARY,
	IDC_IPADDR_ADVANCED,IDH_IPADDR_ADVANCED,
	IDC_DNS_PRIMARY_TEXT,IDH_DNS_PRIMARY,
	IDC_DNS_PRIMARY,IDH_DNS_PRIMARY,
	IDC_DNS_FIXED,IDH_DNS_FIXED,
	IDC_IPADDR_SUBTEXT,IDH_IPADDR_SUB,
	IDC_IPADDR_SUB,IDH_IPADDR_SUB,
	IDC_IPADDR_IPTEXT,IDH_IPADDR_IP,
	IDC_IPADDR_IP,IDH_IPADDR_IP,
	IDC_IP_DHCP,IDH_IP_DHCP,
	IDC_IPADDR_GATETEXT,IDH_IPADDR_GATE_TCP,
	IDC_IPADDR_GATE,IDH_IPADDR_GATE_TCP,
	IDC_IP_FIXED,IDH_IP_FIXED,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_IPADDR_RAS[]=
{
	IDC_DNS_DHCP,IDH_DNS_DHCP,
	IDC_DNS_SECONDARY_TEXT,IDH_DNS_SECONDARY,
	IDC_DNS_SECONDARY,IDH_DNS_SECONDARY,
	IDC_IPADDR_ADVANCED,IDH_IPADDR_ADVANCED,
	IDC_DNS_PRIMARY_TEXT,IDH_DNS_PRIMARY,
	IDC_DNS_PRIMARY,IDH_DNS_PRIMARY,
	IDC_DNS_FIXED,IDH_DNS_FIXED,
	IDC_IPADDR_IPTEXT,IDH_IPADDR_IP,
	IDC_IPADDR_IP,IDH_IPADDR_IP,
	IDC_IP_DHCP,IDH_IP_DHCP,
	IDC_IP_FIXED,IDH_IP_FIXED,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_OPTIONS[]=
{
	IDC_LVW_OPTIONS,IDH_LVW_OPTIONS,
	IDC_OPT_PROPERTIES,IDH_OPT_PROPERTIES,
	IDC_OPT_DESC,IDH_OPT_DESC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_TCP_WINS[]=
{
	IDC_WINS_UP,IDH_WINS_UP,
	IDC_STATIC_DEFALUT_NBT,IDH_RAD_UNSET_NETBT,
	IDC_RAD_UNSET_NETBT,IDH_RAD_UNSET_NETBT,
	IDC_RAD_DISABLE_NETBT,IDH_RAD_DISABLE_NETBT,
	IDC_RAD_ENABLE_NETBT,IDH_RAD_ENABLE_NETBT,
	IDC_WINS_LMHOST,IDH_WINS_LMHOST,
	IDC_WINS_LOOKUP,IDH_WINS_LOOKUP,
	IDC_WINS_REMOVE,IDH_WINS_REMOVE,
	IDC_WINS_EDIT,IDH_WINS_EDIT,
	IDC_WINS_DOWN,IDH_WINS_DOWN,
	IDC_WINS_SERVER_LIST,IDH_WINS_SERVER_LIST,
	IDC_WINS_ADD,IDH_WINS_ADD,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WINS_SERVER[]=
{
	IDC_WINS_CHANGE_SERVER,IDH_WINS_CHANGE_SERVER,
	0, 0
};

const DWORD g_aHelpIDS_IDD_BACK_UP[]=
{
    IDC_BKUP_RD_AUTO,IDH_AC_APIPA,
	IDC_BKUP_RD_USER,IDH_AC_USRCFG,
	IDC_BKUP_IPADDR_TEXT,IDH_AC_IPADDR,
	IDC_BKUP_IPADDR,IDH_AC_IPADDR,
	IDC_BKUP_SUBNET_TEXT,IDH_AC_SUBMASK,
	IDC_BKUP_SUBNET,IDH_AC_SUBMASK,
	IDC_BKUP_GATEWAY_TEXT,IDH_AC_DG,
	IDC_BKUP_GATEWAY,IDH_AC_DG,
	IDC_BKUP_PREF_DNS_TEXT,IDH_AC_DNS_PRE,
	IDC_BKUP_PREF_DNS,IDH_AC_DNS_PRE,
	IDC_BKUP_ALT_DNS_TEXT,IDH_AC_DNS_ALT,
	IDC_BKUP_ALT_DNS,IDH_AC_DNS_ALT,
	IDC_BKUP_WINS1_TEXT,IDH_AC_WINS_PRE,
	IDC_BKUP_WINS1,IDH_AC_WINS_PRE,
	IDC_WINS2_TEXT,IDH_AC_WINS_ALT,
	IDC_BKUP_WINS2,IDH_AC_WINS_ALT,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpfunc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P F U N C . C P P
//
//  Contents:   Various CTcpipcfg member functions that are not interface
//              methods
//
//  Notes:
//
//  Author:     tongl   1 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "tcpipobj.h"
#include "ncatlui.h"
#include "ncmisc.h"
#include "ncpnp.h"
#include "ncreg.h"
#include "ncstl.h"
#include "ncui.h"
#include "tcpconst.h"
#include "tcphelp.h"
#include "tcputil.h"
#include "dhcpcsdk.h"
#include "dlgaddr.h"
#include "atmcommon.h"
#include "regkysec.h"

#include "netconp.h"

#define _PNP_POWER_
#include "ntddip.h"
#undef _PNP_POWER_

#include <atmarpif.h>

// sigh... llinfo.h is needed by ddwanarp.h
#include <llinfo.h>
#include <ddwanarp.h>

extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szBiNdis1394[];
extern const WCHAR c_szBiNdisWanIp[];
extern const WCHAR c_szEmpty[];
extern const WCHAR c_szSvcDnscache[];

extern void CopyVstr(VSTR * vstrDest, const VSTR & vstrSrc);

typedef struct {
    PCWSTR  pszValueName;
    DWORD   dwType;
} ValueType;

const ValueType s_rgNt4Values[] = {
    {RGAS_ENABLE_DHCP, REG_DWORD},
    {RGAS_IPADDRESS, REG_MULTI_SZ},
    {RGAS_SUBNETMASK, REG_MULTI_SZ},
    {RGAS_DEFAULTGATEWAY, REG_MULTI_SZ}
};

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::PAdapterFromInstanceGuid
//
//  Purpose:    Search the adapter info array for an entry with a matching
//              instance guid.  Return a pointer to the ADAPTER_INFO if found.
//
//  Arguments:
//      pGuid [in] pointer to instance guid to search for
//
//  Returns:    Valid pointer if found, NULL if not.
//
//  Author:     shaunco   1 Oct 1998
//
//  Notes:
//
ADAPTER_INFO*
CTcpipcfg::PAdapterFromInstanceGuid (
    const GUID* pGuid)
{
    Assert (pGuid);

    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter++)
    {
        ADAPTER_INFO* pAdapter = *iterAdapter;

        if (pAdapter->m_guidInstanceId == *pGuid)
        {
            return pAdapter;
        }
    }
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::PAdapterFromNetcfgComponent
//
//  Purpose:    Search the adapter info array for an entry with an instance
//              guid matching that of the specified INetCfgComponent.
//              Return a pointer to the ADAPTER_INFO if found.
//
//  Arguments:
//      pncc [in] INetCfgComponent who's instance guid we are looking for.
//
//  Returns:    Valid pointer if found, NULL if not.
//
//  Author:     shaunco   1 Oct 1998
//
//  Notes:
//
ADAPTER_INFO*
CTcpipcfg::PAdapterFromNetcfgComponent (
    INetCfgComponent* pncc)
{
    Assert (pncc);

    HRESULT hr;
    GUID    guidAdapter;

    hr = pncc->GetInstanceGuid (&guidAdapter);
    if (SUCCEEDED(hr))
    {
        return PAdapterFromInstanceGuid (&guidAdapter);
    }
    return NULL;
}

// Called by CTcpipcfg::Initialize.
// We walk the binding path from tcpip and load to first memory state
// all netcards ( both physical cards and Wan adapters )
HRESULT CTcpipcfg::HrGetNetCards()
{
    HRESULT hr = S_OK;

    CIterNetCfgBindingPath      ncbpIter(m_pnccTcpip);
    INetCfgBindingPath *        pncbp;

    // Go through all binding paths in search of tcpip to netcard bindings
    while(SUCCEEDED(hr) && (hr = ncbpIter.HrNext(&pncbp)) == S_OK)
    {
        INetCfgComponent * pnccNetComponent;
        PWSTR pszInterfaceName;

        hr = HrGetLastComponentAndInterface(pncbp,
                                            &pnccNetComponent,
                                            &pszInterfaceName);
        if (SUCCEEDED(hr))
        {
            Assert(pnccNetComponent);

            // The last component should be of NET CLASS

            GUID    guidClass;
            hr = pnccNetComponent->GetClassGuid(&guidClass);
            if (SUCCEEDED(hr) && IsEqualGUID(guidClass, GUID_DEVCLASS_NET))
            {
                PWSTR pszNetCardTcpipBindPath;
                hr = pnccNetComponent->GetBindName(&pszNetCardTcpipBindPath);

                AssertSz(SUCCEEDED(hr),
                         "Net card on binding path with no bind path name!!");

                
                m_vstrBindOrder.push_back(new tstring(pszNetCardTcpipBindPath));

                hr = HrAddCard(pnccNetComponent,
                               pszNetCardTcpipBindPath,
                               pszInterfaceName);

                if (SUCCEEDED(hr))
                {
                    GUID    guidNetCard;
                    hr = pnccNetComponent->GetInstanceGuid(&guidNetCard);
                    if (SUCCEEDED(hr))
                    {
                        // Is the binding enabled?
                        hr = pncbp->IsEnabled();

                        // hr == S_OK if the card is enabled (ie: bound)
                        if (S_OK == hr)
                        {   // bind the card in our data strucutres
                            hr = HrBindCard(&guidNetCard, TRUE);
                        }
                        else if (S_FALSE == hr)
                        {
                            hr = HrUnBindCard(&guidNetCard, TRUE);
                        }
                    }
                }

                CoTaskMemFree(pszNetCardTcpipBindPath);
            }

            ReleaseObj(pnccNetComponent);
            CoTaskMemFree(pszInterfaceName);
        }

        ReleaseObj(pncbp);
    }

    if (S_FALSE == hr) // We just got to the end of the loop
        hr = S_OK;

    TraceError("CTcpipcfg::HrGetNetCards", hr);
    return hr;
}

BOOL CTcpipcfg::IsBindOrderChanged()
{
    HRESULT hr = S_OK;

    VSTR    vstrCurrentBindOrder;
    BOOL    fChanged = FALSE;
    
    hr = HrLoadBindingOrder(&vstrCurrentBindOrder);

    if (SUCCEEDED(hr))
    {
        fChanged = !fIsSameVstr(vstrCurrentBindOrder, m_vstrBindOrder);
        FreeCollectionAndItem(vstrCurrentBindOrder);
    }

    return fChanged;
}


HRESULT CTcpipcfg::HrLoadBindingOrder(VSTR *pvstrBindOrder)
{

    Assert(pvstrBindOrder);

    HRESULT                 hr = S_OK;

    CIterNetCfgBindingPath  ncbpIter(m_pnccTcpip);
    INetCfgBindingPath *    pncbp;
    INetCfgComponent *      pnccLast;

    while (SUCCEEDED(hr) && S_OK == (hr = ncbpIter.HrNext(&pncbp)))
    {
        hr = HrGetLastComponentAndInterface(pncbp, &pnccLast, NULL);

        if (SUCCEEDED(hr))
        {
            Assert(pnccLast);

            // The last component should be of NET CLASS
            GUID    guidClass;
            hr = pnccLast->GetClassGuid(&guidClass);
            if (SUCCEEDED(hr) && IsEqualGUID(guidClass, GUID_DEVCLASS_NET))
            {
                PWSTR pszNetCardTcpipBindPath;
                hr = pnccLast->GetBindName(&pszNetCardTcpipBindPath);

                AssertSz(SUCCEEDED(hr),
                         "Net card on binding path with no bind path name!!");

                if (SUCCEEDED(hr))
                {
                    pvstrBindOrder->push_back(new tstring(pszNetCardTcpipBindPath));
                    
                    CoTaskMemFree(pszNetCardTcpipBindPath);
                }
            }

            ReleaseObj(pnccLast);
        }

        ReleaseObj(pncbp);
    }


    if (S_FALSE == hr) // We just got to the end of the loop
    {
        hr = S_OK;
    }

    //if failed, clean up what we added
    if (FAILED(hr))
    {
        FreeCollectionAndItem(*pvstrBindOrder);
    }

    TraceError("CBindingsDlg::HrGetBindOrder", hr);
    return hr;
}

// Called by CTcpipcfg::CancelProperties and CTcpipcfg::ApplyProperties
// Release second memory state
void CTcpipcfg::ExitProperties()
{
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;
}


// Called by CTcpipcfg's destructor
// Release all memory states
void CTcpipcfg::FinalFree()
{
    FreeCollectionAndItem(m_vcardAdapterInfo);

    FreeCollectionAndItem(m_vstrBindOrder);

    delete m_pSecondMemoryAdapterInfo;

    delete m_ipaddr;

    DeleteObject(g_hiconUpArrow);
    DeleteObject(g_hiconDownArrow);

    ReleaseObj(m_pnc);
    ReleaseObj(m_pTcpipPrivate);
    ReleaseObj(m_pnccTcpip);
    ReleaseObj(m_pnccWins);

    // Just a safty check to make sure the context is released.
    AssertSz((m_pUnkContext == NULL), "Why is context not released ?");
    ReleaseObj(m_pUnkContext) ;
}

// Called by CTcpipcfg::HrSetupPropSheets
// Creates the second memory adapter info from the first
// memory structure
// Note: Bound cards only
HRESULT CTcpipcfg::HrLoadAdapterInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(&m_guidCurrentConnection);
    if (pAdapter)
    {
        // enabled LAN adapter or any RAS Fake adapter
        if ((pAdapter->m_BindingState == BINDING_ENABLE) ||
            pAdapter->m_fIsRasFakeAdapter)
        {
            m_pSecondMemoryAdapterInfo = new ADAPTER_INFO;
            if (NULL == m_pSecondMemoryAdapterInfo)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                *m_pSecondMemoryAdapterInfo = *pAdapter;
                hr = S_OK;
            }
        }
    }

    AssertSz((S_OK == hr), "Can not raise UI on a disabled or non-exist adapter !");
    TraceError("CTcpipcfg::HrLoadAdapterInfo", hr);
    return hr;
}

// Called by CTcpipcfg::ApplyProperties
// Saves the second memory state back into the first
HRESULT CTcpipcfg::HrSaveAdapterInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(
        &m_pSecondMemoryAdapterInfo->m_guidInstanceId);
    if (pAdapter)
    {
#ifdef DBG
        // The card can not get unbound while in tcpip's properties UI!
        if (!pAdapter->m_fIsRasFakeAdapter)
        {
            Assert(pAdapter->m_BindingState == BINDING_ENABLE);
            Assert(m_pSecondMemoryAdapterInfo->m_BindingState == BINDING_ENABLE);
        }
#endif
        *pAdapter = *m_pSecondMemoryAdapterInfo;
        hr = S_OK;

    }
    AssertSz((S_OK == hr),
             "Adapter in second memory not found in first memory!");

    TraceError("CTcpipcfg::HrSaveAdapterInfo", hr);
    return hr;
}

// Called by CTcpipcfg::MergePropPages
// Set the context in which the UI is brought up
HRESULT CTcpipcfg::HrSetConnectionContext()
{
    AssertSz(m_pUnkContext, "Invalid IUnknown pointer passed to CTcpipcfg::SetContext?");

    if (!m_pUnkContext)
    {
        return E_UNEXPECTED;
    }

    // Is this a lan connection ?
    GUID guidConn;
    INetLanConnectionUiInfo * pLanConnUiInfo;
    HRESULT hr = m_pUnkContext->QueryInterface( IID_INetLanConnectionUiInfo,
                            reinterpret_cast<PVOID *>(&pLanConnUiInfo));
    if (SUCCEEDED(hr))
    {
        // yes, lan connection
        m_ConnType = CONNECTION_LAN;

        hr = pLanConnUiInfo->GetDeviceGuid(&guidConn);

        ReleaseObj(pLanConnUiInfo);
    }
    else
    {
        INetRasConnectionIpUiInfo * pRasConnUiInfo;

        // Is this a wan connection ?
        hr = m_pUnkContext->QueryInterface(IID_INetRasConnectionIpUiInfo,
                               reinterpret_cast<PVOID *>(&pRasConnUiInfo));
        if (SUCCEEDED(hr))
        {
            // yes, RAS connection
            RASCON_IPUI info;
            if (SUCCEEDED(pRasConnUiInfo->GetUiInfo(&info)))
            {
                guidConn = info.guidConnection;

                //currently VPN connections only supports PPP frames, so
                //if RCUIF_VPN is set, RCUIF_PPP should also be there.
                //RCUIF_PPP and RCUIF_SLIP are mutually exclusive
                //m_ConnType is only used to show/hide the controls in the RAS
                //config UI. 
                if (info.dwFlags & RCUIF_VPN)
                {
                    m_ConnType = CONNECTION_RAS_VPN;
                }
                else
                {
                    if (info.dwFlags & RCUIF_PPP)
                    {
                        m_ConnType = CONNECTION_RAS_PPP;
                    }
                    else if (info.dwFlags & RCUIF_SLIP)
                    {
                        m_ConnType = CONNECTION_RAS_SLIP;
                    }
                }

                m_fRasNotAdmin = !!(info.dwFlags & RCUIF_NOT_ADMIN);

                AssertSz(((CONNECTION_RAS_PPP == m_ConnType)||
                        (CONNECTION_RAS_SLIP == m_ConnType) ||
                        (CONNECTION_RAS_VPN == m_ConnType)),
                         "RAS connection type unknown ?");

                UpdateRasAdapterInfo (info);
            }
        }

        ReleaseObj(pRasConnUiInfo);
    }

    if (SUCCEEDED(hr))
    {
        m_guidCurrentConnection = guidConn;
    }

    AssertSz(((CONNECTION_LAN == m_ConnType)||
              (CONNECTION_RAS_PPP == m_ConnType)||
              (CONNECTION_RAS_SLIP == m_ConnType)||
              (CONNECTION_RAS_VPN == m_ConnType)),
             "How come this is neither a LAN connection nor a RAS connection?");

    TraceError("CTcpipcfg::HrSetConnectionContext", hr);
    return hr;
}

// Called by CTcpipcfg::MergePropPages
// Allocate property pages
HRESULT CTcpipcfg::HrSetupPropSheets(HPROPSHEETPAGE ** pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;
    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    m_fSecondMemoryLmhostsFileReset = FALSE;
    m_fSecondMemoryModified = FALSE;

    //IPSec is removed from connection UI   
//    m_fSecondMemoryIpsecPolicySet = FALSE;


    // copy in memory state to tcpip dialog memory state
    // Copy global Info
    m_glbSecondMemoryGlobalInfo = m_glbGlobalInfo;

    // Copy adapter card specific info
    hr = HrLoadAdapterInfo();

    // If we have found the matching adapter
    if (SUCCEEDED(hr))
    {
        cPages = 1;

        delete m_ipaddr;
        m_ipaddr = new CTcpAddrPage(this, g_aHelpIDs_IDD_TCP_IPADDR);

        // Allocate a buffer large enough to hold the handles to all of our
        // property pages.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                                 * cPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto err;
        }

        cPages =0;

        Assert(m_ConnType != CONNECTION_UNSET);

        if (m_ConnType == CONNECTION_LAN)
            ahpsp[cPages++] = m_ipaddr->CreatePage(IDD_TCP_IPADDR, 0);
        else
            ahpsp[cPages++] = m_ipaddr->CreatePage(IDD_TCP_IPADDR_RAS, 0);

        *pahpsp = ahpsp;
        *pcPages = cPages;
    }
    else // if we don't have any bound cards, pop-up message box and don't show UI
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_TCP_TEXT, IDS_NO_BOUND_CARDS,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        AssertSz((0== *pcPages), "Invalid page number when no bound cards");
        AssertSz((NULL == *pahpsp), "Invalid page array pointer when no bound cards");
    }

err:

    TraceError("CTcpipcfg::HrSetupPropSheets", hr);
    return hr;
}

// Is there any bound card on the list of physical adapters
BOOL CTcpipcfg::FHasBoundCard()
{
    BOOL fRet = FALSE;

    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter++)
    {
        ADAPTER_INFO* pAdapter = *iterAdapter;

        if (pAdapter->m_BindingState == BINDING_ENABLE)
        {
            fRet = TRUE;
            break;
        }
    }

    return fRet;
}

// Called by CTcpipcfg::NotifyBindingPath
// Handle bind notification of a physical card
HRESULT CTcpipcfg::HrAdapterBindNotify(INetCfgComponent *pnccNetCard,
                                       DWORD dwChangeFlag,
                                       PCWSTR pszInterfaceName)
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    Assert(pnccNetCard);

    GUID guidNetCard;
    HRESULT hr = pnccNetCard->GetInstanceGuid(&guidNetCard);
    if (SUCCEEDED(hr))
    {
        if (dwChangeFlag & NCN_ADD)
        {
            PWSTR pszNetCardTcpipBindPath;
            hr = pnccNetCard->GetBindName(&pszNetCardTcpipBindPath);
            AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

            hr = HrAddCard(pnccNetCard,
                           pszNetCardTcpipBindPath,
                           pszInterfaceName);

            CoTaskMemFree(pszNetCardTcpipBindPath);
        }

        if (dwChangeFlag & NCN_ENABLE)
        {
            hr = HrBindCard(&guidNetCard);
        }

        if (dwChangeFlag & NCN_DISABLE)
        {
            hr = HrUnBindCard(&guidNetCard);
        }

        if (dwChangeFlag & NCN_REMOVE)
        {
            hr = HrDeleteCard(&guidNetCard);
        }

    }

    TraceError("CTcpipCfg::HrPhysicalCardBindNotify", hr);
    return hr;
}

// HrAddCard
// Adds a card to the list of cards installed in the system
// pnccNetCard               the netcard's GUID in string form
// szNetCardTcpipBindPath    the bind path name from Tcpip to the card
// strInterfaceName          the upper interface name of the card
HRESULT CTcpipcfg::HrAddCard(INetCfgComponent * pnccNetCard,
                             PCWSTR pszCardTcpipBindPath,
                             PCWSTR pszInterfaceName)
{
    GUID guidNetCard;
    HRESULT hr = pnccNetCard->GetInstanceGuid(&guidNetCard);
    if (SUCCEEDED(hr))
    {
        // Get card bind name
        PWSTR pszNetCardBindName;
        hr = pnccNetCard->GetBindName(&pszNetCardBindName);

        AssertSz(SUCCEEDED(hr),
                 "Net card on binding path with no bind name!!");

        // Get card description
        // This is only needed for physical cards
        //
        BOOL fFreeDescription = TRUE;
        PWSTR pszDescription;

        // If we can't get a description then give it a default one
        if (FAILED(pnccNetCard->GetDisplayName(&pszDescription)))
        {
            pszDescription = const_cast<PWSTR>(
                                SzLoadIds(IDS_UNKNOWN_NETWORK_CARD));
            fFreeDescription = FALSE;
        }
        Assert (pszDescription);

        ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(&guidNetCard);
        if (!pAdapter)
        {
            pAdapter = new ADAPTER_INFO;

            if (NULL == pAdapter)
            {
                return E_OUTOFMEMORY;
            }

            hr = pAdapter->HrSetDefaults(&guidNetCard,
                                         pszDescription,
                                         pszNetCardBindName,
                                         pszCardTcpipBindPath);
            if (SUCCEEDED(hr))
            {
                // add new card to our data structures and initialize it to default values
                m_vcardAdapterInfo.push_back(pAdapter);
            }
            else
            {
                delete pAdapter;
                pAdapter = NULL;
            }
        }
        else
        {
            // Set the flag that this card is now on the binding path
            pAdapter->m_fIsFromAnswerFile = FALSE;
            pAdapter->m_fDeleted = FALSE;

            // reset binding state
            pAdapter->m_BindingState = BINDING_UNSET;
            pAdapter->m_InitialBindingState = BINDING_UNSET;

            // Set CardDescription, BindName and BindPathName
            pAdapter->m_strDescription = pszDescription;
            pAdapter->m_strBindName = pszNetCardBindName;
            pAdapter->m_strTcpipBindPath = pszCardTcpipBindPath;

            pAdapter->m_strNetBtBindPath = c_szTcpip_;
            pAdapter->m_strNetBtBindPath += pAdapter->m_strTcpipBindPath;
        }

        if (SUCCEEDED(hr))
        {
            Assert(pAdapter);

            // set flags if ATM card or Wan adapter
            if (0 == lstrcmpW(pszInterfaceName, c_szBiNdisAtm))
            {
                pAdapter->m_fIsAtmAdapter = TRUE;
            }
            else if (0 == lstrcmpW(pszInterfaceName, c_szBiNdisWanIp))
            {
                pAdapter->m_fIsWanAdapter = TRUE;
            }
            else if (0 == lstrcmpW(pszInterfaceName, c_szBiNdis1394))
            {
                pAdapter->m_fIs1394Adapter = TRUE;
            }
        }

        if (fFreeDescription)
        {
            CoTaskMemFree(pszDescription);
        }
        CoTaskMemFree(pszNetCardBindName);
    }

    TraceError("CTcpipcfg::HrAddCard", hr);
    return hr;
}

//HrBindCard    sets the state of a netcard in the list of installed
//              netcards to BOUND
//
// Note: fInitialize is only TRUE when this is called from Initialize,
// the default is FALSE.
//
HRESULT CTcpipcfg::HrBindCard(const GUID* pguid, BOOL fInitialize)
{
    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguid);
    if (pAdapter)
    {
        AssertSz(pAdapter->m_BindingState != BINDING_ENABLE,
                 "the same netcard was bound twice to TCPIP");

        // Set binding state
        pAdapter->m_BindingState = BINDING_ENABLE;

        if (fInitialize)
            pAdapter->m_InitialBindingState = BINDING_ENABLE;
    }
    else
    {
        AssertSz(FALSE, "Attempt to bind a card which wasn't installed");
    }
    return S_OK;
}

//HrUnBindCard  sets the state of a netcard in the list of installed
//              netcards to UNBOUND
//
// Note: fInitialize is only TRUE when this is called from Initialize,
// the default is FALSE.
//
HRESULT CTcpipcfg::HrUnBindCard(const GUID* pguid, BOOL fInitialize)
{
    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguid);
    if (pAdapter)
    {
        AssertSz(pAdapter->m_BindingState != BINDING_DISABLE,
                 "attempt to unbind an unbound card");

        // Set binding state to disable
        pAdapter->m_BindingState = BINDING_DISABLE;

        if (fInitialize)
            pAdapter->m_InitialBindingState = BINDING_DISABLE;
    }
    else
    {
        AssertSz(FALSE, "Attempt to unbind a card which wasn't installed");
    }
    return S_OK;
}

// HrDeleteCard
// Deletes a card from the list of cards installed in the system
//
HRESULT CTcpipcfg::HrDeleteCard(const GUID* pguid)
{
    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguid);
    if (pAdapter)
    {
       pAdapter->m_fDeleted = TRUE;
    }
    else
    {
        AssertSz(FALSE, "A delete attempt was made on a card which doesn't exist");
    }
    return S_OK;
}

//Function to get the list of cards which have been added to the system
//hkeyTcpipParam       "Services\Tcpip\Parameters"
HRESULT CTcpipcfg::MarkNewlyAddedCards(const HKEY hkeyTcpipParam)
{

    //(08/19/98 nsun) changed from Tcpip\Parameters\Interfaces to Tcpip\Parameters\Adapters key
    // to support multiple interfaces
    HKEY hkeyAdapters;
    HRESULT hr = HrRegOpenKeyEx(hkeyTcpipParam,
                        c_szAdaptersRegKey,
                        KEY_READ, &hkeyAdapters);
    if (SUCCEEDED(hr))
    {
        VSTR vstrAdaptersInRegistry;
        Assert(vstrAdaptersInRegistry.empty());

        // Get the list of keys
        hr = HrLoadSubkeysFromRegistry(hkeyAdapters,
                                       &vstrAdaptersInRegistry);
        if (SUCCEEDED(hr))
        {
            //Go through the list of cards we currently have
            for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
            {
                ADAPTER_INFO* pAdapter = *iterAdapter;

                BOOL fAdded = TRUE;

                // If we have a card in the list which isn't in registry
                // then we add that card to the list of added cards
                for(VSTR_CONST_ITER iter = vstrAdaptersInRegistry.begin();
                    iter != vstrAdaptersInRegistry.end() ; ++iter)
                {
                    if (lstrcmpiW((**iter).c_str(), pAdapter->m_strBindName.c_str()) == 0)
                    {
                        fAdded = FALSE;
                        break;
                    }
                }

                // if the card is new then mark it
                if (fAdded)
                {
                    pAdapter->m_fNewlyChanged = TRUE;
                }
            }

            FreeCollectionAndItem(vstrAdaptersInRegistry);
        }
        RegCloseKey(hkeyAdapters);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        TraceTag(ttidTcpip, "No existing card found.");
        hr = S_OK;
    }

    TraceError("CTcpipcfg::MarkNewlyAddedCards", hr);
    return hr;
}

//+------------------------------------------------------------------------------
//
//  Function:   HrLoadSettings, HrLoadTcpipRegistry, HrLoadWinsRegistry
//
//              HrSaveSettings, HrSaveTcpipRegistry, HrSaveTcpipNdisWanRegistry,
//              HrSetMisc
//
//  Purpose:    Functions to Load/Set registry settings and other system info
//              during Initialize and Apply time
//
// Author:      tongl 5/5/97
//-------------------------------------------------------------------------------

// Called by CTcpipcfg::Initialize
// Load registry settings for a list of net cards
HRESULT CTcpipcfg::HrLoadSettings()
{
    HKEY hkey = NULL;

    // Load Tcpip's parameters
    HRESULT hrTcpip = S_OK;
    hrTcpip = m_pnccTcpip->OpenParamKey(&hkey);
    if (hrTcpip == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hrTcpip = S_OK;
    else if (SUCCEEDED(hrTcpip))
    {
        Assert(hkey);
        hrTcpip = HrLoadTcpipRegistry(hkey);
        RegCloseKey(hkey);
    }
    else
        Assert(!hkey);

    // Load NetBt's parameters
    HRESULT hrWins = S_OK;

    if (m_pnccWins)
    {   // If Wins is not installed don't get WINS information
        hkey = NULL;
        hrWins = m_pnccWins->OpenParamKey(&hkey);
        if (hrWins == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            hrWins = S_OK;
        else if (SUCCEEDED(hrWins))
        {
            Assert(hkey);
            hrWins = HrLoadWinsRegistry(hkey);
            RegCloseKey(hkey);
        }
        else
            Assert(!hkey);
    }

    HRESULT hr = S_OK;
    hr = SUCCEEDED(hrTcpip)         ? hr : hrTcpip;
    hr = SUCCEEDED(hrWins)          ? hr : hrWins;

    TraceError("CTcpipcfg::HrLoadSettings", hr);
    return hr;
}


// Called by CTcpipcfg::HrLoadSettings
// Loads all information under the Services\Tcpip\Parameters registry key
//
// const HKEY hkeyTcpipParam : Handle to Services\Tcpip\Parameters
HRESULT CTcpipcfg::HrLoadTcpipRegistry(const HKEY hkeyTcpipParam)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    Assert(hkeyTcpipParam);

    // Load global parameters

    // DNS server
    // For bug #147476: in NT5 upgrades, somehow the
    // global DNS server list is deleted, but not until after initialize exits
    // So I'm reading in the value here if it exists

    // DNS server list moved from global to per adapter
    hrTmp = HrRegQueryString(hkeyTcpipParam, RGAS_NAMESERVER, &m_strDnsServerList);

    tstring strDnsSuffixList;
    if FAILED(hrTmp = HrRegQueryString(hkeyTcpipParam, c_szSearchList,
                                       &strDnsSuffixList))
    {
        TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
        TraceTag(ttidTcpip, "Failed on loading SearchList, hr: %x", hr);
        hr = S_OK;
    }
    else
    {
        ConvertStringToColString(strDnsSuffixList.c_str(),
                                 c_chListSeparator,
                                 m_glbGlobalInfo.m_vstrDnsSuffixList);
    }

    m_glbGlobalInfo.m_fUseDomainNameDevolution =
                            FRegQueryBool(hkeyTcpipParam,
                                        c_szUseDomainNameDevolution,
                                        m_glbGlobalInfo.m_fUseDomainNameDevolution);

    m_glbGlobalInfo.m_fEnableRouter = FRegQueryBool(hkeyTcpipParam, c_szIpEnableRouter,
                                  m_glbGlobalInfo.m_fEnableRouter);

    //(nsun 11/02/98) gloabl RRAS settings
    m_glbGlobalInfo.m_fEnableIcmpRedirect = FRegQueryBool(hkeyTcpipParam,
                                    c_szEnableICMPRedirect,
                                    m_glbGlobalInfo.m_fEnableIcmpRedirect);

    //PerformRouterDiscoveryDefault was removed to fix bug 405636

    m_glbGlobalInfo.m_fDeadGWDetectDefault = FRegQueryBool(hkeyTcpipParam,
                                    c_szDeadGWDetectDefault,
                                    m_glbGlobalInfo.m_fDeadGWDetectDefault);

    m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault = FRegQueryBool(hkeyTcpipParam,
                                    c_szDontAddDefaultGatewayDefault,
                                    m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault);

    m_glbGlobalInfo.m_fEnableFiltering = FRegQueryBool(hkeyTcpipParam,
                                    RGAS_SECURITY_ENABLE,
                                    m_glbGlobalInfo.m_fEnableFiltering);

    // Save old values
    m_glbGlobalInfo.ResetOldValues();

    // (08/18/98 nsun) read multiple interface settings for WAN adapters
    // Open CCS\Services\Tcpip\Parameters\Adapters key
    HKEY hkeyAdapters;
    hr = HrRegOpenKeyEx(hkeyTcpipParam, c_szAdaptersRegKey, KEY_READ,
                        &hkeyAdapters);
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) // no adapters key
        hr = S_OK;
    else if (SUCCEEDED(hr))
    {
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end() && SUCCEEDED(hr) ;
            iterAdapter ++)
        {
            //multiple interface only valid for WAN adapters
            if (!((*iterAdapter)->m_fIsWanAdapter))
                continue;

            ADAPTER_INFO * pAdapter = *iterAdapter;
            HKEY hkeyAdapterParam;

            hr = HrRegOpenKeyEx(hkeyAdapters,
                                pAdapter->m_strBindName.c_str(),
                                KEY_READ,
                                &hkeyAdapterParam);

            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                 Assert("No registry settings for a WAN adapter on the "
                    "bind path?!");

                 TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
                 TraceTag(ttidTcpip, "No registry settings for a WAN adapter "
                    "on the bind path, set to defaults");
                 // We just use the default values
                 hr = S_OK;
            }
            else if (SUCCEEDED(hr))
            {
                TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
                TraceTag(ttidTcpip, "Loading multiple interface parameters "
                    "for Adapter '%S'", pAdapter->m_strBindName.c_str());

                DWORD   dwNumInterfaces;
                hr = HrRegQueryDword(hkeyAdapterParam,
                                    RGAS_NUMINTERFACES,
                                    &dwNumInterfaces);

                if (FAILED(hr))
                {
                    // the Wan adapter is NOT in mode of supporting multiple
                    // interfaces
                    TraceTag(ttidTcpip, "No mutliple interface for the WAN "
                        "adapter '%S'", pAdapter->m_strBindName.c_str());

                    pAdapter->m_fIsMultipleIfaceMode = FALSE;
                    hr = S_OK;
                }
                else
                {
                    pAdapter->m_fIsMultipleIfaceMode = TRUE;

                    // the WAN adapter supports multiple interface but not
                    // interface is defined yet
                    //
                    if (0 != dwNumInterfaces)
                    {
                        GUID* aguidIds;
                        DWORD cb;

                        hr = HrRegQueryBinaryWithAlloc(hkeyAdapterParam,
                                                      RGAS_IPINTERFACES,
                                                      (LPBYTE*)&aguidIds,
                                                      &cb);
                        if (FAILED(hr))
                        {
                            AssertSz(FALSE, "NumInterfaces and IpInterfaces "
                                "values conflicts");
                            // the Wan adapter is NOT in mode of supporting
                            // multiple interfaces
                            //
                            TraceTag(ttidTcpip, "NumInterfaces and IpInterfaces "
                                "values conflicts for the WAN adapter '%S'",
                                pAdapter->m_strBindName.c_str());

                            hr = S_OK;
                        }
                        else if (NULL != aguidIds)
                        {
                            dwNumInterfaces = cb / sizeof(GUID);

                            for(DWORD i = 0; i < dwNumInterfaces; i++)
                            {
                                pAdapter->m_IfaceIds.push_back(aguidIds[i]);
                            }

                            MemFree(aguidIds);
                        }
                    }
                }

                RegCloseKey(hkeyAdapterParam);
            }
        }
        RegCloseKey(hkeyAdapters);
    }

    // Get per adapter parameters
    // Open CCS\Services\Tcpip\Parameters\Interfaces key
    HKEY    hkeyInterfaces;
    hr = HrRegOpenKeyEx(hkeyTcpipParam, c_szInterfacesRegKey, KEY_READ,
                        &hkeyInterfaces);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) //no adapter interfaces
        hr = S_OK;
    else if (SUCCEEDED(hr))
    {
        // Get all the subkeys currently in registry
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end() && SUCCEEDED(hr) ;
            iterAdapter ++)
        {
            ADAPTER_INFO * pAdapter = *iterAdapter;

            if (pAdapter->m_fIsWanAdapter)
            {
                continue;
            }

            HKEY hkeyInterfaceParam;
            // Open CCS\Services\Tcpip\Parameters\Interfaces\<card bind path> key
            hr = HrRegOpenKeyEx(hkeyInterfaces,
                                pAdapter->m_strTcpipBindPath.c_str(),
                                KEY_READ,
                                &hkeyInterfaceParam);

            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                Assert("No registry settings for a card on the bind path?!");

                TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
                TraceTag(ttidTcpip, "No registry settings for a card on the bind path, set to defaults");
                // We just use the default values
                hr = S_OK;
            }
            else if (SUCCEEDED(hr))
            {
                TraceTag(ttidTcpip, "CTcpipcfg::HrLoadTcpipRegistry");
                TraceTag(ttidTcpip, "Loading parameters for Interface '%S'",
                    pAdapter->m_strTcpipBindPath.c_str());

                pAdapter->m_fEnableDhcp = FRegQueryBool(hkeyInterfaceParam,
                                              RGAS_ENABLE_DHCP,
                                              pAdapter->m_fEnableDhcp);

                // Get ip address
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_IPADDRESS,
                                                   &(pAdapter->m_vstrIpAddresses))))
                {
                    TraceTag(ttidTcpip, "Failed on loading IpAddress, hr: %x", hr);
                    hr = S_OK;
                }

                // Set subnet mask information
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_SUBNETMASK,
                                                   &(pAdapter->m_vstrSubnetMask))))
                {
                    TraceTag(ttidTcpip, "Failed on loading SubnetMask, hr: %x", hr);
                    hr = S_OK;
                }

                // Set default gateway
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_DEFAULTGATEWAY,
                                                   &(pAdapter->m_vstrDefaultGateway))))
                {
                    TraceTag(ttidTcpip, "Failed on loading Default Gateway, hr: %x", hr);
                    hr = S_OK;
                }

                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                    RGAS_DEFAULTGATEWAYMETRIC,
                                    &(pAdapter->m_vstrDefaultGatewayMetric))))
                {
                    TraceTag(ttidTcpip, "Failed on Loading Default Gateway Metric, hr: %x", hr);
                    hr = S_OK;
                }

                // Dns domain
                if (FAILED(hr = HrRegQueryString(hkeyInterfaceParam,
                                                RGAS_DOMAIN,
                                                &(pAdapter->m_strDnsDomain))))
                {
                    TraceTag(ttidTcpip, "Failed on loading DnsDomain, hr: %x", hr);
                    hr = S_OK;
                }

                // Dns ip address dynamic update
                pAdapter->m_fDisableDynamicUpdate = !DnsIsDynamicRegistrationEnabled(
                                                (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());

                // adapter Dns domain name registration
                pAdapter->m_fEnableNameRegistration = DnsIsAdapterDomainNameRegistrationEnabled(
                                                (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());

                // Dns server search list
                tstring strDnsServerList;
                if (FAILED(hr = HrRegQueryString(hkeyInterfaceParam,
                                                RGAS_NAMESERVER,
                                                &strDnsServerList)))
                {
                    TraceTag(ttidTcpip, "Failed on loading Dns NameServer list, hr: %x", hr);
                    hr = S_OK;
                }
                else
                {
                    ConvertStringToColString(strDnsServerList.c_str(),
                                             c_chListSeparator,
                                             pAdapter->m_vstrDnsServerList);

                }

                // Interface metric
                if FAILED(hr = HrRegQueryDword(hkeyInterfaceParam,
                                              c_szInterfaceMetric,
                                              &(pAdapter->m_dwInterfaceMetric)))
                {
                    TraceTag(ttidTcpip, "Failed on loading InterfaceMetric, hr: %x", hr);
                    hr = S_OK;
                }

                // TCP port filter
                VSTR vstrTcpFilterList;
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_FILTERING_TCP,
                                                   &vstrTcpFilterList)))
                {
                    TraceTag(ttidTcpip, "Failed on loading TCP filter list, hr: %x", hr);
                    hr = S_OK;
                }
                else
                {
                    CopyVstr(&pAdapter->m_vstrTcpFilterList, vstrTcpFilterList);
                    FreeCollectionAndItem(vstrTcpFilterList);
                }

                // UDP port filter
                VSTR vstrUdpFilterList;
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_FILTERING_UDP,
                                                   &vstrUdpFilterList)))
                {
                    TraceTag(ttidTcpip, "Failed on loading UDP filter list, hr: %x", hr);
                    hr = S_OK;
                }
                else
                {
                    CopyVstr(&pAdapter->m_vstrUdpFilterList, vstrUdpFilterList);
                    FreeCollectionAndItem(vstrUdpFilterList);
                }

                // IP port filter
                VSTR vstrIpFilterList;
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                   RGAS_FILTERING_IP,
                                                   &vstrIpFilterList)))
                {
                    TraceTag(ttidTcpip, "Failed on loading IP filter list, hr: %x", hr);
                    hr = S_OK;
                }
                else
                {
                    CopyVstr(&pAdapter->m_vstrIpFilterList, vstrIpFilterList);
                    FreeCollectionAndItem(vstrIpFilterList);
                }

                if (FAILED(HrLoadBackupTcpSettings(hkeyInterfaceParam, 
                                                   pAdapter)))
                {
                    TraceTag(ttidTcpip, "Failed on loading Backup IP settings, hr: %x", hr);
                    hr = S_OK;
                }

                // ATM ARP client configurable parameters
                if (pAdapter->m_fIsAtmAdapter)
                {
                    HKEY hkeyAtmarpc = NULL;

                    // Open the Atmarpc subkey
                    hr = HrRegOpenKeyEx(hkeyInterfaceParam,
                                        c_szAtmarpc,
                                        KEY_READ,
                                        &hkeyAtmarpc);

                    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                    {
                        AssertSz(FALSE,"No atmarpc subkey for an atm adapter on the bind path?!");

                        TraceTag(ttidTcpip, "Failed on opening atmarpc subkey, defaults will be used, hr: %x", hr);
                        hr = S_OK;
                    }
                    else if (SUCCEEDED(hr))
                    {
                        // ARP server address list
                        if (FAILED(hr = HrRegQueryColString(hkeyAtmarpc,
                                                           c_szREG_ARPServerList,
                                                           &(pAdapter->m_vstrARPServerList))))
                        {
                            TraceTag(ttidTcpip, "Failed on loading ARPServerList, hr: %x", hr);
                            hr = S_OK;
                        }

                        // MAR server address list
                        if (FAILED(hr = HrRegQueryColString(hkeyAtmarpc,
                                                           c_szREG_MARServerList,
                                                           &(pAdapter->m_vstrMARServerList))))
                        {
                            TraceTag(ttidTcpip, "Failed on loading MARServerList, hr: %x", hr);
                            hr = S_OK;
                        }

                        // Max Transmit Unit
                        if (FAILED(hr = HrRegQueryDword(hkeyAtmarpc,
                                                       c_szREG_MTU,
                                                       &(pAdapter->m_dwMTU))))
                        {
                            TraceTag(ttidTcpip, "Failed on loading MTU, hr: %x", hr);
                            hr = S_OK;
                        }

                        // PVC Only
                        pAdapter->m_fPVCOnly = FRegQueryBool(hkeyAtmarpc,
                                                       c_szREG_PVCOnly,
                                                       pAdapter->m_fPVCOnly);

                        RegCloseKey(hkeyAtmarpc);
                    }
                }

                (*iterAdapter)->ResetOldValues();

                RegCloseKey(hkeyInterfaceParam);
            }
        }
        RegCloseKey(hkeyInterfaces);
    }

    TraceError("CTcpipcfg::HrLoadTcpipRegistry", hr);
    return hr;
}

// Called by CTcpipcfg::HrLoadSettings
// Loads all information under the Services\NetBt\Parameters registry key
//
// const HKEY hkeyWinsParam : Handle to Services\NetBt\Parameters
HRESULT CTcpipcfg::HrLoadWinsRegistry(const HKEY hkeyWinsParam)
{
    HRESULT hr = S_OK;

    // Global parameters

    m_glbGlobalInfo.m_fEnableLmHosts = FRegQueryBool( hkeyWinsParam,
                                            RGAS_ENABLE_LMHOSTS,
                                            m_glbGlobalInfo.m_fEnableLmHosts);

    // Save a copy of these values for non-reboot reconfiguration notification
    m_glbGlobalInfo.m_fOldEnableLmHosts = m_glbGlobalInfo.m_fEnableLmHosts;

    HKEY    hkeyInterfaces;
    hr = HrRegOpenKeyEx(hkeyWinsParam, c_szInterfacesRegKey,
                        KEY_READ, &hkeyInterfaces);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        hr = S_OK;
    else if (SUCCEEDED(hr))
    {
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end();
            iterAdapter ++)
        {
            ADAPTER_INFO * pAdapter = *iterAdapter;

            // $REIVEW (nsun 10/05/98) We don't need to read NetBT settings the WAN adapter
            if (pAdapter->m_fIsWanAdapter)
            {
                continue;
            }

            // Open the NetBt\Interfaces\<Something> to get per
            // adapter NetBt settings
            HKEY hkeyInterfaceParam;
            hr = HrRegOpenKeyEx(hkeyInterfaces,
                                pAdapter->m_strNetBtBindPath.c_str(),
                                KEY_READ, &hkeyInterfaceParam);

            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                hr = S_OK;
            else if (SUCCEEDED(hr))
            {
                TraceTag(ttidTcpip, "CTcpipcfg::HrLoadWinsRegistry");
                TraceTag(ttidTcpip, "Interface '%S'", pAdapter->m_strNetBtBindPath.c_str());

                // load wins server address list
                if (FAILED(hr = HrRegQueryColString(hkeyInterfaceParam,
                                                    RGAS_NETBT_NAMESERVERLIST,
                                                    &(pAdapter->m_vstrWinsServerList))))
                {
                    TraceTag(ttidTcpip, "Failed on loading NameServerList, hr: %x", hr);
                    hr = S_OK;
                }

                // Save a copy in m_strOldWinsServerList
                CopyVstr(&(pAdapter->m_vstrOldWinsServerList),
                         pAdapter->m_vstrWinsServerList);

                // load Netbios options
                if (FAILED(hr = HrRegQueryDword(hkeyInterfaceParam,
                                                RGAS_NETBT_NETBIOSOPTIONS,
                                                &(pAdapter->m_dwNetbiosOptions))))
                {
                    TraceTag(ttidTcpip, "Failed on loading NetbiosOptions, hr: %x", hr);
                    hr = S_OK;
                }

                // Save a copy in m_dwOldNetbiosOptions
                pAdapter->m_dwOldNetbiosOptions = pAdapter->m_dwNetbiosOptions;

                RegCloseKey(hkeyInterfaceParam);
            }
        }
        RegCloseKey(hkeyInterfaces);
    }

    TraceError("CTcpipcfg::HrLoadWinsRegistry", hr);
    return hr;
}

// Called by CTcpipcfg::Apply
// This function writes all changes to the registy and makes other
// appropriate changes to the system
HRESULT CTcpipcfg::HrSaveSettings()
{
    HRESULT hr = S_OK;

    HRESULT hrTcpip = S_OK;
    HKEY hkeyTcpipParam = NULL;
    Assert(m_pnccTcpip);

    if (m_pnccTcpip)
    {
        hrTcpip = m_pnccTcpip->OpenParamKey(&hkeyTcpipParam);

        // We use hr instead of hrTcpip because this operation is NOT part of
        // HrSaveTcpipRegistry.

        // We must get the list of Added Cards before anything else because
        // otherwise the Adapter GUID keys will be written later and we will
        // not know if they didn't exist in the system before.
        if (SUCCEEDED(hrTcpip))
        {
            hrTcpip = MarkNewlyAddedCards(hkeyTcpipParam);

            if (SUCCEEDED(hrTcpip))
            {
                Assert(hkeyTcpipParam);
                hrTcpip = HrSaveTcpipRegistry(hkeyTcpipParam);
            }
            else
                Assert(!hkeyTcpipParam);
        }
    }

    HRESULT hrWins = S_OK;
    HKEY hkeyWinsParam = NULL;

    Assert(m_pnccWins);

    if (m_pnccWins)
    {
        hrWins = m_pnccWins->OpenParamKey(&hkeyWinsParam);
        if (SUCCEEDED(hrWins))
        {
            Assert(hkeyWinsParam);
            hrWins = HrSaveWinsRegistry(hkeyWinsParam);
        }
        else
            Assert(!hkeyWinsParam);
    }

    HRESULT hrMisc = S_OK;

    //if hrTcpip == E_? then this is possible (thus no Assert)
    // yes because hrTcpip can be set to E_? from HrSaveTcpipRegistry
    if ((hkeyTcpipParam) && (hkeyWinsParam))
    {
        hrMisc = HrSetMisc(hkeyTcpipParam, hkeyWinsParam);
    }

    RegSafeCloseKey(hkeyTcpipParam);
    RegSafeCloseKey(hkeyWinsParam);

    hr = SUCCEEDED(hr) ? hrTcpip : hr;
    hr = SUCCEEDED(hr) ? hrWins : hr;
    hr = SUCCEEDED(hr) ? hrMisc : hr;

    TraceError("CTcpipcfg::HrSaveSettings", hr);
    return hr;
}

// Set global and adapter specific parameters under
// CCS\Services\TCpip\Parameters
// hkeyTcpipParam   handle to reg key HKLM\Systems\CCS\Services\TCpip\Parameters
HRESULT CTcpipcfg::HrSaveTcpipRegistry(const HKEY hkeyTcpipParam)
{
    // hr is the first error occurred,
    // but we don't want to stop at the first error
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    // Save global info

    // DNS host name ( only on installing )
    if (m_fInstalling)
    {
        if (!m_fUpgradeGlobalDnsDomain)
        {
            //  Bug 299038, during install of tcpip, try to get the primary dns domain name
            //  create the global DNS domain as an empty string during clean install if
            //  we couldn't find the primary dns domain name (219090).
            //  if we already got the global Dns Domain when processing the answer file, we should
            //  use the value from the answer file
            tstring strTmpDomain;
            hrTmp = HrRegQueryString(hkeyTcpipParam,
                                    RGAS_DOMAIN,
                                    &strTmpDomain);
            if (FAILED(hrTmp))
            {
                hrTmp = HrGetPrimaryDnsDomain(&strTmpDomain);

                if (SUCCEEDED(hrTmp))
                {
                    if (!SetComputerNameEx(ComputerNamePhysicalDnsDomain,
                                            strTmpDomain.c_str()))
                    {
                        hrTmp = GetLastError();
                        TraceError("CTcpipcfg::HrSaveTcpipRegistry: SetComputerNameEx failed.", hrTmp);
                    }
                }
                else
                {
                    //Bug #335626, some SrvApp directly retrive this value, so we need to create it for
                    //standalone machines
                    strTmpDomain = c_szEmpty;
                }
                
                //SetComputerNameEx() will write to "Domain" reg value after reboot. Per GlennC, it's ok to write
                //the Domain value here to solve the SrvApp compatibility issue.
                HrRegSetString(hkeyTcpipParam,
                                   RGAS_DOMAIN,
                                   strTmpDomain);
            }

            //the hrTmp get from this section should not affect the
            //final return value
        }


        //
        //  391590: We've saved the hostname from NT4 into the answerfile so that
        //          we can remember the exact (case-sensitive) string.  If the
        //          saved DNS hostname is the same (except for case) as the current
        //          COMPUTERNAME, we set the NT5 DNS hostname to be the saved one,
        //          for SAP compatibility (they make case-sensitive comparisons).
        //          Otherwise, we use the regular COMPUTERNAME, lowercased, as the
        //          DNS hostname.
        //
        if (!lstrcmpiW(m_glbGlobalInfo.m_strHostName.c_str(),
                       m_glbGlobalInfo.m_strHostNameFromAnswerFile.c_str()))
        {
            hrTmp = HrRegSetString(hkeyTcpipParam,
                                   RGAS_HOSTNAME,
                                   m_glbGlobalInfo.m_strHostNameFromAnswerFile);
            if (S_OK == hrTmp)
            {
                hrTmp = HrRegSetString(hkeyTcpipParam,
                                       RGAS_NVHOSTNAME,
                                       m_glbGlobalInfo.m_strHostNameFromAnswerFile);
            }
        }
        else
        {
            hrTmp = HrRegSetString(hkeyTcpipParam,
                                   RGAS_HOSTNAME,
                                   m_glbGlobalInfo.m_strHostName);
            if (S_OK == hrTmp)
            {
                hrTmp = HrRegSetString(hkeyTcpipParam,
                                       RGAS_NVHOSTNAME,
                                       m_glbGlobalInfo.m_strHostName);
            }
        }

        TraceError("CTcpipcfg::HrSaveTcpipRegistry: Failed to set HostName.", hrTmp);

        //the hrTmp get from this section should not affect the
        //final return value
    }

    // Added per request from Stuart Kwan:
    // only when the global DNS domain is read from answerfile
    if (m_fUpgradeGlobalDnsDomain)
    {
        if (!SetComputerNameEx(ComputerNamePhysicalDnsDomain,
                                m_strUpgradeGlobalDnsDomain.c_str()))
        {
            hrTmp = GetLastError();
            TraceError("CTcpipcfg::HrSaveTcpipRegistry: SetComputerNameEx failed.", hrTmp);
        }

        //If the registry value Services\Tcpip\Parameters\SyncDomainWithMembership != 0,
        //Netlogon will try to overwirte the value with the member domain name when joining
        //into the domain. (See NT bug 310143
        //
        //Due to bug WinSE 7317, most users don't want us to manually set SyncDomainWithMembership
        //reg value as 0 here.
        //
        //As a workaround in order to upgarde the gloabl Dns domain name, the user has to 
        //add SyncDomainWithMembership reg value under tcpip parameters and make it as 0.
        //In the unattended install case, there needs to be a line
        //   SyncDomainWithMembership=0
        //in the global tcpip parameters section if the user want to specify a global DNS
        //domain name that is different with the membership domain name.

        
        //the hrTmp get from this section should not affect the
        //final return value
    }

    // Dns suffix list
    tstring strSearchList;
    ConvertColStringToString(m_glbGlobalInfo.m_vstrDnsSuffixList,
                             c_chListSeparator,
                             strSearchList);

    hrTmp = HrRegSetString(hkeyTcpipParam,
                           RGAS_SEARCHLIST,
                           strSearchList);

    if (SUCCEEDED(hr))
        hr = hrTmp;

    // UseDomainNameDevolution
    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szUseDomainNameDevolution,
                          m_glbGlobalInfo.m_fUseDomainNameDevolution);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    // IpEnableRouter
    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szIpEnableRouter,
                          m_glbGlobalInfo.m_fEnableRouter);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    //(nsun 11/02/98) parameters of RRAS for unattended install
    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szEnableICMPRedirect,
                          m_glbGlobalInfo.m_fEnableIcmpRedirect);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szDeadGWDetectDefault,
                          m_glbGlobalInfo.m_fDeadGWDetectDefault);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          c_szDontAddDefaultGatewayDefault,
                          m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetBool(hkeyTcpipParam,
                          RGAS_SECURITY_ENABLE,
                          m_glbGlobalInfo.m_fEnableFiltering);
    if (SUCCEEDED(hr))
        hr = hrTmp;


    // Adapter specific info (physical cards)
    HKEY    hkeyAdapters = NULL;
    DWORD   dwDisposition;

    // Create or open the "Adapters" key under "Services\Tcpip\Parameters"
    hrTmp = HrRegCreateKeyEx(hkeyTcpipParam, c_szAdaptersRegKey,
                             REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                             &hkeyAdapters, &dwDisposition);
    if (SUCCEEDED(hrTmp))
    {
        Assert(hkeyAdapters);
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end();
            iterAdapter ++)
        {
            ADAPTER_INFO * pAdapter = *iterAdapter;

            // No need to do this for RAS fake adapters
            if (pAdapter->m_fIsRasFakeAdapter)
            {
                continue;
            }

            // Create specific card bindname key under
            // "Services\Tcpip\Parameters\Adapters\<card bind name>"
            //

            HKEY hkeyAdapterParam;
            hrTmp = HrRegCreateKeyEx(hkeyAdapters,
                                     pAdapter->m_strBindName.c_str(),
                                     REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                                     &hkeyAdapterParam, &dwDisposition);

            if (SUCCEEDED(hr))
                hr = hrTmp;

            if (SUCCEEDED(hrTmp))
            {
                Assert(hkeyAdapterParam);

                // Set LLInterface and IpConfig for new cards
                //
                if (pAdapter->m_fNewlyChanged)
                {
                    PCWSTR pszArpModule = c_szEmpty;

                    if (pAdapter->m_fIsWanAdapter)
                    {
                        pszArpModule = c_szWanArp;
                    }
                    else if (pAdapter->m_fIsAtmAdapter)
                    {
                        pszArpModule = c_szAtmArp;
                    }
                    else if (pAdapter->m_fIs1394Adapter)
                    {
                        pszArpModule = c_sz1394Arp;
                    }
                    
                    hrTmp = HrRegSetSz(hkeyAdapterParam,
                                       RGAS_LLINTERFACE,
                                       pszArpModule);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // (08/18/98 nsun) modified to support multiple interfaces of WAN adapter
                    VSTR vstrIpConfig;

                    if (!pAdapter->m_fIsMultipleIfaceMode)
                    {
                        HrRegDeleteValue(hkeyAdapterParam, RGAS_NUMINTERFACES);

                        tstring* pstr = new tstring(RGAS_TCPIP_PARAM_INTERFACES);

                        if (pstr == NULL)
                        {
                            return(E_OUTOFMEMORY);
                        }

                        pstr->append(pAdapter->m_strTcpipBindPath);
                        vstrIpConfig.push_back(pstr);

                        hrTmp = HrRegSetColString(hkeyAdapterParam,
                                              RGAS_IPCONFIG,
                                              vstrIpConfig);
                    }
                    else
                    {
                        AssertSz(pAdapter->m_fIsWanAdapter, "The card is not WAN adapter, but how can it support multiple interface.");

                        tstring strInterfaceName;
                        IFACEITER iterId;

                        for(iterId  = pAdapter->m_IfaceIds.begin();
                            iterId != pAdapter->m_IfaceIds.end();
                            iterId++)
                        {
                            GetInterfaceName(
                                    pAdapter->m_strTcpipBindPath.c_str(),
                                    *iterId,
                                    &strInterfaceName);

                            tstring* pstr = new tstring(RGAS_TCPIP_PARAM_INTERFACES);
                            pstr->append(strInterfaceName);

                            vstrIpConfig.push_back(pstr);
                        }

                        hrTmp = HrRegSetColString(hkeyAdapterParam,
                                              RGAS_IPCONFIG,
                                              vstrIpConfig);

                        if (SUCCEEDED(hr))
                            hr = hrTmp;

                        //$REVIEW (nsun 09/15/98) use NumInterfaces value to identify if the adapter is in the
                        //mode of supporting multiple interfaces. If the NumInterfaces
                        //exists, the adapter supports multiple interfaces.
                        //If NumInterfaces == 0, it means the adapter supports multiple interfaces
                        // but no interface is associated with it. So the IpInterfaces should not
                        // exists. The NumInterfaces and IpInterfaces should alwasy be consistent.

                        DWORD   dwNumInterfaces = pAdapter->m_IfaceIds.size();
                        hrTmp = HrRegSetDword(hkeyAdapterParam,
                                              RGAS_NUMINTERFACES,
                                              dwNumInterfaces);

                        if (SUCCEEDED(hr))
                            hr = hrTmp;

                        if ( 0 != dwNumInterfaces )
                        {
                            GUID* aguid;
                            DWORD cguid;
                            hrTmp = GetGuidArrayFromIfaceColWithCoTaskMemAlloc(
                                        pAdapter->m_IfaceIds,
                                        &aguid,
                                        &cguid);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            Assert(aguid);
                            hrTmp = HrRegSetBinary(hkeyAdapterParam,
                                              RGAS_IPINTERFACES,
                                              (BYTE*) aguid,
                                              cguid * sizeof(GUID));
                            CoTaskMemFree(aguid);
                        }
                        else
                        {
                            hrTmp = HrRegDeleteValue(hkeyAdapterParam, RGAS_IPINTERFACES);

                            //It's fine that the IpInterfaces does not exist at all if
                            // the WAN adapter does not support multiple interfaces.
                            if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                                hrTmp = S_OK;
                        }

                    }

                    FreeCollectionAndItem(vstrIpConfig);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }
            

                RegCloseKey(hkeyAdapterParam);
            }
        }

        RegCloseKey(hkeyAdapters);
    }
    else if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hrTmp)
    {
        //for netcfg operators, we will get access denied error when opening this key
        //however, it's ok because we don't need to touch the key when just updating the IP settings
        hrTmp = S_OK;
    }

    if (SUCCEEDED(hr))
        hr = hrTmp;


    // Create or open the "Interfaces" key under "Services\Tcpip\Parameters"
    //
    HKEY    hkeyInterfaces;
    hrTmp = HrRegCreateKeyEx(hkeyTcpipParam, c_szInterfacesRegKey,
                             REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                             &hkeyInterfaces, &dwDisposition);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp))
    {
        Assert(hkeyInterfaces);
        for(VCARD::iterator iterAdapter =  m_vcardAdapterInfo.begin();
            iterAdapter !=  m_vcardAdapterInfo.end();
            iterAdapter ++)
        {
            if ((*iterAdapter)->m_fIsRasFakeAdapter)
            {
                continue;
            }

            ADAPTER_INFO * pAdapter = *iterAdapter;

            //(08/20/98 nsun) modified to support multiple interfaces of WAN adapter
            // NULL != pAdapter->m_IfaceIds means it's in multiple interface mode
            if (pAdapter->m_fIsWanAdapter && pAdapter->m_fIsMultipleIfaceMode)
            {
                if (pAdapter->m_fNewlyChanged)
                {
                    HrSaveMultipleInterfaceWanRegistry(hkeyInterfaces, pAdapter);
                }
                continue;
            }

            // Create specific card interface key under
            // "Services\Tcpip\Parameters\Interfaces\<card bind path>"
            //
            HKEY hkeyInterfaceParam;
            hrTmp = HrRegCreateKeyEx(hkeyInterfaces,
                                     pAdapter->m_strTcpipBindPath.c_str(),
                                     REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                                     &hkeyInterfaceParam, &dwDisposition);

            if (SUCCEEDED(hr))
                hr = hrTmp;

            if (SUCCEEDED(hrTmp))
            {
                Assert(hkeyInterfaceParam);

                if (pAdapter->m_fNewlyChanged)
                {
                    //Bug306259 If UseZeroBroadCast already exists (which means it is from the answer
                    // file), we should not overwrite it with the default value.
                    DWORD dwTmp;
                    hrTmp = HrRegQueryDword(hkeyInterfaceParam,
                                             RGAS_USEZEROBROADCAST,
                                             &dwTmp);
                    if (FAILED(hrTmp))
                    {
                        // ZeroBroadcast
                        hrTmp = HrRegSetDword(hkeyInterfaceParam,
                                              RGAS_USEZEROBROADCAST,
                                              0);
                        if (SUCCEEDED(hr))
                            hr = hrTmp;
                    }

                    if (pAdapter->m_fIsWanAdapter)
                    {   // For new RAS cards
                        hrTmp = HrSaveStaticWanRegistry(hkeyInterfaceParam);
                    }
                    else if (pAdapter->m_fIsAtmAdapter)
                    {
                        // For new ATM cards
                        hrTmp = HrSaveStaticAtmRegistry(hkeyInterfaceParam);
                    }
                    else if (pAdapter->m_fIs1394Adapter)
                    {
                        // For new NIC1394 cards
                        // (nothing to do).
                        hrTmp = S_OK;
                    }
                    else
                    {
                        //(nsun 11/02/98) set static RRAS parameters for unattended install

                        //if the values exists, that means they have been set as an unconfigurable 
                        //parameter during upgrade,
                        //we should not set the default value.

                        DWORD   dwTmp;

                        hrTmp = HrRegQueryDword(hkeyInterfaceParam,
                                                c_szDeadGWDetect,
                                                &dwTmp);
                        
                        if (FAILED(hrTmp))
                        {
                            hrTmp = HrRegSetBool(hkeyInterfaceParam,
                                              c_szDeadGWDetect,
                                              m_glbGlobalInfo.m_fDeadGWDetectDefault);
                        }
                    }

                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }

                // For LAN cards and RAS fake guids
                if (!pAdapter->m_fIsWanAdapter)
                {
                    // Ip address etc
                    hrTmp = HrRegSetBool(hkeyInterfaceParam,
                                          RGAS_ENABLE_DHCP,
                                          pAdapter->m_fEnableDhcp);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    //warning: these VSTRs will contain pointers to strings
                    //that are either local to this function or
                    //that are also pointed to in another VSTR
                    // DO NOT call FreeCollectionAndItem on them!
                    VSTR vstrIpAddresses;
                    VSTR vstrSubnetMask;
                    tstring ZeroAddress(ZERO_ADDRESS);

                    if (pAdapter->m_fEnableDhcp)
                    {
                        vstrIpAddresses.push_back(&ZeroAddress);
                        vstrSubnetMask.push_back(&ZeroAddress);
                    }
                    else
                    {
                        vstrIpAddresses = pAdapter->m_vstrIpAddresses;
                        vstrSubnetMask  = pAdapter->m_vstrSubnetMask;
                    }

                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_IPADDRESS,
                                              vstrIpAddresses);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_SUBNETMASK,
                                              vstrSubnetMask);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_DEFAULTGATEWAY,
                                              pAdapter->m_vstrDefaultGateway);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                      RGAS_DEFAULTGATEWAYMETRIC,
                                      pAdapter->m_vstrDefaultGatewayMetric);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // DNS name server list
                    tstring strNameServer;
                    ConvertColStringToString(pAdapter->m_vstrDnsServerList,
                                             c_chListSeparator,
                                             strNameServer);

                    hrTmp = HrRegSetString(hkeyInterfaceParam,
                                           RGAS_NAMESERVER,
                                           strNameServer);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // DNS domain
                    hrTmp = HrRegSetString(hkeyInterfaceParam,
                                           RGAS_DOMAIN,
                                           pAdapter->m_strDnsDomain);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // Dns ip address dynamic update
                    if (pAdapter->m_fDisableDynamicUpdate)
                    {
                        DnsDisableDynamicRegistration(
                                        (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());
                    }
                    else
                    {
                        DnsEnableDynamicRegistration(
                                        (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());
                    }

                    // adapter Dns domain name registration
                    if (pAdapter->m_fEnableNameRegistration)
                    {
                        DnsEnableAdapterDomainNameRegistration(
                                        (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());
                    }
                    else
                    {
                        DnsDisableAdapterDomainNameRegistration(
                                        (LPWSTR)pAdapter->m_strTcpipBindPath.c_str());
                    }

                    // InterfaceMetric
                    if (c_dwDefaultIfMetric != pAdapter->m_dwInterfaceMetric)
                    {
                        hrTmp = HrRegSetDword(hkeyInterfaceParam,
                                          c_szInterfaceMetric,
                                          pAdapter->m_dwInterfaceMetric);
                    }
                    else
                    {
                        //The interface metric is default, remove that value.
                        //In such way, it would be much easier to upgrade if the default is changed
                        //in the future
                        hrTmp = HrRegDeleteValue(hkeyInterfaceParam,
                                          c_szInterfaceMetric);

                        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
                            hrTmp = S_OK;
                    }
                    
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // TCPAllowedPorts
                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_FILTERING_TCP,
                                              pAdapter->m_vstrTcpFilterList);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // UDPAllowedPorts
                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_FILTERING_UDP,
                                              pAdapter->m_vstrUdpFilterList);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // IPAllowedPorts
                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                              RGAS_FILTERING_IP,
                                              pAdapter->m_vstrIpFilterList);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // For ATM cards only
                    if (pAdapter->m_fIsAtmAdapter)
                    {
                        HKEY hkeyAtmarpc;

                        // Open the Atmarpc subkey
                        hrTmp = HrRegCreateKeyEx(hkeyInterfaceParam,
                                                 c_szAtmarpc,
                                                 REG_OPTION_NON_VOLATILE,
                                                 KEY_READ_WRITE,
                                                 NULL,
                                                 &hkeyAtmarpc,
                                                 &dwDisposition);

                        if (SUCCEEDED(hrTmp))
                        {
                            hrTmp = HrRegSetColString(hkeyAtmarpc,
                                                     c_szREG_ARPServerList,
                                                     pAdapter->m_vstrARPServerList);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            hrTmp = HrRegSetColString(hkeyAtmarpc,
                                                     c_szREG_MARServerList,
                                                     pAdapter->m_vstrMARServerList);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            hrTmp = HrRegSetDword(hkeyAtmarpc,
                                                  c_szREG_MTU,
                                                  pAdapter->m_dwMTU);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            hrTmp = HrRegSetBool(hkeyAtmarpc,
                                                  c_szREG_PVCOnly,
                                                  pAdapter->m_fPVCOnly);
                            if (SUCCEEDED(hr))
                                hr = hrTmp;

                            RegCloseKey(hkeyAtmarpc);
                        }
                    }

                    hrTmp = HrDuplicateToNT4Location(hkeyInterfaceParam,
                                             pAdapter);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    hrTmp = HrSaveBackupTcpSettings(hkeyInterfaceParam, 
                                            pAdapter);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                } // For LAN cards and RAS fake guids only

                RegCloseKey(hkeyInterfaceParam);
            }
        }

        RegCloseKey(hkeyInterfaces);
    }

    TraceError("CTcpipcfg::HrSaveTcpipRegistry", hr);
    return hr;
}

HRESULT CTcpipcfg::HrSaveWinsRegistry(const HKEY hkeyWinsParam)
{
    // hr is the first error occurred,
    // but we don't want to stop at the first error
    HRESULT         hr = S_OK;
    HRESULT         hrTmp = S_OK;

    // Global parameters
    hrTmp = HrRegSetBool(hkeyWinsParam,
                          RGAS_ENABLE_LMHOSTS,
                          m_glbGlobalInfo.m_fEnableLmHosts);
    if (SUCCEEDED(hr))
        hr = hrTmp;
/*$REVIEW (nsun 2/17/98) Bug #293643 We don't want to change any unconfigurable values

    // $REVIEW(tongl 8/3/97): Added NodeType settings #97364.
    // If no adapter has static WINS address, then remove NodeType.
    // otherwise, the user has specified the WINs server address for
    // at least one adapters, set NodeType = 0x08 (H-NODE)
    BOOL fNoWinsAddress = TRUE;

    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter++)
    {
        ADAPTER_INFO * pAdapter = *iterAdapter;

        if ((!pAdapter->m_fIsWanAdapter)&&
            (BINDING_ENABLE == pAdapter->m_BindingState)&&
            (pAdapter->m_vstrWinsServerList.size()>0))
        {
            fNoWinsAddress = FALSE;
        }
    }


    DWORD dwNodeType;
    hrTmp = HrRegQueryDword(hkeyWinsParam,
                            c_szNodeType,
                            &dwNodeType);
    // dwNodeType ==0 means the key did not exist before we apply
    if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        dwNodeType =0;

    if (!m_fAnswerFileBasedInstall ||
        (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)))
    {
        if (!fNoWinsAddress) // set NodeType to 0x08
        {
            if (dwNodeType != c_dwHNode)
            {
                hrTmp = HrRegSetDword(hkeyWinsParam,
                                      c_szNodeType,
                                      c_dwHNode);
                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }
        }
        else // remove NodeType key
        {
            if (dwNodeType != 0)
            {
                hrTmp = HrRegDeleteValue(hkeyWinsParam,
                                         c_szNodeType);

                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }
        }
    }
*/
    // $REVIEW(tongl 12\1\97): Per agreement with Malam today(see email),
    // NetBt will re-read NodeType when notified of wins address list change.
    // Thus no need to notify change separately below.
    /*
    if (fNodeTypeChanged)
    {
        // Send notification to NetBt
        TraceTag(ttidTcpip,"NodeType parameter changed, send notification on apply.");
        SetReconfig();
        // SetReconfigNbt();
    }
    */

    // Adapter interface specific parameters
    // Create the "Services\NetBt\Interfacess" key
    HKEY    hkeyInterfaces;
    DWORD   dwDisposition;
    hrTmp = HrRegCreateKeyEx(hkeyWinsParam, c_szInterfacesRegKey,
                             REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                             &hkeyInterfaces, &dwDisposition);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp))
    {
        for(VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
            iterAdapter != m_vcardAdapterInfo.end();
            iterAdapter++)
        {
            ADAPTER_INFO * pAdapter = *iterAdapter;

            //(10/05/98 nsun) modified to support multiple interfaces of WAN adapter
            // NULL != pAdapter->m_IfaceIds means it's in multiple interface mode
            if (pAdapter->m_fNewlyChanged &&
                pAdapter->m_fIsWanAdapter &&
                pAdapter->m_fIsMultipleIfaceMode)
            {
                HrSaveWinsMultipleInterfaceWanRegistry(hkeyInterfaces, pAdapter);
                continue;
            }

            HKEY hkeyInterfaceParam;
            hrTmp = HrRegCreateKeyEx(hkeyInterfaces,
                                     pAdapter->m_strNetBtBindPath.c_str(),
                                     REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                                     &hkeyInterfaceParam, &dwDisposition);

            if (SUCCEEDED(hr))
                hr = hrTmp;

            if (SUCCEEDED(hrTmp))
            {
                // For new RAS cards, only set static values
                if (pAdapter->m_fIsWanAdapter && pAdapter->m_fNewlyChanged)
                {
                    hrTmp = HrRegSetMultiSz(hkeyInterfaceParam,
                                            RGAS_NETBT_NAMESERVERLIST,
                                            L"\0");
                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }
                else // if not RAS adapter
                {
                    // set wins server address list
                    hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                             RGAS_NETBT_NAMESERVERLIST,
                                             pAdapter->m_vstrWinsServerList);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;

                    // set NetbiosOptions
                    hrTmp = HrRegSetDword(hkeyInterfaceParam,
                                          RGAS_NETBT_NETBIOSOPTIONS,
                                          pAdapter->m_dwNetbiosOptions);
                    if (SUCCEEDED(hr))
                        hr = hrTmp;
                }

                RegCloseKey(hkeyInterfaceParam);
            }
        }

        RegCloseKey(hkeyInterfaces);
    }

    TraceError("CTcpipcfg::HrSaveWinsRegistry", hr);
    return hr;
}


// Called by CTcpipcfg::SaveSettings
// Does a lot of miscelaneous actions when Apply is called
// Including cleaning up registry and remove isolated cards
//
// HKEY hkeyTcpipParam           Serviess\Tcpip\Parameters
// HKEY hkeyWinsParam            Services\NetBt\Parameters

HRESULT CTcpipcfg::HrSetMisc(const HKEY hkeyTcpipParam, const HKEY hkeyWinsParam)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    // Registry Cleanup !!

    // We remove DNS domain and DNS server list in NT5 upgrades
    if (m_fUpgradeCleanupDnsKey)
    {
        hrTmp = HrRegDeleteValue(hkeyTcpipParam, RGAS_NAMESERVER);

        // $REVIEW(tongl 3/22/98): Per Stuart Kwan, global DNSDomain key
        // is also used.
        // hrTmp = HrRegDeleteValue(hkeyTcpipParam, RGAS_DOMAIN);
    }

    // remove all keys under the "Services\Tcpip\Parameters\Adapters" reg key
    // that aren't in the list of net cards.
    VSTR vstrNetCardsInTcpipReg;
    HKEY hkeyAdapters = NULL;

    hrTmp = HrRegOpenKeyEx(hkeyTcpipParam, c_szAdaptersRegKey, KEY_READ,
                        &hkeyAdapters);

    if (SUCCEEDED(hrTmp))
    {
        hrTmp = HrLoadSubkeysFromRegistry(hkeyAdapters,
                                          &vstrNetCardsInTcpipReg);
    }
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hr) && vstrNetCardsInTcpipReg.size() > 0)
    {
        // Step through the names of all the registry keys found
        //
        for (VSTR_CONST_ITER iter = vstrNetCardsInTcpipReg.begin();
             iter != vstrNetCardsInTcpipReg.end();
             ++iter)
        {
            // Find out if this particular key is in the list
            // of installed Adapters
            //
            BOOL fFound = FALSE;

            for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
            {
                ADAPTER_INFO* pAdapter = *iterAdapter;

                if (lstrcmpiW(pAdapter->m_strBindName.c_str(), (**iter).c_str()) == 0)
                {
                    fFound = TRUE;
                    break;
                }
            }

            if (!fFound)
            {
                // if it wasn't in the list of installed adapters
                // then delete it
                //
                if (SUCCEEDED(hrTmp))
                    hrTmp = HrRegDeleteKeyTree(hkeyAdapters, (*iter)->c_str());

                //maybe the key is not there. so we don't check whether this will fail.
                HrDeleteBackupSettingsInDhcp((*iter)->c_str());

                if (SUCCEEDED(hr))
                    hr = hrTmp;

            }
        }
    }
    FreeCollectionAndItem(vstrNetCardsInTcpipReg);
    RegSafeCloseKey(hkeyAdapters);

    //we also need to delete the duplicate reg values under Services\{adapter GUID}
    HRESULT hrNt4 = S_OK;
    HKEY    hkeyServices = NULL;
    DWORD   dwDisposition;

    hrNt4 = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegServices,
                            KEY_READ, &hkeyServices);

    if (FAILED(hrNt4))
    {
        TraceTag(ttidTcpip, "HrSetMisc: Failed to open the Services reg key, hr: %x", hr);
    }


    // We remove all keys under the "Services\Tcpip\Parameters\Interfaces" reg key
    // that aren't in our list of net cards.
    VSTR vstrNetCardInterfacesInTcpipReg;

    // Get a list of all keys under the "Services\Tcpip\Parameters\Interfaces" key
    HKEY hkeyInterfaces = NULL;

    hrTmp = HrRegOpenKeyEx(hkeyTcpipParam, c_szInterfacesRegKey, KEY_READ_WRITE_DELETE,
                        &hkeyInterfaces);

    if (SUCCEEDED(hrTmp))
    {
        hrTmp = HrLoadSubkeysFromRegistry(hkeyInterfaces,
                                          &vstrNetCardInterfacesInTcpipReg);
    }

    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp) && vstrNetCardInterfacesInTcpipReg.size() > 0 )
    {
        // step through the names of all the registry keys found
        for (VSTR_CONST_ITER iterTcpipReg = vstrNetCardInterfacesInTcpipReg.begin() ;
                iterTcpipReg != vstrNetCardInterfacesInTcpipReg.end() ; ++iterTcpipReg)
        {
            // Find out if this particular key is in the list
            // of installed Adapters
            BOOL fFound = FALSE;

            for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
            {
                ADAPTER_INFO* pAdapter = *iterAdapter;

                //(08/18/98 nsun) special case for WAN adapters with multiple interfaces
                if (pAdapter->m_fIsWanAdapter && pAdapter->m_fIsMultipleIfaceMode)
                {
                    IFACEITER   iterId;
                    tstring     strInterfaceName;

                    for(iterId  = pAdapter->m_IfaceIds.begin();
                        iterId != pAdapter->m_IfaceIds.end();
                        iterId++)
                    {
                        GetInterfaceName(
                                pAdapter->m_strTcpipBindPath.c_str(),
                                *iterId,
                                &strInterfaceName);

                        if (lstrcmpiW(strInterfaceName.c_str(), (**iterTcpipReg).c_str()) == 0)
                        {
                            fFound = TRUE;
                            break;
                        }
                    }

                    if (fFound)
                        break;
                }
                else if (lstrcmpiW(pAdapter->m_strTcpipBindPath.c_str(), (**iterTcpipReg).c_str()) == 0)
                {
                    fFound = TRUE;
                    break;
                }
            }

            // if it wasn't in the list of installed adapters then delete it
            if (!fFound)
            {
                // remove the key
                if (SUCCEEDED(hrTmp))
                    hrTmp = HrRegDeleteKeyTree(hkeyInterfaces, (*iterTcpipReg)->c_str());

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                if (SUCCEEDED(hrNt4))
                {
                    hrTmp = HrRegDeleteKeyTree(hkeyServices, (*iterTcpipReg)->c_str());
                    if (FAILED(hrTmp))
                    {
                        TraceTag(ttidTcpip, "CTcpipcfg::SetMisc");
                        TraceTag(ttidTcpip, "Failed on deleting duplicated Nt4 layout key: Services\\%S, hr: %x",
                                 (*iterTcpipReg)->c_str(), hrTmp);
                        hrTmp = S_OK;
                    }
                }
            }
        }
    }
    RegSafeCloseKey(hkeyInterfaces);
    RegSafeCloseKey(hkeyServices);
    FreeCollectionAndItem(vstrNetCardInterfacesInTcpipReg);

    // Now we remove all keys under the "SERVICES\NetBt\Parameters\Interfaces" reg key
    // that aren't in our list of net cards.

    VSTR vstrNetCardInterfacesInWinsReg;

    // Get a list of all keys under the "Services\NetBt\Parameters\Interfaces" key
    HKEY hkeyWinsInterfaces = NULL;

    hrTmp = HrRegOpenKeyEx(hkeyWinsParam, c_szInterfacesRegKey, KEY_READ,
                           &hkeyWinsInterfaces);

    // Get a list of all keys under the "SERVICES\NetBt\Parameters\Interfaces" key
    hrTmp = HrLoadSubkeysFromRegistry( hkeyWinsInterfaces,
                                        &vstrNetCardInterfacesInWinsReg);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    if (SUCCEEDED(hrTmp) && vstrNetCardInterfacesInWinsReg.size()>0 )
    {
        // Step through the names of all the registry keys found
        for (VSTR_CONST_ITER iterWinsReg = vstrNetCardInterfacesInWinsReg.begin() ;
             iterWinsReg != vstrNetCardInterfacesInWinsReg.end() ; ++iterWinsReg)
        {
            // Find out if this particular key is in the list
            // of installed Adapters
            BOOL fFound = FALSE;

            // All net cards
            for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
            {
                ADAPTER_INFO* pAdapter = *iterAdapter;

                //(10/05/98 nsun) special case for WAN adapters with multiple interfaces
                if (pAdapter->m_fIsWanAdapter && pAdapter->m_fIsMultipleIfaceMode)
                {
                    IFACEITER   iterId;
                    tstring     strNetBtBindPath;

                    for (iterId  = pAdapter->m_IfaceIds.begin();
                         iterId != pAdapter->m_IfaceIds.end();
                         iterId++)
                    {
                        GetInterfaceName(
                                pAdapter->m_strNetBtBindPath.c_str(),
                                *iterId,
                                &strNetBtBindPath);

                        strNetBtBindPath.insert(0, c_szTcpip_);

                        if (lstrcmpiW(strNetBtBindPath.c_str(), (**iterWinsReg).c_str()) == 0)
                        {
                            fFound = TRUE;
                            break;
                        }
                    }

                    if (fFound)
                        break;
                }
                else if (lstrcmpiW(pAdapter->m_strNetBtBindPath.c_str(), (**iterWinsReg).c_str()) == 0)
                {
                    fFound = TRUE;
                    break;
                }
            }

            // if it wasn't in the list of installed adapters then delete it
            if (!fFound)
            {
                hrTmp = HrRegDeleteKeyTree(hkeyWinsInterfaces, (*iterWinsReg)->c_str());

                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }
        }
    }
    FreeCollectionAndItem(vstrNetCardInterfacesInWinsReg);
    RegSafeCloseKey(hkeyWinsInterfaces);

    TraceError("CTcpipcfg::HrSetMisc", hr);
    return hr;
}

// CTcpipcfg::HrGetDhcpOptions
//
// Gets the list of netcard dependend and netcard independent
// values to delete when DHCP is disabled. This list is obtained from:
// "Services\DHCP\Parameters\Options\#\RegLocation"
//
// GlobalOptions           returns the non-netcard specific reg keys
// PerAdapterOptions       returns the netcard specific reg keys

HRESULT CTcpipcfg::HrGetDhcpOptions(OUT VSTR * const GlobalOptions,
                                    OUT VSTR * const PerAdapterOptions)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HKEY hkeyDhcpOptions;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        RGAS_DHCP_OPTIONS,
                        KEY_ENUMERATE_SUB_KEYS,
                        &hkeyDhcpOptions);

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        hr = S_OK;

    else if (SUCCEEDED(hr))
    {
        WCHAR szBuf[256];
        FILETIME time;
        DWORD dwSize = celems(szBuf);
        DWORD dwRegIndex = 0;

        while(SUCCEEDED(hrTmp = HrRegEnumKeyEx(hkeyDhcpOptions,
                                               dwRegIndex++,
                                               szBuf, &dwSize,
                                               NULL, NULL, &time)))
        {
            dwSize = celems(szBuf);

            HKEY hkeyRegLocation;
            hrTmp = HrRegOpenKeyEx(hkeyDhcpOptions, szBuf,
                                   KEY_QUERY_VALUE,
                                   &hkeyRegLocation);

            if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                hrTmp = S_OK;

            if (SUCCEEDED(hr))
                hr = hrTmp;

            if (hkeyRegLocation)
            {
                tstring strRegLocation;
                hrTmp = HrRegQueryString(hkeyRegLocation,
                                         RGAS_REG_LOCATION,
                                         &strRegLocation);

                if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    hrTmp = S_OK;

                if (SUCCEEDED(hr))
                    hr = hrTmp;

                if (SUCCEEDED(hrTmp))
                {
                    if (strRegLocation.find(TCH_QUESTION_MARK) == tstring::npos)
                    {
                        GlobalOptions->push_back(new tstring(strRegLocation));
                    }
                    else
                    {
                        PerAdapterOptions->push_back(new tstring(strRegLocation));
                    }
                }

                RegCloseKey(hkeyRegLocation);
            }
        }

        if (hrTmp == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            hrTmp = S_OK;

        if (SUCCEEDED(hr))
            hr = hrTmp;

        RegCloseKey(hkeyDhcpOptions);
    }

    // Add default PerAdapterOption
    // $REVIEW(tongl 5/11): This is directly from ncpa1.1
    // What about DhcpNameServer under NetBt ??

    //"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpIPAddress"
    PerAdapterOptions->push_back(new tstring(RGAS_DHCP_OPTION_IPADDRESS));

    //"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\?\\DhcpSubnetMask"
    PerAdapterOptions->push_back(new tstring(RGAS_DHCP_OPTION_SUBNETMASK));

    //"System\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces\\?\\DhcpNameServerBackup"
    PerAdapterOptions->push_back(new tstring(RGAS_DHCP_OPTION_NAMESERVERBACKUP));

    TraceError("HrGetDhcpOptions", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::ReconfigIp
//
//  Purpose:    Notify Tcpip of configuration changes
//
//  Arguments:  INetCfgPnpReconfigCallback* pICallback  
//                  the call back interface to handle Ndis Pnp reconfig
//
//  Returns:    HRESULT, S_OK on success, NETCFG_S_REBOOT otherwise
//

HRESULT CTcpipcfg::HrReconfigIp(INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr = S_OK;
    HRESULT hrReconfig = S_OK;

    
    //$$REVIEW bug 329542, we remove the Pnp notification on "EnableSecurityFilters".
    //And then global PnP notification to tcp stack is not needed at all.
    if (m_glbGlobalInfo.m_fEnableFiltering != m_glbGlobalInfo.m_fOldEnableFiltering)
    {
        hr = NETCFG_S_REBOOT;
    }
    


    IP_PNP_RECONFIG_REQUEST IpReconfigRequest;

    ZeroMemory(&IpReconfigRequest, sizeof(IpReconfigRequest));

    // DWORD version
    IpReconfigRequest.version = IP_PNP_RECONFIG_VERSION;
    IpReconfigRequest.arpConfigOffset = 0;

    //we are only interested in gateway and interface metric, because other
    //parameters cannot be changed from the UI
    IpReconfigRequest.Flags = IP_PNP_FLAG_GATEWAY_LIST_UPDATE | 
                              IP_PNP_FLAG_INTERFACE_METRIC_UPDATE ;


    // Submit per adapter reconfig notifications
    // gatewayListUpdate, filterListUpdate
    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter ++) // for each adapter
    {

        ADAPTER_INFO * pAdapter = *iterAdapter;

        // If not wan adapter or RAS fake guid, and adapter is enabled
        if ((!pAdapter->m_fIsWanAdapter) &&
            (!pAdapter->m_fIsRasFakeAdapter) &&
            (pAdapter->m_BindingState == BINDING_ENABLE) &&
            (pAdapter->m_InitialBindingState != BINDING_DISABLE))
        {
            // gateway list
            IpReconfigRequest.gatewayListUpdate =
                !fIsSameVstr(pAdapter->m_vstrDefaultGateway,
                             pAdapter->m_vstrOldDefaultGateway) ||
                !fIsSameVstr(pAdapter->m_vstrDefaultGatewayMetric,
                             pAdapter->m_vstrOldDefaultGatewayMetric);

            IpReconfigRequest.InterfaceMetricUpdate =
                !!(pAdapter->m_dwInterfaceMetric !=
                   pAdapter->m_dwOldInterfaceMetric);

            if ((IpReconfigRequest.gatewayListUpdate) ||
                (IpReconfigRequest.InterfaceMetricUpdate))
            {
                TraceTag(ttidTcpip, "Sending notification to Tcpip about parameter changes for adapter %S.", pAdapter->m_strBindName.c_str());
                TraceTag(ttidTcpip, "Gateway list update: %d", IpReconfigRequest.gatewayListUpdate);
                TraceTag(ttidTcpip, "Interface metric update: %d", IpReconfigRequest.InterfaceMetricUpdate);

                hrReconfig  = pICallback->SendPnpReconfig(NCRL_NDIS, c_szTcpip,
                                                    pAdapter->m_strTcpipBindPath.c_str(),
                                                    &IpReconfigRequest,
                                                    sizeof(IP_PNP_RECONFIG_REQUEST));

                //we dont want to request reboot if the error is ERROR_FILE_NOT_FOUND
                //because that means the card is not loaded by the stack yet. Usually this is 
                //because the card was disabled from the connection UI. When the card is re-enabled,
                //the statck will reload the card and load all settings from the registry. So a reboot
                //is not needed
                if (FAILED(hrReconfig) && 
                    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrReconfig)
                {
                    TraceTag(ttidTcpip,"Notifying tcpip of adapter specific parameter change returns failure, prompt for reboot ...");
                    hr = NETCFG_S_REBOOT;
                }
            }

            // if ATM adapter, notify atmarp if any parameter has changed
            if (pAdapter->m_fIsAtmAdapter)
            {
                hrReconfig = HrReconfigAtmArp(pAdapter, pICallback);

                
                if (hrReconfig != S_OK)
                {
                    TraceTag(ttidTcpip,"Notifying tcpip of ATM ARP cleint of parameter change returns failure, prompt for reboot ...");
                    hr = NETCFG_S_REBOOT;
                }
            }
            else if (pAdapter->m_fIs1394Adapter)
            {
                // $REVIEW JosephJ: I don't think we need to do
                // anything here, because we have no parameters to
                // change.
            }
            
            // ask for reboot if filter list has changed
            if (m_glbGlobalInfo.m_fEnableFiltering)
            {
                if (!fIsSameVstr(pAdapter->m_vstrTcpFilterList, pAdapter->m_vstrOldTcpFilterList) ||
                    !fIsSameVstr(pAdapter->m_vstrUdpFilterList, pAdapter->m_vstrOldUdpFilterList) ||
                    !fIsSameVstr(pAdapter->m_vstrIpFilterList,  pAdapter->m_vstrOldIpFilterList))
                {
                    TraceTag(ttidTcpip, "This is temporary, filter list changed, ask for reboot");
                    hr = NETCFG_S_REBOOT;
                }
            }
        }

        // Send Wanarp reconfig notification if necessary
        //
        else if (pAdapter->m_fIsWanAdapter && pAdapter->m_fNewlyChanged)
        {
            if (FAILED(HrReconfigWanarp(pAdapter, pICallback)))
            {
                TraceTag(ttidTcpip, "Wanarp failed its reconfig.  Need to reboot.");
                hr = NETCFG_S_REBOOT;
            }
        }
    }

    TraceError("CTcpipcfg::HrReconfigIp",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrReconfigAtmArp
//
//  Purpose:    Notify ATM ARP of configuration changes
//
//  Arguments:  none
//
//  Returns:    S_OK if success, NETCFG_S_REBOOT if failure
//
HRESULT CTcpipcfg::HrReconfigAtmArp(ADAPTER_INFO *pAdapterInfo,
                                    INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr = S_OK;

    // check if any parameter has changed
    DWORD dwFlag = 0;

    // arp server list
    if (!fIsSameVstr(pAdapterInfo->m_vstrARPServerList,
                     pAdapterInfo->m_vstrOldARPServerList))
    {
        dwFlag |= ATMARPC_RECONFIG_FLAG_ARPS_LIST_CHANGED;
    }

    // mar server list
    if (!fIsSameVstr(pAdapterInfo->m_vstrMARServerList,
                     pAdapterInfo->m_vstrOldMARServerList))
    {
        dwFlag |= ATMARPC_RECONFIG_FLAG_MARS_LIST_CHANGED;
    }

    // MTU
    if (pAdapterInfo->m_dwMTU != pAdapterInfo->m_dwOldMTU)
    {
        dwFlag |= ATMARPC_RECONFIG_FLAG_MTU_CHANGED;
    }

    // PVC Only
    if (pAdapterInfo->m_fPVCOnly != pAdapterInfo->m_fOldPVCOnly)
    {
        dwFlag |= ATMARPC_RECONFIG_FLAG_PVC_MODE_CHANGED;
    }

    if (dwFlag) // yep, some parameter has changed
    {

        tstring strIpConfigString = RGAS_TCPIP_PARAM_INTERFACES;
        strIpConfigString += pAdapterInfo->m_strTcpipBindPath;

        DWORD dwBytes = sizeof(IP_PNP_RECONFIG_REQUEST) +
                        sizeof(ATMARPC_PNP_RECONFIG_REQUEST) +
                        sizeof(USHORT) +
                        sizeof(WCHAR)*(strIpConfigString.length() + 1);

        PVOID pvBuf;
        hr = HrMalloc (dwBytes, &pvBuf);
        if (SUCCEEDED(hr))
        {
            BYTE* pbByte = reinterpret_cast<BYTE*>(pvBuf);

            // 1) fillup ip reconfig structure
            IP_PNP_RECONFIG_REQUEST * pIpReconfig =
                    reinterpret_cast<IP_PNP_RECONFIG_REQUEST *>(pbByte);

            pIpReconfig->version =1;
            // set valid offset
            pIpReconfig->arpConfigOffset = sizeof(IP_PNP_RECONFIG_REQUEST);

            // set rest to default
            // pIpReconfig->securityEnabled =0;
            // pIpReconfig->filterListUpdate =0;
            pIpReconfig->gatewayListUpdate =0;
            pIpReconfig->IPEnableRouter =0;

            // 2) fill up atmarp reconfig structure
            pbByte += sizeof(IP_PNP_RECONFIG_REQUEST);

            ATMARPC_PNP_RECONFIG_REQUEST * pAtmarpcReconfig =
                    reinterpret_cast<ATMARPC_PNP_RECONFIG_REQUEST *>(pbByte);

            pAtmarpcReconfig->Version = ATMARPC_RECONFIG_VERSION;
                pAtmarpcReconfig->OpType = ATMARPC_RECONFIG_OP_MOD_INTERFACE;

            // now set specifically what has changed
            pAtmarpcReconfig->Flags = dwFlag;

            // set the interface
            pAtmarpcReconfig->IfKeyOffset = sizeof(ATMARPC_PNP_RECONFIG_REQUEST);
            pbByte += sizeof(ATMARPC_PNP_RECONFIG_REQUEST);

            USHORT* puCount = reinterpret_cast<USHORT *>(pbByte);
            Assert (strIpConfigString.length() <= USHRT_MAX);
            *puCount = (USHORT)strIpConfigString.length();
            pbByte += sizeof(USHORT);

            WCHAR * pwszBindName = reinterpret_cast<WCHAR *>(pbByte);
            lstrcpyW(pwszBindName, strIpConfigString.c_str());

            TraceTag(ttidTcpip, "Sending notification to AtmArpC for adapter %S", pwszBindName);
            TraceTag(ttidTcpip, "OpType: %d", pAtmarpcReconfig->OpType);
            TraceTag(ttidTcpip, "Flags: %d", pAtmarpcReconfig->Flags);
            TraceTag(ttidTcpip, "WChar Count: %d", *puCount);

            // now send the notification
            hr = pICallback->SendPnpReconfig(NCRL_NDIS, c_szTcpip,
                                       pAdapterInfo->m_strTcpipBindPath.c_str(),
                                       pvBuf,
                                       dwBytes);

            //we dont want to request reboot if the error is ERROR_FILE_NOT_FOUND
            //because that means the card is not loaded by the stack yet. Usually this is 
            //because the card was disabled from the connection UI. When the card is re-enabled,
            //the statck will reload the card and load all settings from the registry. So a reboot
            //is not needed
            if (FAILED(hr) && HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
            {
                TraceError("pICallback->SendPnpReconfig to AtmArpC returns failure:", hr);
                hr = NETCFG_S_REBOOT;
            }

            MemFree(pvBuf);
        }
    }

    TraceError("CTcpipcfg::HrReconfigAtmArp",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::ReconfigNbt
//
//  Purpose:    Notify NetBt of configuration changes
//
//  Arguments:  none
//
//  Returns:    S_OK if success, NETCFG_S_REBOOT if failure
//
HRESULT CTcpipcfg::HrReconfigNbt(INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr = S_OK;

    NETBT_PNP_RECONFIG_REQUEST NetbtReconfigRequest;

    // DWORD version
    NetbtReconfigRequest.version = 1;

    // Notify NetBt of any wins address changes (per adapter)
    for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
         iterAdapter != m_vcardAdapterInfo.end();
         iterAdapter++) // for each adapter
    {
        ADAPTER_INFO * pAdapter = *iterAdapter;

        // If not wan adapter, and adapter is enabled
        if ((!pAdapter->m_fIsWanAdapter) &&
            (!pAdapter->m_fIsRasFakeAdapter) &&
            (pAdapter->m_BindingState == BINDING_ENABLE) &&
            (pAdapter->m_InitialBindingState != BINDING_DISABLE))
        {
            if ( (!fIsSameVstr(pAdapter->m_vstrWinsServerList,
                               pAdapter->m_vstrOldWinsServerList)) ||
                 (pAdapter->m_dwNetbiosOptions != pAdapter->m_dwOldNetbiosOptions))
            {
                TraceTag(ttidTcpip, "Sending notification to NetBt for per adapter parameter changes.");
                if ( FAILED( pICallback->SendPnpReconfig(NCRL_TDI, c_szNetBt,
                                                   pAdapter->m_strNetBtBindPath.c_str(),
                                                   NULL,
                                                   0)))
                {
                   TraceTag(ttidTcpip,"Notifying NetBt of Wins address change returns failure, prompt for reboot ...");
                   hr = NETCFG_S_REBOOT;
                };
            }
        }
    }

    // Notify NetBt of any global parameter changes
    if (m_fLmhostsFileSet ||
        (m_glbGlobalInfo.m_fEnableLmHosts != m_glbGlobalInfo.m_fOldEnableLmHosts))
    {
        TraceTag(ttidTcpip, "Sending notification to NetBt about NetBt parameter changes.");

        // $REVIEW(tongl 11/14/97): since we do need to send some notification to tcpip,
        // we need to read the correct value of "EnableDns" from registry
        // This is a temporary thing so Malam can keep the ability to reconfigure these
        // settings that used to be configurable in NT5 Beta1.
        // $REVIEW(nsun 04/14/99): Per MalaM, most users don't use this value and NetBT
        // will ignore this value. We should remove it from the data struct after Beta3.
        NetbtReconfigRequest.enumDnsOption = WinsThenDns;
        //     m_glbGlobalInfo.m_fDnsEnableWins ? WinsThenDns : DnsOnly;

        NetbtReconfigRequest.fScopeIdUpdated = FALSE;

        NetbtReconfigRequest.fLmhostsEnabled = !!m_glbGlobalInfo.m_fEnableLmHosts;
        NetbtReconfigRequest.fLmhostsFileSet = !!m_fLmhostsFileSet;

        TraceTag(ttidTcpip, "Sending notification to NetBt for global parameter changes.");
        TraceTag(ttidTcpip, "fLmhostsEnabled: %d", NetbtReconfigRequest.fLmhostsEnabled);
        TraceTag(ttidTcpip, "fLmhostsFileSet: %d", NetbtReconfigRequest.fLmhostsFileSet);

        if ( FAILED(pICallback->SendPnpReconfig(NCRL_TDI, c_szNetBt,
                                          c_szEmpty,
                                          &NetbtReconfigRequest,
                                          sizeof(NETBT_PNP_RECONFIG_REQUEST))) )
        {
           TraceTag(ttidTcpip,"Notifying NetBt component of DNS parameter change returns failure, prompt for reboot ...");
           hr = NETCFG_S_REBOOT;
        };
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::ReconfigDns
//
//  Purpose:    Notify DNS Cache resolver service of configuration changes
//
//  Arguments:  fDoReconfigWithoutCheckingParams
//                      default is FALSE
//                      if TRUE, then will do Dns reconfig with checking if there
//                      is paramter changes or not
//
//  Returns:    S_OK if success, NETCFG_S_REBOOT otherwise
//
HRESULT CTcpipcfg::HrReconfigDns(BOOL fDoReconfigWithoutCheckingParams)
{
    // Submit a generic reconfig notification to the service
    // if any of the DNS related parameters have changed.
    BOOL fDnsParamChanged = fDoReconfigWithoutCheckingParams;

    if (!fDnsParamChanged)
    {
        // Suffix list and UseDomainNameDevolution changed ?
        BOOL fDnsSuffixChanged =
             !fIsSameVstr(m_glbGlobalInfo.m_vstrDnsSuffixList,
                          m_glbGlobalInfo.m_vstrOldDnsSuffixList);

        if (fDnsSuffixChanged) // suffix changed
        {
            fDnsParamChanged = TRUE;
        }
        else if (m_glbGlobalInfo.m_vstrDnsSuffixList.size() == 0)
        {
            if (m_glbGlobalInfo.m_fUseDomainNameDevolution !=
                m_glbGlobalInfo.m_fOldUseDomainNameDevolution)
                fDnsParamChanged = TRUE;
        }
    }

    // $REVIEW(tongl 6/19/98): DNS also cares about IP address, subnet mask & gateway changes
    if (!fDnsParamChanged)
    {
        // Has any IP setting changed ?
        for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
             iterAdapter != m_vcardAdapterInfo.end();
             iterAdapter++)
        {
            ADAPTER_INFO* pAdapter = *iterAdapter;

            // If not wan adapter
            if (!pAdapter->m_fIsWanAdapter)
            {
                if ( ((!!pAdapter->m_fEnableDhcp) !=
                                    (!!pAdapter->m_fOldEnableDhcp)) ||
                     (!fIsSameVstr(pAdapter->m_vstrIpAddresses,
                                   pAdapter->m_vstrOldIpAddresses)) ||
                     (!fIsSameVstr(pAdapter->m_vstrSubnetMask,
                                   pAdapter->m_vstrOldSubnetMask)) ||
                     (!fIsSameVstr(pAdapter->m_vstrDefaultGateway,
                                   pAdapter->m_vstrOldDefaultGateway)) ||
                     (!fIsSameVstr(pAdapter->m_vstrDefaultGatewayMetric,
                                   pAdapter->m_vstrOldDefaultGatewayMetric)) 
                  )
                {
                    fDnsParamChanged = TRUE;
                    break;
                }
            }
        }
    }

    HRESULT hr = S_OK;
    if (fDnsParamChanged)
    {
        TraceTag(ttidTcpip, "Sending notification to Dns about Dns and IP parameter changes.");

        hr = HrSendServicePnpEvent(c_szSvcDnscache,
                        SERVICE_CONTROL_PARAMCHANGE);
        if (FAILED(hr))
        {
            if (HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE) == hr)
            {
                TraceTag(ttidTcpip,"Notifying dnscache service of parameter change failed because DNS cache is not active.");
                hr = S_OK;
            }
            else
            {
                TraceTag(ttidTcpip,"Notifying dnscache service of parameter change failed, prompt for reboot ...");
                hr = NETCFG_S_REBOOT;
            }
        }
    }

    TraceError("CTcpipcfg::HrReconfigDns",hr);
    return hr;
}

HRESULT CTcpipcfg::HrReconfigWanarp(ADAPTER_INFO *pAdapterInfo, 
                                    INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr;
    DWORD   cbInfo;
    WANARP_RECONFIGURE_INFO* pInfo;

    const IFACECOL& Ifaces = pAdapterInfo->m_IfaceIds;

    cbInfo = sizeof(WANARP_RECONFIGURE_INFO) + (sizeof(GUID) * Ifaces.size());

    hr = HrMalloc(cbInfo, (PVOID*)&pInfo);
    if (SUCCEEDED(hr))
    {
        // Populate the data in the WANARP_RECONFIGURE_INFO structure.
        //
        INT nIndex;

        pInfo->dwVersion = WANARP_RECONFIGURE_VERSION;
        pInfo->wrcOperation = WRC_ADD_INTERFACES;
        pInfo->ulNumInterfaces = Ifaces.size();

        IFACECOL::const_iterator iter;
        for (iter = Ifaces.begin(), nIndex = 0; iter != Ifaces.end();
             iter++, nIndex++)
        {
            pInfo->rgInterfaces[nIndex] = *iter;
        }

        TraceTag(ttidNetCfgPnp, "Sending NDIS reconfig Pnp event to Upper:%S "
            "lower: %S for %d interfaces",
            c_szTcpip,
            pAdapterInfo->m_strTcpipBindPath.c_str(),
            pInfo->ulNumInterfaces);

        hr  = pICallback->SendPnpReconfig(NCRL_NDIS, c_szTcpip,
                    pAdapterInfo->m_strTcpipBindPath.c_str(),
                    pInfo,
                    cbInfo);

        // Send the notification.
        //
        MemFree(pInfo);
    }

    TraceError("CTcpipcfg::HrReconfigWanarp",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSetActiveIpsecPolicy
//
//  Purpose:    Set a user chosen local policy
//
//  Arguments:  none
//
//  Returns:    S_OK if success, NETCFG_S_REBOOT otherwise
//
//IPSec is removed from connection UI   
/*
HRESULT CTcpipcfg::HrSetActiveIpsecPolicy()
{
    HRESULT hr = S_OK;

    AssertSz(m_glbGlobalInfo.m_strIpsecPol != c_szIpsecUnset, "Ipsec policy unset ?");

    if (m_glbGlobalInfo.m_strIpsecPol != c_szIpsecUnset)
    {
        // load the polstore dll & get export function
        typedef HRESULT (WINAPI * PFNHrSetAssignedLocalPolicy)(GUID * pActivePolId);

        HMODULE hPolStore;
        FARPROC pfn;

        hr = HrLoadLibAndGetProc (L"polstore.dll",
                                  "HrSetAssignedLocalPolicy",
                                  &hPolStore, &pfn);

        if (S_OK == hr)
        {
            Assert(hPolStore != NULL);
            Assert(pfn != NULL);

            PFNHrSetAssignedLocalPolicy pfnHrSetAssignedLocalPolicy =
                            reinterpret_cast<PFNHrSetAssignedLocalPolicy>(pfn);

            if (m_glbGlobalInfo.m_strIpsecPol == c_szIpsecNoPol)
            {
                // no ipsec
                TraceTag(ttidTcpip, "Calling HrSetAssignedLocalPolicy with NULL.");
                hr = (*pfnHrSetAssignedLocalPolicy)(NULL);
                TraceTag(ttidTcpip, "HrSetActivePolicy returns hr: %x", hr);
            }
            else
            {
                WCHAR szPolicyGuid[c_cchGuidWithTerm];
                BOOL fSucceeded = StringFromGUID2(m_glbGlobalInfo.m_guidIpsecPol,
                                                  szPolicyGuid,
                                                  c_cchGuidWithTerm);

                TraceTag(ttidTcpip, "Calling HrSetActivePolicy with %S.", szPolicyGuid);
                hr = (*pfnHrSetAssignedLocalPolicy)(&(m_glbGlobalInfo.m_guidIpsecPol));
                TraceTag(ttidTcpip, "HrSetAssignedLocalPolicy returns hr: %x", hr);
            }

            if (FAILED(hr))
            {
                TraceError("Failed setting active ipsec policy.", hr);
                NcMsgBoxWithWin32ErrorText(DwWin32ErrorFromHr(hr),
                                           _Module.GetResourceInstance(),
                                           ::GetActiveWindow(),
                                           IDS_MSFT_TCP_TEXT,
                                           IDS_WIN32_ERROR_FORMAT,
                                           IDS_SET_IPSEC_FAILED,
                                           MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
                hr = S_OK;
            }

            FreeLibrary (hPolStore);
        }
        else
        {
            TraceTag(ttidTcpip,"Failed to get function HrSetActivePolicy from polstore.dll");
            hr = S_OK;
        }
    }

    TraceError("CTcpipcfg::HrSetActiveIpsecPolicy", hr);
    return hr;
}
*/

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSaveMultipleInterfaceWanRegistry
//
//  Purpose:    For WAN adapters with multiple interfaces, we need to check every
//              interface to see if it is newly added. If so, create the interface
//              subkey and set the default settings
//
//  Arguments:  hkeyInterface   CCS\Services\Tcpip\Parameters\Interfaces key
//              pAdapter        ADAPTER_INFO pointer to settings of the WAN adapter
//
//  Returns:    S_OK if success, E_FAIL otherwise
//
//  Author:     nsun 08/29/98

HRESULT CTcpipcfg::HrSaveMultipleInterfaceWanRegistry(const HKEY hkeyInterfaces,
                                                      ADAPTER_INFO* pAdapter)
{
    HRESULT hr = S_OK;

    IFACEITER   iterId;
    tstring     strInterfaceName;

    for (iterId  = pAdapter->m_IfaceIds.begin();
         iterId != pAdapter->m_IfaceIds.end();
         iterId ++)
    {
        GetInterfaceName(
                pAdapter->m_strTcpipBindPath.c_str(),
                *iterId,
                &strInterfaceName);

        HRESULT hrTmp;
        HKEY hkeyInterfaceParam;
        DWORD dwDisposition;

        hrTmp = HrRegCreateKeyEx(hkeyInterfaces,
                                 strInterfaceName.c_str(),
                                 REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                                 &hkeyInterfaceParam, &dwDisposition);
        if (SUCCEEDED(hrTmp))
        {
            //We don't set default settings if the WAN interface is NOT newly added.
            if (REG_CREATED_NEW_KEY == dwDisposition)
            {
                hrTmp = HrRegSetDword(hkeyInterfaceParam,
                                      RGAS_USEZEROBROADCAST,
                                      0);
                if (SUCCEEDED(hr))
                    hr = hrTmp;

                if (SUCCEEDED(hrTmp))
                    hrTmp = HrSaveStaticWanRegistry(hkeyInterfaceParam);
            }

            RegCloseKey(hkeyInterfaceParam);
        }

        if (SUCCEEDED(hr))
            hr = hrTmp;
    }

    TraceError("CTcpipcfg::HrSaveTcpipRegistry", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSaveWinsMultipleInterfaceWanRegistry
//
//  Purpose:    For WAN adapters with multiple interfaces, create the interface
//              subkeys and set the default settings
//
//  Arguments:  hkeyInterface   CCS\Services\NetBT\Parameters\Interfaces key
//              pAdapter        ADAPTER_INFO pointer to settings of the WAN adapter
//
//  Returns:    S_OK if success, E_FAIL otherwise
//
//  Author:     nsun 10/05/98

HRESULT CTcpipcfg::HrSaveWinsMultipleInterfaceWanRegistry(const HKEY hkeyInterfaces,
                                                      ADAPTER_INFO* pAdapter)
{
    HRESULT hr = S_OK;
    IFACEITER   iterId;
    tstring     strInterfaceName;

    for (iterId  = pAdapter->m_IfaceIds.begin();
         iterId != pAdapter->m_IfaceIds.end();
         iterId++)
    {
        GetInterfaceName(
                pAdapter->m_strNetBtBindPath.c_str(),
                *iterId,
                &strInterfaceName);

        strInterfaceName.insert(0, c_szTcpip_);

        HRESULT hrTmp;
        HKEY hkeyInterfaceParam;
        DWORD dwDisposition;

        hrTmp = HrRegCreateKeyEx(hkeyInterfaces,
                                 strInterfaceName.c_str(),
                                 REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                                 &hkeyInterfaceParam, &dwDisposition);
        if (SUCCEEDED(hrTmp))
        {
            //We don't set default settings if the WAN interface is NOT newly added.
            if (REG_CREATED_NEW_KEY == dwDisposition)
            {
                VSTR vstrNameServerList;

                hrTmp = HrRegSetColString(hkeyInterfaceParam,
                                         RGAS_NETBT_NAMESERVERLIST,
                                         vstrNameServerList);
                if (SUCCEEDED(hr))
                    hr = hrTmp;
            }

            RegCloseKey(hkeyInterfaceParam);
        }

        if (SUCCEEDED(hr))
            hr = hrTmp;
    }

    TraceError("CTcpipcfg::HrSaveTcpipRegistry", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSaveStaticWanRegistry
//
//  Purpose:    Write static parameters for Wan adapters to registry
//
//  Arguments:  none
//
//  Returns:    S_OK if success, E_FAIL otherwise
//

HRESULT CTcpipcfg::HrSaveStaticWanRegistry(HKEY hkeyInterfaceParam)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp;

    // EnableDHCP = 0
    // IPAddress = 0.0.0.0
    // SubnetMask = 0.0.0.0
    // DefaultGateWay =

    hrTmp = HrRegSetBool(hkeyInterfaceParam,
                RGAS_ENABLE_DHCP, FALSE);

    hr = hrTmp;

    hrTmp = HrRegSetMultiSz(hkeyInterfaceParam,
                RGAS_IPADDRESS, L"0.0.0.0\0");

    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetMultiSz(hkeyInterfaceParam,
                RGAS_SUBNETMASK, L"0.0.0.0\0");

    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetMultiSz(hkeyInterfaceParam,
                RGAS_DEFAULTGATEWAY, L"\0");

    if (SUCCEEDED(hr))
        hr = hrTmp;

    //(nsun 11/02/98) set static RRAS parameters for unattended install

    hrTmp = HrRegSetBool(hkeyInterfaceParam,
                          c_szDeadGWDetect,
                          m_glbGlobalInfo.m_fDeadGWDetectDefault);
    if (SUCCEEDED(hr))
        hr = hrTmp;

    hrTmp = HrRegSetBool(hkeyInterfaceParam,
                          c_szDontAddDefaultGateway,
                          m_glbGlobalInfo.m_fDontAddDefaultGatewayDefault);

    if (SUCCEEDED(hr))
        hr = hrTmp;


    TraceError("CTcpipcfg::HrSaveStaticWanRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTcpipcfg::HrSaveStaticAtmRegistry
//
//  Purpose:    Write static parameters for Wan adapters to registry
//
//  Arguments:  none
//
//  Returns:    S_OK if success, E_FAIL otherwise
//
HRESULT CTcpipcfg::HrSaveStaticAtmRegistry(HKEY hkeyInterfaceParam)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    HKEY hkeyAtmarpc;
    DWORD dwDisposition;

    // Open the Atmarpc subkey
    hrTmp = HrRegCreateKeyEx(hkeyInterfaceParam,
                             c_szAtmarpc,
                             REG_OPTION_NON_VOLATILE,
                             KEY_READ_WRITE,
                             NULL,
                             &hkeyAtmarpc,
                             &dwDisposition);

    if (SUCCEEDED(hrTmp))
    {
        // SapSelector
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_SapSelector,
                              c_dwSapSelector);
        hr = hrTmp;

        // AddressResolutionTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_AddressResolutionTimeout,
                              c_dwAddressResolutionTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // ARPEntryAgingTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_ARPEntryAgingTimeout,
                              c_dwARPEntryAgingTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // InARPWaitTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_SapSelector,
                              c_dwSapSelector);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MaxRegistrationAttempts
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_InARPWaitTimeout,
                              c_dwInARPWaitTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MaxResolutionAttempts
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MaxResolutionAttempts,
                              c_dwMaxResolutionAttempts);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MinWaitAfterNak
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_SapSelector,
                              c_dwSapSelector);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // ServerConnectInterval
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MinWaitAfterNak,
                              c_dwMinWaitAfterNak);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // ServerRefreshTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_ServerRefreshTimeout,
                              c_dwServerRefreshTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // ServerRegistrationTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_ServerRegistrationTimeout,
                              c_dwServerRegistrationTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // DefaultVcAgingTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_DefaultVcAgingTimeout,
                              c_dwDefaultVcAgingTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MARSConnectInterval
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MARSConnectInterval,
                              c_dwMARSConnectInterval);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MARSRegistrationTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MARSRegistrationTimeout,
                              c_dwMARSRegistrationTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // JoinTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_JoinTimeout,
                              c_dwJoinTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // LeaveTimeout
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_LeaveTimeout,
                              c_dwLeaveTimeout);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        // MaxDelayBetweenMULTIs
        hrTmp = HrRegSetDword(hkeyAtmarpc,
                              c_szREG_MaxDelayBetweenMULTIs,
                              c_dwMaxDelayBetweenMULTIs);
        if (SUCCEEDED(hr))
            hr = hrTmp;

        RegCloseKey(hkeyAtmarpc);
    }

    TraceError("CTcpipcfg::HrSaveStaticAtmRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     ReInitializeInternalState
//
//  Purpose:   Reinitialize internal state at the end of Apply if Apply SUCCEEDED
//
//  Arguments:
//
//  Returns:    None
//  Author:     tongl  4 Sept 1997
//  Notes:      Fix bug# 105383
//
//
void CTcpipcfg::ReInitializeInternalState()
{
    // Reset global and adapter parameter values if necessary
    if (m_fSaveRegistry || m_fReconfig)
    {
        m_glbGlobalInfo.ResetOldValues();


        for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
                 iterAdapter != m_vcardAdapterInfo.end();
                 iterAdapter++)
        {
            ADAPTER_INFO* pAdapter = *iterAdapter;
            pAdapter->ResetOldValues();
        }
    }

    // Reset internal flags
    m_fRemoving = FALSE;
    m_fInstalling = FALSE;

    m_fSaveRegistry = FALSE;
    m_fReconfig = FALSE;

    // Initialize the netbt_pnp_reconfig_request structure
    m_fLmhostsFileSet = FALSE;
}

// This functions adds a new RAS fake GUID directly to our memory structure,
// and loads info from the RAS phone book.
HRESULT CTcpipcfg::UpdateRasAdapterInfo(
    const RASCON_IPUI& RasInfo)
{
    HRESULT hr;
    ADAPTER_INFO* pAdapter;

    hr = S_OK;
    m_fSaveRegistry = TRUE;

    WCHAR szGuid [c_cchGuidWithTerm];
    StringFromGUID2(RasInfo.guidConnection, szGuid, c_cchGuidWithTerm);

    pAdapter = PAdapterFromInstanceGuid(&RasInfo.guidConnection);
    if (!pAdapter)
    {
        pAdapter = new ADAPTER_INFO;
        hr = pAdapter->HrSetDefaults(&RasInfo.guidConnection,
                                     c_szRasFakeAdapterDesc, szGuid, szGuid);
        if (SUCCEEDED(hr))
        {
            m_vcardAdapterInfo.push_back(pAdapter);

            pAdapter->m_fIsRasFakeAdapter = TRUE;
        }
        else
        {
            delete pAdapter;
            pAdapter = NULL;
            Assert (FAILED(hr));
        }
    }
    else
    {
        //We need to set default even if the ras connection is already in our adapter list
        //because we should update all the paramters based on the phone book
        hr = pAdapter->HrSetDefaults(&RasInfo.guidConnection,
                                     c_szRasFakeAdapterDesc, szGuid, szGuid);
        pAdapter->m_fIsRasFakeAdapter = TRUE;
    }

    if (SUCCEEDED(hr))
    {
        Assert (pAdapter);

        // Now see if we should overwrite some of the parameters
        // from what's in the phone book
        if (RasInfo.dwFlags & RCUIF_USE_IP_ADDR)
        {
            // use static IP address
            pAdapter->m_fEnableDhcp = FALSE;
            pAdapter->m_fOldEnableDhcp = FALSE;

            pAdapter->m_vstrIpAddresses.push_back(new tstring(RasInfo.pszwIpAddr));
            CopyVstr(&pAdapter->m_vstrOldIpAddresses,
                     pAdapter->m_vstrIpAddresses);

            // generate the subnet mask
            tstring strIpAddress = RasInfo.pszwIpAddr;
            tstring strSubnetMask;
            DWORD adwIpAddress[4];

            GetNodeNum(strIpAddress.c_str(), adwIpAddress);
            DWORD nValue = adwIpAddress[0];

            if (nValue <= SUBNET_RANGE_1_MAX)
            {
                strSubnetMask = c_szBASE_SUBNET_MASK_1;
            }
            else if (nValue <= SUBNET_RANGE_2_MAX)
            {
                strSubnetMask = c_szBASE_SUBNET_MASK_2;
            }
            else if (nValue <= SUBNET_RANGE_3_MAX)
            {
                strSubnetMask = c_szBASE_SUBNET_MASK_3;
            }
            else
            {
                AssertSz(FALSE, "Invaid IP address ?");
            }

            pAdapter->m_vstrSubnetMask.push_back(new tstring(strSubnetMask.c_str()));
            CopyVstr(&pAdapter->m_vstrOldSubnetMask,
                     pAdapter->m_vstrSubnetMask);
        }

        if (RasInfo.dwFlags & RCUIF_USE_NAME_SERVERS)
        {
            // use DNS and WINS addresses
            if (RasInfo.pszwDnsAddr && lstrlenW(RasInfo.pszwDnsAddr))
                pAdapter->m_vstrDnsServerList.push_back(new tstring(RasInfo.pszwDnsAddr));

            if (RasInfo.pszwDns2Addr && lstrlenW(RasInfo.pszwDns2Addr))
                pAdapter->m_vstrDnsServerList.push_back(new tstring(RasInfo.pszwDns2Addr));

            CopyVstr(&pAdapter->m_vstrOldDnsServerList,
                     pAdapter->m_vstrDnsServerList);

            if (RasInfo.pszwWinsAddr && lstrlenW(RasInfo.pszwWinsAddr))
                pAdapter->m_vstrWinsServerList.push_back(new tstring(RasInfo.pszwWinsAddr));

            if (RasInfo.pszwWins2Addr && lstrlenW(RasInfo.pszwWins2Addr))
                pAdapter->m_vstrWinsServerList.push_back(new tstring(RasInfo.pszwWins2Addr));

            CopyVstr(&pAdapter->m_vstrOldWinsServerList,
                     pAdapter->m_vstrWinsServerList);
        }

        pAdapter->m_fUseRemoteGateway       = !!(RasInfo.dwFlags & RCUIF_USE_REMOTE_GATEWAY);
        pAdapter->m_fUseIPHeaderCompression = !!(RasInfo.dwFlags & RCUIF_USE_HEADER_COMPRESSION);
        pAdapter->m_dwFrameSize = RasInfo.dwFrameSize;
        pAdapter->m_fIsDemandDialInterface = !!(RasInfo.dwFlags & RCUIF_DEMAND_DIAL);
        
        pAdapter->m_fDisableDynamicUpdate = !!(RasInfo.dwFlags & RCUIF_USE_DISABLE_REGISTER_DNS);
        pAdapter->m_fOldDisableDynamicUpdate = pAdapter->m_fDisableDynamicUpdate;
        
        pAdapter->m_fEnableNameRegistration = !!(RasInfo.dwFlags & RCUIF_USE_PRIVATE_DNS_SUFFIX);
        pAdapter->m_fOldEnableNameRegistration = pAdapter->m_fEnableNameRegistration;

        if (RasInfo.dwFlags & RCUIF_ENABLE_NBT)
        {
            pAdapter->m_dwNetbiosOptions = c_dwEnableNetbios;
            pAdapter->m_dwOldNetbiosOptions = c_dwEnableNetbios;
        }
        else
        {
            pAdapter->m_dwNetbiosOptions = c_dwDisableNetbios;
            pAdapter->m_dwOldNetbiosOptions = c_dwDisableNetbios;
        }

        pAdapter->m_strDnsDomain = RasInfo.pszwDnsSuffix;
        pAdapter->m_strOldDnsDomain = pAdapter->m_strDnsDomain;
    }

    TraceError("CTcpipcfg::UpdateRasAdapterInfo", hr);
    return hr;
}

HRESULT CTcpipcfg::HrDuplicateToNT4Location(HKEY hkeyInterface, ADAPTER_INFO * pAdapter)
{
    Assert(hkeyInterface);
    Assert(pAdapter);

    HRESULT hr = S_OK;

    HKEY hkeyServices = NULL;
    HKEY hkeyNt4 = NULL;

    DWORD   dwDisposition;
    tstring strNt4SubKey = pAdapter->m_strBindName;
    strNt4SubKey += c_szRegParamsTcpip;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegServices,
                    KEY_READ, &hkeyServices);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrRemoveNt4DuplicateRegistry: Failed to open the Services reg key, hr: %x", hr);
        goto LERROR;
    }

    hr = HrRegCreateKeyEx(hkeyServices, strNt4SubKey.c_str(),
                    REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                    &hkeyNt4, &dwDisposition);

    if (SUCCEEDED(hr))
    {
        HRESULT hrRead = S_OK;
        HRESULT hrWrite = S_OK;

        //Grant Network service and Netcfg OP the access to the NT4 key if
        //this is a newly created key
        //if the keys already have the ACEs, then the APIs wont add duplicate ones
        //We ignore the return value since nothing can be done if it failed
        //Also this is not critical for the system to run
        if (REG_CREATED_NEW_KEY == dwDisposition)
        {
            HrSetSecurityForNetConfigOpsOnSubkeys(hkeyServices, strNt4SubKey.c_str());
            HrSetSecurityForNetSvcOnSubkeys(hkeyServices, strNt4SubKey.c_str());
        }
        

        UINT cValues = sizeof(s_rgNt4Values)/sizeof(*s_rgNt4Values);
        VSTR vstrTmp;
        tstring strTmp;
        DWORD   dwTmp;
        BOOL    fTmp;

        for (UINT i = 0; i < cValues; i++)
        {
            switch(s_rgNt4Values[i].dwType)
            {
            case REG_BOOL:
                hrRead = HrRegQueryDword(hkeyInterface,
                                       s_rgNt4Values[i].pszValueName,
                                       &dwTmp);
                if (SUCCEEDED(hrRead))
                {
                    fTmp = !!dwTmp;
                    hrWrite = HrRegSetBool(hkeyNt4,
                                          s_rgNt4Values[i].pszValueName,
                                          fTmp);
                }
                break;

            case REG_DWORD:
                hrRead = HrRegQueryDword(hkeyInterface,
                                        s_rgNt4Values[i].pszValueName,
                                        &dwTmp);
                if (SUCCEEDED(hrRead))
                    hrWrite = HrRegSetDword(hkeyNt4,
                                          s_rgNt4Values[i].pszValueName,
                                          dwTmp);

                break;

            case REG_SZ:
                hrRead = HrRegQueryString(hkeyInterface,
                                            s_rgNt4Values[i].pszValueName,
                                            &strTmp);
                if (SUCCEEDED(hrRead))
                    hrWrite = HrRegSetString(hkeyNt4,
                                           s_rgNt4Values[i].pszValueName,
                                           strTmp);
                break;

            case REG_MULTI_SZ:
               hrRead = HrRegQueryColString( hkeyInterface,
                                             s_rgNt4Values[i].pszValueName,
                                             &vstrTmp);

                if (SUCCEEDED(hrRead))
                {
                    hrWrite = HrRegSetColString(hkeyNt4,
                                            s_rgNt4Values[i].pszValueName,
                                            vstrTmp);
                    DeleteColString(&vstrTmp);
                }
                break;
            }

#ifdef ENABLETRACE
            if(FAILED(hrRead))
            {
                TraceTag(ttidTcpip, "HrDuplicateToNT4Location: Failed on loading %S, hr: %x",
                             s_rgNt4Values[i].pszValueName, hr);
            }

            if(FAILED(hrWrite))
            {
                TraceTag(ttidError,
                    "HrDuplicateToNT4Location: failed to write %S to the registry. hr = %x.",
                    s_rgNt4Values[i].pszValueName, hrWrite);
            }
#endif

            if (SUCCEEDED(hr))
                hr = hrWrite;
        }

        RegSafeCloseKey(hkeyNt4);
    }

    RegSafeCloseKey(hkeyServices);

LERROR:
    TraceError("CTcpipcfg::HrDuplicateToNT4Location", hr);
    return hr;
}


//To solve the compatibility issues of non-nt5 applications, we duplicate some important
//per interface tcpip parameters to the old NT4 location: Services\{adapter GUID}\Parameters\Tcpip
//We need to clean it up when removing tcpip
HRESULT CTcpipcfg::HrRemoveNt4DuplicateRegistry()
{
    //we also need to delete the duplicate reg values under Services\{adapter GUID}
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;
    HKEY    hkeyServices = NULL;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegServices,
                    KEY_READ_WRITE_DELETE, &hkeyServices);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrRemoveNt4DuplicateRegistry: Failed to open the Services reg key, hr: %x", hr);
    }
    else
    {
        for (VCARD::iterator iterAdapter = m_vcardAdapterInfo.begin();
             iterAdapter != m_vcardAdapterInfo.end();
             iterAdapter++)
        {
            ADAPTER_INFO* pAdapter = *iterAdapter;

            if (!pAdapter->m_fIsWanAdapter && !pAdapter->m_fIsRasFakeAdapter)
            {
                hrTmp = HrRegDeleteKeyTree(hkeyServices, pAdapter->m_strBindName.c_str());

#ifdef ENABLETRACE
                if (FAILED(hrTmp))
                {
                    TraceTag(ttidTcpip, "CTcpipcfg::HrRemoveNt4DuplicateRegistry");
                    TraceTag(ttidTcpip, "Failed on deleting duplicated Nt4 layout key: Services\\%S, hr: %x",
                             pAdapter->m_strBindName.c_str(), hrTmp);
                }
#endif
            }
        }

        RegSafeCloseKey(hkeyServices);
    }

    TraceError("CTcpipcfg::HrRemoveNt4DuplicateRegistry", hr);
    return hr;
}


HRESULT CTcpipcfg::HrCleanUpPerformRouterDiscoveryFromRegistry()
{
    HRESULT hr = S_OK;
    HKEY    hkey = NULL;

    hr = m_pnccTcpip->OpenParamKey(&hkey);
    
    if (SUCCEEDED(hr))
    {
        Assert(hkey);

        HRESULT hrTemp = S_OK;
        
        //delete the global PerformRouterDiscoveryDefault value
        hrTemp = HrRegDeleteValue(hkey,
                        c_szPerformRouterDiscoveryDefault);
        
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTemp)
            hrTemp = S_OK;

        if (SUCCEEDED(hr))
            hr = hrTemp;

        HKEY hkeyInterfaces = NULL;
        hrTemp = HrRegOpenKeyEx(hkey, 
                            c_szInterfacesRegKey, 
                            KEY_READ,
                            &hkeyInterfaces);

        if (SUCCEEDED(hrTemp) && hkeyInterfaces)
        {
            WCHAR szBuf[256];
            DWORD dwSize = celems(szBuf);
            FILETIME time;
            DWORD dwRegIndex = 0;

            while (SUCCEEDED(hrTemp = HrRegEnumKeyEx(hkeyInterfaces,
                                            dwRegIndex++,
                                            szBuf,
                                            &dwSize,
                                            NULL,
                                            NULL,
                                            &time)))
            {
                HKEY hkeyIf = NULL;

                dwSize = celems(szBuf);
                hrTemp = HrRegOpenKeyEx(hkeyInterfaces,
                                szBuf,
                                KEY_READ_WRITE_DELETE,
                                &hkeyIf);
                
                if (SUCCEEDED(hr))
                    hr = hrTemp;

                if (SUCCEEDED(hrTemp))
                {
                    Assert(hkeyIf);

                    DWORD dwTemp = 0;
                    hrTemp = HrRegQueryDword(hkeyIf,
                                            c_szPerformRouterDiscovery,
                                            &dwTemp);
                    if (SUCCEEDED(hrTemp))
                    {
                        if (IP_IRDP_DISABLED != dwTemp)
                        {
                            hrTemp = HrRegDeleteValue(hkeyIf,
                                            c_szPerformRouterDiscovery);

                            if (SUCCEEDED(hr))
                                hr = hrTemp;
                        }

                    }
                    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTemp)
                    {
                        hrTemp = S_OK;
                    }
                    
                    if (SUCCEEDED(hr))
                        hr = hrTemp;

                    RegSafeCloseKey(hkeyIf);
                }

            }

            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hrTemp)
                hrTemp = S_OK;

            if (SUCCEEDED(hr))
                hr = hrTemp;

            RegSafeCloseKey(hkeyInterfaces);
        }

        
        RegSafeCloseKey(hkey);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    TraceError("CTcpipcfg::HrCleanUpPerformRouterDiscoveryFromRegistry", hr);
    return hr;
}


HRESULT CTcpipcfg::HrSaveBackupTcpSettings(HKEY hkeyInterfaceParam, ADAPTER_INFO * pAdapter)
{
    HRESULT hr = S_OK;

    HKEY hkeyDhcpConfigs = NULL;
    HKEY hkeyDhcpCfg = NULL;
    DWORD dwDisposition = 0;
    tstring strConfigurationName;
    tstring strReg;

    if (!pAdapter->m_BackupInfo.m_fAutoNet)
    {
        //Set the Configuration option name as "Alternate_{Interface GUID}"
        strConfigurationName = c_szAlternate;
        strConfigurationName += pAdapter->m_strBindName;

        //construct the NULL terminator for the Multi_SZ
        int cch = strConfigurationName.length() + 2;
        WCHAR * pwsz = new WCHAR[cch];
        if (NULL == pwsz)
            return E_OUTOFMEMORY;

        ZeroMemory(pwsz, sizeof(pwsz[0]) * cch);
        lstrcpyW(pwsz, strConfigurationName.c_str());

        hr = HrRegSetMultiSz(hkeyInterfaceParam,
                       c_szActiveConfigurations,
                       pwsz);

        delete [] pwsz;
    }
    else
    {
        hr = HrRegDeleteValue(hkeyInterfaceParam,
                        c_szActiveConfigurations);

        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            hr = S_OK;
    }


    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrSaveBackupTcpSettings: Failed to create ActiveConfigurations value, hr: %x", hr);
        goto LERROR;
    }

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDhcpConfigurations,
                    REG_OPTION_NON_VOLATILE, KEY_READ, NULL,
                    &hkeyDhcpConfigs, &dwDisposition);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrSaveBackupTcpSettings: Failed to open the Services reg key, hr: %x", hr);
        goto LERROR;
    }

    hr = HrRegCreateKeyEx(hkeyDhcpConfigs, strConfigurationName.c_str(),
                    REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                    &hkeyDhcpCfg, &dwDisposition);

    if (SUCCEEDED(hr))
    {
        DWORD           pdwOptionData[2];   // buffer holding the option's Dwords
        DWORD           dwIdxData;          // actual data to be saved into blob for each option

        LPBYTE          pRegRaw = NULL;     // buffer holding the blob
        DWORD           cb = 0;             // blob size in the pRegRaw buffer
        DWORD           cbMax = 0;          // pRegRaw buffer size (assert(cb<=cbMax))

        // fill in the blob pRegRaw to be written to the registry
        // 
        // fill in option 50 (requested IpAddress = Fallback IpAddress) 
        pdwOptionData[0] = htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strIpAddr.c_str()));
        // the adapter's address can't be an empty string hence a 0.0.0.0 address

        hr = HrSaveBackupDwordOption (
                OPTION_REQUESTED_ADDRESS,
                pdwOptionData,
                1,
                &pRegRaw,
                &cb,
                &cbMax);
        
        // fill in option 1 (Fallback subnet mask)
        if (hr == S_OK)
        {
            pdwOptionData[0] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strSubnetMask.c_str()));
            // the adapter's subnet mask can't be an empty string, hence a 0.0.0.0 address

            hr = HrSaveBackupDwordOption (
                    OPTION_SUBNET_MASK,
                    pdwOptionData,
                    1,
                    &pRegRaw,
                    &cb,
                    &cbMax);
        }

        // fill in option 3 if any Fallback gateway is specified
        if (hr == S_OK)
        {
            dwIdxData = 0;
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strDefGw.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);

            hr = HrSaveBackupDwordOption (
                    OPTION_ROUTER_ADDRESS,
                    pdwOptionData,
                    dwIdxData,
                    &pRegRaw,
                    &cb,
                    &cbMax);

        }

        // fill in option 6 if any Fallback DNS servers (maximum 2 supported for now) is specified
        if (hr == S_OK)
        {
            dwIdxData = 0;
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strPreferredDns.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strAlternateDns.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);

            hr = HrSaveBackupDwordOption (
                    OPTION_DOMAIN_NAME_SERVERS,
                    pdwOptionData,
                    dwIdxData,
                    &pRegRaw,
                    &cb,
                    &cbMax);
        }

        // fill in option 44 if any Fallback WINS servers (maximum 2 supported for now) is specified
        if (hr == S_OK)
        {
            dwIdxData = 0;
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strPreferredWins.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);
            pdwOptionData[dwIdxData] = 
                htonl(IPStringToDword(pAdapter->m_BackupInfo.m_strAlternateWins.c_str()));
            dwIdxData += (pdwOptionData[dwIdxData] != 0);

            hr = HrSaveBackupDwordOption (
                    OPTION_NETBIOS_NAME_SERVER,
                    pdwOptionData,
                    dwIdxData,
                    &pRegRaw,
                    &cb,
                    &cbMax);
        }

        // write the blob to the registry
        if (hr == S_OK)
        {
            hr = HrRegSetBinary(hkeyDhcpCfg,
                    c_szConfigOptions,
                    pRegRaw,
                    cb);
        }

        // free whatever mem was allocated
        if (pRegRaw != NULL)
            CoTaskMemFree(pRegRaw);


        RegSafeCloseKey(hkeyDhcpCfg);
    }

    RegSafeCloseKey(hkeyDhcpConfigs);

LERROR:
    return hr;
}

///////////////////////////////////////////////////////////////////
// Fills in a DHCP DWORD option into a blob. Adjusts the size of
// the buffer holding the blob if needed and returns through the
// out params the new buffer, its size and the size of the blob
// it contains.
HRESULT CTcpipcfg::HrSaveBackupDwordOption (
            /*IN*/      DWORD  Option,
            /*IN*/      DWORD  OptionData[],
            /*IN*/      DWORD  OptionDataSz,
            /*IN OUT*/  LPBYTE  *ppBuffer,
            /*IN OUT*/  LPDWORD pdwBlobSz,
            /*IN OUT*/  LPDWORD pdwBufferSz)
{
    DWORD           dwBlobSz;
    REG_BACKUP_INFO *pRegBackupInfo;
    DWORD           dwOptIdx;

    // if no data is available at all, then don't save anything
    if (OptionDataSz == 0)
        return S_OK;

    // calculate the memory size needed for the new updated blob.
    // don't forget, REG_BACKUP_INFO already contains one DWORD from the Option's data
    dwBlobSz = (*pdwBlobSz) + sizeof(REG_BACKUP_INFO) + (OptionDataSz-1)*sizeof(DWORD);

    // check whether the buffer is large enough to hold the new blob
    if ((*pdwBufferSz) < dwBlobSz)
    {
        HRESULT hr;
        LPBYTE  pNewBuffer;
        DWORD   dwBuffSz;

        // get the expected size of the new buffer
        dwBuffSz = (DWORD)(max((*pdwBufferSz) + BUFFER_ENLARGEMENT_CHUNK, dwBlobSz));

        // if the pointer provided is NULL...
        if (*ppBuffer == NULL)
        {
            // ...this means we have to do the initial allocation
            pNewBuffer = (LPBYTE)CoTaskMemAlloc(dwBuffSz);
        }
        else
        {
            // ...otherwise is just a buffer enlargement so do a
            // realloc in order to keep the original payload
            pNewBuffer = (LPBYTE)CoTaskMemRealloc((*ppBuffer), dwBuffSz);
                        
        }

        if (pNewBuffer == NULL)
            return E_OUTOFMEMORY;

        // starting from this point we don't expect any other errors
        // so start update the output parameters
        (*ppBuffer) = pNewBuffer;
        (*pdwBufferSz) += dwBuffSz;
    }

    // get the mem storage seen as a REG_BACKUP_INFO struct
    pRegBackupInfo = (REG_BACKUP_INFO *)((*ppBuffer) + (*pdwBlobSz));
    (*pdwBlobSz) = dwBlobSz;
    // update the blob by adding the new option
    pRegBackupInfo->dwOptionId   = Option;
    pRegBackupInfo->dwClassLen   = 0;           // fallback options don't have a class
    pRegBackupInfo->dwDataLen    = OptionDataSz * sizeof(DWORD);
    pRegBackupInfo->dwIsVendor   = 0;           // fallback options are not vendor options
    pRegBackupInfo->dwExpiryTime = 0x7fffffff;  // fallback options don't expire

    // add all the Option's data
    for (dwOptIdx = 0; dwOptIdx < OptionDataSz; dwOptIdx++)
    {
        pRegBackupInfo->dwData[dwOptIdx] = OptionData[dwOptIdx];
    }
    
    return S_OK;
}


HRESULT CTcpipcfg::HrLoadBackupTcpSettings(HKEY hkeyInterfaceParam, ADAPTER_INFO * pAdapter)
{
    HRESULT hr = S_OK;
    
    //construct the string "Alternate_{Interface GUID}"
    tstring strConfigurationName = c_szAlternate;
    strConfigurationName += pAdapter->m_strBindName;

    // if ActiveConfigurations contain a string "Alternate_{Interface GUID}"
    // then there is customized fall-back settings, otherwise Autonet
    VSTR vstrTmp;

    pAdapter->m_BackupInfo.m_fAutoNet = TRUE;
    hr = HrRegQueryColString( hkeyInterfaceParam,
                              c_szActiveConfigurations,
                              &vstrTmp);
    if (SUCCEEDED(hr))
    {
        BOOL fFound = FALSE;
        for (int i = 0; i < (int)vstrTmp.size(); i++)
        {
            if (strConfigurationName == *vstrTmp[i])
            {
                pAdapter->m_BackupInfo.m_fAutoNet = FALSE;
                break;
            }
        }

        DeleteColString(&vstrTmp);
    }


    tstring strReg = c_szDhcpConfigurations;
    strReg += _T("\\");
    strReg += strConfigurationName;

    HKEY hkeyDhcpConfig = NULL;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strReg.c_str(),
                    KEY_READ, &hkeyDhcpConfig);
    if (SUCCEEDED(hr))
    {
        LPBYTE pBackupInfoForReg = NULL;
        DWORD cb = 0;
        
        hr = HrRegQueryBinaryWithAlloc(hkeyDhcpConfig,
                                      c_szConfigOptions,
                                      &pBackupInfoForReg,
                                      &cb);

        if (SUCCEEDED(hr))
        {
            LPBYTE pRaw;

            pRaw = pBackupInfoForReg;
            while (cb >= sizeof(REG_BACKUP_INFO))
            {
                REG_BACKUP_INFO *pOption;

                pOption = (REG_BACKUP_INFO *)pRaw;

                // don't forget REG_BACKUP_INFO already contains one DWORD from
                // the data section. Although the statememnts below are somehow identical
                // the compiler is expected to optimize the code: one constant generated
                // at compile time for sizeof(REG_BACKUP_INFO) - sizeof(DWORD), and one
                // register only used in both lines below.
                cb   -= sizeof(REG_BACKUP_INFO) - sizeof(DWORD);
                pRaw += sizeof(REG_BACKUP_INFO) - sizeof(DWORD);

                // since cb is DWORD take special care to avoid roll over
                if (cb < pOption->dwDataLen)
                    break;

                cb   -= pOption->dwDataLen;
                pRaw += pOption->dwDataLen;

                HrLoadBackupOption(pOption, &pAdapter->m_BackupInfo);
            }

            MemFree(pBackupInfoForReg);
        }

        RegSafeCloseKey(hkeyDhcpConfig);
    }

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        //it's ok if the reg values are missing
        hr = S_OK;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////
// transfers data from the registry raw representation of the option
// to the corresponding fields from the BACKUP_CFG_INFO structure
//
HRESULT CTcpipcfg::HrLoadBackupOption(
        /*IN*/  REG_BACKUP_INFO *pOption,
        /*OUT*/ BACKUP_CFG_INFO *pBackupInfo)
{
    tstring *pIp1 = NULL;
    tstring *pIp2 = NULL;
    HRESULT hr = S_OK;

    // depending on what the option is, have pIp1 & pIp2 point to the 
    // fields to be filled in from BACKUP_CFG_INFO
    switch(pOption->dwOptionId)
    {
    case OPTION_REQUESTED_ADDRESS:
        pIp1 = &pBackupInfo->m_strIpAddr;
        break;
    case OPTION_SUBNET_MASK:
        pIp1 = &pBackupInfo->m_strSubnetMask;
        break;
    case OPTION_ROUTER_ADDRESS:
        pIp1 = &pBackupInfo->m_strDefGw;
        break;
    case OPTION_DOMAIN_NAME_SERVERS:
        pIp1 = &pBackupInfo->m_strPreferredDns;
        pIp2 = &pBackupInfo->m_strAlternateDns;
        break;
    case OPTION_NETBIOS_NAME_SERVER:
        pIp1 = &pBackupInfo->m_strPreferredWins;
        pIp2 = &pBackupInfo->m_strAlternateWins;
        break;
    default:
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // each option has at least one IpAddress value
    DwordToIPString(ntohl(pOption->dwData[0]), *pIp1);

    // if the option has more than one IpAddress (meaning two :-)
    // and if it is supposed to allow 2 addresses to be specified
    // then fill up the second field as well.
    if (pOption->dwDataLen > sizeof(DWORD) && pIp2 != NULL)
        DwordToIPString(ntohl(pOption->dwData[1]), *pIp2);

    return hr;
}

//Cleanup the backup settings registry under System\Services\dhcp
// wszAdapterName       GUID of the adapter of which we want to delete the registry
HRESULT CTcpipcfg::HrDeleteBackupSettingsInDhcp(LPCWSTR wszAdapterName)
{
    HRESULT hr = S_OK;
    HKEY hkeyDhcpConfigs = NULL;
    HKEY hkeyDhcpCfg = NULL;
    DWORD dwDisposition = 0;
    tstring strConfigurationName = c_szAlternate;
    strConfigurationName += wszAdapterName;;

    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szDhcpConfigurations,
                    REG_OPTION_NON_VOLATILE, KEY_READ_WRITE_DELETE, NULL,
                    &hkeyDhcpConfigs, &dwDisposition);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrDeleteBackupSettingsInDhcp: Failed to open the Services reg key, hr: %x", hr);
        goto LERROR;
    }

    hr = HrRegDeleteKeyTree(hkeyDhcpConfigs, strConfigurationName.c_str());

    RegSafeCloseKey(hkeyDhcpConfigs);
LERROR:
    return hr;
}

HRESULT CTcpipcfg::HrSetSecurityForNetConfigOpsOnSubkeys(HKEY hkeyRoot, LPCWSTR strKeyName)
{
    PSID psidGroup = NULL;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    HRESULT hr = S_OK;

    if (AllocateAndInitializeSid(&sidAuth, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS, 0, 0, 0, 0, 0, 0, &psidGroup))
    {
        CRegKeySecurity rkSecurity;

        hr = rkSecurity.RegOpenKey(hkeyRoot, strKeyName);

        if (SUCCEEDED(hr))
        {
            hr = rkSecurity.GetKeySecurity();
            if (SUCCEEDED(hr))
            {
                hr = rkSecurity.GrantRightsOnRegKey(psidGroup, KEY_READ_WRITE_DELETE, KEY_ALL);
            }
            rkSecurity.RegCloseKey();
        }
        
        FreeSid(psidGroup);
    }
    
    return hr;
}

HRESULT CTcpipcfg::HrSetSecurityForNetSvcOnSubkeys(HKEY hkeyRoot, LPCWSTR strKeyName)
{
    PSID psidNetSvc = NULL;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    HRESULT hr = S_OK;
    
    if (AllocateAndInitializeSid(&sidAuth, 1, SECURITY_NETWORK_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &psidNetSvc))
    {
        CRegKeySecurity rkSecurity;
        
        hr = rkSecurity.RegOpenKey(hkeyRoot, strKeyName);
        
        if (SUCCEEDED(hr))
        {
            hr = rkSecurity.GetKeySecurity();
            if (SUCCEEDED(hr))
            {
                hr = rkSecurity.GrantRightsOnRegKey(psidNetSvc, KEY_READ_WRITE_DELETE, KEY_ALL);
            }
            rkSecurity.RegCloseKey();
        }
        
        FreeSid(psidNetSvc);
    }
    
    return hr;
    
}

//Update the NT4 registry permission to grant Netcfg Op and Network Service access
//This is called during upgrade
HRESULT CTcpipcfg::HrUpdateNt4RegistryPermission()
{
    HRESULT hr = S_OK;
    HKEY hkeyServices = NULL;
    tstring strNt4SubKey;
    
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                c_szRegServices,
                KEY_READ, 
                &hkeyServices);

    if (FAILED(hr))
    {
        TraceTag(ttidTcpip, "HrUpdateNt4RegistryPermission: Failed to open the Services reg key, hr: %x", hr);
        return hr;
    }
    
    
    for(VCARD::iterator iterAdapter =  m_vcardAdapterInfo.begin();
    iterAdapter !=  m_vcardAdapterInfo.end();
    iterAdapter ++)
    {
        ADAPTER_INFO * pAdapter = *iterAdapter;
        if (pAdapter->m_fIsRasFakeAdapter || pAdapter->m_fIsWanAdapter)
        {
            continue;
        }
        
        strNt4SubKey = pAdapter->m_strBindName;
        strNt4SubKey += c_szRegParamsTcpip;
 
        //Grant Network service and Netcfg OP the access to the NT4 key
        //if the keys already have the ACEs, then the APIs wont add duplicate ones
        //
        //We ignore the return value since nothing can be done if it failed
        //Also this is not critical for the system to run
        HrSetSecurityForNetConfigOpsOnSubkeys(hkeyServices, strNt4SubKey.c_str());
        HrSetSecurityForNetSvcOnSubkeys(hkeyServices, strNt4SubKey.c_str());
    }

    RegSafeCloseKey(hkeyServices);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpip.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P . C P P
//
//  Contents:   Tcpip config memory structure member functions
//
//  Notes:
//
//  Author:     tongl 13 Nov, 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define _PNP_POWER_
#include "ntddip.h"
#undef _PNP_POWER_

#include "ncstl.h"
#include "tcpip.h"
#include "tcpconst.h"
#include "ncmisc.h"


void CopyVstr(VSTR * vstrDest, const VSTR & vstrSrc)
{
    FreeCollectionAndItem(*vstrDest);
    vstrDest->reserve(vstrSrc.size());

    for(VSTR_CONST_ITER iter = vstrSrc.begin(); iter != vstrSrc.end(); ++iter)
        vstrDest->push_back(new tstring(**iter));
}


//+---------------------------------------------------------------------------
//
//  Name:     ADAPTER_INFO::~ADAPTER_INFO
//
//  Purpose:   Destructor
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
ADAPTER_INFO::~ADAPTER_INFO()
{
    FreeCollectionAndItem(m_vstrIpAddresses);
    FreeCollectionAndItem(m_vstrOldIpAddresses);

    FreeCollectionAndItem(m_vstrSubnetMask);
    FreeCollectionAndItem(m_vstrOldSubnetMask);

    FreeCollectionAndItem(m_vstrDefaultGateway);
    FreeCollectionAndItem(m_vstrOldDefaultGateway);

    FreeCollectionAndItem(m_vstrDefaultGatewayMetric);
    FreeCollectionAndItem(m_vstrOldDefaultGatewayMetric);

    FreeCollectionAndItem(m_vstrDnsServerList);
    FreeCollectionAndItem(m_vstrOldDnsServerList);

    FreeCollectionAndItem(m_vstrWinsServerList);
    FreeCollectionAndItem(m_vstrOldWinsServerList);

    FreeCollectionAndItem(m_vstrARPServerList);
    FreeCollectionAndItem(m_vstrOldARPServerList);

    FreeCollectionAndItem(m_vstrMARServerList);
    FreeCollectionAndItem(m_vstrOldMARServerList);

    FreeCollectionAndItem(m_vstrTcpFilterList);
    FreeCollectionAndItem(m_vstrOldTcpFilterList);

    FreeCollectionAndItem(m_vstrUdpFilterList);
    FreeCollectionAndItem(m_vstrOldUdpFilterList);

    FreeCollectionAndItem(m_vstrIpFilterList);
    FreeCollectionAndItem(m_vstrOldIpFilterList);
}

//+---------------------------------------------------------------------------
//
//  Name:   ADAPTER_INFO::HrSetDefaults
//
//  Purpose:    Function to set all the default values of the ADAPTER_INFO
//              structure.  This is done whenever a new netcard is added
//              to the list of netcards before any real information is
//              added to the structure so that any missing parameters
//              are defaulted
//
//  Arguments:  pguidInstanceId
//              pszNetCardDescription
//              pszNetCardBindName
//              pszNetCardTcpipBindPath
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
HRESULT ADAPTER_INFO::HrSetDefaults(const GUID* pguidInstanceId,
                                    PCWSTR pszNetCardDescription,
                                    PCWSTR pszNetCardBindName,
                                    PCWSTR pszNetCardTcpipBindPath )
{
    Assert (pguidInstanceId);

    m_BackupInfo.m_fAutoNet = TRUE;
    m_BackupInfo.m_strIpAddr = c_szEmpty;
    m_BackupInfo.m_strSubnetMask = c_szEmpty;
    m_BackupInfo.m_strPreferredDns = c_szEmpty;
    m_BackupInfo.m_strAlternateDns = c_szEmpty;
    m_BackupInfo.m_strPreferredWins = c_szEmpty;
    m_BackupInfo.m_strAlternateWins = c_szEmpty;

    m_BindingState       = BINDING_UNSET;
    m_InitialBindingState= BINDING_UNSET;

    m_guidInstanceId     = *pguidInstanceId;
    m_strBindName        = pszNetCardBindName;
    m_strTcpipBindPath   = pszNetCardTcpipBindPath;
    m_strDescription     = pszNetCardDescription;

    // Create the "Services\NetBt\Adapters\<netcard bind path>" key
    // $REVIEW Since we don't have a
    // notification object for NetBt and NetBt has just been changed
    // to bind to Tcpip. For first checkin we hard code the netcard's
    // bindpath to be "Tcpip_"+<Bind path to Tcpip>

    m_strNetBtBindPath = c_szTcpip_;
    m_strNetBtBindPath += m_strTcpipBindPath;

    // $REVIEW(tongl 5/17): behaviour change: enable Dhcp is now the default
    m_fEnableDhcp        = TRUE;
    m_fOldEnableDhcp     = TRUE;

    FreeCollectionAndItem(m_vstrIpAddresses);
    FreeCollectionAndItem(m_vstrOldIpAddresses);

    FreeCollectionAndItem(m_vstrSubnetMask);
    FreeCollectionAndItem(m_vstrOldSubnetMask);

    FreeCollectionAndItem(m_vstrDefaultGateway);
    FreeCollectionAndItem(m_vstrOldDefaultGateway);

    FreeCollectionAndItem(m_vstrDefaultGatewayMetric);
    FreeCollectionAndItem(m_vstrOldDefaultGatewayMetric);

    m_strDnsDomain     = c_szEmpty;
    m_strOldDnsDomain  = c_szEmpty;

    m_fDisableDynamicUpdate = FALSE;
    m_fOldDisableDynamicUpdate = FALSE;

    m_fEnableNameRegistration = FALSE;
    m_fOldEnableNameRegistration = FALSE;

    FreeCollectionAndItem(m_vstrDnsServerList);
    FreeCollectionAndItem(m_vstrOldDnsServerList);

    FreeCollectionAndItem(m_vstrWinsServerList);
    FreeCollectionAndItem(m_vstrOldWinsServerList);

    m_dwNetbiosOptions = c_dwUnsetNetbios;
    m_dwOldNetbiosOptions = c_dwUnsetNetbios;

    m_dwInterfaceMetric               = c_dwDefaultIfMetric;
    m_dwOldInterfaceMetric            = c_dwDefaultIfMetric;

    // Filtering list
    FreeCollectionAndItem(m_vstrTcpFilterList);
    m_vstrTcpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrOldTcpFilterList);
    m_vstrOldTcpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrUdpFilterList);
    m_vstrUdpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrOldUdpFilterList);
    m_vstrOldUdpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrIpFilterList);
    m_vstrIpFilterList.push_back(new tstring(c_szDisableFiltering));

    FreeCollectionAndItem(m_vstrOldIpFilterList);
    m_vstrOldIpFilterList.push_back(new tstring(c_szDisableFiltering));

    // list of ARP server addresses
    FreeCollectionAndItem(m_vstrARPServerList);
    m_vstrARPServerList.push_back(new tstring(c_szDefaultAtmArpServer));

    FreeCollectionAndItem(m_vstrOldARPServerList);
    m_vstrOldARPServerList.push_back(new tstring(c_szDefaultAtmArpServer));

    // list of MAR server addresses
    FreeCollectionAndItem(m_vstrMARServerList);
    m_vstrMARServerList.push_back(new tstring(c_szDefaultAtmMarServer));

    FreeCollectionAndItem(m_vstrOldMARServerList);
    m_vstrOldMARServerList.push_back(new tstring(c_szDefaultAtmMarServer));

    // default is no support for mulitiple interfaces
    m_fIsMultipleIfaceMode = FALSE;
    m_IfaceIds.clear ();

    m_fBackUpSettingChanged = FALSE;

    // MTU
    m_dwMTU = c_dwDefaultAtmMTU;
    m_dwOldMTU = c_dwDefaultAtmMTU;

    // PVC only
    m_fPVCOnly = FALSE;
    m_fOldPVCOnly = FALSE;

    // RAS connection special parameters
    m_fUseRemoteGateway = TRUE;
    m_fUseIPHeaderCompression = TRUE;
    m_dwFrameSize = 1006;
    m_fIsDemandDialInterface = FALSE;

    // Set all special flags to FALSE
    m_fIsFromAnswerFile = FALSE;
    m_fIsAtmAdapter = FALSE;
    m_fIsWanAdapter = FALSE;
    m_fIs1394Adapter = FALSE;
    m_fIsRasFakeAdapter = FALSE;
    m_fDeleted = FALSE;
    m_fNewlyChanged = FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Name:     ADAPTER_INFO & ADAPTER_INFO::operator=
//
//  Purpose:   Copy operator
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
ADAPTER_INFO & ADAPTER_INFO::operator=(const ADAPTER_INFO & info)
{
    Assert(this != &info);

    if (this == &info)
        return *this;

    m_BackupInfo            = info.m_BackupInfo;
    m_BindingState          = info.m_BindingState;
    m_InitialBindingState   = info.m_InitialBindingState;

    m_guidInstanceId        = info.m_guidInstanceId;
    m_strDescription        = info.m_strDescription;
    m_strBindName           = info.m_strBindName;
    m_strTcpipBindPath      = info.m_strTcpipBindPath;
    m_strNetBtBindPath      = info.m_strNetBtBindPath;

    m_fEnableDhcp           = info.m_fEnableDhcp;
    m_fOldEnableDhcp        = info.m_fOldEnableDhcp;

    CopyVstr(&m_vstrIpAddresses, info.m_vstrIpAddresses);
    CopyVstr(&m_vstrOldIpAddresses, info.m_vstrOldIpAddresses);

    CopyVstr(&m_vstrSubnetMask, info.m_vstrSubnetMask);
    CopyVstr(&m_vstrOldSubnetMask, info.m_vstrOldSubnetMask);

    CopyVstr(&m_vstrDefaultGateway, info.m_vstrDefaultGateway);
    CopyVstr(&m_vstrOldDefaultGateway, info.m_vstrOldDefaultGateway);

    CopyVstr(&m_vstrDefaultGatewayMetric, info.m_vstrDefaultGatewayMetric);
    CopyVstr(&m_vstrOldDefaultGatewayMetric, info.m_vstrOldDefaultGatewayMetric);

    m_strDnsDomain      = info.m_strDnsDomain;
    m_strOldDnsDomain   = info.m_strOldDnsDomain;

    m_fDisableDynamicUpdate = info.m_fDisableDynamicUpdate;
    m_fOldDisableDynamicUpdate = info.m_fOldDisableDynamicUpdate;

    m_fEnableNameRegistration = info.m_fEnableNameRegistration;
    m_fOldEnableNameRegistration = info.m_fOldEnableNameRegistration;

    CopyVstr(&m_vstrDnsServerList, info.m_vstrDnsServerList);
    CopyVstr(&m_vstrOldDnsServerList, info.m_vstrOldDnsServerList);

    CopyVstr(&m_vstrWinsServerList, info.m_vstrWinsServerList);
    CopyVstr(&m_vstrOldWinsServerList, info.m_vstrOldWinsServerList);

    m_dwNetbiosOptions =    info.m_dwNetbiosOptions;
    m_dwOldNetbiosOptions = info.m_dwOldNetbiosOptions;

    m_dwInterfaceMetric             = info.m_dwInterfaceMetric;
    m_dwOldInterfaceMetric          = info.m_dwOldInterfaceMetric;

    CopyVstr(&m_vstrTcpFilterList, info.m_vstrTcpFilterList);
    CopyVstr(&m_vstrOldTcpFilterList, info.m_vstrOldTcpFilterList);

    CopyVstr(&m_vstrUdpFilterList, info.m_vstrUdpFilterList);
    CopyVstr(&m_vstrOldUdpFilterList, info.m_vstrOldUdpFilterList);

    CopyVstr(&m_vstrIpFilterList, info.m_vstrIpFilterList);
    CopyVstr(&m_vstrOldIpFilterList, info.m_vstrOldIpFilterList);

    m_fIsAtmAdapter = info.m_fIsAtmAdapter;
    if (m_fIsAtmAdapter)
    {
        CopyVstr(&m_vstrARPServerList, info.m_vstrARPServerList);
        CopyVstr(&m_vstrOldARPServerList, info.m_vstrOldARPServerList);

        CopyVstr(&m_vstrMARServerList, info.m_vstrMARServerList);
        CopyVstr(&m_vstrOldMARServerList, info.m_vstrOldMARServerList);

        m_dwMTU     = info.m_dwMTU;
        m_dwOldMTU  = info.m_dwOldMTU;

        m_fPVCOnly     = info.m_fPVCOnly;
        m_fOldPVCOnly  = info.m_fOldPVCOnly;
    }

    m_fIs1394Adapter = info.m_fIs1394Adapter;
    if (m_fIs1394Adapter)
    {
        // TODO currently no thing more to copy.
    }

    m_fIsRasFakeAdapter = info.m_fIsRasFakeAdapter;
    if (m_fIsRasFakeAdapter)
    {
        m_fUseRemoteGateway = info.m_fUseRemoteGateway;
        m_fUseIPHeaderCompression = info.m_fUseIPHeaderCompression;
        m_dwFrameSize = info.m_dwFrameSize;
        m_fIsDemandDialInterface = info.m_fIsDemandDialInterface;
    }

    m_fNewlyChanged = info.m_fNewlyChanged;

    m_fBackUpSettingChanged = info.m_fBackUpSettingChanged;

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Name: ADAPTER_INFO::ResetOldValues
//
//  Purpose:  This is for initializing the "old" values after the current values
//            are first loaded from registry, also for resetting the "old" values
//            to current ones when "Apply"(instead of "ok") is hit.
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
void ADAPTER_INFO::ResetOldValues()
{
    m_fOldEnableDhcp        = m_fEnableDhcp  ;

    CopyVstr(&m_vstrOldIpAddresses, m_vstrIpAddresses);
    CopyVstr(&m_vstrOldSubnetMask,  m_vstrSubnetMask);
    CopyVstr(&m_vstrOldDefaultGateway, m_vstrDefaultGateway);
    CopyVstr(&m_vstrOldDefaultGatewayMetric, m_vstrDefaultGatewayMetric);

    m_strOldDnsDomain = m_strDnsDomain;

    m_fOldDisableDynamicUpdate = m_fDisableDynamicUpdate;

    m_fOldEnableNameRegistration = m_fEnableNameRegistration;

    CopyVstr(&m_vstrOldDnsServerList,  m_vstrDnsServerList);
    CopyVstr(&m_vstrOldWinsServerList, m_vstrWinsServerList);

    m_dwOldNetbiosOptions = m_dwNetbiosOptions;

    m_dwOldInterfaceMetric          = m_dwInterfaceMetric;

    CopyVstr(&m_vstrOldTcpFilterList, m_vstrTcpFilterList);
    CopyVstr(&m_vstrOldUdpFilterList, m_vstrUdpFilterList);
    CopyVstr(&m_vstrOldIpFilterList, m_vstrIpFilterList);

    if (m_fIsAtmAdapter)
    {
        CopyVstr(&m_vstrOldARPServerList, m_vstrARPServerList);
        CopyVstr(&m_vstrOldMARServerList, m_vstrMARServerList);
        m_dwOldMTU  = m_dwMTU;
        m_fOldPVCOnly = m_fPVCOnly;
    }
}


//+---------------------------------------------------------------------------
//
//  Name:   GLOBAL_INFO::~GLOBAL_INFO
//
//  Purpose:   Destructor
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
GLOBAL_INFO::~GLOBAL_INFO()
{
    FreeCollectionAndItem(m_vstrDnsSuffixList);
    FreeCollectionAndItem(m_vstrOldDnsSuffixList);
}

//+---------------------------------------------------------------------------
//
//  Name:   GLOBAL_INFO::HrSetDefaults
//
//  Purpose:    Function to set all the default values of the GLOBAL_INFO
//              structure.  This is done to the system's GLOBAL_INFO
//              before reading the Registry so that any missing
//              parameters are defaulted
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
HRESULT GLOBAL_INFO::HrSetDefaults()
{
    HRESULT hr = S_OK;

    // Get the ComputerName -> used for default HostName
    WCHAR szComputerName [MAX_COMPUTERNAME_LENGTH + 1];
    szComputerName[0] = L'\0';

    DWORD dwCch = celems(szComputerName);
    BOOL fOk = ::GetComputerName(szComputerName, &dwCch);

    Assert(szComputerName[dwCch] == 0);

    //
    // 398325: DNS hostnames should be lower case whenever possible.
    //
    LowerCaseComputerName(szComputerName);

    m_strHostName   = szComputerName;

    // Set defaults
    FreeCollectionAndItem(m_vstrDnsSuffixList);
    FreeCollectionAndItem(m_vstrOldDnsSuffixList);

    //Bug #265732: per SKwan, the default of m_fUseDomainNameDevolution should be TRUE
    m_fUseDomainNameDevolution    = TRUE;
    m_fOldUseDomainNameDevolution = TRUE;

    m_fEnableLmHosts        = TRUE;
    m_fOldEnableLmHosts     = TRUE;

    m_fEnableRouter         = FALSE;

    m_fEnableIcmpRedirect   = TRUE;
    m_fDeadGWDetectDefault  = TRUE;
    m_fDontAddDefaultGatewayDefault = FALSE;




    m_fEnableFiltering      = FALSE;
    m_fOldEnableFiltering   = FALSE;

    //IPSec is removed from connection UI   
    //m_strIpsecPol = c_szIpsecUnset;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     GLOBAL_INFO::operator=
//
//  Purpose:   Copy operator
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
GLOBAL_INFO& GLOBAL_INFO::operator=(GLOBAL_INFO& info)
{
    Assert(this != &info);

    if (this == &info)
        return *this;

    CopyVstr(&m_vstrDnsSuffixList, info.m_vstrDnsSuffixList);
    CopyVstr(&m_vstrOldDnsSuffixList, info.m_vstrOldDnsSuffixList);

    m_fUseDomainNameDevolution      = info.m_fUseDomainNameDevolution;
    m_fOldUseDomainNameDevolution   = info.m_fOldUseDomainNameDevolution;

    m_fEnableLmHosts        = info.m_fEnableLmHosts;
    m_fOldEnableLmHosts     = info.m_fOldEnableLmHosts;

    m_fEnableRouter         = info.m_fEnableRouter;

    m_fEnableIcmpRedirect   = info.m_fEnableIcmpRedirect;
    m_fDeadGWDetectDefault  = info.m_fDeadGWDetectDefault;
    m_fDontAddDefaultGatewayDefault = info.m_fDontAddDefaultGatewayDefault;



    m_fEnableFiltering      = info.m_fEnableFiltering;
    m_fOldEnableFiltering   = info.m_fOldEnableFiltering;

    //IPSec is removed from connection UI   
    /*
    m_guidIpsecPol = info.m_guidIpsecPol;
    m_strIpsecPol = info.m_strIpsecPol;
    */

    return *this;
}

//+---------------------------------------------------------------------------
//
//  Name:     GLOBAL_INFO::ResetOldValues()
//
//  Purpose:  This is for initializing the "old" values after the current values
//            are first loaded from registry, also for resetting the "old" values
//            to current ones when "Apply"(instead of "ok") is hit.
//
//  Arguments:
//  Returns:
//
//  Author:     tongl  11 Nov, 1997
//
void GLOBAL_INFO::ResetOldValues()
{
    CopyVstr(&m_vstrOldDnsSuffixList, m_vstrDnsSuffixList);

    m_fOldEnableLmHosts     = m_fEnableLmHosts;
    m_fOldEnableFiltering   = m_fEnableFiltering;
    m_fOldUseDomainNameDevolution = m_fUseDomainNameDevolution;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpipobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P O B J . H
//
//  Contents:   Declaration of CTcpipcfg and helper functions.
//
//  Notes:
//
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <ncres.h>
#include <notifval.h>
#include "resource.h"
#include "tcpip.h"

#include "netconp.h"

extern "C"
{
#include "dhcpcapi.h"
};

/////////////////////////////////////////////////////////////////////////////
// Data types & Constants
struct REG_BACKUP_INFO
{
    DWORD dwOptionId;
    DWORD dwClassLen;
    DWORD dwDataLen;
    DWORD dwIsVendor;
    DWORD dwExpiryTime;
    DWORD dwData[1];
};

// when building the blob to be stored into the registry, the memory buffer
// that holds it is enlarged dynamically with chunks of the size below
// (for now, there are only 5 options of at most 2 dwords each - so prepare
// the chunk such that only one allocation is needed)
#define BUFFER_ENLARGEMENT_CHUNK    5*(sizeof(REG_BACKUP_INFO) + sizeof(DWORD))

// Max number of property sheet pages on tcpip's property sheet
static const INT c_cMaxTcpipPages = 6;

extern HICON   g_hiconUpArrow;
extern HICON   g_hiconDownArrow;

/////////////////////////////////////////////////////////////////////////////
// tcpipcfg

class ATL_NO_VTABLE CTcpipcfg :
    public CComObjectRoot,
    public CComCoClass<CTcpipcfg, &CLSID_CTcpipcfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentUpperEdge,
    public INetRasConnectionIpUiInfo,
    public ITcpipProperties,
    public INetCfgComponentSysPrep
{
public:

    CTcpipcfg();
    ~CTcpipcfg() { FinalFree(); }

    BEGIN_COM_MAP(CTcpipcfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentUpperEdge)
        COM_INTERFACE_ENTRY(INetRasConnectionIpUiInfo)
        COM_INTERFACE_ENTRY(ITcpipProperties)
        COM_INTERFACE_ENTRY(INetCfgComponentSysPrep)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CTcpipcfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_TCPIPCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)         (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)         (DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo );
    STDMETHOD (ReadAnswerFile)  (PCWSTR pszAnswerFile,
                                 PCWSTR pszAnswerSection);
    STDMETHOD (Removing)();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgComponentUpperEdge
    STDMETHOD (GetInterfaceIdsForAdapter) (
        INetCfgComponent*   pAdapter,
        DWORD*              pdwNumInterfaces,
        GUID**              ppguidInterfaceIds);

    STDMETHOD (AddInterfacesToAdapter) (
        INetCfgComponent*   pAdapter,
        DWORD               dwNumInterfaces);

    STDMETHOD (RemoveInterfacesFromAdapter) (
        INetCfgComponent*   pAdapter,
        DWORD               dwNumInterfaces,
        const GUID*         pguidInterfaceIds);

// INetRasConnectionIpUiInfo
    STDMETHOD (GetUiInfo) (RASCON_IPUI*  pInfo);

// ITcpipProperties
    STDMETHOD (GetIpInfoForAdapter) (const GUID* pguidAdapter,
                                     REMOTE_IPINFO**  ppInfo);
    STDMETHOD (SetIpInfoForAdapter) (const GUID* pguidAdapter,
                                     REMOTE_IPINFO* pInfo);

    // INetCfgComponentSysPrep
    STDMETHOD (SaveAdapterParameters) (
            INetCfgSysPrep* pncsp,
            LPCWSTR pszwAnswerSections,
            GUID* pAdapterInstanceGuid);

    STDMETHOD (RestoreAdapterParameters) (
            LPCWSTR pszwAnswerFile, 
            LPCWSTR pszwAnswerSection,
            GUID*   pAdapterInstanceGuid);
public:

    GLOBAL_INFO  m_glbSecondMemoryGlobalInfo;

    // Place to keep pointer to INetCfg from Initialize
    INetCfg * m_pnc;

    // Place to keep the pointer to context
    IUnknown * m_pUnkContext;

    // Access methods to second memory state
    const GLOBAL_INFO *     GetConstGlobalInfo() { return &m_glbSecondMemoryGlobalInfo; };
    GLOBAL_INFO *           GetGlobalInfo() { return &m_glbSecondMemoryGlobalInfo; };

    const VCARD *    GetConstAdapterInfoVector() { return &m_vcardAdapterInfo; };

    void    SetReconfig() { m_fReconfig = TRUE; };

    void    SetSecondMemoryLmhostsFileReset() { m_fSecondMemoryLmhostsFileReset = TRUE; };
    BOOL    FIsSecondMemoryLmhostsFileReset() { return m_fSecondMemoryLmhostsFileReset; }

//IPSec is removed from connection UI
//    void    SetSecondMemoryIpsecPolicySet() { m_fSecondMemoryIpsecPolicySet = TRUE; };

    void    SetSecondMemoryModified() { m_fSecondMemoryModified = TRUE; };

private:
    GLOBAL_INFO         m_glbGlobalInfo;
    VCARD               m_vcardAdapterInfo;

    ADAPTER_INFO*       m_pSecondMemoryAdapterInfo;

    VSTR                m_vstrBindOrder;

    class CTcpAddrPage*  m_ipaddr;

    INetCfgComponent*           m_pnccTcpip;
    INetCfgComponentPrivate*    m_pTcpipPrivate;
    INetCfgComponent*           m_pnccWins;

    tstring m_strDnsServerList;
    tstring m_strUpgradeGlobalDnsDomain;

    // Connection type
    ConnectionType  m_ConnType;
    GUID            m_guidCurrentConnection;

    BOOL    m_fSaveRegistry : 1;
    BOOL    m_fRemoving : 1;
    BOOL    m_fInstalling : 1;

    BOOL    m_fUpgradeCleanupDnsKey : 1;

    BOOL    m_fUpgradeGlobalDnsDomain : 1;

    // whether reconfig notification should be sent
    BOOL    m_fReconfig : 1; // Call SendHandlePnpEvent

    // Is there any bound physical card on Initialize
    // This is needed for Add/Remove LmHosts service
    // at apply time
    BOOL    m_fHasBoundCardOnInit : 1;

    BOOL    m_fLmhostsFileSet : 1;
    BOOL    m_fSecondMemoryLmhostsFileReset : 1;
    BOOL    m_fSecondMemoryModified : 1;

    //IPSec is removed from connection UI
    //BOOL    m_fIpsecPolicySet : 1;
    //BOOL    m_fSecondMemoryIpsecPolicySet : 1;

    // Fix 406630: Only used for RAS connection to identify whether the USER has 
    // write access to Global settings
    BOOL    m_fRasNotAdmin : 1;

    BOOL    m_fNoPopupsDuringPnp : 1;


private:
    void    FinalFree();
    void    ExitProperties();

    BOOL    FHasBoundCard();

    ADAPTER_INFO*   PAdapterFromInstanceGuid (const GUID* pGuid);
    ADAPTER_INFO*   PAdapterFromNetcfgComponent (INetCfgComponent* pncc);

    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                PCWSTR pszAnswerSection);

    HRESULT HrLoadGlobalParamFromAnswerFile(HINF hinf,
                                            PCWSTR pszAnswerSection);
    HRESULT HrLoadAdapterParameterFromAnswerFile(HINF hinf,
                                                 PCWSTR mszAdapterList);

    // Set router related parameters at install time
    // HRESULT HrInitRouterParamsAtInstall();

    // Initialize first in memory state
    HRESULT     HrGetNetCards();

    // Load adapterinfo for bound cards from first memory to second memory
    HRESULT HrLoadAdapterInfo();

    // Save adapterinfo from second memory to first memory
    HRESULT HrSaveAdapterInfo();

    // Set connection context
    HRESULT HrSetConnectionContext();

    // Allocate and deallocate property pages
    HRESULT HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT *cPages);
    VOID CleanupPropPages(VOID);

    // Handle Add/Remove/Enable/Disable adapters on BindingPathNotify
    HRESULT HrAdapterBindNotify(INetCfgComponent *pnccNetCard,
                                DWORD dwChangeFlag,
                                PCWSTR szInterfaceName);

    HRESULT HrAddCard(INetCfgComponent * pnccNetCard,
                      PCWSTR szNetCardTcpipBindPath,
                      PCWSTR szInterfaceName);

    HRESULT HrDeleteCard(const GUID* pguid);
    HRESULT HrBindCard  (const GUID* pguid, BOOL fInitialize = FALSE);
    HRESULT HrUnBindCard(const GUID* pguid, BOOL fInitialize = FALSE);

    // Help functions to interface methods
    HRESULT MarkNewlyAddedCards(const HKEY hkeyTcpipParam);

    HRESULT HrGetListOfAddedNdisWanCards(const HKEY hkeyTcpipParam,
                                         VSTR * const pvstrAddedNdisWanCards);

    HRESULT HrLoadSettings();
    HRESULT HrLoadTcpipRegistry(const HKEY hkeyTcpipParam);
    HRESULT HrLoadWinsRegistry(const HKEY hkeyWinsParam);

    HRESULT HrSaveSettings();
    HRESULT HrSaveTcpipRegistry(const HKEY hkeyTcpipParam);
    HRESULT HrSaveMultipleInterfaceWanRegistry(const HKEY hkeyInterfaces, ADAPTER_INFO* pAdapter);
    HRESULT HrSaveWinsMultipleInterfaceWanRegistry(const HKEY hkeyInterfaces, ADAPTER_INFO* pAdapter);
    HRESULT HrSaveWinsRegistry(const HKEY hkeyWinsParam);
    HRESULT HrSetMisc(const HKEY hkeyTcpipParam, const HKEY hkeyWinsParam);
    HRESULT HrGetDhcpOptions(OUT VSTR * const GlobalOptions,
                             OUT VSTR * const PerAdapterOptions);

    HRESULT HrSaveStaticWanRegistry(HKEY hkeyInterfaceParam);
    HRESULT HrSaveStaticAtmRegistry(HKEY hkeyInterfaceParam);

    // Dhcp functions
    HRESULT HrNotifyDhcp();

    HRESULT HrCallDhcpConfig(PWSTR ServerName,
                             PWSTR AdapterName,
                             GUID  & guidAdapter,
                             BOOL IsNewIpAddress,
                             DWORD IpIndex,
                             DWORD IpAddress,
                             DWORD SubnetMask,
                             SERVICE_ENABLE DhcpServiceEnabled);

    HRESULT HrCallDhcpHandlePnPEvent(ADAPTER_INFO * pAdapterInfo,
                                     LPDHCP_PNP_CHANGE pDhcpPnpChange);

    HRESULT HrDhcpRefreshFallbackParams(ADAPTER_INFO * pAdapterInfo);

    // Call SendNdisHandlePnpEvent to notify tcpip and netbt of
    // parameter changes
    HRESULT HrReconfigAtmArp(ADAPTER_INFO* pAdapterInfo,
                            INetCfgPnpReconfigCallback* pICallback);
    HRESULT HrReconfigDns(BOOL fDoReconfigWithoutCheckingParams = FALSE);
    HRESULT HrReconfigIp(INetCfgPnpReconfigCallback* pICallback);
    HRESULT HrReconfigNbt(INetCfgPnpReconfigCallback* pICallback);
    HRESULT HrReconfigWanarp(ADAPTER_INFO* pAdapterInfo,
                            INetCfgPnpReconfigCallback* pICallback);

//IPSec is removed from connection UI
//    HRESULT HrSetActiveIpsecPolicy();

    //Some tcpip params are duplicated to the old Nt4 location to solve compatibility issues.
    HRESULT HrDuplicateToNT4Location(HKEY hkeyInterface, ADAPTER_INFO * pAdapter);
    //We need to clean it up when removing tcpip
    HRESULT HrRemoveNt4DuplicateRegistry();

    // Reinitialize internal state if Apply or Cancel is called
    void ReInitializeInternalState();

    // Upgrade registry in post pnp checkin cases
    HRESULT HrUpgradePostPnpRegKeyChange();

    // Add a new RAS fake GUID if the one set in context is not yet added.
    HRESULT UpdateRasAdapterInfo(
        const RASCON_IPUI& RasInfo);

    HRESULT HrLoadBindingOrder(VSTR *pvstrBindOrder);
    BOOL IsBindOrderChanged();

    HRESULT HrCleanUpPerformRouterDiscoveryFromRegistry();

    // Loads Fallback configuration from registry
    HRESULT HrLoadBackupTcpSettings(HKEY hkeyInterfaceParam, ADAPTER_INFO * pAdapter);
    // Loads one option from the registry blob into the BACKUP_CFG_INFO structure
    HRESULT HrLoadBackupOption(REG_BACKUP_INFO *pOption, BACKUP_CFG_INFO *pBackupInfo);

    // Saves Fallback configuration to registry
    HRESULT HrSaveBackupTcpSettings(HKEY hkeyInterfaceParam, ADAPTER_INFO * pAdapter);
    // Appends one option to the blob to be written into the registry
    HRESULT HrSaveBackupDwordOption (
                DWORD  Option,
                DWORD  OptionData[],
                DWORD  OptionDataSz,
                LPBYTE  *ppBuffer,
                LPDWORD pdwBlobSz,
                LPDWORD pdwBufferSz);

    HRESULT HrDeleteBackupSettingsInDhcp(LPCWSTR wszAdapterName);

    HRESULT HrOpenTcpipInterfaceKey(
                    const GUID & guidInterface,
                    HKEY * phKey,
                    REGSAM sam);

    HRESULT HrOpenNetBtInterfaceKey(
                    const GUID & guidInterface,
                    HKEY * phKey,
                    REGSAM sam);

    HRESULT HrSetSecurityForNetConfigOpsOnSubkeys(HKEY hkeyRoot, LPCWSTR strKeyName);
    HRESULT HrSetSecurityForNetSvcOnSubkeys(HKEY hkeyRoot, LPCWSTR strKeyName);
    HRESULT HrUpdateNt4RegistryPermission();

public:
    ADAPTER_INFO * GetConnectionAdapterInfo()
    {
        return m_pSecondMemoryAdapterInfo;
    };

    ConnectionType GetConnectionType()
    {
        return m_ConnType;
    };

    BOOL IsRasNotAdmin()
    {
        return m_fRasNotAdmin;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpmacro.h ===
// $REVIEW(tongl) the win32 Macros does not call ::SendMessage !!!
// This is a temporary solution, sent mail to BryanT, vcsig
#pragma once

#ifndef SNDMSG
#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif
#endif // ifndef SNDMSG

#ifndef POSTMSG
#ifdef __cplusplus
#define POSTMSG ::PostMessage
#else
#define POSTMSG PostMessage
#endif
#endif // ifndef POSTMSG

// ListBox_InsertString
#define Tcp_ListBox_InsertString(hwndCtl, index, lpsz) ((int)(DWORD)SNDMSG((hwndCtl), LB_INSERTSTRING, (WPARAM)(int)(index), (LPARAM)(PCWSTR)(lpsz)))

// ListBox_AddString
#define Tcp_ListBox_AddString(hwndCtl, lpsz) ((int)(DWORD)SNDMSG((hwndCtl), LB_ADDSTRING, 0L, (LPARAM)(PCWSTR)(lpsz)))

// ListBox_DeleteString
#define Tcp_ListBox_DeleteString(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

// ListBox_SetCurSel
#define Tcp_ListBox_SetCurSel(hwndCtl, index)  ((int)(DWORD)SNDMSG((hwndCtl), LB_SETCURSEL, (WPARAM)(int)(index), 0L))

// ListBox_GetCount
#define Tcp_ListBox_GetCount(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCOUNT, 0L, 0L))

// ListBox_GetTextLen
#define Tcp_ListBox_GetTextLen(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETTEXTLEN, (WPARAM)(int)(index), 0L))

// ListBox_GetText
#define Tcp_ListBox_GetText(hwndCtl, index, lpszBuffer) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETTEXT, (WPARAM)(int)(index), (LPARAM)(PCWSTR)(lpszBuffer)))

// ListBox_GetCount
#define Tcp_ListBox_GetCount(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCOUNT, 0L, 0L))

// ListBox_DeleteString
#define Tcp_ListBox_DeleteString(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), LB_DELETESTRING, (WPARAM)(int)(index), 0L))

// ListBox_GetCurSel
#define Tcp_ListBox_GetCurSel(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), LB_GETCURSEL, 0L, 0L))

// ListBox_ResetContent
#define Tcp_ListBox_ResetContent(hwndCtl)  ((BOOL)(DWORD)SNDMSG((hwndCtl), LB_RESETCONTENT, 0L, 0L))

// ListBox_FindStrExact
#define Tcp_ListBox_FindStrExact(hwndCtl, lpszStr) ((int)(DWORD)SNDMSG((hwndCtl), LB_FINDSTRINGEXACT, -1, (LPARAM)(PCWSTR)lpszStr))

// ComboBox_SetCurSel
#define Tcp_ComboBox_SetCurSel(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))

// ComboBox_GetCurSel
#define Tcp_ComboBox_GetCurSel(hwndCtl)  ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCURSEL, 0L, 0L))

// ComboBox_GetCount
#define Tcp_ComboBox_GetCount(hwndCtl)  ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCOUNT, 0L, 0L))

// Tcp_Edit_LineLength
#define Tcp_Edit_LineLength(hwndCtl, line) ((int)(DWORD)SNDMSG((hwndCtl), EM_LINELENGTH, (WPARAM)(int)(line), 0L))

// PropSheet_CancelToClose (in prsht.h)
#define Tcp_PropSheet_CancelToClose(hDlg) POSTMSG(hDlg, PSM_CANCELTOCLOSE, 0, 0L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcpipobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P I P O B J . C P P
//
//  Contents:   TCP/IP notify object
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncreg.h"
#include "ncstl.h"
#include "tcpconst.h"
#include "tcpipobj.h"
#include "tcputil.h"

extern const WCHAR c_szBiNdisAtm[];

extern const WCHAR c_szInfId_MS_NetBT[];
extern const WCHAR c_szInfId_MS_NetBT_SMB[];


HICON   g_hiconUpArrow;
HICON   g_hiconDownArrow;

// Constructor
CTcpipcfg::CTcpipcfg()
:   m_ipaddr(NULL),
    m_pUnkContext(NULL),
    m_pnc(NULL),
    m_pnccTcpip(NULL),
    m_pTcpipPrivate(NULL),
    m_pnccWins(NULL),
    m_fRemoving(FALSE),
    m_fInstalling(FALSE),
    m_fUpgradeCleanupDnsKey(FALSE),
    m_fUpgradeGlobalDnsDomain(FALSE),
    m_pSecondMemoryAdapterInfo(NULL)
{ }

//+---------------------------------------------------------------------------
// INetCfgComponentControl
//
//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Initialize
//
STDMETHODIMP CTcpipcfg::Initialize(INetCfgComponent * pnccTcpip,
                                   INetCfg * pncNetCfg,
                                   BOOL fInstalling)
{
    HRESULT hr = S_OK;

    Assert(pncNetCfg);
    Assert(pnccTcpip);

    m_fRemoving = FALSE;
    m_fInstalling = FALSE;

    m_fSaveRegistry = FALSE;

    m_ConnType = CONNECTION_UNSET;
    m_fReconfig = FALSE;

    // we havn't changed LmHost file
    m_fLmhostsFileSet = FALSE;

    // IPSec is removed from connection UI
    // we have not change ipsec policy
    //m_fIpsecPolicySet = FALSE;

    // by default, this should be an admin
    m_fRasNotAdmin = FALSE;

    m_fNoPopupsDuringPnp = FALSE;

    Validate_INetCfgNotify_Initialize(pnccTcpip, pncNetCfg, fInstalling);

    do // psudo loop ( so we don't use goto's on err )
    {
        // in case of Initialize called twice, for resurect the component
        ReleaseObj(m_pnc);
        m_pnc = NULL;

        ReleaseObj(m_pnccTcpip);
        m_pnccTcpip = NULL;

        ReleaseObj(m_pTcpipPrivate);
        m_pTcpipPrivate = NULL;

        ReleaseObj(m_pnccWins);
        m_pnccWins = NULL;

        // store reference to the INetCfg in our object
        m_pnc = pncNetCfg;
        m_pnc->AddRef();

        // Store a reference to the INetCfgComponent for tcpip in our object
        m_pnccTcpip = pnccTcpip;
        m_pnccTcpip->AddRef();

        hr = pnccTcpip->QueryInterface(
                    IID_INetCfgComponentPrivate,
                    reinterpret_cast<void**>(&m_pTcpipPrivate));
        if (FAILED(hr))
            break;

        // Get a copy of the WINS component and store in our object

        // NOTE: WINS client is not necessarily installed yet!
        // we also try to get a pointer at the Install sections
        hr = pncNetCfg->FindComponent(c_szInfId_MS_NetBT,
                            &m_pnccWins);
        if (FAILED(hr))
            break;

        if (S_FALSE == hr) // NetBt not found
        {
            if (!fInstalling) // We are in trouble if NetBt is not there
            {
                TraceError("CTcpipcfg::Initialize - NetBt has not been installed yet", hr);
                break;
            }
            else // We are ok since tcpip will install netbt
            {
                hr = S_OK;
            }
        }

        // Set default global parameters
        hr = m_glbGlobalInfo.HrSetDefaults();
        if (FAILED(hr))
            break;

        // If tcpip is being installed, we don't have any cards to load
        if (!fInstalling)
        {
            // Get list of cards which are currently in the system + if they are bound
            hr = HrGetNetCards();

            if (SUCCEEDED(hr))
            {
                // Let's read parameters from registry
                hr = HrLoadSettings();
            }
        }
    } while(FALSE);

    // Have we got any bound cards ?
    m_fHasBoundCardOnInit = FHasBoundCard();

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CTcpipcfg::Initialize", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Validate
//
STDMETHODIMP CTcpipcfg::Validate()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Cancel
//
STDMETHODIMP CTcpipcfg::CancelChanges()
{
    // Note: first memory state is release in destructor

    // If the lmhosts file was set, we need to roll it back to the backup
    if (m_fLmhostsFileSet)
    {
        ResetLmhostsFile();
        m_fLmhostsFileSet = FALSE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::ApplyRegistryChanges
//
STDMETHODIMP CTcpipcfg::ApplyRegistryChanges()
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    if (m_fRemoving)
    {
        // (nsun) we should remove the Nt4 duplicate registry here because the cards
        // may have been marked as deleted
        hr = HrRemoveNt4DuplicateRegistry();

        ReleaseObj(m_pnccWins);
        m_pnccWins = NULL;

        // $REVIEW(tongl 9/29/97): Removing ServiceProvider value from registry
        // Remove "Tcpip" from the:
        // System\CurrentControlSet\Control\ServiceProvider\Order\ProviderOrder value
        hrTmp = ::HrRegRemoveStringFromMultiSz(c_szTcpip,
                                            HKEY_LOCAL_MACHINE,
                                            c_szSrvProvOrderKey,
                                            c_szProviderOrderVal,
                                            STRING_FLAG_REMOVE_ALL);
        if (SUCCEEDED(hr))
            hr = hrTmp;
    }
    else
    {
        // Cleanup the adapters marked as for deletion from the memory structure
        // Change made for #95637
        for(size_t i = 0 ; i < m_vcardAdapterInfo.size() ; ++i)
        {
            if (m_vcardAdapterInfo[i]->m_fDeleted)
            {
                //delete it
                FreeVectorItem(m_vcardAdapterInfo, i);
                i--; //move the pointer back ?
            }
        }

        if (m_fSaveRegistry)
        {
            // Save info in first memory state to registry
            // m_glbGlobalInfo and m_vcardAdapterInfo
            hrTmp = HrSaveSettings();
            if (SUCCEEDED(hr))
                hr = hrTmp;
        }
        else
        {
            // No change
            hr = S_FALSE;
        }
    }


    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CTcpipcfg::ApplyRegistryChanges", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::ApplyPnpChanges
//
STDMETHODIMP CTcpipcfg::ApplyPnpChanges(IN INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    Assert(pICallback);

    if (!m_fRemoving)
    {
        if(!m_fInstalling)
        {
            if (m_fReconfig)
            {
                // Notify protocols/services of changes

                // Notify Tcpip of any changes in the IP Addresses
                hrTmp = HrNotifyDhcp();
                if (S_OK == hr)
                    hr = hrTmp;

                // reconfig tcpip
                hrTmp = HrReconfigIp(pICallback);
                if (S_OK == hr)
                    hr = hrTmp;

                // reconfig netbt
                hrTmp = HrReconfigNbt(pICallback);
                if (S_OK == hr)
                    hr = hrTmp;

                // reconfig dns
                hrTmp = HrReconfigDns();
                if (S_OK == hr)
                    hr = hrTmp;
            }

            if (IsBindOrderChanged())
            {
                //notify DNS cache of binding order changes
                hrTmp = HrReconfigDns(TRUE);
                if (S_OK == hr)
                    hr = hrTmp;
            }

        }

        
//IPSec is removed from connection UI
//        if (m_fIpsecPolicySet)
//            hrTmp = HrSetActiveIpsecPolicy();

        if (S_OK == hr)
            hr = hrTmp;
    }

    // Current state has been applied, reset the flags and
    // "Old" value of parameters
    if (S_OK == hr)
    {
        ReInitializeInternalState();
    }

    TraceError("CTcpipcfg::ApplyPnpChanges", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// INetCfgComponentSetUp
//
//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Install
//
STDMETHODIMP CTcpipcfg::Install(DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install(dwSetupFlags);

    m_fSaveRegistry = TRUE;
    m_fInstalling = TRUE;

    // Install the WINS client on behalf of TCPIP.
    Assert(!m_pnccWins);
    hr = HrInstallComponentOboComponent(m_pnc, NULL,
            GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NetBT, m_pnccTcpip,
            &m_pnccWins);

    if (SUCCEEDED(hr))
    {
        Assert(m_pnccWins);

        hr = HrInstallComponentOboComponent(m_pnc, NULL,
                GUID_DEVCLASS_NETTRANS,
                c_szInfId_MS_NetBT_SMB, m_pnccTcpip,
                NULL);
    }

    TraceError("CTcpipcfg::Install", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Upgrade
//
STDMETHODIMP CTcpipcfg::Upgrade(DWORD dwSetupFlags,
                                DWORD dwUpgradeFomBuildNo )
{
    HrCleanUpPerformRouterDiscoveryFromRegistry();
    HrUpdateNt4RegistryPermission();
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::ReadAnswerFile
//
//  Purpose:    Reads the appropriate fields from the given answer file into
//              our in-memory state.
//
//  Arguments:
//      pszAnswerFile       [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Comma-separated list of sections in the
//                                  file appropriate to this component.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  7 May 1997
//
//  Notes:
//
STDMETHODIMP CTcpipcfg::ReadAnswerFile( PCWSTR pszAnswerFile,
                                        PCWSTR pszAnswerSection)
{
    m_fSaveRegistry = TRUE;

    if (pszAnswerFile && pszAnswerSection)
    {
        // Process answer file
        (void) HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//  Member:     CTcpipcfg::Removing
//
STDMETHODIMP CTcpipcfg::Removing()
{
    HRESULT hr;

    m_fRemoving = TRUE;

    // Remove NetBt protocol. This doesn't actually remove the
    // component, it simply marks it as needing to be removed,
    // and in Apply() it will be fully removed.
    hr = HrRemoveComponentOboComponent(
            m_pnc, GUID_DEVCLASS_NETTRANS,
            c_szInfId_MS_NetBT, m_pnccTcpip);
    if (SUCCEEDED(hr))
    {
        // remove NetBt_SMB
        hr = HrRemoveComponentOboComponent(
                m_pnc, GUID_DEVCLASS_NETTRANS,
                c_szInfId_MS_NetBT_SMB, m_pnccTcpip);

    }

    TraceError("CTcpipcfg::Removing", hr);
    return hr;
}

// INetCfgProperties
STDMETHODIMP CTcpipcfg::SetContext(IUnknown * pUnk)
{
    // release previous context, if any
    ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CTcpipcfg::MergePropPages(
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    // Initialize output parameter
    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    // We don't want any default pages to be shown
    *pdwDefPages = 0;
    *pcPages = NULL;
    *pahpspPrivate = NULL;

    // get the connection context in which we are bringing up the UI
    HRESULT hr = HrSetConnectionContext();

    if (SUCCEEDED(hr))
    {
        AssertSz(((CONNECTION_LAN == m_ConnType)||
                  (CONNECTION_RAS_PPP == m_ConnType)||
                  (CONNECTION_RAS_SLIP == m_ConnType)||
                  (CONNECTION_RAS_VPN == m_ConnType)),
                  "How come we don't know the connection type yet on MergePropPages?");

        // Initialize the common controls library
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC  = ICC_INTERNET_CLASSES;

        SideAssert(InitCommonControlsEx(&icc));

        hr = HrSetupPropSheets(&ahpsp, &cPages);
        if (SUCCEEDED(hr))
        {
            *pahpspPrivate = (LPBYTE)ahpsp;
            *pcPages = cPages;

            // Set the global up\down arrows
            if (!g_hiconUpArrow && !g_hiconDownArrow)
            {
                g_hiconUpArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                                  MAKEINTRESOURCE(IDI_UP_ARROW),
                                                  IMAGE_ICON, 16, 16, 0);
                g_hiconDownArrow = (HICON)LoadImage(_Module.GetResourceInstance(),
                                                    MAKEINTRESOURCE(IDI_DOWN_ARROW),
                                                    IMAGE_ICON, 16, 16, 0);
            }

        }
        else
        {
            *pcPages = 0;
            CoTaskMemFree(ahpsp);

        }
    }

    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CTcpipcfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CTcpipcfg::ValidateProperties(HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CTcpipcfg::CancelProperties()
{
    // If the lmhosts file was set, we need to roll it back to the backup
    if (m_fSecondMemoryLmhostsFileReset)
    {
        ResetLmhostsFile();
    }

    // Release second memory state
    ExitProperties();

    return S_OK;
}

STDMETHODIMP CTcpipcfg::ApplyProperties()
{
    HRESULT hr = S_OK;

    if (!m_fReconfig)
    {
        m_fReconfig = m_fSecondMemoryModified ||
                      m_fSecondMemoryLmhostsFileReset;

        //IPSec is removed from connection UI
        // || m_fSecondMemoryIpsecPolicySet;
    }

    if (!m_fLmhostsFileSet)
        m_fLmhostsFileSet = m_fSecondMemoryLmhostsFileReset;

    //IPSec is removed from connection UI
    //if (!m_fIpsecPolicySet)
    //    m_fIpsecPolicySet = m_fSecondMemoryIpsecPolicySet;

    if (!m_fSaveRegistry)
        m_fSaveRegistry = m_fSecondMemoryModified;

    // Copy info from second memory state to first memory state
    if (m_fSecondMemoryModified)
    {
        m_glbGlobalInfo = m_glbSecondMemoryGlobalInfo;
        hr = HrSaveAdapterInfo();
    }

    // Release second memory state
    ExitProperties();

    Validate_INetCfgProperties_ApplyProperties_Return(hr);

    TraceError("CTcpipcfg::ApplyProperties", hr);
    return hr;
}

STDMETHODIMP CTcpipcfg::QueryBindingPath(DWORD dwChangeFlag,
                                         INetCfgBindingPath * pncbp)
{
    HRESULT hr = S_OK;

    // If the binding is to an atm adapter (i.e. interface = ndisatm),
    // then return NETCFG_S_DISABLE_QUERY
    //
    if (dwChangeFlag & NCN_ADD)
    {

        INetCfgComponent* pnccLastComponent;
        PWSTR pszInterfaceName;

        hr = HrGetLastComponentAndInterface(pncbp,
                &pnccLastComponent,
                &pszInterfaceName);

        if (SUCCEEDED(hr))
        {
            // If adding an adapter through interface ndisatm,
            // we want to disable the binding interface since it's
            // the IP over ATM direct binding
            if (0 == lstrcmpW(c_szBiNdisAtm,  pszInterfaceName))
            {
                hr = NETCFG_S_DISABLE_QUERY;
            }

            ReleaseObj (pnccLastComponent);
            CoTaskMemFree (pszInterfaceName);
        }
    }

    TraceError("CTcpipcfg::QueryBindingPath",
        (NETCFG_S_DISABLE_QUERY == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP CTcpipcfg::NotifyBindingPath(
    DWORD                   dwChangeFlag,
    INetCfgBindingPath *    pncbp)
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    // If we are told to add a card, we must be told at the same time whether the
    // binding is enabled or disabled
    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    HRESULT hr = S_OK;

    Validate_INetCfgBindNotify_NotifyBindingPath(dwChangeFlag, pncbp);

    INetCfgComponent * pnccLastComponent;
    PWSTR pszInterfaceName;
    hr = HrGetLastComponentAndInterface(pncbp,
            &pnccLastComponent,
            &pszInterfaceName);
    if (SUCCEEDED(hr))
    {
#if DBG
        GUID guidNetClass;
        hr = pnccLastComponent->GetClassGuid (&guidNetClass);

        AssertSz(
            SUCCEEDED(hr) &&
            IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET),
            "Why the last component on the path is not an adapter?");
#endif

        // If we are adding/removing cards, set m_fSaveRegistry
        // so we apply the changes to registry

        if (dwChangeFlag & (NCN_ADD | NCN_REMOVE))
            m_fSaveRegistry = TRUE;

        hr = HrAdapterBindNotify(pnccLastComponent,
                                 dwChangeFlag,
                                 pszInterfaceName);

        ReleaseObj (pnccLastComponent);
        CoTaskMemFree (pszInterfaceName);
    }

    if (SUCCEEDED(hr))
        hr = S_OK;

    Validate_INetCfgBindNotify_NotifyBindingPath_Return(hr);

    TraceError("CTcpipcfg::NotifyBindingPath", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// INetCfgComponentUpperEdge
//

// Return an array of interface ids for an adapter bound to
// this component.  If the specified adapter does not have explicit
// interfaces exported from it, S_FALSE is returned.
// pAdapter is the adapter in question.
// pdwNumInterfaces is the address of a DWORD where the count of elements
// returned via ppguidInterfaceIds is stored.
// ppguidInterfaceIds is the address of a pointer where an allocated
// block of memory is returned.  This memory is an array of interface ids.
// *ppguidInterfaceIds should be free with CoTaskMemFree if S_OK is returned.
// if S_FALSE is returned, *pdwNumInterfaces and *ppguidInterfaceIds should
// be NULL.
//

HRESULT
CTcpipcfg::GetInterfaceIdsForAdapter (
    INetCfgComponent*   pnccAdapter,
    DWORD*              pdwNumInterfaces,
    GUID**              ppguidInterfaceIds)
{
    Assert (pnccAdapter);
    Assert (pdwNumInterfaces);

    HRESULT hr = S_FALSE;

    // Initialize output parameters.
    //
    *pdwNumInterfaces = 0;
    if (ppguidInterfaceIds)
    {
        *ppguidInterfaceIds = NULL;
    }

    ADAPTER_INFO* pAdapterInfo = PAdapterFromNetcfgComponent(pnccAdapter);

    if (pAdapterInfo &&
        pAdapterInfo->m_fIsWanAdapter &&
        pAdapterInfo->m_fIsMultipleIfaceMode)
    {
        hr = GetGuidArrayFromIfaceColWithCoTaskMemAlloc(
                pAdapterInfo->m_IfaceIds,
                ppguidInterfaceIds,
                pdwNumInterfaces);
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CTcpipcfg::GetInterfaceIdsForAdapter");
    return hr;
}


// Add the specified number of new interfaces to the specified adapter.
// The implementation will choose the interface ids.
//
HRESULT
CTcpipcfg::AddInterfacesToAdapter (
    INetCfgComponent*   pnccAdapter,
    DWORD               dwNumInterfaces)
{
    Assert (pnccAdapter);

    HRESULT         hr = S_FALSE;
    ADAPTER_INFO*   pAdapterInfo;

    if ((NULL == pnccAdapter) || (0 == dwNumInterfaces))
    {
        hr = E_INVALIDARG;
        goto end_AddInterfacesToAdapter;
    }

    pAdapterInfo = PAdapterFromNetcfgComponent(pnccAdapter);

    if (pAdapterInfo &&
        pAdapterInfo->m_fIsWanAdapter)
    {
        AddInterfacesToAdapterInfo(
            pAdapterInfo,
            dwNumInterfaces);

        pAdapterInfo->m_fIsMultipleIfaceMode = TRUE;
        pAdapterInfo->m_fNewlyChanged = TRUE;
        m_fSaveRegistry = TRUE;
        m_fReconfig = TRUE;

        // Notify the binding engine that our upper edge has changed.
        //
        (VOID)m_pTcpipPrivate->NotifyUpperEdgeConfigChange ();
        hr = S_OK;
    }

end_AddInterfacesToAdapter:
    TraceErrorSkip1("CTcpipcfg::AddInterfacesToAdapter", hr, S_FALSE);
    return hr;
}


// Remove the specified interface ids from the specified adapter.
// pguidInterfaceIds is the array of ids to be removed.  dwNumInterfaces
// is the count in that array.
//
HRESULT
CTcpipcfg::RemoveInterfacesFromAdapter (
    INetCfgComponent*   pnccAdapter,
    DWORD               dwNumInterfaces,
    const GUID*         pguidInterfaceIds)
{
    Assert (pnccAdapter);
    Assert (pguidInterfaceIds);

    HRESULT         hr = E_UNEXPECTED;
    ADAPTER_INFO*   pAdapterInfo;

    if ((NULL == pnccAdapter) ||
        (0 == dwNumInterfaces) ||
        (NULL == pguidInterfaceIds))
    {
        hr = E_INVALIDARG;
        goto end_RemoveInterfacesFromAdapter;
    }

    pAdapterInfo = PAdapterFromNetcfgComponent(pnccAdapter);

    AssertSz( pAdapterInfo,
        "CTcpipcfg::AddInterfacesToAdapter cannot find the adapter "
        "GUID from the adapter list");

    if (pAdapterInfo &&
        pAdapterInfo->m_fIsWanAdapter &&
        pAdapterInfo->m_fIsMultipleIfaceMode)
    {
        DWORD       dwNumRemoved = 0;
        IFACEITER   iter;
        for (DWORD i = 0; i < dwNumInterfaces; i++)
        {
            iter = find(pAdapterInfo->m_IfaceIds.begin(),
                        pAdapterInfo->m_IfaceIds.end(),
                        pguidInterfaceIds[i]);

            if (iter != pAdapterInfo->m_IfaceIds.end())
            {
                pAdapterInfo->m_IfaceIds.erase(iter);
                dwNumRemoved++;
            }
        }

        //$REVIEW (nsun) mark the adapter as NewlyAdded so that we will re-write its adapter registry
        if (dwNumRemoved > 0)
        {
            pAdapterInfo->m_fNewlyChanged = TRUE;
            m_fSaveRegistry = TRUE;
        }

        // Notify the binding engine that our upper edge has changed.
        //
        (VOID)m_pTcpipPrivate->NotifyUpperEdgeConfigChange ();

        hr = (dwNumRemoved == dwNumInterfaces) ? S_OK : S_FALSE;
    }

end_RemoveInterfacesFromAdapter:
    TraceError("CTcpipcfg::RemoveInterfacesFromAdapter", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// ITcpipProperties
//

// The following two methods are for remote tcpip configuration.
/*
typedef struct tagREMOTE_IPINFO
{
    DWORD   dwEnableDhcp;
    PWSTR pszIpAddrList;
    PWSTR pszSubnetMaskList;
    PWSTR pszOptionList;

} REMOTE_IPINFO;
*/

HRESULT CTcpipcfg::GetIpInfoForAdapter(const GUID*      pguidAdapter,
                                       REMOTE_IPINFO**  ppRemoteIpInfo)
{
    Assert(pguidAdapter);
    Assert(ppRemoteIpInfo);

    // Initialize the output parameter.
    //
    *ppRemoteIpInfo = NULL;

    HRESULT hr = S_OK;

    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguidAdapter);
    if (pAdapter)
    {
        // get the strings from the list
        tstring strIpAddressList;
        ConvertColStringToString(pAdapter->m_vstrIpAddresses,
                                 c_chListSeparator,
                                 strIpAddressList);

        tstring strSubnetMaskList;
        ConvertColStringToString(pAdapter->m_vstrSubnetMask,
                                 c_chListSeparator,
                                 strSubnetMaskList);

        //bug 272647 add gateway metric and interface metric into REMOTE_IPINFO
        tstring strOptionList;
        ConstructOptionListString(pAdapter,
                                  strOptionList);

        // allocate buffer for the output param
        DWORD dwBytes = sizeof(REMOTE_IPINFO) +
                        sizeof(WCHAR)*(strIpAddressList.length() + 1) +
                        sizeof(WCHAR)*(strSubnetMaskList.length() + 1) +
                        sizeof(WCHAR)*(strOptionList.length() + 1);

        PVOID   pbBuf;
        hr = HrCoTaskMemAlloc(dwBytes, &pbBuf);

        if (SUCCEEDED(hr))
        {
            ZeroMemory(pbBuf, dwBytes);

            REMOTE_IPINFO * pRemoteIpInfo = reinterpret_cast<REMOTE_IPINFO *>(pbBuf);
            pRemoteIpInfo->dwEnableDhcp = pAdapter->m_fEnableDhcp;

            BYTE* pbByte = reinterpret_cast<BYTE*>(pbBuf);

            // ip address
            pbByte+= sizeof(REMOTE_IPINFO);
            pRemoteIpInfo->pszwIpAddrList = reinterpret_cast<WCHAR *>(pbByte);
            lstrcpyW(pRemoteIpInfo->pszwIpAddrList, strIpAddressList.c_str());

            // subnet mask
            pbByte += sizeof(WCHAR)*(strIpAddressList.length() + 1);
            pRemoteIpInfo->pszwSubnetMaskList = reinterpret_cast<WCHAR *>(pbByte);
            lstrcpyW(pRemoteIpInfo->pszwSubnetMaskList, strSubnetMaskList.c_str());

            // default gateway
            pbByte += sizeof(WCHAR)*(strSubnetMaskList.length() + 1);
            pRemoteIpInfo->pszwOptionList = reinterpret_cast<WCHAR *>(pbByte);
            lstrcpyW(pRemoteIpInfo->pszwOptionList, strOptionList.c_str());

            *ppRemoteIpInfo = pRemoteIpInfo;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    TraceError("CTcpipcfg::GetIpInfoForAdapter", hr);
    return hr;
}

HRESULT CTcpipcfg::SetIpInfoForAdapter(const GUID*      pguidAdapter,
                                       REMOTE_IPINFO*   pRemoteIpInfo)
{
    Assert(pguidAdapter);
    Assert(pRemoteIpInfo);

    HRESULT hr = S_OK;

    ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(pguidAdapter);
    if (pAdapter)
    {
    
        // Tell INetCfg that our component is dirty
        Assert(m_pTcpipPrivate);
        m_pTcpipPrivate->SetDirty();

        // set the flags so we write this to registry & send notification
        // at apply
        m_fSaveRegistry = TRUE;
        m_fReconfig = TRUE;

        // copy over the info to our data structure
        pAdapter->m_fEnableDhcp = !!pRemoteIpInfo->dwEnableDhcp;

        ConvertStringToColString(pRemoteIpInfo->pszwIpAddrList,
                                 c_chListSeparator,
                                 pAdapter->m_vstrIpAddresses);

        ConvertStringToColString(pRemoteIpInfo->pszwSubnetMaskList,
                                 c_chListSeparator,
                                 pAdapter->m_vstrSubnetMask);

        hr = HrParseOptionList(pRemoteIpInfo->pszwOptionList, pAdapter);

        //we only try to set the m_fNoPopupsDuringPnp when it is currently FALSE
        if (SUCCEEDED(hr) && 
            (!m_fNoPopupsDuringPnp) && 
            NULL != pRemoteIpInfo->pszwOptionList)
        {
            BOOL fDisablePopup = FALSE;

            
            hr = GetPnpPopupSettingFromOptionList(pRemoteIpInfo->pszwOptionList, 
                                        &fDisablePopup);
            if (S_OK == hr)
            {
                m_fNoPopupsDuringPnp = fDisablePopup;
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                //it's ok if the option list string doesn't contain this setting
                hr = S_OK;
            }
        }


    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    TraceError("CTcpipcfg::SetIpInfoForAdapter", hr);
    return hr;
}


STDMETHODIMP
CTcpipcfg::GetUiInfo (
    RASCON_IPUI*  pIpui)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pIpui)
    {
        hr = E_POINTER;
    }
    else
    {
        ZeroMemory (pIpui, sizeof(*pIpui));

        ADAPTER_INFO* pAdapter = PAdapterFromInstanceGuid(
                                    &m_guidCurrentConnection);
        if (pAdapter)
        {
            if (!pAdapter->m_fEnableDhcp &&
                pAdapter->m_vstrIpAddresses.size())
            {
                pIpui->dwFlags |= RCUIF_USE_IP_ADDR;

                lstrcpyW(pIpui->pszwIpAddr,
                        pAdapter->m_vstrIpAddresses[0]->c_str());
            }

            if (pAdapter->m_vstrDnsServerList.size() > 0)
            {
                pIpui->dwFlags |= RCUIF_USE_NAME_SERVERS;

                lstrcpyW(pIpui->pszwDnsAddr,
                        pAdapter->m_vstrDnsServerList[0]->c_str());

                if (pAdapter->m_vstrDnsServerList.size() > 1)
                {
                    lstrcpyW(pIpui->pszwDns2Addr,
                            pAdapter->m_vstrDnsServerList[1]->c_str());
                }
            }

            if (pAdapter->m_vstrWinsServerList.size() > 0)
            {
                pIpui->dwFlags |= RCUIF_USE_NAME_SERVERS;

                lstrcpyW(pIpui->pszwWinsAddr,
                        pAdapter->m_vstrWinsServerList[0]->c_str());

                if (pAdapter->m_vstrWinsServerList.size() > 1)
                {
                    lstrcpyW(pIpui->pszwWins2Addr,
                            pAdapter->m_vstrWinsServerList[1]->c_str());
                }
            }

            if (pAdapter->m_fUseRemoteGateway)
            {
                 pIpui->dwFlags |= RCUIF_USE_REMOTE_GATEWAY;
            }

            if (pAdapter->m_fUseIPHeaderCompression)
            {
                pIpui->dwFlags |= RCUIF_USE_HEADER_COMPRESSION;
            }

            if (pAdapter->m_fDisableDynamicUpdate)
            {
                pIpui->dwFlags |= RCUIF_USE_DISABLE_REGISTER_DNS;
            }

            if (pAdapter->m_fEnableNameRegistration)
            {
                pIpui->dwFlags |= RCUIF_USE_PRIVATE_DNS_SUFFIX;
            }

            if (c_dwEnableNetbios == pAdapter->m_dwNetbiosOptions)
            {
                pIpui->dwFlags |= RCUIF_ENABLE_NBT;
            }

            lstrcpynW(pIpui->pszwDnsSuffix, 
                     pAdapter->m_strDnsDomain.c_str(), 
                     sizeof(pIpui->pszwDnsSuffix)/sizeof(pIpui->pszwDnsSuffix[0]));

            pIpui->dwFrameSize = pAdapter->m_dwFrameSize;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    TraceError("CTcpipcfg::GetUiInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcputil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T C P U T I L . C P P
//
//  Contents: Utility functions used by tcpipcfg
//
//  Notes:
//
//  Author:     tongl
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <dsrole.h>
#include "ncatlui.h"
#include <time.h>
#include "ncreg.h"
#include "ncstl.h"
#include "ncui.h"
#include "tcpconst.h"
#include "tcputil.h"
#include "resource.h"
#include "tcpmacro.h"
#include "atmcommon.h"

#define MAX_NUM_DIGIT_MULTI_INTERFACES  10

extern const WCHAR c_szNetCfgHelpFile[];

// HrLoadSubkeysFromRegistry
// Gets the list of subkeys under a registry key
// hkey             the root registry key
// pvstrAdapters    returns the list of subkeykey names from hkey

HRESULT HrLoadSubkeysFromRegistry(const HKEY hkey,
                                  OUT VSTR * const pvstrSubkeys)
{
    HRESULT hr = S_OK;
    Assert(pvstrSubkeys);

    // Initialize output parameter
    FreeCollectionAndItem(*pvstrSubkeys);

    WCHAR szBuf[256];
    FILETIME time;
    DWORD dwSize = celems(szBuf);
    DWORD dwRegIndex = 0;

    while(SUCCEEDED(hr = HrRegEnumKeyEx(hkey, dwRegIndex++, szBuf,
                                        &dwSize, NULL, NULL, &time)))
    {
        dwSize = celems(szBuf);
        Assert(szBuf);
        pvstrSubkeys->push_back(new tstring(szBuf));
    }

    if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
        hr = S_OK;

    TraceError("HrLoadSubkeysFromRegistry", hr);
    return hr;
}

//
//HrIsComponentInstalled      Given a Component ID, determins if the component
//                            is installed in the system
// Note: The net class of the component must be
//
//pnc              the system's INetCfg
//rguidClass       the Net Class of this component we are earching for
//pszInfId          the Component ID
//pfInstalled      returns a flag to determine if the component is installed
//
// Returns S_OK if succeed ( whether component found or not
//         Other: ERROR

HRESULT HrIsComponentInstalled(INetCfg * pnc,
                             const GUID& rguidClass,
                             PCWSTR pszInfId,
                             OUT BOOL * const pfInstalled)
{
    Assert(pnc);
    Assert(pszInfId);
    Assert(pfInstalled);

    *pfInstalled = FALSE;

    INetCfgComponent *  pncc;

    HRESULT hr = pnc->FindComponent(pszInfId, &pncc);

    if(hr == S_OK)
    {
        Assert(pncc);
        *pfInstalled = TRUE;
    }
    else if(hr == S_FALSE)
    {
        Assert(!pncc);
        *pfInstalled = FALSE;
        hr = S_OK;
    }

    ReleaseObj(pncc);

    TraceError("HrIsComponentInstalled", hr);
    return hr;
}

//
//  GetNodeNum
//
//  Get an IP Address and return the 4 numbers in the IP address.
//
//  pszIpAddress:    IP Address
//  ardw[4]:        The 4 numbers in the IP Address

VOID GetNodeNum(PCWSTR pszIpAddress, DWORD ardw[4])
{
    VSTR    vstr;

    tstring strIpAddress(pszIpAddress);

    ConvertStringToColString(strIpAddress.c_str(),
                             CH_DOT,
                             vstr);

    VSTR_ITER iter = vstr.begin();
    // Go through each field and get the number value

    ardw[0] = 0;
    ardw[1] = 0;
    ardw[2] = 0;
    ardw[3] = 0;

    if(iter != vstr.end())
    {
        ardw[0] = _ttol((*iter++)->c_str());
        if(iter != vstr.end())
        {
            ardw[1] = _ttol((*iter++)->c_str());
            if(iter != vstr.end())
            {
                ardw[2] = _ttol((*iter++)->c_str());
                if(iter != vstr.end())
                {
                    ardw[3] = _ttol((*iter++)->c_str());
                }
            }
        }
    }
    FreeCollectionAndItem(vstr);
}

//Check if the subnet mask is contiguous
//Return:   TRUE    contiguous
//          FALSE   uncontigous
BOOL IsContiguousSubnet(PCWSTR pszSubnet)
{
    DWORD ardwSubnet[4];

    GetNodeNum(pszSubnet, ardwSubnet);

    DWORD dwMask = (ardwSubnet[0] << 24) + (ardwSubnet[1] << 16)
             + (ardwSubnet[2] << 8) + ardwSubnet[3];


    DWORD i, dwContiguousMask;

    // Find out where the first '1' is in binary going right to left
    dwContiguousMask = 0;
    for (i = 0; i < sizeof(dwMask)*8; i++)
    {
        dwContiguousMask |= 1 << i;

        if (dwContiguousMask & dwMask)
            break;
    }

    // At this point, dwContiguousMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwContiguousMask = dwMask | ~dwContiguousMask;

    // If the new mask is different, correct it here
    if (dwMask != dwContiguousMask)
        return FALSE;
    else
        return TRUE;
}

// Replace first element of a vector of tstrings
VOID ReplaceFirstAddress(VSTR * pvstr, PCWSTR pszIpAddress)
{
    Assert(pszIpAddress);

    if(pvstr->empty())
    {
        pvstr->push_back(new tstring(pszIpAddress));
    }
    else
    {
        *(*pvstr)[0] = pszIpAddress;
    }
}

// Replace second element of a vector of tstrings
VOID ReplaceSecondAddress(VSTR * pvstr, PCWSTR pszIpAddress)
{
    Assert(pszIpAddress);

    if (pvstr->size()<2)
    {
        pvstr->push_back(new tstring(pszIpAddress));
    }
    else
    {
        *(*pvstr)[1] = pszIpAddress;
    }
}

// Generate subnetmask for an IP address
BOOL GenerateSubnetMask(IpControl & ipAddress,
                        tstring * pstrSubnetMask)
{
    BOOL bResult = TRUE;

    if (!ipAddress.IsBlank())
    {
        tstring strAddress;
        DWORD adwIpAddress[4];

        ipAddress.GetAddress(&strAddress);
        GetNodeNum(strAddress.c_str(), adwIpAddress);

        DWORD nValue = adwIpAddress[0];

        if(nValue <= SUBNET_RANGE_1_MAX)
        {
            *pstrSubnetMask = c_szBASE_SUBNET_MASK_1;
        }
        else if( nValue <= SUBNET_RANGE_2_MAX)
        {
            *pstrSubnetMask = c_szBASE_SUBNET_MASK_2;
        }
        else if( nValue <= SUBNET_RANGE_3_MAX)
        {
            *pstrSubnetMask = c_szBASE_SUBNET_MASK_3;
        }
        else
        {
            Assert(FALSE);
            bResult = FALSE;
        }
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}

// BOOL fIsSameVstr
// Return TRUE is all strings in a vstr are the same and in same order
BOOL fIsSameVstr(const VSTR vstr1, const VSTR vstr2)
{
    int iCount1 = vstr1.size();
    int iCount2 = vstr2.size();
    int idx =0;

    if (iCount1 != iCount2)
    {
        return FALSE;
    }
    else // same size
    {
        // For each string in both vstr1 and vstr2
        for (idx=0; idx<iCount1; idx++)
        {
            // if mismatch found
            if((*vstr1[idx] != *vstr2[idx]))
            {
                return FALSE;
            }
        }
    }

    Assert((iCount1==iCount2) && (iCount1==idx));
    return TRUE;
}

// Registry access help functions for Boolean type
// FRegQueryBool
// hkey         the regisry key
// pszName       the value in the registry key
// fValue       the default vaule
//
// NOTE:    If the function failed to read the value from the registry, it will return
//          the default value.

BOOL    FRegQueryBool(const HKEY hkey, PCWSTR pszName, BOOL fDefaultValue)
{
    BOOL fRetValue = fDefaultValue;
    DWORD dwValue;

    HRESULT hr = HrRegQueryDword(hkey, pszName, &dwValue);

    if (S_OK == hr)
    {
        fRetValue = !!dwValue;
    }
#ifdef ENABLETRACE
    else
    {
        const HRESULT hrNoRegValue = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        if (hr == hrNoRegValue)
        {
            TraceTag(ttidTcpip, "FRegQueryBool: registry key %S not found", pszName);
            hr = S_OK;
        }
    }
#endif

    TraceError("FRegQueryBool", hr);
    return fRetValue;
}



// ResetLmhostsFile
// Called by Cancel and Cancelproperties to roll back changes to the file lmhosts
VOID ResetLmhostsFile()
{
    WCHAR szSysPath[MAX_PATH] = {0};
    WCHAR szSysPathBackup[MAX_PATH];

    BOOL fSysPathFound = (GetSystemDirectory(szSysPath, MAX_PATH) != 0);

    lstrcpyW(szSysPathBackup, szSysPath);

    wcscat(szSysPath, RGAS_LMHOSTS_PATH);
    wcscat(szSysPathBackup, RGAS_LMHOSTS_PATH_BACKUP);

    WIN32_FIND_DATA FileData;
    if (FindFirstFile(szSysPathBackup, &FileData) == INVALID_HANDLE_VALUE)
    {
        AssertSz(FALSE, "lmhosts.bak file not found");
    }
    else
    {
        BOOL ret;

        // Rename lmhosts.bak file to lmhosts
        ret = MoveFileEx(szSysPathBackup, szSysPath, MOVEFILE_REPLACE_EXISTING);
        AssertSz(ret, "Failed to restore lmhosts file!");
    }
}

//
//  IPAlertPrintf() - Does a printf to a message box for IP address
//
//  ids: message string, IDS_IPBAD_FIELD_VALUE
//  iCurrent: value of the field
//  iLow: Low range of the field
//  iHigh: High range of the field
//
int IPAlertPrintf(HWND hwndParent, UINT ids,
                  int iCurrent, int iLow, int iHigh)
{

    if (ids != IDS_IPNOMEM)
    {
        WCHAR szCurrent[3];
        wsprintfW(szCurrent, c_szItoa, iCurrent);

        WCHAR szLow[3];
        wsprintfW(szLow, c_szItoa, iLow);

        WCHAR szHigh[3];
        wsprintfW(szHigh, c_szItoa, iHigh);

        return NcMsgBox(hwndParent,
                        IDS_IPMBCAPTION,
                        ids,
                        MB_ICONEXCLAMATION,
                        szCurrent, szLow, szHigh);
    }
    else
        return NcMsgBox(hwndParent,
                        IDS_IPMBCAPTION,
                        ids,
                        MB_ICONEXCLAMATION);

}

// IpRangeError
//
VOID IpCheckRange(LPNMIPADDRESS lpnmipa, HWND hWnd, int iLow, int iHigh, BOOL fCheckLoopback)
{
    /*
    // This is a workaround because the IP control will send this notification
    // twice if I don't set the out of range value in this code. However there
    // is no way to set the value of an individual field. Send request to strohma.
    static BOOL fNotified = FALSE;
    static int iNotifiedValue = 0;

    if ((lpnmipa->iValue != c_iEmptyIpField) &&
        ((lpnmipa->iValue<iLow) || (lpnmipa->iValue>iHigh)))
    {
        if (!fNotified) // If we havn't been notified yet
        {
            fNotified = TRUE;
            iNotifiedValue = lpnmipa->iValue;

            IPAlertPrintf(hWnd, IDS_IPBAD_FIELD_VALUE,
                          lpnmipa->iValue, iLow, iHigh);
        }
        else // ignor the second notify
        {
            // Make sure we are alerted of change in the workaround from common control
            AssertSz(iNotifiedValue == lpnmipa->iValue, "Common control behaviour changed!!");
            fNotified = FALSE;
            iNotifiedValue =0;
        }
    };
    */
/*
    // This is a workaround because the IP control will send this notification
    // twice if I don't set the out of range value in this code. However there
    // is no way to set the value of an individual field. Send request to strohma.
    if ((lpnmipa->iValue != c_iEmptyIpField) &&
        ((lpnmipa->iValue<iLow) || (lpnmipa->iValue>iHigh)))
    {
        IPAlertPrintf(hWnd, IDS_IPBAD_FIELD_VALUE,
                      lpnmipa->iValue, iLow, iHigh);
        if (lpnmipa->iValue<iLow)
            lpnmipa->iValue = iLow;
        else
            lpnmipa->iValue = iHigh;

    };
*/

    //$REVIEW (nsun) BUG171839 this is a workaround because the IP control will send this notifcation
    // twice when I put a 3 digit value. I added a static value to make sure every error message
    // is brought up only once
    // The static values that should be able to uniquely identify a notification
    static UINT idIpControl = 0;
    static int  iField = 0;
    static int  iValue = 0;

    //we know the notification may be sent twice
    //We only want to the second duplcate notifiction
    //If we receive the third notification with the same control, field and value, it should
    //be real notification and we shouldn't ignore it.
    static UINT  cRejectTimes = 0;

    if(idIpControl != lpnmipa->hdr.idFrom ||
       iField != lpnmipa->iField || iValue != lpnmipa->iValue || cRejectTimes > 0)
    {
        //update the static values
        //(nsun) We have to update the static values before the error
        //  message box because there will be IPN_FIELDCHANGED notification
        //  sent out when the message box is brought up.
        cRejectTimes = 0;
        idIpControl = (UINT)lpnmipa->hdr.idFrom;
        iField = lpnmipa->iField;
        iValue = lpnmipa->iValue;

        if ((lpnmipa->iValue != c_iEmptyIpField) &&
        ((lpnmipa->iValue<iLow) || (lpnmipa->iValue>iHigh)))
        {
            IPAlertPrintf(hWnd, IDS_IPBAD_FIELD_VALUE,
                          lpnmipa->iValue, iLow, iHigh);
        }

        if (fCheckLoopback && lpnmipa->iValue == c_iIPADDR_FIELD_1_LOOPBACK
            && 0 == lpnmipa->iField)
        {
            IPAlertPrintf(hWnd, IDS_INCORRECT_IP_LOOPBACK,
                          lpnmipa->iValue, iLow, iHigh);
            lpnmipa->iValue = iLow;
        }
    }
    else
    {
        cRejectTimes++;
    }

}


//+---------------------------------------------------------------------------
//
//  Name:     SetButtons
//
//  Purpose:   Enables/disables push buttons based on item count and current selection
//             in the list.
//             Used by DNS and ATM ARPC pages that have group of HANDLES
//
//  Arguments:
//      h         [in]   The group of handles
//      nNumLimit [in]   Limit of number of elements allowed in the list
//
//  Returns:    Nothing
//
//  Author:     tongl  9 July 1997
//
//  Notes:
//
VOID SetButtons(HANDLES& h, const int nNumLimit)
{
    Assert(IsWindow(h.m_hList));
    Assert(IsWindow(h.m_hAdd));
    Assert(IsWindow(h.m_hEdit));
    Assert(IsWindow(h.m_hRemove));

    // $REVIEW(tongl):macro problem
    int nCount = Tcp_ListBox_GetCount(h.m_hList);

    // If there are currently no item in list, set focus to "Add" button
    if (!nCount)
    {
        // remove the default on the remove button, if any
        SendMessage(h.m_hRemove, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

        // move focus to Add button
        ::SetFocus(h.m_hAdd);
    }

    // If number of items less than limit, enable "Add" button
    // Otherwise disable it
    if (nCount != nNumLimit)
        ::EnableWindow(h.m_hAdd, TRUE);
    else
    {
        //disable the button and move focus only if the add button is currently enabled
        if (::IsWindowEnabled(h.m_hAdd))
        {
            // disable "Add button"
            ::EnableWindow(h.m_hAdd, FALSE);

            // remove the default on the add button, if any
            SendMessage(h.m_hAdd, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

            // move focus to edit button
            ::SetFocus(h.m_hEdit);
        }
    }

    // If number of items >0, enable "Edit" and "Remove" buttons
    // Otherwise disable them

    ::EnableWindow(h.m_hEdit, nCount);
    ::EnableWindow(h.m_hRemove, nCount);

    // Enable/disable the "Up" and "Down" buttons

    // determine Up and Down logic
    if (nCount > 1)
    {
        int idxCurSel = Tcp_ListBox_GetCurSel(h.m_hList);
        Assert(idxCurSel != CB_ERR );

        BOOL fChangeFocus = FALSE;

        if (idxCurSel == 0)
        {
            if (h.m_hUp == ::GetFocus())
                fChangeFocus = TRUE;

            ::EnableWindow(h.m_hUp, FALSE);
            ::EnableWindow(h.m_hDown, TRUE);

            // remove the default on the up button, if any
            SendMessage(h.m_hUp, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

            if (fChangeFocus)
                ::SetFocus(h.m_hDown);
        }
        else if (idxCurSel == (nCount-1))
        {
            if (h.m_hDown == ::GetFocus())
                fChangeFocus = TRUE;

            ::EnableWindow(h.m_hUp, TRUE);
            ::EnableWindow(h.m_hDown, FALSE);

            // remove the default on the down button, if any
            SendMessage(h.m_hDown, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

            if (fChangeFocus)
                ::SetFocus(h.m_hUp);
        }
        else
        {
            ::EnableWindow(h.m_hUp, TRUE);
            ::EnableWindow(h.m_hDown, TRUE);
        }
    }
    else
    {
        ::EnableWindow(h.m_hUp, FALSE);
        ::EnableWindow(h.m_hDown, FALSE);
    }

}

//+---------------------------------------------------------------------------
//
//  Name:     ListBoxRemoveAt
//
//  Purpose:   Remove an item from a list box and save it to a tstring
//             Used by DNS and ATM ARPC pages.
//
//  Arguments:
//      hListBox            [in]   Handle to the list box
//      idx                 [in]   Index of the item to remove
//      pstrRemovedItem     [out]  The content of the removed item
//
//  Returns:    TRUE if succeeded, else FALSE
//
//  Author:     tongl  9 July 1997
//
//  Notes:
//
BOOL ListBoxRemoveAt(HWND hListBox, int idx, tstring * pstrRemovedItem)
{
    BOOL bResult = FALSE;

    Assert(idx >=0);
    Assert(hListBox);

    WCHAR buf[MAX_PATH];
    int len;
    if((len = Tcp_ListBox_GetTextLen(hListBox, idx)) >= celems(buf))
    {
        Assert(FALSE);
        return FALSE;
    }
    Assert(len != 0);

    Tcp_ListBox_GetText(hListBox, idx, buf);
    *pstrRemovedItem = buf;

    if (len != 0)
    {
        if (::SendMessage(hListBox,
                          LB_DELETESTRING,
                          (WPARAM)(int)(idx), 0L) != LB_ERR)

            bResult = TRUE;
    }

    return bResult;
}

//+---------------------------------------------------------------------------
//
//  Name:     ListBoxInsertAfter
//
//  Purpose:   Insert an item into a list box
//             Used by DNS and ATM ARPC pages
//
//  Arguments:
//      hListBox    [in]   Handle to the list box
//      idx         [in]   Index of the item to insert after
//      pszItem      [out]  The item to insert
//
//  Returns:    TRUE if succeeded, else FALSE
//
//  Author:     tongl  9 July 1997
//
//  Notes:
//
BOOL ListBoxInsertAfter(HWND hListBox, int idx, PCWSTR pszItem)
{
#ifdef DBG
    Assert(hListBox);

    // validate the range
    int nCount = Tcp_ListBox_GetCount(hListBox);

    Assert(idx >=0);
    Assert(idx <= nCount);

    // insist there is a string
    Assert(pszItem);
#endif

    return (Tcp_ListBox_InsertString(hListBox, idx, pszItem) == idx);
}

//+---------------------------------------------------------------------------
//
//  Name:     HrRegRenameTree
//
//  Purpose:   Rename a registr subkey
//
//  Arguments:
//      hkeyRoot    [in]   The root key where the subkey to be renamed exists
//      pszOldName   [in]   The existing name of the sub key
//      pszNewName   [in]   The new name of the sub key
//
//  Returns:    S_OK if succeeded,
//              E_FAIL otherwise
//
//  Author:     tongl  7 Aug 1997
//
//  Notes:
//
HRESULT HrRegRenameTree(HKEY hkeyRoot, PCWSTR pszOldName, PCWSTR pszNewName)
{
    HRESULT hr = S_OK;
    HKEY hkeyNew = NULL;
    HKEY hkeyOld = NULL;
    DWORD dwDisposition;

    //$REVIEW (nsun) make sure we don't rename the same tree
    if(0 == lstrcmpiW (pszOldName, pszNewName))
        return S_OK;

    // Create new subkey
    hr = HrRegCreateKeyEx(hkeyRoot,
                          pszNewName,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ_WRITE,
                          NULL,
                          &hkeyNew,
                          &dwDisposition);

    if (S_OK == hr)
    {
        // Copy all items under old subkey to new subkey
        hr = HrRegOpenKeyEx(hkeyRoot,
                            pszOldName,
                            KEY_READ_WRITE_DELETE,
                            &hkeyOld);
        if (S_OK == hr)
        {
            hr = HrRegCopyKeyTree(hkeyNew, hkeyOld);
            RegSafeCloseKey(hkeyOld);

            if (S_OK == hr)
            {
                // Delete old subkey
                hr = HrRegDeleteKeyTree(hkeyRoot, pszOldName);
            }
        }
    }
    RegSafeCloseKey(hkeyNew);

    TraceTag(ttidTcpip, "HrRegRenameTree failed to rename %S to %S", pszOldName, pszNewName);

    TraceError("Tcpipcfg: HrRegRenameTree failed", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     HrRegCopyKeyTree
//
//  Purpose:   Copies a registry subtree to a new location
//
//  Arguments:
//      hkeyDest    [in]   The subkey to copy to
//      hkeySrc     [in]   The subkey to copy from
//
//  Returns:    S_OK if succeeded,
//              E_FAIL otherwise
//
//  Author:     tongl  7 Aug 1997
//
//  Notes: Modified from NetSetupRegCopyTree in ncpa1.1\netcfg\setup.cpp
//
HRESULT HrRegCopyKeyTree(HKEY hkeyDest, HKEY hkeySrc )
{
    HRESULT hr = S_OK;
    FILETIME ftLastWrite;

    DWORD cchMaxSubKeyLen;
    DWORD cchMaxClassLen;
    DWORD cchMaxValueNameLen;
    DWORD cbMaxValueLen;

    DWORD  iItem;
    PWSTR pszName;
    PWSTR pszClass;
    PBYTE pbData;

    DWORD cchName;
    DWORD cchClass;
    DWORD cbData;

    HKEY hkeyChildDest = NULL;
    HKEY hkeyChildSrc = NULL;

    DWORD dwDisposition;

    // Find out the longest name and data field and create the buffers
    // to store enumerations in
    //
    LONG lrt;
    lrt =  RegQueryInfoKeyW( hkeySrc,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            &cchMaxSubKeyLen,
                            &cchMaxClassLen,
                            NULL,
                            &cchMaxValueNameLen,
                            &cbMaxValueLen,
                            NULL,
                            &ftLastWrite );
    do
    {
        if (ERROR_SUCCESS != lrt)
        {
            hr = HrFromLastWin32Error();
            break;
        }

        // use only one buffer for all names, values or keys
        cchMaxValueNameLen = max( cchMaxSubKeyLen, cchMaxValueNameLen );

        // allocate buffers
        hr = E_OUTOFMEMORY;

        pszName = new WCHAR[cchMaxValueNameLen + 1];
        if (NULL == pszName)
        {
            break;
        }

        pszClass = new WCHAR[cchMaxClassLen + 1];
        if (NULL == pszClass)
        {
            delete [] pszName;
            break;
        }

        pbData = new BYTE[ cbMaxValueLen ];
        if (NULL == pbData)
        {
            delete [] pszName;
            delete [] pszClass;
            break;
        }

        hr = S_OK;

        // enum all sub keys and copy them
        //
        iItem = 0;
        do
        {
            cchName = cchMaxValueNameLen + 1;
            cchClass = cchMaxClassLen + 1;

            // Enumerate the subkeys
            hr = HrRegEnumKeyEx(hkeySrc,
                                iItem,
                                pszName,
                                &cchName,
                                pszClass,
                                &cchClass,
                                &ftLastWrite );
            iItem++;
            if (SUCCEEDED(hr))
            {
                // create key at destination
                // Note: (tongl 8/7/97): Netcfg common code sets class to NULL ??
                hr = HrRegCreateKeyEx(  hkeyDest,
                                        pszName,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE,
                                        NULL,
                                        &hkeyChildDest,
                                        &dwDisposition );

                if (S_OK != hr)
                {
                    break;
                }

                // open the key at source
                hr = HrRegOpenKeyEx(hkeySrc,
                                    pszName,
                                    KEY_READ_WRITE,
                                    &hkeyChildSrc );

                if (S_OK != hr)
                {
                    RegSafeCloseKey(hkeyChildDest);
                    break;
                }

                // copy this sub-tree
                hr = HrRegCopyKeyTree(hkeyChildDest, hkeyChildSrc);

                RegSafeCloseKey(hkeyChildDest);
                RegSafeCloseKey(hkeyChildSrc);
            }

        } while (S_OK == hr);

        // We are done with the subkeys, now onto copying values
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            // enum completed, no errors
            //

            DWORD dwType;
            // enum all values and copy them
            //
            iItem = 0;
            do
            {
                cchName = cchMaxValueNameLen + 1;
                cbData = cbMaxValueLen;

                hr = HrRegEnumValue(hkeySrc,
                                    iItem,
                                    pszName,
                                    &cchName,
                                    &dwType,
                                    pbData,
                                    &cbData );
                iItem++;
                if (S_OK == hr)
                {
                    // write the value to the destination
                    hr = HrRegSetValueEx(hkeyDest,
                                         pszName,
                                         dwType,
                                         pbData,
                                         cbData );
                }
            } while (S_OK == hr);

            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
            {
                // if we hit the end of the enum without error
                // reset error code to success
                //
                hr = S_OK;
            }
        }

        // free our buffers
        delete [] pszName;
        delete [] pszClass;
        delete [] pbData;
    } while ( FALSE );

    TraceError("HrRegCopyKeyTree failed.", hr);
    return( hr );
}

//+---------------------------------------------------------------------------
//
//  Name:     fQueryFirstAddress
//
//  Purpose:   Retrieves the first string in a vector of strings
//
//  Arguments:
//      vstr    [in]   The vector of strings
//      pstr    [in]   The first string
//
//  Returns:    TRUE if succeeded,
//              FALSE otherwise
//
//  Author:     tongl  10 Nov 1997
//
//  Notes: Modified from NetSetupRegCopyTree in ncpa1.1\netcfg\setup.cpp
//

BOOL fQueryFirstAddress(const VSTR & vstr, tstring * const pstr)
{
    if(vstr.empty())
    {
        *pstr = L"";
        return FALSE;
    }
    else
    {
        *pstr = *vstr[0];
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Name:     fQuerySecondAddress
//
//  Purpose:   Retrieves the first string in a vector of strings
//
//  Arguments:
//      vstr    [in]   The vector of strings
//      pstr    [in]   The second string
//
//  Returns:    TRUE if succeeded,
//              FALSE otherwise
//
//  Author:     tongl  10 Nov 1997
//
//  Notes: Modified from NetSetupRegCopyTree in ncpa1.1\netcfg\setup.cpp
//

BOOL fQuerySecondAddress(const VSTR & vstr, tstring * const pstr)
{
    if(vstr.size()<2)
    {
        *pstr = L"";
        return FALSE;
    }
    else
    {
        *pstr = *vstr[1];
        return TRUE;
    }
}

// Function that decides whether a string is a valid ATM address
// Return TRUE if Valid, return FALSE and the index of the first
// invalid character if invalid.
BOOL FIsValidAtmAddress(PCWSTR pszAtmAddress,
                        INT * piErrCharPos,
                        INT * pnId)
{
    const WCHAR * pch;
    *piErrCharPos =0;
    *pnId =0;

    // 1. Validate characters must be '+' (first character),
    //    '.', or hex digits '0'~'F'
    for (pch=pszAtmAddress; *pch; pch++)
    {
        if (!(((*pch == L'+') && (pch == pszAtmAddress))||
              (*pch == L'.')||
              (((*pch >= L'0') && (*pch <= L'9'))||
               ((*pch >= L'A') && (*pch <= L'F'))||
               ((*pch >= L'a') && (*pch <= L'f')))))
        {
            *piErrCharPos = (INT)(pch - pszAtmAddress);
            *pnId = IDS_ATM_INVALID_CHAR;
            return FALSE;
        }

        if (*pch == L'.')
        {
            // '.' is for punctuation, so it should not be at the beginning,
            // end or have two in a row

            if ((pch == pszAtmAddress) ||
                (pch == pszAtmAddress+lstrlenW(pszAtmAddress)-1) ||
                (*pch == *(pch+1)))
            {
                *piErrCharPos = (INT)(pch-pszAtmAddress);
                *pnId = IDS_ATM_INVALID_CHAR;
                return FALSE;
            }
        }
    }

    // 2. Strip off all punctuation characters ('.' characters)
    PWSTR pszBuff = new WCHAR[lstrlenW(pszAtmAddress)+1];
    if (NULL == pszBuff)
        return TRUE;

    PWSTR pchBuff = pszBuff;
    pch = pszAtmAddress;

    for (pch = pszAtmAddress; *pch; pch++)
    {
        if (*pch != L'.')
        {
            *pchBuff = *pch;
            pchBuff++;
        }
    }

    *pchBuff = L'\0';

    // 3. Decide whether the address is E.164 or NSAP
    //    and check syntax accordingly

    if ((lstrlenW(pszBuff) <= 15) ||
        ((*pszBuff == L'+') && (lstrlenW(pszBuff) <= 16)))
    {
        // The address is E.164;
        // Check if string is empty
        if (*pchBuff == L'+')
        {
            pchBuff++;

            if (lstrlenW(pchBuff) == 0) // empty string
            {
                *pnId = IDS_ATM_EMPTY_ADDRESS;
                delete pszBuff;

                return FALSE;
            }
        }

        // Check that all characters are in range '0' through '9'
        // i.e. (ASCII values)
        pch = pszAtmAddress;
        if (*pch == L'+')
        {
            pch++;
        }

        while (*pch)
        {
            if ((*pch != L'.') &&
                (!((*pch >= L'0') && (*pch <= L'9'))))
            {
                *piErrCharPos = (INT)(pch-pszAtmAddress);
                *pnId = IDS_ATM_INVALID_CHAR;

                delete pszBuff;
                return FALSE;
            }
            pch++;
        }
    }
    else
    {
        // The address is NSAP;
        if (lstrlenW(pszBuff) != 40)
        {
            *pnId = IDS_ATM_INVALID_LENGTH;

            delete pszBuff;
            return FALSE;
        }
    }

    delete pszBuff;
    return TRUE;
}

BOOL FIsIpInRange(PCWSTR pszIp)
{
    BOOL fReturn = TRUE;
    DWORD ardwIp[4];
    GetNodeNum(pszIp, ardwIp);

    if ((ardwIp[0] > c_iIPADDR_FIELD_1_HIGH) ||
        (ardwIp[0] < c_iIPADDR_FIELD_1_LOW))
    {
        fReturn = FALSE;
    }

    return fReturn;
}

VOID ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs)
{
    if (pdwHelpIDs != NULL)
    {
        WinHelp(hDlg,
                c_szNetCfgHelpFile,
                uCommand,
                (ULONG_PTR)pdwHelpIDs);
    }
}


//+---------------------------------------------------------------------------
//
//  Name:     AddInterfacesToAdapterInfo
//
//  Purpose:   Add several interfaces IDs into the interface list
//
//  Arguments:
//      pAdapter        [in]    Adapter info to add interfaces to
//      dwNumInterfaces [in]    Number of interface IDs to be added
//
//  Returns:    None
//
//  Author:     nsun  22 August 1998
//
//
VOID AddInterfacesToAdapterInfo(
    ADAPTER_INFO*   pAdapter,
    DWORD           dwNumInterfaces)
{
    DWORD i;
    GUID  guid;

    for (i = 0; i < dwNumInterfaces; i++)
    {
        if (SUCCEEDED(CoCreateGuid(&guid)))
        {
            pAdapter->m_IfaceIds.push_back(guid);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Name:     GetGuidArrayFromIfaceColWithCoTaskMemAlloc
//
//  Purpose:   Get the data as a DWORD array from a DWORD list.
//             The caller is responsible to free the array by
//             calling CoTaskMemFree()
//
//  Arguments:
//      ldw     [in]    The DWORD list
//      ppdw    [out]   Pointer to the array
//      pcguid  [out]   The count of guids placed in the array.
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  Author:     nsun  22 August 1998
//
//
HRESULT GetGuidArrayFromIfaceColWithCoTaskMemAlloc(
    const IFACECOL& Ifaces,
    GUID**          ppguid,
    DWORD*          pcguid)
{
    Assert(pcguid);

    // Initialize output parameters
    //
    if (ppguid)
    {
        *ppguid = NULL;
    }

    HRESULT hr = S_OK;
    DWORD cguid = Ifaces.size();

    if ((cguid > 0) && ppguid)
    {
        GUID* pguid = (GUID*)CoTaskMemAlloc(cguid * sizeof(GUID));
        if (pguid)
        {
            *ppguid = pguid;
            *pcguid = cguid;

            IFACECOL::const_iterator iter;
            for (iter  = Ifaces.begin();
                 iter != Ifaces.end();
                 iter++)
            {
                *(pguid++) = *iter;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        // Caller just wants the count.
        //
        *pcguid = 0;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "GetGuidArrayFromIfaceColWithCoTaskMemAlloc");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     GetInterfaceName
//
//  Purpose:   Get the interface name as <Adapter name>_<interface ID>
//             to support multiple interface for WAN adapters.
//
//  Arguments:
//      pszAdapterName  [in]   The adapter name
//      guidIfaceId     [in]   The interface ID
//      pstrIfaceName   [out]  The interface name
//
//  Returns:    None
//
//  Author:     nsun  12 Sept 1998
//
//  Note:       This function is also used to construct NetBt binding
//              interface names from NetBt binding path
//
VOID GetInterfaceName(
    PCWSTR      pszAdapterName,
    const GUID& guidIfaceId,
    tstring*    pstrIfaceName)
{
    Assert(pszAdapterName);
    Assert(pstrIfaceName);

    WCHAR pszGuid [c_cchGuidWithTerm];

    StringFromGUID2 (guidIfaceId, pszGuid, c_cchGuidWithTerm);

//    pstrIfaceName->assign(pszAdapterName);
//    pstrIfaceName->append(pszGuid);
    pstrIfaceName->assign(pszGuid);
}


//+---------------------------------------------------------------------------
//
//  Name:     RetrieveStringFromOptionList
//
//  Purpose:   Retrieve a substring from the option list of REMOTE_IPINFO
//
//
//  Arguments:
//      pszOption       [in]   The string of option list
//      szIdentifier    [in]   The identifier of the substring to retrieve
//      str             [out]  The substring
//
//  Returns:    S_OK
//              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)
//              E_INVALIDARG
//
//  Author:     nsun  01/11/99
//
//
HRESULT RetrieveStringFromOptionList(PCWSTR pszOption,
                                     PCWSTR szIdentifier,
                                     tstring & str)
{
    Assert(szIdentifier);

    HRESULT hr = S_OK;
    WCHAR*  pszBegin;
    WCHAR*  pszEnd;
    PWSTR  pszString = NULL;

    str = c_szEmpty;

    if (!pszOption)
    {
        goto LERROR;
    }

    pszBegin = wcsstr(pszOption, szIdentifier);
    if (!pszBegin)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto LERROR;
    }

    pszString = (PWSTR) MemAlloc((wcslen(pszOption)+1) * sizeof(WCHAR));
    if (NULL == pszString)
    {
        hr = E_OUTOFMEMORY;
        goto LERROR;
    }

    pszBegin += wcslen(szIdentifier);

    wcscpy(pszString, pszBegin);

    pszEnd = wcschr(pszString, c_chOptionSeparator);
    if(!pszEnd)
        hr = E_INVALIDARG;
    else
    {
        //set the end of the string
        *pszEnd = 0;
        str = pszString;
    }

LERROR:

    //it's ok to MemFree(NULL)
    MemFree(pszString);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Name:     ConstructOptionListString
//
//  Purpose:  Construct the option list of REMOTE_IPINFO
//
//
//  Arguments:
//      pAdapter        [in]   Pointer to info of the adapter
//      strOptionList   [out]  The OptionList string
//
//  Returns:    None
//
//  Author:     nsun  01/12/99
//
//  Note:   Syntax of the Option list:
//          "<Identifier><data>;<Identifier><data>;...;"
//          The order of identifiers does not matter.
//
//          Example:
//          "DefGw=111.111.111.111,222.222.222.222;GwMetric=1,2;IfMetric=1;DNS=1.1.1.1;WINS=2.2.2.2"
//
VOID ConstructOptionListString(ADAPTER_INFO*   pAdapter,
                               tstring &       strOptionList)
{
    Assert(pAdapter);

    strOptionList = c_szEmpty;

    //add gateway list
    tstring str = c_szEmpty;
    tstring strGatewayList = c_szDefGw;
    ConvertColStringToString(pAdapter->m_vstrDefaultGateway,
                             c_chListSeparator,
                             str);
    strGatewayList += str;
    strOptionList += strGatewayList;
    strOptionList += c_chOptionSeparator;

    //add gateway metric list
    tstring strMetricList = c_szGwMetric;
    str = c_szEmpty;
    ConvertColStringToString(pAdapter->m_vstrDefaultGatewayMetric,
                             c_chListSeparator,
                             str);
    strMetricList += str;
    strOptionList += strMetricList;
    strOptionList += c_chOptionSeparator;

    //add interface metric info to option list
    strOptionList += c_szIfMetric;
    WCHAR szBuf[MAX_METRIC_DIGITS + 1];
    _ltot(pAdapter->m_dwInterfaceMetric, szBuf, 10);
    strOptionList += szBuf;
    strOptionList += c_chOptionSeparator;

    //add DNS server list
    strOptionList += c_szDNS;
    str = c_szEmpty;
    ConvertColStringToString(pAdapter->m_vstrDnsServerList,
                             c_chListSeparator,
                             str);
    strOptionList += str;
    strOptionList += c_chOptionSeparator;

    //add WINS server list
    strOptionList += c_szWINS;
    str = c_szEmpty;
    ConvertColStringToString(pAdapter->m_vstrWinsServerList,
                             c_chListSeparator,
                             str);
    strOptionList += str;
    strOptionList += c_chOptionSeparator;

    //add DNS update parameters
    strOptionList += c_szDynamicUpdate;
    ZeroMemory(szBuf, sizeof(szBuf));
    _ltot(pAdapter->m_fDisableDynamicUpdate ? 0 : 1, szBuf, 10);
    strOptionList += szBuf;
    strOptionList += c_chOptionSeparator;

    strOptionList += c_szNameRegistration;
    ZeroMemory(szBuf, sizeof(szBuf));
    _ltot(pAdapter->m_fEnableNameRegistration ? 1 : 0, szBuf, 10);
    strOptionList += szBuf;
    strOptionList += c_chOptionSeparator;
}

//+---------------------------------------------------------------------------
//
//  Name:     HrParseOptionList
//
//  Purpose:  Parse the option list string of REMOTE_IPINFO and load the 
//            settings to the adapter info struct
//
//  Arguments:
//      pszOption       [in]       The OptionList string
//      pAdapter        [in/out]   Pointer to info of the adapter
//
//  Returns:    S_OK if succeed
//              Otherwise, the hresult error
//
//  Author:     nsun  07/11/99
//
//
HRESULT HrParseOptionList(PCWSTR pszOption, 
                          ADAPTER_INFO*   pAdapter)
{
    HRESULT hr = S_OK;
    Assert(pAdapter);

    if (NULL == pszOption)
        return hr;

    HRESULT hrTmp = S_OK;

    tstring str;
    DWORD dwTemp = 0;

    //Get default gateways
    hr = RetrieveStringFromOptionList(pszOption,
                                      c_szDefGw,
                                      str);
    if(SUCCEEDED(hr))
    {
        ConvertStringToColString(str.c_str(),
                                 c_chListSeparator,
                                 pAdapter->m_vstrDefaultGateway);


        //Get gateway metrics
        hr = RetrieveStringFromOptionList(pszOption,
                                          c_szGwMetric,
                                          str);
        if(SUCCEEDED(hr))
        {
            ConvertStringToColString(str.c_str(),
                                     c_chListSeparator,
                                     pAdapter->m_vstrDefaultGatewayMetric);
        }
    }
    
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        //the option list doesn't have to have any of the tags
        hr = S_OK;
    }

    //Get interface metric
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                         c_szIfMetric,
                                         str);
    if(SUCCEEDED(hrTmp) && !str.empty())
    {
        DWORD dwIfMetric = _wtol(str.c_str());
        pAdapter->m_dwInterfaceMetric = dwIfMetric;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    //Get DNS servers
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                         c_szDNS,
                                         str);
    if (SUCCEEDED(hrTmp))
    {
        ConvertStringToColString(str.c_str(),
                                 c_chListSeparator,
                                 pAdapter->m_vstrDnsServerList);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    //Get WINS servers
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                         c_szWINS,
                                         str);
    if (SUCCEEDED(hrTmp))
    {
        ConvertStringToColString(str.c_str(),
                                 c_chListSeparator,
                                 pAdapter->m_vstrWinsServerList);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    //Get DNS dynamic update parameters
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                        c_szDynamicUpdate,
                                        str);
    if (SUCCEEDED(hrTmp))
    {
        dwTemp = _wtol(str.c_str());
        pAdapter->m_fDisableDynamicUpdate = !dwTemp;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    
    hrTmp = RetrieveStringFromOptionList(pszOption,
                                        c_szNameRegistration,
                                        str);
    if (SUCCEEDED(hrTmp))
    {
        dwTemp = _wtol(str.c_str());
        pAdapter->m_fEnableNameRegistration = !!dwTemp;
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrTmp)
    {
        hrTmp = S_OK;
    }

    if(SUCCEEDED(hr))
        hr = hrTmp;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     GetPnpPopupSettingFromOptionList
//
//  Purpose:  Parse the option list string of REMOTE_IPINFO and get the setting 
//            on whether the Popups in PnP process should be suppressed
//
//  Arguments:
//      pszOption       [in]       The OptionList string
//      fDisablePopup   [in/out]   Pointer to boolean setting
//
//  Returns:    S_OK if succeed
//              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if the setting cannot be found
//              Otherwise, the hresult error
//
//  Author:     nsun  12/17/02
//
//
HRESULT GetPnpPopupSettingFromOptionList(PCWSTR pszOption, 
                                         BOOL * pfDisablePopup)
{
    HRESULT hr = S_OK;
    tstring str;
    DWORD dwTemp = 0;
    Assert(pfDisablePopup);

    if (NULL == pszOption)
        return hr;


    hr = RetrieveStringFromOptionList(pszOption,
                                c_szNoPopupsInPnp,
                                str);
    if (SUCCEEDED(hr))
    {
        dwTemp = _wtol(str.c_str());
        *pfDisablePopup = !!dwTemp;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Name:     HrGetPrimaryDnsDomain
//
//  Purpose:  Get the Primary Dns Domain name
//
//
//  Arguments:
//      pstr   [out]  The string contains the Primary Dns Domain name
//
//  Returns:    HRESULT
//
//  Author:     nsun  03/03/99
HRESULT HrGetPrimaryDnsDomain(tstring *pstr)
{
    HRESULT hr = S_OK;

    Assert(pstr);

    DWORD dwErr;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pPrimaryDomainInfo = NULL;


    dwErr = DsRoleGetPrimaryDomainInformation( NULL,
                                        DsRolePrimaryDomainInfoBasic,
                                        (PBYTE *) &pPrimaryDomainInfo);
    if (ERROR_SUCCESS == dwErr && NULL != pPrimaryDomainInfo )
    {
        if (pPrimaryDomainInfo->DomainNameDns)
            *pstr = pPrimaryDomainInfo->DomainNameDns;
        else
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        DsRoleFreeMemory(pPrimaryDomainInfo);
    }
    else
        hr = HRESULT_FROM_WIN32(dwErr);

    TraceError("CTcpipcfg::HrGetPrimaryDnsDomain:", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Name:     WriteSetupErrorLog
//
//  Purpose:  Write an error to setuperr.log
//
//
//  Arguments:
//      nIdErrorFormat   [in]       The ID of the error format string
//
//  Returns:    None, but Error trace will be generated if fails to write setup
//              error log
//
//  Author:     nsun  03/21/99
VOID WriteTcpSetupErrorLog(UINT nIdErrorFormat, ...)
{
    PCWSTR pszFormat = SzLoadIds(nIdErrorFormat);

    PWSTR pszText = NULL;
    DWORD dwRet;

    va_list val;
    va_start(val, nIdErrorFormat);
    dwRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end(val);

    if (dwRet && pszText)
    {
        tstring strMsg = L"";

        //Add the current time at the begining of the error log
        time_t tclock;
        time(&tclock);

        struct tm * ptmLocalTime;
        ptmLocalTime = localtime(&tclock);

        if (ptmLocalTime)
        {
            LPWSTR pwsz = _wasctime(ptmLocalTime);
            if (pwsz)
            {
                strMsg = pwsz;
            }
        }

        strMsg += pszText;

        if (!SetupLogError(strMsg.c_str(), LogSevError))
        {
            TraceError("Tcpip: WriteSetupErrorLog", HRESULT_FROM_WIN32(GetLastError()));
        }
        LocalFree(pszText);
    }
    else
    {
        TraceError("Tcpip: WriteSetupErrorLog: unable to FormatMessage()", HRESULT_FROM_WIN32(GetLastError()));
    }
}

DWORD IPStringToDword(LPCTSTR szIP)
{
    if (NULL == szIP || 0 == lstrlenW(szIP))
    {
        return 0;
    }
    
    DWORD arrdwIp[4];
    GetNodeNum(szIP, arrdwIp);

    return (arrdwIp[0] << 24) + (arrdwIp[1] << 16)
             + (arrdwIp[2] << 8) + arrdwIp[3];
}

void DwordToIPString(DWORD dwIP, tstring & strIP)
{
    if (0 == dwIP)
    {
        strIP = c_szEmpty;
        return;
    }

    WCHAR szTemp[4];
    
    wsprintf(szTemp, L"%d", dwIP >> 24);
    strIP = szTemp;
    strIP += CH_DOT;

    wsprintf(szTemp, L"%d", (dwIP & 0x00FF0000) >> 16);
    strIP += szTemp;    
    strIP += CH_DOT;

    wsprintf(szTemp, L"%d", (dwIP & 0x0000FF00) >> 8);
    strIP += szTemp;    
    strIP += CH_DOT;

    wsprintf(szTemp, L"%d", (dwIP & 0x000000FF));
    strIP += szTemp;

    return;
}

//Seach a List view for an item contains the specified string
//Arguments:
//          hListView   [IN]    Handle to the list view
//          iSubItem    [IN]    Subitem to search
//          psz         [IN]    The string to search
//Return
//          -1 if no items are found
//          otherwise the index of the first item matching the string
//
int SearchListViewItem(HWND hListView, int iSubItem, LPCWSTR psz)
{
    int iRet = -1;
    int nlvCount = ListView_GetItemCount(hListView);

    WCHAR szBuf[256];

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT;
    lvItem.pszText = szBuf;
    lvItem.cchTextMax = celems(szBuf);

    for (int i = 0; i < nlvCount; i++)
    {
        lvItem.iItem = i;
        lvItem.iSubItem = iSubItem;
        ListView_GetItem(hListView, &lvItem);

        if (lstrcmpiW(psz, szBuf) == 0)
        {
            iRet = i;
            break;
        }
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\clusterdlg.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    cluster.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - cluster config tab

Author:

    kyrilf
    shouse

--*/

#include "pch.h"
#pragma hdrstop
#include "ncatlui.h"

#include <locale.h>
#include <process.h>

#include "resource.h"
#include "wlbsparm.h"
#include "wlbsconfig.h"
#include "ClusterDlg.h"
#include "utils.h"

#include <winsock2.h>
#include <strsafe.h>

#if DBG
static void TraceMsg(PCWSTR pszFormat, ...);
#else
#define TraceMsg NOP_FUNCTION
#endif

#define DUMMY_PASSWORD L"somepassword"
#define EMPTY_PASSWORD L""

/*
 * Method: CDialogCluster
 * Description: The class constructor.
 */
CDialogCluster::CDialogCluster (NETCFG_WLBS_CONFIG * paramp, const DWORD * adwHelpIDs) {

    TraceMsg(L"CDialogCluster::CDialogCluster\n");

    m_paramp = paramp;
    m_adwHelpIDs = adwHelpIDs;
    m_rct_warned = FALSE;
    m_igmp_warned = FALSE;
    m_igmp_mcast_warned = FALSE;

    ZeroMemory(&m_IPFieldChangeState, sizeof(m_IPFieldChangeState));

    _wsetlocale (LC_ALL, L".OCP");
}

/*
 * Method: CDialogCluster
 * Description: The class destructor.
 */
CDialogCluster::~CDialogCluster () {

    TraceMsg(L"CDialogCluster::~CDialogCluster\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the cluster properties dialog.
 */
LRESULT CDialogCluster::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnInitDialog\n");

    /* Always tell NetCfg that the page has changed, so we don't have to keep track of this. */
    SetChangedFlag();

    /* Limit the field ranges for the address and password fields. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, EM_SETLIMITTEXT, CVY_MAX_CL_IP_ADDR, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_MASK, EM_SETLIMITTEXT, CVY_MAX_CL_NET_MASK, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, EM_SETLIMITTEXT, CVY_MAX_DOMAIN_NAME, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, EM_SETLIMITTEXT, CVY_MAX_NETWORK_ADDR, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, EM_SETLIMITTEXT, CVY_MAX_RCT_CODE, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, EM_SETLIMITTEXT, CVY_MAX_RCT_CODE, 0);

    /* Limit the zeroth field of the cluster IP address between 1 and 223. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, IPM_SETRANGE, 0, (LPARAM)MAKEIPRANGE(WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH));

    /* Disable the MAC address field.  It should be read-only. */
    if (m_paramp->fConvertMac) ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_ETH), FALSE);

    /* If the cluster IP address or subnet mask are the default values, set them to NUL strings. */
    if (!wcscmp(m_paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR)) m_paramp->cl_ip_addr[0] = 0;
    if (!wcscmp(m_paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) m_paramp->cl_net_mask[0] = 0;

    /* Copy a dummy password into the parameter set. */
    wcsncpy(m_passw, DUMMY_PASSWORD, CVY_MAX_RCT_CODE);
    wcsncpy(m_passw2, DUMMY_PASSWORD, CVY_MAX_RCT_CODE);

    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CDialogCluster::OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CDialogCluster::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnActive
 * Description: Called when the cluster settings tab becomes active (is clicked). 
 */
LRESULT CDialogCluster::OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnActive\n");

    /* Populate the UI with the current configuration. */
    SetInfo();

    /* Enable/disable the password entry boxes based on the state of the remote control checkbox. */
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));

    /* Enable/disable the IGMP checkbox based on the state of the multicast checkbox. */
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), ::IsDlgButtonChecked (m_hWnd, IDC_RADIO_MULTICAST));

    /* Fill in the cluster MAC address, based on the values of multicast, IGMP, and the cluster IP. */
    SetClusterMACAddress();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnKillActive
 * Description: Called When the focus moves away from the cluster settings tab.
 */
LRESULT CDialogCluster::OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnKillActive\n");

    /* Get the new configuration from the UI. */
    UpdateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnApply
 * Description: Called when the user clicks "OK".
 */
LRESULT CDialogCluster::OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    LRESULT fError = PSNRET_NOERROR;

    TraceMsg(L"CDialogCluster::OnApply\n");

    /* Validate the UI values entered by the user. */
    fError = ValidateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);

    return fError;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CDialogCluster::OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnCancel\n");

    return 0;
}

/*
 * Method: OnEditClIp
 * Description: Called when the user edits the cluster IP address.
 */
LRESULT CDialogCluster::OnEditClIp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnEditClIp\n");

    switch (wNotifyCode) {
        case EN_CHANGE:
            /* Update the cluster MAC address. */
            SetClusterMACAddress();
            break;
    }

    return 0;
}

/*
 * Method: PrintIPRangeError
 * Description: Displays a message box warning the user of an out-of-range entry in 
 *              an IP address octet.
 */
void CDialogCluster::PrintIPRangeError (unsigned int ids, int value, int low, int high) {
    WCHAR szCurrent[12]; // size = sign + n,nnn,nnn,nnn + null-terminator
    WCHAR szLow[12];
    WCHAR szHigh[12];

    TraceMsg(L"CDialogCluster::PrintIPRangeError\n");

    /* Fill in the allowed range and the offending value. */
    StringCchPrintf(szHigh   , ASIZECCH(szHigh)   , L"%d", high);
    StringCchPrintf(szCurrent, ASIZECCH(szCurrent), L"%d", value);
    StringCchPrintf(szLow    , ASIZECCH(szLow)    , L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szCurrent, szLow, szHigh);
}

/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the cluster IP address changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CDialogCluster::OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    LPNMIPADDRESS Ip;
    int low = WLBS_FIELD_LOW;
    int high = WLBS_FIELD_HIGH;

    TraceMsg(L"CDialogCluster::OnIpFieldChange\n");

    Ip = (LPNMIPADDRESS)pnmh;
        
    switch(idCtrl) {
    case IDC_EDIT_CL_IP:
        /* Field zero of the cluster IP address has different limits. */
        if (!Ip->iField) {
            low = WLBS_IP_FIELD_ZERO_LOW;
            high = WLBS_IP_FIELD_ZERO_HIGH;
        }        
    case IDC_EDIT_CL_MASK:
        /* The notifier may call us twice for the same change, so we have to do the bookkeeping to make 
           sure we only alert the user once.  Use static variables to keep track of our state.  This will 
           allow us to ignore duplicate alerts. */
        if ((m_IPFieldChangeState.IpControl != Ip->hdr.idFrom) || (m_IPFieldChangeState.Field != Ip->iField) || 
            (m_IPFieldChangeState.Value != Ip->iValue) || (m_IPFieldChangeState.RejectTimes > 0)) {
            m_IPFieldChangeState.RejectTimes = 0;
            m_IPFieldChangeState.IpControl = (UINT)(Ip->hdr.idFrom);
            m_IPFieldChangeState.Field = Ip->iField;
            m_IPFieldChangeState.Value = Ip->iValue;
            
            /* Check the field value against its limits. */
            if ((Ip->iValue != WLBS_FIELD_EMPTY) && ((Ip->iValue < low) || (Ip->iValue > high))) {
                /* Alert the user. */
                PrintIPRangeError((idCtrl == IDC_EDIT_CL_IP) ? IDS_PARM_CL_IP_FIELD : IDS_PARM_CL_NM_FIELD, Ip->iValue, low, high);
            }
        } else m_IPFieldChangeState.RejectTimes++;
        
        break;
    default:

        break;
    }

    return 0;
}

/*
 * Method: OnEditClMask
 * Description: Called when the user modifies the cluster netmask.
 */
LRESULT CDialogCluster::OnEditClMask (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    WCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];
    WCHAR cl_mask_addr[CVY_MAX_CL_NET_MASK + 1];

    TraceMsg(L"CDialogCluster::OnEditClMask\n");

    switch (wNotifyCode) {
        case EN_SETFOCUS:
            /* Only generate a netmask if the netmask is currently empty and the IP address is not. */
            if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_ISBLANK, 0, 0) &&
                !::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_ISBLANK, 0, 0)) {
                /* Retrieve the cluster IP address. */
                ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)cl_ip_addr);

                /* Fill the subnet mask. */
                ParamsGenerateSubnetMask(cl_ip_addr, cl_mask_addr, ASIZECCH(cl_mask_addr));

                /* Set the cluster subnet mask. */
                ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_MASK, WM_SETTEXT, 0, (LPARAM)cl_mask_addr);

                break;
            }
    }

    return 0;
}

/*
 * Method: OnCheckRct
 * Description: Called when the user checks/unchecks the remote control enabled checkbox.
 */
LRESULT CDialogCluster::OnCheckRct (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnCheckRct\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Decide whether to enable or diable the password entry boxes based on the value of the remote checkbox. */
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));
    
        /* Warn the user about the implications of enabling remote control. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT) && !m_rct_warned) {
            /* Alert the user. */
            int iResponse = NcMsgBox(m_hWnd, IDS_PARM_WARN, IDS_PARM_RCT_WARN,
                                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2);

            if (iResponse == IDYES)
            {
                //
                // Dialog button is already checked, so don't do anything in this case.
                //
                /* Only warn the user once. */
                m_rct_warned = TRUE;
            }
            else
            {
                //
                // Any response other than Yes means No
                //
                if (::CheckDlgButton(m_hWnd, IDC_CHECK_RCT, BST_UNCHECKED))
                {
                    TraceMsg(L"CDialogCluster::OnCheckRct unchecking remote control option failed with error 0x%x\n", GetLastError());
                }
            }
        }
        
        break;
    }
    
    return 0;
}

/*
 * Method: OnCheckMode
 * Description: Called when the user changes cluster mode.
 */
LRESULT CDialogCluster::OnCheckMode (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnCheckMode\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* If the user has IGMP checked, but is turning off multicast support, warn them. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) && !::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST)) {
            if (!m_igmp_mcast_warned) {
                /* Alert the user. */
                NcMsgBox(::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_IGMP_MCAST,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);            

                /* Only warn the user once. */
                m_igmp_mcast_warned = TRUE;
            } 

            /* Uncheck and disable the IGMP checkbox and set the IGMP support flag to FALSE. */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_IGMP, FALSE);
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), FALSE);
            m_paramp->fIGMPSupport = FALSE;
        } else {
            /* Enable/disable and check/uncheck the IGMP checkbox based on the value of the cluster mode radio buttons. */
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST));
        }

        /* Update the cluster MAC address. */
        SetClusterMACAddress();
    
        break;
    }

    return 0;
}

/*
 * Method: OnCheckIGMP
 * Description: Called when the user checks/unchecks the IGMP support checkbox.
 */
LRESULT CDialogCluster::OnCheckIGMP (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {

    TraceMsg(L"CDialogCluster::OnCheckIGMP\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Update the cluster MAC address. */
        SetClusterMACAddress();
    
        /* Warn the user about the implications of enabling remote control. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) && !m_igmp_warned) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_IGMP_WARN,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            
            /* Only warn the user once. */
            m_igmp_warned = TRUE;
        }

        break;
    }

    return 0;
}

/*
 * Method: SetClusterMACAddress
 * Description: Used to determine the cluster MAC address based on the cluster IP, and the
 *              state of multicast and IGMP support.
 */
void CDialogCluster::SetClusterMACAddress () {
    WCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];
    WCHAR cl_mac_addr[CVY_MAX_NETWORK_ADDR + 1];

    TraceMsg(L"CDialogCluster::SetClusterMACAddress\n");

    /* If the convert MAC flag isn't set, the bail out. */
    if (!m_paramp->fConvertMac) return;

    /* Retrieve the cluster IP address from the UI. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)cl_ip_addr);
    
    /* Generate the cluster MAC address. */
    ParamsGenerateMAC(cl_ip_addr, cl_mac_addr, ASIZECCH(cl_mac_addr), m_paramp->szMCastIpAddress, ASIZECCH(m_paramp->szMCastIpAddress), m_paramp->fConvertMac, ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST), 
                      ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP), m_paramp->fIpToMCastIp);
    
    /* Set the cluster MAC address. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_SETTEXT, 0, (LPARAM)cl_mac_addr);
}

/*
 * Method: CheckClusterMACAddress
 * Description: Used to check the cluster MAC address in the case where we aren't generating it ourselves.
 */
BOOL CDialogCluster::CheckClusterMACAddress () {
    PWCHAR p1, p2;
    WCHAR mac_addr[WLBS_MAX_NETWORK_ADDR + 1];
    DWORD i, j;
    BOOL flag = TRUE;
    
    /* Valid formats include:
       02:bf:0b:0b:01:01
       02-bf-0b-0b-01-01
       02:bf:0b:b:01:1 */

    /* Make a copy of the MAC address. */
    (VOID) StringCchCopy(mac_addr, ASIZECCH(mac_addr), m_paramp->cl_mac_addr);
    
    /* Point to the beginning of the MAC. */
    p2 = p1 = mac_addr;
    
    /* Loop through all six bytes. */
    for (i = 0 ; i < 6 ; i++) {
        /* If we are pointing at the end of the string, its invalid. */
        if (*p2 == _TEXT('\0')) return FALSE;
        
        //
        // TODO: _tcstoul searches p1 for an integer value in base 16. p2 points to the first non-integer
        //       byte after p1. There are a couple of error conditions:
        //       1. Integer overflow -- this is covered in the range check.
        //       2. No integer found -- in this case _tcstoul returns 0. This code will treate this syntax
        //          error as a valid entry. For example, 02:bf:0::00:00:00 will be treated as something like
        //          02:bf:00:00:00:00 instead of calling it malformed.
        //       Looks like making the following check would work:
        //          if (j > 255 || p1 != p2) return FALSE
        //       would work. This is because if no integer is found p2 will be set to the value of p1.
        //
        /* Convert the hex characters into decimal. */
        j = _tcstoul(p1, &p2, 16);
        
        /* If the number is greater than 255, then the format is bad. */
        if (j > 255) return FALSE;
        
        /* If the NEXT character is neither a -, :, nor the NUL character, then the format is bad. */
        if (!((*p2 == _TEXT('-')) || (*p2 == _TEXT(':')) || (*p2 == _TEXT('\0')))) return FALSE;
        
        /* If the NEXT character is the end of the string, but we don't have enough bytes yet, bail out. */
        if (*p2 == _TEXT('\0') && i < 5) return FALSE;
        
        /* Repoint to the NEXT character. */
        p1 = p2 + 1;
        p2 = p1;
    }

    return TRUE;
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the current cluster settings.
 */
void CDialogCluster::SetInfo () {
    DWORD addr[4];

    TraceMsg(L"CDialogCluster::SetInfo %x %x\n", m_hWnd, ::GetActiveWindow());

    /* Check (or uncheck) the checkboxes. */
    ::CheckDlgButton(m_hWnd, IDC_CHECK_RCT, m_paramp->fRctEnabled);

    /* Check the appropriate radio button for cluster mode. */
    if (m_paramp->fMcastSupport) {
        ::CheckDlgButton(m_hWnd, IDC_RADIO_MULTICAST, TRUE);

        if (m_paramp->fIGMPSupport) ::CheckDlgButton(m_hWnd, IDC_CHECK_IGMP, TRUE);
    } else 
        ::CheckDlgButton(m_hWnd, IDC_RADIO_UNICAST, TRUE);

    /* If the cluster IP address is empty, then clear the entry box.  Otherwise, populate it with the IP address. */
    if (!m_paramp->cl_ip_addr[0])
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_CLEARADDRESS, 0, 0);
    else {
        /* Extract the IP address octects from the IP address string. */ 
        GetIPAddressOctets(m_paramp->cl_ip_addr, addr);

        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));
    }

    /* If the cluster subnet mask is empty, then clear the entry box.  Otherwise, populate it with the netmask. */
    if (!m_paramp->cl_net_mask[0])
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_CLEARADDRESS, 0, 0);
    else {
        /* Extract the IP address octects from the IP address string. */ 
        GetIPAddressOctets(m_paramp->cl_net_mask, addr);
        
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));
    }

    /* Fill in the edit boxes. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_SETTEXT, 0, (LPARAM)m_paramp->domain_name);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_SETTEXT, 0, (LPARAM)m_paramp->cl_mac_addr);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, WM_SETTEXT, 0, (LPARAM)m_passw);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, WM_SETTEXT, 0, (LPARAM)m_passw2);
}

/*
 * Method: UpdateInfo
 * Description: Called to copy the UI state to the cluster configuration.
 */
void CDialogCluster::UpdateInfo () {

    TraceMsg(L"CDialogCluster::UpdateInfo\n");

    /* Retrieve the checkbox values. */
    m_paramp->fRctEnabled = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT) == 1;

    /* Retrieve the cluster mode radio button value. */
    m_paramp->fIGMPSupport = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) == 1;
    m_paramp->fMcastSupport = ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST) == 1;

    /* If the cluster IP entry box is empty, then the cluster IP address is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_ISBLANK, 0, 0))
        m_paramp->cl_ip_addr[0] = 0;
    else 
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)m_paramp->cl_ip_addr);

    /* If the cluster net mask entry box is empty, then the cluster net mask is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_ISBLANK, 0, 0))
        m_paramp->cl_net_mask[0] = 0;
    else 
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_MASK, WM_GETTEXT, CVY_MAX_CL_NET_MASK + 1, (LPARAM)m_paramp->cl_net_mask);

    /* Retrieve the entry box values. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_GETTEXT, CVY_MAX_DOMAIN_NAME + 1, (LPARAM)m_paramp->domain_name);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_GETTEXT, CVY_MAX_NETWORK_ADDR + 1, (LPARAM)m_paramp->cl_mac_addr);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, WM_GETTEXT, CVY_MAX_RCT_CODE + 1, (LPARAM)m_passw);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, WM_GETTEXT, CVY_MAX_RCT_CODE + 1, (LPARAM)m_passw2);
}

/*
 * Method: ValidateInfo
 * Description: Called to validate the entries made by the user.
 */
LRESULT CDialogCluster::ValidateInfo () {
    BOOL fError = FALSE;
    DWORD IPAddr;

    TraceMsg(L"CDialogCluster::ValidateInfo\n");

    /* Check for a blank cluster IP address. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), IPM_ISBLANK, 0, 0)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_CL_IP_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Check for a blank cluster net mask and fill it in if necessary. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), IPM_ISBLANK, 0, 0)) {
        /* Fill in the netmask for the user. */
        OnEditClMask(EN_SETFOCUS, 0, 0, fError);
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_MASK, WM_GETTEXT, CVY_MAX_CL_NET_MASK + 1, (LPARAM)m_paramp->cl_net_mask);

        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_CL_NM_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Get the cluster IP address. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, IPM_GETADDRESS, 0, (LPARAM)&IPAddr);

    /* Make sure that the first octet is not zero.  If it is, make it 1 and alter the user. */
    if (!FIRST_IPADDRESS(IPAddr)) {
        /* Make the first octet 1 instead of the erroneous 0. */
        IPAddr = IPAddr | (DWORD)(WLBS_IP_FIELD_ZERO_LOW << 24);

        /* Set the IP address and update our cluster IP address string. */
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, IPM_SETADDRESS, 0, (LPARAM)IPAddr);
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)m_paramp->cl_ip_addr);
      
        /* Alert the user. */
        PrintIPRangeError(IDS_PARM_CL_IP_FIELD, 0, WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH);

        return PSNRET_INVALID;
    }

    /* Check for valid cluster IP address/netmask pairs. */
    if (!IsValidIPAddressSubnetMaskPair(m_paramp->cl_ip_addr, m_paramp->cl_net_mask)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_CL_IP,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }
    
    /* Check to make sure that the netmask is contiguous. */
    if (!IsContiguousSubnetMask(m_paramp->cl_net_mask)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_CL_MASK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }
        
    /* Check to make sure that the dedicated IP and cluster IP are not the same. */
    if (!wcscmp(m_paramp->ded_ip_addr, m_paramp->cl_ip_addr)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_IP_CONFLICT,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        
        /* An error occurred. */
        return PSNRET_INVALID;
    }

    if (!m_paramp->fConvertMac && !CheckClusterMACAddress()) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_MAC,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Only check for invalid passwords and update if remote control is enabled. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT)) {
        /* Make sure the passwords match. */
        if (wcscmp(m_passw, m_passw2) != 0) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_PASSWORD,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);

            /* Empty the passwords. */
            m_passw [0] = m_passw2 [0] = 0;

            /* An error occurred. */
            return PSNRET_INVALID;
        } else {
            /* If the new password is not the dummy password, update the password. */
            if (wcscmp (m_passw, DUMMY_PASSWORD) != 0) {
                (VOID) StringCchCopy(m_paramp->szPassword, ASIZECCH(m_paramp->szPassword), m_passw);
                m_paramp->fChangePassword = true;
            }

        }
    }

    return PSNRET_NOERROR;
}

#if DBG
/*
 * Function: TraceMsg
 * Description: Generate a trace or error message.
 */
void TraceMsg (PCWSTR pszFormat, ...) {
    static WCHAR szTempBufW[4096];
    static CHAR szTempBufA[4096];

    va_list arglist;

    va_start(arglist, pszFormat);

    //
    // Ignore return value since error occurs when supplied output buffer isn't big enough. In this case this function truncates the result to the size of the supplied buffer.
    //
    (VOID) StringCchVPrintf(szTempBufW, ASIZECCH(szTempBufW), pszFormat, arglist);

    /* Convert the WCHAR to CHAR. This is for backward compatability with TraceMsg
       so that it was not necessary to change all pre-existing calls thereof. */
    if (WideCharToMultiByte(CP_ACP, 0, szTempBufW, -1, szTempBufA, ASIZECCH(szTempBufA), NULL, NULL) != 0)
    {
        /* Traced messages are now sent through the netcfg TraceTag routine so that
           they can be turned on/off dynamically. */
        TraceTag(ttidWlbs, szTempBufA);
    }

    va_end(arglist);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\host.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

        host.cpp

Abstract:

        Windows Load Balancing Service (WLBS)
    Notifier object UI - host config tab

Author:

    kyrilf
    shouse

--*/

#include "pch.h"
#pragma hdrstop
#include "ncatlui.h"

#include "resource.h"
#include "wlbsparm.h"
#include "wlbscfg.h"
#include "host.h"
#include "utils.h"

#include <winsock2.h>
#include <strsafe.h>

#if DBG
static void TraceMsg(PCTSTR pszFormat, ...);
#else
#define TraceMsg NOP_FUNCTION
#endif

/*
 * Method: CDialogHost
 * Description: The class constructor.
 */
CDialogHost::CDialogHost (NETCFG_WLBS_CONFIG * paramp, const DWORD * adwHelpIDs) {

    TraceMsg(L"CDialogHost::CDialogHost\n");

    m_paramp = paramp;
    m_adwHelpIDs = adwHelpIDs;

    ZeroMemory(&m_IPFieldChangeState, sizeof(m_IPFieldChangeState));
}

/*
 * Method: ~CDialogHost
 * Description: The class destructor.
 */
CDialogHost::~CDialogHost () {

    TraceMsg(L"CDialogHost::~CDialogHost\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the host properties dialog.
 */
LRESULT CDialogHost::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    INT iItem;
    INT cItems;

    TraceMsg(L"CDialogHost::OnInitDialog\n");

    /* Always tell NetCfg that the page has changed, so we don't have to keep track of this. */
    SetChangedFlag();

    /* Limit the field ranges for the address and priority fields. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, EM_SETLIMITTEXT, CVY_MAX_DED_IP_ADDR, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_MASK, EM_SETLIMITTEXT, CVY_MAX_DED_NET_MASK, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PRI, EM_SETLIMITTEXT, 2, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_PRI, UDM_SETRANGE32, CVY_MIN_MAX_HOSTS, m_paramp->dwMaxHosts);

    /* Limit the zeroth field of the dedicated IP address between 1 and 223. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, IPM_SETRANGE, 0, (LPARAM)MAKEIPRANGE(WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH));

    /* If the cluster IP address or subnet mask are the default values, set them to NUL strings. */
    if (!wcscmp(m_paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR)) m_paramp->ded_ip_addr[0] = 0;
    if (!wcscmp(m_paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) m_paramp->ded_net_mask[0] = 0;

    /* Insert "Started" into the dropdown list for initial host state.  Set its data to CVY_HOST_STATE_STARTED (1). */
    iItem = (INT)SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_ADDSTRING, 0, (LPARAM)SzLoadIds(IDS_HOST_STATE_STARTED));
    SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_SETITEMDATA, iItem, (LPARAM)CVY_HOST_STATE_STARTED);

    /* Insert "Stopped" into the dropdown list for initial host state.  Set its data to CVY_HOST_STATE_STOPPED (0). */
    iItem = (INT)SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_ADDSTRING, 0, (LPARAM)SzLoadIds(IDS_HOST_STATE_STOPPED));
    SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_SETITEMDATA, iItem, (LPARAM)CVY_HOST_STATE_STOPPED);

    /* Insert "Suspended" into the dropdown list for initial host state.  Set its data to CVY_HOST_STATE_SUSPENDED (2). */
    iItem = (INT)SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_ADDSTRING, 0, (LPARAM)SzLoadIds(IDS_HOST_STATE_SUSPENDED));
    SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_SETITEMDATA, iItem, (LPARAM)CVY_HOST_STATE_SUSPENDED);

    /* Get the number of items added to ths dropdown list. */
    cItems = (INT)SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_GETCOUNT);

    /* This had better be 3. */
    ASSERT(cItems == 3);

    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CDialogHost::OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CDialogHost::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnActive
 * Description: Called when the host settings tab becomes active (is clicked). 
 */
LRESULT CDialogHost::OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnActive\n");

    /* Populate the UI with the current configuration. */
    SetInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnKillActive
 * Description: Called When the focus moves away from the host settings tab.
 */
LRESULT CDialogHost::OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnKillActive\n");

    /* Get the new configuration from the UI. */
    UpdateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnApply
 * Description: Called when the user clicks "OK".
 */
LRESULT CDialogHost::OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    LRESULT fError = PSNRET_NOERROR;

    TraceMsg(L"CDialogHost::OnApply\n");

    /* Validate the UI values entered by the user. */
    fError = ValidateInfo();

    /* If the user has not specified dedicated IP address information, copy the defaults back. */
    if (!fError && !m_paramp->ded_ip_addr[0])
    {
        (VOID) StringCchCopy(m_paramp->ded_ip_addr, ASIZECCH(m_paramp->ded_ip_addr), CVY_DEF_DED_IP_ADDR);
    }

    if (!fError && !m_paramp->ded_net_mask[0])
    {
        (VOID) StringCchCopy(m_paramp->ded_net_mask, ASIZECCH(m_paramp->ded_net_mask), CVY_DEF_DED_NET_MASK);
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);

    return fError;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CDialogHost::OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {

    TraceMsg(L"CDialogHost::OnCancel\n");

    return 0;
}

/*
 * Method: OnEditDedMask
 * Description: Called when the user modifies the host netmask.
 */
LRESULT CDialogHost::OnEditDedMask (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    WCHAR ded_ip_addr [CVY_MAX_DED_IP_ADDR + 1];
    WCHAR ded_mask_addr [CVY_MAX_DED_NET_MASK + 1];

    TraceMsg(L"CDialogHost::OnEditDedMask\n");

    switch (wNotifyCode) {
        case EN_SETFOCUS:
            /* Only generate a netmask if the netmask is currently empty and the IP address is not. */
            if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0) &&
                !::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0)) {
                /* Retrieve the cluster IP address. */
                ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, WM_GETTEXT, CVY_MAX_DED_IP_ADDR + 1, (LPARAM)ded_ip_addr);

                /* Fill the subnet mask. */
                ParamsGenerateSubnetMask(ded_ip_addr, ded_mask_addr, ASIZECCH(ded_mask_addr));

                /* Set the cluster subnet mask. */
                ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_MASK, WM_SETTEXT, 0, (LPARAM)ded_mask_addr);

                break;
            }
    }

    return 0;
}

/*
 * Method: PrintRangeError
 * Description: Displays a message box warning the user of an out-of-range entry.
 */
void CDialogHost::PrintRangeError (unsigned int ids, int low, int high) {
    WCHAR szLow[12];  // size = sign + n,nnn,nnn,nnn + null-terminator
    WCHAR szHigh[12];

    TraceMsg(L"CDialogHost::PrintRangeError\n");

    /* Fill in the range and the offending value. */
    StringCchPrintf(szHigh, ASIZECCH(szHigh), L"%d", high);
    StringCchPrintf(szLow , ASIZECCH(szLow) , L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szLow, szHigh);
}

/*
 * Method: PrintIPRangeError
 * Description: Displays a message box warning the user of an out-of-range entry in
 *              an IP address octet.
 */
void CDialogHost::PrintIPRangeError (unsigned int ids, int value, int low, int high) {
    WCHAR szCurrent[12]; // size = sign + n,nnn,nnn,nnn + null-terminator
    WCHAR szLow[12];
    WCHAR szHigh[12];

    TraceMsg(L"CDialogHost::PrintIPRangeError\n");

    /* Fill in the range and the offending value. */
    StringCchPrintf(szHigh   , ASIZECCH(szHigh)   , L"%d", high);
    StringCchPrintf(szCurrent, ASIZECCH(szCurrent), L"%d", value);
    StringCchPrintf(szLow    , ASIZECCH(szLow)    , L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szCurrent, szLow, szHigh);
}

/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the dedicated IP address changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CDialogHost::OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    LPNMIPADDRESS Ip;
    int low = WLBS_FIELD_LOW;
    int high = WLBS_FIELD_HIGH;

    TraceMsg(L"CDialogHost::OnIpFieldChange\n");

    Ip = (LPNMIPADDRESS)pnmh;

    switch(idCtrl) {
    case IDC_EDIT_DED_IP:
        /* Field zero of the cluster IP address has different limits. */
        if (!Ip->iField) {
            low = WLBS_IP_FIELD_ZERO_LOW;
            high = WLBS_IP_FIELD_ZERO_HIGH;
        }        
    case IDC_EDIT_DED_MASK:
        /* The notifier may call us twice for the same change, so we have to do the bookkeeping to make 
           sure we only alert the user once.  Use static variables to keep track of our state.  This will 
           allow us to ignore duplicate alerts. */
        if ((m_IPFieldChangeState.IpControl != Ip->hdr.idFrom) || (m_IPFieldChangeState.Field != Ip->iField) || 
            (m_IPFieldChangeState.Value != Ip->iValue) || (m_IPFieldChangeState.RejectTimes > 0)) {
            m_IPFieldChangeState.RejectTimes = 0;
            m_IPFieldChangeState.IpControl = (UINT)(Ip->hdr.idFrom);
            m_IPFieldChangeState.Field = Ip->iField;
            m_IPFieldChangeState.Value = Ip->iValue;

            /* Check the field value against its limits. */
            if ((Ip->iValue != WLBS_FIELD_EMPTY) && ((Ip->iValue < low) || (Ip->iValue > high))) {
                /* Alert the user. */
                PrintIPRangeError((idCtrl == IDC_EDIT_DED_IP) ? IDS_PARM_DED_IP_FIELD : IDS_PARM_DED_NM_FIELD, Ip->iValue, low, high);
            }
        } else m_IPFieldChangeState.RejectTimes++;
        
        break;
    default:

        break;
    }

    return 0;
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the current host settings.
 */
void CDialogHost::SetInfo () {
    DWORD addr[4];
    INT cItems;
    INT iItem;

    TraceMsg(L"CDialogHost::SetInfo\n");

    /* Get the number of items in the dropdown list. */
    cItems = (INT)SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_GETCOUNT);

    /* This MUST be 3. */
    ASSERT(cItems == 3);

    /* Loop through the items looking for the one currently selected in the registry. */
    for (iItem = 0; iItem < cItems; iItem++) {
        /* The "state" is the item data that we inserted during OnInitDialog. */
        INT state = (INT)SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_GETITEMDATA, iItem, 0);

        /* If this is the one currently set in the registry, make it the current selection. */
        if (m_paramp->dwInitialState == state) {
            SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_SETCURSEL, iItem, 0);
            break;
        }
    }

    /* Check (or uncheck) the persist suspended state checkbox. */
    ::CheckDlgButton(m_hWnd, IDC_CHECK_PERSIST_SUSPEND, m_paramp->dwPersistedStates & CVY_PERSIST_STATE_SUSPENDED);

    /* If the dedicated IP address is empty, then clear the entry box.  Otherwise, populate it with the IP address. */
    if (!m_paramp->ded_ip_addr[0])
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_CLEARADDRESS, 0, 0);
    else {
        /* Extract the IP address octects from the IP address string. */ 
        GetIPAddressOctets(m_paramp->ded_ip_addr, addr);

        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));
    }

    /* If the host subnet mask is empty, then clear the entry box.  Otherwise, populate it with the netmask. */
    if (!m_paramp->ded_net_mask[0])
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_CLEARADDRESS, 0, 0);
    else {
        /* Extract the IP address octects from the IP address string. */ 
        GetIPAddressOctets(m_paramp->ded_net_mask, addr);
        
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));
    }

    /* Fill in the host priority entry box.  If the entry is blank or out of range, insert an empty string. */
    if (m_paramp->dwHostPriority >= CVY_MIN_HOST_PRIORITY && m_paramp->dwHostPriority <= CVY_MAX_HOST_PRIORITY)
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_PRI, m_paramp->dwHostPriority, FALSE);
    else
        ::SetDlgItemText(m_hWnd, IDC_EDIT_PRI, L"");
}

/*
 * Method: UpdateInfo
 * Description: Called to copy the UI state to the host configuration.
 */
void CDialogHost::UpdateInfo () {
    BOOL fValid = TRUE;
    INT iItem;

    TraceMsg(L"CDialogHost::UpdateInfo\n");

    /* Get the current selection from the dropdown list. */
    iItem = (INT)SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_GETCURSEL, 0, 0);

    /* Get the item data for the current selection and store it. */
    m_paramp->dwInitialState = (INT)SendDlgItemMessage(IDC_COMBOBOX_DEFAULT_STATE, CB_GETITEMDATA, iItem, 0);    

    /* If the persist suspend checkbox is checked, then set the suspend bit 
       in the persisted states registry setting; otherwise, clear that bit. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_PERSIST_SUSPEND))
        m_paramp->dwPersistedStates |= CVY_PERSIST_STATE_SUSPENDED;
    else
        m_paramp->dwPersistedStates &= ~CVY_PERSIST_STATE_SUSPENDED;

    /* If the dedicated IP entry box is empty, then the dedicated IP address is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0))
        m_paramp->ded_ip_addr[0] = 0;
    else
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, WM_GETTEXT, CVY_MAX_DED_IP_ADDR + 1, (LPARAM)m_paramp->ded_ip_addr);

    /* If the host net mask entry box is empty, then the host net mask is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0))
        m_paramp->ded_net_mask[0] = 0;
    else
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_MASK, WM_GETTEXT, CVY_MAX_DED_NET_MASK + 1, (LPARAM)m_paramp->ded_net_mask);

    /* Retrieve the host priority from the entry box. */
    m_paramp->dwHostPriority = ::GetDlgItemInt(m_hWnd, IDC_EDIT_PRI, &fValid, FALSE);

    /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
       string to an integer. This allows us to check for empty fields, assuming that because
       we otherwise limit the user input to digits, there will be no errors of any other type. 
       In this case, we set the priority to a sentinnel value that will be checked later. */
    if (!fValid) m_paramp->dwHostPriority = WLBS_BLANK_HPRI;
}

/*
 * Method: ValidateInfo
 * Description: Called to validate the entries made by the user.
 */
BOOL CDialogHost::ValidateInfo () {
    BOOL fError = FALSE;
    DWORD IPAddr;

    TraceMsg(L"CDialogHost::ValidateInfo\n");

    /* Check for an invalid host priority. */
    if ((m_paramp->dwHostPriority < CVY_MIN_HOST_PRIORITY) || (m_paramp->dwHostPriority > m_paramp->dwMaxHosts)) {
        /* Help the user by setting the priority to the closest viable value. */
        if (m_paramp->dwHostPriority != WLBS_BLANK_HPRI) {
            /* Alert the user. */
            PrintRangeError(IDS_PARM_PRI, CVY_MIN_HOST_PRIORITY, CVY_MAX_HOST_PRIORITY);

            CVY_CHECK_MIN(m_paramp->dwHostPriority, CVY_MIN_HOST_PRIORITY);
            CVY_CHECK_MAX(m_paramp->dwHostPriority, CVY_MAX_HOST_PRIORITY);

            /* Set the handling priority to the now valid entry. */
            ::SetDlgItemInt(m_hWnd, IDC_EDIT_PRI, m_paramp->dwHostPriority, FALSE);
        } else {
            /* Alert the user. */
            PrintRangeError(IDS_PARM_PRI_BLANK, CVY_MIN_HOST_PRIORITY, CVY_MAX_HOST_PRIORITY);
        }

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Check for blank dedicated IP address with a non-empty netmask. */
    if (!::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0) &&
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_DED_IP_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Check for blank netmask with a non-empty dedicated IP address and fill in the netmask if necessary. */
    if (!::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0) &&
        ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0)) {
        /* Fill in the netmask for the user. */
        OnEditDedMask(EN_SETFOCUS, 0, 0, fError);
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_MASK, WM_GETTEXT, CVY_MAX_DED_NET_MASK + 1, (LPARAM)m_paramp->ded_net_mask);

        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_DED_NM_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Only perform the rest of the IP checking if the user has specified both a dedicated
       IP address and a corresponding netmask. */
    if (!::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_IP), IPM_ISBLANK, 0, 0) &&
        !::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_DED_MASK), IPM_ISBLANK, 0, 0)) {
        /* Get the dedicated IP address. */
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, IPM_GETADDRESS, 0, (LPARAM)&IPAddr);
        
        /* Make sure that the first octet is not zero.  If it is, make it 1 and alter the user. */
        if (!FIRST_IPADDRESS(IPAddr)) {
            /* Make the first octet 1 instead of the erroneous 0. */
            IPAddr = IPAddr | (DWORD)(WLBS_IP_FIELD_ZERO_LOW << 24);
            
            /* Set the IP address and update our dedicated IP address string. */
            ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, IPM_SETADDRESS, 0, (LPARAM)IPAddr);
            ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DED_IP, WM_GETTEXT, CVY_MAX_DED_IP_ADDR + 1, (LPARAM)m_paramp->ded_ip_addr);
            
            /* Alert the user. */
            PrintIPRangeError(IDS_PARM_DED_IP_FIELD, 0, WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH);
            
            return PSNRET_INVALID;
        }

        /* Check for valid dedicated IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(m_paramp->ded_ip_addr, m_paramp->ded_net_mask)) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_DED_IP,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            /* An error occurred. */
            return PSNRET_INVALID;
        }
        
        /* Check to make sure that the netmask is contiguous. */
        if (!IsContiguousSubnetMask(m_paramp->ded_net_mask)) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_DED_MASK,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            /* An error occurred. */
            return PSNRET_INVALID;
        }

        /* Check if the Dedicated IP Address is not the same as one of the VIPs */
        DWORD dwNumRules = m_paramp->dwNumRules;
        while(dwNumRules--)
        {
            /* If this port rule has specified a virtual IP address, make sure it 
               doesn't match the DIP the user has specified here. */
            if (lstrcmpi(m_paramp->port_rules[dwNumRules].virtual_ip_addr, CVY_DEF_ALL_VIP)) {
                if (IpAddressFromAbcdWsz(m_paramp->ded_ip_addr) == IpAddressFromAbcdWsz(m_paramp->port_rules[dwNumRules].virtual_ip_addr)) 
                {
                    /* Alert the user. */
                    NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_DIP_CONFLICT_VIP,
                             MB_APPLMODAL | MB_ICONSTOP | MB_OK);
                    
                    /* An error occurred. */
                    return PSNRET_INVALID;
                }
            }
        }

    }

    return PSNRET_NOERROR;
}

#if DBG
/*
 * Function: TraceMsg
 * Description: Generate a trace or error message.
 */
void TraceMsg (PCWSTR pszFormat, ...) {
    static WCHAR szTempBufW[4096];
    static CHAR szTempBufA[4096];

    va_list arglist;

    va_start(arglist, pszFormat);

    (VOID) StringCchVPrintf(szTempBufW, ASIZECCH(szTempBufW), pszFormat, arglist);

    /* Convert the WCHAR to CHAR. This is for backward compatability with TraceMsg 
       so that it was not necessary to change all pre-existing calls thereof. */
    if(WideCharToMultiByte(CP_ACP, 0, szTempBufW, -1, szTempBufA, ASIZECCH(szTempBufA), NULL, NULL) != 0)
    {
        /* Traced messages are now sent through the netcfg TraceTag routine so that
           they can be turned on/off dynamically.   */
        TraceTag(ttidWlbs, szTempBufA);
    }

    va_end(arglist);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\host.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    host.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - host config tab

Author:

    kyrilf
    shouse

--*/

#pragma once

#include <ncxbase.h>
#include <ncatlps.h>

#include "resource.h"
#include "wlbsparm.h"
#include "wlbscfg.h"

/* Limitations for IP address fields. */
#define WLBS_FIELD_EMPTY -1
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223

#define WLBS_BLANK_HPRI -1

class CDialogHost : public CPropSheetPage {
public:
    /* Declare the message map. */
    BEGIN_MSG_MAP (CDialogHost)

    MESSAGE_HANDLER (WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER (WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER (WM_HELP, OnHelp)

    NOTIFY_CODE_HANDLER (PSN_APPLY, OnApply)
    NOTIFY_CODE_HANDLER (PSN_KILLACTIVE, OnKillActive)
    NOTIFY_CODE_HANDLER (PSN_SETACTIVE, OnActive)
    NOTIFY_CODE_HANDLER (PSN_RESET, OnCancel)
    NOTIFY_CODE_HANDLER (IPN_FIELDCHANGED, OnIpFieldChange)

    COMMAND_ID_HANDLER (IDC_EDIT_DED_MASK, OnEditDedMask)

    END_MSG_MAP ()

    /* Constructors/Destructors. */
    CDialogHost (NETCFG_WLBS_CONFIG * paramp, const DWORD * phelpIDs = NULL);
    ~CDialogHost ();

public:
    /* Message map functions. */
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);

    LRESULT OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    LRESULT OnEditDedMask (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);

    LRESULT OnFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    friend class CDialogCluster;
    friend class CDialogPorts;

private:
    void PrintRangeError (unsigned int ids, int low, int high);
    void PrintIPRangeError (unsigned int ids, int value, int low, int high);

    void SetInfo ();
    void UpdateInfo ();

    BOOL ValidateInfo ();

    NETCFG_WLBS_CONFIG * m_paramp;

    const DWORD * m_adwHelpIDs;

    struct {
        UINT IpControl;
        int Field;
        int Value;
        UINT RejectTimes;
    } m_IPFieldChangeState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\debug.h ===
#ifndef DEBUG_H
#define DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>


//
// Macros for debugging support.
//
// ASSERT(exp)   Popup a dialogbox, if exp is FALSE
// ASSERTMSG(exp, msg)  Similar to ASSERT.  Except the msg is displayed instead of the expression
//
// USE VERIFY for expressions executed for both debug and release version
//

#undef ASSERT
#undef ASSERTMSG

/*
//
// Used by atl
//
#ifdef _ATL_NO_DEBUG_CRT
#define _ASSERTE ASSERT
#define _ASSERT ASSERT
#endif
*/


#ifdef DBG
#define DEBUG
#endif

#if	( defined(DEBUG) || defined(_DEBUG))

#ifdef UNICODE
#define AssertMessage AssertMessageW
#endif

void AssertMessage(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg);

#define ASSERT(x)		(void)((x) || (AssertMessage(TEXT(__FILE__),__LINE__,TEXT(#x)),0))
#define ASSERTMSG(exp, msg)   (void)((exp) || (AssertMessage(TEXT(__FILE__),__LINE__,msg),0))

#define VERIFY(x)		    ASSERT(x)

#define ASSERT_VALID(pObj) ((ASSERT(pObj),1) && ((pObj)->AssertValid(),1))

#else // DEBUG

#define ASSERT_VALID(pObj) 
#define ASSERT(x)           ((void)0)
#define ASSERTMSG(exp, msg) ((void)0)
#define VERIFY(x)           (x)       
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\tcpipcfg\tcputil.h ===
//
// T C P U T I L . H
//
// Header of utility functions
//

#pragma once
#include "netcfgx.h"
#include "tcpip.h"
#include "ipctrl.h"

inline BOOL FHrFailed(HRESULT hr)
{
    return FAILED(hr);
}

#define CORg(hResult) \
    do\
        {\
        hr = (hResult);\
        if (FHrFailed(hr))\
          {\
            goto Error;\
          }\
        }\
    while (FALSE)

HRESULT HrLoadSubkeysFromRegistry(const HKEY hkeyParam,
                                  OUT VSTR * const pvstrAdapters);

HRESULT HrIsComponentInstalled(INetCfg * pnc,
                               const GUID& rguidClass,
                               PCWSTR szInfId,
                               OUT BOOL * const pfInstalled);

// Get the four numbers from an Ip Address
VOID GetNodeNum(PCWSTR szIpAddress, DWORD ardw[4]);

BOOL IsContiguousSubnet(PCWSTR pszSubnet);

VOID ReplaceFirstAddress(VSTR * pvstr, PCWSTR szIpAddress);
VOID ReplaceSecondAddress(VSTR * pvstr, PCWSTR szIpAddress);

BOOL GenerateSubnetMask(IpControl & ipAddress,
                        tstring * pstrSubnetMask);

BOOL    FRegQueryBool(const HKEY hkey, PCWSTR szName, BOOL fDefaultValue);

VOID ResetLmhostsFile();

int IPAlertPrintf(HWND hwndParent, UINT ids,
                  int iCurrent, int iLow, int iHigh);

VOID IpCheckRange(LPNMIPADDRESS lpnmipa, HWND hWnd,
                  int iLow, int iHigh, BOOL fCheckLoopback = FALSE);

VOID SetButtons(HANDLES& h, const int nNumLimit = -1);

BOOL ListBoxRemoveAt(HWND hListBox, int idx, tstring * pstrRemovedItem);
BOOL ListBoxInsertAfter(HWND hListBox, int idx, PCWSTR szItem);

HRESULT HrRegRenameTree(HKEY hkeyRoot, PCWSTR szOldName, PCWSTR szNewName);
HRESULT HrRegCopyKeyTree(HKEY hkeyDest, HKEY hkeySrc );

BOOL fQueryFirstAddress(const VSTR & vstr, tstring * const pstr);
BOOL fQuerySecondAddress(const VSTR & vstr, tstring * const pstr);

BOOL FIsIpInRange(PCWSTR szIp);

VOID ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs);

VOID AddInterfacesToAdapterInfo(
    ADAPTER_INFO*   pAdapter,
    DWORD           dwNumInterfaces);

HRESULT GetGuidArrayFromIfaceColWithCoTaskMemAlloc(
    const IFACECOL& IfaceIds,
    GUID** ppdw,
    DWORD* pdwSize);

VOID GetInterfaceName(
    PCWSTR     pszAdapterName,
    const GUID& guidIfaceId,
    tstring*    pstrIfaceName);

HRESULT RetrieveStringFromOptionList(PCWSTR pszOption,
                                    PCWSTR szIdentifier,
                                    tstring & str);

HRESULT GetPnpPopupSettingFromOptionList(PCWSTR pszOption, 
                                         BOOL * pfDisablePopup);

VOID ConstructOptionListString(ADAPTER_INFO*   pAdapter,
                               tstring &       strOptionList);

HRESULT HrParseOptionList(PCWSTR pszOption, 
                          ADAPTER_INFO*   pAdapter);

HRESULT HrGetPrimaryDnsDomain(tstring *pstr);

VOID WriteTcpSetupErrorLog(UINT nIdErrorFormat, ...);

DWORD IPStringToDword(LPCTSTR strIP);

void DwordToIPString(DWORD dwIP, tstring & strIP);

int SearchListViewItem(HWND hListView, int iSubItem, LPCWSTR psz);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\clusterdlg.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    ClusterDlg.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - cluster config tab

Author:

    kyrilf
    shouse

--*/

#pragma once

#include <ncxbase.h>
#include <ncatlps.h>

#include "resource.h"
#include "wlbsparm.h"
#include "wlbscfg.h"

/* Limitations for IP address fields. */
#define WLBS_FIELD_EMPTY -1
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223

class CDialogCluster : public CPropSheetPage {
public:
    /* Declare the message map. */
    BEGIN_MSG_MAP (CDialogCluster)

    MESSAGE_HANDLER (WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER (WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER (WM_HELP, OnHelp)

    NOTIFY_CODE_HANDLER (PSN_APPLY, OnApply)
    NOTIFY_CODE_HANDLER (PSN_KILLACTIVE, OnKillActive)
    NOTIFY_CODE_HANDLER (PSN_SETACTIVE, OnActive)
    NOTIFY_CODE_HANDLER (PSN_RESET, OnCancel)
    NOTIFY_CODE_HANDLER (IPN_FIELDCHANGED, OnIpFieldChange)

    COMMAND_ID_HANDLER (IDC_EDIT_CL_IP, OnEditClIp)
    COMMAND_ID_HANDLER (IDC_EDIT_CL_MASK, OnEditClMask)
    COMMAND_ID_HANDLER (IDC_CHECK_RCT, OnCheckRct)
    COMMAND_ID_HANDLER (IDC_RADIO_UNICAST, OnCheckMode)
    COMMAND_ID_HANDLER (IDC_RADIO_MULTICAST, OnCheckMode)
    COMMAND_ID_HANDLER (IDC_CHECK_IGMP, OnCheckIGMP)

    END_MSG_MAP ()

    /* Constructors/Destructors. */
    CDialogCluster (NETCFG_WLBS_CONFIG * paramp, const DWORD * phelpIDs = NULL);
    ~CDialogCluster ();

public:
    /* Message map functions. */
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);

    LRESULT OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    LRESULT OnEditClIp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnEditClMask (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckRct (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnButtonHelp (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckMode (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckIGMP (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);

    friend class CDialogHost;
    friend class CDialogPorts;

private:
    void SetClusterMACAddress ();
    BOOL CheckClusterMACAddress ();

    void PrintIPRangeError (unsigned int ids, int value, int low, int high);

    void SetInfo ();
    void UpdateInfo ();

    LRESULT ValidateInfo ();          

    NETCFG_WLBS_CONFIG * m_paramp;

    const DWORD * m_adwHelpIDs;

    BOOL m_rct_warned;
    BOOL m_igmp_warned;
    BOOL m_igmp_mcast_warned;

    WCHAR m_passw[CVY_MAX_RCT_CODE + 1];
    WCHAR m_passw2[CVY_MAX_RCT_CODE + 1];

    struct {
        UINT IpControl;
        int Field;
        int Value;
        UINT RejectTimes;
    } m_IPFieldChangeState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\help.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    help.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - help section mappings to the controls

Author:

    kyrilf

--*/

#pragma once
#include "resource.h"

#define IDH_GROUP_CL_IP           IDC_GROUP_CL_IP
#define IDH_EDIT_CL_IP            IDC_EDIT_CL_IP
#define IDH_EDIT_CL_MASK          IDC_EDIT_CL_MASK
#define IDH_EDIT_DOMAIN           IDC_EDIT_DOMAIN
#define IDH_EDIT_ETH              IDC_EDIT_ETH
#define IDH_GROUP_CL_MODE         IDC_GROUP_CL_MODE
#define IDH_RADIO_UNICAST         IDC_RADIO_UNICAST
#define IDH_RADIO_MULTICAST       IDC_RADIO_MULTICAST
#define IDH_CHECK_IGMP            IDC_CHECK_IGMP
#define IDH_CHECK_RCT             IDC_CHECK_RCT
#define IDH_EDIT_PASSW            IDC_EDIT_PASSW
#define IDH_EDIT_PASSW2           IDC_EDIT_PASSW2

const DWORD g_aHelpIDs_IDD_DIALOG_CLUSTER [] = {
    IDC_GROUP_CL_IP,              IDH_GROUP_CL_IP,
    IDC_TEXT_CL_IP,               IDH_EDIT_CL_IP,
    IDC_EDIT_CL_IP,               IDH_EDIT_CL_IP,
    IDC_TEXT_CL_MASK,             IDH_EDIT_CL_MASK,
    IDC_EDIT_CL_MASK,             IDH_EDIT_CL_MASK,
    IDC_TEXT_DOMAIN,              IDH_EDIT_DOMAIN,
    IDC_EDIT_DOMAIN,              IDH_EDIT_DOMAIN,
    IDC_TEXT_ETH,                 IDH_EDIT_ETH,
    IDC_EDIT_ETH,                 IDH_EDIT_ETH,
    IDC_GROUP_CL_MODE,            IDH_GROUP_CL_MODE,
    IDC_RADIO_UNICAST,            IDH_RADIO_UNICAST,
    IDC_RADIO_MULTICAST,          IDH_RADIO_MULTICAST,
    IDC_CHECK_IGMP,               IDH_CHECK_IGMP,
    IDC_GROUP_RCT,                IDH_CHECK_RCT,
    IDC_CHECK_RCT,                IDH_CHECK_RCT,
    IDC_TEXT_PASSW,               IDH_EDIT_PASSW,
    IDC_EDIT_PASSW,               IDH_EDIT_PASSW,
    IDC_TEXT_PASSW2,              IDH_EDIT_PASSW2,
    IDC_EDIT_PASSW2,              IDH_EDIT_PASSW2,
    0, 0
};

#define IDH_EDIT_PRI                 IDC_EDIT_PRI
#define IDH_GROUP_DED_IP             IDC_GROUP_DED_IP
#define IDH_EDIT_DED_IP              IDC_EDIT_DED_IP
#define IDH_EDIT_DED_MASK            IDC_EDIT_DED_MASK
#define IDH_GROUP_INITIAL_HOST_STATE IDC_GROUP_INITIAL_HOST_STATE
#define IDH_COMBOBOX_DEFAULT_STATE   IDC_COMBOBOX_DEFAULT_STATE
#define IDH_CHECK_PERSIST_SUSPEND    IDC_CHECK_PERSIST_SUSPEND

const DWORD g_aHelpIDs_IDD_DIALOG_HOST [] = {
    IDC_TEXT_PRI,                 IDH_EDIT_PRI,
    IDC_EDIT_PRI,                 IDH_EDIT_PRI,
    IDC_SPIN_PRI,                 IDH_EDIT_PRI,
    IDC_GROUP_DED_IP,             IDH_GROUP_DED_IP,
    IDC_TEXT_DED_IP,              IDH_EDIT_DED_IP,
    IDC_EDIT_DED_IP,              IDH_EDIT_DED_IP,
    IDC_TEXT_DED_MASK,            IDH_EDIT_DED_MASK,
    IDC_EDIT_DED_MASK,            IDH_EDIT_DED_MASK,
    IDC_GROUP_INITIAL_HOST_STATE, IDH_GROUP_INITIAL_HOST_STATE,
    IDC_COMBOBOX_DEFAULT_STATE,   IDH_COMBOBOX_DEFAULT_STATE,
    IDC_TEXT_DEFAULT_STATE,       IDH_COMBOBOX_DEFAULT_STATE,
    IDC_CHECK_PERSIST_SUSPEND,    IDH_CHECK_PERSIST_SUSPEND,
    0, 0
};

#define IDH_LIST_PORT_RULE          IDC_LIST_PORT_RULE
#define IDH_BUTTON_ADD              IDC_BUTTON_ADD
#define IDH_BUTTON_MODIFY           IDC_BUTTON_MODIFY
#define IDH_BUTTON_DEL              IDC_BUTTON_DEL
#define IDH_GROUP_PORT_RULE_DESCR   IDC_GROUP_PORT_RULE_DESCR

#define IDH_GROUP_PORT_RULE_VIP     IDC_GROUP_PORT_RULE_VIP
#define IDH_EDIT_PORT_RULE_VIP      IDC_EDIT_PORT_RULE_VIP
#define IDH_CHECK_PORT_RULE_ALL_VIP IDC_CHECK_PORT_RULE_ALL_VIP
#define IDH_GROUP_RANGE             IDC_GROUP_RANGE
#define IDH_EDIT_START              IDC_EDIT_START
#define IDH_EDIT_END                IDC_EDIT_END
#define IDH_GROUP_PROTOCOLS         IDC_GROUP_PROTOCOLS
#define IDH_RADIO_TCP               IDC_RADIO_TCP
#define IDH_RADIO_UDP               IDC_RADIO_UDP
#define IDH_RADIO_BOTH              IDC_RADIO_BOTH
#define IDH_GROUP_FILTERING         IDC_GROUP_MULTIPLE
#define IDH_RADIO_MULTIPLE          IDC_RADIO_MULTIPLE
#define IDH_AFFINITY                IDC_TEXT_AFF
#define IDH_RADIO_AFF_NONE          IDC_RADIO_AFF_NONE
#define IDH_RADIO_AFF_SINGLE        IDC_RADIO_AFF_SINGLE
#define IDH_RADIO_AFF_CLASSC        IDC_RADIO_AFF_CLASSC
#define IDH_LOAD_WEIGHT             IDC_TEXT_MULTI
#define IDH_EDIT_MULTI              IDC_EDIT_MULTI
#define IDH_CHECK_EQUAL             IDC_CHECK_EQUAL
#define IDH_RADIO_SINGLE            IDC_RADIO_SINGLE
#define IDH_EDIT_SINGLE             IDC_EDIT_SINGLE
#define IDH_RADIO_DISABLED          IDC_RADIO_DISABLED

const DWORD g_aHelpIDs_IDD_DIALOG_PORTS [] = {
    IDC_TEXT_PORT_RULE,           IDH_LIST_PORT_RULE,
    IDC_LIST_PORT_RULE,           IDH_LIST_PORT_RULE,
    IDC_BUTTON_ADD,               IDH_BUTTON_ADD,
    IDC_BUTTON_MODIFY,            IDH_BUTTON_MODIFY,
    IDC_BUTTON_DEL,               IDH_BUTTON_DEL,
    IDC_GROUP_PORT_RULE_DESCR,    IDH_GROUP_PORT_RULE_DESCR,
    IDC_TEXT_PORT_RULE_DESCR,     IDH_GROUP_PORT_RULE_DESCR,

    IDC_GROUP_PORT_RULE_VIP,      IDH_GROUP_PORT_RULE_VIP,
    IDC_EDIT_PORT_RULE_VIP,       IDH_EDIT_PORT_RULE_VIP,
    IDC_CHECK_PORT_RULE_ALL_VIP,  IDH_CHECK_PORT_RULE_ALL_VIP,
    IDC_GROUP_RANGE,              IDH_GROUP_RANGE,
    IDC_TEXT_START,               IDH_EDIT_START,
    IDC_EDIT_START,               IDH_EDIT_START,
    IDC_SPIN_START,               IDH_EDIT_START,
    IDC_TEXT_END,                 IDH_EDIT_END,
    IDC_EDIT_END,                 IDH_EDIT_END,
    IDC_SPIN_END,                 IDH_EDIT_END,
    IDC_GROUP_PROTOCOLS,          IDH_GROUP_PROTOCOLS,
    IDC_RADIO_TCP,                IDH_RADIO_TCP,
    IDC_RADIO_UDP,                IDH_RADIO_UDP,
    IDC_RADIO_BOTH,               IDH_RADIO_BOTH,
    IDC_GROUP_MULTIPLE,           IDH_GROUP_FILTERING,
    IDC_RADIO_MULTIPLE,           IDH_RADIO_MULTIPLE,
    IDC_TEXT_AFF,                 IDH_AFFINITY,
    IDC_RADIO_AFF_NONE,           IDH_RADIO_AFF_NONE,
    IDC_RADIO_AFF_SINGLE,         IDH_RADIO_AFF_SINGLE,
    IDC_RADIO_AFF_CLASSC,         IDH_RADIO_AFF_CLASSC,
    IDC_TEXT_MULTI,               IDH_LOAD_WEIGHT,
    IDC_EDIT_MULTI,               IDH_EDIT_MULTI,
    IDC_SPIN_MULTI,               IDH_EDIT_MULTI,
    IDC_CHECK_EQUAL,              IDH_CHECK_EQUAL,
    IDC_GROUP_SINGLE,             IDH_GROUP_FILTERING,
    IDC_RADIO_SINGLE,             IDH_RADIO_SINGLE,
    IDC_TEXT_SINGLE,              IDH_EDIT_SINGLE,
    IDC_EDIT_SINGLE,              IDH_EDIT_SINGLE,
    IDC_SPIN_SINGLE,              IDH_EDIT_SINGLE,
    IDC_GROUP_DISABLED,           IDH_GROUP_FILTERING,
    IDC_RADIO_DISABLED,           IDH_RADIO_DISABLED,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\debug.cpp ===
//+----------------------------------------------------------------------------
//
// File: debug.cpp       
//
// Module:  Network Load Balancing
//
// Synopsis: Provide the functionality of ASSERT
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:   fengsun Created    8/3/98
//
//+----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "debug.h"

#include <strsafe.h>
#include "utils.h"

#if ( defined(DEBUG) || defined(_DEBUG) || defined (DBG))

#ifndef MB_SERVICE_NOTIFICATION
#define MB_SERVICE_NOTIFICATION 0
#endif

static long dwAssertCount = 0;  // Avoid another assert while the messagebox is up


//+----------------------------------------------------------------------------
//
// Function:  AssertMessage
//
// Synopsis:  Popup a message box for asserting failure.  Has three options:
//            ignore/debug/abort.
//
// Arguments: const char *pszFile - File name
//            unsigned nLine - Line number
//            const char *pszMsg - Message in the dialog box
//
// Returns:   Nothing
//
// History:   fengsun Created Header    8/3/98
//
//+----------------------------------------------------------------------------
extern "C" void AssertMessageW(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg) 
{
    TCHAR szOutput[1024];

    //
    // Ignore return value of StringCchPrintf since it will truncate the buffer and
    // guarantees to null-terminate it for us.
    //
    (VOID) StringCchPrintf(szOutput, ASIZECCH(szOutput), TEXT("%s(%u) - %s\n"), pszFile, nLine, pszMsg);
    OutputDebugString(szOutput);

    (VOID) StringCchPrintf(szOutput, ASIZECCH(szOutput), TEXT("%s(%u) - %s\n( Press Retry to debug )"), pszFile, nLine, pszMsg);
    int nCode = IDIGNORE;

    //
    // If there is no Assertion messagebox, popup one
    //
    if (dwAssertCount <2 )
    {
        dwAssertCount++;

        //
        // Title format: Assertion Failed - hello.dll
        //

        //
        // Find the base address of this module.
        //

        MEMORY_BASIC_INFORMATION mbi;
        mbi.AllocationBase = NULL; // current process by if VirtualQuery failed
        VirtualQuery(
                    AssertMessageW,   // any pointer with in the module
                    &mbi,
                    sizeof(mbi) );

        //
        // Get the module filename.
        //

        WCHAR szFileName[MAX_PATH + 1];
        szFileName[0] = L'\0';   // in case of failure

        if (GetModuleFileNameW(
                    (HINSTANCE)mbi.AllocationBase,
                    szFileName,
                    MAX_PATH ) == 0)
        {
            szFileName[0] = L'\0';
        }

        //
        // Get the filename out of the full path
        //
        for (int i=lstrlen(szFileName);i != 0 && szFileName[i-1] != L'\\'; i--)
           ;

        WCHAR szTitle[48];
        if (StringCchCopy(szTitle, ASIZECCH(szTitle), L"Assertion Failed - ") == S_OK)
        {
            (VOID) StringCchCat(szTitle, ASIZECCH(szTitle), szFileName+i);
        }

        nCode = MessageBoxEx(NULL,szOutput,szTitle,
            MB_TOPMOST | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SERVICE_NOTIFICATION,LANG_USER_DEFAULT);


        dwAssertCount--;
    }


    if (nCode == IDIGNORE)
    {
        return;     // ignore
    }
    else if (nCode == IDRETRY)
    {
        
#ifdef _X86_
        //
        // break into the debugger .
        // Step out of this fuction to get to your ASSERT() code
        //
        _asm { int 3 };     
#else
        DebugBreak();
#endif
        return; // ignore and continue in debugger to diagnose problem
    }
    // else fall through and call Abort

    ExitProcess((DWORD)-1);

}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\license.c ===
/*++

Copyright(c) 2000  Microsoft Corporation

Module Name:

    license.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Code to encrypt/decrypt passwords and port rules.

Author:

    kyrilf

History:

    JosephJ 11/22/00 Gutted this file and folded in three constants from
                the now defunct license.h. Basically the functions in this
                file used to do lots of things but now only encrypt/decrypt
                port rules and passwords. The port rules stuff is only used
                for upgrading from olde versions of wlbs so that may go away
                as well.

        This file is located in two places:
            WLBS netconfig code -- net\config\netcfg\wlbscfg
            WLBS API code -- net\wlbs\api

        Because this involves password encryption, we don't want to make
        the functions callable via a DLL entrypoint, and setting up
        a static library to be shared between netconfig and api stuff is
        not trivial and overkill because the two trees are far apart.
        
--*/
// #include <precomp.h>
#include <windows.h>
#include "wlbsparm.h"
#include "license.h"


/* CONSTANTS */


static UCHAR    data_key [] =
                            { 0x3f, 0xba, 0x6e, 0xf0, 0xe1, 0x44, 0x1b, 0x45,
                              0x41, 0xc4, 0x9f, 0xfb, 0x46, 0x54, 0xbc, 0x43 };

static UCHAR    str_key [] =

                           { 0xdb, 0x1b, 0xac, 0x1a, 0xb9, 0xb1, 0x18, 0x03,
                             0x55, 0x57, 0x4a, 0x62, 0x36, 0x21, 0x7c, 0xa6 };


/* Encryption and decryption routines are based on a public-domain Tiny
   Encryption Algorithm (TEA) by David Wheeler and Roger Needham at the
   Computer Laboratory of Cambridge University. For reference, please
   consult http://vader.brad.ac.uk/tea/tea.shtml */


static VOID License_decipher (
    PULONG              v,
    PULONG              k)
{
   ULONG                y = v [0],
                        z = v [1],
                        a = k [0],
                        b = k [1],
                        c = k [2],
                        d = k [3],
                        n = 32,
                        sum = 0xC6EF3720,
                        delta = 0x9E3779B9;

    /* sum = delta<<5, in general sum = delta * n */

    while (n-- > 0)
    {
        z -= (y << 4) + c ^ y + sum ^ (y >> 5) + d;
        y -= (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        sum -= delta;
    }

    v [0] = y; v [1] = z;

} /* end License_decipher */


static VOID License_encipher (
    PULONG              v,
    PULONG              k)
{
    ULONG               y = v [0],
                        z = v [1],
                        a = k [0],
                        b = k [1],
                        c = k [2],
                        d = k [3],
                        n = 32,
                        sum = 0,
                        delta = 0x9E3779B9;

    while (n-- > 0)
    {
        sum += delta;
        y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
        z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;
    }

    v [0] = y; v [1] = z;

} /* end License_encipher */



BOOL License_data_decode (
    PCHAR               data,
    ULONG               len)
{
    ULONG               i;


    if (len % LICENSE_DATA_GRANULARITY != 0)
        return FALSE;

    for (i = 0; i < len; i += LICENSE_DATA_GRANULARITY)
        License_decipher ((PULONG) (data + i), (PULONG) data_key);

    return TRUE;

} /* License_data_decode */


ULONG License_wstring_encode (
    PWCHAR              str)
{
    CHAR                buf [LICENSE_STR_IMPORTANT_CHARS + 1];
    ULONG               code, i;
    PULONG              nibp;


    for (i = 0; i < LICENSE_STR_IMPORTANT_CHARS; i++)
    {
        if (str[i] == 0)
            break;

        buf[i] = (UCHAR)str[i];
    }

    for (; i < LICENSE_STR_IMPORTANT_CHARS + 1; i ++)
        buf[i] = 0;

    for (i = 0; i < LICENSE_STR_NIBBLES; i ++)
        License_encipher ((PULONG) (buf + i * LICENSE_DATA_GRANULARITY),
                          (PULONG) str_key);

    for (i = 0, code = 0; i < LICENSE_STR_NIBBLES; i ++)
    {
        nibp = (PULONG) (buf + (i * LICENSE_DATA_GRANULARITY));
        code ^= nibp [0] ^ nibp [1];
    }

    /* V2.2 - if password consists of the same characters - XORing nibbles
       above makes it go to 0 - put some recovery for that special case since
       we cannot modify the algorithm due to legacy issues */

    if (code == 0 && str [0] != 0)
        code = * ((PULONG) buf);

    return code;

} /* License_wstring_encode */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\netcfgcluster.h ===
#pragma once

#include "wlbscfg.h"

//+----------------------------------------------------------------------------
//
// class CNetcfgCluster
//
// Description: Provide cluster config functionality for netcfg .
//              SetConfig caches the settings without saving to registry            
//              and can be retrieved by GetConfig.
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------

HRESULT GetAdapterFromGuid(INetCfg *pNetCfg, const GUID& NetCardGuid, OUT INetCfgComponent** ppNetCardComponent);

class CNetcfgCluster
{
public:
    CNetcfgCluster(CWlbsConfig* pConfig);
    ~CNetcfgCluster();

    DWORD InitializeFromRegistry(const GUID& guidAdapter, bool fBindingEnabled, bool fUpgradeFromWin2k);
    HRESULT InitializeFromAnswerFile(const GUID& AdapterGuid, CSetupInfFile& caf, PCWSTR answer_sections);
    void InitializeWithDefault(const GUID& guidAdapter);

    void SetConfig(const NETCFG_WLBS_CONFIG* pClusterConfig);
    void GetConfig(NETCFG_WLBS_CONFIG* pClusterConfig);

    void NotifyBindingChanges(DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

    DWORD NotifyAdapter (INetCfgComponent * pAdapter, DWORD newStatus);

    DWORD ApplyRegistryChanges(bool fUninstall);
    DWORD ApplyPnpChanges(HANDLE hWlbsDevice);

    const GUID& GetAdapterGuid() { return m_AdapterGuid;}

    bool CheckForDuplicateClusterIPAddress (WCHAR * szOtherIP);
    bool CheckForDuplicateBDATeamMaster (NETCFG_WLBS_BDA_TEAMING * pBDATeaming);

    bool NLBIsBound();

    bool IsReloadRequired () { return m_fReloadRequired; };
    static void ResetMSCSLatches();
protected:

    GUID m_AdapterGuid;

    WLBS_REG_PARAMS m_OriginalConfig;        // original config 
    WLBS_REG_PARAMS m_CurrentConfig;         // cached config

    bool m_fHasOriginalConfig;               // whether the adapter has an original config
    bool m_fOriginalBindingEnabled;          // whether the binding to the adapter is originally enabled
    bool m_fRemoveAdapter;                   // whether the adapter is to be removed
    bool m_fMacAddrChanged;                  // whether we need to reload the nic driver
    bool m_fReloadRequired;                  // set if changes in registry need to be picked by wlbs driver
    bool m_fReenableAdapter;                 // do we need to re-enable this adapter (did WE disable it?)
    static bool m_fMSCSWarningEventLatched;  // Throw MSCS warning only once when binding NLB
    static bool m_fMSCSWarningPopupLatched;  // Popup MSCS warning only once when binding NLB

    CWlbsConfig* m_pConfig;                  // pointer to access m_pWlbsApiFuncs
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\license.h ===
#ifdef  __cplusplus
extern "C"
{
#endif

ULONG License_wstring_encode (
    PWCHAR              str);               /* NULL-terminated wide character string */
/*
  Encodes string

  returns ULONG:
    <code> => encoded string

  function:
*/


BOOL License_data_decode (
    PCHAR               data,               /* pointer to data */
    ULONG               len);               /* data length in bytes */
/*
  Decodes arbitrary data stream

  returns BOOL:
    TRUE  => data encoded OK
    FALSE => length has to be the multiples of LICENSE_DATA_GRANULARITY bytes

  function:
*/

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\ports.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    ports.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - port rules tab

Author:

    kyrilf
    shouse

--*/


#pragma once

#include <ncxbase.h>
#include <ncatlps.h>

#include "resource.h"
#include "wlbsconfig.h"
#include "wlbsparm.h"
#include "wlbscfg.h"

/* Limitations for IP address fields. */
#define WLBS_FIELD_EMPTY -1
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223

#define WLBS_INVALID_PORT_RULE_INDEX -1

#define WLBS_NUM_COLUMNS        8
#define WLBS_VIP_COLUMN         0
#define WLBS_PORT_START_COLUMN  1
#define WLBS_PORT_END_COLUMN    2
#define WLBS_PROTOCOL_COLUMN    3
#define WLBS_MODE_COLUMN        4
#define WLBS_PRIORITY_COLUMN    5
#define WLBS_LOAD_COLUMN        6
#define WLBS_AFFINITY_COLUMN    7

struct VALID_PORT_RULE : public NETCFG_WLBS_PORT_RULE {
    BOOL valid;
};

class CDialogPorts : public CPropSheetPage {
public:
    /* Declare the message map. */
    BEGIN_MSG_MAP (CDialogPorts)

    MESSAGE_HANDLER (WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER (WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER (WM_HELP, OnHelp)

    NOTIFY_CODE_HANDLER (PSN_APPLY, OnApply)
    NOTIFY_CODE_HANDLER (PSN_KILLACTIVE, OnKillActive)
    NOTIFY_CODE_HANDLER (PSN_SETACTIVE, OnActive)
    NOTIFY_CODE_HANDLER (PSN_RESET, OnCancel)
    NOTIFY_CODE_HANDLER (LVN_ITEMCHANGED, OnStateChange)
    NOTIFY_CODE_HANDLER (NM_DBLCLK, OnDoubleClick)
    NOTIFY_CODE_HANDLER (LVN_COLUMNCLICK, OnColumnClick)

    COMMAND_ID_HANDLER (IDC_BUTTON_ADD, OnButtonAdd)
    COMMAND_ID_HANDLER (IDC_BUTTON_DEL, OnButtonDel)
    COMMAND_ID_HANDLER (IDC_BUTTON_MODIFY, OnButtonModify)

    END_MSG_MAP ()

    /* Constructors/Destructors. */
    CDialogPorts (NETCFG_WLBS_CONFIG * paramp, const DWORD * phelpIDs = NULL);
    ~CDialogPorts ();

public:
    /* Message map functions. */
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);

    LRESULT OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnStateChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnDoubleClick (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnColumnClick (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
 
    LRESULT OnButtonAdd (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnButtonDel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnButtonModify (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);

    friend class CDialogHost;
    friend class CDialogCluster;
    friend class CDialogPortRule;

private:
    void SetInfo ();
    void UpdateInfo ();
    
    void CreateRule (BOOL select, VALID_PORT_RULE * rulep);
    void UpdateList (BOOL add, BOOL del, BOOL modify, VALID_PORT_RULE * rulep);
    int InsertRule (VALID_PORT_RULE * rulep);
    void FillPortRuleDescription ();

    NETCFG_WLBS_CONFIG * m_paramp;

    const DWORD * m_adwHelpIDs;

    BOOL m_rulesValid;

    int m_sort_column;
    enum { WLBS_SORT_ASCENDING = 0, WLBS_SORT_DESCENDING = 1 } m_sort_order;

    VALID_PORT_RULE m_rules[WLBS_MAX_RULES];
};

class CDialogPortRule : public CDialogImpl<CDialogPortRule> {
public:
    enum { IDD = IDD_DIALOG_PORT_RULE_PROP };

    BEGIN_MSG_MAP (CDialogPortRule)

    MESSAGE_HANDLER (WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER (WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER (WM_HELP, OnHelp)

    NOTIFY_CODE_HANDLER (IPN_FIELDCHANGED, OnIpFieldChange)

    COMMAND_ID_HANDLER (IDOK, OnOk);
    COMMAND_ID_HANDLER (IDCANCEL, OnCancel);
    COMMAND_ID_HANDLER (IDC_CHECK_PORT_RULE_ALL_VIP, OnCheckPortRuleAllVip);
    COMMAND_ID_HANDLER (IDC_CHECK_EQUAL, OnCheckEqual)
    COMMAND_ID_HANDLER (IDC_RADIO_MULTIPLE, OnRadioMode)
    COMMAND_ID_HANDLER (IDC_RADIO_SINGLE, OnRadioMode)
    COMMAND_ID_HANDLER (IDC_RADIO_DISABLED, OnRadioMode)

    END_MSG_MAP ()

    CDialogPortRule (CDialogPorts * parent, const DWORD * phelpIDs, int index);
    ~CDialogPortRule ();

public:
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled);

    LRESULT OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    LRESULT OnOk (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckPortRuleAllVip (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnCheckEqual (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);
    LRESULT OnRadioMode (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled);

    friend class CDialogPorts;

private:
    void PrintIPRangeError (unsigned int ids, int value, int low, int high);
    void PrintRangeError (unsigned int ids, int low, int high);

    void SetInfo ();
    void ModeSwitch ();

    BOOL ValidateRule (VALID_PORT_RULE * rulep, BOOL self_check);

    const DWORD * m_adwHelpIDs;

    CDialogPorts * m_parent;

    int m_index;

    VALID_PORT_RULE m_rule;
    struct {
      UINT IpControl;
      int Field;
      int Value;
      UINT RejectTimes;
    } m_IPFieldChangeState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\resource.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object UI - resource IDs

Author:

    kyrilf

--*/

//#include <ncres.h>

#pragma once

#define IDR_REG_WLBS                            40001

#define ID_CONTEXT_HELP                             8
#define ID_HELP                                     9

/* String table entries for configuration error messages or warnings. */
#define IDS_PARM_RULES                            201
#define IDS_PARM_RANGE                            202
#define IDS_PARM_OVERLAP                          203
#define IDS_PARM_PASSWORD                         204
#define IDS_PARM_IGMP_MCAST                       205
#define IDS_PARM_RCT_WARN                         206
#define IDS_PARM_IGMP_WARN                        207
#define IDS_PARM_WARN                             208
#define IDS_PARM_ERROR                            209
#define IDS_PARM_INFORMATION                      210
#define IDS_PARM_PORT_BLANK                       211
#define IDS_PARM_LOAD_BLANK                       212
#define IDS_PARM_HPRI_BLANK                       213
#define IDS_PARM_PRI_BLANK                        214
#define IDS_PARM_CL_IP_BLANK                      215
#define IDS_PARM_DED_IP_BLANK                     216
#define IDS_PARM_CL_NM_BLANK                      217
#define IDS_PARM_DED_NM_BLANK                     218
#define IDS_PARM_INVAL_CL_IP                      219
#define IDS_PARM_INVAL_DED_IP                     220
#define IDS_PARM_INVAL_CL_MASK                    221
#define IDS_PARM_INVAL_DED_MASK                   222
#define IDS_PARM_CL_IP_FIELD                      223
#define IDS_PARM_CL_NM_FIELD                      224
#define IDS_PARM_DED_IP_FIELD                     225
#define IDS_PARM_DED_NM_FIELD                     226
#define IDS_PARM_PRI                              227
#define IDS_PARM_PORT_VAL                         228
#define IDS_PARM_LOAD                             229
#define IDS_PARM_SINGLE                           230
#define IDS_PARM_IP_CONFLICT                      231
#define IDS_PARM_MULTINIC_IP_CONFLICT             232
#define IDS_PARM_INVAL_MAC                        233
#define IDS_PARM_TCPIP                            234
#define IDS_PARM_VIP_BLANK                        235
#define IDS_PARM_VIP_CONFLICT_DIP                 236
#define IDS_PARM_DIP_CONFLICT_VIP                 237
#define IDS_PARM_MSCS_INSTALLED                   238
#define IDS_PARM_OPEN_ANS_FILE_FAILED             239
#define IDS_PARM_GET_ADAPTERS_FAILED              240
#define IDS_PARM_GET_SPECIFIC_TO                  241
#define IDS_PARM_GET_NETCARD_GUID                 242
#define IDS_PARM_OOM_NETCFGCLUS                   243
#define IDS_PARM_GET_VALUE_FAILED                 244
#define IDS_PARM_LICENSE_DECODE_FAILED            245
#define IDS_PARM_PORT_RULE_INVALID                246

/* String table entries for the port rule listbox. */
#define IDS_LIST_BOTH                             260
#define IDS_LIST_TCP                              261
#define IDS_LIST_UDP                              262
#define IDS_LIST_MULTIPLE                         263
#define IDS_LIST_SINGLE                           264
#define IDS_LIST_DISABLED                         265
#define IDS_LIST_EQUAL                            266
#define IDS_LIST_ANONE                            267
#define IDS_LIST_ASINGLE                          268
#define IDS_LIST_ACLASSC                          269
#define IDS_LIST_START                            270
#define IDS_LIST_END                              271
#define IDS_LIST_PROT                             272
#define IDS_LIST_MODE                             273
#define IDS_LIST_PRI                              274
#define IDS_LIST_LOAD                             275
#define IDS_LIST_AFF                              276
#define IDS_LIST_VIP                              277
#define IDS_LIST_ALL_VIP                          278

/* String table entries for the host state combo box. */
#define IDS_HOST_STATE_STARTED                    290
#define IDS_HOST_STATE_STOPPED                    291
#define IDS_HOST_STATE_SUSPENDED                  292

/* String table entries for the port rule descriptions. */
#define IDS_PORT_RULE_DEFAULT                             300
#define IDS_PORT_RULE_ALL_VIP_TCP_PORT_DISABLED           301
#define IDS_PORT_RULE_ALL_VIP_TCP_PORT_SINGLE             302
#define IDS_PORT_RULE_ALL_VIP_TCP_PORT_MULTIPLE_EQUAL     303
#define IDS_PORT_RULE_ALL_VIP_TCP_PORT_MULTIPLE_UNEQUAL   304
#define IDS_PORT_RULE_ALL_VIP_TCP_PORTS_DISABLED          305
#define IDS_PORT_RULE_ALL_VIP_TCP_PORTS_SINGLE            306
#define IDS_PORT_RULE_ALL_VIP_TCP_PORTS_MULTIPLE_EQUAL    307
#define IDS_PORT_RULE_ALL_VIP_TCP_PORTS_MULTIPLE_UNEQUAL  308
#define IDS_PORT_RULE_ALL_VIP_UDP_PORT_DISABLED           309
#define IDS_PORT_RULE_ALL_VIP_UDP_PORT_SINGLE             310
#define IDS_PORT_RULE_ALL_VIP_UDP_PORT_MULTIPLE_EQUAL     311
#define IDS_PORT_RULE_ALL_VIP_UDP_PORT_MULTIPLE_UNEQUAL   312
#define IDS_PORT_RULE_ALL_VIP_UDP_PORTS_DISABLED          313
#define IDS_PORT_RULE_ALL_VIP_UDP_PORTS_SINGLE            314
#define IDS_PORT_RULE_ALL_VIP_UDP_PORTS_MULTIPLE_EQUAL    315
#define IDS_PORT_RULE_ALL_VIP_UDP_PORTS_MULTIPLE_UNEQUAL  316
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORT_DISABLED          317
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORT_SINGLE            318
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORT_MULTIPLE_EQUAL    319
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORT_MULTIPLE_UNEQUAL  320
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_DISABLED         321
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_SINGLE           322
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_MULTIPLE_EQUAL   323
#define IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_MULTIPLE_UNEQUAL 324
#define IDS_PORT_RULE_VIP_TCP_PORT_DISABLED               331
#define IDS_PORT_RULE_VIP_TCP_PORT_SINGLE                 332
#define IDS_PORT_RULE_VIP_TCP_PORT_MULTIPLE_EQUAL         333
#define IDS_PORT_RULE_VIP_TCP_PORT_MULTIPLE_UNEQUAL       334
#define IDS_PORT_RULE_VIP_TCP_PORTS_DISABLED              335
#define IDS_PORT_RULE_VIP_TCP_PORTS_SINGLE                336
#define IDS_PORT_RULE_VIP_TCP_PORTS_MULTIPLE_EQUAL        337
#define IDS_PORT_RULE_VIP_TCP_PORTS_MULTIPLE_UNEQUAL      338
#define IDS_PORT_RULE_VIP_UDP_PORT_DISABLED               339
#define IDS_PORT_RULE_VIP_UDP_PORT_SINGLE                 340
#define IDS_PORT_RULE_VIP_UDP_PORT_MULTIPLE_EQUAL         341
#define IDS_PORT_RULE_VIP_UDP_PORT_MULTIPLE_UNEQUAL       342
#define IDS_PORT_RULE_VIP_UDP_PORTS_DISABLED              343
#define IDS_PORT_RULE_VIP_UDP_PORTS_SINGLE                344
#define IDS_PORT_RULE_VIP_UDP_PORTS_MULTIPLE_EQUAL        345
#define IDS_PORT_RULE_VIP_UDP_PORTS_MULTIPLE_UNEQUAL      346
#define IDS_PORT_RULE_VIP_BOTH_PORT_DISABLED              347
#define IDS_PORT_RULE_VIP_BOTH_PORT_SINGLE                348
#define IDS_PORT_RULE_VIP_BOTH_PORT_MULTIPLE_EQUAL        349
#define IDS_PORT_RULE_VIP_BOTH_PORT_MULTIPLE_UNEQUAL      350
#define IDS_PORT_RULE_VIP_BOTH_PORTS_DISABLED             351
#define IDS_PORT_RULE_VIP_BOTH_PORTS_SINGLE               352
#define IDS_PORT_RULE_VIP_BOTH_PORTS_MULTIPLE_EQUAL       353
#define IDS_PORT_RULE_VIP_BOTH_PORTS_MULTIPLE_UNEQUAL     354
#define IDS_PORT_RULE_AFFINITY_NONE                       355
#define IDS_PORT_RULE_AFFINITY_SINGLE                     356
#define IDS_PORT_RULE_AFFINITY_CLASSC                     357

/* The dialogs. */
#define IDD_DIALOG_CLUSTER                        533
#define IDD_DIALOG_HOST                           534
#define IDD_DIALOG_PORTS                          535
#define IDD_DIALOG_PORT_RULE_PROP                 536

/* Accelerators. */
#define IDR_ACCELERATOR                           700

/* The controls for the cluster properties page. */
#define IDC_GROUP_CL_IP                          1000
#define IDC_TEXT_CL_IP                           1001
#define IDC_EDIT_CL_IP                           1002
#define IDC_TEXT_CL_MASK                         1003
#define IDC_EDIT_CL_MASK                         1004
#define IDC_TEXT_DOMAIN                          1005
#define IDC_EDIT_DOMAIN                          1006
#define IDC_TEXT_ETH                             1007
#define IDC_EDIT_ETH                             1008
#define IDC_GROUP_CL_MODE                        1009
#define IDC_RADIO_UNICAST                        1010
#define IDC_RADIO_MULTICAST                      1011
#define IDC_CHECK_IGMP                           1012
#define IDC_GROUP_RCT                            1013
#define IDC_CHECK_RCT                            1014
#define IDC_TEXT_PASSW                           1015
#define IDC_EDIT_PASSW                           1016
#define IDC_TEXT_PASSW2                          1017
#define IDC_EDIT_PASSW2                          1018

/* The controls for the host properties page. */
#define IDC_TEXT_PRI                             2000
#define IDC_EDIT_PRI                             2001
#define IDC_SPIN_PRI                             2002
#define IDC_GROUP_DED_IP                         2003
#define IDC_TEXT_DED_IP                          2004
#define IDC_EDIT_DED_IP                          2005
#define IDC_TEXT_DED_MASK                        2006
#define IDC_EDIT_DED_MASK                        2007
#define IDC_COMBOBOX_DEFAULT_STATE               2008
#define IDC_TEXT_DEFAULT_STATE                   2009
#define IDC_GROUP_INITIAL_HOST_STATE             2010
#define IDC_CHECK_PERSIST_SUSPEND                2011

/* The controls for the port rules page. */
#define IDC_TEXT_PORT_RULE                       3000
#define IDC_LIST_PORT_RULE                       3001
#define IDC_BUTTON_ADD                           3002
#define IDC_BUTTON_MODIFY                        3003
#define IDC_BUTTON_DEL                           3004
#define IDC_GROUP_PORT_RULE_DESCR                3005
#define IDC_TEXT_PORT_RULE_DESCR                 3006

/* The controls for the port rule properties page. */
#define IDC_GROUP_RANGE                          4000
#define IDC_EDIT_START                           4001
#define IDC_SPIN_START                           4002
#define IDC_EDIT_END                             4003
#define IDC_SPIN_END                             4004
#define IDC_GROUP_PROTOCOLS                      4005
#define IDC_RADIO_TCP                            4006
#define IDC_RADIO_UDP                            4007
#define IDC_RADIO_BOTH                           4008
#define IDC_GROUP_SINGLE                         4009
#define IDC_GROUP_MULTIPLE                       4010
#define IDC_GROUP_DISABLED                       4011
#define IDC_RADIO_SINGLE                         4012
#define IDC_RADIO_MULTIPLE                       4013
#define IDC_RADIO_DISABLED                       4014
#define IDC_TEXT_AFF                             4015
#define IDC_RADIO_AFF_NONE                       4016
#define IDC_RADIO_AFF_SINGLE                     4017
#define IDC_RADIO_AFF_CLASSC                     4018
#define IDC_TEXT_MULTI                           4019
#define IDC_EDIT_MULTI                           4020
#define IDC_SPIN_MULTI                           4021
#define IDC_CHECK_EQUAL                          4022
#define IDC_TEXT_SINGLE                          4023
#define IDC_EDIT_SINGLE                          4024
#define IDC_SPIN_SINGLE                          4025
#define IDC_TEXT_START                           4026
#define IDC_TEXT_END                             4027
#define IDC_GROUP_PORT_RULE_VIP                  4028
#define IDC_EDIT_PORT_RULE_VIP                   4029
#define IDC_CHECK_PORT_RULE_ALL_VIP              4030
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\ports.cpp ===
/*++         
    
Copyright(c) 1998,99  Microsoft Corporation
    
Module Name:
    
ports.cpp
    
Abstract:
    
Windows Load Balancing Service (WLBS)
Notifier object UI - port rules config tab
    
Author:
    
kyrilf
shouse
    
--*/

#include "pch.h"
#pragma hdrstop
#include "ncatlui.h"

#include "resource.h"
#include "wlbsparm.h"
#include "wlbscfg.h"
#include "ports.h"
#include "utils.h"
#include <winsock.h>

#include <strsafe.h>

#include "ports.tmh"

#if DBG
static void TraceMsg(PCWSTR pszFormat, ...);
#else
#define TraceMsg NOP_FUNCTION
#endif

#define DIALOG_LIST_STRING_SIZE 80
#define MAX_PORT_RULE_DESCRIPTION_LEN 512

typedef struct
{
    WCHAR              wszDescription[MAX_PORT_RULE_DESCRIPTION_LEN];
} NLB_PORT_RULE_DESC, * PNLB_PORT_RULE_DESC;

/*
 * Method: CDialogPorts
 * Description: The class constructor.
 */
CDialogPorts::CDialogPorts (NETCFG_WLBS_CONFIG * paramp, const DWORD * adwHelpIDs) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::CDialogPorts\n");

    m_paramp = paramp;
    m_adwHelpIDs = adwHelpIDs;
    m_rulesValid = FALSE;
    m_sort_column = WLBS_VIP_COLUMN;
    m_sort_order = WLBS_SORT_ASCENDING;
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: ~CDialogPorts
 * Description: The class destructor.
 */
CDialogPorts::~CDialogPorts () {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CDialogPorts::~CDialogPorts\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the port rule properties dialog.
 */
LRESULT CDialogPorts::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnInitDialog\n");

    LV_COLUMN lvCol;
    RECT rect;

    /* Always tell NetCfg that the page has changed, so we don't have to keep track of this. */
    SetChangedFlag();

    /* We are specifying the column format, text, and width. */
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;

    ::GetClientRect(GetDlgItem(IDC_LIST_PORT_RULE), &rect);
    int colWidth = (rect.right - 90)/(WLBS_NUM_COLUMNS - 2);

    /* Add all column headers to the port rule list box. */
    for (int index = 0; index < WLBS_NUM_COLUMNS; index++) {
        /* Set column configuration based on which column we're inserting. */
        switch (index) {
        case WLBS_VIP_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_VIP);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 98;
            break;
        case WLBS_PORT_START_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_START);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 42;
            break;
        case WLBS_PORT_END_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_END);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 42;
            break;
        case WLBS_PROTOCOL_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_PROT);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 44;
            break;
        case WLBS_MODE_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_MODE);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 53;
            break;
        case WLBS_PRIORITY_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_PRI);
            lvCol.fmt = LVCFMT_CENTER;
            lvCol.cx = 43;
            break;
        case WLBS_LOAD_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_LOAD);
            lvCol.fmt = LVCFMT_CENTER;
            lvCol.cx = 52;
            break;
        case WLBS_AFFINITY_COLUMN:
            lvCol.pszText = (LPWSTR)SzLoadIds(IDS_LIST_AFF);
            lvCol.fmt = LVCFMT_LEFT;
            lvCol.cx = 50;
            break;
        }

        /* Insert the column into the listbox. */
        if (ListView_InsertColumn(GetDlgItem(IDC_LIST_PORT_RULE), index, &lvCol) != index) {
            TraceMsg(L"CDialogPorts::OnInitDialog Invalid item (%d) inserted into list view\n", index);
            TRACE_CRIT("%!FUNC! Invalid item (%d) inserted into list view", index);
            TRACE_VERB("<-%!FUNC!");
            return 0;
        }
    }

    /* Set the extended sytles: Full row selection (as opposed to the default of column one only)  */
    ListView_SetExtendedListViewStyleEx(GetDlgItem(IDC_LIST_PORT_RULE), LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CDialogPorts::OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CDialogPorts::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnActive
 * Description: Called when the port rules tab becomes active (is clicked). 
 */
LRESULT CDialogPorts::OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnActive\n");

    /* Populate the UI with the current configuration. */
    SetInfo();

    /* If any port rules have been defined, "snap" the listbox to the first rule.
       If no rules currently exist, disable the MODIFY and DELETE buttons. */
    if (m_paramp->dwNumRules) {
        /* Select the first item in the port rule list. */
        ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    } else {
        /* Since there are no port rules defined, disable the Modify and Delete buttons. */
        ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), FALSE);
        ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), FALSE);

        /* Fill in the default port rule description */
        FillPortRuleDescription();
    }

    /* If the maximum number of port rules has already been defined, then disable the ADD button. */
    if (m_paramp->dwNumRules >= m_paramp->dwMaxRules)
        ::EnableWindow(GetDlgItem(IDC_BUTTON_ADD), FALSE);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, 0);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnKillActive
 * Description: Called When the focus moves away from the port rules tab.
 */
LRESULT CDialogPorts::OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnKillActive\n");

    /* Get the new configuration from the UI. */
    UpdateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnApply
 * Description: Called when the user clicks "OK".
 */
LRESULT CDialogPorts::OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnApply\n");

    return 0;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CDialogPorts::OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnCancel\n");

    return 0;
}

/*
 * Method: OnColumnClick
 * Description: Called when the user clicks a column header in the listbox.
 */
LRESULT CDialogPorts::OnColumnClick (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnColumnClick\n");

    LPNMLISTVIEW lv;

    switch (idCtrl) {
    case IDC_LIST_PORT_RULE:
        /* Extract the column information. */
        lv = (LPNMLISTVIEW)pnmh;

        /* If we are sorting by the same column we were previously sorting by, 
           then we reverse the sort order. */
        if (m_sort_column == lv->iSubItem) {
            if (m_sort_order == WLBS_SORT_ASCENDING)
                m_sort_order = WLBS_SORT_DESCENDING;
            else if (m_sort_order == WLBS_SORT_DESCENDING)
                m_sort_order = WLBS_SORT_ASCENDING;
        }

        /* We sort by the column that was clicked. */
        m_sort_column = lv->iSubItem;

        /* Teardown the listbox and make sure our data matches the state of the UI. */
        UpdateInfo();

        /* Rebuild the listbox, with the new sort criteria. */
        SetInfo();

        /* Select the first item in the port rule list. */
        if (m_paramp->dwNumRules) ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnDoubleClick
 * Description: Called when the user double clicks an item in the listbox. 
 */
LRESULT CDialogPorts::OnDoubleClick (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnDoubleClick\n");

    switch (idCtrl) {
    case IDC_LIST_PORT_RULE:
        /* When an item is double-clicked, consider it an edit request. */
        OnButtonModify(BN_CLICKED, 0, 0, fHandled);
        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnStateChange
 * Description: Called when the user selects a port rule from the list.
 */
LRESULT CDialogPorts::OnStateChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnStateChange\n");

    switch (idCtrl) {
    case IDC_LIST_PORT_RULE:
        LPNMLISTVIEW lv = (LPNMLISTVIEW)pnmh;
        int index;

        /* When the user selects a port rule, change the port rule description. */
        if (lv->uChanged & LVIF_STATE) FillPortRuleDescription();

        /* Find the index of the currently selected port rule. */
        if ((index = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1) {
            /* If no port rule is selected, then disable the edit and delete buttons. */
            ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), FALSE);
            ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), FALSE);
        } else {
            /* If one is selected, make sure the edit and delete buttons are enabled. */
            ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), TRUE);
            ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), TRUE);

            /* Give it the focus. */
            ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), index, LVIS_FOCUSED, LVIS_FOCUSED);
        }

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

//+----------------------------------------------------------------------------
//
// Function:  FormPortRuleDescription
//
// Description: Form the port rule description string from the resource string. 
//              FormatMessage parses the resource string for %1, %2!d!, ..etc
//              and replaces it with the values passed in the variable args
//
// Arguments: WCHAR *pwcDescription - Buffer to be filled on return
//            UINT uiIdDescrFormat - string resource identifier
//            <variable length list of variable args>
//
// Returns:   return value of FormatMessage
//
// History:   karthicn Created: Dec 7, 2001
//
//+----------------------------------------------------------------------------
DWORD FormPortRuleDescription(NLB_PORT_RULE_DESC *pDescription, UINT uiIdDescrFormat, ...)
{
    PCWSTR pszFormat = SzLoadIds(uiIdDescrFormat);
    DWORD  dwRet;

    va_list val;
    va_start(val, uiIdDescrFormat);

    ASSERT (pDescription != NULL);

    dwRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                          pszFormat, 
                          0, // Message Identifier - Ignored for FORMAT_MESSAGE_FROM_STRING
                          0, // Language Identifier
                          pDescription->wszDescription,
                          ASIZECCH(pDescription->wszDescription), 
                          &val);

    va_end(val);

    return dwRet;
}


/*
 * Method: OnDoubleClick
 * Description: Called when the user double clicks an item in the listbox. 
 */
void CDialogPorts::FillPortRuleDescription () {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::FillPortRuleDescription\n");

    VALID_PORT_RULE * rp = NULL;
    NLB_PORT_RULE_DESC description;
    LV_ITEM  lvItem;
    int      index;            
    DWORD    dwRet = 0;
    
    /* Find the index of the currently selected port rule. */
    if ((index = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1) {
        /* If there is no port rule selected, then display information about how traffic
           not covered by the port rule set is handled. */
        ::SetDlgItemText(m_hWnd, IDC_TEXT_PORT_RULE_DESCR, SzLoadIds(IDS_PORT_RULE_DEFAULT));
        TRACE_INFO("%!FUNC! a port rule was no selected");
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    /* Fill in the information for this port rule. */
    lvItem.iItem = index;
    lvItem.iSubItem = 0;
    lvItem.mask = LVIF_PARAM;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    
    /* Get the information about this port rule. */
    if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
        TraceMsg(L"CDialogPorts::FillPortRuleDescription Unable to retrieve item %d from listbox\n", index);
        TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", index);
        TRACE_VERB("<-%!FUNC!");
        return;
    }
    
    /* Get the data pointer for this port rule. */
    if (!(rp = (VALID_PORT_RULE*)lvItem.lParam)) {
        TraceMsg(L"CDialogPorts::FillPortRuleDescription rule for item %d is bogus\n", index);
        TRACE_CRIT("%!FUNC! rule for item %d is bogus", index);
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    /* This code is terrible - for localization reasons, we require an essentially static string table entry
       for each possible port rule configuration.  So, we have to if/switch ourselves to death trying to 
       match this port rule with the correct string in the table - then we pop in stuff like port ranges. */
    if (!lstrcmpi(rp->virtual_ip_addr, CVY_DEF_ALL_VIP)) {
        switch (rp->protocol) {
        case CVY_TCP:
            if (rp->start_port == rp->end_port) {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_TCP_PORT_DISABLED, rp->start_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_TCP_PORT_SINGLE, rp->start_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_TCP_PORT_MULTIPLE_EQUAL, rp->start_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_TCP_PORT_MULTIPLE_UNEQUAL, rp->start_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            } else {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_TCP_PORTS_DISABLED, rp->start_port, rp->end_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_TCP_PORTS_SINGLE, rp->start_port, rp->end_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_TCP_PORTS_MULTIPLE_EQUAL, rp->start_port, rp->end_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_TCP_PORTS_MULTIPLE_UNEQUAL, rp->start_port, rp->end_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            }
            break;
        case CVY_UDP:
            if (rp->start_port == rp->end_port) {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_UDP_PORT_DISABLED, rp->start_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_UDP_PORT_SINGLE, rp->start_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_UDP_PORT_MULTIPLE_EQUAL, rp->start_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_UDP_PORT_MULTIPLE_UNEQUAL, rp->start_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            } else {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_UDP_PORTS_DISABLED, rp->start_port, rp->end_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_UDP_PORTS_SINGLE, rp->start_port, rp->end_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_UDP_PORTS_MULTIPLE_EQUAL, rp->start_port, rp->end_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_UDP_PORTS_MULTIPLE_UNEQUAL, rp->start_port, rp->end_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            }
            break;
        case CVY_TCP_UDP:
            if (rp->start_port == rp->end_port) {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_BOTH_PORT_DISABLED, rp->start_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_BOTH_PORT_SINGLE, rp->start_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_BOTH_PORT_MULTIPLE_EQUAL, rp->start_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_BOTH_PORT_MULTIPLE_UNEQUAL, rp->start_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            } else {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_DISABLED, rp->start_port, rp->end_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_SINGLE, rp->start_port, rp->end_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_MULTIPLE_EQUAL, rp->start_port, rp->end_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_ALL_VIP_BOTH_PORTS_MULTIPLE_UNEQUAL, rp->start_port, rp->end_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            }
            break;
        }
    } else {
        switch (rp->protocol) {
        case CVY_TCP:
            if (rp->start_port == rp->end_port) {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_TCP_PORT_DISABLED, rp->virtual_ip_addr, rp->start_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_TCP_PORT_SINGLE, rp->virtual_ip_addr, rp->start_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_TCP_PORT_MULTIPLE_EQUAL, rp->virtual_ip_addr, rp->start_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_TCP_PORT_MULTIPLE_UNEQUAL, rp->virtual_ip_addr, rp->start_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            } else {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_TCP_PORTS_DISABLED, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_TCP_PORTS_SINGLE, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_TCP_PORTS_MULTIPLE_EQUAL, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_TCP_PORTS_MULTIPLE_UNEQUAL, rp->virtual_ip_addr, rp->start_port, rp->end_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            }
            break;
        case CVY_UDP:
            if (rp->start_port == rp->end_port) {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_UDP_PORT_DISABLED, rp->virtual_ip_addr, rp->start_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_UDP_PORT_SINGLE, rp->virtual_ip_addr, rp->start_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_UDP_PORT_MULTIPLE_EQUAL, rp->virtual_ip_addr, rp->start_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_UDP_PORT_MULTIPLE_UNEQUAL, rp->virtual_ip_addr, rp->start_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            } else {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_UDP_PORTS_DISABLED, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_UDP_PORTS_SINGLE, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_UDP_PORTS_MULTIPLE_EQUAL, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_UDP_PORTS_MULTIPLE_UNEQUAL, rp->virtual_ip_addr, rp->start_port, rp->end_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            }
            break;
        case CVY_TCP_UDP:
            if (rp->start_port == rp->end_port) {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_BOTH_PORT_DISABLED, rp->virtual_ip_addr, rp->start_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_BOTH_PORT_SINGLE, rp->virtual_ip_addr, rp->start_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_BOTH_PORT_MULTIPLE_EQUAL, rp->virtual_ip_addr, rp->start_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_BOTH_PORT_MULTIPLE_UNEQUAL, rp->virtual_ip_addr, rp->start_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            } else {
                switch (rp->mode) {
                case CVY_NEVER:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_BOTH_PORTS_DISABLED, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    break;
                case CVY_SINGLE:
                    dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_BOTH_PORTS_SINGLE, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    break;
                case CVY_MULTI:
                    if (rp->mode_data.multi.equal_load)
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_BOTH_PORTS_MULTIPLE_EQUAL, rp->virtual_ip_addr, rp->start_port, rp->end_port);
                    else
                        dwRet = FormPortRuleDescription(&description, IDS_PORT_RULE_VIP_BOTH_PORTS_MULTIPLE_UNEQUAL, rp->virtual_ip_addr, rp->start_port, rp->end_port);

                    if (!dwRet) 
                        break;

                    ASSERT(ASIZECCH(description.wszDescription) > wcslen(description.wszDescription));

                    switch (rp->mode_data.multi.affinity) {
                    case CVY_AFFINITY_NONE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_NONE));
                        break;
                    case CVY_AFFINITY_SINGLE:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_SINGLE));
                        break;
                    case CVY_AFFINITY_CLASSC:
                        (VOID) StringCchCat(description.wszDescription, ASIZECCH(description.wszDescription), SzLoadIds(IDS_PORT_RULE_AFFINITY_CLASSC));
                        break;
                    }
                    break;
                }
            }
            break;
        }
    }

    /* Set the port rule description text. */
    if (dwRet) 
    {
        ::SetDlgItemText(m_hWnd, IDC_TEXT_PORT_RULE_DESCR, description.wszDescription);
    }
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: OnButtonAdd
 * Description: Called when the user clicks the ADD button.
 */
LRESULT CDialogPorts::OnButtonAdd (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnButtonAdd\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        CDialogPortRule * portRuleDialog = NULL;
        
        /* Create a port rule properties dialog box.  The invalid index tells the dialog that this
           operation is an ADD, so it populates the dialog box with default values. */
        if (!(portRuleDialog = new CDialogPortRule(this, m_adwHelpIDs, WLBS_INVALID_PORT_RULE_INDEX))) {
            TraceMsg(L"CDialogPorts::OnButtonAdd Unable to allocate for ADD dialog\n");
            TRACE_CRIT("%!FUNC! memory allocation failed when creating a port rule properties dialog box");
            TRACE_VERB("<-%!FUNC!");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        
        /* Show the listbox.  If the user presses "OK", update the port rule list, otherwise ignore it. */
        if (portRuleDialog->DoModal() == IDOK)
            UpdateList(TRUE, FALSE, FALSE, &portRuleDialog->m_rule);
        
        /* Free the dialog box memory. */
        delete portRuleDialog;
        
        break;
    }
    
    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnButtonAdd
 * Description: Called when the user clicks the DELETE button.
 */
LRESULT CDialogPorts::OnButtonDel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnButtonDel\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Call UpdateList to DELETE a port rule. */
        UpdateList(FALSE, TRUE, FALSE, NULL);
        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnButtonAdd
 * Description: Called when the user clicks the EDIT button.
 */
LRESULT CDialogPorts::OnButtonModify (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::OnButtonModify\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        CDialogPortRule * portRuleDialog = NULL;
        int index;            

        /* Find the index of the currently selected port rule. */
        if ((index = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1) return 0;

        /* Create a port rule properties dialog box.  The index tells the dialog box which port rule
           is being modified, so the dialog can be populated with the configuration of that rule. */
        if (!(portRuleDialog = new CDialogPortRule(this, m_adwHelpIDs, index))) {
            TraceMsg(L"CDialogPorts::OnButtonModify Unable to allocate for MODIFY dialog\n");
            TRACE_CRIT("%!FUNC! memory allocation failed when creating a port rule properties dialog box");
            TRACE_VERB("<-%!FUNC!");
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        /* Show the listbox.  If the user presses "OK", update the port rule list, otherwise ignore it. */
        if (portRuleDialog->DoModal() == IDOK)
            UpdateList(FALSE, FALSE, TRUE, &portRuleDialog->m_rule);

        /* Free the dialog box memory. */
        delete portRuleDialog;

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: UpdateList
 * Description: Called when the user presses either ADD, MODIFY, or DELETE.  This function
 *              performs the appropriate function and error checking. 
 */
void CDialogPorts::UpdateList (BOOL add, BOOL del, BOOL modify, VALID_PORT_RULE * rulep) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::UpdateList\n");

    VALID_PORT_RULE * rp;
    LV_ITEM lvItem;
    int i;

    /* Find a slot for this rule in the array of port rules. */
    if (modify) {
        /* For a MODIFY, we put the rule in place of the one the user modified. */
        if ((i = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1)
        {
            TRACE_CRIT("%!FUNC! failure while looking up a port rule for modify");
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Fill in the information for this port rule. */
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the information about this port rule. */
        if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPorts::UpdateList MODIFY: Unable to retrieve item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox for modify", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Get the data pointer for this port rule. */
        if (!(rp = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPorts::UpdateList rule for item %d is bogus\n", i);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus in modify", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }
        
        /* Delete the obsolete rule from the listbox. */
        if (!ListView_DeleteItem(GetDlgItem(IDC_LIST_PORT_RULE), i)) {
            TraceMsg(L"CDialogPorts::UpdateList MODIFY: Unable to delete item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to delete item %d from listbox for modify", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Now that the new rule has been validated, copy it into the array of port rules. */
        CopyMemory((PVOID)rp, (PVOID)rulep, sizeof(VALID_PORT_RULE));
    } else if (add) {
        /* For an ADD, we have to find an "empty" place for the rule in the array. */
        for (i = 0; i < WLBS_MAX_RULES; i ++)
            /* Loop and break when we find the first invalid rule. */
            if (!(rp = m_rules + i)->valid) break;
        
        /* Make sure that somehow we haven't allowed too many rules. */
        ASSERT(i < WLBS_MAX_RULES);

        /* Now that the new rule has been validated, copy it into the array of port rules. */
        CopyMemory((PVOID)rp, (PVOID)rulep, sizeof(VALID_PORT_RULE));
    } else if (del) {
        /* For a DELETE, get the currently selected rule from the listbox. */
        if ((i = ListView_GetNextItem(GetDlgItem(IDC_LIST_PORT_RULE), -1, LVNI_SELECTED)) == -1)
        {
            TRACE_CRIT("%!FUNC! failure while looking up a port rule for delete");
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Fill in the information for this port rule. */
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the information about this port rule. */
        if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPorts::UpdateList DEL: Unable to retrieve item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox for delete", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Get the data pointer for this rule and invalidate the rule. */
        if (!(rp = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPorts::UpdateList rule for item %d is bogus\n", i);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus in delete", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }
        
        rp->valid = FALSE;
        
        /* Delete the obsolete rule from the listbox. */
        if (!ListView_DeleteItem(GetDlgItem(IDC_LIST_PORT_RULE), i)) {
            TraceMsg(L"CDialogPorts::UpdateList DEL: Unable to delete item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to delete item %d from listbox for delete", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        if (ListView_GetItemCount(GetDlgItem(IDC_LIST_PORT_RULE)) > i) {
            /* This was NOT the last (in order) port rule in the list, so highlight
               the port rule in the same position in the list box. */
            ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), i, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);        
        } else  if (ListView_GetItemCount(GetDlgItem(IDC_LIST_PORT_RULE)) > 0) {
            /* This was the last (in order) port rule in the list, so we highlight
               the rule "behind" us in the list - our position minus one. */
            ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), i - 1, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);        
        } else {
            /* This was the last port rule (by count), so disable DELETE and MODIFY. */
            ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), FALSE);
            ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), FALSE);            
        }

        /* Each time we DELETE a rule, we can enable the enable the ADD button, because we
           can be certain the room now exists for a new rule. */
        ::EnableWindow(GetDlgItem(IDC_BUTTON_ADD), TRUE);

        TRACE_INFO("%!FUNC! port rule deleted.");
        TRACE_VERB("<-%!FUNC!");
        return;
    } else
    {
        TRACE_CRIT("%!FUNC! unexpect action for port rule. Not an add, modify or delete.");
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    /* Create the rule and select it in the listbox. */
    CreateRule(TRUE, rp); 

    /* Whenever we ADD a rule, check to see whether we have to disable the ADD button
       (when we have reached the maximum number of rules, we can no longer allow ADDs. */
    if (add && (ListView_GetItemCount(GetDlgItem(IDC_LIST_PORT_RULE)) >= (int)m_paramp->dwMaxRules))
        ::EnableWindow(GetDlgItem(IDC_BUTTON_ADD), FALSE);
    TRACE_VERB("<-%!FUNC!");
}


/*
 * Method: InsertRule
 * Description: Determines where to insert a new rule into the listbox.
 */
int CDialogPorts::InsertRule (VALID_PORT_RULE * rulep) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::InsertRule\n");

    WCHAR buf[DIALOG_LIST_STRING_SIZE];
    WCHAR tmp[DIALOG_LIST_STRING_SIZE];
    int index;
    DWORD id, NewIpAddr;

    /* Determine sort field contents by column. */
    switch (m_sort_column) {
    case WLBS_VIP_COLUMN:
        /* Use the Vip & start port */
        NewIpAddr = htonl(IpAddressFromAbcdWsz(rulep->virtual_ip_addr));
        (VOID) StringCchPrintf(tmp, ASIZECCH(tmp), L"%5d", rulep->start_port);
        break;

    case WLBS_PORT_START_COLUMN:
        /* Use the start port. */
        (VOID) StringCchPrintf(tmp, ASIZECCH(tmp), L"%5d", rulep->start_port);
        
        break;
    case WLBS_PORT_END_COLUMN:
        /* Use the end port. */
        (VOID) StringCchPrintf(tmp, ASIZECCH(tmp), L"%5d", rulep->end_port);

        break;
    case WLBS_PROTOCOL_COLUMN:
        /* Find the protocol for this port rule. */
        switch (rulep->protocol) {
        case CVY_TCP:
            id = IDS_LIST_TCP;
            break;
        case CVY_UDP:
            id = IDS_LIST_UDP;
            break;
        case CVY_TCP_UDP:
            id = IDS_LIST_BOTH;
            break;
        default:
            id = IDS_LIST_BOTH;
        }
        
        /* Use the protocol. */
        (VOID) StringCchCopy(tmp, ASIZECCH(tmp), SzLoadIds(id));

        break;
    case WLBS_MODE_COLUMN:
        /* Find the mode for this port rule. */
        switch (rulep->mode) {
        case CVY_SINGLE:
            id = IDS_LIST_SINGLE;
            break;
        case CVY_MULTI:
            id = IDS_LIST_MULTIPLE;
            break;
        case CVY_NEVER:
            id = IDS_LIST_DISABLED;
            break;
        default:
            id = IDS_LIST_MULTIPLE;
        }            

        /* Use the mode. */
        (VOID) StringCchCopy(tmp, ASIZECCH(tmp), SzLoadIds(id));

        break;
    case WLBS_PRIORITY_COLUMN:
        /* In single host filtering, we use the priority.  If this rule does not use single host
           filtering, and therefore does not have a filtering priority, we insert at the end. */
        if (rulep->mode == CVY_SINGLE)
        {
            (VOID) StringCchPrintf(tmp, ASIZECCH(tmp), L"%2d", rulep->mode_data.single.priority);
        }
        else 
        {
            TRACE_VERB("<-%!FUNC!");
            return (int)m_paramp->dwMaxRules;
        }

        break;
    case WLBS_LOAD_COLUMN:
        /* In multiple host filtering, use the load, which can be "Equal" or an integer.  If this
           rule does not use multiple host filtering, and therefore does not have a load weight,
           we insert at the end. */
        if (rulep->mode == CVY_MULTI) {
            if (rulep->mode_data.multi.equal_load)
            {
                (VOID) StringCchCopy(tmp, ASIZECCH(tmp), SzLoadIds(IDS_LIST_EQUAL));
            }
            else
            {
                (VOID) StringCchPrintf(tmp, ASIZECCH(tmp), L"%3d", rulep->mode_data.multi.load);
            }
        } else
        {
            TRACE_VERB("<-%!FUNC!");
            return (int)m_paramp->dwMaxRules;
        }

        break;
    case WLBS_AFFINITY_COLUMN:
        /* Find the affinity for this port rule.  Rules that do not use multiple host filtering
           will not have an affinity setting - that's fine.  Ignore this here. */
        switch (rulep->mode_data.multi.affinity) {
        case CVY_AFFINITY_NONE:
            id = IDS_LIST_ANONE;
            break;
        case CVY_AFFINITY_SINGLE:
            id = IDS_LIST_ASINGLE;
            break;
        case CVY_AFFINITY_CLASSC:
            id = IDS_LIST_ACLASSC;
            break;
        default:
            id = IDS_LIST_ASINGLE;
        }

        /* In multiple host filtering, use the affinity.  If this port rule does not use multiple 
           host filtering, and therefore does not have an affinity, we insert at the end. */
        if (rulep->mode == CVY_MULTI)
        {
            (VOID) StringCchCopy(tmp, ASIZECCH(tmp), SzLoadIds(id));
        }
        else
        {
            TRACE_VERB("<-%!FUNC!");
            return (int)m_paramp->dwMaxRules;
        }

        break;
    }

    /* Loop through the listbox to find the place to insert the new rule, in port range order. */
    for (index = 0; index < ::SendDlgItemMessage(m_hWnd, IDC_LIST_PORT_RULE, LVM_GETITEMCOUNT, 0, 0); index ++) {
        LV_ITEM lvItem;
        DWORD CurIpAddr;
    
        /* Fill in the information to retrieve the corresponding list entry for the column
           by which we are sorting. */
        lvItem.iItem = index;
        lvItem.iSubItem = m_sort_column;
        lvItem.mask = LVIF_TEXT;
        lvItem.state = 0;
        lvItem.stateMask = 0;
        lvItem.pszText = buf;
        lvItem.cchTextMax = DIALOG_LIST_STRING_SIZE;

        /* Get the item from the listbox. */
        if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPorts::InsertRule Unable to retrieve item %d from listbox\n", index);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", index);
            TRACE_VERB("<-%!FUNC!");
            return (int)m_paramp->dwMaxRules;
        }

        // If the coolumn to sort on is VIP, get the vip in the list box
        if (m_sort_column == WLBS_VIP_COLUMN) {
            if (!wcscmp(lvItem.pszText, SzLoadIds(IDS_LIST_ALL_VIP)))
                CurIpAddr = htonl(IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP));
            else
                CurIpAddr = htonl(IpAddressFromAbcdWsz(lvItem.pszText));

            lvItem.iSubItem = WLBS_PORT_START_COLUMN;
            lvItem.pszText  = buf;
            /* Get the Start Port from the listbox. */
            if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
                TraceMsg(L"CDialogPorts::InsertRule Unable to retrieve start port for item %d from listbox\n", index);
                TRACE_CRIT("%!FUNC! unable to retrieve start port for item %d from listbox", index);
                TRACE_VERB("<-%!FUNC!");
                return (int)m_paramp->dwMaxRules;
            }
        }

        if (m_sort_order == WLBS_SORT_ASCENDING) {
            /* If the column subitem is empty, then we insert in front of it. */
            if (!wcscmp(lvItem.pszText, L"")) break;
            
            /* Compare IP Addresses as DWORDS for VIPs */
            /* If the VIP for this rule is "greater" than the new rule, then this is where we insert. */
            /* If the VIPs are equal and if the start port for this rule is greater than the new rule, then this
               is where we insert */
            if (m_sort_column == WLBS_VIP_COLUMN) 
            {
                if ((CurIpAddr > NewIpAddr) || ((CurIpAddr == NewIpAddr) && (wcscmp(lvItem.pszText, tmp) > 0))) 
                    break;
            }
            else // Other columns
            {
                if (wcscmp(lvItem.pszText, tmp) > 0) break;
            }
        } else if (m_sort_order == WLBS_SORT_DESCENDING) {
            /* Compare IP Addresses as DWORDS for VIPs */
            /* If the VIP for this rule is "less" than the new rule, then this is where we insert. */
            /* If the VIPs are equal and if the start port for this rule is greater than the new rule, then this
               is where we insert */
            if (m_sort_column == WLBS_VIP_COLUMN) 
            {
                if ((CurIpAddr < NewIpAddr) || ((CurIpAddr == NewIpAddr) && (wcscmp(lvItem.pszText, tmp) > 0))) 
                    break;
            }
            else // Other columns
            {
                if (wcscmp(lvItem.pszText, tmp) < 0) break;
            }
        }
    }

    TRACE_VERB("<-%!FUNC!");
    return index;
}

/*
 * Method: CreateRule
 * Description: Adds a rule to the port rule list box.
 */
void CDialogPorts::CreateRule (BOOL select, VALID_PORT_RULE * rulep) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::CreateRule\n");

    WCHAR buf[DIALOG_LIST_STRING_SIZE];
    WCHAR tmp[DIALOG_LIST_STRING_SIZE];
    LV_ITEM lvItem;
    DWORD id;
    int index;

    /* Find out at what index we are inserting into the listbox. */
    index = InsertRule(rulep);


    /* Insert the vip column, If Vip is "All Vip", insert the corresponding string, else insert the IP address */
    if (!lstrcmpi(rulep->virtual_ip_addr, CVY_DEF_ALL_VIP))
    {
        (VOID) StringCchCopy(buf, ASIZECCH(buf), SzLoadIds(IDS_LIST_ALL_VIP));
    }
    else
    {
        (VOID) StringCchCopy(buf, ASIZECCH(buf), rulep->virtual_ip_addr);
    }


    /* Fill in the information to insert this item into the list and set
       the lParam to the pointer for this port rule.  This makes it trivial
       to retrieve the port rule structure from the listbox later. */
    lvItem.iItem = index;
    lvItem.iSubItem = 0;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.pszText = buf;
    lvItem.lParam = (LPARAM)rulep;
    
    /* Insert this item into the list. */
    if ((index = ListView_InsertItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) == -1) {
        TraceMsg(L"CDialogPorts::CreateRule Unable to insert item into listbox\n");
        TRACE_CRIT("%!FUNC! unable to insert item into listbox");
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    (VOID) StringCchPrintf(buf, ASIZECCH(buf), L"%5d", rulep->start_port);

    /* Set the text associated with the start port subitem. */
    ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_PORT_START_COLUMN, buf);

    (VOID) StringCchPrintf(buf, ASIZECCH(buf), L"%5d", rulep->end_port);

    /* Set the text associated with the end port subitem. */
    ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_PORT_END_COLUMN, buf);

    /* Find the string table entry corresponding to the selected protocol. */
    switch (rulep->protocol) {
    case CVY_TCP:
        id = IDS_LIST_TCP;
        break;
    case CVY_UDP:
        id = IDS_LIST_UDP;
        break;
    case CVY_TCP_UDP:
        id = IDS_LIST_BOTH;
        break;
    default:
        id = IDS_LIST_BOTH;
    }

    (VOID) StringCchCopy(buf, ASIZECCH(buf), SzLoadIds(id));

    /* Set the text associated with the protocol subitem. */
    ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_PROTOCOL_COLUMN, buf);

    switch (rulep->mode) {
    case CVY_SINGLE:
        /* Single host filetering fills in only the mode and priority fields. */
        (VOID) StringCchCopy(buf, ASIZECCH(buf), SzLoadIds(IDS_LIST_SINGLE));
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_MODE_COLUMN, buf);

        (VOID) StringCchPrintf(buf, ASIZECCH(buf), L"%2d", rulep->mode_data.single.priority);
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_PRIORITY_COLUMN, buf);

        break;
    case CVY_MULTI:
        /* Find the appropriate string table entry for the affinity. */
        switch (rulep->mode_data.multi.affinity) {
        case CVY_AFFINITY_NONE:
            id = IDS_LIST_ANONE;
            break;
        case CVY_AFFINITY_SINGLE:
            id = IDS_LIST_ASINGLE;
            break;
        case CVY_AFFINITY_CLASSC:
            id = IDS_LIST_ACLASSC;
            break;
        default:
            id = IDS_LIST_ASINGLE;
        }

        /* Multiple host filtering fills in the mode, load, and affinity fields. */
        (VOID) StringCchCopy(buf, ASIZECCH(buf), SzLoadIds(IDS_LIST_MULTIPLE));
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_MODE_COLUMN, buf);
            
        if (rulep->mode_data.multi.equal_load) {
            (VOID) StringCchCopy(buf, ASIZECCH(buf), SzLoadIds(IDS_LIST_EQUAL));
                
            /* Set the text associated with this subitem. */
            ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_LOAD_COLUMN, buf);
        } else {
            (VOID) StringCchPrintf(buf, ASIZECCH(buf), L"%3d", rulep->mode_data.multi.load);

            /* Set the text associated with this subitem. */
            ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_LOAD_COLUMN, buf);
        }

        (VOID) StringCchCopy(buf, ASIZECCH(buf), SzLoadIds(id));
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_AFFINITY_COLUMN, buf);

        break;
    case CVY_NEVER:
        /* Disabled filtering only fills in the mode field. */
        (VOID) StringCchCopy(buf, ASIZECCH(buf), SzLoadIds(IDS_LIST_DISABLED));
            
        /* Set the text associated with this subitem. */
        ListView_SetItemText(GetDlgItem(IDC_LIST_PORT_RULE), index, WLBS_MODE_COLUMN, buf);

        break;
    }

    if (select) {
        /* Select the first item in the port rule list. */
        ListView_SetItemState(GetDlgItem(IDC_LIST_PORT_RULE), index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);        
        ListView_EnsureVisible(GetDlgItem(IDC_LIST_PORT_RULE), index, TRUE);

        /* If we select a port rule in the list, we should enable the MODIFY and REMOVE buttons. */
        ::EnableWindow(GetDlgItem(IDC_BUTTON_DEL), TRUE);
        ::EnableWindow(GetDlgItem(IDC_BUTTON_MODIFY), TRUE);
    }
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the port rule settings.
 */
void CDialogPorts::SetInfo() {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::SetInfo\n");

    VALID_PORT_RULE * rp;
    DWORD i;

    /* Empty the port rule memory. */
    memset(m_rules, 0, sizeof(m_rules));

    /* Get rid of all rules in the list box. */
    if (!ListView_DeleteAllItems(GetDlgItem(IDC_LIST_PORT_RULE))) {
        TraceMsg(L"CDialogPorts::SetInfo Unable to delete all items from listbox\n");
        TRACE_CRIT("%!FUNC! unable to delete all items from listbox");
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    /* Re-insert all port rules. */
    for (i = 0; i < m_paramp->dwNumRules; i ++) {
        *(NETCFG_WLBS_PORT_RULE *)&m_rules[i] = m_paramp->port_rules[i];

        /* Validate the port rule. */
        rp = m_rules + i;
        rp->valid = TRUE;

        /* Call CreateRule to insert the rule into the list. */
        CreateRule(FALSE, m_rules + i);
    }

    /* Mark the listbox rules as valid. */
    m_rulesValid = TRUE;
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: UpdateInfo
 * Description: Called to copy the UI state to the port rule configuration.
 */
void CDialogPorts::UpdateInfo() {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPorts::UpdateInfo\n");

    VALID_PORT_RULE * rulep;
    DWORD i;

    /* If the rules are invalid, i.e. the listbox does not currently reflect the actual
       state of the port rules, then bail out. */
    if (!m_rulesValid)
    {
        TRACE_INFO("%!FUNC! rules are invalid and can't be processed");
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    /* Empty the port rule memory. */
    memset(m_paramp->port_rules, 0, sizeof(m_paramp->port_rules));

    /* Set the number of port rules to the number of entries in the listbox. */
    m_paramp->dwNumRules = ListView_GetItemCount(GetDlgItem(IDC_LIST_PORT_RULE));

    /* For each rule, retrieve the data pointer and store it. */
    for (i = 0; i < m_paramp->dwNumRules; i++) {
        LV_ITEM lvItem;

        /* Fill in the information necessary to retrive the port rule data pointer. */
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the listbox item information. */
        if (!ListView_GetItem(GetDlgItem(IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPorts::UpdateInfo Unable to retrieve item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Get the data pointer for this port rule. */
        if (!(rulep = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPorts::UpdateInfo rule for item %d is bogus\n", i);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus", i);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Make sure the port rule is valid.  This should never happen because invalid
           rules are not added to the list!!!. */
        if (!rulep->valid) {
            TraceMsg(L"CDialogPorts::UpdateInfo Rule %d invalid\n", i);
            TRACE_CRIT("%!FUNC! invalid rule %d will be skipped", i);
            continue;
        }

        /* Store the valid port rule. */
        m_paramp->port_rules[i] = *(NETCFG_WLBS_PORT_RULE *)rulep;
    }

    /* Mark the listbox rules as invalid. */
    m_rulesValid = FALSE;
    TRACE_VERB("<-%!FUNC!");
}

#if DBG
/*
 * Function: TraceMsg
 * Description: Generate a trace or error message.
 */
void TraceMsg(PCWSTR pszFormat, ...) {
    static WCHAR szTempBufW[4096];
    static CHAR szTempBufA[4096];

    va_list arglist;

    va_start(arglist, pszFormat);

    (VOID) StringCchVPrintf(szTempBufW, ASIZECCH(szTempBufW), pszFormat, arglist);

    /* Convert the WCHAR to CHAR. This is for backward compatability with TraceMsg 
       so that it was not necessary to change all pre-existing calls thereof. */
    if (WideCharToMultiByte(CP_ACP, 0, szTempBufW, -1, szTempBufA, ASIZECCH(szTempBufA), NULL, NULL) != 0)
    {
        /* Traced messages are now sent through the netcfg TraceTag routine so that 
           they can be turned on/off dynamically. */
        TraceTag(ttidWlbs, szTempBufA);
    }

    va_end(arglist);
}
#endif

/*
 * Method: CDialogPortRule
 * Description: The class constructor.
 */
CDialogPortRule::CDialogPortRule (CDialogPorts * parent, const DWORD * adwHelpIDs, int index) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::CDialogPortRule\n");

    m_adwHelpIDs = adwHelpIDs;
    m_index = index;
    m_parent = parent;

    ZeroMemory(&m_IPFieldChangeState, sizeof(m_IPFieldChangeState));
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: ~CDialogPortRule
 * Description: The class destructor.
 */
CDialogPortRule::~CDialogPortRule () {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CDialogPortRule::~CDialogPortRule\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the port rule properties dialog.
 */
LRESULT CDialogPortRule::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnInitDialog\n");

    RECT rect;

    /* Position this window with the upper-left corner matching the upper left corner
       of the port rule list box in the parent window.  Simply for consistency. */
    ::GetWindowRect(::GetDlgItem(m_parent->m_hWnd, IDC_LIST_PORT_RULE), &rect);
    SetWindowPos(NULL, rect.left, rect.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

    /* Limit the field ranges for the port rule properties. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_START, EM_SETLIMITTEXT, 5, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_END, EM_SETLIMITTEXT, 5, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_MULTI, EM_SETLIMITTEXT, 3, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_SINGLE, EM_SETLIMITTEXT, 2, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_SINGLE, UDM_SETRANGE32, CVY_MIN_MAX_HOSTS, CVY_MAX_MAX_HOSTS);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_MULTI, UDM_SETRANGE32, CVY_MIN_LOAD, CVY_MAX_LOAD);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_START, UDM_SETRANGE32, CVY_MIN_PORT, CVY_MAX_PORT);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_END, UDM_SETRANGE32, CVY_MIN_PORT, CVY_MAX_PORT);

    /* Limit the zeroth field of the cluster IP address between 1 and 223. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, IPM_SETRANGE, 0, (LPARAM)MAKEIPRANGE(WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH));

    /* Invalidate the rule.  The validity will be checked upon clicking "OK". */
    m_rule.valid = FALSE;

    /* Populate the UI with the current configuration. */
    SetInfo();

    /* Set the cursor to be the arrow.  For some reason, if we don't do this, then the cursor 
       will remain an hourglass until the mouse moves over any UI element.  Probably need to
       call CPropertPage constructor to fix this? */
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CDialogPortRule::OnContextMenu (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CDialogPortRule::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnOk
 * Description: Called when the user clicks "OK".
 */
LRESULT CDialogPortRule::OnOk (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnOk\n");

    BOOL fSuccess = FALSE;
    DWORD IPAddr;

    /* If "All" is Checked, then, initialize with CVY_ALL_VIP_STRING */
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP) == BST_CHECKED) 
    {
        (VOID) StringCchCopy(m_rule.virtual_ip_addr, ASIZECCH(m_rule.virtual_ip_addr), CVY_DEF_ALL_VIP);
    }
    else // UnChecked
    {
        /* Check for Blank Virtual IP Address */
        if (::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_PORT_RULE_VIP), IPM_ISBLANK, 0, 0)) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_VIP_BLANK, MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            /* An error occurred. */
            TRACE_CRIT("%!FUNC! No virtual IP address provided for a port rule");
            TRACE_VERB("<-%!FUNC!");
            return PSNRET_INVALID;
        }

        /* Get the Virtual IP address as a string and DWORD. */
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)m_rule.virtual_ip_addr);
        ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, IPM_GETADDRESS, 0, (LPARAM)&IPAddr);

        /* Make sure that the first octet is not zero.  If it is, make it 1 and alter the user. */
        if (!FIRST_IPADDRESS(IPAddr)) {
            /* Make the first octet 1 instead of the erroneous 0. */
            IPAddr = IPAddr | (DWORD)(WLBS_IP_FIELD_ZERO_LOW << 24);

            /* Set the IP address and update our cluster IP address string. */
            ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, IPM_SETADDRESS, 0, (LPARAM)IPAddr);
            //::SendDlgItemMessage(m_hWnd, IDC_EDIT_PORT_RULE_VIP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)m_rule.virtual_ip_addr);
      
            /* Alert the user. */
            PrintIPRangeError(IDS_PARM_CL_IP_FIELD, 0, WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH);

            TRACE_CRIT("%!FUNC! invalid first octect value for IP address");
            TRACE_VERB("<-%!FUNC!");
            return PSNRET_INVALID;
        }
    }
    
    /* Find out which protocol has been selected. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_TCP))
        m_rule.protocol = CVY_TCP;
    else if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_UDP))
        m_rule.protocol = CVY_UDP;
    else
        m_rule.protocol = CVY_TCP_UDP;
        
    /* Get the start port for this rule. */
    m_rule.start_port = ::GetDlgItemInt(m_hWnd, IDC_EDIT_START, &fSuccess, FALSE); 

    /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
       string to an integer. This allows us to check for empty fields, assuming that because
       we otherwise limit the user input to digits, there will be no errors of any other type. */
    if (!fSuccess) {
        /* Alert the user. */
        PrintRangeError(IDS_PARM_PORT_BLANK, CVY_MIN_PORT, CVY_MAX_PORT);

        /* Return the focus to the erred entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_START));

        TRACE_CRIT("%!FUNC! no start port value provided");
        TRACE_VERB("<-%!FUNC!");
        return 0; 
    }

    /* Get the end port for this rule. */
    m_rule.end_port = ::GetDlgItemInt(m_hWnd, IDC_EDIT_END, &fSuccess, FALSE); 

    /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
       string to an integer. This allows us to check for empty fields, assuming that because
       we otherwise limit the user input to digits, there will be no errors of any other type. */
    if (!fSuccess) {
        /* Alert the user. */
        PrintRangeError(IDS_PARM_PORT_BLANK, CVY_MIN_PORT, CVY_MAX_PORT);

        /* Return the focus to the erred entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_END));

        TRACE_CRIT("%!FUNC! no end port value provided");
        TRACE_VERB("<-%!FUNC!");
        return 0;                      
    }

    /* Make sure that the start port value falls within the valid range. */
    if (/* m_rule.start_port < CVY_MIN_PORT || */ m_rule.start_port > CVY_MAX_PORT) {
        /* Alert the user. */
        PrintRangeError(IDS_PARM_PORT_VAL, CVY_MIN_PORT, CVY_MAX_PORT);

        /* Force the start port to fall into the range, effectively helping the user. */
        /* CVY_CHECK_MIN(m_rule.start_port, CVY_MIN_PORT); */
        CVY_CHECK_MAX(m_rule.start_port, CVY_MAX_PORT);

        /* Set the start port to the now valid entry. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_START, m_rule.start_port, FALSE);

        /* Return the focus to the erred entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_START));

        TRACE_CRIT("%!FUNC! invalid start port value");
        TRACE_VERB("<-%!FUNC!");
        return 0;
    }

    /* Make sure that the end port value falls within the valid range. */
    if (/* m_rule.end_port < CVY_MIN_PORT || */ m_rule.end_port > CVY_MAX_PORT) {
        /* Alert the user. */
        PrintRangeError(IDS_PARM_PORT_VAL, CVY_MIN_PORT, CVY_MAX_PORT);

        /* Force the end port to fall into the range, effectively helping the user. */
        /* CVY_CHECK_MIN(m_rule.end_port, CVY_MIN_PORT); */
        CVY_CHECK_MAX(m_rule.end_port, CVY_MAX_PORT);

        /* Set the end port to the now valid entry. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, m_rule.end_port, FALSE);

        /* Return the focus to the erred entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_END));

        TRACE_CRIT("%!FUNC! invalid end port value");
        TRACE_VERB("<-%!FUNC!");
        return 0;
    }

    /* Retrieve the filtering mode settings. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_SINGLE)) {
        /* The user has selected single host filtering. */
        m_rule.mode = CVY_SINGLE;

        /* Get the handling priority. */
        m_rule.mode_data.single.priority = ::GetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, &fSuccess, FALSE); 

        /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
           string to an integer. This allows us to check for empty fields, assuming that because
           we otherwise limit the user input to digits, there will be no errors of any other type. */
        if (!fSuccess) {
            /* Alert the user. */
            PrintRangeError(IDS_PARM_HPRI_BLANK, CVY_MIN_PRIORITY, CVY_MAX_PRIORITY);

            /* Return the focus to the erred entry. */
            ::SetFocus(GetDlgItem(IDC_EDIT_SINGLE));

            TRACE_CRIT("%!FUNC! a handling priority is required but was not provided");
            TRACE_VERB("<-%!FUNC!");
            return 0;                          
        }

        /* Make sure that the handling priority falls within the valid range. */
        if (m_rule.mode_data.single.priority > CVY_MAX_PRIORITY || m_rule.mode_data.single.priority < CVY_MIN_PRIORITY) {
            /* Alert the user. */
            PrintRangeError(IDS_PARM_SINGLE, CVY_MIN_PRIORITY, CVY_MAX_PRIORITY);

            /* Force the handling priority to fall into the range, effectively helping the user. */
            CVY_CHECK_MIN(m_rule.mode_data.single.priority, CVY_MIN_PRIORITY);
            CVY_CHECK_MAX(m_rule.mode_data.single.priority, CVY_MAX_PRIORITY);

            /* Set the handling priority to the now valid entry. */
            ::SetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, m_rule.mode_data.single.priority, FALSE);

            /* Return the focus to the erred entry. */
            ::SetFocus(GetDlgItem(IDC_EDIT_SINGLE));

            TRACE_CRIT("%!FUNC! an invalid handling priority was provided");
            TRACE_VERB("<-%!FUNC!");
            return 0;
        }
    } else if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTIPLE)) {
        /* The user has selected multiple host filtering. */
        m_rule.mode = CVY_MULTI;

        if (::IsDlgButtonChecked (m_hWnd, IDC_CHECK_EQUAL)) {
            /* If the users has chosen equal load, then note this fact. */
            m_rule.mode_data.multi.equal_load = TRUE;
        } else {
            /* Otherwise, they have specified a specific load weight. */
            m_rule.mode_data.multi.equal_load = FALSE;

            /* Get the load weight. */
            m_rule.mode_data.multi.load = ::GetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, &fSuccess, FALSE); 

            /* The error code from GetDlgItemInt() indicates an error converting the alphanumeric 
               string to an integer. This allows us to check for empty fields, assuming that because
               we otherwise limit the user input to digits, there will be no errors of any other type. */
            if (!fSuccess) {
                /* Alert the user. */
                PrintRangeError(IDS_PARM_LOAD_BLANK, CVY_MIN_LOAD, CVY_MAX_LOAD);

                /* Return the focus to the erred entry. */
                ::SetFocus(GetDlgItem(IDC_EDIT_MULTI));

                TRACE_CRIT("%!FUNC! a load weight is required but was not provided");
                TRACE_VERB("<-%!FUNC!");
                return 0;                    
            }

            /* Make sure that the load weight falls within the valid range. */
            if (/* m_rule.mode_data.multi.load < CVY_MIN_LOAD || */ m_rule.mode_data.multi.load > CVY_MAX_LOAD) {
                /* Alert the user. */
                PrintRangeError(IDS_PARM_LOAD, CVY_MIN_LOAD, CVY_MAX_LOAD);

                /* Force the load weight to fall into the range, effectively helping the user. */
                /* CVY_CHECK_MIN(m_rule.mode_data.multi.load, CVY_MIN_LOAD); */
                CVY_CHECK_MAX(m_rule.mode_data.multi.load, CVY_MAX_LOAD);

                /* Set the load weight to the now valid entry. */
                ::SetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, m_rule.mode_data.multi.load, FALSE);

                /* Return the focus to the erred entry. */
                ::SetFocus(GetDlgItem(IDC_EDIT_MULTI));

                TRACE_CRIT("%!FUNC! an invalid load weight was provided");
                TRACE_VERB("<-%!FUNC!");
                return 0;
            }
        }

        /* Find out which affinity setting has been selected. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_AFF_CLASSC))
            m_rule.mode_data.multi.affinity = CVY_AFFINITY_CLASSC;
        else if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_AFF_SINGLE))
            m_rule.mode_data.multi.affinity = CVY_AFFINITY_SINGLE;
        else
            m_rule.mode_data.multi.affinity = CVY_AFFINITY_NONE;

    } else {
        /* The user has selected no filtering (disabled). */
        m_rule.mode = CVY_NEVER;
    }

    /* Validate the rule.  If it is invalid, just bail out. */
    if (!ValidateRule(&m_rule, (m_index != WLBS_INVALID_PORT_RULE_INDEX) ? FALSE : TRUE))
    {
        TRACE_CRIT("%!FUNC! rule validation failed");
        TRACE_VERB("<-%!FUNC!");
        return 0;
    }

    /* If we get here, then the rule is valid. */
    m_rule.valid = TRUE;

    /* Close the dialog and note that the user clicked "OK". */
    EndDialog(IDOK);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: ValidateRule
 * Description: Check a port rule for validity, including enforcing the non-overlap of port ranges.
 */
BOOL CDialogPortRule::ValidateRule (VALID_PORT_RULE * rulep, BOOL self_check) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::ValidateRule\n");

    VALID_PORT_RULE * rp;
    int i, index, count;

    /* If the user has actually specified a virtual IP address for this port rule, 
       make sure its not the same as the dedicated IP address from the host tab. */
    if (lstrcmpi(rulep->virtual_ip_addr, CVY_DEF_ALL_VIP)) {
        /* Verify that the virtual ip address is not the same as the dip */
        if (IpAddressFromAbcdWsz(rulep->virtual_ip_addr) == IpAddressFromAbcdWsz(m_parent->m_paramp->ded_ip_addr)) 
        {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_VIP_CONFLICT_DIP, MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            /* Return focus to the invalid entry. */
            ::SetFocus(GetDlgItem(IDC_EDIT_PORT_RULE_VIP));
            
            /* Invalidate the rule. */
            rulep->valid = FALSE;
            
            TRACE_CRIT("%!FUNC! virtual IP address and dedicated IP address are the same: %ls", rulep->virtual_ip_addr);
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }
    }

    /* Make sure that the end port is greater than or equal to the start port. */
    if (rulep->start_port > rulep->end_port) {
        TRACE_CRIT("%!FUNC! start port %d is greater than end port %d", rulep->start_port, rulep->end_port);
        /* If the end port is less than the start port, generate an error and set the 
           value of the erroneous end port to the value of the start port. */
        rulep->end_port = rulep->start_port;
        
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_RANGE,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        
        /* Populate the UI with the new (conforming) end port value. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, rulep->end_port, FALSE);
        
        /* Return focus to the invalid entry. */
        ::SetFocus(GetDlgItem(IDC_EDIT_END));

        /* Invalidate the rule. */
        rulep->valid = FALSE;

        TRACE_VERB("<-%!FUNC!");
        return FALSE;
    }

    /* Find out how many rules are currently in the listbox. */
    count = ListView_GetItemCount(::GetDlgItem(m_parent->m_hWnd, IDC_LIST_PORT_RULE));

    for (i = 0; i < count; i ++) {
        LV_ITEM lvItem;

        /* If this is a MODIFY operation, do not check against ourselves */
        if (!self_check && (i == m_index)) continue;

        /* Fill in the information necessary to retrieve the port rule data pointer. */
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the item from the listbox. */
        if (!ListView_GetItem(::GetDlgItem(m_parent->m_hWnd, IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPortRule::ValidateRule Unable to retrieve item %d from listbox\n", i);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", i);
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }

        /* Get the data pointer for the i'th port rule in the list. */
        if (!(rp = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPortRule::ValidateRule rule for item %d is bogus\n", i);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus", i);
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }

        /* Make sure the port rule is valid.  This should never happen because invalid
           rules are not added to the list!!!. */
        if (!rp->valid) {
            TraceMsg(L"CDialogPortRule::ValidateRule Rule %d invalid\n", i);
            TRACE_VERB("%!FUNC! rule %d invalid and will be skipped", i);
            continue;
        }

        /* Check for overlapping port ranges. */
        if ((IpAddressFromAbcdWsz(rulep->virtual_ip_addr) == IpAddressFromAbcdWsz(rp->virtual_ip_addr)) 
        && (((rulep->start_port < rp->start_port) && (rulep->end_port >= rp->start_port)) ||
            ((rulep->start_port >= rp->start_port) && (rulep->start_port <= rp->end_port)))) {
            /* Alert the user. */
            NcMsgBox(::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_OVERLAP,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            /* Set the listbox selection to be the conflicting rule. */
            ::SendDlgItemMessage(m_hWnd, IDC_LIST_PORT_RULE, LB_SETCURSEL, i, 0);
            
            /* Return focus to the invalid entry. */
            ::SetFocus(GetDlgItem(IDC_EDIT_START));

            /* Invalidate the rule. */
            rulep->valid = FALSE;

            TRACE_CRIT("%!FUNC! a port rule overlaps with the port range of another rule and will be rejected");
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }
    }

    TRACE_VERB("<-%!FUNC!");
    return TRUE;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CDialogPortRule::OnCancel (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnCancel\n");

    /* Close the dialog and note that the user clicked "Cancel". */
    EndDialog(IDCANCEL);

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: PrintIPRangeError
 * Description: Displays a message box warning the user of an out-of-range entry in 
 *              an IP address octet.
 */
void CDialogPortRule::PrintIPRangeError (unsigned int ids, int value, int low, int high) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::PrintIPRangeError\n");

    WCHAR szCurrent[12];  // size = sign + n,nnn,nnn,nnn + null-terminator
    WCHAR szLow[12];
    WCHAR szHigh[12];

    /* Fill in the allowed range and the offending value. */
    StringCchPrintf(szHigh   , ASIZECCH(szHigh)   , L"%d", high);
    StringCchPrintf(szCurrent, ASIZECCH(szCurrent), L"%d", value);
    StringCchPrintf(szLow    , ASIZECCH(szLow)    , L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szCurrent, szLow, szHigh);
    TRACE_CRIT("%!FUNC! an IP address octect with value %ls is out of range", szCurrent);
    TRACE_VERB("<-%!FUNC!");
}


/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the cluster IP address changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CDialogPortRule::OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnIpFieldChange\n");

    LPNMIPADDRESS Ip;
    int low, high;

    Ip = (LPNMIPADDRESS)pnmh;
        
    switch(idCtrl) {
    case IDC_EDIT_PORT_RULE_VIP:
        /* Field zero of the cluster IP address has different limits. */
        if (!Ip->iField) {
            low = WLBS_IP_FIELD_ZERO_LOW;
            high = WLBS_IP_FIELD_ZERO_HIGH;
        }        
        else {
            low = WLBS_FIELD_LOW;
            high = WLBS_FIELD_HIGH;
        }
        /* The notifier may call us twice for the same change, so we have to do the bookkeeping to make 
           sure we only alert the user once.  Use static variables to keep track of our state.  This will 
           allow us to ignore duplicate alerts. */
        if ((m_IPFieldChangeState.IpControl != Ip->hdr.idFrom) || (m_IPFieldChangeState.Field != Ip->iField) || 
            (m_IPFieldChangeState.Value != Ip->iValue) || (m_IPFieldChangeState.RejectTimes > 0)) {
            m_IPFieldChangeState.RejectTimes = 0;
            m_IPFieldChangeState.IpControl = (UINT)(Ip->hdr.idFrom);
            m_IPFieldChangeState.Field = Ip->iField;
            m_IPFieldChangeState.Value = Ip->iValue;
            
            /* Check the field value against its limits. */
            if ((Ip->iValue != WLBS_FIELD_EMPTY) && ((Ip->iValue < low) || (Ip->iValue > high))) {
                /* Alert the user. */
                PrintIPRangeError(IDS_PARM_CL_IP_FIELD, Ip->iValue, low, high);
                TRACE_CRIT("%!FUNC! IP address or subnet mask are not valid and will be rejected");
            }
        } else m_IPFieldChangeState.RejectTimes++;
        
        break;
    default:

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}


/*
 * Method: OnCheckRct
 * Description: Called when the user checks/unchecks the remote control enabled checkbox.
 */
LRESULT CDialogPortRule::OnCheckPortRuleAllVip (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnCheckPortRuleAllVip\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
         /* If the All Vip box is checked, grey out the IP control, Else brighten the IP control */
         if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP)) 
         {
             ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_PORT_RULE_VIP), FALSE);
         }
         else
         {
             ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_PORT_RULE_VIP), TRUE);
         }
         break;
    }
    
    TRACE_VERB("<-%!FUNC!");
    return 0;
}



/*
 * Method: OnCheckEqual
 * Description: Called when the user checks/unchecks the equal load weight checkbox.
 */
LRESULT CDialogPortRule::OnCheckEqual (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnCheckEqual\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* If equal has been checked, then disable the load weight entry box and spin control.  */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_EQUAL)) {
            ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), FALSE);
            ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), FALSE);
        } else {
            /* Otherwise, enable them. */
            ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), TRUE);
            ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), TRUE);
        }

        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: OnRadioMode
 * Description: Called when the user changes the radio button selection for the filtering mode.
 */
LRESULT CDialogPortRule::OnRadioMode (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL & fHandled) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::OnRadioMode\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Call ModeSwitch to enable/disable UI entities appropriately based on 
           the currently selected filtering mode. */
        ModeSwitch();
        break;
    }

    TRACE_VERB("<-%!FUNC!");
    return 0;
}

/*
 * Method: PrintRangeError
 * Description: Displays a message box warning the user of an out-of-range entry.
 */
void CDialogPortRule::PrintRangeError (unsigned int ids, int low, int high) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::PrintRangeError\n");

    WCHAR szLow[12];  // size = sign + n,nnn,nnn,nnn + null-terminator
    WCHAR szHigh[12];

    /* Fill in the allowed range and the offending value. */
    StringCchPrintf(szHigh, ASIZECCH(szHigh), L"%d", high);
    StringCchPrintf(szLow , ASIZECCH(szLow) , L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(m_hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szLow, szHigh);
    TRACE_VERB("->%!FUNC!");
}

/*
 * Method: ModeSwitch
 * Description: Called when the user changes the filtering mode. 
 */
VOID CDialogPortRule::ModeSwitch () {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::ModeSwitch\n");

    if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_SINGLE)) {
        /* If single host filtering was selected, then turn on all controls for 
           single host and turn off all controls for multiple host. */
        ::EnableWindow(GetDlgItem(IDC_EDIT_SINGLE), TRUE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_SINGLE), TRUE);
        ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), FALSE);
        ::EnableWindow(GetDlgItem(IDC_CHECK_EQUAL), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_NONE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_CLASSC), FALSE);
    } else if (::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTIPLE)) {
        /* If multiple host filtering was selected, then turn on all controls for
           multiple host and turn off all controls for single host. */
        ::EnableWindow(GetDlgItem(IDC_EDIT_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_CHECK_EQUAL), TRUE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_NONE), TRUE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_SINGLE), TRUE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_CLASSC), TRUE);

        /* Turn the load weight entry on/off depending on the value of the 
           equal load weight checkbox. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_EQUAL)) {
            ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), FALSE);
            ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), FALSE);
        } else {
            ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), TRUE);
            ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), TRUE);
        }
    } else {
        /* Otherwise, if disabled was selected, then turn off all controls for
           both multiple host and single host. */
        ::EnableWindow(GetDlgItem(IDC_EDIT_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_EDIT_MULTI), FALSE);
        ::EnableWindow(GetDlgItem(IDC_SPIN_MULTI), FALSE);
        ::EnableWindow(GetDlgItem(IDC_CHECK_EQUAL), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_NONE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_SINGLE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_RADIO_AFF_CLASSC), FALSE);
    }
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the port rule settings.
 */
void CDialogPortRule::SetInfo() {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CDialogPortRule::SetInfo\n");

    VALID_PORT_RULE * rulep = NULL;
    DWORD addr[4];

    if (m_index != WLBS_INVALID_PORT_RULE_INDEX) {
        LV_ITEM lvItem;

        /* Fill in the information necessary to retrieve the port rule data pointer. */
        lvItem.iItem = m_index;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_PARAM;
        lvItem.state = 0;
        lvItem.stateMask = 0;

        /* Get the item from the listbox. */
        if (!ListView_GetItem(::GetDlgItem(m_parent->m_hWnd, IDC_LIST_PORT_RULE), &lvItem)) {
            TraceMsg(L"CDialogPortRule::SetInfo Unable to retrieve item %d from listbox\n", m_index);
            TRACE_CRIT("%!FUNC! unable to retrieve item %d from listbox", m_index);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Get the data pointer for the i'th port rule in the list. */
        if (!(rulep = (VALID_PORT_RULE*)lvItem.lParam)) {
            TraceMsg(L"CDialogPortRule::SetInfo rule for item %d is bogus\n", m_index);
            TRACE_CRIT("%!FUNC! rule for item %d is bogus\n", m_index);
            TRACE_VERB("<-%!FUNC!");
            return;
        }

        /* Make sure the port rule is valid.  This should never happen because invalid
           rules are not added to the list!!!. */
        if (!rulep->valid) {
            TraceMsg(L"CDialogPortRule::SetInfo Rule %d invalid\n", m_index);
            TRACE_CRIT("%!FUNC! rule %d invalid\n", m_index);
            TRACE_VERB("<-%!FUNC!");
            return;
        }        

        /* If the cluster IP address is CVY_ALL_VIP_STRING, grey out the ip control and check the All Vip box, 
           Else, fill in the IP address in the IP control and uncheck the All Vip box  */

        if (!lstrcmpi(rulep->virtual_ip_addr, CVY_DEF_ALL_VIP)) 
        {
           /* Grey out IP Control */
           ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_PORT_RULE_VIP), FALSE);

           /* Check the All Vip checkbox */
           ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_CHECKED);
        }
        else
        {
            /* Extract the IP address octects from the IP address string. */ 
            GetIPAddressOctets(rulep->virtual_ip_addr, addr);
            ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_PORT_RULE_VIP), IPM_SETADDRESS, 0, (LPARAM)MAKEIPADDRESS(addr[0], addr[1], addr[2], addr[3]));

            /* UnCheck the All Vip checkbox */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_UNCHECKED);
        }

        /* Set the start and end port values for this rule. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_START, rulep->start_port, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, rulep->end_port, FALSE);
        
        /* Check the protocol and filtering mode radio buttons appropriately. */
        ::CheckRadioButton(m_hWnd, IDC_RADIO_TCP, IDC_RADIO_BOTH,
                           IDC_RADIO_TCP + rulep->protocol - CVY_MIN_PROTOCOL);
        ::CheckRadioButton(m_hWnd, IDC_RADIO_SINGLE, IDC_RADIO_DISABLED,
                           IDC_RADIO_SINGLE + rulep->mode - CVY_MIN_MODE);
        
        /* Set the default values for filtering mode parameters.  Below, we
           overwrite the ones for the specific filtering mode for this rule. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, CVY_DEF_PRIORITY, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, CVY_DEF_LOAD, FALSE);
        ::CheckDlgButton(m_hWnd, IDC_CHECK_EQUAL, CVY_DEF_EQUAL_LOAD);
        ::CheckRadioButton(m_hWnd, IDC_RADIO_AFF_NONE, IDC_RADIO_AFF_CLASSC,
                           IDC_RADIO_AFF_NONE + CVY_DEF_AFFINITY - CVY_MIN_AFFINITY);
        
        switch (rulep -> mode) {
        case CVY_SINGLE:
            /* In sinlge host filtering, the only user parameter is the priority for this host. */
            ::SetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, rulep->mode_data.single.priority, FALSE);
        
        break;
        case CVY_MULTI:
            /* In multiple host filtering, we need to set the affinity and load weight. */
            ::CheckRadioButton(m_hWnd, IDC_RADIO_AFF_NONE, IDC_RADIO_AFF_CLASSC,
                               IDC_RADIO_AFF_NONE + rulep->mode_data.multi.affinity);
        
        if (rulep->mode_data.multi.equal_load) {
            /* If this rule uses equal load, then check the equal checkbox. */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_EQUAL, TRUE);
        } else {
            /* If this rule has a specific load weight, then uncheck the equal
               checkbox and set the load value. */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_EQUAL, FALSE);
            ::SetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, rulep->mode_data.multi.load, FALSE);
        }

        break;
        default:
            /* If the mode is DISABLED, then do nothing. */
            break;
        }
    } else {

        /* Grey out IP Control */
        ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_PORT_RULE_VIP), FALSE);

        /* Check the All Vip checkbox */
        ::CheckDlgButton(m_hWnd, IDC_CHECK_PORT_RULE_ALL_VIP, BST_CHECKED);

        /* Check the radio buttons with their default settings. */
        ::CheckRadioButton(m_hWnd, IDC_RADIO_TCP, IDC_RADIO_BOTH,
                           IDC_RADIO_TCP + CVY_DEF_PROTOCOL - CVY_MIN_PROTOCOL);
        ::CheckRadioButton(m_hWnd, IDC_RADIO_AFF_NONE, IDC_RADIO_AFF_CLASSC,
                           IDC_RADIO_AFF_NONE + CVY_DEF_AFFINITY - CVY_MIN_AFFINITY);
        ::CheckRadioButton(m_hWnd, IDC_RADIO_SINGLE, IDC_RADIO_DISABLED,
                           IDC_RADIO_SINGLE + CVY_DEF_MODE - CVY_MIN_MODE);
        
        /* Check/uncheck the equal load checkbox. */
        ::CheckDlgButton(m_hWnd, IDC_CHECK_EQUAL, CVY_DEF_EQUAL_LOAD);
        
        /* Fill in the entry boxes with their default values. */
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_START, CVY_DEF_PORT_START, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, CVY_DEF_PORT_END, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_SINGLE, CVY_DEF_PRIORITY, FALSE);
        ::SetDlgItemInt(m_hWnd, IDC_EDIT_MULTI, CVY_DEF_LOAD, FALSE);
    }

    /* Call ModeSwitch to enable and disable UI entries as appropriate, based 
       the the filtering mode currently selected. */
    ModeSwitch();
    TRACE_VERB("<-%!FUNC!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\netcfgconfig.cpp ===
//+----------------------------------------------------------------------------
//
// File:         netcfgconfig.cpp
//
// Module:       
//
// Description: Implement class CNetcfgCluster and class CWlbsConfig
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:       fengsun Created    3/2/00
//
//+----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#define ENABLE_PROFILE

#include <winsock2.h>
#include <windows.h>
#include <clusapi.h>
#include "debug.h"
#include "netcon.h"
#include "ncatlui.h"
#include "ndispnp.h"
#include "ncsetup.h"
#include "netcfgn.h"
#include "afilestr.h"

#include "help.h"
#include "resource.h"
#include "ClusterDlg.h"
#include "host.h"
#include "ports.h"
#include "wlbsparm.h"
#include "wlbsconfig.h"
#include "wlbscfg.h"
#include <time.h>
#include "netcfgcluster.h"
#include "license.h"

#include <strsafe.h>

#include "utils.h"
#include "netcfgconfig.tmh"
#include "log_msgs.h"

/* For IPSec notification that NLB is bound to at least one adapter in this host. */
#include "winipsec.h"

#define NETCFG_WLBS_ID L"ms_wlbs"

typedef DWORD (CALLBACK* LPFNGNCS)(LPCWSTR,DWORD*);

// Used by Netsetup and Component's who's answer file references AdapterSections
static const WCHAR c_szAdapterSections[] = L"AdapterSections";

void WlbsToNetcfgConfig(const WlbsApiFuncs* pApiFuncs, const WLBS_REG_PARAMS* pWlbsConfig, NETCFG_WLBS_CONFIG* pBNetcfgConfig);

void RemoveAllPortRules(PWLBS_REG_PARAMS reg_data);

HRESULT ParamReadAnswerFile(CSetupInfFile& caf, PCWSTR answer_sections, WLBS_REG_PARAMS* paramp);

bool WriteAdapterName(CWlbsConfig* pConfig, GUID& AdapterGuid);

/* 353752 - Persist host state across reboots, etc.  This function creates the key that holds the state
   on bind and defaults its initial value to the host properties TAB dropdown list (ClusterModeOnStart). */
bool WriteHostStateRegistryKey (CWlbsConfig * pConfig, GUID & AdapterGuid, ULONG State);

/* Notify IPSec of the NLB presence.  Typically this is done via an RPC call to the IPSec service;
   if the service is unavailable, this function attempts to manually create/modify the appropriate
   registry settings. */
bool WriteIPSecNLBRegistryKey (DWORD dwNLBSFlags);

bool ValidateVipInRule(const PWCHAR pwszRuleString, const WCHAR pwToken, DWORD& dwVipLen);

#if DBG
static void TraceMsg(PCWSTR pszFormat, ...);
#else
#define TraceMsg NOP_FUNCTION
#define DbgDumpBindPath NOP_FUNCTION
#endif

//
// Function pointers to avoid link with wlbsctrl.dll
//
bool WINAPI ParamReadReg(const GUID& AdaperGuid, PWLBS_REG_PARAMS reg_data, bool fUpgradeFromWin2k = false, bool *pfPortRulesInBinaryForm = NULL);
typedef bool (WINAPI* ParamReadRegFUNC)(const GUID& AdaperGuid, PWLBS_REG_PARAMS reg_data, bool fUpgradeFromWin2k /*= false*/, bool *pfPortRulesInBinaryForm /*= NULL*/);

bool  WINAPI ParamWriteReg(const GUID& AdaperGuid, PWLBS_REG_PARAMS reg_data);
typedef bool (WINAPI* ParamWriteRegFUNC)(const GUID& AdaperGuid, PWLBS_REG_PARAMS reg_data);

bool  WINAPI ParamDeleteReg(const GUID& AdaperGuid, bool fDeleteObsoleteEntries = false);
typedef bool (WINAPI* ParamDeleteRegFUNC)(const GUID& AdaperGuid, bool fDeleteObsoleteEntries /*= false*/);

DWORD  WINAPI ParamSetDefaults(PWLBS_REG_PARAMS    reg_data);
typedef DWORD (WINAPI* ParamSetDefaultsFUNC)(PWLBS_REG_PARAMS    reg_data);

bool  WINAPI RegChangeNetworkAddress(const GUID& AdapterGuid, const WCHAR* mac_address, BOOL fRemove);
typedef bool(WINAPI* RegChangeNetworkAddressFUNC) (const GUID& AdapterGuid, const WCHAR* mac_address, BOOL fRemove);

void  WINAPI NotifyAdapterAddressChangeEx(const WCHAR* pszPnpDevNodeId, const GUID& AdapterGuid, bool bWaitAndQuery);
typedef void (WINAPI* NotifyAdapterAddressChangeExFUNC)(const WCHAR* pszPnpDevNodeId, const GUID& AdapterGuid, bool bWaitAndQuery);

DWORD WINAPI WlbsAddPortRule(PWLBS_REG_PARAMS reg_data, PWLBS_PORT_RULE rule);
typedef DWORD (WINAPI* WlbsAddPortRuleFUNC)(PWLBS_REG_PARAMS reg_data, PWLBS_PORT_RULE rule);

DWORD WINAPI WlbsSetRemotePassword(PWLBS_REG_PARAMS reg_data, const WCHAR* password);
typedef DWORD (WINAPI* WlbsSetRemotePasswordFUNC)(const PWLBS_REG_PARAMS reg_data, const WCHAR* password);

DWORD WINAPI WlbsEnumPortRules(PWLBS_REG_PARAMS reg_data, PWLBS_PORT_RULE rules, PDWORD num_rules);
typedef DWORD (WINAPI* WlbsEnumPortRulesFUNC)(PWLBS_REG_PARAMS reg_data, PWLBS_PORT_RULE rules, PDWORD num_rules);

DWORD WINAPI NotifyDriverConfigChanges(HANDLE hDeviceWlbs, const GUID& AdapterGuid);
typedef DWORD (WINAPI* NotifyDriverConfigChangesFUNC)(HANDLE hDeviceWlbs, const GUID& AdapterGuid);

HKEY WINAPI RegOpenWlbsSetting(const GUID& AdapterGuid, bool fReadOnly);
typedef HKEY (WINAPI* RegOpenWlbsSettingFUNC)(const GUID& AdapterGuid, bool fReadOnly);


struct WlbsApiFuncs {
    ParamReadRegFUNC pfnParamReadReg;
    ParamWriteRegFUNC pfnParamWriteReg;
    ParamDeleteRegFUNC pfnParamDeleteReg;
    ParamSetDefaultsFUNC pfnParamSetDefaults;
    RegChangeNetworkAddressFUNC pfnRegChangeNetworkAddress;
    NotifyAdapterAddressChangeExFUNC pfnNotifyAdapterAddressChangeEx;
    WlbsAddPortRuleFUNC pfnWlbsAddPortRule;
    WlbsSetRemotePasswordFUNC pfnWlbsSetRemotePassword;
    WlbsEnumPortRulesFUNC pfnWlbsEnumPortRules;
    NotifyDriverConfigChangesFUNC pfnNotifyDriverConfigChanges;
    RegOpenWlbsSettingFUNC pfnRegOpenWlbsSetting;
};

//+----------------------------------------------------------------------------
//
// Function:  LoadWlbsCtrlDll
//
// Description:  Load wlbsctrl.dll and get all function pointers
//
// Arguments: WlbsApiFuncs* pFuncs - 
//
// Returns:   HINSTANCE - wlbsctrl.dll handle
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
HINSTANCE LoadWlbsCtrlDll(WlbsApiFuncs* pFuncs) {

    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"LoadWlbsCtrlDll");

    ASSERT(pFuncs);

    HINSTANCE hDll;
    DWORD dwStatus = 0;
    hDll = LoadLibrary(L"wlbsctrl.dll");

    if (hDll == NULL) {
        dwStatus = GetLastError();
        TraceError("Failed to load wlbsctrl.dll", dwStatus);
        TRACE_CRIT("%!FUNC! Could not load wlbsctrl.dll with %d", dwStatus);
        TRACE_VERB("<-%!FUNC!");
        return NULL;
    }

    pFuncs->pfnParamReadReg = (ParamReadRegFUNC)GetProcAddress(hDll, "ParamReadReg");
    pFuncs->pfnParamWriteReg = (ParamWriteRegFUNC)GetProcAddress(hDll, "ParamWriteReg");
    pFuncs->pfnParamDeleteReg = (ParamDeleteRegFUNC)GetProcAddress(hDll, "ParamDeleteReg");
    pFuncs->pfnParamSetDefaults = (ParamSetDefaultsFUNC)GetProcAddress(hDll, "ParamSetDefaults");
    pFuncs->pfnRegChangeNetworkAddress = (RegChangeNetworkAddressFUNC)GetProcAddress(hDll, "RegChangeNetworkAddress");
    pFuncs->pfnNotifyAdapterAddressChangeEx = (NotifyAdapterAddressChangeExFUNC)GetProcAddress(hDll, "NotifyAdapterAddressChangeEx");
    pFuncs->pfnWlbsAddPortRule = (WlbsAddPortRuleFUNC)GetProcAddress(hDll, "WlbsAddPortRule");
    pFuncs->pfnWlbsSetRemotePassword = (WlbsSetRemotePasswordFUNC)GetProcAddress(hDll, "WlbsSetRemotePassword");
    pFuncs->pfnWlbsEnumPortRules = (WlbsEnumPortRulesFUNC)GetProcAddress(hDll, "WlbsEnumPortRules");
    pFuncs->pfnNotifyDriverConfigChanges = (NotifyDriverConfigChangesFUNC)GetProcAddress(hDll, "NotifyDriverConfigChanges");
    pFuncs->pfnRegOpenWlbsSetting = (RegOpenWlbsSettingFUNC)GetProcAddress(hDll, "RegOpenWlbsSetting");

    ASSERT (pFuncs->pfnParamReadReg != NULL); 
    ASSERT (pFuncs->pfnParamWriteReg != NULL); 
    ASSERT (pFuncs->pfnParamDeleteReg != NULL);
    ASSERT (pFuncs->pfnParamSetDefaults != NULL);
    ASSERT (pFuncs->pfnRegChangeNetworkAddress != NULL);
    ASSERT (pFuncs->pfnNotifyAdapterAddressChangeEx != NULL);
    ASSERT (pFuncs->pfnWlbsAddPortRule != NULL);
    ASSERT (pFuncs->pfnWlbsSetRemotePassword != NULL);
    ASSERT (pFuncs->pfnWlbsEnumPortRules != NULL);
    ASSERT (pFuncs->pfnNotifyDriverConfigChanges != NULL);
    ASSERT (pFuncs->pfnRegOpenWlbsSetting != NULL);

    if (pFuncs->pfnParamReadReg == NULL ||
        pFuncs->pfnParamWriteReg == NULL||
        pFuncs->pfnParamDeleteReg == NULL||
        pFuncs->pfnParamSetDefaults == NULL||
        pFuncs->pfnRegChangeNetworkAddress == NULL||
        pFuncs->pfnNotifyAdapterAddressChangeEx == NULL||
        pFuncs->pfnWlbsAddPortRule == NULL||
        pFuncs->pfnWlbsSetRemotePassword == NULL||
        pFuncs->pfnWlbsEnumPortRules == NULL||
        pFuncs->pfnNotifyDriverConfigChanges == NULL ||
        pFuncs->pfnRegOpenWlbsSetting == NULL) {

        dwStatus = GetLastError();
        TraceError("LoadWlbsCtrlDll GetProcAddress failed %d", dwStatus);
        TRACE_CRIT("%!FUNC! GetProcAddress failed %d", dwStatus);

        FreeLibrary(hDll);
        TRACE_VERB("<-%!FUNC!");
        
        return NULL;
    }

    TRACE_VERB("<-%!FUNC!");

    return hDll;
}

// Maximum characters in an IP address string of the form a.b.c.d
const DWORD MAXIPSTRLEN = 20;

void TransformOldPortRulesToNew(PWLBS_OLD_PORT_RULE  p_old_port_rules,
                                PWLBS_PORT_RULE      p_new_port_rules, 
                                DWORD                num_rules)
{
    TRACE_VERB("->%!FUNC!");
    if (num_rules == 0)
    {
        TRACE_INFO("%!FUNC! No port rules");
        TRACE_VERB("<-%!FUNC!");
        return;
    }
            
    while(num_rules--)
    {
        (VOID) StringCchCopy(p_new_port_rules->virtual_ip_addr, ASIZECCH(p_new_port_rules->virtual_ip_addr), CVY_DEF_ALL_VIP);
        p_new_port_rules->start_port      = p_old_port_rules->start_port;
        p_new_port_rules->end_port        = p_old_port_rules->end_port;
 #ifdef WLBSAPI_INTERNAL_ONLY
        p_new_port_rules->code            = p_old_port_rules->code;
 #else
        p_new_port_rules->Private1        = p_old_port_rules->Private1;
 #endif
        p_new_port_rules->mode            = p_old_port_rules->mode;
        p_new_port_rules->protocol        = p_old_port_rules->protocol;

 #ifdef WLBSAPI_INTERNAL_ONLY
        p_new_port_rules->valid           = p_old_port_rules->valid;
 #else
        p_new_port_rules->Private2        = p_old_port_rules->Private2;
 #endif
        switch (p_new_port_rules->mode) 
        {
        case CVY_MULTI :
             p_new_port_rules->mode_data.multi.equal_load = p_old_port_rules->mode_data.multi.equal_load;
             p_new_port_rules->mode_data.multi.affinity   = p_old_port_rules->mode_data.multi.affinity;
             p_new_port_rules->mode_data.multi.load       = p_old_port_rules->mode_data.multi.load;
             break;
        case CVY_SINGLE :
             p_new_port_rules->mode_data.single.priority  = p_old_port_rules->mode_data.single.priority;
             break;
        default:
             break;
        }
        p_old_port_rules++;
        p_new_port_rules++;
    }

    TRACE_VERB("<-%!FUNC!");

    return;
}

/* Initialize static data members of CNetcfgCluster */
bool CNetcfgCluster::m_fMSCSWarningEventLatched = false;
bool CNetcfgCluster::m_fMSCSWarningPopupLatched = false;

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::CNetcfgCluster
//
// Description:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
CNetcfgCluster::CNetcfgCluster(CWlbsConfig* pConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::CNetcfgCluster");

    m_fHasOriginalConfig = false;
    m_fMacAddrChanged = false;
    m_fReloadRequired = false;
    m_fRemoveAdapter = false;
    m_fOriginalBindingEnabled = false;
    m_fReenableAdapter = false;

    ZeroMemory(&m_AdapterGuid, sizeof(m_AdapterGuid));

    ASSERT(pConfig);
    
    m_pConfig = pConfig;
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::~CNetcfgCluster
//
// Description:  
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
CNetcfgCluster::~CNetcfgCluster() {
    TRACE_VERB("<->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::~CNetcfgCluster");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::InitializeFromRegistry
//
// Description:  Read the cluster settings from registry
//
// Arguments: const GUID& guidAdapter - 
//
// Returns:   DWORD - Win32 Error
//
// History:   fengsun Created Header    2/13/00
//
//+----------------------------------------------------------------------------
DWORD CNetcfgCluster::InitializeFromRegistry(const GUID& guidAdapter, bool fBindingEnabled, bool fUpgradeFromWin2k) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::InitializeFromRegistry");

    bool fPortRulesInBinaryForm = false;

    ASSERT(m_fHasOriginalConfig == false);

    m_fHasOriginalConfig = true;
    m_fOriginalBindingEnabled = fBindingEnabled;
    m_AdapterGuid = guidAdapter;

    if (!m_pConfig->m_pWlbsApiFuncs->pfnParamReadReg(m_AdapterGuid, &m_OriginalConfig, fUpgradeFromWin2k, &fPortRulesInBinaryForm))
    {
        TRACE_VERB("%!FUNC! error reading settings from the registry"); // This is verbose because this is invoked for non-NLB adapters too.
        TRACE_VERB("<-%!FUNC!");
        return ERROR_CANTREAD;
    }
    
    /* Force a write at apply. */
    if (fUpgradeFromWin2k || fPortRulesInBinaryForm)
    {
        m_fHasOriginalConfig = false;  
        TRACE_INFO("%!FUNC! upgrading from win2k or port rules are in binary form");
    }

    CopyMemory(&m_CurrentConfig, &m_OriginalConfig, sizeof(m_CurrentConfig));

    TRACE_VERB("<-%!FUNC!");
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::InitializeFromAnswerFile
//
// Description:  Read cluster settings from answer file
//
// Arguments: PCWSTR answer_file - 
//            PCWSTR answer_sections - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    2/13/00
//
//+----------------------------------------------------------------------------
HRESULT CNetcfgCluster::InitializeFromAnswerFile(const GUID& AdapterGuid, CSetupInfFile& caf, PCWSTR answer_sections) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::InitializeFromAnswerFile");

    /* Setup with the default values first. */
    InitializeWithDefault(AdapterGuid);

    HRESULT hr = ParamReadAnswerFile(caf, answer_sections, &m_CurrentConfig);

    if (FAILED(hr)) {
        TRACE_CRIT("%!FUNC! failed CNetcfgCluster::ParamReadAnswerFile failed. returned: %d", hr);
        TraceError("CNetcfgCluster::InitializeFromAnswerFile failed at ParamReadAnswerFile", hr);
    }

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::InitializeWithDefault
//
// Description:  Set the cluster settings to default
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/13/00
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::InitializeWithDefault(const GUID& guidAdapter) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::InitializeWithDefault");

    time_t cur_time;

    ASSERT(m_fHasOriginalConfig == false);

    m_fHasOriginalConfig = false;

    m_pConfig->m_pWlbsApiFuncs->pfnParamSetDefaults(&m_CurrentConfig); // Always returns WLBS_OK

    // time() returns a 64-bit value on ia64 and 32-bit value on x86.
    // We store this value in the registry and we do not want to 
    // change the type of this value from DWORD this late in the release
    // cycle. So, we are going to care only about the lower 4 bytes returned 
    // by time().
    // -KarthicN, 05/17/02
    m_CurrentConfig.install_date = (DWORD) time(& cur_time);

    // JosephJ 11/00 -- We used to call License_stamp to set this value,
    //                  but that was a holdover from convoy days.
    //                  We no longer use this field.
    //
    m_CurrentConfig.i_verify_date = 0;

    m_AdapterGuid = guidAdapter;
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::SetConfig
//
// Description:  SetConfig caches the settings without saving to registry            
//               and can be retrieved by GetConfig.
//
// Arguments: const NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::SetConfig(const NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::SetConfig");

    DWORD dwStatus = WLBS_OK; // Used for tracing output

    ASSERT(pClusterConfig != NULL);

    m_CurrentConfig.host_priority = pClusterConfig->dwHostPriority;
    m_CurrentConfig.rct_enabled = pClusterConfig->fRctEnabled ;
    m_CurrentConfig.cluster_mode = pClusterConfig->dwInitialState;
    m_CurrentConfig.persisted_states = pClusterConfig->dwPersistedStates;
    m_CurrentConfig.mcast_support = pClusterConfig->fMcastSupport;
    m_CurrentConfig.fIGMPSupport = pClusterConfig->fIGMPSupport;
    m_CurrentConfig.fIpToMCastIp = pClusterConfig->fIpToMCastIp;

    (VOID) StringCchCopy(m_CurrentConfig.szMCastIpAddress, ASIZECCH(m_CurrentConfig.szMCastIpAddress), pClusterConfig->szMCastIpAddress);
    (VOID) StringCchCopy(m_CurrentConfig.cl_mac_addr     , ASIZECCH(m_CurrentConfig.cl_mac_addr)     , pClusterConfig->cl_mac_addr);
    (VOID) StringCchCopy(m_CurrentConfig.cl_ip_addr      , ASIZECCH(m_CurrentConfig.cl_ip_addr)      , pClusterConfig->cl_ip_addr);
    (VOID) StringCchCopy(m_CurrentConfig.cl_net_mask     , ASIZECCH(m_CurrentConfig.cl_net_mask)     , pClusterConfig->cl_net_mask);
    (VOID) StringCchCopy(m_CurrentConfig.ded_ip_addr     , ASIZECCH(m_CurrentConfig.ded_ip_addr)     , pClusterConfig->ded_ip_addr);
    (VOID) StringCchCopy(m_CurrentConfig.ded_net_mask    , ASIZECCH(m_CurrentConfig.ded_net_mask)    , pClusterConfig->ded_net_mask);
    (VOID) StringCchCopy(m_CurrentConfig.domain_name     , ASIZECCH(m_CurrentConfig.domain_name)     , pClusterConfig->domain_name);

    if (pClusterConfig->fChangePassword)
    {
        dwStatus = m_pConfig->m_pWlbsApiFuncs->pfnWlbsSetRemotePassword(&m_CurrentConfig, (WCHAR*)pClusterConfig->szPassword);
        if (WLBS_OK != dwStatus)
        {
            TRACE_CRIT("%!FUNC! set password failed with return code = %d", dwStatus);
        }
    }

    RemoveAllPortRules(&m_CurrentConfig);

    for (DWORD i=0; i<pClusterConfig->dwNumRules; i++) {
        WLBS_PORT_RULE PortRule;
        
        ZeroMemory(&PortRule, sizeof(PortRule));

        (VOID) StringCchCopy(PortRule.virtual_ip_addr, ASIZECCH(PortRule.virtual_ip_addr), pClusterConfig->port_rules[i].virtual_ip_addr);
        PortRule.start_port = pClusterConfig->port_rules[i].start_port;
        PortRule.end_port = pClusterConfig->port_rules[i].end_port;
        PortRule.mode = pClusterConfig->port_rules[i].mode;
        PortRule.protocol = pClusterConfig->port_rules[i].protocol;

        if (PortRule.mode == WLBS_AFFINITY_SINGLE) {
            PortRule.mode_data.single.priority = 
            pClusterConfig->port_rules[i].mode_data.single.priority;
        } else {
            PortRule.mode_data.multi.equal_load = 
            pClusterConfig->port_rules[i].mode_data.multi.equal_load;
            PortRule.mode_data.multi.affinity = 
            pClusterConfig->port_rules[i].mode_data.multi.affinity;
            PortRule.mode_data.multi.load = 
            pClusterConfig->port_rules[i].mode_data.multi.load;
        }

        PortRule.valid = TRUE;
        
        CVY_RULE_CODE_SET(&PortRule);

        dwStatus = m_pConfig->m_pWlbsApiFuncs->pfnWlbsAddPortRule( &m_CurrentConfig, &PortRule );
        if (WLBS_OK != dwStatus)
        {
            TRACE_CRIT("%!FUNC! add port rule failed with return code = %d", dwStatus);
        }

    }

    
    (VOID) StringCchCopy(m_CurrentConfig.bda_teaming.team_id, ASIZECCH(m_CurrentConfig.bda_teaming.team_id), pClusterConfig->bda_teaming.team_id);

    m_CurrentConfig.bda_teaming.active = pClusterConfig->bda_teaming.active;
    m_CurrentConfig.bda_teaming.master = pClusterConfig->bda_teaming.master;
    m_CurrentConfig.bda_teaming.reverse_hash = pClusterConfig->bda_teaming.reverse_hash;

    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::GetConfig
//
// Description:  Get the config, which could be cached by SetConfig call
//
// Arguments: NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::GetConfig(NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::GetConfig");

    ASSERT(pClusterConfig != NULL);

    WlbsToNetcfgConfig(m_pConfig->m_pWlbsApiFuncs, &m_CurrentConfig, pClusterConfig);
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::NotifyBindingChanges
//
// Description:  Notify binding changes
//
// Arguments: DWORD dwChangeFlag - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/13/00
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::NotifyBindingChanges(DWORD dwChangeFlag, INetCfgBindingPath* pncbp) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::NotifyBindingChanges");

    ASSERT(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    if (dwChangeFlag & NCN_ADD) { m_fRemoveAdapter = false; }

    if ((dwChangeFlag & NCN_ENABLE) && !m_fMSCSWarningPopupLatched)
    {
        HINSTANCE hDll = LoadLibrary(L"clusapi.dll");
        if (NULL != hDll)
        {
            LPFNGNCS pfnGetNodeClusterState = (LPFNGNCS) GetProcAddress(hDll, "GetNodeClusterState");

            if (NULL != pfnGetNodeClusterState)
            {
                /* Warn the user via a pop-up if we detect MSCS is installed, but allow the NLB install to proceed. */
                DWORD dwClusterState = 0;
                if (ERROR_SUCCESS == pfnGetNodeClusterState(NULL, &dwClusterState))
                {
                    if (ClusterStateNotRunning == dwClusterState || ClusterStateRunning == dwClusterState)
                    {
                        NcMsgBox(::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_MSCS_INSTALLED,
                                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
                        m_fMSCSWarningPopupLatched = true;
                        TRACE_INFO("%!FUNC! Cluster Service is installed");
                        TraceMsg(L"CNetcfgCluster::NotifyBindingChanges Cluster Service is installed.");
                    } else { /* MSCS is not installed. That's good! */ }
                } else {
                    TRACE_CRIT("%!FUNC! error determining if MSCS is installed.");
                    TraceMsg(L"CNetcfgCluster::NotifyBindingChanges error getting MSCS status.");
                }
            }
            else
            {
                TRACE_CRIT("%!FUNC! Get function address for GetNodeClusterState in clusapi.dll failed with %d", GetLastError());
            }

            if (!FreeLibrary(hDll))
            {
                TRACE_CRIT("%!FUNC! FreeLibrary for clusapi.dll failed with %d", GetLastError());
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! Load clusapi.dll failed with %d", GetLastError());
        }
    }

    if (dwChangeFlag & NCN_REMOVE) { m_fRemoveAdapter = true; }
    TRACE_VERB("<-%!FUNC!");
}

/*
 * Function: CNetcfgCluster::NotifyAdapter
 * Description: Notify an adapter of a state change
 * Author: shouse 6.1.00
 */
DWORD CNetcfgCluster::NotifyAdapter (INetCfgComponent * pAdapter, DWORD newStatus) {
    TRACE_VERB("->%!FUNC!");
    HRESULT hr = S_OK;
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;
    PWSTR pszPnpDevNodeId;

    switch (newStatus) {
        case DICS_PROPCHANGE: 
            TraceMsg(L"##### CWLBS::HrNotifyAdapter: Reload the adapter\n");
            break;
        case DICS_DISABLE:
            TraceMsg(L"##### CWLBS::HrNotifyAdapter: Disable the adapter\n");
            break;
        case DICS_ENABLE:
            TraceMsg(L"##### CWLBS::HrNotifyAdapter: Enable the adapter\n");
            break;
        default:
            TRACE_CRIT("%!FUNC! Invalid Notification 0x%x", newStatus);
            TraceMsg(L"##### CWLBS::HrNotifyAdapter: Invalid Notification 0x%x\n", newStatus);
            return ERROR_INVALID_PARAMETER;                              
    }

    if ((hr = HrSetupDiCreateDeviceInfoList(& GUID_DEVCLASS_NET, NULL, &hdi)) == S_OK) {
        if ((hr = pAdapter->GetPnpDevNodeId (& pszPnpDevNodeId)) == S_OK) {
            if ((hr = HrSetupDiOpenDeviceInfo (hdi, pszPnpDevNodeId, NULL, 0, &deid)) == S_OK) {
                if ((hr = HrSetupDiSendPropertyChangeNotification (hdi, & deid, newStatus, DICS_FLAG_GLOBAL, 0)) == S_OK) {
                    TraceMsg(L"##### CWLBS::HrNotifyAdapter notified NIC\n");
                } else {
                    TRACE_CRIT("%!FUNC! error %x in HrSetupDiSendPropertyChangeNotification", hr);
                    TraceMsg(L"##### CWLBS::HrNotifyAdapter error %x in HrSetupDiSendPropertyChangeNotification\n", hr);
                }
            } else {
                TRACE_CRIT("%!FUNC! error %x in HrSetupDiOpenDeviceInfo", hr);
                TraceMsg(L"##### CWLBS::HrNotifyAdapter error %x in HrSetupDiOpenDeviceInfo\n", hr);
            }
        } else {
            TRACE_CRIT("%!FUNC! error %x in GetPnpDevNodeId", hr);
            TraceMsg(L"##### CWLBS::HrNotifyAdapter error %x in GetPnpDevNodeId\n", hr);
        }
        
        SetupDiDestroyDeviceInfoList (hdi);
    } else {
        TRACE_CRIT("%!FUNC! error %x in HrSetupDiCreateDeviceInfoList for Change: 0x%x", hr, newStatus);
        TraceMsg(L"##### CWLBS::HrNotifyAdapter error %x in HrSetupDiCreateDeviceInfoList for Change: 0x%x\n", newStatus);
    }

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::ApplyRegistryChanges
//
// Description:  Apply registry changes
//
// Arguments: None
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
DWORD CNetcfgCluster::ApplyRegistryChanges(bool fUninstall) {
    TRACE_VERB("->%!FUNC!");
    HRESULT hr = S_OK;
    DWORD dwStatus = 0;

    m_fReenableAdapter = false;
    m_fReloadRequired = false;

    /* Uninstall WLBS or remove the adapter. */
    if (fUninstall || m_fRemoveAdapter) {
        if (m_fHasOriginalConfig &&m_OriginalConfig.mcast_support == false ) {
            /* If we were in unicast mode, remove the mac, and reload Nic driver upon PnP. */
            if (fUninstall) {
                INetCfgComponent * pAdapter = NULL;
                
                /* If the adapter is enabled, disable it when the MAC address changes.  This prevents a
                   switch from learning a MAC address due to ARPs that TCP/IP sends out before WLBS is
                   enabled and able to spoof the source MAC. The NIC will be re-enabled in ApplyPnpChanges(). */
                if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) == S_OK) {
                    ULONG status = 0UL;
                    
                    /* Only disable the adapter if the adapter is currently enabled and NLB was initially 
                       (in this netcfg session) bound to the adapter. */
                    if (m_fOriginalBindingEnabled) {
                        if ((hr = pAdapter->GetDeviceStatus(&status)) == S_OK) {
                            if (status != CM_PROB_DISABLED) {
                                m_fReenableAdapter = true;
                                m_fReloadRequired = false;
                                TRACE_INFO("%!FUNC! disable adapter");
                                dwStatus = NotifyAdapter(pAdapter, DICS_DISABLE);
                                if (!SUCCEEDED(dwStatus))
                                {
                                    TRACE_CRIT("%!FUNC! disable the adapter for NLB uninstall or adapter remove failed with %d", dwStatus);
                                } else
                                {
                                    TRACE_INFO("%!FUNC! disable the adapter for NLB uninstall or adapter remove succeeded");
                                }

                            }
                        }
                    }

                    pAdapter->Release();
                    pAdapter = NULL;
                }

                m_fMacAddrChanged = true;
            }

            /*  remove mac addr, */
            if (m_pConfig->m_pWlbsApiFuncs->pfnRegChangeNetworkAddress(m_AdapterGuid, m_OriginalConfig.cl_mac_addr, true) == false) {
                dwStatus = GetLastError();
                TraceError("CWlbsCluster::WriteConfig failed at RegChangeNetworkAddress", dwStatus);
                TRACE_CRIT("<-%!FUNC! failed removing MAC address with %d", dwStatus);
            }
        }

        m_pConfig->m_pWlbsApiFuncs->pfnParamDeleteReg(m_AdapterGuid, false); 

        TRACE_INFO("<-%!FUNC! Exiting on success removing adapter or uninstalling NLB");
        TRACE_VERB("<-%!FUNC!");
        return ERROR_SUCCESS;
    }

    /* Find out whether the adapter is bound to NLB. */
    INetCfgComponent* pAdapter = NULL;
    bool fCurrentBindingEnabled;
//    bool fOriginalMacAddrSet;
    bool fCurrentMacAddrSet;
    bool fAdapterDisabled = false; // Assuming that Adapter is NOT disabled

    if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) != S_OK) {
        fCurrentBindingEnabled = false;
    } else {
        ULONG status = 0UL;
        fCurrentBindingEnabled = (m_pConfig->IsBoundTo(pAdapter) == S_OK);
        if ((hr = pAdapter->GetDeviceStatus(&status)) == S_OK) {
            TRACE_INFO("%!FUNC! device status is 0x%x", status);
            if (status == CM_PROB_DISABLED) 
            {
                fAdapterDisabled = true;           
            }
        }
        else
        {  
            TRACE_CRIT("%!FUNC! GetDeviceStatus failed with 0x%x, Assuming that adapter is NOT disabled", hr);
        }
        pAdapter->Release();
        pAdapter = NULL;
    }

    // Note: make sure to call ParamWriteReg before early exit. Needed in case
    // upgrading to build where new reg keys are introduced

    // The m_fHasOriginalConfig flag will be false if 
    // 1. Bind NLB for the first time
    // 2. Clean Installs with NLB info in Answer file
    // 3. Upgrade from NT 4 or Win 2k or XP with Port Rules in Binary format
    // In case #1 & #2, the following attempt to delete registry entries from the old location
    // will be a no-op 'cos there will be no old registry entries to delete
    bool bStatus = true;
    if (!m_fHasOriginalConfig)
    {
        TRACE_INFO("%!FUNC! deleting old parameters from the registry");
        if (!m_pConfig->m_pWlbsApiFuncs->pfnParamDeleteReg(m_AdapterGuid, true))
        {
            TRACE_CRIT("%!FUNC! error deleting parameters from the registry");
        }
    }

    TRACE_INFO("%!FUNC! writing parameters to the registry");
    if (!m_pConfig->m_pWlbsApiFuncs->pfnParamWriteReg(m_AdapterGuid, &m_CurrentConfig))
    {
        TRACE_CRIT("%!FUNC! error writing parameters to the registry");
        TRACE_VERB("<-%!FUNC!");
        return WLBS_REG_ERROR;
    }

    if ((m_fOriginalBindingEnabled == fCurrentBindingEnabled) && m_fHasOriginalConfig) {
        if (!memcmp(&m_OriginalConfig, &m_CurrentConfig, sizeof(m_CurrentConfig))) {
            /* If the binding hasn't changed and we have previously bound to this adapter
               (originalconfig -> loaded from registry) and the NLB parameters haven't 
               changed, then nothing changed and we can bail out here. */
            TRACE_INFO("%!FUNC! no changes needed...exiting");
            TRACE_VERB("<-%!FUNC!");
            return WLBS_OK;
        } else {
            /* Otherwise, if the binding hasn't changed, NLB is currently bound, and we have 
               previously bound to this adapter (originalconfig -> loaded from registry) 
               and the NLB parameters HAVE changed, then we need to reload the driver. */
            if (fCurrentBindingEnabled && !fAdapterDisabled)
            {
                m_fReloadRequired = true;
                TRACE_INFO("%!FUNC! will reload adapter");
            }

        }
    }

    /* If MSCS is installed and NLB is bound, throw an NT event (event is latched, so check this too) */
    DWORD dwClusterState = 0;
    if (fCurrentBindingEnabled && !m_fMSCSWarningEventLatched)
    {
        HINSTANCE hDll = LoadLibrary(L"clusapi.dll");
        if (NULL != hDll)
        {
            LPFNGNCS pfnGetNodeClusterState = (LPFNGNCS) GetProcAddress(hDll, "GetNodeClusterState");

            if (NULL != pfnGetNodeClusterState)
            {
                if (ERROR_SUCCESS == pfnGetNodeClusterState(NULL, &dwClusterState))
                {
                    if (ClusterStateNotRunning == dwClusterState || ClusterStateRunning == dwClusterState)
                    {
                        /* Log NT event -- Do not throw an error if these calls fail. This is just best effort. */
                        HANDLE hES = RegisterEventSourceW (NULL, CVY_NAME);
                        if (NULL != hES)
                        {
                            TRACE_INFO("%!FUNC! detected that MSCS is installed");
                            TraceMsg(L"CNetcfgCluster::ApplyRegistryChanges MSCS warning event needs to be logged.");
                            if (ReportEventW(hES,                                /* Handle to event log*/
                                             EVENTLOG_WARNING_TYPE,              /* Event type */
                                             0,                                  /* Category */
                                             IDS_INSTALL_WITH_MSCS_INSTALLED,    /* MessageId */
                                             NULL,                               /* Security identifier */
                                             0,                                  /* Num args to event string */ 
                                             0,                                  /* Size of binary data */
                                             NULL,                               /* Ptr to args for event string */
                                             NULL))                              /* Ptr to binary data */
                            {
                                /* Latch the event, so it won't be thrown again */
                                m_fMSCSWarningEventLatched = true;
                            }
                            else
                            {
                                /* Couldn't log the NT event. Don't fail anything; we aren't latched so we'll try to log again on next change */
                                TRACE_CRIT("%!FUNC! call to write the MSCS warning event failed");
                                TraceMsg(L"CNetcfgCluster::ApplyRegistryChanges failed to write MSCS warning event to log.");
                            }
                            DeregisterEventSource(hES);
                        }
                        else
                        {
                            TRACE_CRIT("%!FUNC! failed call to RegisterEventSource to log the MSCS warning event.");
                            TraceMsg(L"CNetcfgCluster::ApplyRegistryChanges failed call to RegisterEventSource for MSCS warning event.");
                        }
                    }
                    else { /* MS Cluster Service is not installed. That's good! */ }
                }
                else
                {
                    TRACE_CRIT("%!FUNC! error determining if MSCS is installed.");
                    TraceMsg(L"CNetcfgCluster::ApplyRegistryChanges error checking MSCS state.");
                }
            }
            else
            {
                TRACE_CRIT("%!FUNC! Get function address for GetNodeClusterState in clusapi.dll failed with %d", GetLastError());
            }

            if (!FreeLibrary(hDll))
            {
                TRACE_CRIT("%!FUNC! FreeLibrary for clusapi.dll failed with %d", GetLastError());
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! Load clusapi.dll failed with %d", GetLastError());
        }
    }

    /* Write adapter name into the registry for API use. */
    if(!WriteAdapterName(m_pConfig, m_AdapterGuid))
    {
        TRACE_CRIT("%!FUNC! error writing adapter name into the registry (for API use)");
    }

    if (!m_fOriginalBindingEnabled && fCurrentBindingEnabled) {
        /* This is a BIND operation.  Create/Modify the initial state registry 
           key.  We initialize the state to the user-specified preference in 
           the host TAB of the UI - ClusterModeOnStart.  The driver will 
           subsequently update this key with the current state of the driver 
           in order to persist that state across reboots, etc. */
        if (!WriteHostStateRegistryKey(m_pConfig, m_AdapterGuid, m_CurrentConfig.cluster_mode)) {
            TRACE_CRIT("%!FUNC! error writing host state into the registry");
        } else {
            TRACE_INFO("%!FUNC! host state set to: %s", (m_CurrentConfig.cluster_mode == CVY_HOST_STATE_STARTED) ? "Started" : 
                                                        (m_CurrentConfig.cluster_mode == CVY_HOST_STATE_STOPPED) ? "Stopped" :
                                                        (m_CurrentConfig.cluster_mode == CVY_HOST_STATE_SUSPENDED) ? "Suspended" : "Unknown");
        }
    }

    /* Figure out whether we need to change MAC address. */
//    if (!m_fOriginalBindingEnabled || !m_fHasOriginalConfig)
//        fOriginalMacAddrSet = false;
//    else
//        fOriginalMacAddrSet = !m_OriginalConfig.mcast_support;

    if (!fCurrentBindingEnabled)
        fCurrentMacAddrSet = false;
    else
        fCurrentMacAddrSet = !m_CurrentConfig.mcast_support;

    /* If the MAC address changes because we are unbinding NLB, disable the adapter. The reload flag should be set true already
       if that is needed. So we modify it to false if we are disabling the adapter, but leave it untouched otherwise.  Because
       an IP address change does not ALWAYS cause a MAC address change, we will also bounce the NIC if the cluster IP address
       changes.  Although this is not necessary from an operational perspective, we do it to achieve consistency in the resulting
       state of NLB - we bounce the NIC in these cases to cause NLB to re-assume its initial host state in all cases where we 
       change our cluster membership (primary IP change, MAC change or bind/unbind). */
    if (m_fOriginalBindingEnabled != fCurrentBindingEnabled               ||
        m_CurrentConfig.mcast_support != m_OriginalConfig.mcast_support   ||
        wcscmp(m_CurrentConfig.cl_mac_addr, m_OriginalConfig.cl_mac_addr) ||
        wcscmp(m_CurrentConfig.cl_ip_addr, m_OriginalConfig.cl_ip_addr)     )
    {
        if (m_fOriginalBindingEnabled && !fCurrentBindingEnabled)
        {
            if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) == S_OK) {
                ULONG status = 0UL;

                if ((hr = pAdapter->GetDeviceStatus(&status)) == S_OK) {
                    TRACE_INFO("%!FUNC! device status is 0x%x", status);
                    if (status != CM_PROB_DISABLED) {
                        m_fReenableAdapter = true;
                        m_fReloadRequired = false;
                        TRACE_INFO("%!FUNC! disable adapter");
                        dwStatus = NotifyAdapter(pAdapter, DICS_DISABLE);
                        if (!SUCCEEDED(dwStatus))
                        {
                            TRACE_CRIT("%!FUNC! a call to NotifyAdapter to disable the adapter for a MAC address change failed with %d", dwStatus);
                        } else
                        {
                            TRACE_INFO("%!FUNC! a call to NotifyAdapter to disable the adapter for a MAC address change succeeded");
                        }
                    }
                }
                else
                {
                    TRACE_CRIT("%!FUNC! GetDeviceStatus failed with 0x%x", hr);
                }

                pAdapter->Release();
                pAdapter = NULL;
            }
            else
            {
                TRACE_CRIT("%!FUNC! GetAdapterFromGuid failed with 0x%x", hr);
            }
        }        

        /* Change the mac address. */
        m_fMacAddrChanged = true;
        m_pConfig->m_pWlbsApiFuncs->pfnRegChangeNetworkAddress(m_AdapterGuid, m_CurrentConfig.cl_mac_addr, !fCurrentMacAddrSet);
        TraceMsg(L"New MAC address written to registry");
        TRACE_INFO("%!FUNC! new MAC address written to registry");
    }

    CopyMemory(&m_OriginalConfig, &m_CurrentConfig, sizeof(m_CurrentConfig));

    m_fHasOriginalConfig = true;
    m_fOriginalBindingEnabled = fCurrentBindingEnabled;

    TRACE_VERB("<-%!FUNC!");
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::ResetMSCSLatches
//
// Description:  Resets the static flags for latching warning popup and NT event
//               when MSCS is already installed. This reset allows the user to
//               control the period during which latching is valid
//
// Arguments: None
//
// Returns:   None
//
// History:   chrisdar Created: 01.05.07
//
//+----------------------------------------------------------------------------
void CNetcfgCluster::ResetMSCSLatches() {
    TRACE_VERB("->%!FUNC!");
    CNetcfgCluster::m_fMSCSWarningEventLatched = false;
    CNetcfgCluster::m_fMSCSWarningPopupLatched = false;
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  CNetcfgCluster::ApplyPnpChanges
//
// Description:  Apply the changes to drivers
//
// Arguments: HANDLE hWlbsDevice - 
//
// Returns:   DWORD - Win32 Error
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------
DWORD CNetcfgCluster::ApplyPnpChanges(HANDLE hDeviceWlbs) {
    TRACE_VERB("->%!FUNC!");

    if (m_fReloadRequired && (hDeviceWlbs != INVALID_HANDLE_VALUE)) {
        DWORD dwStatus = m_pConfig->m_pWlbsApiFuncs->pfnNotifyDriverConfigChanges(hDeviceWlbs, m_AdapterGuid); // Always returns ERROR_SUCCESS
        TraceMsg(L"NLB driver notified of configuration changes");
        TRACE_INFO("%!FUNC! nlb driver notified of configuration changes and returned %d where %d indicates success", dwStatus, ERROR_SUCCESS);
    }

    if (m_fMacAddrChanged) {
        PWSTR pszPnpDevNodeId = NULL;
        INetCfgComponent* pAdapter = NULL;
        HRESULT hr;

        hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter);
        
        if (hr != S_OK) {
            TraceError("GetAdapterFromGuid failed at GetPnpDevNodeId", hr);
            TRACE_CRIT("%!FUNC! call to GetAdapterFromGuid failed with %d", hr);
            return false;
        }

        hr = pAdapter->GetPnpDevNodeId (& pszPnpDevNodeId);

        if (hr != S_OK) {
            TraceError("HrWriteAdapterName failed at GetPnpDevNodeId", hr);
            TRACE_CRIT("%!FUNC! call to GetPnpDevNodeId failed with %d", hr);

            pAdapter->Release();
            pAdapter = NULL;

            return false;
        }

        /*
            The following function "NotifyAdapterAddressChangeEx" calls into setup apis
            to get the network adapter to adopt its new mac address. This leads to the 
            network adapter getting disabled and re-enabled. Because the setup apis 
            are asynchronous, NotifyAdapterAddressChangeEx, in order to determine the completeness
            of the disable and re-enable process, waits until a "Query" to the NLB driver
            is successful. Obviously, in order for the "Query" to succeed, the NLB driver has to be
            re-bound to the network adapter upon re-enable of the network adapter. So, we check
            if NLB is bound to the network adapter NOW (this means NLB will be re-bound) to 
            indicate to "NotifyAdapterAddressChangeEx" if it should wait until the "Query" succeeds.
            
            If we are executing in the context of an Unbind or Uninstall+Unbind of NLB, obviously, 
            NLB will NOT re-bound to the network adapter upon re-enable. So, "NotifyAdapterAddressChangeEx"
            will NOT wait. But, we are fine because the network adapter *should* already have been
            disabled (in ApplyRegistryChanges). So, the call to "NotifyAdapterAddressChangeEx"
            will be a no-op.
            -- KarthicN, 05-31-02
        */
        m_pConfig->m_pWlbsApiFuncs->pfnNotifyAdapterAddressChangeEx(pszPnpDevNodeId, 
                                                                    m_AdapterGuid, 
                                                                    (m_pConfig->IsBoundTo(pAdapter) == S_OK)); 
        TraceMsg(L"Adapter notified of new MAC address");
        TRACE_INFO("%!FUNC! adapter notified of new MAC address");

        /* If the adapter was disabled in ApplyRegistryChanges() because the MAC 
           address changed and the NIC was enabled, then re-enable it here. */
        if (m_fReenableAdapter) {
            TRACE_INFO("%!FUNC! enable adapter");
            DWORD dwStatus = NotifyAdapter(pAdapter, DICS_ENABLE);
            if (!SUCCEEDED(dwStatus))
            {
                TRACE_CRIT("%!FUNC! a call to NotifyAdapter to reenable the adapter after a previous disable for a MAC address change failed with %d", dwStatus);
            } else
            {
                TRACE_INFO("%!FUNC! a call to NotifyAdapter to reenable the adapter after a previous disable for a MAC address change succeeded");
            }
        }

        pAdapter->Release();
        pAdapter = NULL;

        CoTaskMemFree(pszPnpDevNodeId);
    }

    TRACE_VERB("<-%!FUNC!");
    return ERROR_SUCCESS;
}

/*
 * Function: CNetcfgCluster::CheckForDuplicateClusterIPAddress
 * Description: Used to check for duplicate cluster IP addresses across multiple NICs.
 *              Note that this method uses IP information taken from the NLB registry, not from TCP/IP.
 *              As a result, this checking is incomplete and no guarantee can be made that an IP will not be usurped.
 * Author: shouse 10.24.00
 * History: ChrisDar 06.06.02 Adapter must be currently installed for it to contribute to the duplicate checking.
 */
bool CNetcfgCluster::CheckForDuplicateClusterIPAddress (WCHAR * szOtherIP) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::CheckForDuplicateClusterIPAddress");

    HRESULT hr = S_OK;

    /* First check to see whether the cluster IP addresses match. */
    if (!wcscmp(m_CurrentConfig.cl_ip_addr, szOtherIP)) {
        INetCfgComponent* pAdapter = NULL;
        
        TRACE_INFO("%!FUNC! possible duplicate IP address found");

        /* If they do match, get the INetCfgComponent interface for this GUID. */
        if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) != S_OK) {
            TraceError("GetAdapterFromGuid failed in CNetcfgCluster::CheckForDuplicateClusterIPAddress", hr);
            TRACE_CRIT("%!FUNC! call to GetAdapterFromGuid failed with %d. Treating this as a 'match-not-found' case.", hr);
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }
        
        {
            ULONG status = E_UNEXPECTED;

            hr = pAdapter->GetDeviceStatus(&status);
            if (hr == S_OK)
            {
                /* The device with this IP is installed, but we don't have a duplicate unless NLB is bound to it. */
                if (m_pConfig->IsBoundTo(pAdapter) == S_OK)
                {
                    TRACE_INFO("%!FUNC! duplicate IP address found");
                    TRACE_VERB("<-%!FUNC!");

                    pAdapter->Release();
                    pAdapter = NULL;

                    return TRUE;
                }

                TRACE_INFO("%!FUNC! NLB is not bound to this adapter. This is not a duplicate match.");
            }
            else if (hr == NETCFG_E_ADAPTER_NOT_FOUND)
            {
                TRACE_INFO("%!FUNC! matching adapter found but it is not currently installed. This is not a duplicate match.");
            }
            else
            {
                TRACE_CRIT("%!FUNC! error 0x%x while getting device status of adapter. Treating this as a 'match-not-found' case.", hr);
            }
        }
        
        pAdapter->Release();
        pAdapter = NULL;
    }

    TRACE_INFO("%!FUNC! no duplicate IP address was found");
    TRACE_VERB("<-%!FUNC!");
    return FALSE;
}

/*
 * Function: CNetcfgCluster::CheckForDuplicateBDATeamMaster
 * Description: Used to check for duplicate masters in the same BDA team.
 * Author: shouse 1.29.02
 */
bool CNetcfgCluster::CheckForDuplicateBDATeamMaster (NETCFG_WLBS_BDA_TEAMING * pBDATeaming) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CNetcfgCluster::CheckForDuplicateBDATeamMaster");

    HRESULT hr = S_OK;

    /* If the adapter being operated on (probably being bound, if we've come down 
       this path) is not part of a BDA team, or is not the master of its team, then
       there is no reason to check.  Note that this check should have already been
       done by the calling function. */
    if (!m_CurrentConfig.bda_teaming.active || !m_CurrentConfig.bda_teaming.master) {
        TRACE_INFO("%!FUNC! this adapter is not the master of a BDA team.");
        TRACE_VERB("<-%!FUNC!");
        return FALSE;
    }

    /* Otherwise, if the adapter we're comparing against is not part of a BDA team,
       or is not the master of its team, there's nothing to compare. */
    if (!pBDATeaming->active || !pBDATeaming->master) {
        TRACE_INFO("%!FUNC! other adapter is not the master of a BDA team.");
        TRACE_VERB("<-%!FUNC!");
        return FALSE;
    }

    /* At this point, both adapters are masters of a BDA team.  Check to see 
       whether its the SAME BDA team. */
    if (!wcscmp(m_CurrentConfig.bda_teaming.team_id, pBDATeaming->team_id)) {
        INetCfgComponent* pAdapter = NULL;
        
        /* If they do match, get the INetCfgComponent interface for this GUID. */
        if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) != S_OK) {
            TraceError("GetAdapterFromGuid failed in CNetcfgCluster::CheckForDuplicateBDATeamMaster", hr);
            TRACE_CRIT("%!FUNC! call to GetAdapterFromGuid failed with %d", hr);
            TRACE_VERB("<-%!FUNC!");
            return FALSE;
        }
        
        /* If NLB is bound to this adapter, then there is a conflict. */
        if (m_pConfig->IsBoundTo(pAdapter) == S_OK)
        {
            TRACE_INFO("%!FUNC! duplicate BDA team masters found");
            TRACE_VERB("<-%!FUNC!");

            pAdapter->Release();
            pAdapter = NULL;

            return TRUE;
        }

        pAdapter->Release();
        pAdapter = NULL;
    }

    TRACE_INFO("%!FUNC! no duplicate BDA team master was found");
    TRACE_VERB("<-%!FUNC!");
    return FALSE;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::CWlbsConfig
//
// Purpose:   constructor for class CWlbsConfig
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
// ----------------------------------------------------------------------
CWlbsConfig::CWlbsConfig(VOID) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::CWlbsConfig");

    m_pWlbsComponent = NULL;
    m_pNetCfg = NULL;
    m_ServiceOperation = WLBS_SERVICE_NONE;
    m_hDeviceWlbs = INVALID_HANDLE_VALUE;
    m_hdllWlbsCtrl = NULL;
    m_pWlbsApiFuncs = NULL;

    /* Initialize latched flags of CNetCfgCluster so that we get pristine
       MSCS popup and NT events when making config changes and MSCS is installed.
       Comment out this call if the NT event and popup should be thrown only
       once per loading of this dll */
    CNetcfgCluster::ResetMSCSLatches();
    TRACE_VERB("<-%!FUNC!");
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::~CWlbsConfig
//
// Purpose:   destructor for class CWlbsConfig
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
// ----------------------------------------------------------------------
CWlbsConfig::~CWlbsConfig(VOID) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::~CWlbsConfig");

    /* Release interfaces if acquired. */
    ReleaseObj(m_pWlbsComponent);
    ReleaseObj(m_pNetCfg);

    if (m_pWlbsApiFuncs) delete m_pWlbsApiFuncs;

    if (m_hdllWlbsCtrl) FreeLibrary(m_hdllWlbsCtrl);

    /* Free all clusters. */
    for (vector<CNetcfgCluster*>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;
        ASSERT(pCluster != NULL);
        delete pCluster;
    }
    TRACE_VERB("<-%!FUNC!");
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::Initialize(INetCfg* pNetCfg, BOOL fInstalling) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::Initialize");

    HRESULT hr = S_OK;

    /* Load wlbsctrl.dll */
    ASSERT(m_pWlbsApiFuncs == NULL);
    ASSERT(m_hdllWlbsCtrl == NULL);

    m_pWlbsApiFuncs = new WlbsApiFuncs;

    if (m_pWlbsApiFuncs == NULL)
    {
        TRACE_CRIT("%!FUNC! memory allocation failed for m_pWlbsApiFuncs");
        return E_OUTOFMEMORY;
    }

    m_hdllWlbsCtrl = LoadWlbsCtrlDll(m_pWlbsApiFuncs);

    if (m_hdllWlbsCtrl == NULL) {
        DWORD dwStatus = GetLastError();
        TRACE_CRIT("%!FUNC! failed to load wlbsctrl.dll with error %d", dwStatus);
        TraceError("CWlbsConfig::Initialize Failed to load wlbsctrl.dll", dwStatus);
    
        // CLD: What in the world is going on here?
        if (dwStatus == ERROR_SUCCESS)
        {
            TRACE_VERB("<-%!FUNC!");
            return E_FAIL;
        }

        TRACE_VERB("<-%!FUNC!");
        return HRESULT_FROM_WIN32(dwStatus);
    }

    AddRefObj (m_pNetCfg = pNetCfg);

    /* Find the WLBS component. */
    ASSERT(m_pWlbsComponent == NULL);
    m_pWlbsComponent = NULL;

    /* The WLBS conponent object is not available at installation time. */
    if (!fInstalling) {
        if (FAILED(hr = pNetCfg->FindComponent(NETCFG_WLBS_ID, &m_pWlbsComponent)) || m_pWlbsComponent == NULL) {
            ASSERT(fInstalling);
            TRACE_CRIT("%!FUNC! find for nlb component object failed with %d", hr);
            TraceError("INetCfg::FindComponent failed",hr);
        }

        hr = LoadAllAdapterSettings(false);  // fUpgradeFromWin2k = false
        if (FAILED(hr))
        {
            TRACE_CRIT("%!FUNC! loading all adapter settings for a non-window 2000 upgrade failed with %d", hr);
        }
    }

    ASSERT_VALID(this);

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::LoadAllAdapters
//
// Description:  Load all cluster settings from registry
//
// Arguments: None
//
// Returns:   HRESULT - 
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
HRESULT CWlbsConfig::LoadAllAdapterSettings(bool fUpgradeFromWin2k) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::LoadAllAdapterSettings");

    HRESULT hr = S_OK;
    INetCfgClass *pNetCfgClass = NULL;
    INetCfgComponent* pNetCardComponent = NULL;

    ASSERT_VALID(this);

    hr = m_pNetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET, IID_INetCfgClass, (void **)&pNetCfgClass);

    if (FAILED(hr)) {
        TraceError("INetCfg::QueryNetCfgClass failed", hr);
        TRACE_CRIT("%!FUNC! call to QueryNetCfgClass failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return hr; 
    }

    /* Get an enumerator to list all network devices. */
    IEnumNetCfgComponent *pIEnumComponents = NULL;

    if (FAILED(hr = pNetCfgClass->EnumComponents(&pIEnumComponents))) {
        TraceError("INetCfg::EnumComponents failed", hr);
        TRACE_CRIT("%!FUNC! call to enumerate components failed with %d", hr);
        pNetCfgClass->Release();
        TRACE_VERB("<-%!FUNC!");
        return hr;
    }

    /* Go through all the adapters and load settings for adapters that are bound to WLBS. */
    while (pIEnumComponents->Next(1, &pNetCardComponent, NULL) == S_OK) {
        GUID AdapterGuid;

        /* Retrieve the instance GUID of the component. */
        if (FAILED(hr = (pNetCardComponent)->GetInstanceGuid(&AdapterGuid))) {
            pNetCardComponent->Release();
            pNetCardComponent = NULL;
            TraceError("GetInstanceGuid failed", hr);
            TRACE_CRIT("%!FUNC! call to retrieve the guid instance of the adapter failed with %d", hr);
            continue;
        }

        bool fBound = (IsBoundTo(pNetCardComponent) == S_OK);

        pNetCardComponent->Release();
        pNetCardComponent = NULL;

        /* Win2k support only one adapter.  The settings will be lost if not bound. */
        if (fUpgradeFromWin2k && !fBound) continue;

        /* Load settings regardless of bindings for non-upgrade case. */
        CNetcfgCluster* pCluster = new CNetcfgCluster(this);

        if (pCluster == NULL)
        {
            TRACE_CRIT("%!FUNC! failed memory allocation for CNetcfgCluster");
            TRACE_VERB("<-%!FUNC!");
            return ERROR_OUTOFMEMORY;
        }

        DWORD dwStatus = pCluster->InitializeFromRegistry(AdapterGuid, fBound, fUpgradeFromWin2k);
        if (dwStatus != ERROR_SUCCESS) {
            /* If NLB is already bound to this adapter, this may be an issue.  Normally, it will be
               an indication of something heinous, but in the case of a win2k (perhaps NT4.0 as well),
               its only happening because we're looking for the NLB settings in the wrong place.  If
               so, a subsequent call to our Upgrade COM API will fall-back to attempt to read from
               the win2k location in the registry.  Because we don't know here whether or not this is
               an upgrade, etc., we don't have the necessary information to be able to ASSERT that 
               this is wrong with any real certainty. */
            if (fBound) {
                TRACE_CRIT("%!FUNC! Reading NLB information from registry failed with status=0x%08x", dwStatus);
            }

            delete pCluster;
            continue;
        }

        m_vtrCluster.push_back(pCluster);    
    }

    pIEnumComponents->Release();
    pNetCfgClass->Release();
    TRACE_VERB("<-%!FUNC!");

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure WLBS
//
// Arguments:
//    pszAnswerFile     [in]  name of AnswerFile
//    pszAnswerSection  [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::ReadAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::ReadAnswerFile");

    HRESULT hr = S_OK;
    CSetupInfFile caf;

    ASSERT_VALID(this);

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = caf.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);

    if (FAILED(hr)) {
        TraceError("caf.HrOpen failed", hr);
        WriteNlbSetupErrorLog(IDS_PARM_OPEN_ANS_FILE_FAILED, hr);
        TRACE_CRIT("%!FUNC! attempt to open answer file failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    // Get the adapter specific parameters
    WCHAR * mszAdapterList;

    TRACE_INFO("%!FUNC! answer section name from answer file=%ls", pszAnswerSection);

    hr = HrSetupGetFirstMultiSzFieldWithAlloc(caf.Hinf(), pszAnswerSection, c_szAdapterSections, &mszAdapterList);

    if (FAILED(hr)) {
        TraceError("WLBS HrSetupGetFirstMultiSzFieldWithAlloc failed", hr);
        //
        // We get here on any error reading the answer file. Log to setuperr.log only if the problem is not
        // a missing section. NLB is optional, not mandatory, for an install.
        //
        // Check for, and ignore, both missing section and missing line. The latter is returned currently, but the former
        // makes more sense here, because that means the NLB section is completely missing.
        //
        if ((SPAPI_E_LINE_NOT_FOUND != hr) && (SPAPI_E_SECTION_NOT_FOUND != hr))
        {
             WriteNlbSetupErrorLog(IDS_PARM_GET_ADAPTERS_FAILED, hr);
        }
        TRACE_CRIT("%!FUNC! attempt to retrieve adapter list from answer file failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    TRACE_INFO("%!FUNC! list of adapters with nlb settings=%ls", mszAdapterList);

    tstring  strAdapterName;
    tstring  strInterfaceRegPath;

    for (PCWSTR pszAdapterSection = mszAdapterList; *pszAdapterSection; pszAdapterSection += lstrlenW(pszAdapterSection) + 1) {
        // Get the card name "SpecificTo = ..."
        TRACE_INFO("%!FUNC! adapter section=%ls", pszAdapterSection);
        hr = HrSetupGetFirstString(caf.Hinf(), pszAdapterSection, c_szAfSpecificTo, &strAdapterName);

        if (FAILED(hr)) {
            TraceError("WLBS HrSetupGetFirstString failed", hr);
            WriteNlbSetupErrorLog(IDS_PARM_GET_SPECIFIC_TO, pszAdapterSection, hr);
            TRACE_CRIT("%!FUNC! attempt to retrieve adapter name from answer file failed with %d. Skipping to next adapter", hr);
            continue;
        }
        TRACE_INFO("%!FUNC! adapter to which nlb settings apply=%ls", strAdapterName.c_str());

        GUID guidNetCard;

        if (!FGetInstanceGuidOfComponentInAnswerFile(strAdapterName.c_str(), m_pNetCfg, &guidNetCard)) {
            TraceError("WLBS FGetInstanceGuidOfComponentInAnswerFile failed", FALSE);
            WriteNlbSetupErrorLog(IDS_PARM_GET_NETCARD_GUID);
            TRACE_CRIT("%!FUNC! attempt to retrieve netcard guid from answer file failed. Skipping to next adapter");
            continue;
        }

        CNetcfgCluster* pCluster = new CNetcfgCluster(this);

        if (pCluster == NULL)
        {
            WriteNlbSetupErrorLog(IDS_PARM_OOM_NETCFGCLUS);
            TRACE_CRIT("%!FUNC! memory allocation failure for CNetcfgCluster");
            TRACE_VERB("<-%!FUNC!");
            return ERROR_OUTOFMEMORY;
        }

        if (FAILED(hr = pCluster->InitializeFromAnswerFile(guidNetCard, caf, pszAdapterSection))) {
            TraceError("WLBS InitializeFromAnswerFile failed", hr);
            TRACE_CRIT("%!FUNC! attempt to initialize the adapter settings from answer file failed with %d. Skipping to next adapter", hr);
            delete pCluster;
            continue;
        }

        m_vtrCluster.push_back(pCluster);    
    }

    delete [] mszAdapterList;

    caf.Close();

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::Install(DWORD /* dw */) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::Install");

    HRESULT hr = S_OK;

    ASSERT_VALID(this);

    /* Start up the install process. */
    m_ServiceOperation = WLBS_SERVICE_INSTALL;

    if (m_pWlbsComponent == NULL && FAILED(m_pNetCfg->FindComponent(NETCFG_WLBS_ID, &m_pWlbsComponent)) || m_pWlbsComponent == NULL) {
        TraceError("INetCfg::FindComponent failed at Install",hr);
        TRACE_CRIT("%!FUNC! find for nlb component object failed with %d", hr);
    }

    TRACE_VERB("->%!FUNC!");
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::Upgrade
//
// Purpose:   Do operations necessary for upgrade.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::Upgrade(DWORD /* dwSetupFlags */, DWORD /* dwUpgradeFromBuildNo */) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::Upgrade");

    ASSERT_VALID(this);

    /*  If we do not have any cluster, there might be 
        old registry settings under different place. */
    if (m_vtrCluster.size() == 0)
    {
        HRESULT hr = LoadAllAdapterSettings(true); // fUpgradeFromWin2k = true
        if (FAILED(hr))
        {
            TRACE_CRIT("%!FUNC! loading all adapter settings for a window 2000 upgrade failed with %d", hr);
        }
    }

    m_ServiceOperation = WLBS_SERVICE_UPGRADE;

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::Removing(VOID) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"##### CWlbsConfig::Removing\n");

    ASSERT_VALID(this);

    m_ServiceOperation = WLBS_SERVICE_REMOVE;

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::GetAdapterConfig
//
// Description:  Read the adapter config, which could be cached by SetAdapterConfig
//
// Arguments: const GUID& AdapterGuid - 
//            NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   STDMETHODIMP - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::GetAdapterConfig(const GUID& AdapterGuid, NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::GetAdapterConfig");

    ASSERT_VALID(this);
    ASSERT(pClusterConfig);

    CNetcfgCluster* pCluster = GetCluster(AdapterGuid);

    if (pCluster == NULL)
    {
        TRACE_INFO("%!FUNC! did not find cluster");
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    pCluster->GetConfig(pClusterConfig); // Returns void

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::SetAdapterConfig
//
// Description: Set the adapter config, the result is cached and not saved to registry 
//
// Arguments: const GUID& AdapterGuid - 
//            NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   STDMETHODIMP - 
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::SetAdapterConfig(const GUID& AdapterGuid, NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::SetAdapterConfig");

    ASSERT_VALID(this);
    ASSERT(pClusterConfig);

    CNetcfgCluster* pCluster = GetCluster(AdapterGuid);

    if (pCluster == NULL) {
        TRACE_INFO("%!FUNC! did not find cluster. Will create instance");
        pCluster = new CNetcfgCluster(this);

        if (pCluster == NULL)
        {
            TRACE_CRIT("%!FUNC! memory allocation failure creating instance of CNetcfgCluster");
            TRACE_VERB("<-%!FUNC!");
            return E_OUTOFMEMORY;
        }

        pCluster->InitializeWithDefault(AdapterGuid); // Returns void

        //
        // See bug 233962, NLB configuration lost when leaving nlb properties
        // The reason is that NLB notifier object is not notified when NLB is checked.
        // Currently, there is no consistant repro.  Uncommented the code below will fix the peoblem.
        // But will leaves potential bug in netcfg hard to catch.
        // Uncomment the code only after the netcfg bug is fixed.
        //
        // m_vtrCluster.push_back(pCluster);    
    }

    pCluster->SetConfig(pClusterConfig); // Returns void

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
// 
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::ApplyRegistryChanges(VOID) {
    DWORD dwIPSecFlags = 0;
    DWORD dwStatus;

    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::ApplyRegistryChanges");

    ASSERT_VALID(this);

    for (vector<CNetcfgCluster*>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;

        ASSERT(pCluster != NULL);

        if (pCluster != NULL)
        {
            dwStatus = pCluster->ApplyRegistryChanges(m_ServiceOperation == WLBS_SERVICE_REMOVE);
            if (ERROR_SUCCESS != dwStatus && WLBS_OK != dwStatus)
            {
                TRACE_CRIT("%!FUNC! applying registry changes to a CNetcfgCluster failed with %d. Continue with next instance", dwStatus);
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! retrieved null instance of CNetcfgCluster");
        }
    }

    /* If NLB is being uninstalled, then we definately need to notify
       IPSec that we're going away, so turn off the "NLB bound" bit 
       in the NLB flags. */
    if (m_ServiceOperation == WLBS_SERVICE_REMOVE) {

        dwIPSecFlags &= ~FLAGS_NLBS_BOUND;     /* Defined in winipsec.h */

    } else {

        /* Count the number of adapters that NLB is currently bound to.
           This count INCLUDES the operation we are in the middle of 
           performing, if we happen to be binding or unbinding. */
        ULONG dwNLBInstances = CountNLBBindings();

        /* If this is a bind and we are the first instance of NLB on this host,
           then notify IPSec that NLB is now bound. */
        if (dwNLBInstances > 0) {
            dwIPSecFlags |= FLAGS_NLBS_BOUND;  /* Defined in winipsec.h */
        } else {
            dwIPSecFlags &= ~FLAGS_NLBS_BOUND; /* Defined in winipsec.h */
        }

    }

    if (!WriteIPSecNLBRegistryKey(dwIPSecFlags)) {
        TRACE_CRIT("%!FUNC! Unable to notify IPSec of NLB binding changes... This will affect the ability of NLB to track IPSec sessions");
    } else {
        TRACE_INFO("%!FUNC! IPSec successfully notified of NLB binding status");
    }

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::ApplyPnpChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Propagate changes to the driver.
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::ApplyPnpChanges() {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::ApplyPnpChanges");

    vector<CNetcfgCluster*>::iterator iter;
    bool bCreateDevice = FALSE;
    DWORD dwStatus = ERROR_SUCCESS;

    ASSERT_VALID(this);

    /* Check to see if we need to open the IOCTL interface to the driver.  This is necessary
       if any adapter in our cluster list requries a reload (which is done via an IOCTL). */
    for (iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;

        if (bCreateDevice |= pCluster->IsReloadRequired()) break;
    }
    
    /* Open the file and return an error if this is unsuccessful. */
    if (bCreateDevice) {
        TRACE_INFO("%!FUNC! at least one adapter requires a reload. Open an IOCTL.");
        ASSERT(m_hDeviceWlbs == INVALID_HANDLE_VALUE);
        
        m_hDeviceWlbs = CreateFile(_TEXT("\\\\.\\WLBS"), GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
        
        if (m_hDeviceWlbs == INVALID_HANDLE_VALUE) {
            dwStatus = GetLastError();
            TraceMsg(L"Error opening \\\\.\\WLBS device %x", dwStatus);
            TraceError("Invalid \\\\.\\WLBS handle", dwStatus);
            TRACE_CRIT("%!FUNC! invalid handle opening \\\\.\\WLBS device. Error is %d", dwStatus);
            return HRESULT_FROM_WIN32(dwStatus);
        }
        
        ASSERT(m_hDeviceWlbs != INVALID_HANDLE_VALUE);
    }

    for (iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;

        ASSERT(pCluster != NULL);

        if (pCluster != NULL)
        {
            dwStatus = pCluster->ApplyPnpChanges(m_hDeviceWlbs);
            if (ERROR_SUCCESS != dwStatus)
            {
                TRACE_CRIT("%!FUNC! apply pnp changes on CNetcfgCluster failed with %d", dwStatus);
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! retrieved null instance of CNetcfgCluster");
        }
    }

    if (m_hDeviceWlbs != INVALID_HANDLE_VALUE)
    {
        if (!CloseHandle(m_hDeviceWlbs))
        {
            dwStatus = GetLastError();
            TRACE_CRIT("%!FUNC! close nlb device handle failed with %d", dwStatus);
        }
    }

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::QueryBindingPath
//
// Purpose:   Allow or veto a binding path involving us
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbi        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::QueryBindingPath(DWORD dwChangeFlag, INetCfgComponent* pAdapter) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::QueryBindingPath");

    ASSERT_VALID(this);

    TRACE_VERB("<-%!FUNC!");
    return NETCFG_S_DISABLE_QUERY;
}

// ----------------------------------------------------------------------
//
// Function:  CWlbsConfig::NotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path involving us has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWlbsConfig::NotifyBindingPath(DWORD dwChangeFlag, INetCfgBindingPath* pncbp) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::NotifyBindingPath");

    HRESULT hr = S_OK;
    INetCfgComponent * pAdapter;
    PWSTR pszInterfaceName;
    GUID AdapterGuid;
    DWORD dwStatus = 0;

    ASSERT_VALID(this);

    if (m_pWlbsComponent == NULL && FAILED(m_pNetCfg->FindComponent(NETCFG_WLBS_ID, &m_pWlbsComponent)) || m_pWlbsComponent == NULL) {
        dwStatus = GetLastError();
        TraceError("NotifyBindingPath failed at INetCfg::FindComponent\n", dwStatus);
        TRACE_CRIT("%!FUNC! find for nlb component object failed with %d", dwStatus);
        TRACE_VERB("<-%!FUNC!");
        return S_FALSE;
    }

    hr = HrGetLastComponentAndInterface (pncbp, &pAdapter, &pszInterfaceName);

    if (FAILED(hr))
    {
        TRACE_CRIT("%!FUNC! enumerating binding path failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return hr;
    }

    CoTaskMemFree(pszInterfaceName);

    hr = pAdapter->GetInstanceGuid(&AdapterGuid);

    pAdapter->Release();
    pAdapter = NULL;

    if (FAILED(hr))
    {
        TRACE_CRIT("%!FUNC! retrieval of adapter guid from adapter failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return hr;
    }

    CNetcfgCluster* pCluster = GetCluster(AdapterGuid);

    if (pCluster == NULL) {
        if (dwChangeFlag & NCN_ENABLE) {
            /* new configuration. */
            pCluster = new CNetcfgCluster(this);

            if (pCluster == NULL)
            {
                TRACE_CRIT("%!FUNC! memory allocation failure creating instance of CNetcfgCluster");
                TRACE_VERB("<-%!FUNC!");
                return E_OUTOFMEMORY;
            }

            pCluster->InitializeWithDefault(AdapterGuid); // Returns void

            m_vtrCluster.push_back(pCluster);
        } else {
            TraceMsg(L"CWlbsConfig::NotifyBindingPath adapter not bound");
            TRACE_INFO("%!FUNC! adapter is not bound");
            TRACE_VERB("<-%!FUNC!");
            return S_OK;
        }
    }

    pCluster->NotifyBindingChanges(dwChangeFlag, pncbp); // Returns void

    /* If we are enabling a binding path, then check for cluster IP address conflicts. */
    if (dwChangeFlag & NCN_ENABLE) {
        NETCFG_WLBS_CONFIG adapterConfig;
        
        /* Retrieve the cluster configuration. */
        pCluster->GetConfig(&adapterConfig); // Returns void
        
        /* If we detect another bound adapter with this cluster IP address, then revert this cluster's 
           cluster IP Address to the default value.  If the user opens the property dialog, they can
           change the IP address, but we CANNOT warn them here - this code can be run programmatically.
           However, because the user CAN bind NLB without opening the properties, we MUST check this here. */
        if ((hr = CheckForDuplicateCLusterIPAddresses(AdapterGuid, &adapterConfig)) != S_OK) {
            TRACE_CRIT("%!FUNC! another adapter is bound and has the same cluster IP address %ls. Status of check is %d", adapterConfig.cl_ip_addr, hr);

            /* Revert this cluster IP Address to the default (0.0.0.0). */
            (VOID) StringCchCopy(adapterConfig.cl_ip_addr, ASIZECCH(adapterConfig.cl_ip_addr), CVY_DEF_CL_IP_ADDR);
            
            /* Revert this cluster subnet mask to the default (0.0.0.0). */
            (VOID) StringCchCopy(adapterConfig.cl_net_mask, ASIZECCH(adapterConfig.cl_net_mask), CVY_DEF_CL_NET_MASK);
            
            /* Set the cluster configuration. */
            pCluster->SetConfig(&adapterConfig); // Returns void
        }

        /* If this adapter happens to be configured for BDA teaming, and is the master, make sure that
           no other adapter was set to be the master of this team while NLB was unbound from this NIC.
           If there is a conflict, inactivate BDA teaming on this NIC. */
        if ((hr = CheckForDuplicateBDATeamMasters(AdapterGuid, &adapterConfig)) != S_OK) {
            TRACE_CRIT("%!FUNC! another adapter is bound and is the master for this BDA team %ls. Status of check is %d", adapterConfig.bda_teaming.team_id, hr);

            /* Remove the BDA teaming settings for this adapter. */
            adapterConfig.bda_teaming.active = FALSE;
            
            /* Set the cluster configuration. */
            pCluster->SetConfig(&adapterConfig); // Returns void
        }
    }

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

/* 
 * Function: NLBIsBound
 * Description: Returns TRUE if this instance of NLB is currently bound,
 *              FALSE if it is not. 
 * Author: shouse, 8.27.01
 */
bool CNetcfgCluster::NLBIsBound () {
    INetCfgComponent * pAdapter = NULL;
    HRESULT            hr = S_OK;
    bool               bBound = false;

    TRACE_VERB("->%!FUNC!");

    /* Use our GUID to get our netcfg component object pointer.  
       If this fails, then we are definately not bound. */
    if ((hr = GetAdapterFromGuid(m_pConfig->m_pNetCfg, m_AdapterGuid, &pAdapter)) != S_OK) {
        TRACE_INFO("%!FUNC! Unable to get Adapter from GUID.");
        bBound = false;
    } else {
        /* Otherwise, call IsBoundTo to query the binding of this
           instance.  A return value of S_OK indicates bound. */
        bBound = (m_pConfig->IsBoundTo(pAdapter) == S_OK);

        /* Release the interface reference. */
        pAdapter->Release();
        pAdapter = NULL;
    }
    
    TRACE_VERB("<-%!FUNC!");

    return bBound;
}

/* 
 * Function: CountNLBBindings
 * Description: Returns the number of instances of NLB that are currently bound.
 * Author: shouse, 8.27.01
 */
ULONG CWlbsConfig::CountNLBBindings () {
    ULONG status = E_UNEXPECTED;
    ULONG count = 0;
    HRESULT hr = S_OK;

    TRACE_VERB("->%!FUNC!");

    /* Loop through all of our cluster objects and determine the binding state of each one. */
    for (vector<CNetcfgCluster *>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster * pCluster = *iter;
        INetCfgComponent* pAdapter = NULL;
        
        ASSERT(pCluster);

        if (!pCluster) {
            TRACE_INFO("%!FUNC! Found NULL pointer to a CNetcfgCluster.");
            continue;
        }

        /* Get the INetCfgComponent interface for this instance. */
        if ((hr = GetAdapterFromGuid(m_pNetCfg, pCluster->GetAdapterGuid(), &pAdapter)) != S_OK) {
            TRACE_CRIT("%!FUNC! Call to GetAdapterFromGuid failed, hr=0x%08x.", hr);
            continue;
        }

        hr = pAdapter->GetDeviceStatus(&status);
        
        if (hr == S_OK)
        {
            /* A return value of OK means that the device is physically present.  If NLB
               is bound to this adapter, add one to the count. */
            if (pCluster->NLBIsBound()) 
            {
                count++;

                TRACE_INFO("%!FUNC! NLB is bound to this adapter.");
            }
            else
            {
                TRACE_INFO("%!FUNC! NLB is not bound to this adapter.");
            }
        }
        else if (hr == NETCFG_E_ADAPTER_NOT_FOUND)
        {
            TRACE_INFO("%!FUNC! Adapter is not currently installed.");
        }
        else
        {
            TRACE_CRIT("%!FUNC! Error while getting device status of the adapter, hr=0x%08x.", hr);
        }

        pAdapter->Release();
        pAdapter = NULL;
    }

    TRACE_VERB("<-%!FUNC!");

    return count;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::GetCluster
//
// Description:  
//
// Arguments: const GUID& AdapterGuid - 
//
// Returns:   CNetcfgCluster* - 
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
CNetcfgCluster* CWlbsConfig::GetCluster(const GUID& AdapterGuid) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::GetCluster");

    ASSERT_VALID(this);

    for (vector<CNetcfgCluster*>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster* pCluster = *iter;

        ASSERT(pCluster != NULL);

        if (pCluster != NULL) {
            if (IsEqualGUID(pCluster->GetAdapterGuid(), AdapterGuid))
            {
                TRACE_INFO("%!FUNC! cluster instance found");
                TRACE_VERB("<-%!FUNC!");
                return pCluster;
            }
        }
        else
        {
            TRACE_CRIT("%!FUNC! retrieved null instance of CNetcfgCluster. Skipping it.");
        }
    }

    TRACE_INFO("%!FUNC! cluster instance not found");
    TRACE_VERB("<-%!FUNC!");
    return NULL;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::IsBoundTo
//
// Description:  
//
// Arguments: INetCfgComponent* pAdapter - 
//
// Returns:   HRESULT - 
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
HRESULT CWlbsConfig::IsBoundTo(INetCfgComponent* pAdapter) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::IsBoundTo");

    HRESULT hr;

    ASSERT_VALID(this);
    ASSERT(pAdapter != NULL);

    if (m_pWlbsComponent == NULL) {
        TraceMsg(L"CWlbsConfig::IsBoundTo wlbs not installed");
        TRACE_INFO("%!FUNC! nlb is not installed");
        TRACE_VERB("<-%!FUNC!");
        return S_FALSE;
    }

    INetCfgComponentBindings *pIBinding = NULL;

    if (FAILED(m_pWlbsComponent->QueryInterface(IID_INetCfgComponentBindings, (void**)&pIBinding))) {
        DWORD dwStatus = GetLastError();
        TraceError("QI for INetCfgComponentBindings failed\n", dwStatus);
        TRACE_INFO("%!FUNC! QueryInterface on the nlb component object failed with %d", dwStatus);
    }

    if (FAILED(hr = pIBinding->IsBoundTo(pAdapter))) {
        TraceError("Failed to IsBoundTo", hr);
        TRACE_INFO("%!FUNC! the check whether nlb is bound to an adapter failed with %d", hr);
    }

    if (pIBinding) pIBinding->Release();

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  CWlbsConfig::SetDefaults
//
// Description:  
//
// Arguments: NETCFG_WLBS_CONFIG* pClusterConfig - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
void CWlbsConfig::SetDefaults(NETCFG_WLBS_CONFIG* pClusterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::SetDefaults");

    WLBS_REG_PARAMS config;

    ASSERT_VALID(this);
    ASSERT(pClusterConfig);
    ASSERT(m_pWlbsApiFuncs);
    ASSERT(m_pWlbsApiFuncs->pfnParamSetDefaults);

    DWORD dwStatus = m_pWlbsApiFuncs->pfnParamSetDefaults(&config);
    if (WLBS_OK != dwStatus)
    {
        TRACE_CRIT("%!FUNC! failed to set defaults for the cluster configuration");
    }

    WlbsToNetcfgConfig(m_pWlbsApiFuncs, &config, pClusterConfig); // Returns void

    TRACE_VERB("<-%!FUNC!");
}

/*
 * Function: CWlbsConfig::ValidateProperties
 * Description: Check for conflicting cluster IP addresses and alert the user.
 * Author: shouse 7.13.00
 */
STDMETHODIMP CWlbsConfig::ValidateProperties (HWND hwndSheet, GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::ValidateProperties");

    HRESULT hr = S_OK;

    ASSERT_VALID(this);

    /* If we detect another bound adapter with this cluster IP address, then fail the check and 
       pop-up an error message warning the user that there are conflicting IP addresses. */
    if ((hr = CheckForDuplicateCLusterIPAddresses(adapterGUID, adapterConfig)) != S_OK)
    {
        NcMsgBox(hwndSheet, IDS_PARM_ERROR, IDS_PARM_MULTINIC_IP_CONFLICT, MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        TRACE_CRIT("%!FUNC! another network adapter is using IP address %ls", adapterConfig->cl_ip_addr);
    }

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

/*
 * Function: CWlbsConfig::CheckForDuplicateCLusterIPAddresses
 * Description: Loop through all adapters and check for conflicting cluster IP addresses.
 * Author: shouse 7.13.00
 */
STDMETHODIMP CWlbsConfig::CheckForDuplicateCLusterIPAddresses (GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::CheckForDuplicateCLusterIPAddresses");

    CNetcfgCluster * pClusterMe = NULL;

    ASSERT_VALID(this);

    /* Get the cluster pointer for this adapter GUID. */
    pClusterMe = GetCluster(adapterGUID);

    ASSERT(pClusterMe);
    if (!pClusterMe)
    {
        TRACE_INFO("%!FUNC! no cluster instance was found for the supplied adapter");
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    /* If the cluster IP address is the default, then don't check other adapters because
       if they have not been configured yet, this may cause confusion for the user.  We 
       will ignore the error here and other validation in the cluster properties should
       catch this error instead. */
    if (!lstrcmpi(adapterConfig->cl_ip_addr, CVY_DEF_CL_IP_ADDR))
    {
        TRACE_INFO("%!FUNC! the adapter has the default cluster IP address.  No checking needed.");
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    /* Loop through the rest of the list and check this cluster IP against the cluster
       IP of each adapter left in the list. */
    for (vector<CNetcfgCluster *>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster * pCluster = *iter;

        ASSERT(pCluster);
        if (!pCluster)
        {
            /* CLD: 05.17.01 is this a no op or do we store nulls in the vector? */
            TRACE_INFO("%!FUNC! Found NULL pointer to a CNetcfgCluster.");
            TRACE_VERB("<-%!FUNC!");
            continue;
        }

        /* Obviously, don't check against myself. */
        if (pClusterMe == pCluster) continue;

        /* If we find a match, report and error and do not allow the dialog to close. */
        if (pCluster->CheckForDuplicateClusterIPAddress(adapterConfig->cl_ip_addr)) 
        {
            TRACE_INFO("%!FUNC! duplicate cluster IP address found.");
            TRACE_VERB("<-%!FUNC!");
            return S_FALSE;
        }
    }
    
    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

/*
 * Function: CWlbsConfig::CheckForDuplicateBDATeamMasters
 * Description: Loop through all adapters and check for conflicting BDA teaming master specifications.
 * Author: shouse 1.29.02
 */
STDMETHODIMP CWlbsConfig::CheckForDuplicateBDATeamMasters (GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"CWlbsConfig::CheckForDuplicateBDATeamMasters");

    CNetcfgCluster * pClusterMe = NULL;

    ASSERT_VALID(this);

    /* Get the cluster pointer for this adapter GUID. */
    pClusterMe = GetCluster(adapterGUID);

    ASSERT(pClusterMe);
    if (!pClusterMe)
    {
        TRACE_INFO("%!FUNC! no cluster instance was found for the supplied adapter");
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    /* If this adapter is not part of a BDA team, or if it is not the designated 
       master for its BDA team, then there is no reason to check this adapter for
       conflicts with other adapters. */
    if (!adapterConfig->bda_teaming.active || !adapterConfig->bda_teaming.master)
    {
        TRACE_INFO("%!FUNC! the adapter is not the master of a BDA team.  No checking needed.");
        TRACE_VERB("<-%!FUNC!");
        return S_OK;
    }

    /* Loop through the rest of the list and check its BDA team settings against the
       settings of all other adapters in our list. */
    for (vector<CNetcfgCluster *>::iterator iter = m_vtrCluster.begin(); iter != m_vtrCluster.end(); iter++) {
        CNetcfgCluster * pCluster = *iter;

        ASSERT(pCluster);
        if (!pCluster)
        {
            /* CLD: 05.17.01 is this a no op or do we store nulls in the vector? */
            TRACE_INFO("%!FUNC! Found NULL pointer to a CNetcfgCluster.");
            TRACE_VERB("<-%!FUNC!");
            continue;
        }

        /* Obviously, don't check against myself. */
        if (pClusterMe == pCluster) continue;

        /* If we find a match, report and error and do not allow the dialog to close. */
        if (pCluster->CheckForDuplicateBDATeamMaster(&adapterConfig->bda_teaming)) 
        {
            TRACE_INFO("%!FUNC! duplicate BDA team master assignment found.");
            TRACE_VERB("<-%!FUNC!");
            return S_FALSE;
        }
    }
    
    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

//+----------------------------------------------------------------------------
//
// Function:  WlbsToNetcfgConfig
//
// Description:  
//
// Arguments: const WLBS_REG_PARAMS* pWlbsConfig - 
//            NETCFG_WLBS_CONFIG* pNetcfgConfig - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    2/14/00
//
//+----------------------------------------------------------------------------
void WlbsToNetcfgConfig(const WlbsApiFuncs* pWlbsApiFuncs, const WLBS_REG_PARAMS* pWlbsConfig, NETCFG_WLBS_CONFIG* pNetcfgConfig) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"WlbsToNetcfgConfig");

    ASSERT(pNetcfgConfig != NULL);
    ASSERT(pWlbsConfig != NULL);
    ASSERT(pWlbsApiFuncs);
    ASSERT(pWlbsApiFuncs->pfnWlbsEnumPortRules);

    pNetcfgConfig->dwHostPriority = pWlbsConfig->host_priority;
    pNetcfgConfig->fRctEnabled = (pWlbsConfig->rct_enabled != FALSE);
    pNetcfgConfig->dwInitialState = pWlbsConfig->cluster_mode;
    pNetcfgConfig->dwPersistedStates = pWlbsConfig->persisted_states;
    pNetcfgConfig->fMcastSupport = (pWlbsConfig->mcast_support != FALSE);
    pNetcfgConfig->fIGMPSupport = (pWlbsConfig->fIGMPSupport != FALSE);
    pNetcfgConfig->fIpToMCastIp = (pWlbsConfig->fIpToMCastIp != FALSE);
    pNetcfgConfig->fConvertMac = (pWlbsConfig->i_convert_mac != FALSE);
    pNetcfgConfig->dwMaxHosts = pWlbsConfig->i_max_hosts;
    pNetcfgConfig->dwMaxRules = pWlbsConfig->i_max_rules;

    (VOID) StringCchCopy(pNetcfgConfig->szMCastIpAddress, ASIZECCH(pNetcfgConfig->szMCastIpAddress), pWlbsConfig->szMCastIpAddress);
    (VOID) StringCchCopy(pNetcfgConfig->cl_mac_addr     , ASIZECCH(pNetcfgConfig->cl_mac_addr)     , pWlbsConfig->cl_mac_addr);
    (VOID) StringCchCopy(pNetcfgConfig->cl_ip_addr      , ASIZECCH(pNetcfgConfig->cl_ip_addr)      , pWlbsConfig->cl_ip_addr);
    (VOID) StringCchCopy(pNetcfgConfig->cl_net_mask     , ASIZECCH(pNetcfgConfig->cl_net_mask)     , pWlbsConfig->cl_net_mask);
    (VOID) StringCchCopy(pNetcfgConfig->ded_ip_addr     , ASIZECCH(pNetcfgConfig->ded_ip_addr)     , pWlbsConfig->ded_ip_addr);
    (VOID) StringCchCopy(pNetcfgConfig->ded_net_mask    , ASIZECCH(pNetcfgConfig->ded_net_mask)    , pWlbsConfig->ded_net_mask);
    (VOID) StringCchCopy(pNetcfgConfig->domain_name     , ASIZECCH(pNetcfgConfig->domain_name)     , pWlbsConfig->domain_name);

    pNetcfgConfig->fChangePassword =false;
    pNetcfgConfig->szPassword[0] = L'\0';

    ZeroMemory(pNetcfgConfig->port_rules, sizeof(pNetcfgConfig->port_rules));

    WLBS_PORT_RULE PortRules[WLBS_MAX_RULES];
    DWORD dwNumRules = WLBS_MAX_RULES;

    if (pWlbsApiFuncs->pfnWlbsEnumPortRules((WLBS_REG_PARAMS*)pWlbsConfig, PortRules,  &dwNumRules)!= WLBS_OK) {
        DWORD dwStatus = GetLastError();
        TraceError("CNetcfgCluster::GetConfig failed at WlbsEnumPortRules", dwStatus);
        TRACE_CRIT("%!FUNC! api call to enumerate port rules failed with %d", dwStatus);
        TRACE_VERB("<-%!FUNC!");
        return;
    }

    ASSERT(dwNumRules <= WLBS_MAX_RULES);
    pNetcfgConfig->dwNumRules = dwNumRules; 

    for (DWORD i=0; i<dwNumRules; i++) {
        (VOID) StringCchCopy(pNetcfgConfig->port_rules[i].virtual_ip_addr, ASIZECCH(pNetcfgConfig->port_rules[i].virtual_ip_addr), PortRules[i].virtual_ip_addr);
        pNetcfgConfig->port_rules[i].start_port = PortRules[i].start_port;
        pNetcfgConfig->port_rules[i].end_port = PortRules[i].end_port;
        pNetcfgConfig->port_rules[i].mode = PortRules[i].mode;
        pNetcfgConfig->port_rules[i].protocol = PortRules[i].protocol;

        if (pNetcfgConfig->port_rules[i].mode == WLBS_AFFINITY_SINGLE) {
            pNetcfgConfig->port_rules[i].mode_data.single.priority = 
            PortRules[i].mode_data.single.priority;
        } else {
            pNetcfgConfig->port_rules[i].mode_data.multi.equal_load = 
            PortRules[i].mode_data.multi.equal_load;
            pNetcfgConfig->port_rules[i].mode_data.multi.affinity = 
            PortRules[i].mode_data.multi.affinity;
            pNetcfgConfig->port_rules[i].mode_data.multi.load = 
            PortRules[i].mode_data.multi.load;
        }

    }

    /* Copy the BDA teaming settings. */
    (VOID) StringCchCopy(pNetcfgConfig->bda_teaming.team_id, ASIZECCH(pNetcfgConfig->bda_teaming.team_id), pWlbsConfig->bda_teaming.team_id);
    pNetcfgConfig->bda_teaming.active = pWlbsConfig->bda_teaming.active;
    pNetcfgConfig->bda_teaming.master = pWlbsConfig->bda_teaming.master;
    pNetcfgConfig->bda_teaming.reverse_hash = pWlbsConfig->bda_teaming.reverse_hash;
}

#if DBG
void TraceMsg(PCWSTR pszFormat, ...) {
    static WCHAR szTempBufW[4096];
    static CHAR szTempBufA[4096];

    va_list arglist;

    va_start(arglist, pszFormat);

    (VOID) StringCchVPrintf(szTempBufW, ASIZECCH(szTempBufW), pszFormat, arglist);

    /* Convert the WCHAR to CHAR. This is for backward compatability with TraceMsg 
       so that it was not necessary to change all pre-existing calls thereof. */
    if(WideCharToMultiByte(CP_ACP, 0, szTempBufW, -1, szTempBufA, ASIZECCH(szTempBufA), NULL, NULL) != 0)
    {
        /* Traced messages are now sent through the netcfg TraceTag routine so that 
           they can be turned on/off dynamically. */
        TraceTag(ttidWlbs, szTempBufA);
    }

    va_end(arglist);
}
#endif


#ifdef DEBUG
void CWlbsConfig::AssertValid() {
    ASSERT(m_ServiceOperation >= WLBS_SERVICE_NONE && m_ServiceOperation <= WLBS_SERVICE_UPGRADE);
    ASSERT(m_pNetCfg != NULL);
    ASSERT(m_hdllWlbsCtrl != NULL);
    ASSERT(m_pWlbsApiFuncs != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnParamReadReg != NULL); 
    ASSERT (m_pWlbsApiFuncs->pfnParamWriteReg != NULL); 
    ASSERT (m_pWlbsApiFuncs->pfnParamDeleteReg != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnParamSetDefaults != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnRegChangeNetworkAddress != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnNotifyAdapterAddressChangeEx != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnWlbsAddPortRule != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnWlbsSetRemotePassword != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnWlbsEnumPortRules != NULL);
    ASSERT (m_pWlbsApiFuncs->pfnNotifyDriverConfigChanges != NULL);
    ASSERT(m_vtrCluster.size()<=128);
}    
#endif

//+----------------------------------------------------------------------------
//
// Function:  ParamReadAnswerFile
//
// Description:  
//
// Arguments: CWSTR         answer_file - 
//            PCWSTR         answer_sections - 
//            WLBS_REG_PARAMS*     paramp - 
//
// Returns:   HRESULT - 
//
//      The minimal parameters that must be specified are cluster IP address,
//      cluster network mask and host priority. All others are considered optional.
//      Though the appearance of an optional parameter may make another optional
//      parameter mandatory (e.g. setting IPToMACEnable to false but not providing
//      a cluster MAC address), that is ignored for now.
//
// History: fengsun  Created Header    3/2/00
//          chrisdar 07.13.01 Added tracing and logging to setuperr.log for certain
//                            failures.
//
//+----------------------------------------------------------------------------
HRESULT ParamReadAnswerFile(CSetupInfFile& caf, PCWSTR answer_sections, WLBS_REG_PARAMS* paramp) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"ParamReadAnswerFile");

    HRESULT hr = S_OK;
    tstring str;
    DWORD dword;
    ULONG code;
    INFCONTEXT ctx;
    PWCHAR port_str;
    ULONG           ulDestLen;
    ULONG           ulSourceLen;

    hr = caf.HrGetDword(answer_sections, CVY_NAME_VERSION, & dword);

    if (SUCCEEDED(hr))
    {
        paramp -> i_parms_ver = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_VERSION, paramp -> i_parms_ver);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d", CVY_NAME_VERSION, paramp -> i_parms_ver);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_VERSION);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_VERSION, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_VERSION, paramp -> i_parms_ver);
    }

    // Host priority is a mandatory parameter
    hr = caf.HrGetDword(answer_sections, CVY_NAME_HOST_PRIORITY, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> host_priority = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_HOST_PRIORITY, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_CLUSTER_MODE, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> cluster_mode = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_CLUSTER_MODE, paramp -> cluster_mode);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_CLUSTER_MODE, paramp -> cluster_mode);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_CLUSTER_MODE);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_CLUSTER_MODE, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_CLUSTER_MODE, paramp -> cluster_mode);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_PERSISTED_STATES, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> persisted_states = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_PERSISTED_STATES, paramp -> persisted_states);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_PERSISTED_STATES, paramp -> persisted_states);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_PERSISTED_STATES);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_PERSISTED_STATES, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_PERSISTED_STATES, paramp -> persisted_states);
    }

    hr = caf.HrGetString(answer_sections, CVY_NAME_NETWORK_ADDR, & str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> cl_mac_addr) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> cl_mac_addr, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> cl_mac_addr[ulDestLen] = L'\0'; 
        
        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_NETWORK_ADDR, paramp -> cl_mac_addr);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_NETWORK_ADDR, paramp -> cl_mac_addr);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_NETWORK_ADDR);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_NETWORK_ADDR, hr);
        if (NULL != str.c_str())
        {
            TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %ls", CVY_NAME_NETWORK_ADDR, str.c_str());
        } else {
            TRACE_CRIT("%!FUNC! failed reading %ls. String was not retrieved", CVY_NAME_NETWORK_ADDR);
        }
    }

    // Cluster IP address is a mandatory parameter
    hr = caf.HrGetString(answer_sections, CVY_NAME_CL_IP_ADDR, & str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> cl_ip_addr) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> cl_ip_addr, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> cl_ip_addr[ulDestLen] = L'\0'; 

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_CL_IP_ADDR, paramp -> cl_ip_addr);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_CL_IP_ADDR, paramp -> cl_ip_addr);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_CL_IP_ADDR, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_CL_IP_ADDR);
    }

    // Cluster network mask is a mandatory parameter
    hr = caf.HrGetString(answer_sections, CVY_NAME_CL_NET_MASK, & str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> cl_net_mask) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> cl_net_mask, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> cl_net_mask[ulDestLen] = L'\0'; 

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_CL_NET_MASK, paramp -> cl_net_mask);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_CL_NET_MASK, paramp -> cl_net_mask);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_CL_NET_MASK, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_CL_NET_MASK);
    }

    hr = caf.HrGetString(answer_sections, CVY_NAME_DED_IP_ADDR, & str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> ded_ip_addr) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> ded_ip_addr, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> ded_ip_addr[ulDestLen] = L'\0'; 

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_DED_IP_ADDR, paramp -> ded_ip_addr);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_DED_IP_ADDR, paramp -> ded_ip_addr);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_DED_IP_ADDR);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_DED_IP_ADDR, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls", CVY_NAME_DED_IP_ADDR);
    }

    hr = caf.HrGetString(answer_sections, CVY_NAME_DED_NET_MASK, & str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> ded_net_mask) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> ded_net_mask, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> ded_net_mask[ulDestLen] = L'\0'; 

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_DED_NET_MASK, paramp -> ded_net_mask);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_DED_NET_MASK, paramp -> ded_net_mask);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_DED_NET_MASK);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_DED_NET_MASK, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_DED_NET_MASK);
    }

    hr = caf.HrGetString(answer_sections, CVY_NAME_DOMAIN_NAME, & str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> domain_name) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> domain_name, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> domain_name[ulDestLen] = L'\0'; 

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_DOMAIN_NAME, paramp -> domain_name);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_DOMAIN_NAME, paramp -> domain_name);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_DOMAIN_NAME);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_DOMAIN_NAME, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_DOMAIN_NAME);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_ALIVE_PERIOD, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> alive_period = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_ALIVE_PERIOD, paramp -> alive_period);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_ALIVE_PERIOD, paramp -> alive_period);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_ALIVE_PERIOD);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_ALIVE_PERIOD, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_ALIVE_PERIOD, paramp -> alive_period);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_ALIVE_TOLER, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> alive_tolerance = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_ALIVE_TOLER, paramp -> alive_tolerance);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_ALIVE_TOLER, paramp -> alive_tolerance);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_ALIVE_TOLER);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_ALIVE_TOLER, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_ALIVE_TOLER, paramp -> alive_tolerance);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NUM_ACTIONS, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> num_actions = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NUM_ACTIONS, paramp -> num_actions);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NUM_ACTIONS, paramp -> num_actions);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_NUM_ACTIONS);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_NUM_ACTIONS, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NUM_ACTIONS, paramp -> num_actions);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NUM_PACKETS, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> num_packets = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NUM_PACKETS, paramp -> num_packets);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NUM_PACKETS, paramp -> num_packets);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_NUM_PACKETS);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_NUM_PACKETS, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NUM_PACKETS, paramp -> num_packets);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NUM_SEND_MSGS, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> num_send_msgs = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_NUM_SEND_MSGS);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_NUM_SEND_MSGS, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_DSCR_PER_ALLOC, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> dscr_per_alloc = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_DSCR_PER_ALLOC, paramp -> dscr_per_alloc);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_DSCR_PER_ALLOC, paramp -> dscr_per_alloc);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_DSCR_PER_ALLOC);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_DSCR_PER_ALLOC, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_DSCR_PER_ALLOC, paramp -> dscr_per_alloc);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_TCP_TIMEOUT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> tcp_dscr_timeout = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_TCP_TIMEOUT, paramp -> tcp_dscr_timeout);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_TCP_TIMEOUT, paramp -> tcp_dscr_timeout);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_TCP_TIMEOUT);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_TCP_TIMEOUT, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_TCP_TIMEOUT, paramp -> tcp_dscr_timeout);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_IPSEC_TIMEOUT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> ipsec_dscr_timeout = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_IPSEC_TIMEOUT, paramp -> ipsec_dscr_timeout);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_IPSEC_TIMEOUT, paramp -> ipsec_dscr_timeout);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_IPSEC_TIMEOUT);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_IPSEC_TIMEOUT, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_IPSEC_TIMEOUT, paramp -> ipsec_dscr_timeout);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_FILTER_ICMP, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> filter_icmp = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_FILTER_ICMP, paramp -> filter_icmp);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_FILTER_ICMP, paramp -> filter_icmp);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_FILTER_ICMP);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_FILTER_ICMP, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_FILTER_ICMP, paramp -> filter_icmp);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_MAX_DSCR_ALLOCS, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> max_dscr_allocs = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_MAX_DSCR_ALLOCS);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_MAX_DSCR_ALLOCS, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_SCALE_CLIENT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_scale_client = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_SCALE_CLIENT, paramp -> i_scale_client);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_SCALE_CLIENT, paramp -> i_scale_client);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_SCALE_CLIENT);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_SCALE_CLIENT, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_SCALE_CLIENT, paramp -> i_scale_client);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_CLEANUP_DELAY, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_cleanup_delay = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_CLEANUP_DELAY, paramp -> i_cleanup_delay);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_CLEANUP_DELAY, paramp -> i_cleanup_delay);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_CLEANUP_DELAY);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_CLEANUP_DELAY, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_CLEANUP_DELAY, paramp -> i_cleanup_delay);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NBT_SUPPORT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_nbt_support = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NBT_SUPPORT, paramp -> i_nbt_support);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NBT_SUPPORT, paramp -> i_nbt_support);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_NBT_SUPPORT);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_NBT_SUPPORT, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NBT_SUPPORT, paramp -> i_nbt_support);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_MCAST_SUPPORT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> mcast_support = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_MCAST_SUPPORT);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_MCAST_SUPPORT, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_MCAST_SPOOF, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_mcast_spoof = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_MCAST_SPOOF, paramp -> i_mcast_spoof);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_MCAST_SPOOF, paramp -> i_mcast_spoof);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_MCAST_SPOOF);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_MCAST_SPOOF, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_MCAST_SPOOF, paramp -> i_mcast_spoof);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_MASK_SRC_MAC, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> mask_src_mac = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_MASK_SRC_MAC, paramp -> mask_src_mac);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_MASK_SRC_MAC, paramp -> mask_src_mac);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_MASK_SRC_MAC);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_MASK_SRC_MAC, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_MASK_SRC_MAC, paramp -> mask_src_mac);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NETMON_ALIVE, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_netmon_alive = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NETMON_ALIVE, paramp -> i_netmon_alive);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NETMON_ALIVE, paramp -> i_netmon_alive);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_NETMON_ALIVE);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_NETMON_ALIVE, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NETMON_ALIVE, paramp -> i_netmon_alive);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_IP_CHG_DELAY, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_ip_chg_delay = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_IP_CHG_DELAY, paramp -> i_ip_chg_delay);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_IP_CHG_DELAY, paramp -> i_ip_chg_delay);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_IP_CHG_DELAY);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_IP_CHG_DELAY, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_IP_CHG_DELAY, paramp -> i_ip_chg_delay);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_CONVERT_MAC, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_convert_mac = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_CONVERT_MAC, paramp -> i_convert_mac);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_CONVERT_MAC, paramp -> i_convert_mac);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_CONVERT_MAC);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_CONVERT_MAC, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_CONVERT_MAC, paramp -> i_convert_mac);
    }

    hr = caf.HrGetString(answer_sections, CVY_NAME_LICENSE_KEY, & str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> i_license_key) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> i_license_key, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> i_license_key[ulDestLen] = L'\0'; 

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_LICENSE_KEY, paramp -> i_license_key);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_LICENSE_KEY, paramp -> i_license_key);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_LICENSE_KEY);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_LICENSE_KEY, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_LICENSE_KEY);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_RMT_PASSWORD, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_rmt_password = dword;
        TRACE_VERB("%!FUNC! read %ls %x", CVY_NAME_RMT_PASSWORD, paramp -> i_rmt_password);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %x\n", CVY_NAME_RMT_PASSWORD, paramp -> i_rmt_password);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_RMT_PASSWORD);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_RMT_PASSWORD, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %x", CVY_NAME_RMT_PASSWORD, paramp -> i_rmt_password);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_RCT_PASSWORD, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_rct_password = dword;
        TRACE_VERB("%!FUNC! read %ls %x", CVY_NAME_RCT_PASSWORD, paramp -> i_rct_password);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %x\n", CVY_NAME_RCT_PASSWORD, paramp -> i_rct_password);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_RCT_PASSWORD);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_RCT_PASSWORD, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %x", CVY_NAME_RCT_PASSWORD, paramp -> i_rct_password);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_RCT_PORT, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> rct_port = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_RCT_PORT, paramp -> rct_port);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_RCT_PORT, paramp -> rct_port);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_RCT_PORT);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_RCT_PORT, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_RCT_PORT, paramp -> rct_port);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_RCT_ENABLED, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> rct_enabled = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_RCT_ENABLED, paramp -> rct_enabled);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_RCT_ENABLED, paramp -> rct_enabled);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_RCT_ENABLED);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_RCT_ENABLED, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_RCT_ENABLED, paramp -> rct_enabled);
    }

    hr = caf.HrGetString(answer_sections, CVY_NAME_PASSWORD, & str);

    if (SUCCEEDED(hr)) {
        WCHAR passw [LICENSE_STR_IMPORTANT_CHARS + 1];

        ulDestLen = (sizeof (passw) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(passw, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        passw[ulDestLen] = L'\0'; 


        paramp -> i_rct_password = License_wstring_encode (passw);

        TRACE_VERB("%!FUNC! read %ls %ls %x", CVY_NAME_PASSWORD, passw, paramp -> i_rct_password);
        TraceMsg(TEXT("#### ParamReadAnswerFile read %ls %ls %x\n"), CVY_NAME_PASSWORD, passw, paramp -> i_rct_password);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_PASSWORD);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_PASSWORD, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_PASSWORD);        
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_ID_HB_PERIOD, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> identity_period = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_ID_HB_PERIOD, paramp -> identity_period);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_ID_HB_PERIOD, paramp -> identity_period);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_ID_HB_PERIOD);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_ID_HB_PERIOD, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_ID_HB_PERIOD, paramp -> identity_period);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_ID_HB_ENABLED, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> identity_enabled = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_ID_HB_ENABLED, paramp -> identity_enabled);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_ID_HB_ENABLED, paramp -> identity_enabled);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_ID_HB_ENABLED);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_ID_HB_ENABLED, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_ID_HB_ENABLED, paramp -> identity_enabled);
    }

    /* IGMP support. */
    hr = caf.HrGetDword(answer_sections, CVY_NAME_IGMP_SUPPORT, &dword);

    if (SUCCEEDED(hr)) {
        // Since we read a DWORD and want a BOOL be paranoid. Assume FALSE is a fixed integer value (should be 0). Anything else will be TRUE.
        paramp->fIGMPSupport = TRUE;
        if (FALSE == dword) paramp->fIGMPSupport = FALSE;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_IGMP_SUPPORT, paramp->fIGMPSupport);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_IGMP_SUPPORT, paramp->fIGMPSupport);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_IGMP_SUPPORT);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_IGMP_SUPPORT, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_IGMP_SUPPORT, paramp->fIGMPSupport);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_IP_TO_MCASTIP, &dword);

    if (SUCCEEDED(hr)) {
        // Since we read a DWORD and want a BOOL be paranoid. Assume FALSE is a fixed integer value (should be 0). Anything else will be TRUE.
        paramp->fIpToMCastIp = TRUE;
        if (FALSE == dword) paramp->fIpToMCastIp = FALSE;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_IP_TO_MCASTIP, paramp->fIpToMCastIp);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_IP_TO_MCASTIP, paramp->fIpToMCastIp);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_IP_TO_MCASTIP);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_IP_TO_MCASTIP, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_IP_TO_MCASTIP, paramp->fIpToMCastIp);
    }

    hr = caf.HrGetString(answer_sections, CVY_NAME_MCAST_IP_ADDR, &str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> szMCastIpAddress) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> szMCastIpAddress, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> szMCastIpAddress[ulDestLen] = L'\0'; 

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_MCAST_IP_ADDR, paramp->szMCastIpAddress);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_MCAST_IP_ADDR, paramp->szMCastIpAddress);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_MCAST_IP_ADDR);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_MCAST_IP_ADDR, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_MCAST_IP_ADDR);
    }
    /* End IGMP support. */

    /* BDA support */

    // Read the team id, which must be a GUID with "{}" included
    hr = caf.HrGetString(answer_sections, CVY_NAME_BDA_TEAM_ID, &str);

    if (SUCCEEDED(hr)) {
        ulDestLen = (sizeof (paramp -> bda_teaming . team_id) / sizeof (WCHAR)) - 1;
        ulSourceLen = wcslen(str.c_str());
        wcsncpy(paramp -> bda_teaming . team_id, str.c_str(), ulSourceLen > ulDestLen ? ulDestLen : ulSourceLen + 1);
        // Terminate the end of the destination with a NULL, even in the case that we don't need to. It's simpler than checking if we need to.
        paramp -> bda_teaming . team_id [ulDestLen] = L'\0'; 

        //
        // Since we read a team id, we assume that the user intends to run BDA, even though it may turn out that the
        // supplied id may not be a valid one. Set the active flag so that WriteRegParams knows we are gonna be teamed
        //
        paramp->bda_teaming.active = TRUE;

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_BDA_TEAM_ID, paramp->bda_teaming.team_id);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_BDA_TEAM_ID, paramp->bda_teaming.team_id);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_BDA_TEAM_ID);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_BDA_TEAM_ID, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_BDA_TEAM_ID);
    }

    // Read the BDA "master" property
    hr = caf.HrGetDword(answer_sections, CVY_NAME_BDA_MASTER, &dword);

    if (SUCCEEDED(hr)) {
        // Since we read a DWORD and want a BOOL be paranoid. Assume FALSE is a fixed integer value (should be 0). Anything else will be TRUE.
        paramp->bda_teaming.master = TRUE;
        if (FALSE == dword) paramp->bda_teaming.master = FALSE;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_BDA_MASTER, paramp->bda_teaming.master);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_BDA_MASTER, paramp->bda_teaming.master);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_BDA_MASTER);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_BDA_MASTER, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_BDA_MASTER, paramp->bda_teaming.master);
    }

    // Read the reverse_hash property
    hr = caf.HrGetDword(answer_sections, CVY_NAME_BDA_REVERSE_HASH, &dword);

    if (SUCCEEDED(hr)) {
        // Since we read a DWORD and want a BOOL be paranoid. Assume FALSE is a fixed integer value (should be 0). Anything else will be TRUE.
        paramp->bda_teaming.reverse_hash = TRUE;
        if (FALSE == dword) paramp->bda_teaming.reverse_hash = FALSE;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_BDA_REVERSE_HASH, paramp->bda_teaming.reverse_hash);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_BDA_REVERSE_HASH, paramp->bda_teaming.reverse_hash);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_BDA_REVERSE_HASH);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_BDA_REVERSE_HASH, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_BDA_REVERSE_HASH, paramp->bda_teaming.reverse_hash);
    }

    /* End BDA support */

    hr = HrSetupGetFirstMultiSzFieldWithAlloc(caf.Hinf(), answer_sections, CVY_NAME_PORTS, & port_str);

    if (SUCCEEDED(hr)) {
        PWCHAR ptr;
        PWLBS_PORT_RULE rp, rulep;

        /* distinct rule elements for parsing */

        typedef enum
        {
            vip,
            start,
            end,
            protocol,
            mode,
            affinity,
            load,
            priority
        }
        CVY_RULE_ELEMENT;

        CVY_RULE_ELEMENT elem = vip;
        DWORD count = 0;
        DWORD i;
        DWORD dwVipLen = 0;
        const DWORD dwVipAllNameLen = sizeof(CVY_NAME_PORTRULE_VIPALL)/sizeof(WCHAR) - 1; // Used below in a loop. Set it here since it is a constant.
        WCHAR wszTraceOutputTmp[WLBS_MAX_CL_IP_ADDR + 1];
        bool bFallThrough = false; // Used in 'vip' case statement below.

        ptr = port_str;

        TRACE_VERB("%!FUNC! %ls", ptr);
        TraceMsg(L"%ls\n", ptr);

        while (!(*ptr == 0 && *(ptr+1) == 0)) {
            if (*ptr == 0) {
                *ptr = L',';
                TRACE_VERB("%!FUNC! %ls", ptr);
                TraceMsg(L"%ls\n", ptr);
            }

            ptr++;
        }

        TRACE_VERB("%!FUNC! read %ls %ls", CVY_NAME_PORTS, port_str);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %ls\n", CVY_NAME_PORTS, port_str);

        rulep = paramp->i_port_rules;
        ptr = port_str;

        while (ptr != NULL) {
            switch (elem) {
                case vip:
                    // DO NOT MOVE THIS CASE STATEMENT. IT MUST ALWAYS COME BEFORE THE 'start' CASE STATEMENT. See FALLTHROUGH comment below.
                    bFallThrough = false;
                    dwVipLen = 0;
                    if (ValidateVipInRule(ptr, L',', dwVipLen))
                    {
                        ASSERT(dwVipLen <= WLBS_MAX_CL_IP_ADDR);

                        // rulep->virtual_ip_addr is a TCHAR and ptr is a WCHAR.
                        // Data is moved from the latter to the former so ASSERT TCHAR is WCHAR.
                        ASSERT(sizeof(TCHAR) == sizeof(WCHAR));

                        // This is a rule for a specific VIP
                        _tcsncpy(rulep->virtual_ip_addr, ptr, dwVipLen);
                        (rulep->virtual_ip_addr)[dwVipLen] = '\0';
                    }
                    else
                    {
                        // This is either an 'all' rule, a VIP-less rule or a malformed rule. We can't distinguish a malformed rule
                        // from a VIP-less rule, so we will assume the rule is either an 'all' rule or a VIP-less rule. In both cases
                        // set the VIP component of the rule to be the default or 'all' value.

                        // Copy the 'all' IP into the rule.
                        (VOID) StringCchCopy(rulep->virtual_ip_addr, ASIZECCH(rulep->virtual_ip_addr), CVY_DEF_ALL_VIP);

                        if (dwVipAllNameLen != dwVipLen || (_tcsnicmp(ptr, CVY_NAME_PORTRULE_VIPALL, dwVipAllNameLen) != 0))
                        {
                            // The rule is either VIP-less or it is malformed. We assume it is VIP-less and let the 'start'
                            // case handle the current token as a start_port property by falling through to the next case clause
                            // rather than breaking.
                            bFallThrough = true;

                            _tcsncpy(wszTraceOutputTmp, ptr, dwVipLen);
                            wszTraceOutputTmp[dwVipLen] = '\0';
                            TRACE_VERB("%!FUNC! VIP element of port rule is invalid = %ls", wszTraceOutputTmp);
                            TraceMsg(L"-----\n#### VIP element of port rule is invalid = %s\n", wszTraceOutputTmp);
                        }
                    }
                    TRACE_VERB("%!FUNC! Port rule vip = %ls", rulep->virtual_ip_addr);
                    TraceMsg(L"-----\n#### Port rule vip = %s\n", rulep->virtual_ip_addr);
                    
                    elem = start;
                    // !!!!!!!!!!!!!!!!!!!!
                    // FALLTHROUGH
                    // !!!!!!!!!!!!!!!!!!!!
                    // When we have a VIP-less port rule, we will fall through this case statement into the 'start' case statement
                    // below so that the current token can be used as the start_port for a port rule.
                    if (!bFallThrough)
                    {
                        // We have a VIP in the port rule. We do a "break;" as std operating procedure.
                        TRACE_VERB("%!FUNC! Fallthrough case statement from port rule vip to start");
                        TraceMsg(L"-----\n#### Fallthrough case statement from port rule vip to start\n");
                        break;
                    }
                    // NO AUTOMATIC "break;" STATEMENT HERE. Above, we conditionally flow to the 'start' case...
                case start:
                    // DO NOT MOVE THIS CASE STATEMENT. IT MUST ALWAYS COME AFTER THE 'vip' CASE STATEMENT.
                    // See comments (FALLTHROUGH) inside the 'vip' case statement.
                    rulep->start_port = _wtoi(ptr);
//                    CVY_CHECK_MIN (rulep->start_port, CVY_MIN_PORT);
                    CVY_CHECK_MAX (rulep->start_port, CVY_MAX_PORT);
                    TRACE_VERB("%!FUNC! Start port   = %d", rulep->start_port);
                    TraceMsg(L"-----\n#### Start port   = %d\n", rulep->start_port);
                    elem = end;
                    break;
                case end:
                    rulep->end_port = _wtoi(ptr);
//                    CVY_CHECK_MIN (rulep->end_port, CVY_MIN_PORT);
                    CVY_CHECK_MAX (rulep->end_port, CVY_MAX_PORT);
                    TRACE_VERB("%!FUNC! End port     = %d", rulep->end_port);
                    TraceMsg(L"#### End port     = %d\n", rulep->end_port);
                    elem = protocol;
                    break;
                case protocol:
                    switch (ptr [0]) {
                        case L'T':
                        case L't':
                            rulep->protocol = CVY_TCP;
                            TRACE_VERB("%!FUNC! Protocol     = TCP");
                            TraceMsg(L"#### Protocol     = TCP\n");
                            break;
                        case L'U':
                        case L'u':
                            rulep->protocol = CVY_UDP;
                            TRACE_VERB("%!FUNC! Protocol     = UDP");
                            TraceMsg(L"#### Protocol     = UDP\n");
                            break;
                        default:
                            rulep->protocol = CVY_TCP_UDP;
                            TRACE_VERB("%!FUNC! Protocol     = Both");
                            TraceMsg(L"#### Protocol     = Both\n");
                            break;
                    }

                    elem = mode;
                    break;
                case mode:
                    switch (ptr [0]) {
                        case L'D':
                        case L'd':
                            rulep->mode = CVY_NEVER;
                            TRACE_VERB("%!FUNC! Mode         = Disabled");
                            TraceMsg(L"#### Mode         = Disabled\n");
                            goto end_rule;
                        case L'S':
                        case L's':
                            rulep->mode = CVY_SINGLE;
                            TRACE_VERB("%!FUNC! Mode         = Single");
                            TraceMsg(L"#### Mode         = Single\n");
                            elem = priority;
                            break;
                        default:
                            rulep->mode = CVY_MULTI;
                            TRACE_VERB("%!FUNC! Mode         = Multiple");
                            TraceMsg(L"#### Mode         = Multiple\n");
                            elem = affinity;
                            break;
                    }
                    break;
                case affinity:
                    switch (ptr [0]) {
                        case L'C':
                        case L'c':
                            rulep->mode_data.multi.affinity = CVY_AFFINITY_CLASSC;
                            TRACE_VERB("%!FUNC! Affinity     = Class C");
                            TraceMsg(L"#### Affinity     = Class C\n");
                            break;
                        case L'N':
                        case L'n':
                            rulep->mode_data.multi.affinity = CVY_AFFINITY_NONE;
                            TRACE_VERB("%!FUNC! Affinity     = None");
                            TraceMsg(L"#### Affinity     = None\n");
                            break;
                        default:
                            rulep->mode_data.multi.affinity = CVY_AFFINITY_SINGLE;
                            TRACE_VERB("%!FUNC! Affinity     = Single");
                            TraceMsg(L"#### Affinity     = Single\n");
                            break;
                    }

                    elem = load;
                    break;
                case load:
                    if (ptr [0] == L'E' || ptr [0] == L'e') {
                        rulep->mode_data.multi.equal_load = TRUE;
                        rulep->mode_data.multi.load       = CVY_DEF_LOAD;
                        TRACE_VERB("%!FUNC! Load         = Equal");
                        TraceMsg(L"#### Load         = Equal\n");
                    } else {
                        rulep->mode_data.multi.equal_load = FALSE;
                        rulep->mode_data.multi.load       = _wtoi(ptr);
//                        CVY_CHECK_MIN (rulep->mode_data.multi.load, CVY_MIN_LOAD);
                        CVY_CHECK_MAX (rulep->mode_data.multi.load, CVY_MAX_LOAD);
                        TRACE_VERB("%!FUNC! Load         = %d", rulep->mode_data.multi.load);
                        TraceMsg(L"#### Load         = %d\n", rulep->mode_data.multi.load);
                    }
                    goto end_rule;
                case priority:
                    rulep->mode_data.single.priority = _wtoi(ptr);
                    CVY_CHECK_MIN (rulep->mode_data.single.priority, CVY_MIN_PRIORITY);
                    CVY_CHECK_MAX (rulep->mode_data.single.priority, CVY_MAX_PRIORITY);
                    TRACE_VERB("%!FUNC! Priority     = %d", rulep->mode_data.single.priority);
                    TraceMsg(L"#### Priority     = %d\n", rulep->mode_data.single.priority);
                    goto end_rule;
                default:
                    TRACE_VERB("%!FUNC! Bad rule element %d", elem);
                    TraceMsg(L"#### Bad rule element %d\n", elem);
                    break;
            }

        next_field:

            ptr = wcschr(ptr, L',');

            if (ptr != NULL) {
                ptr ++;
                continue;
            } else break;

        end_rule:

            elem = vip;

            for (i = 0; i < count; i ++) {
                rp = paramp->i_port_rules + i;

                if ((rulep -> start_port < rp -> start_port &&
                     rulep -> end_port >= rp -> start_port) ||
                    (rulep -> start_port >= rp -> start_port &&
                     rulep -> start_port <= rp -> end_port) &&
                    (wcscmp(rulep -> virtual_ip_addr, rp -> virtual_ip_addr) == 0))
                {
                    TRACE_VERB("%!FUNC! Rule %d (%d - %d) overlaps with rule %d (%d - %d)", i, rp -> start_port, rp -> end_port, count, rulep -> start_port, rulep -> end_port);
                    TraceMsg(L"#### Rule %d (%d - %d) overlaps with rule %d (%d - %d)\n", i, rp -> start_port, rp -> end_port, count, rulep -> start_port, rulep -> end_port);
                    break;
                }
            }

            rulep -> valid = TRUE;
            CVY_RULE_CODE_SET (rulep);

            if (i >= count) {
                count++;
                rulep++;

                if (count >= CVY_MAX_RULES) break;
            }

            goto next_field;
        }

        TRACE_VERB("%!FUNC! Port rules   = %d", count);
        TraceMsg(L"-----\n#### Port rules   = %d\n", count);
        paramp->i_num_rules = count;

        delete [] port_str;
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_PORTS);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_PORTS, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls.", CVY_NAME_PORTS);
    }

    hr = caf.HrGetDword(answer_sections, CVY_NAME_NUM_RULES, & dword);

    if (SUCCEEDED(hr)) {
        paramp -> i_num_rules = dword;
        TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_NUM_RULES, paramp -> i_num_rules);
        TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_NUM_RULES, paramp -> i_num_rules);
    }
    else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_NUM_RULES);
    }
    else
    {
        WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_NUM_RULES, hr);
        TRACE_CRIT("%!FUNC! failed reading %ls. Retrieved %d", CVY_NAME_NUM_RULES, paramp -> i_num_rules);
    }

    WLBS_OLD_PORT_RULE  old_port_rules [WLBS_MAX_RULES];

    hr = HrSetupFindFirstLine (caf.Hinf(), answer_sections, CVY_NAME_OLD_PORT_RULES, & ctx);

    if (SUCCEEDED(hr)) {
        // hr = HrSetupGetBinaryField (ctx, 1, (PBYTE) paramp -> i_port_rules, sizeof (paramp -> i_port_rules), & dword);
        hr = HrSetupGetBinaryField (ctx, 1, (PBYTE) old_port_rules, sizeof (old_port_rules), & dword);

        if (SUCCEEDED(hr)) {
            TRACE_VERB("%!FUNC! read %ls %d", CVY_NAME_OLD_PORT_RULES, dword);
            TraceMsg(L"#### ParamReadAnswerFile read %ls %d\n", CVY_NAME_OLD_PORT_RULES, dword);

            if (dword % sizeof (WLBS_OLD_PORT_RULE) != 0 ||
                paramp -> i_num_rules != dword / sizeof (WLBS_OLD_PORT_RULE)) {
                TRACE_VERB("%!FUNC! bad port rules length %d %d %d", paramp -> i_num_rules, sizeof (WLBS_OLD_PORT_RULE), dword);
                TraceMsg(L"#### ParamReadAnswerFile bad port rules length %d %d %d\n", paramp -> i_num_rules, sizeof (WLBS_OLD_PORT_RULE), dword),
                paramp -> i_num_rules = 0;
            }
            else // Convert the port rules to new format
            {
                if (paramp -> i_parms_ver > 3) 
                {
                    TransformOldPortRulesToNew(old_port_rules, paramp -> i_port_rules, paramp -> i_num_rules); // Returns void
                    TRACE_INFO("%!FUNC! transformed binary port rules to current format");
                }
                else
                {
                    TRACE_INFO("%!FUNC! will not transform port rules to current format because param version is <=3: %d", paramp -> i_parms_ver);
                }
            }
        }
        else if ((SPAPI_E_LINE_NOT_FOUND == hr) || (SPAPI_E_SECTION_NOT_FOUND == hr))
        {
            paramp -> i_num_rules = 0;
            TRACE_INFO("%!FUNC! optional parameter %ls not provided", CVY_NAME_OLD_PORT_RULES);
        }
        else
        {
            paramp -> i_num_rules = 0;
            WriteNlbSetupErrorLog(IDS_PARM_GET_VALUE_FAILED, CVY_NAME_OLD_PORT_RULES, hr);
            TRACE_CRIT("%!FUNC! failed retrieve of binary port rules %ls while reading %d", CVY_NAME_OLD_PORT_RULES, dword);
        }
    }
    else // Did the answer file contain port rules in the non-binary form and ParametersVersion <= 3 ?
    {
        if ((paramp -> i_parms_ver <= 3) && (paramp -> i_num_rules > 0))
        {
            TRACE_VERB("%!FUNC! Answer file contains port rules in the non-binary format and yet the version number is <=3, Assuming default port rule");
            TraceMsg(L"#### ParamReadAnswerFile Answer file contains port rules in the non-binary format and yet the version number is <=3, Assuming default port rule\n");
            paramp -> i_num_rules = 0;
        }
    }

    /* decode port rules prior to version 3 */
    if (paramp -> i_parms_ver <= 3) {
        TRACE_VERB("%!FUNC! converting port rules from version <= 3");
        TraceMsg(L"#### ParamReadAnswerFile converting port rules from version 3\n");

        paramp -> i_parms_ver = CVY_PARAMS_VERSION;

        /* decode the port rules */

        if (paramp -> i_num_rules > 0)
        {
            if (! License_data_decode ((PCHAR) old_port_rules, paramp -> i_num_rules * sizeof (WLBS_OLD_PORT_RULE))) 
            {
                paramp -> i_num_rules = 0;
                WriteNlbSetupErrorLog(IDS_PARM_LICENSE_DECODE_FAILED);
                TRACE_CRIT("%!FUNC! license data decode failed. Port rules will not be converted to new format.");
            }
            else
            {
                TransformOldPortRulesToNew(old_port_rules, paramp -> i_port_rules, paramp -> i_num_rules);
                TRACE_INFO("%!FUNC! transformed port rules to current format. Old port rule version = %d", paramp -> i_parms_ver);
            }
        }
        else
        {
            TRACE_INFO("%!FUNC! there were no port rules to transform");
        }
    }

    /* upgrade port rules from params V1 to params V2 */

    if (paramp -> i_parms_ver == 1) {
        paramp -> i_parms_ver = CVY_PARAMS_VERSION;

        TRACE_VERB("%!FUNC! converting from version 1");
        TraceMsg(L"#### ParamReadAnswerFile converting from version 1\n");

        /* keep multicast off by default for old users */

        paramp -> mcast_support = FALSE;

        for (ULONG i = 0; i < paramp -> i_num_rules; i ++) {
            PWLBS_PORT_RULE rp = paramp -> i_port_rules + i;

            code = CVY_RULE_CODE_GET (rp);

            CVY_RULE_CODE_SET (rp);

            if (code != CVY_RULE_CODE_GET (rp)) {
                rp -> code = code;
                TRACE_INFO("%!FUNC! (early exit) port rule %d transformed to current version from version 1", i);
                continue;
            }

            if (! rp -> valid) {
                WriteNlbSetupErrorLog(IDS_PARM_PORT_RULE_INVALID, i);
                TRACE_CRIT("%!FUNC! port rule %d (version 1 format) is not valid and will be skipped", i);
                continue;
            }

            /* set affinity according to current ScaleSingleClient setting */

            if (rp -> mode == CVY_MULTI)
                rp -> mode_data . multi . affinity = (WORD)(CVY_AFFINITY_SINGLE - paramp -> i_scale_client);

            CVY_RULE_CODE_SET (rp);
            TRACE_INFO("%!FUNC! port rule %d transformed to current version from version 1", i);
        }
    }

    /* upgrade max number of descriptor allocs */

    if (paramp -> i_parms_ver == 2) {
        TRACE_VERB("%!FUNC! upgrading descriptor settings from version 2 parameters to current");
        TraceMsg(L"#### ParamReadAnswerFile converting port rules from version 2\n");

        paramp -> i_parms_ver = CVY_PARAMS_VERSION;
        paramp -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;
        paramp -> dscr_per_alloc  = CVY_DEF_DSCR_PER_ALLOC;
    }

    paramp -> i_max_hosts        = CVY_MAX_HOSTS;
    paramp -> i_max_rules        = CVY_MAX_USABLE_RULES;

//    CVY_CHECK_MIN (paramp -> i_num_rules, CVY_MIN_NUM_RULES);
    CVY_CHECK_MAX (paramp -> i_num_rules, CVY_MAX_NUM_RULES);
    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

    TRACE_VERB("<-%!FUNC!");
    return S_OK;

}

//+----------------------------------------------------------------------------
//
// Function:  RemoveAllPortRules
//
// Description:  Remove all port rules from PWLBS_REG_PARAMS
//
// Arguments: PWLBS_REG_PARAMS reg_data - 
//
// Returns:   Nothing
//
// History: fengsun  Created Header    3/2/00
//
//+----------------------------------------------------------------------------
void RemoveAllPortRules(PWLBS_REG_PARAMS reg_data) {
    TRACE_VERB("->%!FUNC!");
    TraceMsg(L"RemoveAllPortRules");

    reg_data -> i_num_rules = 0;

    ZeroMemory(reg_data -> i_port_rules, sizeof(reg_data -> i_port_rules));
    TRACE_VERB("<-%!FUNC!");
}

//+----------------------------------------------------------------------------
//
// Function:  GetAdapterFromGuid
//
// Description:  
//
// Arguments: INetCfg *pNetCfg - 
//            const GUID& NetCardGuid - 
//            OUT INetCfgComponent** ppNetCardComponent - 
//
// Returns:   HRESULT - 
//
// History:   fengsun Created Header    1/21/00
//
//+----------------------------------------------------------------------------
HRESULT GetAdapterFromGuid(INetCfg *pNetCfg, const GUID& NetCardGuid, OUT INetCfgComponent** ppNetCardComponent) {
    TRACE_VERB("->%!FUNC!");

    *ppNetCardComponent = NULL;
    HRESULT hr = S_OK;
    INetCfgClass *pNetCfgClass = NULL;
    BOOL fFoundMatch = FALSE;

    hr = pNetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NET, IID_INetCfgClass, (void **)&pNetCfgClass);

    if (FAILED(hr)) {
        TraceError("INetCfg::QueryNetCfgClass failed", hr);
        TRACE_CRIT("%!FUNC! QueryNetCfgClass failed with %d", hr);
        return hr; 
    }

    /* Get an enumerator to list all network devices. */
    IEnumNetCfgComponent *pIEnumComponents = NULL;

    if (FAILED(hr = pNetCfgClass->EnumComponents(&pIEnumComponents))) {
        TraceError("INetCfg::EnumComponents failed", hr);
        TRACE_CRIT("%!FUNC! failed enumerating components with %d", hr);
        pNetCfgClass->Release();
        return hr;
    }

    /* Go through all the components and bind to the matching netcard. */
    while (pIEnumComponents->Next(1, ppNetCardComponent, NULL) == S_OK) {
        GUID guidInstance; 

        /* Retrieve the instance GUID of the component. */
        if (FAILED(hr = (*ppNetCardComponent)->GetInstanceGuid(&guidInstance))) {
            TraceError("GetInstanceGuid failed", hr);
            TRACE_CRIT("%!FUNC! getting instance guid from the net card failed with %d", hr);
            continue;
        }

        /* Check whether we found a match. */
        if (IsEqualGUID(NetCardGuid, guidInstance)) {
            fFoundMatch = TRUE; 
            TRACE_INFO("%!FUNC! netcard matched to component");
            break;
        }

        (*ppNetCardComponent)->Release();
        *ppNetCardComponent = NULL;
    }

    if (!fFoundMatch) {
        TraceMsg(L"Found no netcard\n");
        TRACE_CRIT("%!FUNC! no adapter found with the input GUID");
        hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND );
    }

    if (pIEnumComponents) pIEnumComponents->Release();

    if (pNetCfgClass) pNetCfgClass->Release();

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

//+----------------------------------------------------------------------------
//
// Function:  WriteAdapterName
//
// Description:  
//
// Arguments: CWlbsConfig* pConfig - 
//            GUID& AdapterGuid - 
//
// Returns:   bool - 
//
// History: fengsun  Created Header    7/6/00
//
//+----------------------------------------------------------------------------
bool WriteAdapterName(CWlbsConfig* pConfig, GUID& AdapterGuid) {
    TRACE_VERB("->%!FUNC!");

    PWSTR pszPnpDevNodeId = NULL;
    HKEY key;
    DWORD status;
    HRESULT hr;

    INetCfgComponent* pAdapter = NULL;

    hr = GetAdapterFromGuid(pConfig->m_pNetCfg, AdapterGuid, &pAdapter);

    if (hr != S_OK) {
        TraceError("GetAdapterFromGuid failed at GetPnpDevNodeId", hr);
        TRACE_CRIT("%!FUNC! GetAdapterFromGuid failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    hr = pAdapter->GetPnpDevNodeId (& pszPnpDevNodeId);

    pAdapter->Release();
    pAdapter = NULL;

    if (hr != S_OK) {
        TraceError("HrWriteAdapterName failed at GetPnpDevNodeId", hr);
        TRACE_CRIT("%!FUNC! GetPnpDevNodeId on adapter failed with %d", hr);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    key = pConfig->m_pWlbsApiFuncs->pfnRegOpenWlbsSetting(AdapterGuid, false);

    if (key == NULL) {
        status = GetLastError();
        TraceError("HrWriteAdapterName failed at RegOpenWlbsSetting", status);
        CoTaskMemFree(pszPnpDevNodeId);
        TRACE_CRIT("%!FUNC! RegOpenWlbsSetting failed with %d", status);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    status = RegSetValueEx (key, CVY_NAME_CLUSTER_NIC, 0L, CVY_TYPE_CLUSTER_NIC, (LPBYTE) pszPnpDevNodeId, wcslen(pszPnpDevNodeId) * sizeof (WCHAR));

    CoTaskMemFree(pszPnpDevNodeId);

    RegCloseKey(key);

    if (status != ERROR_SUCCESS) {
        TraceError("HrWriteAdapterName failed at RegSetValueEx", status);
        TRACE_CRIT("%!FUNC! RegSetValueEx failed with %d", status);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    TRACE_VERB("<-%!FUNC!");
    return true;
}

/*
 * Function: WriteIPSecNLBRegistryKey
 * Description: This function updates IPSec as to the current binding state
 *              of NLB.  That is, if NLB is bound to at least one adapter on
 *              this host, we notify IPSec so that they begin to notify us
 *              when IPSec sessions are created and destroyed.  This is 
 *              usually accomplished through an RPC call to the IPSec service;
 *              however, if the service is unavailable, we attempt to create
 *              or modify the key(s) ourselves.
 * Parameters: dwNLBSFlags - the current value of the NLB flags to pass to IPSec
 * Returns: boolean - true if successful, false otherwise
 * Author: shouse, 11.27.01
 */
bool WriteIPSecNLBRegistryKey (DWORD dwNLBSFlags) {
    IKE_CONFIG IKEConfig; /* Defined in winipsec.h */
    bool       bForceUpdate = false;
    DWORD dwDisposition =0;
    HKEY       registry;
    DWORD      key_type;
    DWORD      key_size = sizeof(DWORD);
    DWORD      tmp;

    ZeroMemory(&IKEConfig, sizeof(IKE_CONFIG));
    
    /* If it failed because the RPC server was unavailable, then the IPSec
       service is not currently running - this happens certainly during 
       upgrades and installs, but can also happen if the service has been
       purposefully stopped.  In this case, try to create the keys ourselves
       and IPSec will pick up the changes when the service is re-started. */
    if (GetConfigurationVariables(NULL, &IKEConfig) != ERROR_SUCCESS) {
        
        TRACE_CRIT("%!FUNC! IPSec RPC server unavailable... Trying to read registry settings manually");
        
        /* Try to open the Oakley (IKE) settings registry key. */
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\PolicyAgent\\Oakley", 0, KEY_QUERY_VALUE, &registry) == ERROR_SUCCESS) {
            
            /* Try to query the current value of the NLBSFlags. */
            if (RegQueryValueEx(registry, L"NLBSFlags", 0, &key_type, (unsigned char *)&tmp, &key_size) == ERROR_SUCCESS) {
                
                /* If successful, store the retrieved value in the IKEConfig structure. */
                IKEConfig.dwNLBSFlags = tmp;
                
            } else {
                
                TRACE_INFO("%!FUNC! Unable to read NLBSFlags registry value... Will force a write to try to create it");

                /* If querying the key failed, it might not yet exist, so force an 
                   update to attempt to create the key later. */
                bForceUpdate = true;
                
            }        
            
            /* Close the Oakley registry key. */
            RegCloseKey(registry);
            
        } else {
            
            TRACE_INFO("%!FUNC! Unable to open Oakley registry key... Will force a write to try to create it");

            /* If we can't open the Oakley registry key, it might not yet exist, 
               so force an update to try to create it ourselves later. */
            bForceUpdate = true;
            
        }        

        /* If the registry contains the same flag value that we're trying to set
           it to, there is no reason to proceed unless we're forcing an update. */
        if (!bForceUpdate && (IKEConfig.dwNLBSFlags == dwNLBSFlags))
            return true;
        
        /* Set the NLB flags - this tells IPSec whether or not NLB is bound to at least one adapter. */
        IKEConfig.dwNLBSFlags = dwNLBSFlags;

    } else {

        /* If the registry contains the same flag value that we're trying to set
           it to, there is no reason to proceed. */
        if (IKEConfig.dwNLBSFlags == dwNLBSFlags)
            return true;
        
        /* Set the NLB flags - this tells IPSec whether or not NLB is bound to at least one adapter. */
        IKEConfig.dwNLBSFlags = dwNLBSFlags;
        
        /* Set the new configuration, of which only the NLB flags are changed.  Only attempt 
           this if the corresponding RPC read succeeded.  Note that the value of dwStatus is 
           only set by the GetConfigurationVariables and SetConfigurationVariables RPC calls. */
        if (SetConfigurationVariables(NULL, IKEConfig) == ERROR_SUCCESS)
            return true;
    }    

    TRACE_CRIT("%!FUNC! IPSec RPC server unavailable... Trying to write registry settings manually");
    
    /* Try to open the Oakley registry key. */
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\PolicyAgent\\Oakley", 0, KEY_SET_VALUE, &registry) != ERROR_SUCCESS) {
        
        /* If opening the key fails, it might not exist, so try to create it. */
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Services\\PolicyAgent\\Oakley", 0, NULL, 0, KEY_ALL_ACCESS, NULL, &registry, &dwDisposition) != ERROR_SUCCESS) {
            
            TRACE_CRIT("%!FUNC! Unable to create Oakley registry key");
            
            /* If we can't create the key, we're hosed; bail out. */
            return false;
        }
    }
    
    /* Now try to set the new value of the NLBSFlags settings. */
    if (RegSetValueEx(registry, L"NLBSFlags", 0, REG_DWORD, (unsigned char *)&IKEConfig.dwNLBSFlags, sizeof(DWORD)) != ERROR_SUCCESS) {
        
        /* If setting the value fails, close the Oakley key and bail out. */
        RegCloseKey(registry);
        
        TRACE_CRIT("%!FUNC! Unable to write NLBSFlags registry value");
        
        return false;
    }
    
    /* Now that we've successfully updated the NLB settings, close the Oakley key. */
    RegCloseKey(registry);

    /* Return successfully. */
    return true;
}

/* 
 * Function: WriteHostStateRegistryKey
 * Description: This function writes the HostState registry key, which is the key
 *              that the driver will use to determine the state of the host on boot.
 * Author: shouse, 7.22.01
 * Notes: 
 */
bool WriteHostStateRegistryKey (CWlbsConfig * pConfig, GUID & AdapterGuid, ULONG State) {
    HKEY    key;
    DWORD   status;
    HRESULT hr;

    TRACE_VERB("->%!FUNC!");

    /* Open the WLBS registry settings. */
    key = pConfig->m_pWlbsApiFuncs->pfnRegOpenWlbsSetting(AdapterGuid, false);

    /* If we can't open the key, just bail out. */
    if (key == NULL) {
        status = GetLastError();
        TraceError("WriteHostStateRegistryKey failed at RegOpenWlbsSetting", status);
        TRACE_CRIT("%!FUNC! RegOpenWlbsSetting failed with %d", status);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    /* Set the value of the HostState registry entry. */
    status = RegSetValueEx(key, CVY_NAME_HOST_STATE, 0L, CVY_TYPE_HOST_STATE, (LPBYTE)&State, sizeof(State));

    /* Close the handle. */
    RegCloseKey(key);

    /* If writing failed, bail out. */
    if (status != ERROR_SUCCESS) {
        TraceError("WriteHostStateRegistryKey failed at RegSetValueEx", status);
        TRACE_CRIT("%!FUNC! RegSetValueEx failed with %d", status);
        TRACE_VERB("<-%!FUNC!");
        return false;
    }

    TRACE_VERB("<-%!FUNC!");

    return true;
}

//+----------------------------------------------------------------------------
//
// Function:  ValidateVipInRule
//
// Description:  Parses pwszRuleString, looking for a valid VIP which must be
//               in the first token
//
// Arguments: PWCHAR pwszRuleString - tokenized string concatentating all
//                                    defined port rules
//            PWCHAR pwToken        - the token character that separates the fields
//            DWORD& dwVipLen       - if a token is found, this contains the size
//                                    of the string; 0 otherwise. The number of
//                                    characters returned is bound to <=
//                                    WLBS_MAX_CL_IP_ADDR
//
// NOTES:     A non-zero value for dwVipLen does NOT imply that the VIP is valid,
//            only that there was a non-zero length string in the expected
//            location. The user must check the return value to validate the VIP.
//
// Returns:   bool - true if the first field in the string has a valid IP address
//                   format; false otherwise.
//
// Assumptions: First token is the VIP element of a port rule
//
// History:   chrisdar  Created 01/05/15
//
//+----------------------------------------------------------------------------
bool ValidateVipInRule(const PWCHAR pwszRuleString, const WCHAR pwToken, DWORD& dwVipLen)
{
    TRACE_VERB("->%!FUNC!");
    ASSERT(NULL != pwszRuleString);

    bool ret = false;
    dwVipLen = 0;

    // Find the first occurence of the token string, which will denote the end of
    // the VIP part of the rule
    PWCHAR pwcAtSeparator = wcschr(pwszRuleString, pwToken);
    if (NULL == pwcAtSeparator) {
        TRACE_CRIT("%!FUNC! No token separator when one was expected");
        TRACE_VERB("<-%!FUNC!");
        return ret;
    }

    // Found the token string. Copy out the VIP and validate it.
    WCHAR wszIP[WLBS_MAX_CL_IP_ADDR + 1];
    DWORD dwStrLen = min((UINT)(pwcAtSeparator - pwszRuleString),
                         WLBS_MAX_CL_IP_ADDR);
    wcsncpy(wszIP, pwszRuleString, dwStrLen);
    wszIP[dwStrLen] = '\0';

    ASSERT(dwStrLen == wcslen(wszIP));

    dwVipLen = dwStrLen;

    // IpAddressFromAbcdWsz calls inet_addr to check the format of the IP address, but the
    // allowed formats are very flexible. For our port rule definition of a VIP we require
    // a rigid a.b.c.d format. To ensure that we only say the IP address is valid for IPs
    // specified in this manner, ensure that there are 3 and only 3 '.' in the string.
    DWORD dwTmpCount = 0;
    PWCHAR pwszTmp = pwszRuleString;
    while (pwszTmp < pwcAtSeparator)
    {
        if (*pwszTmp++ == L'.') { dwTmpCount++; }
    }
    if (dwTmpCount == 3 && INADDR_NONE != IpAddressFromAbcdWsz(wszIP)) {
        TRACE_INFO("%!FUNC! The IP address %ls is a valid IP of the form a.b.c.d", wszIP);
        ret = true;
    } else {
        TRACE_INFO("%!FUNC! The IP address %ls is NOT a valid IP of the form a.b.c.d", wszIP);
    }

    TRACE_VERB("<-%!FUNC!");
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\utils.h ===
DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress);

VOID
WINAPI AbcdWszFromIpAddress(
    IN  DWORD  IpAddress,    
    OUT WCHAR*  wszIpAddress,
    IN  const DWORD dwBufSize);

VOID GetIPAddressOctets (PCWSTR pszIpAddress, DWORD ardw[4]);
BOOL IsValidIPAddressSubnetMaskPair (PCWSTR szIp, PCWSTR szSubnet);


BOOL IsContiguousSubnetMask (PCWSTR pszSubnet);

//
// Arguments: PWSTR ip                  - Input dotted decimal IP address string
//            PWSTR sub                 - Output dotted decimal subnet mask for input IP address
//            const DWORD dwMaskBufSize - Size of sub output buffer in characters
//
BOOL ParamsGenerateSubnetMask (PWSTR ip, PWSTR sub, IN const DWORD dwMaskBufSize);

void ParamsGenerateMAC (const WCHAR * szClusterIP, 
                               OUT WCHAR * szClusterMAC, 
                               IN  const DWORD dwMACBufSize,
                               OUT WCHAR * szMulticastIP, 
                               IN  const DWORD dwIPBufSize,
                               BOOL fConvertMAC, 
                               BOOL fMulticast, 
                               BOOL fIGMP, 
                               BOOL fUseClusterIP);

void WriteNlbSetupErrorLog(UINT nIdErrorFormat, ...);

#define ASIZECCH(_array) (sizeof(_array)/sizeof((_array)[0]))
#define ASIZECB(_array) (sizeof(_array))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\wlbs.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbs.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object - main module implementing object

Author:

    kyrilf

--*/

#pragma once
#include "clusterdlg.h"
#include "host.h"
#include "wlbsparm.h"
#include "ports.h"
#include "resource.h"
#include "netcfgn.h"
#include "ncxclsid.h"
#include "wlbscfg.h"


class CWLBS :
    public CComObjectRoot,
    public CComCoClass<CWLBS, &CLSID_CWLBS>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding
{
public:
    CWLBS(VOID);
    ~CWLBS(VOID);

    BEGIN_COM_MAP(CWLBS)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CWLBS)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_WLBS)

    // INetCfgComponentControl
    STDMETHOD (Initialize) (IN INetCfgComponent* pIComp, IN INetCfg* pINetCfg, IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (IN INetCfgPnpReconfigCallback * pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

    // INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile) (PCWSTR szAnswerFile, PCWSTR szAnswerSections);
    STDMETHOD (Upgrade) (DWORD, DWORD);
    STDMETHOD (Install) (DWORD);
    STDMETHOD (Removing) ();
    
    // INetCfgProperties
    STDMETHOD (QueryPropertyUi) (IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (IN OUT DWORD* pdwDefPages, OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate, IN HWND hwndParent, OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

    // INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath) (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath) (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

private:
    class CDialogCluster * m_pClusterDlg;
    class CDialogHost * m_pHostDlg;
    class CDialogPorts * m_pPortsDlg;
    
    CWlbsConfig m_WlbsConfig;
    
    NETCFG_WLBS_CONFIG m_OriginalConfig;
    NETCFG_WLBS_CONFIG m_AdapterConfig;
    
    GUID m_AdapterGuid;

public:
    LRESULT OnInitDialog(IN HWND hWnd);
    LRESULT OnOk(IN HWND hWnd);
    LRESULT OnCancel(IN HWND hWnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\wlbs.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbs.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object - main module implementing object

Author:

    kyrilf

--*/

#include "pch.h"
#pragma hdrstop
#include "netcon.h"
#include "ncatlui.h"
#include "ndispnp.h"
#include "ncsetup.h"
#include "wlbs.h"
#include "help.h"
#include "wlbs.tmh" // for event tracing

// ----------------------------------------------------------------------
//
// Function:  CWLBS::CWLBS
//
// Purpose:   constructor for class CWLBS
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
// ----------------------------------------------------------------------
CWLBS::CWLBS(VOID) {
    
    m_pClusterDlg = NULL;
    m_pHostDlg = NULL;
    m_pPortsDlg = NULL;

    ZeroMemory(&m_AdapterGuid, sizeof(m_AdapterGuid));
    ZeroMemory(&m_OriginalConfig, sizeof(m_OriginalConfig));
    ZeroMemory(&m_AdapterConfig, sizeof(m_AdapterConfig));

    //
    // Register tracing
    //
    WPP_INIT_TRACING(L"Microsoft\\NLB");
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::~CWLBS
//
// Purpose:   destructor for class CWLBS
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
// ----------------------------------------------------------------------
CWLBS::~CWLBS(VOID) {

    if (m_pClusterDlg != NULL) delete m_pClusterDlg;
    if (m_pHostDlg != NULL) delete m_pHostDlg;
    if (m_pPortsDlg != NULL) delete m_pPortsDlg;

    //
    // DeRegister tracing
    //
    WPP_CLEANUP();;
}

// =================================================================
// INetCfgNotify
//
// The following functions provide the INetCfgNotify interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CWLBS::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Initialize(INetCfgComponent* pnccItem, INetCfg* pINetCfg, BOOL fInstalling) {
    TRACE_VERB("<->%!FUNC!");    
    return m_WlbsConfig.Initialize(pINetCfg, fInstalling);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure WLBS
//
// Arguments:
//    pszAnswerFile     [in]  name of AnswerFile
//    pszAnswerSection  [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ReadAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.ReadAnswerFile(pszAnswerFile, pszAnswerSection);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Install(DWORD dw) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.Install(dw);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Upgrade
//
// Purpose:   Do operations necessary for upgrade.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Upgrade(DWORD dw1, DWORD dw2) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.Upgrade(dw1, dw2);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Removing(VOID) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.Removing();
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Validate
//
// Purpose:   Do necessary parameter validation
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::Validate() {
    TRACE_VERB("<->%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::Cancel
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::CancelChanges(VOID) {
    TRACE_VERB("<->%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ApplyRegistryChanges(VOID) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.ApplyRegistryChanges();
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ApplyPnpChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Propagate changes to the driver.
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ApplyPnpChanges(INetCfgPnpReconfigCallback* pICallback) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.ApplyPnpChanges();
}

// =================================================================
// INetCfgBindNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CWLBS::QueryBindingPath
//
// Purpose:   Allow or veto a binding path involving us
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbi        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::QueryBindingPath(DWORD dwChangeFlag, INetCfgBindingPath* pncbp) {
    TRACE_VERB("->%!FUNC!");

    INetCfgComponent* pAdapter = NULL;

    HRESULT hr = HrGetLastComponentAndInterface (pncbp, &pAdapter, NULL);
    
    if (SUCCEEDED(hr) && pAdapter) {
        TRACE_INFO("%!FUNC! get last component succeeded");
        hr = m_WlbsConfig.QueryBindingPath(dwChangeFlag, pAdapter);
        pAdapter->Release();
        if (FAILED(hr))
        {
            TRACE_CRIT("%!FUNC! failed to query binding path with %d", hr);
        }
        else
        {
            TRACE_INFO("%!FUNC! query binding path succeeded");
        }
    }
    else {
        TRACE_CRIT("%!FUNC! failed on get last component with %d", hr);
    }

    TRACE_VERB("<-%!FUNC!");
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::NotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path involving us has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::NotifyBindingPath(DWORD dwChangeFlag, INetCfgBindingPath* pncbp) {
    TRACE_VERB("<->%!FUNC!");
    return m_WlbsConfig.NotifyBindingPath(dwChangeFlag, pncbp);
}

// =================================================================
// INetCfgProperties
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CWLBS::SetContext
//
// Purpose:   
//
// Arguments:
//
// Returns:
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::SetContext(IUnknown * pUnk) {
    TRACE_VERB("->%!FUNC!");
    HRESULT hr = S_OK;

    if (pUnk) { 
        INetLanConnectionUiInfo * pLanConnUiInfo;

        /* Set the new context.  Here we assume that we are going to be called only for
           a LAN connection since the sample IM works only with LAN devices. */
        hr = pUnk->QueryInterface(IID_INetLanConnectionUiInfo, reinterpret_cast<PVOID *>(&pLanConnUiInfo));

        if (SUCCEEDED(hr)) {
            hr = pLanConnUiInfo->GetDeviceGuid(&m_AdapterGuid);
            ReleaseObj(pLanConnUiInfo);
            TRACE_INFO("%!FUNC! query interface succeeded");
        } else {
            TraceError("CWLBS::SetContext called for non-lan connection", hr);
            TRACE_INFO("%!FUNC! query interface failed with %d", hr);
            return hr;
        }
    } else {
        /* Clear context. */
        ZeroMemory(&m_AdapterGuid, sizeof(m_AdapterGuid));
        TRACE_INFO("%!FUNC! clearing context");
    }

    /* If S_OK is not returned, the property page will not be displayed. */
    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::MergePropPages
//
// Purpose:   Supply our property page to system
//
// Arguments:
//    pdwDefPages   [out]  pointer to num default pages
//    pahpspPrivate [out]  pointer to array of pages
//    pcPages       [out]  pointer to num pages
//    hwndParent    [in]   handle of parent window
//    szStartPage   [in]   pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::MergePropPages(DWORD* pdwDefPages, LPBYTE* pahpspPrivate, UINT* pcPages, HWND hwndParent, PCWSTR* pszStartPage) {
    TRACE_VERB("->%!FUNC!");
    HPROPSHEETPAGE * ahpsp = NULL;
    HRESULT hr = S_OK;;

    /* We don't want any default pages to be shown. */
    *pdwDefPages = 0;
    *pcPages = 0;
    *pahpspPrivate = NULL;

    ahpsp = (HPROPSHEETPAGE*)CoTaskMemAlloc(3 * sizeof(HPROPSHEETPAGE));

    if (m_pClusterDlg != NULL) {
        delete m_pClusterDlg;
        m_pClusterDlg = NULL;
    }

    if (m_pHostDlg != NULL) {
        delete m_pHostDlg;
        m_pHostDlg = NULL;
    }

    if (m_pPortsDlg != NULL) {
        delete m_pPortsDlg;
        m_pPortsDlg = NULL;
    }

    if (ahpsp) {
        /* Get the cached configuration. */
        if (FAILED (hr = m_WlbsConfig.GetAdapterConfig(m_AdapterGuid, &m_OriginalConfig))) {
            TraceError("CWLBS::MergePropPages failed to query cluster config", hr);
            m_WlbsConfig.SetDefaults(&m_OriginalConfig);
            TRACE_CRIT("%!FUNC! failed in query to cluster configuration with %d", hr);
        }
        else
        {
            TRACE_INFO("%!FUNC! successfully retrieved the cached configuration");
        }

        /* Copy the configuration into the "current" config. */
        CopyMemory(&m_AdapterConfig, &m_OriginalConfig, sizeof(m_OriginalConfig));

        m_pClusterDlg = new CDialogCluster(&m_AdapterConfig, g_aHelpIDs_IDD_DIALOG_CLUSTER);
        if (NULL == m_pClusterDlg)
        {
            TRACE_CRIT("%!FUNC! memory allocation failure for cluster page dialog");
        }
        ahpsp[0] = m_pClusterDlg->CreatePage(IDD_DIALOG_CLUSTER, 0);

        m_pHostDlg = new CDialogHost(&m_AdapterConfig, g_aHelpIDs_IDD_DIALOG_HOST);
        if (NULL == m_pHostDlg)
        {
            TRACE_CRIT("%!FUNC! memory allocation failure for host page dialog");
        }
        ahpsp[1] = m_pHostDlg->CreatePage(IDD_DIALOG_HOST, 0);

        m_pPortsDlg = new CDialogPorts(&m_AdapterConfig, g_aHelpIDs_IDD_DIALOG_PORTS);
        if (NULL == m_pPortsDlg)
        {
            TRACE_CRIT("%!FUNC! memory allocation failure for ports page dialog");
        }
        ahpsp[2] = m_pPortsDlg->CreatePage(IDD_DIALOG_PORTS, 0);

        *pcPages = 3;
        *pahpspPrivate = (LPBYTE)ahpsp;
    }
    else
    {
        TRACE_CRIT("%!FUNC! CoTaskMemAlloc failed");
    }

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ValidateProperties
//
// Purpose:   Validate changes to property page
//
// Arguments:
//    hwndSheet [in]  window handle of property sheet
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ValidateProperties(HWND hwndSheet) {
    TRACE_VERB("->%!FUNC!");
    NETCFG_WLBS_CONFIG adapterConfig;

    /* Make a copy of our config.  It is voodoo to pass a pointer to 
       a private date member, so we make a copy instead. */
    CopyMemory(&adapterConfig, &m_AdapterConfig, sizeof(m_AdapterConfig));

    TRACE_VERB("<-%!FUNC!");
    return m_WlbsConfig.ValidateProperties(hwndSheet, m_AdapterGuid, &adapterConfig);
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::CancelProperties
//
// Purpose:   Cancel changes to property page
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::CancelProperties(VOID) {
    TRACE_VERB("->%!FUNC!");

    delete m_pClusterDlg;
    delete m_pHostDlg;
    delete m_pPortsDlg;

    m_pClusterDlg = NULL;
    m_pHostDlg = NULL;
    m_pPortsDlg = NULL;

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CWLBS::ApplyProperties
//
// Purpose:   Apply value of controls on property page
//            to internal memory structure
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We do this work in OnOk so no need to do it here again.
//
// ----------------------------------------------------------------------
STDMETHODIMP CWLBS::ApplyProperties(VOID) {
    TRACE_VERB("->%!FUNC!");

    /* If the cluster IP address / subnet mask or the dedicated IP address / subnet mask has changed in this 
       configuration session, remind the user that they have to enter this address in TCP/IP properties as well. */
    if (wcscmp(m_OriginalConfig.cl_ip_addr, m_AdapterConfig.cl_ip_addr) || 
        wcscmp(m_OriginalConfig.cl_net_mask, m_AdapterConfig.cl_net_mask) ||
        wcscmp(m_OriginalConfig.ded_ip_addr, m_AdapterConfig.ded_ip_addr) || 
        wcscmp(m_OriginalConfig.ded_net_mask, m_AdapterConfig.ded_net_mask)) {
        /* Alert the user. */
        NcMsgBox(::GetActiveWindow(), IDS_PARM_INFORMATION, IDS_PARM_TCPIP, MB_APPLMODAL | MB_ICONINFORMATION | MB_OK);
        TRACE_INFO("%!FUNC! vip and/or dip ip settings were modified");
    }

    /* Commit the configuration. */
    DWORD dwStatus = m_WlbsConfig.SetAdapterConfig(m_AdapterGuid, &m_AdapterConfig);
    if (S_OK != dwStatus)
    {
        TRACE_CRIT("%!FUNC! call to set the adapter configuration failed with %d", dwStatus);
    }
    else
    {
        TRACE_INFO("%!FUNC! call to set the adapter configuration succeeded");
    }

    delete m_pClusterDlg;
    delete m_pHostDlg;
    delete m_pPortsDlg;

    m_pClusterDlg = NULL;
    m_pHostDlg = NULL;
    m_pPortsDlg = NULL;

    TRACE_VERB("<-%!FUNC!");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\utils.cpp ===
#include "pch.h"
#pragma hdrstop

#include <winsock2.h>
#include <stdio.h>
#include "utils.h"
#include <ncxbase.h> // Needed in order to use SzLoadIds
#include <setupapi.h>

#include <strsafe.h>
#include "wlbsconfig.h"

//#include "utils.tmh"

#define MAXIPSTRLEN 20

//+----------------------------------------------------------------------------
//
// Function:  IpAddressFromAbcdWsz
//
// Synopsis:Converts caller's a.b.c.d IP address string to a network byte order IP 
//          address. 0 if formatted incorrectly.    
//
// Arguments: IN const WCHAR*  wszIpAddress - ip address in a.b.c.d unicode string
//
// Returns:   DWORD - IPAddr, return INADDR_NONE on failure
//
// History:   fengsun Created Header    12/8/98
//
//+----------------------------------------------------------------------------
DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress)
{   
    CHAR    szIpAddress[MAXIPSTRLEN + 1];
    DWORD  nboIpAddr;    

    ASSERT(lstrlen(wszIpAddress) < MAXIPSTRLEN);

    WideCharToMultiByte(CP_ACP, 0, wszIpAddress, -1, 
            szIpAddress, sizeof(szIpAddress), NULL, NULL);

    nboIpAddr = inet_addr(szIpAddress);

    return(nboIpAddr);
}

//+----------------------------------------------------------------------------
//
// Function:  IpAddressToAbcdWsz
//
// Synopsis:  
//    Converts IpAddr to a string in the a.b.c.d form and returns same in 
//    caller's wszIpAddress buffer.
//
//    The caller MUST provider a buffer that is at least MAXIPSTRLEN + 1 WCHAR long.
//
// Arguments: IPAddr IpAddress - 
//            OUT WCHAR* wszIpAddress -  buffer at least MAXIPSTRLEN
//            IN const DWORD dwBufSize - size of wszIpAddress buffer in WCHARs
//
// Returns:   void 
//
// History:   fengsun Created Header    12/21/98
//            chrisdar 07-Mar-2002 - Added argument for the size of the output buffer
//
//+----------------------------------------------------------------------------
VOID
WINAPI AbcdWszFromIpAddress(
    IN  DWORD  IpAddress,    
    OUT WCHAR*  wszIpAddress,
    IN  const DWORD dwBufSize)
{
    ASSERT(wszIpAddress);

    if (dwBufSize == 0)
    {
        return;
    }
    wszIpAddress[0] = L'\0';

    LPSTR AnsiAddressString = inet_ntoa( *(struct in_addr *)&IpAddress );

    ASSERT(AnsiAddressString);

    if (AnsiAddressString == NULL)
    {
        return ; 
    }

    int iLen = MultiByteToWideChar(CP_ACP, 0, AnsiAddressString,  -1 , 
                    wszIpAddress,  dwBufSize);
    //
    // There are three states that MultiByteToWideChar can return:
    //   1) iLen == 0                       This means the call failed
    //   2) iLen > 0 when dwBufSize > 0     This means the call succeeded
    //   3) iLen > 0 when dwBufSize == 0    This means the call succeeded, but only to inform the caller of 
    //                                      the required size of the out buffer in wide chars. The buffer is not modified.
    // This last case is prevented from occuring above by an early return if dwBufSize == 0.

    //
    // Note also that an 'int' return type is used above because that is what
    // MultiByteToWideChar returns. However, the returned value is always non-negative.
    //
    ASSERT(iLen >= 0);

    DWORD dwLen = (DWORD) iLen;
    if (dwLen == 0)
    {
        //
        // In case MultiByteToWideChar modified the buffer then failed
        //
        wszIpAddress[0] = L'\0';
        return;
    }

    ASSERT(dwLen < dwBufSize);
}

/*
 * Function: GetIPAddressOctets
 * Description: Turn an IP Address string into its 4 integer components.
 * Author: shouse 7.24.00
 */
VOID GetIPAddressOctets (PCWSTR pszIpAddress, DWORD ardw[4]) {
    DWORD dwIpAddr = IpAddressFromAbcdWsz(pszIpAddress);
    const BYTE * bp = (const BYTE *)&dwIpAddr;

    ardw[0] = (DWORD)bp[0];
    ardw[1] = (DWORD)bp[1];
    ardw[2] = (DWORD)bp[2];
    ardw[3] = (DWORD)bp[3];
}

/*
 * Function: IsValidIPAddressSubnetMaskPair
 * Description: Checks for valid IP address/netmask pairs.
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcperror.cpp
 */
BOOL IsValidIPAddressSubnetMaskPair (PCWSTR szIp, PCWSTR szSubnet) {
    BOOL fNoError = TRUE;

    DWORD dwAddr = IpAddressFromAbcdWsz(szIp);
    DWORD dwMask = IpAddressFromAbcdWsz(szSubnet);

    if (( (dwMask   | dwAddr) == 0xFFFFFFFF) // Is the host ID all 1's ?
     || (((~dwMask) & dwAddr) == 0)          // Is the host ID all 0's ?
     || ( (dwMask   & dwAddr) == 0))         // Is the network ID all 0's ?
    {
        fNoError = FALSE;
        return FALSE;
    }

    DWORD ardwNetID[4];
    DWORD ardwHostID[4];
    DWORD ardwIp[4];
    DWORD ardwMask[4];

    GetIPAddressOctets(szIp, ardwIp);
    GetIPAddressOctets(szSubnet, ardwMask);

    INT nFirstByte = ardwIp[0] & 0xFF;

    // setup Net ID
    ardwNetID[0] = ardwIp[0] & ardwMask[0] & 0xFF;
    ardwNetID[1] = ardwIp[1] & ardwMask[1] & 0xFF;
    ardwNetID[2] = ardwIp[2] & ardwMask[2] & 0xFF;
    ardwNetID[3] = ardwIp[3] & ardwMask[3] & 0xFF;

    // setup Host ID
    ardwHostID[0] = ardwIp[0] & (~(ardwMask[0]) & 0xFF);
    ardwHostID[1] = ardwIp[1] & (~(ardwMask[1]) & 0xFF);
    ardwHostID[2] = ardwIp[2] & (~(ardwMask[2]) & 0xFF);
    ardwHostID[3] = ardwIp[3] & (~(ardwMask[3]) & 0xFF);

    // check each case
    if( ((nFirstByte & 0xF0) == 0xE0)  || // Class D
        ((nFirstByte & 0xF0) == 0xF0)  || // Class E
        (ardwNetID[0] == 127) ||          // NetID cannot be 127...
        ((ardwNetID[0] == 0) &&           // netid cannot be 0.0.0.0
         (ardwNetID[1] == 0) &&
         (ardwNetID[2] == 0) &&
         (ardwNetID[3] == 0)) ||
        // netid cannot be equal to sub-net mask
        ((ardwNetID[0] == ardwMask[0]) &&
         (ardwNetID[1] == ardwMask[1]) &&
         (ardwNetID[2] == ardwMask[2]) &&
         (ardwNetID[3] == ardwMask[3])) ||
        // hostid cannot be 0.0.0.0
        ((ardwHostID[0] == 0) &&
         (ardwHostID[1] == 0) &&
         (ardwHostID[2] == 0) &&
         (ardwHostID[3] == 0)) ||
        // hostid cannot be 255.255.255.255
        ((ardwHostID[0] == 0xFF) &&
         (ardwHostID[1] == 0xFF) &&
         (ardwHostID[2] == 0xFF) &&
         (ardwHostID[3] == 0xFF)) ||
        // test for all 255
        ((ardwIp[0] == 0xFF) &&
         (ardwIp[1] == 0xFF) &&
         (ardwIp[2] == 0xFF) &&
         (ardwIp[3] == 0xFF)))
    {
        fNoError = FALSE;
    }

    return fNoError;
}

/*
 * Function: IsContiguousSubnetMask
 * Description: Makes sure the netmask is contiguous
 * Author: Copied largely from net/config/netcfg/tcpipcfg/tcputil.cpp
 */
BOOL IsContiguousSubnetMask (PCWSTR pszSubnet) {
    DWORD ardwSubnet[4];

    GetIPAddressOctets(pszSubnet, ardwSubnet);

    DWORD dwMask = (ardwSubnet[0] << 24) + (ardwSubnet[1] << 16)
        + (ardwSubnet[2] << 8) + ardwSubnet[3];
    
    
    DWORD i, dwContiguousMask;
    
    // Find out where the first '1' is in binary going right to left
    dwContiguousMask = 0;

    for (i = 0; i < sizeof(dwMask)*8; i++) {
        dwContiguousMask |= 1 << i;
        
        if (dwContiguousMask & dwMask)
            break;
    }
    
    // At this point, dwContiguousMask is 000...0111...  If we inverse it,
    // we get a mask that can be or'd with dwMask to fill in all of
    // the holes.
    dwContiguousMask = dwMask | ~dwContiguousMask;

    // If the new mask is different, correct it here
    if (dwMask != dwContiguousMask)
        return FALSE;
    else
        return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  ParamsGenerateSubnetMask
//
// Description:  
//
// Arguments: PWSTR ip                  - Input dotted decimal IP address string
//            PWSTR sub                 - Output dotted decimal subnet mask for input IP address
//            const DWORD dwMaskBufSize - Size of sub output buffer in characters
//
// Returns:   BOOL                      - TRUE if a subnet mask was generated. FALSE otherwise
//
// History: fengsun  Created Header    3/2/00
//          chrisdar 07 Mar 2002 - Added buffer size argument and tightened error checking
//
//+----------------------------------------------------------------------------
BOOL ParamsGenerateSubnetMask (PWSTR ip, PWSTR sub, IN const DWORD dwMaskBufSize) {
    DWORD               b [4];

    ASSERT(sub != NULL);

    if (dwMaskBufSize < WLBS_MAX_DED_NET_MASK + 1)
    {
        return FALSE;
    }

    int iScan = swscanf (ip, L"%d.%d.%d.%d", b, b+1, b+2, b+3);

    //
    // If we didn't read the first octect of the IP address then we can't generate a subnet mask
    //
    if (iScan != EOF && iScan > 0)
    {
        if ((b [0] >= 1) && (b [0] <= 126)) {
            b [0] = 255;
            b [1] = 0;
            b [2] = 0;
            b [3] = 0;
        } else if ((b [0] >= 128) && (b [0] <= 191)) {
            b [0] = 255;
            b [1] = 255;
            b [2] = 0;
            b [3] = 0;
        } else if ((b [0] >= 192) && (b [0] <= 223)) {
            b [0] = 255;
            b [1] = 255;
            b [2] = 255;
            b [3] = 0;
        } else {
            b [0] = 0;
            b [1] = 0;
            b [2] = 0;
            b [3] = 0;
        }
    }
    else
    {
        b [0] = 0;
        b [1] = 0;
        b [2] = 0;
        b [3] = 0;
    }

    StringCchPrintf(sub, dwMaskBufSize, L"%d.%d.%d.%d",
              b [0], b [1], b [2], b [3]);

    return((b[0] + b[1] + b[2] + b[3]) > 0);
}

/*
 * Function: ParamsGenerateMAC
 * Description: Calculate the generated field in the structure
 * History: fengsun Created 3.27.00
 *          shouse Modified 7.12.00 
 */
//
//  TODO: This function needs to be rewritten
//      1. One of the first executable lines is 'if (!fConvertMAC) { return; }. No need to call this function in this case.
//      2. Two buffers are OUT, but all are not touched for every call. This makes the code very fragile. If it is an out
//         and the pointer is non-NULL the user should expect this function to at least set the result to "no result", e.g.,
//         empty string. But looks like calling code has made assumptions about when these OUTs are modified. The caller has
//         too much knowledge of the implementation.
//      3. Calls are made to IpAddressFromAbcdWsz but no check is made to determine if the result is INADDR_NONE.
//      4. I suspect that this code would be much clearer if there were one input string, one output string, a buf size for
//         the output string and a enum telling the function how to create the MAC (unicast, multicast or IGMP)
//
//  When rewritten, many of the checks within the 'if' branches can then be moved to the top of the function. This will clean
//  the code considerably.
//
void ParamsGenerateMAC (const WCHAR * szClusterIP, 
                               OUT WCHAR * szClusterMAC, 
                               IN  const DWORD dwMACBufSize,
                               OUT WCHAR * szMulticastIP,
                               IN  const DWORD dwIPBufSize,
                               BOOL fConvertMAC, 
                               BOOL fMulticast, 
                               BOOL fIGMP, 
                               BOOL fUseClusterIP) {
    DWORD dwIp;    
    const BYTE * bp;

    //
    // Isn't this dumb? Why call this function at all if caller passes this flag in as false???
    //
    if (!fConvertMAC) return;

    /* Unicast mode. */
    if (!fMulticast) {
        ASSERT(szClusterIP != NULL);
        ASSERT(szClusterMAC != NULL);
        ASSERT(dwMACBufSize > WLBS_MAX_NETWORK_ADDR);

        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        bp = (const BYTE *)&dwIp;
        
        StringCchPrintf(szClusterMAC, dwMACBufSize, L"02-bf-%02x-%02x-%02x-%02x", bp[0], bp[1], bp[2], bp[3]);

        return;
    }

    /* Multicast without IGMP. */
    if (!fIGMP) {
        ASSERT(szClusterIP != NULL);
        ASSERT(szClusterMAC != NULL);
        ASSERT(dwMACBufSize > WLBS_MAX_NETWORK_ADDR);

        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        bp = (const BYTE *)&dwIp;
        
        StringCchPrintf(szClusterMAC, dwMACBufSize, L"03-bf-%02x-%02x-%02x-%02x", bp[0], bp[1], bp[2], bp[3]);

        return;
    }
    
    /* Multicast with IGMP. */
    if (fUseClusterIP) {
        ASSERT(szClusterIP != NULL);
        ASSERT(szMulticastIP != NULL);
        ASSERT(dwIPBufSize > WLBS_MAX_CL_IP_ADDR);

        /* 239.255.x.x */
        dwIp = IpAddressFromAbcdWsz(szClusterIP);
        dwIp = 239 + (255 << 8) + (dwIp & 0xFFFF0000);
        AbcdWszFromIpAddress(dwIp, szMulticastIP, dwIPBufSize);
    }

    //
    // The OUT buffer szMulticastIP is used here as an input. The buffer will be uninitialized if
    // fUseClusterIP == FALSE && fIGMP == TRUE && fMulticast == TRUE. That doesn't sound intentional...
    // Looks like we shouldn't get here unless fUseClusterIP == TRUE. Perhaps caller is taking care of this
    // for us, but this is fragile.
    //
    ASSERT(szClusterMAC != NULL);
    ASSERT(szMulticastIP != NULL);
    ASSERT(dwMACBufSize > WLBS_MAX_NETWORK_ADDR);
    dwIp = IpAddressFromAbcdWsz(szMulticastIP);
    bp = (const BYTE*)&dwIp;
        
    StringCchPrintf(szClusterMAC, dwMACBufSize, L"01-00-5e-%02x-%02x-%02x", (bp[1] & 0x7f), bp[2], bp[3]);
}

//+----------------------------------------------------------------------------
//
// Function:  WriteNlbSetupErrorLog
//
// Description:  Writes a log message to setuperr.log. Used for logging during
//               GUI mode setup.
//
// Arguments: UINT uiIdErrorFormat - string resourse identifier
//            <variable length list of variable args>
//
// Returns:   None
//
// History:   chrisdar Created: 01.06.20
//
//+----------------------------------------------------------------------------
void WriteNlbSetupErrorLog(UINT uiIdErrorFormat, ...)
{
//    TRACE_VERB("->%!FUNC! error code string: %ui", uiIdErrorFormat);
    PCWSTR pszFormat = SzLoadIds(uiIdErrorFormat);

    PWSTR pszText = NULL;
    DWORD dwRet;

    va_list val;
    va_start(val, uiIdErrorFormat);
    dwRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end(val);

    if (dwRet && pszText)
    {
        if (!SetupLogError(pszText, LogSevError))
        {
//            TRACE_CRIT("%!FUNC! write to setup error log failed with %d", HRESULT_FROM_WIN32(GetLastError()));
        }
        LocalFree(pszText);
    }
    else
    {
//        TRACE_CRIT("%!FUNC! format message failed with %d", HRESULT_FROM_WIN32(GetLastError()));
    }

//    TRACE_VERB("<-%!FUNC!");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\wlbscfg.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbscfg.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Notifier object - Provide the functionality of notifier object

Author:

    fengsun

--*/


#pragma once

#include <netcfgx.h>

#include "wlbsparm.h"

#define WLBS_MAX_PASSWORD 16

struct NETCFG_WLBS_PORT_RULE {
    TCHAR virtual_ip_addr [CVY_MAX_CL_IP_ADDR + 1]; // Virtual IP Address 
    DWORD start_port;             // Starting port number. 
    DWORD end_port;               // Ending port number. 
    DWORD mode;                   // Filtering mode. WLBS_PORT_RULE_XXXX 
    DWORD protocol;               // WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP 

    union {
        struct {
            DWORD priority;       // Mastership priority: 1..32 or 0 for not-specified. 
        } single;                 // Data for single server mode. 

        struct {
            WORD equal_load;      // TRUE - Even load distribution. 
            WORD affinity;        // WLBS_AFFINITY_XXX 
            DWORD load;           // Percentage of load to handle locally 0..100. 
        } multi;                  // Data for multi-server mode. 

    } mode_data;                  // Data for appropriate port group mode. 
};

/* This is not visible from the UI, but we need it
   to correct some bad configuration on binding. */
struct NETCFG_WLBS_BDA_TEAMING {
    WCHAR team_id[CVY_MAX_BDA_TEAM_ID + 1];   /* The team ID - MUST be a GUID. */
    ULONG active;                             /* On write, this flag determines whether to create BDATeaming key - BDA on/off switch. */
    ULONG master;                             /* Boolean indication of master status. */
    ULONG reverse_hash;                       /* Sets direction of hashing - forward (normal) or reverse. */
};

struct NETCFG_WLBS_CONFIG {
    DWORD dwHostPriority;                             // Host priority ID.
    DWORD dwPersistedStates;                          // The states that will be persisted across reboot.
    DWORD dwInitialState;                             // The states that will be persisted across reboot.
    bool fRctEnabled;                                 // TRUE - remote control enabled. 
    bool fMcastSupport;                               // TRUE - multicast mode, FALSE - unicast mode.
    bool fIGMPSupport;                                // TRUE - IGMP enabled.
    bool fIpToMCastIp;                                // TRUE - derive multicast IP from cluster IP.

    WCHAR szMCastIpAddress[CVY_MAX_CL_IP_ADDR + 1];   // The multicast IP address, if user-specified.
    TCHAR cl_mac_addr[CVY_MAX_NETWORK_ADDR + 1];      // Cluster MAC address.
    TCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];         // Cluster IP address.
    TCHAR cl_net_mask[CVY_MAX_CL_NET_MASK + 1];       // Netmask for cluster IP.
    TCHAR ded_ip_addr[CVY_MAX_DED_IP_ADDR + 1];       // Dedicated IP address or "" for none.
    TCHAR ded_net_mask[CVY_MAX_DED_NET_MASK + 1];     // Netmask for dedicated IP address or "" for none.
    TCHAR domain_name[CVY_MAX_DOMAIN_NAME + 1];       // Full Qualified Domain Name of the cluster. 

    bool fChangePassword;                             // Whether to change password, valid for SetAdapterConfig only.
    TCHAR szPassword[CVY_MAX_RCT_CODE + 1];           // Remote control password, valid for SetAdapterConfig only.

    bool fConvertMac;                                 // Whether the mac address is generated from IP.
    DWORD dwMaxHosts;                                 // Maximum # hosts allowed.
    DWORD dwMaxRules;                                 // Maximum # port group rules allowed.
    
    DWORD dwNumRules;                                 // # active port group rules 

    NETCFG_WLBS_BDA_TEAMING bda_teaming;              /* The BDA teaming config, which is NOT visible in the UI. */

    NETCFG_WLBS_PORT_RULE port_rules[CVY_MAX_RULES];  // Port rules
};

class CNetcfgCluster;
struct WlbsApiFuncs;

//+----------------------------------------------------------------------------
//
// class CWlbsConfig
//
// Description: Provide the functionality for the notifier object.
//              It would be used by TCPIP notifier if WLBS UI merged with TCPIP
//
// History:   fengsun Created Header    2/11/00
//
//+----------------------------------------------------------------------------

class CWlbsConfig
{
public:
    CWlbsConfig(VOID);
    ~CWlbsConfig(VOID);

    STDMETHOD (Initialize) (IN INetCfg* pINetCfg, IN BOOL fInstalling);
    STDMETHOD (ReadAnswerFile) (PCWSTR szAnswerFile, PCWSTR szAnswerSections);
    STDMETHOD (Upgrade) (DWORD, DWORD);
    STDMETHOD (Install) (DWORD);
    STDMETHOD (Removing) ();
    STDMETHOD (QueryBindingPath) (DWORD dwChangeFlag, INetCfgComponent * pAdapter);
    STDMETHOD (NotifyBindingPath) (DWORD dwChangeFlag, INetCfgBindingPath * pncbp);
    STDMETHOD (GetAdapterConfig) (const GUID & AdapterGuid, NETCFG_WLBS_CONFIG * pClusterConfig);
    STDMETHOD (SetAdapterConfig) (const GUID & AdapterGuid, NETCFG_WLBS_CONFIG * pClusterConfig);
    STDMETHOD_(void, SetDefaults) (NETCFG_WLBS_CONFIG * pClusterConfig);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) ();
    STDMETHOD (ValidateProperties) (HWND hwndSheet, GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig);
    STDMETHOD (CheckForDuplicateCLusterIPAddresses) (GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig);
    STDMETHOD (CheckForDuplicateBDATeamMasters) (GUID adapterGUID, NETCFG_WLBS_CONFIG * adapterConfig);

#ifdef DEBUG
    void AssertValid();
#endif

protected:
    CNetcfgCluster * GetCluster (const GUID& AdapterGuid);
    HRESULT LoadAllAdapterSettings (bool fUpgradeFromWin2k);

    vector<CNetcfgCluster*> m_vtrCluster; // List of clusters.
    HANDLE m_hDeviceWlbs;                 // Handle to the WLBS device object.

    enum ENUM_WLBS_SERVICE {
        WLBS_SERVICE_NONE, 
        WLBS_SERVICE_INSTALL, 
        WLBS_SERVICE_REMOVE,
        WLBS_SERVICE_UPGRADE
    };

    ENUM_WLBS_SERVICE m_ServiceOperation; // Operations to be applied
    INetCfgComponent * m_pWlbsComponent;  // Wlbs Component.

public:
    HRESULT IsBoundTo (INetCfgComponent* pAdapter);
    ULONG CountNLBBindings ();

    //
    // To avoid link with wlbsctrl.dll, which only shiped in adavanced server
    // Can not put them as global variables, because multiple instance of this
    // object could exist
    //
    INetCfg * m_pNetCfg;        
    HINSTANCE m_hdllWlbsCtrl;
    WlbsApiFuncs * m_pWlbsApiFuncs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\dialup\conmanw.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N W . H
//
//  Contents:   Class manager for RAS connections.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"


class ATL_NO_VTABLE CWanConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CWanConnectionManager,
                        &CLSID_WanConnectionManager>,
    public IConnectionPointContainerImpl <CWanConnectionManager>,
    public INetConnectionManager
{
public:
    CWanConnectionManager() throw()
    {
    }

    DECLARE_CLASSFACTORY_SINGLETON(CWanConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_WAN_CONMAN)

    BEGIN_COM_MAP(CWanConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CWanConnectionManager)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHOD (EnumConnections) (
        IN  NETCONMGR_ENUM_FLAGS    Flags,
        OUT IEnumNetConnection**    ppEnum);

public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\wlbscfg\tests\main.cpp ===
#include <windows.h>
#include <tchar.h>
#include <winsock2.h>
#include <stdio.h>
#include "debug.h"
#include "wlbsconfig.h"
#include "wlbsparm.h"

#define MAXIPSTRLEN 20

//+----------------------------------------------------------------------------
//
// Function:  IpAddressFromAbcdWsz
//
// Synopsis:Converts caller's a.b.c.d IP address string to a network byte order IP 
//          address. 0 if formatted incorrectly.    
//
// Arguments: IN const WCHAR*  wszIpAddress - ip address in a.b.c.d unicode string
//
// Returns:   DWORD - IPAddr, return INADDR_NONE on failure
//
// History:   fengsun Created Header    12/8/98
//            chrisdar COPIED FROM \nt\net\config\netcfg\wlbscfg\utils.cpp BECAUSE COULDN'T RESOLVE RtlAssert WHEN COMPILING THIS FILE INTO PROJECT
//
//+----------------------------------------------------------------------------
DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress)
{   
    CHAR    szIpAddress[MAXIPSTRLEN + 1];
    DWORD  nboIpAddr;    

    ASSERT(lstrlen(wszIpAddress) < MAXIPSTRLEN);

    WideCharToMultiByte(CP_ACP, 0, wszIpAddress, -1, 
		    szIpAddress, sizeof(szIpAddress), NULL, NULL);

    nboIpAddr = inet_addr(szIpAddress);

    return(nboIpAddr);
}

bool ValidateVipInRule(const PWCHAR pwszRuleString, const WCHAR pwToken, DWORD& dwVipLen)
{
    ASSERT(NULL != pwszRuleString);

    bool ret = false;
    dwVipLen = 0;

    // Find the first occurence of the token string, which will denote the end of
    // the VIP part of the rule
    PWCHAR pwcAtSeparator = wcschr(pwszRuleString, pwToken);
    if (NULL == pwcAtSeparator) { return ret; }

    // Found the token string. Copy out the VIP and validate it.
    WCHAR wszIP[WLBS_MAX_CL_IP_ADDR + 1];
    DWORD dwStrLen = min((UINT)(pwcAtSeparator - pwszRuleString),
                         WLBS_MAX_CL_IP_ADDR);
    wcsncpy(wszIP, pwszRuleString, dwStrLen);
    wszIP[dwStrLen] = '\0';

    ASSERT(dwStrLen == wcslen(wszIP));

    dwVipLen = dwStrLen;

    // IpAddressFromAbcdWsz calls inet_addr to check the format of the IP address, but the
    // allowed formats are very flexible. For our port rule definition of a VIP we require
    // a rigid a.b.c.d format. To ensure that we only say the IP address is valid for IPs
    // specified in this manner, ensure that there are 3 and only 3 '.' in the string.
    DWORD dwTmpCount = 0;
    PWCHAR pwszTmp = pwszRuleString;
    while (pwszTmp < pwcAtSeparator)
    {
        if (*pwszTmp++ == L'.') { dwTmpCount++; }
    }
    if (dwTmpCount == 3 && INADDR_NONE != IpAddressFromAbcdWsz(wszIP)) { ret = true; }

    return ret;
}

DWORD testRule(PWCHAR ptr)
{
    WLBS_REG_PARAMS* paramp = new WLBS_REG_PARAMS;
    DWORD ret = 0;
    PWLBS_PORT_RULE rp, rulep;

    /* distinct rule elements for parsing */

    typedef enum
    {
        vip,
        start,
        end,
        protocol,
        mode,
        affinity,
        load,
        priority
    }
    CVY_RULE_ELEMENT;

    CVY_RULE_ELEMENT elem = vip;
    DWORD count = 0;
    DWORD i;
    DWORD dwVipLen = 0;
    const DWORD dwVipAllNameLen = sizeof(CVY_NAME_PORTRULE_VIPALL)/sizeof(WCHAR) - 1; // Used below in a loop. Set it here since it is a constant.
    WCHAR wszTraceOutputTmp[WLBS_MAX_CL_IP_ADDR + 1];
    bool bFallThrough = false; // Used in 'vip' case statement below.

    rulep = paramp->i_port_rules;

    while (ptr != NULL) {
        switch (elem) {
            case vip:
                // DO NOT MOVE THIS CASE STATEMENT. IT MUST ALWAYS COME BEFORE THE 'start' CASE STATEMENT. See FALLTHROUGH comment below.
                bFallThrough = false;
                dwVipLen = 0;
                if (ValidateVipInRule(ptr, L',', dwVipLen))
                {
                    ASSERT(dwVipLen <= WLBS_MAX_CL_IP_ADDR);

                    // rulep->virtual_ip_addr is a TCHAR and ptr is a WCHAR.
                    // Data is moved from the latter to the former so ASSERT TCHAR is WCHAR.
                    ASSERT(sizeof(TCHAR) == sizeof(WCHAR));

                    // This is a rule for a specific VIP
                    _tcsncpy(rulep->virtual_ip_addr, ptr, dwVipLen);
                    (rulep->virtual_ip_addr)[dwVipLen] = '\0';
                }
                else
                {
                    // This is either an 'all' rule, a VIP-less rule or a malformed rule. We can't distinguish a malformed rule
                    // from a VIP-less rule, so we will assume the rule is either an 'all' rule or a VIP-less rule. In both cases
                    // set the VIP component of the rule to be the default or 'all' value.

                    // Copy the 'all' IP into the rule.
                    _tcscpy(rulep->virtual_ip_addr, CVY_DEF_ALL_VIP);

                    if (dwVipAllNameLen != dwVipLen || (_tcsnicmp(ptr, CVY_NAME_PORTRULE_VIPALL, dwVipAllNameLen) != 0))
                    {
                        // The rule is either VIP-less or it is malformed. We assume it is VIP-less and let the 'start'
                        // case handle the current token as a start_port property by falling through to the next case clause
                        // rather than breaking.
                        bFallThrough = true;
//                      wprintf(L"doing fallthrough...%d, %d\n", dwVipAllNameLen, dwVipLen);

                        _tcsncpy(wszTraceOutputTmp, ptr, dwVipLen);
                        wszTraceOutputTmp[dwVipLen] = '\0';
//                        TraceMsg(L"-----\n#### VIP element of port rule is invalid = %s\n", wszTraceOutputTmp);
                    }
                }
//                TraceMsg(L"-----\n#### Port rule vip = %s\n", rulep->virtual_ip_addr);
                
                elem = start;
                // !!!!!!!!!!!!!!!!!!!!
                // FALLTHROUGH
                // !!!!!!!!!!!!!!!!!!!!
                // When we have a VIP-less port rule, we will fall through this case statement into the 'start' case statement
                // below so that the current token can be used as the start_port for a port rule.
                if (!bFallThrough)
                {
                    // We have a VIP in the port rule. We do a "break;" as std operating procedure.
//                  TraceMsg(L"-----\n#### Fallthrough case statement from port rule vip to start\n");
                    break;
                }
                // NO AUTOMATIC "break;" STATEMENT HERE. Above, we conditionally flow to the 'start' case...
            case start:
                // DO NOT MOVE THIS CASE STATEMENT. IT MUST ALWAYS COME AFTER THE 'vip' CASE STATEMENT.
                // See comments (FALLTHROUGH) inside the 'vip' case statement.
                rulep->start_port = _wtoi(ptr);
//                    CVY_CHECK_MIN (rulep->start_port, CVY_MIN_PORT);
                CVY_CHECK_MAX (rulep->start_port, CVY_MAX_PORT);
//                TraceMsg(L"-----\n#### Start port   = %d\n", rulep->start_port);
                elem = end;
                break;
            case end:
                rulep->end_port = _wtoi(ptr);
//                    CVY_CHECK_MIN (rulep->end_port, CVY_MIN_PORT);
                CVY_CHECK_MAX (rulep->end_port, CVY_MAX_PORT);
//                TraceMsg(L"#### End port     = %d\n", rulep->end_port);
                elem = protocol;
                break;
            case protocol:
                switch (ptr [0]) {
                    case L'T':
                    case L't':
                        rulep->protocol = CVY_TCP;
//                        TraceMsg(L"#### Protocol     = TCP\n");
                        break;
                    case L'U':
                    case L'u':
                        rulep->protocol = CVY_UDP;
//                        TraceMsg(L"#### Protocol     = UDP\n");
                        break;
                    default:
                        rulep->protocol = CVY_TCP_UDP;
//                        TraceMsg(L"#### Protocol     = Both\n");
                        break;
                }

                elem = mode;
                break;
            case mode:
                switch (ptr [0]) {
                    case L'D':
                    case L'd':
                        rulep->mode = CVY_NEVER;
//                        TraceMsg(L"#### Mode         = Disabled\n");
                        goto end_rule;
                    case L'S':
                    case L's':
                        rulep->mode = CVY_SINGLE;
//                        TraceMsg(L"#### Mode         = Single\n");
                        elem = priority;
                        break;
                    default:
                        rulep->mode = CVY_MULTI;
//                        TraceMsg(L"#### Mode         = Multiple\n");
                        elem = affinity;
                        break;
                }
                break;
            case affinity:
                switch (ptr [0]) {
                    case L'C':
                    case L'c':
                        rulep->mode_data.multi.affinity = CVY_AFFINITY_CLASSC;
//                        TraceMsg(L"#### Affinity     = Class C\n");
                        break;
                    case L'N':
                    case L'n':
                        rulep->mode_data.multi.affinity = CVY_AFFINITY_NONE;
//                        TraceMsg(L"#### Affinity     = None\n");
                        break;
                    default:
                        rulep->mode_data.multi.affinity = CVY_AFFINITY_SINGLE;
//                        TraceMsg(L"#### Affinity     = Single\n");
                        break;
                }

                elem = load;
                break;
            case load:
                if (ptr [0] == L'E' || ptr [0] == L'e') {
                    rulep->mode_data.multi.equal_load = TRUE;
                    rulep->mode_data.multi.load       = CVY_DEF_LOAD;
//                    TraceMsg(L"#### Load         = Equal\n");
                } else {
                    rulep->mode_data.multi.equal_load = FALSE;
                    rulep->mode_data.multi.load       = _wtoi(ptr);
//                        CVY_CHECK_MIN (rulep->mode_data.multi.load, CVY_MIN_LOAD);
                    CVY_CHECK_MAX (rulep->mode_data.multi.load, CVY_MAX_LOAD);
//                    TraceMsg(L"#### Load         = %d\n", rulep->mode_data.multi.load);
                }
                goto end_rule;
            case priority:
                rulep->mode_data.single.priority = _wtoi(ptr);
                CVY_CHECK_MIN (rulep->mode_data.single.priority, CVY_MIN_PRIORITY);
                CVY_CHECK_MAX (rulep->mode_data.single.priority, CVY_MAX_PRIORITY);
//                TraceMsg(L"#### Priority     = %d\n", rulep->mode_data.single.priority);
                goto end_rule;
            default:
//                TraceMsg(L"#### Bad rule element %d\n", elem);
                break;
        }

    next_field:

        ptr = wcschr(ptr, L',');

        if (ptr != NULL) {
            ptr ++;
            continue;
        } else break;

    end_rule:

        elem = vip;

        for (i = 0; i < count; i ++) {
            rp = paramp->i_port_rules + i;

            if ((rulep -> start_port < rp -> start_port &&
                 rulep -> end_port >= rp -> start_port) ||
                (rulep -> start_port >= rp -> start_port &&
                 rulep -> start_port <= rp -> end_port)) {
//                TraceMsg(L"#### Rule %d (%d - %d) overlaps with rule %d (%d - %d)\n", i, rp -> start_port, rp -> end_port, count, rulep -> start_port, rulep -> end_port);
                break;
            }
        }

        wprintf(L"vip = %s, start = %d, end = %d, protocol = %d\n", rulep->virtual_ip_addr, rulep->start_port, rulep->end_port, rulep->protocol);
        wprintf(L"mode = %d, affinity = %d, load = %d, %d\n", rulep->mode, rulep->mode_data.multi.affinity, rulep->mode_data.multi.equal_load, rulep->mode_data.multi.load);
        wprintf(L"priority = %d\n\n\n", rulep->mode_data.single.priority);
        rulep -> valid = TRUE;
        CVY_RULE_CODE_SET (rulep);

        if (i >= count) {
            count++;
            rulep++;

            if (count >= CVY_MAX_RULES) break;
        }

        goto next_field;
    }


    delete paramp;
    return ret;
}

int __cdecl wmain(int argc, wchar_t * argv[])
{
    DWORD result = 0;
    
    // Good Vip = gv
	// No Vip = nv
	// Bad Vip = bv
    PWCHAR ppGoodRuleStrings[] = {
        L"1.2.3.4,20,21,Both,Multiple,Single,Equal\n",  // gv
        L"1018,1019,UDP,Multiple,None,Equal\n",			// nv
        L"1.2.3.4,20,21,Both,Multiple,Single,Equal,1018,1019,UDP,Multiple,None,Equal\n",		// gv nv
        L"1018,1019,UDP,Multiple,None,Equal,1.2.3.4,20,21,Both,Multiple,Single,Equal\n",		// nv gv
        L"1.2.3.4,20,21,Both,Multiple,Single,Equal,5.6.7.8,20,21,Both,Multiple,Single,Equal\n",	// gv gv
        L"1018,1019,UDP,Multiple,None,Equal,4018,4019,UDP,Multiple,None,Equal\n",				// nv nv
        L"1.2.3.4,20,21,Both,Multiple,Single,Equal,1018,1019,UDP,Multiple,None,Equal,4018,4019,UDP,Multiple,None,Equal\n",		// gv nv nv
        L"1018,1019,UDP,Multiple,None,Equal,1.2.3.4,20,21,Both,Multiple,Single,Equal,4018,4019,UDP,Multiple,None,Equal\n",		// nv gv nv
        L"1018,1019,UDP,Multiple,None,Equal,4018,4019,UDP,Multiple,None,Equal,1.2.3.4,20,21,Both,Multiple,Single,Equal\n",		// nv nv gv
        L"1.2.3.4,20,21,Both,Multiple,Single,Equal,5.6.7.8,20,21,Both,Multiple,Single,Equal,1018,1019,UDP,Multiple,None,Equal\n",	// gv gv nv
        L"1.2.3.4,20,21,Both,Multiple,Single,Equal,1018,1019,UDP,Multiple,None,Equal,5.6.7.8,20,21,Both,Multiple,Single,Equal\n",	// gv nv gv
        L"1018,1019,UDP,Multiple,None,Equal,1.2.3.4,20,21,Both,Multiple,Single,Equal,5.6.7.8,20,21,Both,Multiple,Single,Equal\n",	// nv gv gv

        L"all,0,19,Both,Multiple,None,Equal,1.2.3.4,20,21,Both,Multiple,Single,Equal,254.254.254.254,22,138,Both,Multiple,None,Equal,207.46.148.249,139,139,Both,Multiple,Single,Equal,157.54.55.192,140,442,Both,Multiple,None,Equal,443,443,Both,Multiple,Single,Equal\n",
        L"111.222.222.111,1018,1018,TCP,Multiple,None,Equal,\n",
        NULL
    };

    PWCHAR ppBadRuleStrings[] = {
		L"",
		L"\n",
        L"111.222.333.111,1018,1018,TCP,Multiple,None,Equal,\n",
		L"443,1000,1001,Both,Multiple,Single,Equal\n",
		L"1,1000,1001,Both,Multiple,Single,Equal\n",
		L"1.1,1000,1001,Both,Multiple,Single,Equal\n",
		L"1.1.1,1000,1001,Both,Multiple,Single,Equal\n",
		L"allinthefamily,1000,1001,Both,Multiple,Single,Equal\n",
		NULL
	};

    PWCHAR* ptr = ppGoodRuleStrings;

    wprintf(L"These rules are valid and should be read properly.\n\n");

    while(*ptr != NULL)
    {
        wprintf(L"Input rule string is = %s", *ptr);
        result = testRule(*ptr);
        wprintf(L"\n\n\n");
        ptr++;
    }

    wprintf(L"These rules will fail, but should not cause AV, etc.\n\n");

	ptr = ppBadRuleStrings;
    while(*ptr != NULL)
    {
        wprintf(L"Input rule string is = %s", *ptr);
        result = testRule(*ptr);
        wprintf(L"\n\n\n");
        ptr++;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\dialup\conmanw.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N W . C P P
//
//  Contents:   Class manager for RAS connections.
//
//  Notes:
//
//  Author:     shaunco   21 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conmanw.h"
#include "enumw.h"
#include "ncbase.h"
#include <ras.h>

//+---------------------------------------------------------------------------
// INetConnectionManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManager::EnumConnections
//
//  Purpose:    Return an INetConnection enumerator.
//
//  Arguments:
//      Flags        [in]
//      ppEnum       [out]  The enumerator.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   21 Sep 1997
//
//  Notes:
//
STDMETHODIMP
CWanConnectionManager::EnumConnections (
    IN  NETCONMGR_ENUM_FLAGS    Flags,
    OUT IEnumNetConnection**    ppEnum)
{
    HRESULT hr = CWanConnectionManagerEnumConnection::CreateInstance (
                    Flags,
                    IID_IEnumNetConnection,
                    reinterpret_cast<void**>(ppEnum));

    TraceError ("CWanConnectionManager::EnumConnections", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\dialup\enumw.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M W . H
//
//  Contents:   Enumerator for RAS connections objects.
//
//  Notes:
//
//  Author:     shaunco   2 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasapip.h>


class ATL_NO_VTABLE CWanConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CWanConnectionManagerEnumConnection,
                        &CLSID_WanConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    NETCONMGR_ENUM_FLAGS    m_EnumFlags;
    RASENUMENTRYDETAILS*    m_aRasEntryName;
    ULONG                   m_cRasEntryName;
    ULONG                   m_iNextRasEntryName;
    BOOL                    m_fDone;

private:
    HRESULT
    HrNextOrSkip (
        IN  ULONG               celt,
        OUT INetConnection**    rgelt,
        OUT ULONG*              pceltFetched);

public:
    CWanConnectionManagerEnumConnection () throw();
    ~CWanConnectionManagerEnumConnection () throw();

    DECLARE_REGISTRY_RESOURCEID(IDR_WAN_CONMAN_ENUM)

    BEGIN_COM_MAP(CWanConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD (Next) (
        IN  ULONG               celt,
        OUT INetConnection**    rgelt,
        OUT ULONG*              pceltFetched);

    STDMETHOD (Skip) (
        IN  ULONG   celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        OUT IEnumNetConnection**    ppenum);

public:
    static HRESULT CreateInstance (
        IN  NETCONMGR_ENUM_FLAGS    Flags,
        IN  REFIID                  riid,
        OUT void**                  ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\dialup\dialup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I A L U P . C P P
//
//  Contents:   Implements the dial up connection object.
//
//  Notes:
//
//  Author:     shaunco   23 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "dialup.h"
#include "nccom.h"
#include "ncnetcon.h"
#include "ncras.h"
#include "ncreg.h"
#include "userenv.h"
#include "cmutil.h"
#include "cobase.h"

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::CreateInstanceUninitialized
//
//  Purpose:    Create an uninitialized instance of
//              CComObject <CDialupConnection> and return an interface
//              pointer as well as a pointer to the CDialupConnection.
//
//  Arguments:
//      riid  [in]  IID of desired interface.
//      ppv   [out] Returned interface pointer.
//      ppObj [out] Returned object pointer.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   20 Apr 1998
//
//  Notes:
//
//static
HRESULT
CDialupConnection::CreateInstanceUninitialized (
    IN  REFIID              riid,
    OUT VOID**              ppv,
    OUT CDialupConnection** ppObj)
{
    Assert (ppObj);
    Assert (ppv);

    *ppv = NULL;
    *ppObj = NULL;

    HRESULT hr = E_OUTOFMEMORY;

    CDialupConnection* pObj;
    pObj = new CComObject <CDialupConnection>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            INetConnection* pCon = static_cast<INetConnection*>(pObj);
            hr = pCon->QueryInterface (riid, ppv);
            if (SUCCEEDED(hr))
            {
                *ppObj = pObj;
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    TraceError ("CDialupConnection::CreateInstanceFromDetails", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::CreateInstanceFromDetails
//
//  Purpose:    Create an initialized instance of
//              CComObject <CDialupConnection> given RASENUMENTRYDETAILS and
//              return an interface pointer on that object.
//
//  Arguments:
//      pszwPbkFile     [in]  Path to the phonebook file.
//      pszwEntryName   [in]  Name of the entry in the phonebook.
//      fForAllUsers    [in]  TRUE if this entry is for all users.
//      riid            [in]  IID of desired interface.
//      ppv             [out] Returned interface pointer.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   23 Sep 1997
//
//  Notes:
//
// static
HRESULT
CDialupConnection::CreateInstanceFromDetails (
    const RASENUMENTRYDETAILS*  pEntryDetails,
    REFIID                      riid,
    VOID**                      ppv)
{
    Assert(pEntryDetails);
    Assert(pEntryDetails->szPhonebookPath);

    CDialupConnection* pObj;
    HRESULT hr = CreateInstanceUninitialized (riid, ppv, &pObj);
    if (SUCCEEDED(hr))
    {
        pObj->SetPbkFile (pEntryDetails->szPhonebookPath);

        pObj->CacheProperties (pEntryDetails);

        // We are now a full-fledged object.
        //
        pObj->m_fInitialized = TRUE;
    }
    TraceError ("CDialupConnection::CreateInstanceFromDetails", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::CreateInstanceFromPbkFileAndEntryName
//
//  Purpose:    Create an initialized instance of
//              CComObject <CDialupConnection> given only a phonebook path,
//              entry name, and weather it is for all users or not and
//              return an interface pointer on that object.
//
//  Arguments:
//      pszPbkFile   [in]  Phonebook path.
//      pszEntryName [in]  Entry name.
//      riid          [in]  IID of desired interface.
//      ppv           [out] Returned interface pointer.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   20 Apr 1998
//
//  Notes:      This is called from Duplicate.
//
//static
HRESULT
CDialupConnection::CreateInstanceFromPbkFileAndEntryName (
    IN  PCWSTR pszPbkFile,
    IN  PCWSTR pszEntryName,
    IN  REFIID  riid,
    OUT VOID**  ppv)
{
    TraceTag (ttidWanCon,
        "CDialupConnection::CreateInstanceFromPbkFileAndEntryName called");

    CDialupConnection* pObj;
    HRESULT hr = CreateInstanceUninitialized (riid, ppv, &pObj);
    if (SUCCEEDED(hr))
    {
        pObj->SetPbkFile (pszPbkFile);
        pObj->SetEntryName (pszEntryName);
        pObj->m_guidId = GUID_NULL;

        // We are now a full-fledged object.
        //
        pObj->m_fInitialized = TRUE;
    }
    TraceError ("CDialupConnection::CreateInstanceFromPbkFileAndEntryName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnection
//

STDMETHODIMP
CDialupConnection::GetUiObjectClassId (
    OUT CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        static const CLSID CLSID_DialupConnectionUi =
                {0x7007ACC1,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

        static const CLSID CLSID_DirectConnectionUi =
                {0x7007ACC2,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

        static const CLSID CLSID_VpnConnectionUi =
                {0x7007ACC6,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

        static const CLSID CLSID_PPPoEUi = 
                {0x7007ACD4,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};     

        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            switch (MediaType ())
            {
                case NCM_DIRECT:
                    *pclsid = CLSID_DirectConnectionUi;
                    break;

                case NCM_ISDN:
                case NCM_PHONE:
                    *pclsid = CLSID_DialupConnectionUi;
                    break;

                case NCM_TUNNEL:
                    *pclsid = CLSID_VpnConnectionUi;
                    break;

                case NCM_PPPOE:
                    *pclsid = CLSID_PPPoEUi;
                    break;

                default:
                    *pclsid = CLSID_DialupConnectionUi;
                    TraceTag (ttidWanCon, "GetUiObjectClassId: Unknown media type "
                        "(%d) treating as CLSID_DialupConnectionUi", MediaType());
            }
        }
    }
    TraceError ("CDialupConnection::GetUiObjectClassId", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Connect ()
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDialupConnection::Disconnect ()
{
    HRESULT hr;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        HRASCONN hRasConn;

        hr = HrFindRasConn (&hRasConn, NULL);
        if (S_OK == hr)
        {
            // Because RasHangup could call RasCustomHangup
            // we need to impersonate the client to allow the correct
            // per-user information to be used.
            //

            // Impersonate the client.
            //
            HRESULT hrT = CoImpersonateClient ();
            TraceErrorOptional ("CDialupConnection::Disconnect -- CoImpersonateClient", hrT, RPC_E_CALL_COMPLETE == hrT);

            // We need to continue if we're called in-proc (ie. if RPC_E_CALL_COMPLETE is returned).
            if (SUCCEEDED(hrT) || (RPC_E_CALL_COMPLETE == hrT))
            {
                hr = HrRasHangupUntilDisconnected (hRasConn);
            }
            
            if (SUCCEEDED(hrT))
            {
                hrT = CoRevertToSelf ();
                TraceError ("CDialupConnection::Disconnect -- CoRevertToSelf", hrT);
            }
        }
        else if (S_FALSE == hr)
        {
            hr = S_OK;
        }
    }
    TraceError ("CDialupConnection::Disconnect", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Delete ()
{
    HRESULT hr = E_UNEXPECTED;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            // If we allow removal (a decision which is based on the
            // whether the user is an admin, whether the connection is
            // 'for all users', and the connection's current state) then
            // proceed.  If FAllowRemoval fails, it's output parameter
            // is the "reason" in the form of an HRESULT.  We can use
            // this as our return value in that case.
            //
            HRESULT hrReason;
            if (FAllowRemoval (&hrReason))
            {
                // If we're active in any way, we can't be removed.
                //
                NETCON_STATUS status;

                hr = HrGetStatus(&status);
                if (SUCCEEDED(hr) &&
                    ((NCS_CONNECTING    != status) &&
                     (NCS_CONNECTED     != status) &&
                     (NCS_DISCONNECTING != status)))
                {

                    // We do an impersonation here in case the connection has a RAS custom delete notification
                    // setup (CM connections do, for instance).  This allows the RasCustomDeleteEntryNotify
                    // function to interact with the system as the user.
                    //
                    HRESULT hrT = CoImpersonateClient ();
                    TraceError ("HrRemoveCmProfile -- CoImpersonateClient", hrT);

                    // We need to continue if we're called in-proc (ie. if RPC_E_CALL_COMPLETE is returned).
                    if (SUCCEEDED(hrT) || (RPC_E_CALL_COMPLETE == hrT))
                    {
                        //  Delete the RAS entry, note that for branded connections, RAS
                        //  will call RasCustomDeleteEntryNotify after deletion.
                        //
                        DWORD dwErr = RasDeleteEntry (PszwPbkFile (), PszwEntryName ());

                        hr = HRESULT_FROM_WIN32 (dwErr);
                        TraceError ("RasDeleteEntry", hr);
                    }
                    
                    //  Revert to ourselves
                    //
                    if (SUCCEEDED(hrT))
                    {
                        CoRevertToSelf ();
                    }

                }
                else
                {
                    // Don't allow deletion unless disconnected
                    //
                    TraceTag (ttidWanCon, "Disallowing delete while in connected or"
                        "partially connected state");
                    hr = E_UNEXPECTED;
                }
            }
            else
            {
                hr = hrReason;
            }
        }
    }

    TraceError ("CDialupConnection::Delete", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Duplicate (
    IN  PCWSTR              pszDuplicateName,
    OUT INetConnection**    ppCon)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pszDuplicateName || !ppCon)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *ppCon = NULL;

        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            // Make sure the name is valid in the same phone book.
            //
            DWORD dwErr = RasValidateEntryName (
                            PszwPbkFile (), pszDuplicateName);

            hr = HRESULT_FROM_WIN32 (dwErr);
            TraceError ("RasValidateEntryName", hr);

            if (SUCCEEDED(hr))
            {
                dwErr = DwCloneEntry (
                            PszwPbkFile(),
                            PszwEntryName(),
                            pszDuplicateName);

                hr = HRESULT_FROM_WIN32 (dwErr);
                TraceError ("DwCloneEntry", hr);

                if (SUCCEEDED(hr))
                {
                    hr = CreateInstanceFromPbkFileAndEntryName (
                            PszwPbkFile (),
                            pszDuplicateName,
                            IID_INetConnection, (VOID**)ppCon);
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = HrEnsureHNetPropertiesCached();
                    }
                    
                    if (SUCCEEDED(hr))
                    {
                        if (m_HNetProperties.fFirewalled || m_HNetProperties.fIcsPublic) // lazy eval the hnetcfg stuff
                        {
                            IHNetCfgMgr* pHomenetConfigManager;
                            hr = HrGetHNetCfgMgr(&pHomenetConfigManager);
                            if(SUCCEEDED(hr))
                            {
                                IHNetConnection* pNewHomenetConnection;
                                hr = pHomenetConfigManager->GetIHNetConnectionForINetConnection(*ppCon, &pNewHomenetConnection);
                                if(SUCCEEDED(hr))
                                {
                                    IHNetConnection* pHomenetConnection;
                                    hr = HrGetIHNetConnection(&pHomenetConnection);
                                    if(SUCCEEDED(hr))
                                    {
                                        // copy port bindings
                                        // REVIEW if somethings fails here to we need to nuke the new connection?
                                        IEnumHNetPortMappingBindings* pEnumPortMappingBindings;
                                        hr = pNewHomenetConnection->EnumPortMappings(FALSE, &pEnumPortMappingBindings);
                                        if(SUCCEEDED(hr))
                                        {
                                            ULONG ulFetched;
                                            IHNetPortMappingBinding* pNewPortMappingBinding;
                                            while(S_OK == pEnumPortMappingBindings->Next(1, &pNewPortMappingBinding, &ulFetched)) 
                                            {
                                                Assert(1 == ulFetched);
                                                IHNetPortMappingProtocol* pPortMappingProtocol;
                                                hr = pNewPortMappingBinding->GetProtocol(&pPortMappingProtocol);
                                                if(SUCCEEDED(hr))
                                                {
                                                    // find the original binding by using the protocol field
                                                    IHNetPortMappingBinding* pPortMappingBinding;
                                                    hr = pHomenetConnection->GetBindingForPortMappingProtocol(pPortMappingProtocol, &pPortMappingBinding);
                                                    if(SUCCEEDED(hr))
                                                    {
                                                        BOOLEAN bEnabled;
                                                        hr = pPortMappingBinding->GetEnabled(&bEnabled);
                                                        if(SUCCEEDED(hr))
                                                        {
                                                            if(TRUE == bEnabled)
                                                            {
                                                                hr = pNewPortMappingBinding->SetEnabled(bEnabled);
                                                            }
                                                        }
                                                        
                                                        // always set the computer address
                                                        
                                                        if(SUCCEEDED(hr))
                                                        {
                                                            ULONG ulAddress;
                                                            hr = pPortMappingBinding->GetTargetComputerAddress(&ulAddress);
                                                            if(SUCCEEDED(hr))
                                                            {
                                                                if(0 != ulAddress)
                                                                {
                                                                    hr = pNewPortMappingBinding->SetTargetComputerAddress(ulAddress);
                                                                }
                                                            }
                                                        }
                                                        
                                                        // only set the computer name if it is used
                                                        
                                                        if(SUCCEEDED(hr))
                                                        {
                                                            BOOLEAN bUseName;
                                                            hr = pPortMappingBinding->GetCurrentMethod(&bUseName);
                                                            if(SUCCEEDED(hr) && TRUE == bUseName)
                                                            {
                                                                OLECHAR* pszTargetComputerName;
                                                                hr = pPortMappingBinding->GetTargetComputerName(&pszTargetComputerName);
                                                                if(SUCCEEDED(hr))
                                                                {
                                                                    if(L'\0' != *pszTargetComputerName)
                                                                    {
                                                                        hr = pNewPortMappingBinding->SetTargetComputerName(pszTargetComputerName);
                                                                    }
                                                                    CoTaskMemFree(pszTargetComputerName);
                                                                }
                                                            }
                                                        }
                                                        ReleaseObj(pPortMappingBinding);    
                                                    }
                                                    ReleaseObj(pPortMappingProtocol);
                                                }
                                                ReleaseObj(pNewPortMappingBinding);
                                            }
                                            ReleaseObj(pEnumPortMappingBindings);
                                        }
                                        
                                        if(m_HNetProperties.fFirewalled) // copy firewall yes/no and ICMP settings
                                        {
                                            IHNetFirewalledConnection* pFirewalledConnection;
                                            hr = pNewHomenetConnection->Firewall(&pFirewalledConnection);
                                            if(SUCCEEDED(hr))
                                            {
                                                HNET_FW_ICMP_SETTINGS* pICMPSettings;
                                                hr = pHomenetConnection->GetIcmpSettings(&pICMPSettings);
                                                if(SUCCEEDED(hr))
                                                {
                                                    hr = pNewHomenetConnection->SetIcmpSettings(pICMPSettings);
                                                    CoTaskMemFree(pICMPSettings);
                                                }
                                                ReleaseObj(pFirewalledConnection);
                                            }
                                        }
                                        ReleaseObj(pHomenetConnection);
                                    }
                                    ReleaseObj(pNewHomenetConnection);
                                }
                                ReleaseObj(pHomenetConfigManager);
                            }
                        }
                    }
                }
            }
        }
    }
    TraceError ("CDialupConnection::Duplicate", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::GetProperties (
    OUT NETCON_PROPERTIES** ppProps)
{
    HRESULT hr = S_OK;
    HRESULT hrHiddenCM = S_OK;
    CMEntry cm;

    // Validate parameters.
    //
    if (!ppProps)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Initialize the output parameter.
        //
        *ppProps = NULL;

        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            NETCON_PROPERTIES* pProps;
            hr = HrCoTaskMemAlloc (sizeof (NETCON_PROPERTIES),
                    reinterpret_cast<VOID**>(&pProps));
            if (SUCCEEDED(hr))
            {
                HRESULT hrT;

                ZeroMemory (pProps, sizeof (NETCON_PROPERTIES));

                // guidId
                //
                pProps->guidId = GuidId ();

                // pszwName
                //
                hrT = HrCoTaskMemAllocAndDupSz (
                            PszwEntryName(),
                            &pProps->pszwName,
                            NETCON_MAX_NAME_LEN);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                hrT = HrCoTaskMemAllocAndDupSz (
                            PszwDeviceName(),
                            &pProps->pszwDeviceName,
                            NETCON_MAX_NAME_LEN);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                // Status
                //
                hrT = HrGetStatus (&pProps->Status);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                // Verify that the status return is accurate. HrGetStatus returns NCS_DISCONNECTED
                // if the connectoid is NCS_CONNECTING, which is wrong!!!!.
                //
                if( pProps->Status == NCS_DISCONNECTED )
                {
                    // CMUtil remebers the Hidden connection (Connection Manager) and the status of
                    // any ras events (i.e. Connecting, Disconnecting etc). The Data is filled in 
                    // in function RasEventNotify.
                    //
                    hrHiddenCM = CCMUtil::Instance().HrGetEntry(pProps->guidId,cm);
                    if ( S_OK == hrHiddenCM )
                    {
                        // Use CCMUtil's status, its more accurate.
                        //
                        pProps->Status = cm.m_ncs;
                    }
                }

                // Check if this connection has a child connection
                //
               
                hrHiddenCM = CCMUtil::Instance().HrGetEntry(PszwEntryName(),cm);        
                if( hrHiddenCM == S_OK )
                {
                    // It has a child connectoid
                    // Now we have to determine which one describes the overall status of the connection
                    //
                    if( cm.m_ncs == NCS_CONNECTING || cm.m_ncs == NCS_DISCONNECTING ||
                        cm.m_ncs == NCS_CONNECTED)
                    {
                        if( pProps->Status == NCS_DISCONNECTING )
                        {
                            // This case happens if the parent is disconnecting
                            // The parent is disconnecting, so the child will be disconnecting.
                            // Change the status of the child to disconnecting so that we do not
                            // get confused later on when the child is connected at the parent is
                            // disconnected. i.e. are we overall connecting or disconnecting!!!!
                            //
                            CCMUtil::Instance().SetEntry(GuidId (), PszwEntryName(),pProps->Status);        
                        }
                        else
                        if( cm.m_ncs == NCS_CONNECTED && pProps->Status == NCS_DISCONNECTED )
                        {
                            // This case will only happen if the child is connected and the parent is still
                            // disconnected.
                            //
                            pProps->Status = NCS_CONNECTING;
                        }
                        else if (!IsEqualGUID(pProps->guidId, cm.m_guid))
                        {
                            TraceTag(ttidWanCon, "Overwriting parent connection status: %s with child status: %s", DbgNcs(pProps->Status), DbgNcs(cm.m_ncs));

                            // When in doubt and the GUID's are different (ie. not a BAP/Multilink connection) take the childs status =)
                            //
                            pProps->Status = cm.m_ncs;
                        }
                    }

                }


                // Type
                //
                pProps->MediaType = MediaType ();

                // dwCharacter
                //
                hrT = HrGetCharacteristics (&pProps->dwCharacter);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                // clsidThisObject
                //
                pProps->clsidThisObject = CLSID_DialupConnection;

                // clsidUiObject
                //
                hrT = GetUiObjectClassId (&pProps->clsidUiObject);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }

                // Assign the output parameter or cleanup if we had any failures.
                //
                if (SUCCEEDED(hr))
                {
                    *ppProps = pProps;
                }
                else
                {
                    Assert (NULL == *ppProps);
                    FreeNetconProperties (pProps);
                }
            }
        }
    }
    TraceError ("CDialupConnection::GetProperties", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Rename (
    IN  PCWSTR pszNewName)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pszNewName)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrLockAndRenameEntry (pszNewName, this);
    }
    TraceError ("CDialupConnection::Rename", hr);
    return hr;
}


//+---------------------------------------------------------------------------
// INetRasConnection
//
STDMETHODIMP
CDialupConnection::GetRasConnectionInfo (
    OUT RASCON_INFO* pRasConInfo)
{
    HRESULT hr = HrGetRasConnectionInfo (pRasConInfo);

    TraceError ("CDialupConnection::GetRasConnectionInfo", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::SetRasConnectionInfo (
    IN const RASCON_INFO* pRasConInfo)
{
    HRESULT hr = HrSetRasConnectionInfo (pRasConInfo);

    TraceError ("CDialupConnection::SetRasConnectionInfo", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::GetRasConnectionHandle (
    OUT ULONG_PTR* phRasConn)
{
    HRESULT hr = HrGetRasConnectionHandle (
                    reinterpret_cast<HRASCONN*>(phRasConn));

    TraceError ("CDialupConnection::GetRasConnectionHandle",
        (S_FALSE == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
// IPersistNetConnection
//
STDMETHODIMP
CDialupConnection::GetClassID (
    OUT CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_DialupConnection;
    }
    TraceError ("CDialupConnection::GetClassID", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::GetSizeMax (
    OUT ULONG*  pcbSize)
{
    HRESULT hr = HrPersistGetSizeMax (pcbSize);
    TraceError ("CDialupConnection::GetSizeMax", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Load (
    IN  const BYTE* pbBuf,
    IN  ULONG       cbSize)
{
    HRESULT hr = HrPersistLoad (pbBuf, cbSize);
    TraceError ("CDialupConnection::Load", hr);
    return hr;
}

STDMETHODIMP
CDialupConnection::Save (
    OUT BYTE*   pbBuf,
    OUT ULONG   cbSize)
{
    HRESULT hr = HrPersistSave (pbBuf, cbSize);
    TraceError ("CDialupConnection::Save", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionBrandingInfo
//

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetBrandingIconPaths
//
//  Purpose:    Returns the full paths to three icons.
//
//  Arguments:  pConBrandInfo - pointer to an Icon branding structure
//
//  Returns:   S_OK or an error code
//
STDMETHODIMP
CDialupConnection::GetBrandingIconPaths(
    OUT CON_BRANDING_INFO ** ppConBrandInfo)
{
    HRESULT hr = HrEnsureEntryPropertiesCached ();
    CON_BRANDING_INFO * pConBrandInfo   = NULL;

    BOOL fRunOldVersion = TRUE;
    typedef DWORD (WINAPI* pfnGetCustomPropertiesFunc)(LPCWSTR, LPCWSTR, LPWSTR, PBYTE*, DWORD*);
    
    Assert(ppConBrandInfo);

    if (SUCCEEDED(hr)) 
    {
        if (!FIsBranded ())
        {
            hr = E_NOTIMPL;
        }
        else
        {
            WCHAR szTemp[MAX_PATH+1];
            WCHAR szIconName[MAX_PATH+1];
            const WCHAR* const CMSECTION = L"Connection Manager";
            HICON hIcon;

            hr = HrCoTaskMemAlloc(sizeof(CON_BRANDING_INFO), (LPVOID*)&pConBrandInfo);

            if (SUCCEEDED(hr)) 
            {
                ZeroMemory(pConBrandInfo, sizeof(CON_BRANDING_INFO));

                WCHAR szExpandedCustomDLL[MAX_PATH+1] = {0};
                HMODULE hCustomDll = NULL;
                DWORD dwRetCode = ERROR_SUCCESS;
                RASENTRY re = {0};
                DWORD dwNeededSize = sizeof(re);
                re.dwSize = dwNeededSize;
                DWORD dwTODOREMOVE = sizeof(re.szCustomDialDll)/sizeof(WCHAR);

                DWORD dwNum = GetPrivateProfileStringW(PszwEntryName (), L"CustomRasDialDll", L"", &re.szCustomDialDll[0], 
                                                      (sizeof(re.szCustomDialDll)/sizeof(WCHAR))-1, PszwPbkFile ());
                if (0 == dwNum)
                {
                    dwRetCode = RasGetEntryProperties(PszwPbkFile (), PszwEntryName (), &re, &dwNeededSize, NULL, NULL);
                }

                if ((ERROR_SUCCESS == dwRetCode) && (lstrlenW(re.szCustomDialDll)))
                {
                    BOOL fRetCode = ExpandEnvironmentStringsForUserW(NULL, re.szCustomDialDll, szExpandedCustomDLL, MAX_PATH);
                    if (fRetCode)
                    {
                        hCustomDll = LoadLibrary(szExpandedCustomDLL);
                        if (hCustomDll)
                        {
                            WCHAR szIconPath[(2*MAX_PATH) + 1] = {0};
                            WCHAR szHideTrayIcon[(2*MAX_PATH) + 1] = {0};
                            WCHAR szTrayIcon[(2*MAX_PATH) + 1] = {0};

                            pfnGetCustomPropertiesFunc pfnGetCustomProperties = NULL;
                            pfnGetCustomProperties = (pfnGetCustomPropertiesFunc)GetProcAddress(hCustomDll, "GetCustomProperty");

                            if (pfnGetCustomProperties)
                            {
                                DWORD dwSize = 2*MAX_PATH;
                                BOOL fRet = pfnGetCustomProperties(PszwPbkFile (), PszwEntryName (), L"Icon", (PBYTE*)&szIconPath, &dwSize);
                                if (fRet)
                                {
                                    if (NULL != (hIcon = (HICON)LoadImage(NULL, szIconPath, IMAGE_ICON, 32, 32, LR_LOADFROMFILE)))
                                    {
                                        DestroyIcon(hIcon);
                                        hr = HrCoTaskMemAllocAndDupSz (szIconPath, &(pConBrandInfo->szwLargeIconPath), MAX_PATH);
                                    }
                                }

                                dwSize = 2*MAX_PATH;
                                fRet = pfnGetCustomProperties(PszwPbkFile (), PszwEntryName (), L"HideTrayIcon", (PBYTE*)&szHideTrayIcon, &dwSize);
                                
                                // We don't care if we the call fails just need to check the length below
                                if (SUCCEEDED(hr))
                                {
                                    DWORD dwNewHideTrayIcon = 1; // default is to hide the icon

                                    if (szHideTrayIcon)
                                    {
                                        if (lstrlenW(szHideTrayIcon))
                                        {
                                            dwNewHideTrayIcon = _ttoi(szHideTrayIcon);
                                        }
                                    }
                                    
                                    if (dwNewHideTrayIcon)
                                    {
                                        dwSize = 2*MAX_PATH;
                                        fRet = pfnGetCustomProperties(PszwPbkFile (), PszwEntryName (), L"TrayIcon", (PBYTE*)&szTrayIcon, &dwSize);
                                        if (fRet)
                                        {
                                            if (NULL != (hIcon = (HICON)LoadImage(NULL, szTrayIcon, IMAGE_ICON, 16, 16, LR_LOADFROMFILE)))
                                            {
                                                DestroyIcon(hIcon);
                                                hr = HrCoTaskMemAllocAndDupSz (szTrayIcon, &(pConBrandInfo->szwTrayIconPath), MAX_PATH);
                                                if (SUCCEEDED(hr))
                                                {
                                                    //
                                                    // We got all the info for the icons
                                                    //
                                                    fRunOldVersion = FALSE;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        //
                                        // We got this far (meaning the call for getting the Icon succeeded), 
                                        // thus no need to run the older code which is left for compatibility reasons.
                                        //
                                        fRunOldVersion = FALSE;
                                    }
                                }
                            }
                            
                            FreeLibrary(hCustomDll);
                            hCustomDll = NULL;
                        }
                    }
                }

                //
                // For compatibility reasons we leave this code. If the CustomDialDll doesn't have the appropriate
                // entry point, then we'll just use this version of the code.
                //
                if (fRunOldVersion)
                {
                    // Get the path to the cms file to get the Icon entries from.
                    //
                    hr = HrEnsureCmStringsLoaded();

                    if (SUCCEEDED(hr))
                    {
                        //  Get the Large Icon path
                        //
                        if (0 != GetPrivateProfileStringW(CMSECTION, L"Icon", L"",
                                    szIconName, celems(szIconName), PszwCmsFile ()))
                        {
                            lstrcpynW(szTemp, PszwCmDir (), celems(szTemp));
                            lstrcatW(szTemp, szIconName);

                            if (NULL != (hIcon = (HICON)LoadImage(NULL, szTemp, IMAGE_ICON, 32, 32, LR_LOADFROMFILE)))
                            {
                                DestroyIcon(hIcon);
                                hr = HrCoTaskMemAllocAndDupSz (szTemp, &(pConBrandInfo->szwLargeIconPath), MAX_PATH);
                            }
                        }

                        // See if the CM icon is hidden
                        WCHAR szHideTrayIcon[MAX_PATH+1];
                        DWORD dwHideTrayIcon = 1; // default is to hide the CM icon
                        if (SUCCEEDED(hr) &&
                            (0 != GetPrivateProfileStringW(CMSECTION, L"HideTrayIcon", L"1",
                                    szHideTrayIcon, celems(szHideTrayIcon), PszwCmsFile ())))
                        {
                            dwHideTrayIcon = _ttoi(szHideTrayIcon);
                        }

                        if (dwHideTrayIcon) // If the CM icon is not hidden, we don't want another branded icon. We'll use blinky lights instead
                        {
                            //  Get the Tray Icon path
                            //
                            if (SUCCEEDED(hr) &&
                                (0 != GetPrivateProfileStringW(CMSECTION, L"TrayIcon", L"",
                                        szIconName, celems(szIconName), PszwCmsFile ())))
                            {
                                lstrcpynW(szTemp, PszwCmDir (), celems(szTemp));
                                lstrcatW(szTemp, szIconName);

                                if (NULL != (hIcon = (HICON)LoadImage(NULL, szTemp, IMAGE_ICON, 16, 16, LR_LOADFROMFILE)))
                                {
                                    DestroyIcon(hIcon);
                                    hr = HrCoTaskMemAllocAndDupSz (szTemp, &(pConBrandInfo->szwTrayIconPath), MAX_PATH);
                                }
                            }
                        }
                    }
                } 
            }
        }
    }

    // Fill in the out param struct if we succeeded, otherwise leave it alone so it will still
    // marshall.
    //
    if (SUCCEEDED(hr))
    {
        *ppConBrandInfo = pConBrandInfo;
    }

    TraceError ("CDialupConnection::GetBrandingIconPaths", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetTrayMenuEntries
//
//  Purpose:    Returns any branded menu items to be added to the tray menu.
//
//  Arguments:  pMenuData -- Pointer to a Tray Menu Data struct
//
//  Returns:   S_OK or an error code
//
STDMETHODIMP
CDialupConnection::GetTrayMenuEntries(
    OUT CON_TRAY_MENU_DATA** ppMenuData)
{
    // initialize output
    Assert(ppMenuData);
    *ppMenuData = NULL;

    CON_TRAY_MENU_DATA * pMenuData = NULL;
    HRESULT hr = HrEnsureEntryPropertiesCached ();

    BOOL fRunOldVersion = TRUE;
    typedef DWORD (WINAPI* pfnGetCustomPropertiesFunc)(LPCWSTR, LPCWSTR, LPWSTR, PBYTE*, DWORD*);

    if (SUCCEEDED(hr))
    {
        if (!FIsBranded ())
        {
            hr = E_NOTIMPL;
        }
        else
        {
            WCHAR szExpandedCustomDLL[MAX_PATH+1] = {0};
            HMODULE hCustomDll = NULL;
            DWORD dwRetCode = ERROR_SUCCESS;
            RASENTRY re = {0};
            DWORD dwNeededSize = sizeof(re);
            re.dwSize = dwNeededSize;
            
            DWORD dwNum = GetPrivateProfileStringW(PszwEntryName (), L"CustomRasDialDll", L"", &re.szCustomDialDll[0], 
                                                  (sizeof(re.szCustomDialDll)/sizeof(WCHAR))-1, PszwPbkFile ());
            if (0 == dwNum)
            {
                dwRetCode = RasGetEntryProperties(PszwPbkFile (), PszwEntryName (), &re, &dwNeededSize, NULL, NULL);
            }

            if ((ERROR_SUCCESS == dwRetCode) && (lstrlenW(re.szCustomDialDll)))
            {
                BOOL fRetCode = ExpandEnvironmentStringsForUserW(NULL, re.szCustomDialDll, szExpandedCustomDLL, MAX_PATH);
                if (fRetCode)
                {
                    hCustomDll = LoadLibrary(szExpandedCustomDLL);
                    if (hCustomDll)
                    {
                        pfnGetCustomPropertiesFunc pfnGetCustomProperties = NULL;
                        pfnGetCustomProperties = (pfnGetCustomPropertiesFunc)GetProcAddress(hCustomDll, "GetCustomProperty");

                        if (pfnGetCustomProperties)
                        {
                            //
                            // This call actually allocates memory and fills in the whole structure inside 
                            // the GetCustomProperty call
                            //
                            DWORD dwSize = 0;
                            BOOL fRet = pfnGetCustomProperties(PszwPbkFile (), PszwEntryName (), L"Menu Items", (PBYTE*)&pMenuData, &dwSize);
                            if (fRet)
                            {
                                hr = S_OK; // needed at the end of the function
                                fRunOldVersion = FALSE;
                            }
                        }
                        
                        FreeLibrary(hCustomDll);
                        hCustomDll = NULL;
                    }
                }
            }

            //
            // For compatibility reasons we leave this code. If the CustomDialDll doesn't have the appropriate
            // entry point, then we'll just use this version of the code.
            //
            if (fRunOldVersion)
            {
                hr = HrEnsureCmStringsLoaded();
                if (SUCCEEDED(hr))
                {
                    //
                    //  Get the menu item section
                    //
                    WCHAR* pszMenuItemsSection = NULL;
                    int nSize;

                    hr = HrGetPrivateProfileSectionWithAlloc(&pszMenuItemsSection, &nSize);

                    //  Process the menu items
                    //
                    if (SUCCEEDED(hr) && (nSize>0))
                    {
                        //  We have menu items to process.  First make a copy of the data
                        //  and figure out a line count.
                        //
                        hr = HrCoTaskMemAlloc(sizeof(CON_TRAY_MENU_DATA), (LPVOID*)&pMenuData);
                        if (SUCCEEDED(hr))
                        {
                            DWORD dwCount = 0;
                            WCHAR*pszLine = NULL;
                            WCHAR szName[MAX_PATH+1];
                            WCHAR szCmdLine[MAX_PATH+1];
                            WCHAR szParams[MAX_PATH+1];

                            pszLine = pszMenuItemsSection;

                            while ((NULL != pszLine) && (0 != *pszLine))
                            {
                                if (SUCCEEDED(HrGetMenuNameAndCmdLine(pszLine, szName,
                                        szCmdLine, szParams)))
                                {
                                    dwCount++;
                                }
                                pszLine = pszLine + lstrlenW(pszLine) + 1;
                            }

                            ASSERT(0 != dwCount);

                            // Now that we have an accurate count, lets
                            // allocate the memory for the marshalling and
                            // reparse the items.
                            //
                            hr = HrCoTaskMemAlloc(dwCount*sizeof(CON_TRAY_MENU_ENTRY),
                                                  (LPVOID*)&pMenuData->pctme);

                            if (SUCCEEDED(hr))
                            {
                                pMenuData->dwCount = dwCount;

                                DWORD dwNumAdded = 0;
                                pszLine = pszMenuItemsSection;
                                while ((NULL != pszLine) && (0 != *pszLine) && SUCCEEDED(hr))
                                {
                                    if (SUCCEEDED(HrGetMenuNameAndCmdLine(pszLine,
                                        szName, szCmdLine, szParams)) && (dwNumAdded <= dwCount))
                                    {
                                        hr = HrFillInConTrayMenuEntry(szName, szCmdLine, szParams,
                                            &(pMenuData->pctme[dwNumAdded]));

                                        if (FAILED(hr))
                                        {
                                            CoTaskMemFree(&pMenuData->pctme);
                                        }

                                        dwNumAdded++;
                                    }
                                    pszLine = pszLine + lstrlenW(pszLine) + 1;
                                }
                            }
                            else
                            {
                                delete pMenuData;
                            }
                        }
                        delete (pszMenuItemsSection);
                    }
                }
            }
        }
    }

    // Fill in the out param struct if we succeeded, otherwise leave it alone so it will still
    // marshall.
    //
    if (SUCCEEDED(hr))
    {
        *ppMenuData = pMenuData;
    }

    TraceError ("CDialupConnection::GetTrayMenuEntries", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrGetPrivateProfileSectionWithAlloc
//
//  Purpose:    This function ensures that the CM specific member vars for dialup
//              are loaded and usable by CM specific functions.
//
//  Arguments: none
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrGetPrivateProfileSectionWithAlloc (
    OUT WCHAR** pszSection,
    OUT int*    pnSize)
{

    Assert(pszSection);
    Assert(pnSize);

    HRESULT hr = HrEnsureCmStringsLoaded();

    if (!pszSection)
    {
        return E_POINTER;
    }
    if (!pnSize)
    {
        return E_POINTER;
    }


    if (SUCCEEDED(hr))
    {
        const int c_64K= 64*1024;
        int nAllocated = 1024;
        *pnSize = nAllocated - 2;

        while ((nAllocated <= c_64K) && ((*pnSize) == (nAllocated - 2)))
        {
            //      Should never need more than the 4-5 lines we already allocated
            //      but someone might want lots of menu options.
            //
            if (NULL != *pszSection)
            {
                delete (*pszSection);
            }

            *pszSection = new WCHAR[nAllocated];

            if (*pszSection)
            {
                *pnSize = GetPrivateProfileSectionW(L"Menu Options",
                            *pszSection, nAllocated,
                            PszwCmsFile ());
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            nAllocated = 2*nAllocated;
        }

        if (nAllocated > c_64K)
        {
            hr = E_UNEXPECTED;
        }
        if (nAllocated > c_64K || 0 == *pnSize)
        {
            // We need to free this in both cases, because if the size is 0, then the callers don't free this.
            delete *pszSection;
        }
    }

    TraceError ("CDialupConnection::HrGetPrivateProfileSectionWithAlloc", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrGetMenuNameAndCmdLine
//
//  Purpose:    Given a menu item line from a CMS file parses out the Menu item name,
//                              Menu executable, and Menu item parameters.
//
//  Arguments:  pMenuData -- Pointer to a Tray Menu Data struct
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrGetMenuNameAndCmdLine(
    IN  PCWSTR pszString,
    OUT PWSTR szName,
    OUT PWSTR szProgram,
    OUT PWSTR szParams)
{
    WCHAR*      pszPtr1;
    WCHAR*      pszPtr2;
    WCHAR       szLine[MAX_PATH+1];
    BOOL fLong = FALSE;
    HRESULT hr;

    Assert(NULL != pszString);
    Assert(NULL != szName);
    Assert(NULL != szProgram);
    Assert(NULL != szParams);

    ZeroMemory(szName, celems(szName));
    ZeroMemory(szProgram, celems(szProgram));
    ZeroMemory(szParams, celems(szParams));

    lstrcpynW(szLine, pszString, celems(szLine));

    // Process the first portion, the "Name=" part
    //
    pszPtr1 = wcsstr(szLine, L"=");

    if (pszPtr1)
    {
        *pszPtr1 = 0;
        lstrcpynW(szName, szLine, MAX_PATH);

        // Process next portion, the program name
        //
        pszPtr1++;

        if (pszPtr1)
        {
            // Look for "+" or " " marking end of program portion
            //
            if (*pszPtr1 == L'+')
            {
                pszPtr1++;
                pszPtr2 = wcsstr(pszPtr1, L"+");
                fLong = TRUE;
            }
            else
            {
                // If not a long filename then we have two choices,
                // either a short program name and params or just a
                // short program name.
                //
                pszPtr2 = wcsstr(pszPtr1, L" ");
                fLong = FALSE;
            }

            // Terminate program name and copy
            //
            if (pszPtr2)
            {
                if (*pszPtr2 != 0)
                {
                    *pszPtr2 = 0;
                    pszPtr2++;
                }

                lstrcpynW(szProgram, pszPtr1, MAX_PATH);

                // Process final portion, the params
                //
                if (fLong)
                {
                    pszPtr2++; // skip blank
                }

                // Now we are have the param string
                //
                if (pszPtr2)
                {
                    lstrcpynW(szParams, pszPtr2, MAX_PATH);
                }
            }
            else
            {
                // Just a program with no params and no space seperator
                // (this happens on memphis)
                //
                lstrcpynW(szProgram, pszPtr1, MAX_PATH);
            }
        }
        hr = S_OK;
    }
    else
    {
        //  No entries
        //
        hr =  E_UNEXPECTED;
    }

    TraceError ("CDialupConnection::HrGetMenuNameAndCmdLine", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrFillInConTrayMenuEntry
//
//  Purpose:    Given the elements of a ConTrayMenuEntry struct, the function
//              allocs the memory necessary and copies of the given elements.
//
//  Arguments:  szwName - Display name of the command to show in the tray context menu
//              szwCmdLine - actual command to run for this menu entry
//              szwParams - command params for this command
//              pMenuEntry - pointer to the struct to fill in and execute
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrFillInConTrayMenuEntry (
    IN  PCWSTR szName,
    IN  PCWSTR szCmdLine,
    IN  PCWSTR szParams,
    OUT CON_TRAY_MENU_ENTRY* pMenuEntry)
{
    HRESULT hr;
    ZeroMemory(pMenuEntry, sizeof(CON_TRAY_MENU_ENTRY));

    hr = HrCoTaskMemAlloc ((lstrlenW(szName)+1)*sizeof(WCHAR),
                               (LPVOID*)&(pMenuEntry->szwMenuText));
    if (SUCCEEDED(hr))
    {
        lstrcpyW(pMenuEntry->szwMenuText, szName);
        hr = HrCoTaskMemAlloc ((lstrlenW(szParams)+1)*sizeof(WCHAR),
                                                   (LPVOID*)&(pMenuEntry->szwMenuParams));
        if (S_OK == hr)
        {
            lstrcpyW(pMenuEntry->szwMenuParams, szParams);
            if (0 == wcsncmp(PszwShortServiceName (), szCmdLine,
                    lstrlenW(PszwShortServiceName ())))
            {
                //
                //      Then we have an included file.  Add the profile dir path
                //
                // Take out the "short service name" because it's already included in the path
                PCWSTR pszFileName = szCmdLine + lstrlenW(PszwShortServiceName()) + 1;
                hr = HrCoTaskMemAlloc ((lstrlenW(pszFileName)+lstrlenW(PszwProfileDir())+1)*sizeof(WCHAR),
                                                           (LPVOID*)&(pMenuEntry->szwMenuCmdLine));
                if (S_OK == hr)
                {
                    lstrcpyW(pMenuEntry->szwMenuCmdLine, PszwProfileDir ());
                    lstrcatW(pMenuEntry->szwMenuCmdLine, pszFileName);
                }
            }
            else
            {
                hr = HrCoTaskMemAlloc ((lstrlenW(szCmdLine)+1)*sizeof(WCHAR),
                                                           (LPVOID*)&(pMenuEntry->szwMenuCmdLine));
                if (S_OK == hr)
                {
                    lstrcpyW(pMenuEntry->szwMenuCmdLine, szCmdLine);
                }
            }
        }
    }
    if (FAILED(hr))
    {
        //
        //      We Failed so free the memory
        //
        CoTaskMemFree(pMenuEntry->szwMenuText);
        CoTaskMemFree(pMenuEntry->szwMenuCmdLine);
        CoTaskMemFree(pMenuEntry->szwMenuParams);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrGetCmpFileLocation
//
//  Purpose:    Compares the phonebook file path to path of the current user's
//              application data dir.  If the initial paths are the same we have
//              a private profile.  Please NOTE that calling this function
//              requires the calling client to properly setup CoSetProxyBlanket for
//              a private user profile (matches the call to CoImpersonateClient)
//
//  Arguments:  szwPhonebook -- path to the phonebook the CM connectoid lives in
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrGetCmpFileLocation(
    IN  PCWSTR szPhonebook,
    IN  PCWSTR szEntryName,
    OUT PWSTR  szCmpFilePath)
{
    DWORD dwSize = MAX_PATH;
    HKEY hKey;
    HANDLE hBaseKey = NULL;
    HANDLE hFile;
    HRESULT hr;
    HRESULT hrImpersonate = E_FAIL;
    static const WCHAR c_mappingsRegKey[] = L"Software\\Microsoft\\Connection Manager\\Mappings";
    HANDLE hImpersonationToken = NULL;   // The token of the thread
    HANDLE hPrimaryToken = NULL;         // The primary token for the new process

    if ((NULL == szCmpFilePath) || (NULL == szPhonebook))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();

        if (SUCCEEDED(hr))
        {
            if (m_fForAllUsers)
            {
                //  We have an all users key so get the information from HKLM
                //
                hBaseKey = HKEY_LOCAL_MACHINE;
            }
            else
            {
                //  Then we have a private profile.  Since netman runs as a system account,
                //  we must impersonate the client and then make an RTL call to get
                //  the current users HKCU hive before querying the registry for the
                //  cmp path.  We also need to get the user token so that we can expand the
                //  cmp string in the single user case.
                //

                hrImpersonate = CoImpersonateClient ();
                TraceError ("HrGetCmpFileLocation -- CoImpersonateClient", hr);

                if (SUCCEEDED(hrImpersonate))
                {
                    NTSTATUS ntstat = RtlOpenCurrentUser(KEY_READ | KEY_WRITE, &hBaseKey);
                    hr = HRESULT_FROM_NT(ntstat);
                    TraceError ("RtlOpenCurrentUser", hr);

                    if (SUCCEEDED(hr))
                    {
                        // Create a primary token
                        //
                        if (!OpenThreadToken(
                                GetCurrentThread(),
                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_ASSIGN_PRIMARY,
                                TRUE,
                                &hImpersonationToken))
                        {
                            hr = HrFromLastWin32Error();
                            TraceError ("HrGetCmpFileLocation -- OpenThreadToken", hr);
                        }
                        else
                        {
                            if(!DuplicateTokenEx(hImpersonationToken,
                                TOKEN_IMPERSONATE | TOKEN_READ | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE,
                                NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                &hPrimaryToken
                                ))
                            {
                                hr = HrFromLastWin32Error();
                                TraceError ("HrGetCmpFileLocation -- DuplicateTokenEx", hr);
                            }
                        }
                    }
                }
                else
                {
                    hr = hrImpersonate;
                }
            }

            //  Now Open the mappings key and get the cmp file path
            //
            if (SUCCEEDED(hr) && hBaseKey)
            {
                hr = HrRegOpenKeyEx((HKEY)hBaseKey,
                                    c_mappingsRegKey,
                                    KEY_READ, &hKey);

                if (SUCCEEDED(hr))
                {
                    dwSize = MAX_PATH;
                    WCHAR szTemp[MAX_PATH+1];
                    hr = HrRegQuerySzBuffer(hKey, szEntryName, szTemp, &dwSize);

                    if (SUCCEEDED (hr))
                    {
                        //  Check to see if the file exists
                        //
                        if (!m_fForAllUsers)
                        {
                            ExpandEnvironmentStringsForUserW(hPrimaryToken, szTemp,
                                szCmpFilePath, MAX_PATH);
                        }
                        else
                        {
                            lstrcpyW(szCmpFilePath, szTemp);
                        }

                        hFile = CreateFile(szCmpFilePath, GENERIC_READ, FILE_SHARE_READ,
                                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                        if (INVALID_HANDLE_VALUE == hFile)
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        else
                        {
                            CloseHandle(hFile);
                            hr = S_OK;
                        }
                    }
                    RegCloseKey(hKey);
                }
            }
        }

        if (!m_fForAllUsers)
        {
            if (hImpersonationToken)
            {
                CloseHandle(hImpersonationToken);
            }

            if (hPrimaryToken)
            {
                CloseHandle(hPrimaryToken);
            }

            // If it's a valid key that is not NULL then we can close it because we opened it.
            if (hBaseKey)
            {
                // Close the handle opened by RtlOpenCurrentUser
                //
                NtClose(hBaseKey);
            }

        }
        if (SUCCEEDED(hrImpersonate))
        {
            hr = CoRevertToSelf ();
            TraceError ("HrGetCmpFileLocation -- CoRevertToSelf", hr);
        }        
    }

    TraceError ("CDialupConnection::HrGetCmpFileLocation", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::HrEnsureCmStringsLoaded
//
//  Purpose:    This function ensures that the CM specific member vars for dialup
//              are loaded and usable by CM specific functions.  Please NOTE that
//              calling EnsureCmStringsAreLoaded requires the calling client to
//              properly setup CoSetProxyBlanket for a private user profile.
//
//  Arguments: none
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::HrEnsureCmStringsLoaded()
{
    HRESULT hr = S_OK;

    if (!m_fCmPathsLoaded)
    {
        WCHAR szwCmpFile[MAX_PATH];
        WCHAR szwCmsFile[MAX_PATH];
        WCHAR szwDrive[MAX_PATH];
        WCHAR szwDir[MAX_PATH];
        WCHAR szwFileName[MAX_PATH];
        WCHAR szwExtension[MAX_PATH];
        WCHAR szwProfileDir[MAX_PATH];
        WCHAR szwCmDir[MAX_PATH];

        int nNumChars;

        hr = HrGetCmpFileLocation(PszwPbkFile (), PszwEntryName (), szwCmpFile);

        if (SUCCEEDED(hr))
        {
            //  Now split the path
            //
            _wsplitpath(szwCmpFile, szwDrive, szwDir, szwFileName, szwExtension);

            //  Now construct the path to the cms file
            //
            nNumChars = wsprintfW(szwCmsFile, L"%s%s%s\\%s%s", szwDrive, szwDir, szwFileName, szwFileName, L".cms");
            ASSERT(nNumChars < celems(szwCmsFile));

            //  Now construct the profile dir path
            //
            nNumChars = wsprintfW(szwProfileDir, L"%s%s%s\\", szwDrive, szwDir, szwFileName);
            ASSERT(nNumChars < celems(szwProfileDir));

            //  Now construct the CM dir path
            //
            nNumChars = wsprintfW(szwCmDir, L"%s%s", szwDrive, szwDir);
            ASSERT(nNumChars < celems(szwCmDir));

            //  Now transfer to the member variables
            //
            m_strCmsFile = szwCmsFile;
            m_strProfileDir = szwProfileDir;    // remember this already has the trailing slash
            m_strCmDir = szwCmDir;              // remember this already has the trailing slash
            m_strShortServiceName = szwFileName;
            m_fCmPathsLoaded = TRUE;
        }
    }

    TraceError ("CDialupConnection::HrEnsureCmStringsLoaded", hr);
    return hr;
}

// INetDefaultConnection

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::SetDefault
//
//  Purpose:    Set the default RAS connection
//
//  Arguments:  TRUE to set as default connection. FALSE to unset it
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::SetDefault(IN  BOOL bDefault)
{
    HRESULT hr = S_OK;
    HRESULT hrT = S_OK;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            RASAUTODIALENTRY adEntry;
            ZeroMemory(&adEntry, sizeof(adEntry));
            
            adEntry.dwSize = sizeof(adEntry);
            if (bDefault)
            {
                wcsncpy(adEntry.szEntry, PszwEntryName(), sizeof(adEntry.szEntry) / sizeof(TCHAR));
            }

            hrT = CoImpersonateClient();
            if (SUCCEEDED(hrT))
            {
                DWORD dwErr = RasSetAutodialAddress(
                                NULL,
                                NULL,
                                &adEntry,
                                sizeof(adEntry),
                                1);

                if (dwErr != NO_ERROR)
                {
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
                hrT = CoRevertToSelf();
            }
        }
    }
    TraceError ("CDialupConnection::SetDefault", hr);
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetDefault
//
//  Purpose:    Get the default RAS connection
//
//  Arguments:  pbDefault - Is this the default connection
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::GetDefault (OUT BOOL* pbDefault)
{
    HRESULT hr = S_OK;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            if (m_dwFlagsPriv & REED_F_Default)
            {
                *pbDefault = TRUE;
            }
            else
            {
                *pbDefault = FALSE;
            }
        }
    }

    TraceError ("CDialupConnection::GetDefault", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDialupConnection::GetPropertiesEx
//
//  Purpose:    Get the GetPropertiesEx for this connection
//
//  Arguments:  ppConnectionPropertiesEx [out]
//
//  Returns:    S_OK or an error code
//
HRESULT
CDialupConnection::GetPropertiesEx(OUT NETCON_PROPERTIES_EX** ppConnectionPropertiesEx)
{
    HRESULT hr = S_OK;

    *ppConnectionPropertiesEx = NULL;
    
    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        NETCON_PROPERTIES* pProps;
        NETCON_PROPERTIES_EX* pPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));

        if (pPropsEx)
        {
        
            ZeroMemory(pPropsEx, sizeof(NETCON_PROPERTIES_EX));

            hr = GetProperties(&pProps);
        
            if (SUCCEEDED(hr))
            {
                hr = HrBuildPropertiesExFromProperties(pProps, pPropsEx, dynamic_cast<IPersistNetConnection *>(this));
                if (SUCCEEDED(hr))
                {
                    pPropsEx->bstrPhoneOrHostAddress = SysAllocString(m_strPhoneNumber.c_str());
                    *ppConnectionPropertiesEx = pPropsEx;
                }
                FreeNetconProperties(pProps);
            }

            if (FAILED(hr))
            {
                CoTaskMemFree(pPropsEx);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    TraceError ("CDialupConnection::GetPropertiesEx", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\dialup\dialup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I A L U P . H
//
//  Contents:   Dial-up Connection UI object.
//
//  Notes:
//
//  Author:     shaunco   15 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "rasconob.h"
#include <rasapip.h>

class ATL_NO_VTABLE CDialupConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CDialupConnection,
                        &CLSID_DialupConnection>,
    public CRasConnectionBase,
    public INetConnection,
    public INetRasConnection,
    public IPersistNetConnection,
    public INetConnectionBrandingInfo,
    public INetDefaultConnection,
    public INetConnection2
{
public:
    CDialupConnection () throw() : CRasConnectionBase ()
    {
        m_fCmPathsLoaded = FALSE;
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_DIALUP_CONNECTION)

    BEGIN_COM_MAP(CDialupConnection)
        COM_INTERFACE_ENTRY(INetConnection)
        COM_INTERFACE_ENTRY(INetConnection2)
        COM_INTERFACE_ENTRY(INetRasConnection)
        COM_INTERFACE_ENTRY(INetDefaultConnection)
        COM_INTERFACE_ENTRY(IPersistNetConnection)
        COM_INTERFACE_ENTRY(INetConnectionBrandingInfo)
    END_COM_MAP()

    // INetConnection
    STDMETHOD (Connect) ();

    STDMETHOD (Disconnect) ();

    STDMETHOD (Delete) ();

    STDMETHOD (Duplicate) (
        IN  PCWSTR             pszDuplicateName,
        OUT INetConnection**    ppCon);

    STDMETHOD (GetProperties) (
        OUT NETCON_PROPERTIES** ppProps);

    STDMETHOD (GetUiObjectClassId) (
        OUT CLSID*  pclsid);

    STDMETHOD (Rename) (
        IN  PCWSTR pszNewName);

    // INetRasConnection
    STDMETHOD (GetRasConnectionInfo) (
        OUT RASCON_INFO* pRasConInfo);

    STDMETHOD (SetRasConnectionInfo) (
        IN  const RASCON_INFO* pRasConInfo);

    STDMETHOD (GetRasConnectionHandle) (
        OUT ULONG_PTR*  phRasConn);

    // IPersistNetConnection
    STDMETHOD (GetClassID) (
        OUT CLSID* pclsid);

    STDMETHOD (GetSizeMax) (
        OUT ULONG* pcbSize);

    STDMETHOD (Load) (
        IN  const BYTE* pbBuf,
        IN  ULONG       cbSize);

    STDMETHOD (Save) (
        OUT BYTE*  pbBuf,
        IN  ULONG  cbSize);

    // INetConnectionBrandingInfo
    STDMETHOD (GetBrandingIconPaths) (OUT CON_BRANDING_INFO  ** ppConBrandInfo);
    STDMETHOD (GetTrayMenuEntries)(OUT CON_TRAY_MENU_DATA ** ppMenuData);

    // INetDefaultConnection
    STDMETHOD (SetDefault (IN  BOOL  bDefault));
    STDMETHOD (GetDefault (OUT BOOL* pbDefault));
    
    // INetConnection2
    STDMETHOD (GetPropertiesEx)(OUT NETCON_PROPERTIES_EX** ppConnectionPropertiesEx);

private:

    //  Private Vars to hold the paths to the CM file and keep track if they have been loaded or not.
    //
    tstring m_strCmsFile;
    tstring m_strProfileDir;
    tstring m_strShortServiceName;
    tstring m_strCmDir;
    BOOL    m_fCmPathsLoaded;

    //  Private Accessor functions for the above strings
    //
    PCWSTR
    PszwCmsFile () throw()
    {
        AssertH (!m_strCmsFile.empty());
        return m_strCmsFile.c_str();
    }
    PCWSTR
    PszwProfileDir () throw()
    {
        AssertH (!m_strProfileDir.empty());
        return m_strProfileDir.c_str();
    }
    PCWSTR
    PszwCmDir () throw()
    {
        AssertH (!m_strCmDir.empty());
        return m_strCmDir.c_str();
    }
    PCWSTR
    PszwShortServiceName () throw()
    {
        AssertH (!m_strShortServiceName.empty());
        return m_strShortServiceName.c_str();
    }

    //  Private methods for handling of type NCT_Internet
    HRESULT HrGetCmpFileLocation(IN  PCWSTR pszPhonebook, IN  PCWSTR pszEntryName, OUT PWSTR pszCmpFilePath);
    HRESULT HrEnsureCmStringsLoaded();
    HRESULT HrGetPrivateProfileSectionWithAlloc(OUT WCHAR** pszwSection, OUT int* nSize);
    HRESULT HrGetMenuNameAndCmdLine(IN  PCWSTR pszString, OUT PWSTR pszName, OUT PWSTR pszProgram, OUT PWSTR pszParams);
    HRESULT HrFillInConTrayMenuEntry(IN  PCWSTR pszName, IN  PCWSTR pszCmdLine, IN  PCWSTR pszParams, OUT CON_TRAY_MENU_ENTRY* pMenuEntry);
public:
    static HRESULT
    CreateInstanceUninitialized (
        IN  REFIID              riid,
        OUT VOID**              ppv,
        OUT CDialupConnection** ppObj);

    static HRESULT
    CreateInstanceFromDetails (
        const RASENUMENTRYDETAILS*  pEntryDetails,
        REFIID                      riid,
        VOID**                      ppv);

    static HRESULT
    CreateInstanceFromPbkFileAndEntryName (
        IN  PCWSTR pszwPbkFile,
        IN  PCWSTR pszwEntryName,
        IN  REFIID  riid,
        OUT VOID**  ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\dialup\enumw.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M W . C P P
//
//  Contents:   Enumerator for RAS connection objects.
//
//  Notes:
//
//  Author:     shaunco   2 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enumw.h"
#include "dialup.h"
#include "ncras.h"

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManagerEnumConnection::CreateInstance
//
//  Purpose:    Creates the WAN class manager's implementation of
//              a connection enumerator.
//
//  Arguments:
//      Flags        [in]
//      riid         [in]
//      ppv          [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   23 Sep 1997
//
//  Notes:
//
HRESULT
CWanConnectionManagerEnumConnection::CreateInstance (
    NETCONMGR_ENUM_FLAGS    Flags,
    REFIID                  riid,
    VOID**                  ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CWanConnectionManagerEnumConnection* pObj;
    pObj = new CComObject <CWanConnectionManagerEnumConnection>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_EnumFlags = Flags;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManagerEnumConnection::CWanConnectionManagerEnumConnection
//
//  Purpose:    Constructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   5 Oct 1997
//
//  Notes:
//
CWanConnectionManagerEnumConnection::CWanConnectionManagerEnumConnection () throw()
{
    m_EnumFlags         = NCME_DEFAULT;
    m_aRasEntryName     = NULL;
    m_cRasEntryName     = 0;
    m_iNextRasEntryName = 0;
    m_fDone             = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManagerEnumConnection::~CWanConnectionManagerEnumConnection
//
//  Purpose:    Destructor
//
//  Arguments:
//      (none)
//
//  Returns:    nothing
//
//  Author:     shaunco   2 Oct 1997
//
//  Notes:
//
CWanConnectionManagerEnumConnection::~CWanConnectionManagerEnumConnection () throw()
{
    MemFree (m_aRasEntryName);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWanConnectionManagerEnumConnection::HrNextOrSkip
//
//  Purpose:    Common implementation of Next and Skip.  rgelt and
//              pceltFetched are optional.  If provided, the output
//              objects are returned (for Next).  If not provided, the output
//              objects are not returned (for Skip).
//
//  Arguments:
//      celt         [in]   Count of elements to fetch or skip.
//      rgelt        [out]
//      pceltFetched [out]
//
//  Returns:
//
//  Author:     shaunco   15 Oct 1997
//
//  Notes:
//
HRESULT
CWanConnectionManagerEnumConnection::HrNextOrSkip (
    IN  ULONG               celt,
    OUT INetConnection**    rgelt,
    OUT ULONG*              pceltFetched)
{
    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    CExceptionSafeComObjectLock EsLock (this);

    // Enumerate the requested number of elements or stop short
    // if we don't have that many left to enumerate.
    //
    HRESULT hr = S_OK;
    ULONG   celtFetched = 0;
    while (SUCCEEDED(hr) && (celtFetched < celt) && !m_fDone)
    {
        // See if we need to fill m_aRasEntryName.  This is our
        // array of RASENTRYNAME structures enumerted from RAS.  We need
        // to keep this array across calls because RAS doesn't allow us to
        // pickup from a previous enumeration.  So, we enumerate everything
        // in one shot from RAS and hand it out to the caller however they
        // they want it.
        //
        if (!m_aRasEntryName)
        {
            // Because RasEnumEntries also enumerates per-user entries
            // we need to impersonate the client to allow the correct
            // per-user entries to be enumerated.
            //

            // Impersonate the client.
            //
            HRESULT hrT = CoImpersonateClient ();
            TraceHr (ttidError, FAL, hrT, FALSE, "CoImpersonateClient");

            // We need to continue if we're called in-proc (ie. if RPC_E_CALL_COMPLETE is returned).
            if (SUCCEEDED(hrT) || (RPC_E_CALL_COMPLETE == hrT))
            {
                hr = HrRasEnumAllEntriesWithDetails (NULL,
                    &m_aRasEntryName, &m_cRasEntryName);
            }

            if (SUCCEEDED(hrT))
            {
                hrT = CoRevertToSelf ();
                TraceHr (ttidError, FAL, hrT, FALSE, "CoRevertToSelf");
            }

            if (!m_cRasEntryName || FAILED(hr))
            {
                // RAS may not be installed or may otherwise have a problem.
                // We catch this here and return an empty enumeration.
                //
                Assert (!m_aRasEntryName);
                Assert (!m_cRasEntryName);

                m_fDone = TRUE;
                hr = S_OK;
            }
        }

        // Now that we have m_aRasEntryName and m_iNextRasEntryName,
        // use them to fill up the output array if we have an output
        // array to fill up.
        //
        if (SUCCEEDED(hr) && !m_fDone)
        {
            Assert (m_aRasEntryName);
            Assert (m_cRasEntryName);
            Assert (m_iNextRasEntryName < m_cRasEntryName);

            // Create the RAS connection objects.
            //
            while (SUCCEEDED(hr) && (celtFetched < celt) &&
                   (m_iNextRasEntryName < m_cRasEntryName))
            {
                // Its important that this check for rgelt come inside the
                // loop because we still need to loop to update our state
                // for the Skip case.
                //
                if (rgelt)
                {
                    hr = CDialupConnection::CreateInstanceFromDetails (
                            m_aRasEntryName + m_iNextRasEntryName,
                            IID_INetConnection,
                            reinterpret_cast<VOID**>(rgelt + celtFetched));
                }

                celtFetched++;
                m_iNextRasEntryName++;
            }

            if (m_iNextRasEntryName >= m_cRasEntryName)
            {
                Assert (S_OK == hr);
                m_fDone = TRUE;
                MemFree (m_aRasEntryName);
                m_aRasEntryName = NULL;
                m_cRasEntryName = 0;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidWanCon, "Enumerated %d RAS connections", celtFetched);

        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        hr = (celtFetched == celt) ? S_OK : S_FALSE;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        if (rgelt)
        {
            for (ULONG ulIndex = 0; ulIndex < celt; ulIndex++)
            {
                ReleaseObj (rgelt[ulIndex]);
                rgelt[ulIndex] = NULL;
            }
        }
        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }

    TraceError ("CWanConnectionManagerEnumConnection::HrNextOrSkip",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//

STDMETHODIMP
CWanConnectionManagerEnumConnection::Next (
    IN  ULONG               celt,
    OUT INetConnection**    rgelt,
    OUT ULONG*              pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceError ("CWanConnectionManagerEnumConnection::Next",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CWanConnectionManagerEnumConnection::Skip (
    IN  ULONG   celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceError ("CWanConnectionManagerEnumConnection::Skip",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CWanConnectionManagerEnumConnection::Reset ()
{
    CExceptionSafeComObjectLock EsLock (this);

    MemFree (m_aRasEntryName);
    m_aRasEntryName     = NULL;
    m_cRasEntryName     = 0;
    m_iNextRasEntryName = 0;
    m_fDone             = FALSE;

    return S_OK;
}

STDMETHODIMP
CWanConnectionManagerEnumConnection::Clone (
    OUT IEnumNetConnection**    ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        // Initialize output parameter.
        //
        *ppenum = NULL;

        CWanConnectionManagerEnumConnection* pObj;
        pObj = new CComObject <CWanConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Copy our internal state.
            //
            pObj->m_EnumFlags           = m_EnumFlags;

            ULONG cbBuf = m_cRasEntryName * sizeof (RASENUMENTRYDETAILS);
            if (cbBuf && m_aRasEntryName)
            {
                hr = E_OUTOFMEMORY;
                pObj->m_aRasEntryName = (RASENUMENTRYDETAILS*)(MemAlloc (cbBuf));
                if (pObj->m_aRasEntryName)
                {
                    hr = S_OK;
                    CopyMemory (pObj->m_aRasEntryName, m_aRasEntryName, cbBuf);
                    pObj->m_cRasEntryName = m_cRasEntryName;
                }
            }

            if (S_OK == hr)
            {
                pObj->m_iNextRasEntryName   = m_iNextRasEntryName;
                pObj->m_fDone               = m_fDone;

                // Return the object with a ref count of 1 on this
                // interface.
                pObj->m_dwRef = 1;
                *ppenum = pObj;
            }
            else
            {
                delete pObj;
            }
        }
    }
    TraceError ("CWanConnectionManagerEnumConnection::Clone", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\dialup\rasconob.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       R A S C O N O B . C P P
//
//  Contents:   Implements the base class used to implement the Dialup,
//              Direct, and Vpn connection objects.  Also includes
//              RAS-related utility functions used only within netman.exe.
//
//  Notes:
//
//  Author:     shaunco   23 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nmbase.h"
#include "nccom.h"
#include "ncperms.h"
#include "ncras.h"
#include "rasconob.h"
#include <raserror.h>
#include "gpnla.h" 

extern CGroupPolicyNetworkLocationAwareness* g_pGPNLA;

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::CacheProperties
//
//  Purpose:
//
//  Arguments:
//
//  Returns:    nothing.
//
//  Author:     shaunco   2 Feb 1998
//
//  Notes:
//
VOID
CRasConnectionBase::CacheProperties (
    IN  const RASENUMENTRYDETAILS*  pDetails) throw()
{
    Assert (pDetails);
    AssertSz(pDetails->dwSize >= sizeof(RASENUMENTRYDETAILS), "RASENUMENTRYDETAILS too small");

    m_fEntryPropertiesCached = TRUE;
    m_lRasEntryModifiedVersionEra = g_lRasEntryModifiedVersionEra;

    m_guidId                    = pDetails->guidId;
    SetEntryName (pDetails->szEntryName);
    m_fForAllUsers              = !!(pDetails->dwFlags & REN_AllUsers);
    m_fShowMonitorIconInTaskBar = pDetails->fShowMonitorIconInTaskBar;
    m_strDeviceName             = pDetails->szDeviceName;
    m_dwFlagsPriv               = pDetails->dwFlagsPriv;
    m_strPhoneNumber            = pDetails->szPhoneNumber;

    TraceTag(ttidWanCon, "PhoneNumber: %S", m_strPhoneNumber.c_str());

    m_fBranded = (RASET_Internet == pDetails->dwType);

    TraceTag (ttidWanCon, "rdt:0x%08x,  dwType:0x%08x",
        pDetails->rdt,
        pDetails->dwType);

    switch (LOWORD(pDetails->rdt))
    {
        case RDT_PPPoE:
            m_MediaType = NCM_PPPOE;
            break;

        case RDT_Modem:
        case RDT_X25:
            m_MediaType = NCM_PHONE;
            break;

        case RDT_Isdn:
            m_MediaType = NCM_ISDN;
            break;

        case RDT_Serial:
        case RDT_FrameRelay:
        case RDT_Atm:
        case RDT_Sonet:
        case RDT_Sw56:
            m_MediaType = NCM_PHONE;
            break;

        case RDT_Tunnel_Pptp:
        case RDT_Tunnel_L2tp:
            m_MediaType = NCM_TUNNEL;
            break;

        case RDT_Irda:
        case RDT_Parallel:
            m_MediaType = NCM_DIRECT;
            break;

        case RDT_Other:
        default:
            if (RASET_Vpn == pDetails->dwType)
            {
                m_MediaType = NCM_TUNNEL;
            }
            else if (RASET_Direct == pDetails->dwType)
            {
                m_MediaType = NCM_DIRECT;
            }
            else
            {
                m_MediaType = NCM_PHONE;
            }
            break;
    }

    if (pDetails->rdt & RDT_Tunnel)
    {
        m_MediaType = NCM_TUNNEL;
    }
    else if (pDetails->rdt & (RDT_Direct | RDT_Null_Modem))
    {
        m_MediaType = NCM_DIRECT;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::FAllowRemoval
//
//  Purpose:    Returns TRUE if the connection is in a state where we
//              can validly remove it.
//
//  Arguments:
//      phrReason [out] If FALSE is returned, this is the reason.  It is
//                      either E_ACCESSDENIED or E_UNEXPECTED.
//
//  Returns:    TRUE or FALSE.
//
//  Author:     shaunco   17 Jul 1998
//
//  Notes:
//
BOOL
CRasConnectionBase::FAllowRemoval (
    OUT HRESULT* phrReason) throw()
{
    Assert (phrReason);
    Assert (m_fEntryPropertiesCached);

    // If this connection is for all users, the user must be
    // an administrator or power user.
    //
    if (m_fForAllUsers && !FIsUserAdmin())
    {
        *phrReason = E_ACCESSDENIED;
        return FALSE;
    }

    // $$NOTE (jeffspr) -- moved the test for connection state to the
    // delete function because we don't want it to affect our loading
    // of characteristics

    //
    // If we passed all tests above, we're okay to remove.
    //
    *phrReason = S_OK;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrGetCharacteristics
//
//  Purpose:    Get the characteristics of the connection.
//
//  Arguments:
//      pdwFlags [out]
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   17 Jul 1998
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrGetCharacteristics (
    OUT DWORD*    pdwFlags)
{
    Assert (pdwFlags);

    DWORD dwFlags = NCCF_OUTGOING_ONLY;

    HRESULT hr = HrEnsureEntryPropertiesCached ();
    if (SUCCEEDED(hr))
    {
        if (FIsBranded ())
        {
            dwFlags |= NCCF_BRANDED;
        }
        else
        {
            dwFlags |= (NCCF_ALLOW_RENAME | NCCF_ALLOW_DUPLICATION);
        }

        if (m_fForAllUsers)
        {
            dwFlags |= NCCF_ALL_USERS;
        }

        if (m_dwFlagsPriv & REED_F_Default)
        {
            dwFlags |= NCCF_DEFAULT;
        }

        HRESULT hrReason;
        if (FAllowRemoval (&hrReason))
        {
            dwFlags |= NCCF_ALLOW_REMOVAL;
        }

        if (FShowIcon ())
        {
            dwFlags |= NCCF_SHOW_ICON;
        }

        if (S_OK == HrEnsureHNetPropertiesCached())
        {
            if (m_HNetProperties.fIcsPublic)
            {
                dwFlags |= NCCF_SHARED;
            }
            
            BOOL fIsFirewalled = FALSE;
            hr = HrIsConnectionFirewalled(&fIsFirewalled);
            if (fIsFirewalled)
            {
                dwFlags |= NCCF_FIREWALLED;
            }

        }
    }

    *pdwFlags = dwFlags;

    TraceError ("CRasConnectionBase::HrGetCharacteristics", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrGetStatus
//
//  Purpose:    Get the stauts of the connection.
//
//  Arguments:
//      pStatus [out] NETCON_STATUS
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   17 Jul 1998
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrGetStatus (
    OUT NETCON_STATUS*  pStatus)
{
    Assert (pStatus);

    // Initialize output parameters.
    //
    *pStatus = NCS_DISCONNECTED;

    // Find the active RAS connection corresponding to this object if
    // it exists.
    //
    HRASCONN hRasConn;
    HRESULT hr = HrFindRasConn (&hRasConn, NULL);
    if (S_OK == hr)
    {
        hr = HrRasGetNetconStatusFromRasConnectStatus (
                hRasConn, pStatus);

        // When the connection becomes disconnected between HrFindRas
        // and HrRasGet calls above, ERROR_INVALID_HANLDE is returned
        // this simply means that the connection has been disconnected.
        //
        if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr)
        {
            Assert (NCS_DISCONNECTED == *pStatus);
            hr = S_OK;
        }
    }
    else if (S_FALSE == hr)
    {
        hr = S_OK;

        if (!PszwDeviceName())
        {
            *pStatus = NCS_HARDWARE_NOT_PRESENT;
        }

        // NCS_HARDWARE_DISABLED ?
        // NCS_HARDWARE_MALFUNCTION ?
    }
    TraceError ("CRasConnectionBase::HrGetStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrEnsureEntryPropertiesCached
//
//  Purpose:    Ensures that the member's corresponding to entry properties
//              are cached by calling RasGetEntryProperties if needed.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   17 Dec 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrEnsureEntryPropertiesCached ()
{
    HRESULT hr = S_OK;

    // If we're not yet cached, or the cache is possibly out of date, we
    // need to update ourselves.  g_lRasEntryModifiedVersionEra is the global
    // version indicator for RAS phonebook entry modifications.  Our local
    // version indicator is set in CacheProperties.
    //
    if (!m_fEntryPropertiesCached ||
        (m_lRasEntryModifiedVersionEra != g_lRasEntryModifiedVersionEra))
    {
        // We now need to enumerate all entries in this phonebook and
        // find our details record with the matching guidId.
        //
        RASENUMENTRYDETAILS* aRasEntryDetails = NULL;
        DWORD                cRasEntryDetails = 0;

        // Impersonate the client.
        //
        HRESULT hrT = CoImpersonateClient ();
        TraceHr (ttidError, FAL, hrT, FALSE, "CoImpersonateClient");

        // We need to continue if we're called in-proc (ie. if RPC_E_CALL_COMPLETE is returned).
        if (SUCCEEDED(hrT) || (RPC_E_CALL_COMPLETE == hrT))
        {
            hr = HrRasEnumAllEntriesWithDetails (
                    PszwPbkFile(),
                    &aRasEntryDetails,
                    &cRasEntryDetails);

            if ((!aRasEntryDetails) || (!cRasEntryDetails))
            {
                hr = HRESULT_FROM_WIN32 (ERROR_NOT_FOUND);
            }
        }
        else
        {
            hr = hrT;
        }

        if (SUCCEEDED(hrT))
        {
            hrT = CoRevertToSelf ();
            TraceHr (ttidError, FAL, hrT, FALSE, "CoRevertToSelf");
        }

        if (SUCCEEDED(hr))
        {
            BOOL fNoGuidYet = (m_guidId == GUID_NULL);

            RASENUMENTRYDETAILS* pDetails;

            // Assume we don't find the entry.
            //
            hr = HRESULT_FROM_WIN32 (ERROR_NOT_FOUND);

            for (DWORD i = 0; i < cRasEntryDetails; i++)
            {
                pDetails = &aRasEntryDetails[i];

                if (pDetails->guidId == m_guidId)
                {
                    CacheProperties (pDetails);
                    hr = S_OK;

                    TraceTag (ttidWanCon,
                        "HrRasEnumAllEntriesWithDetails found entry "
                        "via guid (%S)",
                        PszwEntryName());
                    break;
                }
                else if (fNoGuidYet &&
                         !lstrcmpW (PszwEntryName(), pDetails->szEntryName))
                {
                    CacheProperties (pDetails);
                    hr = S_OK;

                    TraceTag (ttidWanCon,
                        "HrRasEnumAllEntriesWithDetails found entry "
                        "via entryname (%S)",
                        PszwEntryName());
                    break;
                }
            }

            MemFree (aRasEntryDetails);
        }
        else if (HRESULT_FROM_WIN32(ERROR_CANNOT_OPEN_PHONEBOOK) == hr)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }
    }
    TraceError ("CRasConnectionBase::HrEnsureEntryPropertiesCached", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrFindRasConn
//
//  Purpose:    Searches for the active RAS connection that corresponds to
//              this phone book and entry.
//
//  Arguments:
//      phRasConn   [out]   The returned handle to the RAS connection if it
//                          was found.  NULL otherwise.
//      pRasConn    [out]   Optional pointer to returned RASCONN structure
//                          if found.
//
//  Returns:    S_OK if found, S_FALSE if not, or an error code.
//
//  Author:     shaunco   29 Sep 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrFindRasConn (
    OUT HRASCONN* phRasConn,
    OUT RASCONN* pRasConn OPTIONAL)
{
    Assert (phRasConn);
    Assert (m_fInitialized);

    HRESULT hr = S_OK;

    // Initialize the output parameter.
    //
    *phRasConn = NULL;

    // We need m_guidId to be valid.  If it is GUID_NULL, it means
    // we have an entry name with with to look it up.
    //
    if (GUID_NULL == m_guidId)
    {
        hr = HrEnsureEntryPropertiesCached ();
    }

    if (SUCCEEDED(hr))
    {
        hr = HrFindRasConnFromGuidId (&m_guidId, phRasConn, pRasConn);

    }

    TraceError ("CRasConnectionBase::HrFindRasConn",
        (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrLockAndRenameEntry
//
//  Purpose:    Renames the phone book entry and updates our entry name
//              member atomically.
//
//  Arguments:
//      pszwNewName [in] The new name.
//      pObj        [in] Used to Lock the operation.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   23 Sep 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrLockAndRenameEntry (
    IN  PCWSTR                                     pszwNewName,
    IN  CComObjectRootEx <CComMultiThreadModel>*    pObj)
{
    // Make sure the name is valid in the same phone book.
    //
    DWORD dwErr = RasValidateEntryName (PszwPbkFile (), pszwNewName);

    HRESULT hr = HRESULT_FROM_WIN32 (dwErr);
    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr,
        "RasValidateEntryName", hr);

    // We can ignore ERROR_ALREADY_EXISTS as it will happen when a user
    // tries to change the case of the entry name.
    //
    if (SUCCEEDED(hr) || (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr))
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            // Lock the object and rename it.
            //
            CExceptionSafeComObjectLock EsLock (pObj);

            dwErr = RasRenameEntry (
                        PszwPbkFile (),
                        PszwEntryName (),
                        pszwNewName);

            hr = HRESULT_FROM_WIN32 (dwErr);
            TraceHr (ttidError, FAL, hr, FALSE, "RasRenameEntry");

            if (SUCCEEDED(hr))
            {
                SetEntryName (pszwNewName);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRasConnectionBase::HrLockAndRenameEntry");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrGetRasConnectionInfo
//
//  Purpose:    Implementation of INetRasConnection::GetRasConnectionInfo
//
//  Arguments:
//      pRasConInfo [out] pointer to returned info
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Author:     shaunco   20 Oct 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrGetRasConnectionInfo (
    OUT RASCON_INFO* pRasConInfo)
{
    Assert (m_fInitialized);

    HRESULT hr;

    // Validate parameters.
    //
    if (!pRasConInfo)
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrEnsureEntryPropertiesCached ();
        if (SUCCEEDED(hr))
        {
            ZeroMemory (pRasConInfo, sizeof (*pRasConInfo));

            hr = S_OK;

            HRESULT hrT;

            hrT = HrCoTaskMemAllocAndDupSz (PszwPbkFile(),
                            &pRasConInfo->pszwPbkFile, MAX_PATH);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            hrT = HrCoTaskMemAllocAndDupSz (PszwEntryName(),
                            &pRasConInfo->pszwEntryName, MAX_PATH);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            pRasConInfo->guidId = m_guidId;

            if (FAILED(hr))
            {
                RciFree (pRasConInfo);

                AssertSz (!pRasConInfo->pszwPbkFile && !pRasConInfo->pszwEntryName,
                        "RciFree should be zeroing the structure!");
            }
        }
    }
    TraceError ("CRasConnectionBase::HrGetRasConnectionInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrSetRasConnectionInfo
//
//  Purpose:    Implementation of INetRasConnection::SetRasConnectionInfo
//
//  Arguments:
//      pRasConInfo [in] info to set
//
//  Returns:    S_OK
//
//  Author:     shaunco   20 Oct 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrSetRasConnectionInfo (
    IN  const RASCON_INFO* pRasConInfo)
{
    Assert (!m_fInitialized);

    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pRasConInfo)
    {
        hr = E_POINTER;
    }
    else if (!pRasConInfo->pszwPbkFile ||
             (0 == lstrlenW (pRasConInfo->pszwPbkFile)) ||
             !pRasConInfo->pszwEntryName ||
             (0 == lstrlenW (pRasConInfo->pszwEntryName)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        SetPbkFile (pRasConInfo->pszwPbkFile);
        SetEntryName (pRasConInfo->pszwEntryName);
        m_guidId = pRasConInfo->guidId;

        // We are now a full-fledged object.
        //
        m_fInitialized = TRUE;
    }
    TraceError ("CRasConnectionBase::HrSetRasConnectionInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrGetRasConnectionHandle
//
//  Purpose:    Implementation of INetRasConnection::HrGetRasConnectionHandle
//
//  Arguments:
//      phRasConn  [out] pointer to the returned RAS connection handle
//
//  Returns:    S_OK if connected, S_FALSE if not, error code otherwise.
//
//  Author:     CWill   09 Dec 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrGetRasConnectionHandle (
    OUT HRASCONN* phRasConn)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!phRasConn)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Initialize the output parameter.
        //
        *phRasConn = 0;

        hr = HrFindRasConn (phRasConn, NULL);
    }

    TraceError ("CRasConnectionBase::HrGetRasConnectionHandle",
        (S_FALSE == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
// IPersistNetConnection -
//
// For our persistent (across session) data, we choose to store only the
// the phonebook name and the guid Id of the RAS entry.  We explicitly don't
// store the entry name because it can be changed externally.  If it were
// we would have an orhpaned connection.
//
// When loading the connection from the persistent store, we need to
// enumerate all of the entries in the given phonebook looking for the one
// with the matching guid Id.  Once found, the connection can successfully
// be loaded.
//

// Lead and trail characters for our persistent memory form.
//
static const WCHAR c_chwLead  = 0x14;
static const WCHAR c_chwTrail = 0x05;


//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrPersistGetSizeMax
//
//  Purpose:    Implementation of IPersistNetConnection::GetSizeMax
//
//  Arguments:
//      pcbSize []
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   4 Nov 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrPersistGetSizeMax (
    OUT ULONG*  pcbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcbSize)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Size the buffer for the following form:
        //  +--------------------------------------------+
        //  |0x14<phonebook file>\0<guid Id>\0<users>0x05|
        //  +--------------------------------------------+
        //
        *pcbSize = sizeof (c_chwLead) +
                   CbOfSzAndTerm (PszwPbkFile()) +
                   sizeof (m_guidId) +
                   sizeof (m_fForAllUsers) +
                   sizeof (c_chwTrail);
    }
    TraceError ("CRasConnectionBase::HrPersistGetSizeMax", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrPersistLoad
//
//  Purpose:    Implementation of IPersistNetConnection::Load
//
//  Arguments:
//      pbBuf  []
//      cbSize []
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   4 Nov 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrPersistLoad (
    IN  const BYTE* pbBuf,
    IN  ULONG       cbSize)
{
    TraceFileFunc(ttidWanCon);
    // The theoretical minimum size for the buffer is:
    // (4 characters for a minimal path like 'c:\a')
    //
    const ULONG c_cbSizeMin = sizeof (c_chwLead) +
                              (4 + 1) * sizeof(WCHAR) +
                              sizeof (m_guidId) +
                              sizeof (m_fForAllUsers) +
                              sizeof (c_chwTrail);

    HRESULT hr = E_INVALIDARG;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (cbSize < c_cbSizeMin)
    {
        hr = E_INVALIDARG;
    }
    // We can only accept one call on this method and only if we're not
    // already initialized.
    //
    else if (m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // The buffer *should* look like this:
        //  +--------------------------------------------+
        //  |0x14<phonebook file>\0<guid Id>\0<users>0x05|
        //  +--------------------------------------------+
        //
        const WCHAR*            pchw = reinterpret_cast<const WCHAR*>(pbBuf);
        const WCHAR*            pchwMax;
        PCWSTR                  pszwPhonebook;
        GUID                    guidId;
        const GUID UNALIGNED    *pguidId;
        BOOL                    fForAllUsers;
        const BOOL UNALIGNED    *pfForAllUsers;

        // The last valid pointer for the embedded strings.
        //
        pchwMax = reinterpret_cast<const WCHAR*>(pbBuf + cbSize
                       - (sizeof (m_guidId) +
                          sizeof (m_fForAllUsers) +
                          sizeof (c_chwTrail)));

        if (c_chwLead != *pchw)
        {
            goto finished;
        }

        // Skip past our lead byte.
        //
        pchw++;

        // Get m_strPbkFile.  Search for the terminating null and make sure
        // we find it before the end of the buffer.  Using lstrlen to skip
        // the string can result in an an AV in the event the string is
        // not actually null-terminated.
        //
        for (pszwPhonebook = pchw; ; pchw++)
        {
            if (pchw >= pchwMax)
            {
                goto finished;
            }
            if (0 == *pchw)
            {
                pchw++;
                break;
            }
        }

        // Get m_guidId
        //
        pguidId = reinterpret_cast<const GUID*>(pchw);
        CopyMemory(&guidId, pguidId, sizeof(guidId));
        pguidId++;

        // Get m_fForAllUsers
        //
        pfForAllUsers = reinterpret_cast<const BOOL*>(pguidId);
        CopyMemory(&fForAllUsers, pfForAllUsers, sizeof(fForAllUsers));
        pfForAllUsers++;

        // Check our trail byte.
        //
        pchw = reinterpret_cast<const WCHAR *>(pfForAllUsers);
        if (c_chwTrail != *pchw)
        {
            goto finished;
        }

        TraceTag (ttidWanCon, "HrPersistLoad for %S", pszwPhonebook);

        SetPbkFile (pszwPhonebook);
        m_fForAllUsers = fForAllUsers;
        m_guidId = guidId;

        // We are now a full-fledged object.
        //
        m_fInitialized = TRUE;
        hr = S_OK;

    finished:
            ;
    }
    TraceError ("CRasConnectionBase::HrPersistLoad", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrPersistSave
//
//  Purpose:    Implementation of IPersistNetConnection::Save
//
//  Arguments:
//      pbBuf  []
//      cbSize []
//
//  Returns:    S_OK or an error code
//
//  Author:     shaunco   4 Nov 1997
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrPersistSave (
    BYTE*   pbBuf,
    ULONG   cbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Make sure the user's buffer is big enough.
        //
        ULONG cbSizeRequired;
        SideAssert (SUCCEEDED(HrPersistGetSizeMax(&cbSizeRequired)));

        if (cbSize < cbSizeRequired)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            TraceTag (ttidWanCon, "HrPersistSave for %S (%S)",
                PszwEntryName (),
                PszwPbkFile ());

            hr = HrEnsureEntryPropertiesCached ();
            if (SUCCEEDED(hr))
            {
                // Make the buffer look like this when we're done:
                //  +--------------------------------------------+
                //  |0x14<phonebook file>\0<guid Id>\0<users>0x05|
                //  +--------------------------------------------+
                //
                WCHAR* pchw = reinterpret_cast<WCHAR*>(pbBuf);

                // Put our lead byte.
                //
                *pchw = c_chwLead;
                pchw++;

                // Put m_strPbkFile
                //
                ULONG cchw = lstrlenW (PszwPbkFile());
                lstrcpyW (pchw, PszwPbkFile());
                pchw += cchw + 1;

                // Put m_guidId
                //
                GUID UNALIGNED *pguidId = reinterpret_cast<GUID*>(pchw);
                CopyMemory(pguidId, &GuidId(), sizeof(*pguidId));
                pguidId++;

                // Put m_fForAllUsers
                //
                BOOL UNALIGNED * pfForAllUsers = reinterpret_cast<BOOL*>(pguidId);
                CopyMemory(pfForAllUsers, &m_fForAllUsers, sizeof(*pfForAllUsers));
                pfForAllUsers++;

                // Put our trail byte.
                //
                pchw = reinterpret_cast<WCHAR*>(pfForAllUsers);
                *pchw = c_chwTrail;
                pchw++;

                AssertSz (pbBuf + cbSizeRequired == (BYTE*)pchw,
                    "pch isn't pointing where it should be.");
            }
        }
    }
    TraceError ("CRasConnectionBase::HrPersistSave", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasConnectionBase::HrEnsureHNetPropertiesCached
//
//  Purpose:    Makes sure home networking properties are up-to-date
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if m_pHNetProperties is now valid (success)
//              S_FALSE if it's not currently possible to update the properties
//              (e.g., recursive attempt to update)
//
//  Author:     jonburs     16 August 2000
//
//  Notes:
//
HRESULT
CRasConnectionBase::HrEnsureHNetPropertiesCached ()
{
    HRESULT hr = S_OK;

    if (!m_fHNetPropertiesCached
        || m_lHNetModifiedEra != g_lHNetModifiedEra)
    {
        //
        // Our cached properties are possibly out of date. Check
        // to see that this is not a recursive entry
        //

        if (0 == InterlockedExchange(&m_lUpdatingHNetProperties, 1))
        {
            IHNetConnection *pHNetConn;
            HNET_CONN_PROPERTIES *pProps;

            hr = HrGetIHNetConnection(&pHNetConn);

            if (SUCCEEDED(hr))
            {
                hr = pHNetConn->GetProperties(&pProps);
                ReleaseObj(pHNetConn);

                if (SUCCEEDED(hr))
                {
                    //
                    // Copy retrieved properties to member structure.
                    //

                    CopyMemory(
                        reinterpret_cast<PVOID>(&m_HNetProperties),
                        reinterpret_cast<PVOID>(pProps),
                        sizeof(m_HNetProperties)
                        );

                    CoTaskMemFree(pProps);

                    //
                    // Update our era, and note that we have valid properties
                    //

                    InterlockedExchange(&m_lHNetModifiedEra, g_lHNetModifiedEra);
                    m_fHNetPropertiesCached = TRUE;

                    hr = S_OK;
                }
            }
            else
            {
                //
                // If we don't yet have a record of this connection w/in the
                // home networking store, HrGetIHNetConnection will fail (as
                // we ask it not to create new entries). We therefore convert
                // failure to S_FALSE, which means we can't retrieve this info
                // right now.
                //

                hr = S_FALSE;
            }

            //
            // We're no longer updating our properties
            //

            InterlockedExchange(&m_lUpdatingHNetProperties, 0);
        }
        else
        {
            //
            // Update is alredy going on (possibly an earlier call on
            // the same thread). Return S_FALSE.
            //

            hr = S_FALSE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:   HrGetIHNetConnection
//
//  Purpose:    Retrieves the IHNetConnection for this connection
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     jonburs 16 August 2000
//
//  Notes:
//
HRESULT CRasConnectionBase::HrGetIHNetConnection (
    OUT IHNetConnection **ppHNetConnection)
{
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr;
    GUID guid;

    Assert(ppHNetConnection);

    hr = HrGetHNetCfgMgr(&pCfgMgr);

    if (SUCCEEDED(hr))
    {
        guid = GuidId();

        hr = pCfgMgr->GetIHNetConnectionForGuid(
                &guid,
                FALSE,
                FALSE,
                ppHNetConnection
                );

        ReleaseObj(pCfgMgr);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:   HrGetIHNetConnection
//
//  Purpose:    Retrieves the IHNetConnection for this connection
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     jonburs 16 August 2000
//
//  Notes:
//
HRESULT CRasConnectionBase::HrIsConnectionFirewalled(
    OUT BOOL* pfFirewalled)
{
    *pfFirewalled = FALSE;

    HRESULT hr = S_OK;
    BOOL fHasPermission = FALSE;
    
    hr = HrEnsureHNetPropertiesCached();
    if (S_OK == hr)
    {
        *pfFirewalled = m_HNetProperties.fFirewalled;

        if (*pfFirewalled)
        {
            // A Connection is only firewalled if the firewall is currently running, so
            // we return FALSE if the permission denies the firewall from running.
            hr = HrEnsureValidNlaPolicyEngine();
            TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "CRasConnectionBase::HrIsConnectionFirewalled calling HrEnsureValidNlaPolicyEngine", hr);

            if (SUCCEEDED(hr))
            {
                hr = m_pNetMachinePolicies->VerifyPermission(NCPERM_PersonalFirewallConfig, &fHasPermission);
                if (SUCCEEDED(hr) && !fHasPermission)
                {
                    *pfFirewalled = FALSE;
                }
            }
        }
    }
        
    return hr;
}

HRESULT CRasConnectionBase::HrEnsureValidNlaPolicyEngine()
{
    HRESULT hr = S_FALSE;  // Assume we already have the object
    
    if (!m_pNetMachinePolicies)
    {
        hr = CoCreateInstance(CLSID_NetGroupPolicies, NULL, CLSCTX_INPROC, IID_INetMachinePolicies, reinterpret_cast<void**>(&m_pNetMachinePolicies));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\dialup\rasconob.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S C O N O B . H
//
//  Contents:   Declares the base class used to implement the Dialup, Direct,
//              and Vpn connection objects.  Also includes RAS-related
//              utility functions used only within netman.exe.
//
//  Notes:
//
//  Author:     shaunco   23 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netconp.h"
#include "nmhnet.h"
#include <ras.h>
#include <rasapip.h>


class CRasConnectionBase
{
protected:
    BOOL                m_fInitialized;

    // These are the 'primary id' for the connection.  Every property of
    // a connection can be obtained using these two pieces of information.
    //
    tstring             m_strPbkFile;
    GUID                m_guidId;

    // m_fEntryPropertiesCached is set to TRUE after the first call
    // to HrEnsureEntryPropertiesCached.  The following members are cached
    // as a result of this.
    //
    BOOL                m_fEntryPropertiesCached;
    LONG                m_lRasEntryModifiedVersionEra;
    tstring             m_strEntryName;
    tstring             m_strDeviceName;
    BOOL                m_fBranded;
    BOOL                m_fForAllUsers;
    BOOL                m_fShowMonitorIconInTaskBar;
    NETCON_MEDIATYPE    m_MediaType;
    DWORD               m_dwFlagsPriv;
    tstring             m_strPhoneNumber;


    // This is required for checking permission on Firewall etc.
    CComPtr<INetMachinePolicies>    m_pNetMachinePolicies;
    
    // Home networking support. m_fHNetPropertiesCached is set to TRUE
    // after the first successful call to HrEnsureHNetPropertiesCached.
    //
    BOOL                m_fHNetPropertiesCached;
    LONG                m_lHNetModifiedEra;
    LONG                m_lUpdatingHNetProperties;
    HNET_CONN_PROPERTIES    m_HNetProperties;

protected:
    CRasConnectionBase () throw()
    {
        // Warning: this class should never have any virtual methods
        // or derive from a class with virtual methods.  If it does,
        // you'll have to remove the ZeroMemory and replace it with
        // induhvidual moves.  (Did you catch the Dilbert reference?)
        //
        ZeroMemory (this, sizeof(CRasConnectionBase));
    }

    BOOL FAllowRemoval (
        OUT HRESULT* phReason) throw();

    BOOL
    FIsBranded () throw()
    {
        AssertH (m_fEntryPropertiesCached);
        return m_fBranded;
    }

    BOOL
    FShowIcon () throw()
    {
        AssertH (m_fEntryPropertiesCached);
        return m_fShowMonitorIconInTaskBar;
    }

    GUID
    GuidId () throw()
    {
        AssertH (m_fEntryPropertiesCached);
        AssertH (m_guidId != GUID_NULL);
        return m_guidId;
    }

    PCWSTR
    PszwPbkFile () throw()
    {
        AssertH (!m_strPbkFile.empty());
        return m_strPbkFile.c_str();
    }

    PCWSTR
    PszwEntryName () throw()
    {
        AssertH (!m_strEntryName.empty());
        return m_strEntryName.c_str();
    }

    VOID
    SetPbkFile (
            PCWSTR pszwPbkFile) throw()
    {
        AssertH (pszwPbkFile);
        m_strPbkFile = pszwPbkFile;
        AssertH (!m_strPbkFile.empty());
    }

    VOID
    SetEntryName (
            PCWSTR pszwEntryName) throw()
    {
        AssertH (pszwEntryName);
        m_strEntryName = pszwEntryName;
        AssertH (!m_strEntryName.empty());
    }

    PCWSTR
    PszwDeviceName () throw()
    {
        AssertH (m_fEntryPropertiesCached);
        return (!m_strDeviceName.empty()) ? m_strDeviceName.c_str()
                                          : NULL;
    }

    NETCON_MEDIATYPE
    MediaType () throw()
    {
        AssertH (m_fEntryPropertiesCached);
        return m_MediaType;
    }


    VOID
    CacheProperties (
        IN  const RASENUMENTRYDETAILS*  pDetails) throw();

    HRESULT
    HrEnsureEntryPropertiesCached ();

    HRESULT
    HrFindRasConn (
        OUT HRASCONN* phRasConn,
        OUT RASCONN* pRasConn OPTIONAL);

    HRESULT HrGetCharacteristics (
        OUT DWORD*    pFlags);

    HRESULT HrGetStatus (
        OUT NETCON_STATUS*  pStatus);

    HRESULT
    HrLockAndRenameEntry (
        IN  PCWSTR                                     pszwNewName,
        IN  CComObjectRootEx <CComMultiThreadModel>*    pObj);

    HRESULT
    HrGetRasConnectionInfo (
        OUT RASCON_INFO* pRasConInfo);

    HRESULT
    HrSetRasConnectionInfo (
        IN  const RASCON_INFO* pRasConInfo);

    HRESULT
    HrGetRasConnectionHandle (
        OUT HRASCONN* phRasConn);

    HRESULT
    HrPersistGetSizeMax (
        OUT ULONG*  pcbSize);

    HRESULT
    HrPersistLoad (
        IN  const BYTE* pbBuf,
        IN  ULONG       cbSize);

    HRESULT
    HrPersistSave (
        OUT BYTE*   pbBuf,
        IN  ULONG   cbSize);

    HRESULT
    HrEnsureHNetPropertiesCached ();

    HRESULT
    HrGetIHNetConnection (
        OUT IHNetConnection **ppHNetConnection);

    HRESULT
    HrIsConnectionFirewalled(
        OUT BOOL* pfFirewalled);

    HRESULT 
    HrEnsureValidNlaPolicyEngine();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\inbound\conmani.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N I . H
//
//  Contents:   Class manager for Inbound connections.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"


class ATL_NO_VTABLE CInboundConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CInboundConnectionManager,
                        &CLSID_WanConnectionManager>,
    public IConnectionPointContainerImpl <CInboundConnectionManager>,
    public INetConnectionManager
{
public:
    CInboundConnectionManager() throw()
    {
    }

    DECLARE_CLASSFACTORY_SINGLETON(CInboundConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_INBOUND_CONMAN)

    BEGIN_COM_MAP(CInboundConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CInboundConnectionManager)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHOD (EnumConnections) (
        IN  NETCONMGR_ENUM_FLAGS    Flags,
        OUT IEnumNetConnection**    ppEnum);

public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\inbound\enumi.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M I . C P P
//
//  Contents:   Enumerator for Inbound connection objects.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enumi.h"
#include "inbound.h"
#include "ncras.h"
#include "ncsvc.h"


LONG g_CountIncomingConnectionEnumerators;


extern const WCHAR c_szSvcRemoteAccess[];
extern const GUID GUID_InboundConfigConnectionId;

//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnectionManagerEnumConnection::CreateInstance
//
//  Purpose:    Creates the Inbound class manager's implementation of
//              a connection enumerator.
//
//  Arguments:
//      Flags        [in]
//      riid         [in]
//      ppv          [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:
//
HRESULT
CInboundConnectionManagerEnumConnection::CreateInstance (
    IN  NETCONMGR_ENUM_FLAGS    Flags,
    IN  REFIID                  riid,
    OUT VOID**                  ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CInboundConnectionManagerEnumConnection* pObj;
    pObj = new CComObject <CInboundConnectionManagerEnumConnection>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_EnumFlags = Flags;

        pObj->m_fReturnedConfig = FALSE;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

CInboundConnectionManagerEnumConnection::CInboundConnectionManagerEnumConnection () throw()
{
    InterlockedIncrement (&g_CountIncomingConnectionEnumerators);

    m_EnumFlags         = NCME_DEFAULT;
    m_aRasSrvConn       = NULL;
    m_cRasSrvConn       = 0;
    m_iNextRasSrvConn   = 0;
    m_fFirstTime        = TRUE;
    m_fDone             = FALSE;
}

CInboundConnectionManagerEnumConnection::~CInboundConnectionManagerEnumConnection () throw()
{
    MemFree (m_aRasSrvConn);

    InterlockedDecrement (&g_CountIncomingConnectionEnumerators);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateConfigOrCurrentEnumeratedConnection
//
//  Purpose:    Parameterize the call to CInboundConnection::CreateInstance
//              based on whether we are returning the configuration
//              connection or the currently enumerated one.
//
//  Arguments:
//      fIsConfigConnection [in]
//      ppCon               [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   16 Nov 1997
//
//  Notes:
//
HRESULT
CInboundConnectionManagerEnumConnection::
HrCreateConfigOrCurrentEnumeratedConnection (
    IN  BOOL                fIsConfigConnection,
    OUT INetConnection**    ppCon)
{
    // Parameterize the call to
    // CInboundConnection::CreateInstance based on whether
    // we are returning the configuration connection or the currently
    // enumerated one.
    //
    HRASSRVCONN hRasSrvConn;
    PCWSTR      pszName;
    PCWSTR      pszDeviceName;
    DWORD       dwType;
    const GUID* pguidId;

    if (fIsConfigConnection)
    {
        hRasSrvConn     = 0;
        pszName        = NULL;
        pszDeviceName  = NULL;
        dwType          = 0;
        pguidId         = &GUID_InboundConfigConnectionId;
        m_fReturnedConfig = TRUE;        
    }
    else
    {
        hRasSrvConn     = m_aRasSrvConn[m_iNextRasSrvConn].hRasSrvConn;
        pszName         = m_aRasSrvConn[m_iNextRasSrvConn].szEntryName;
        pszDeviceName   = m_aRasSrvConn[m_iNextRasSrvConn].szDeviceName;
        dwType          = m_aRasSrvConn[m_iNextRasSrvConn].dwType;
        pguidId         = &m_aRasSrvConn[m_iNextRasSrvConn].Guid;

        m_iNextRasSrvConn++;
    }

    HRESULT hr = CInboundConnection::CreateInstance (
                        fIsConfigConnection,
                        hRasSrvConn,
                        pszName,
                        pszDeviceName,
                        dwType,
                        pguidId,
                        IID_INetConnection,
                        reinterpret_cast<VOID**>(ppCon));

    TraceError ("CInboundConnectionManagerEnumConnection::"
                "HrCreateConfigOrCurrentEnumeratedConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnectionManagerEnumConnection::HrNextOrSkip
//
//  Purpose:    Common implementation of Next and Skip.  rgelt and
//              pceltFetched are optional.  If provided, the output
//              objects are returned (for Next).  If not provided, the output
//              objects are not returned (for Skip).
//
//  Arguments:
//      celt         [in]   Count of elements to fetch or skip.
//      rgelt        [out]
//      pceltFetched [out]
//
//  Returns:
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:
//
HRESULT
CInboundConnectionManagerEnumConnection::HrNextOrSkip (
    IN  ULONG               celt,
    OUT INetConnection**    rgelt,
    OUT ULONG*              pceltFetched)
{
    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    CExceptionSafeComObjectLock EsLock (this);

    // Enumerate the requested number of elements or stop short
    // if we don't have that many left to enumerate.  We don't enumerate
    // anything specific to the current user.  All elements are for all
    // users.
    //
    HRESULT hr = S_OK;
    ULONG   celtFetched = 0;
    if ((celtFetched < celt) && !m_fDone)
    {
        // This gets set to TRUE if we are to return the configuration
        // connection.  This only happens when RAS is running and no
        // active connections exist.
        //
        BOOL fReturnConfigCon = FALSE;

        // If this is our first time through, we need to check if the server
        // is running and possibly fill up m_aRasSrvConn.  This is our
        // array of RASSRVCONN handles enumerted from RAS.  We need
        // to keep this array across calls because RAS doesn't allow us to
        // pickup from a previous enumeration.  So, we enumerate everything
        // in one shot from RAS and hand it out to the caller however they
        // they want it.
        //
        if (m_fFirstTime)
        {
            m_fFirstTime = FALSE;

            // Assert is so that we don't set m_fDone back to FALSE
            // in the case where the service is suddenly running again.
            // The enumerator is static.  Once done, always done.
            //
            AssertSz (!m_fDone, "How'd we get here if we're done?");

            // Use HrSvcQueryStatus instead of RasSrvIsServiceRunning since
            // calling the latter could page in all of the RAS DLLs.  If
            // the service isn't running, we have nothing to enumerate anyway
            // so if we were to page in the RAS DLLs only to find that we
            // have no further work to do.
            //
            DWORD dwState;
            HRESULT hrT = HrSvcQueryStatus (c_szSvcRemoteAccess, &dwState);
            m_fDone = FAILED(hrT) || (SERVICE_RUNNING != dwState);

            if (!m_fDone)
            {
                hr = HrRasEnumAllActiveServerConnections (&m_aRasSrvConn,
                            &m_cRasSrvConn);

                // If no active connections returned, we need to return
                // the configuration connection.
                //
                if (SUCCEEDED(hr) && (!m_aRasSrvConn || !m_cRasSrvConn || !m_fReturnedConfig))
                {
                    // See if RAS allows us to configure incoming
                    // connections.
                    //
                    BOOL fAllowConfig;
                    DWORD dwErr = RasSrvAllowConnectionsConfig (&fAllowConfig);
                    TraceError ("RasSrvAllowConnectionsConfig",
                            HRESULT_FROM_WIN32 (dwErr));

                    fReturnConfigCon = ((ERROR_SUCCESS == dwErr) &&
                                            fAllowConfig);

                    // We're done if we're not returning the config connection.
                    //
                    m_fDone = !fReturnConfigCon;
                }
                else if (FAILED(hr))
                {
                    // Return an empty enumeration on any failures.
                    //
                    Assert (!m_aRasSrvConn);
                    Assert (!m_cRasSrvConn);

                    m_fDone = TRUE;
                    hr = S_OK;
                }
            }
        }

        // If we're not done, and we need to return something, do it.
        //
        if (SUCCEEDED(hr) && !m_fDone && (m_cRasSrvConn || fReturnConfigCon))
        {
            // If we're not returning the configuration connection, it means
            // we must be returning an active connection.
            //
            Assert (FImplies (!fReturnConfigCon, m_aRasSrvConn));
            Assert (FImplies (!fReturnConfigCon,
                                m_iNextRasSrvConn < m_cRasSrvConn));

            // For each entry returned, create the inbound connection object.
            //
            while (SUCCEEDED(hr) && (celtFetched < celt) &&
                   (fReturnConfigCon || (m_iNextRasSrvConn < m_cRasSrvConn)))
            {
                // Its important that this check for rgelt come inside the
                // loop because we still need to loop to update our state
                // for the Skip case.
                //
                if (rgelt)
                {
                    hr = HrCreateConfigOrCurrentEnumeratedConnection (
                            fReturnConfigCon,
                            rgelt + celtFetched);
                }

                if (fReturnConfigCon)
                {
                    // Only return one of these, so set it back to false.
                    // This let's the loop complete above.
                    //
                    fReturnConfigCon = FALSE;
//                    m_fDone = TRUE;
                }

                celtFetched++;
            }

            if (m_iNextRasSrvConn >= m_cRasSrvConn)
            {
                Assert (S_OK == hr);
                m_fDone = TRUE;
                MemFree (m_aRasSrvConn);
                m_aRasSrvConn = NULL;
                m_cRasSrvConn = 0;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidWanCon, "Enumerated %d incoming connections",
            celtFetched);

        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        hr = (celtFetched == celt) ? S_OK : S_FALSE;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        if (rgelt)
        {
            for (ULONG ulIndex = 0; ulIndex < celt; ulIndex++)
            {
                ReleaseObj (rgelt[ulIndex]);
                rgelt[ulIndex] = NULL;
            }
        }
        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }

    TraceError ("CInboundConnectionManagerEnumConnection::HrNextOrSkip",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//

STDMETHODIMP
CInboundConnectionManagerEnumConnection::Next (
    IN  ULONG               celt,
    OUT INetConnection**    rgelt,
    OUT ULONG*              pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceError ("CInboundConnectionManagerEnumConnection::Next",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionManagerEnumConnection::Skip (
    IN  ULONG   celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceError ("CInboundConnectionManagerEnumConnection::Skip",
            (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CInboundConnectionManagerEnumConnection::Reset ()
{
    CExceptionSafeComObjectLock EsLock (this);

    MemFree (m_aRasSrvConn);
    m_aRasSrvConn     = NULL;

    m_cRasSrvConn     = 0;
    m_iNextRasSrvConn = 0;
    m_fFirstTime      = TRUE;
    m_fDone           = FALSE;

    return S_OK;
}

STDMETHODIMP
CInboundConnectionManagerEnumConnection::Clone (
    OUT IEnumNetConnection**    ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        // Initialize output parameter.
        //
        *ppenum = NULL;

        CInboundConnectionManagerEnumConnection* pObj;
        pObj = new CComObject <CInboundConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Copy our internal state.
            //
            pObj->m_EnumFlags = m_EnumFlags;

            ULONG cbBuf = m_cRasSrvConn * sizeof (RASSRVCONN);

            hr = HrMalloc (cbBuf, (PVOID*)&pObj->m_aRasSrvConn);
            if (SUCCEEDED(hr))
            {
                CopyMemory (pObj->m_aRasSrvConn, m_aRasSrvConn, cbBuf);
                pObj->m_cRasSrvConn     = m_cRasSrvConn;

                pObj->m_iNextRasSrvConn = m_iNextRasSrvConn;
                pObj->m_fFirstTime      = m_fFirstTime;
                pObj->m_fDone           = m_fDone;

                // Return the object with a ref count of 1 on this
                // interface.
                pObj->m_dwRef = 1;
                *ppenum = pObj;
            }

            if (FAILED(hr))
            {
                delete pObj;
            }
        }
    }
    TraceError ("CInboundConnectionManagerEnumConnection::Clone", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\inbound\inbound.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       I N B O U N D . C P P
//
//  Contents:   Implements the inbound connection object.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "inbound.h"
#include "nccom.h"
#include "ncnetcon.h"
#include "..\conman\conman.h"

LONG g_CountIncomingConnectionObjects;

static const CLSID CLSID_InboundConnectionUi =
    {0x7007ACC3,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

extern const GUID GUID_InboundConfigConnectionId =
{ /* 89150b9f-9b5c-11d1-a91f-00805fc1270e */
    0x89150b9f,
    0x9b5c,
    0x11d1,
    {0xa9, 0x1f, 0x00, 0x80, 0x5f, 0xc1, 0x27, 0x0e}
};


//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnection::CreateInstance
//
//  Purpose:    Creates an inbound connection object.
//
//  Arguments:
//      fIsConfigConnection [in]
//      hRasSrvConn         [in]
//      pszwName            [in]
//      pguidId             [in]
//      riid                [in]
//      ppv                 [in]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:
//
HRESULT
CInboundConnection::CreateInstance (
    IN  BOOL        fIsConfigConnection,
    IN  HRASSRVCONN hRasSrvConn,
    IN  PCWSTR     pszwName,
    IN  PCWSTR     pszwDeviceName,
    IN  DWORD       dwType,
    IN  const GUID* pguidId,
    IN  REFIID      riid,
    OUT void**      ppv)
{
    Assert (FIff(fIsConfigConnection, !hRasSrvConn));
    Assert (pguidId);

    HRESULT hr = E_OUTOFMEMORY;

    CInboundConnection* pObj;
    pObj = new CComObject <CInboundConnection>;
    if (pObj)
    {
        if (fIsConfigConnection)
        {
            // No need to start the service (FALSE) since we're being
            // created as a result of the service running.
            //
            pObj->InitializeAsConfigConnection (FALSE);
        }
        else
        {
            // Initialize our members.
            //
            pObj->m_fIsConfigConnection = FALSE;
            pObj->m_hRasSrvConn = hRasSrvConn;
            pObj->SetName (pszwName);
            pObj->SetDeviceName (pszwDeviceName);

            switch (dwType)
            {
                case RASSRVUI_MODEM:
                    pObj->m_MediaType = NCM_PHONE;
                    break;
                case RASSRVUI_VPN:
                    pObj->m_MediaType = NCM_TUNNEL;
                    break;
                case RASSRVUI_DCC:
                    pObj->m_MediaType = NCM_DIRECT;
                    break;
                default:
                    pObj->m_MediaType = NCM_PHONE;
                    break;
            }

            pObj->m_guidId = *pguidId;

            // We are now a full-fledged object.
            //
            pObj->m_fInitialized = TRUE;
        }

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            INetConnection* pCon = static_cast<INetConnection*>(pObj);
            hr = pCon->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    TraceError ("CInboundConnection::CreateInstance", hr);
    return hr;
}

CInboundConnection::CInboundConnection() throw()
{
    InterlockedIncrement (&g_CountIncomingConnectionObjects);

    m_fIsConfigConnection   = FALSE;
    m_hRasSrvConn           = NULL;
    m_MediaType             = NCM_NONE;
    m_fInitialized          = FALSE;
}

CInboundConnection::~CInboundConnection() throw()
{
    InterlockedDecrement (&g_CountIncomingConnectionObjects);
}

HRESULT
CInboundConnection::GetCharacteristics (
    OUT  DWORD*    pdwFlags)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pdwFlags)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *pdwFlags = NCCF_INCOMING_ONLY | NCCF_ALL_USERS;

        // For the configuration connection, we only allow removal.
        // Don't query for NCCF_SHOW_ICON (below) because this connection
        // never get's connected.
        //
        if (m_fIsConfigConnection)
        {
            *pdwFlags |= NCCF_ALLOW_REMOVAL;
        }
        else
        {
            BOOL fShowIcon;
            DWORD dwErr = RasSrvQueryShowIcon (&fShowIcon);

            TraceError ("RasSrvQueryShowIcon", HRESULT_FROM_WIN32(dwErr));

            if ((ERROR_SUCCESS == dwErr) && fShowIcon)
            {
                *pdwFlags |= NCCF_SHOW_ICON;
            }
        }
    }
    TraceError ("CInboundConnection::GetCharacteristics", hr);
    return hr;
}

HRESULT
CInboundConnection::GetStatus (
    OUT  NETCON_STATUS*  pStatus)
{
    Assert (pStatus);

    HRESULT hr = S_OK;

    // Initialize the output parameter.
    //
    *pStatus = NCS_DISCONNECTED;

    if (!m_fIsConfigConnection)
    {
        BOOL fConnected;
        DWORD dwErr = RasSrvIsConnectionConnected (m_hRasSrvConn,
                            &fConnected);

        TraceError ("RasSrvIsConnectionConnected",
            HRESULT_FROM_WIN32(dwErr));

        if ((ERROR_SUCCESS == dwErr) && fConnected)
        {
            *pStatus = NCS_CONNECTED;
        }
    }
    TraceError ("CInboundConnection::GetStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnection
//

STDMETHODIMP
CInboundConnection::Connect ()
{
    return E_NOTIMPL;
}

STDMETHODIMP
CInboundConnection::Disconnect ()
{
    HRESULT hr;

    // We don't expect to be called on Disconnect if we are the
    // configuration connection object.  Why?  Because this object never
    // reports itself as connected through GetStatus.
    //
    if (!m_fInitialized || m_fIsConfigConnection)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        DWORD dwErr = RasSrvHangupConnection (m_hRasSrvConn);
        hr = HRESULT_FROM_WIN32 (dwErr);

        TraceError ("RasSrvHangupConnection", hr);

        // Disconnect means this object is no longer valid.
        // Indicate so by uniniatializing ourselves (so subsequent
        // method calls will fail) and returning S_OBJECT_NO_LONGER_VALID.
        //
        m_fInitialized = FALSE;
        hr = S_OBJECT_NO_LONGER_VALID;
    }
    TraceError ("CInboundConnection::Disconnect",
        (S_OBJECT_NO_LONGER_VALID == hr) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Delete ()
{
    HRESULT hr;

    // We don't expect to be called on Remove if we are not the
    // configuration connection object.  Why?  Because connected objects never
    // report themselves as removeable through GetCharacteristics.
    //
    if (!m_fInitialized || !m_fIsConfigConnection)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        DWORD dwErr = RasSrvCleanupService ();
        hr = HRESULT_FROM_WIN32 (dwErr);

        TraceError ("RasSrvCleanupService", hr);
    }
    TraceError ("CInboundConnection::Delete", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Duplicate (
    IN  PCWSTR             pszwDuplicateName,
    OUT INetConnection**    ppCon)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CInboundConnection::GetProperties (
    OUT NETCON_PROPERTIES** ppProps)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!ppProps)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Initialize the output parameter.
        //
        *ppProps = NULL;

        NETCON_PROPERTIES* pProps;
        hr = HrCoTaskMemAlloc (sizeof (NETCON_PROPERTIES),
                reinterpret_cast<void**>(&pProps));
        if (SUCCEEDED(hr))
        {
            HRESULT hrT;

            ZeroMemory (pProps, sizeof (NETCON_PROPERTIES));

            // guidId
            //
            pProps->guidId = m_guidId;

            // pszwName
            //
            hrT = HrCoTaskMemAllocAndDupSz (PszwName(),
                            &pProps->pszwName, 
                            NETCON_MAX_NAME_LEN);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // pszwDeviceName
            //
            if (!m_fIsConfigConnection)
            {
                hrT = HrCoTaskMemAllocAndDupSz (PszwDeviceName(),
                                &pProps->pszwDeviceName,
                                NETCON_MAX_NAME_LEN);
                if (FAILED(hrT))
                {
                    hr = hrT;
                }
            }

            // Status
            //
            hrT = GetStatus (&pProps->Status);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // MediaType
            //
            pProps->MediaType = m_MediaType;

            // dwCharacter
            //
            hrT = GetCharacteristics (&pProps->dwCharacter);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // clsidThisObject
            //
            pProps->clsidThisObject = CLSID_InboundConnection;

            // clsidUiObject
            //
            pProps->clsidUiObject = CLSID_InboundConnectionUi;

            // Assign the output parameter or cleanup if we had any failures.
            //
            if (SUCCEEDED(hr))
            {
                *ppProps = pProps;
            }
            else
            {
                Assert (NULL == *ppProps);
                FreeNetconProperties (pProps);
            }
        }
    }
    TraceError ("CInboundConnection::GetProperties", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::GetUiObjectClassId (
    OUT CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *pclsid = CLSID_InboundConnectionUi;
    }
    TraceError ("CInboundConnection::GetUiObjectClassId", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Rename (
    IN  PCWSTR pszwNewName)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
// INetInboundConnection
//
STDMETHODIMP
CInboundConnection::GetServerConnectionHandle (
    OUT ULONG_PTR*  phRasSrvConn)
{
    HRESULT hr = S_OK;

    // If this is the configuration connection, the server connection
    // handle better be zero.  This is used by the UI object so that it
    // knows it is the configuration connection.
    //
    Assert (FIff (m_fIsConfigConnection, !m_hRasSrvConn));

    // Because MIDL doesn't know about HRASSRVCONN's, just make sure
    // it is the same size as the ULONG_PTR we pass it as.
    //
    Assert (sizeof (m_hRasSrvConn) == sizeof (*phRasSrvConn));

    *phRasSrvConn = reinterpret_cast<ULONG_PTR>(m_hRasSrvConn);

    TraceError ("CInboundConnection::GetServerConnectionHandle", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::InitializeAsConfigConnection (
    IN  BOOL fStartRemoteAccess)
{
    Assert (!m_fInitialized);

    // Initialize our members.
    //
    m_fIsConfigConnection = TRUE;
    m_hRasSrvConn = 0;
    SetName (SzLoadIds (IDS_INBOUND_CONFIG_CONNECTION_NAME));
    SetDeviceName (NULL);
    m_MediaType = NCM_NONE;
    m_guidId = GUID_InboundConfigConnectionId;

    // We are now a full-fledged object.
    //
    m_fInitialized = TRUE;

    // Start the service if we were told.
    //
    HRESULT hr = S_OK;
    if (fStartRemoteAccess)
    {
        DWORD dwErr = RasSrvInitializeService ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        TraceError ("RasSrvInitializeService", hr);
    }
    TraceError ("CInboundConnection::InitializeAsConfigConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IPersistNetConnection
//
STDMETHODIMP
CInboundConnection::GetClassID (
    OUT CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_InboundConnection;
    }
    TraceError ("CInboundConnection::GetClassID", hr);
    return hr;
}


static const WCHAR c_chwLead  = 0x19;
static const WCHAR c_chwTrail = 0x07;

STDMETHODIMP
CInboundConnection::GetSizeMax (
    OUT ULONG*  pcbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcbSize)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Size the buffer for the following form:
        //  +--------------------------------------------------------------+
        //  |0x19<m_fIsConfigConnection><m_hRasSrvConn><m_strName>...\00x07|
        //  +--------------------------------------------------------------+
        //
        // m_strDeviceName may be empty, in which case we want to still
        // store the null-terminator.  Don't use PszwDeviceName() as it
        // returns NULL when m_strDeviceName is empty.
        //
        *pcbSize = sizeof (c_chwLead) +
                   sizeof (m_fIsConfigConnection) +
                   sizeof (m_hRasSrvConn) +
                   CbOfSzAndTerm (PszwName()) +
                   CbOfSzAndTerm (m_strDeviceName.c_str()) +
                   sizeof (m_MediaType) +
                   sizeof (m_guidId) +
                   sizeof (c_chwTrail);
    }
    TraceError ("CInboundConnection::GetSizeMax", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Load (
    IN  const BYTE* pbBuf,
    IN  ULONG       cbSize)
{
    // The theoretical minimum size for the buffer.  Computed
    // as the number of bytes in the following minimum string:
    //
    const ULONG c_cbSizeMin = sizeof (c_chwLead) +
                              sizeof (m_fIsConfigConnection) +
                              sizeof (m_hRasSrvConn) +
                              4 +   // 4 bytes for 1 UNICODE char and NULL
                              2 +   // 1 UNICODE NULL for empty device name
                              sizeof (m_MediaType) +
                              sizeof (m_guidId) +
                              sizeof (c_chwTrail);

    HRESULT hr = E_INVALIDARG;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (cbSize < c_cbSizeMin)
    {
        hr = E_INVALIDARG;
    }
    // We can only accept one call on this method and only if we're not
    // already initialized.
    //
    else if (m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // The buffer *should* look like this:
        //  +--------------------------------------------------------------+
        //  |0x19<m_fIsConfigConnection><m_hRasSrvConn><m_strName>...\00x07|
        //  +--------------------------------------------------------------+
        //
        const WCHAR *                      pchw;
        const WCHAR *                      pchwMax;
        const BOOL  UNALIGNED *            pfIsConfigConnection;
        BOOL                               fIsConfigConnection;
        const HRASSRVCONN UNALIGNED *      phRasSrvCon;
        HRASSRVCONN                        hRasSrvConn;
        PCWSTR                             pszwName;
        PCWSTR                             pszwDeviceName;
        const NETCON_MEDIATYPE UNALIGNED * pMediaType;
        const GUID UNALIGNED *             pguidTemp;
        const GUID UNALIGNED *             pguidId;
        NETCON_MEDIATYPE                   MediaType;

        pchw = reinterpret_cast<const WCHAR*>(pbBuf);

        // The last valid pointer for the embedded strings.
        //
        pchwMax = reinterpret_cast<const WCHAR*>(pbBuf + cbSize
                       - (sizeof (m_MediaType) +
                          sizeof (m_guidId) +
                          sizeof (c_chwTrail)));

        // Check our lead byte.
        //
        if (c_chwLead != *pchw)
        {
            goto finished;
        }
        pchw++;

        // Get m_fIsConfigConnection.
        //
        pfIsConfigConnection = reinterpret_cast<const BOOL*>(pchw);
        CopyMemory(&fIsConfigConnection, pfIsConfigConnection, sizeof(fIsConfigConnection));
        pfIsConfigConnection++;

        // Get m_hRasSrvConn.
        //
        phRasSrvCon = reinterpret_cast<const HRASSRVCONN*>(pfIsConfigConnection);
        CopyMemory(&hRasSrvConn, phRasSrvCon, sizeof(hRasSrvConn));
        phRasSrvCon++;

        // Get m_strName.  Search for the terminating null and make sure
        // we find it before the end of the buffer.  Using lstrlen to skip
        // the string can result in an AV in the event the string is not
        // actually null-terminated.
        //
        pchw = reinterpret_cast<const WCHAR*>(phRasSrvCon);

        for (pszwName = pchw; ; pchw++)
        {
            if (pchw >= pchwMax)
            {
                goto finished;
            }
            if (0 == *pchw)
            {
                pchw++;
                break;
            }
        }

        // Get m_strDeviceName.  Search for the terminating null and make
        // sure we find it before the end of the buffer.
        //
        for (pszwDeviceName = pchw; ; pchw++)
        {
            if (pchw >= pchwMax)
            {
                goto finished;
            }
            if (0 == *pchw)
            {
                pchw++;
                break;
            }
        }

        // Get m_MediaType.
        //
        pMediaType = reinterpret_cast<const NETCON_MEDIATYPE*>(pchw);
        CopyMemory(&MediaType, pMediaType, sizeof(MediaType));
        pMediaType++;

        // Get m_guidId.
        //
        pguidTemp = reinterpret_cast<const GUID*>(pMediaType);
        pguidId = pguidTemp;
        pguidTemp++;

        // Check our trail byte.
        //
        pchw = reinterpret_cast<const WCHAR*>(pguidTemp);
        if (c_chwTrail != *pchw)
        {
            goto finished;
        }

        // If we're the configuration object, we can't have a connection
        // HANDLE and vice-versa.
        //
        if ((fIsConfigConnection && hRasSrvConn) ||
            (!fIsConfigConnection && !hRasSrvConn))
        {
            goto finished;
        }

        // We are now a full-fledged object.
        //
        m_fIsConfigConnection = fIsConfigConnection;
        m_hRasSrvConn = hRasSrvConn;
        SetName (pszwName);
        SetDeviceName (pszwDeviceName);
        m_MediaType = MediaType;
        CopyMemory(&m_guidId, pguidId, sizeof(m_guidId));
        m_fInitialized = TRUE;
        hr = S_OK;

    finished:
            ;
    }
    TraceError ("CInboundConnection::Load", hr);
    return hr;
}

STDMETHODIMP
CInboundConnection::Save (
    OUT BYTE*   pbBuf,
    IN  ULONG   cbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Make sure the user's buffer is big enough.
        //
        ULONG cbSizeRequired;
        SideAssert (SUCCEEDED(GetSizeMax(&cbSizeRequired)));

        if (cbSize < cbSizeRequired)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            // Make the buffer look like this when we're done:
            //  +--------------------------------------------------------------+
            //  |0x19<m_fIsConfigConnection><m_hRasSrvConn><m_strName>...\00x07|
            //  +--------------------------------------------------------------+
            //
            WCHAR* pchw = reinterpret_cast<WCHAR*>(pbBuf);

            // Put our lead byte.
            //
            *pchw = c_chwLead;
            pchw++;

            // Put m_fIsConfigConnection.
            //
            BOOL UNALIGNED *pfIsConfigConnection =
                    reinterpret_cast<BOOL*>(pchw);
            CopyMemory(pfIsConfigConnection, &m_fIsConfigConnection, sizeof(m_fIsConfigConnection));
            pfIsConfigConnection++;

            // Put m_hRasSrvConn.
            //
            HRASSRVCONN UNALIGNED *phRasSrvCon =
                    reinterpret_cast<HRASSRVCONN*>(pfIsConfigConnection);
            CopyMemory(phRasSrvCon, &m_hRasSrvConn, sizeof(m_hRasSrvConn));
            phRasSrvCon++;

            // Put m_strName.
            //
            pchw = reinterpret_cast<WCHAR*>(phRasSrvCon);
            lstrcpyW (pchw, PszwName());
            pchw += lstrlenW (PszwName()) + 1;

            // Put m_strDeviceName.
            //
            lstrcpyW (pchw, m_strDeviceName.c_str());
            pchw += m_strDeviceName.length() + 1;

            // Put m_MediaType.
            //
            NETCON_MEDIATYPE UNALIGNED *pMediaType = reinterpret_cast<NETCON_MEDIATYPE*>(pchw);
            CopyMemory(pMediaType, &m_MediaType, sizeof(m_MediaType));
            pMediaType++;

            // Put m_guidId.
            //
            GUID UNALIGNED *pguidId = reinterpret_cast<GUID*>(pMediaType);
            CopyMemory(pguidId, &m_guidId, sizeof(m_guidId));
            pguidId++;

            // Put our trail byte.
            //
            pchw = reinterpret_cast<WCHAR*>(pguidId);
            *pchw = c_chwTrail;
            pchw++;

            AssertSz (pbBuf + cbSizeRequired == (BYTE*)pchw,
                "pch isn't pointing where it should be.");
        }
    }
    TraceError ("CInboundConnection::Save", hr);
    return hr;
}

#define ID_DEVICE_DATABASE 1
#define ID_MISC_DATABASE 8

//+---------------------------------------------------------------------------
//
//  Function:   IconStateChanged
//
//  Purpose:    Fires an event to notify NetShell of a Change occuring in an
//              incoming connection.
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     ckotze 25 September 2000
//
//  Notes:
//
HRESULT CInboundConnection::IconStateChanged()
{
    HRESULT hr = S_OK;

    IncomingEventNotify(REFRESH_ALL, NULL, NULL, NULL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\inbound\conmani.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N I . C P P
//
//  Contents:   Class manager for Inbound connections.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conmani.h"
#include "enumi.h"
#include "ncbase.h"

//+---------------------------------------------------------------------------
// INetConnectionManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CInboundConnectionManager::EnumConnections
//
//  Purpose:    Return an INetConnection enumerator.
//
//  Arguments:
//      Flags        [in]
//      ppEnum       [out]  The enumerator.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   12 Nov 1997
//
//  Notes:
//
STDMETHODIMP
CInboundConnectionManager::EnumConnections (
    IN  NETCONMGR_ENUM_FLAGS    Flags,
    OUT IEnumNetConnection**    ppEnum)
{
    HRESULT hr = CInboundConnectionManagerEnumConnection::CreateInstance (
                    Flags,
                    IID_IEnumNetConnection,
                    reinterpret_cast<void**>(ppEnum));

    TraceError ("CInboundConnectionManager::EnumConnections", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\inbound\inbound.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I N B O U N D . H
//
//  Contents:   Inbound Connection object.
//
//  Notes:
//
//  Author:     shaunco   23 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasuip.h>


class ATL_NO_VTABLE CInboundConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CInboundConnection,
                        &CLSID_InboundConnection>,
    public INetConnection,
    public INetInboundConnection,
    public IPersistNetConnection,
    public INetConnectionSysTray
{
private:
    // This member will be TRUE if this connection object represents
    // the disconnected object used to configure inbound connections.
    // Only one of these objects exists and is created by the enumerator
    // only when no connected inbound objects exist.
    //
    BOOL                m_fIsConfigConnection;

    // For connected inbound objects, this member is the handle to the
    // connection.
    //
    HRASSRVCONN         m_hRasSrvConn;

    // This is the name of the connection object as shown in the shell.
    // This should never be empty.
    //
    tstring             m_strName;

    // This is the name of the device associated with the connection.
    // This will be empty when m_fIsConfigConnection is TRUE.
    //
    tstring             m_strDeviceName;

    // This is the media type of the connection.
    //
    NETCON_MEDIATYPE    m_MediaType;

    // This is the id of the connection.
    //
    GUID                m_guidId;

    // This member is TRUE only when we are fully initialized.
    //
    BOOL                m_fInitialized;

private:
    PCWSTR
    PszwName () throw()
    {
        //AssertH (!m_strName.empty());
        return m_strName.c_str();
    }

    PCWSTR
    PszwDeviceName () throw()
    {
        AssertH (FIff(m_strDeviceName.empty(), m_fIsConfigConnection));
        return (!m_strDeviceName.empty()) ? m_strDeviceName.c_str()
                                          : NULL;
    }

    VOID
    SetName (
            IN  PCWSTR pszwName) throw()
    {
        AssertH (pszwName);
        m_strName = pszwName;
        //AssertH (!m_strName.empty());
    }

    VOID
    SetDeviceName (
            IN  PCWSTR pszwDeviceName) throw()
    {
        if (pszwDeviceName && *pszwDeviceName)
        {
            AssertH (!m_fIsConfigConnection);
            m_strDeviceName = pszwDeviceName;
        }
        else
        {
            AssertH (m_fIsConfigConnection);
            m_strDeviceName.erase();
        }
    }

    HRESULT
    GetCharacteristics (
        OUT  DWORD*    pdwFlags);

    HRESULT
    GetStatus (
        OUT  NETCON_STATUS*  pStatus);

public:
    CInboundConnection() throw();
    ~CInboundConnection() throw();

    DECLARE_REGISTRY_RESOURCEID(IDR_INBOUND_CONNECTION)

    BEGIN_COM_MAP(CInboundConnection)
        COM_INTERFACE_ENTRY(INetConnection)
        COM_INTERFACE_ENTRY(INetInboundConnection)
        COM_INTERFACE_ENTRY(IPersistNetConnection)
        COM_INTERFACE_ENTRY(INetConnectionSysTray)
    END_COM_MAP()

    // INetConnection
    STDMETHOD (Connect) ();

    STDMETHOD (Disconnect) ();

    STDMETHOD (Delete) ();

    STDMETHOD (Duplicate) (
        IN  PCWSTR             pszwDuplicateName,
        OUT INetConnection**    ppCon);

    STDMETHOD (GetProperties) (
        OUT NETCON_PROPERTIES** ppProps);

    STDMETHOD (GetUiObjectClassId) (
        OUT CLSID*  pclsid);

    STDMETHOD (Rename) (
        IN  PCWSTR pszwNewName);

    // INetInboundConnection
    STDMETHOD (GetServerConnectionHandle) (
        OUT ULONG_PTR*  phRasSrvConn);

    STDMETHOD (InitializeAsConfigConnection) (
        IN  BOOL fStartRemoteAccess);

    // IPersistNetConnection
    STDMETHOD (GetClassID) (
        OUT CLSID* pclsid);

    STDMETHOD (GetSizeMax) (
        OUT ULONG* pcbSize);

    STDMETHOD (Load) (
        IN  const BYTE* pbBuf,
        IN  ULONG       cbSize);

    STDMETHOD (Save) (
        OUT BYTE*  pbBuf,
        IN  ULONG  cbSize);

    // INetConnectionSysTray
    STDMETHOD (ShowIcon) (
        IN  const BOOL bShowIcon)
    {
        return E_NOTIMPL;
    }

    STDMETHOD (IconStateChanged) ();

public:
    static HRESULT CreateInstance (
        IN  BOOL        fIsConfigConnection,
        IN  HRASSRVCONN hRasSrvConn,
        IN  PCWSTR     pszwName,
        IN  PCWSTR     pszwDeviceName,
        IN  DWORD       dwType,
        IN  const GUID* pguidId,
        IN  REFIID      riid,
        OUT VOID**      ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\inbound\enumi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M I . H
//
//  Contents:   Enumerator for Inbound connection objects.
//
//  Notes:
//
//  Author:     shaunco   12 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nmbase.h"
#include "nmres.h"
#include <rasuip.h>


class ATL_NO_VTABLE CInboundConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CInboundConnectionManagerEnumConnection,
                        &CLSID_WanConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    NETCONMGR_ENUM_FLAGS    m_EnumFlags;
    RASSRVCONN*             m_aRasSrvConn;
    ULONG                   m_cRasSrvConn;
    ULONG                   m_iNextRasSrvConn;
    BOOL                    m_fFirstTime;
    BOOL                    m_fDone;
    BOOL                    m_fReturnedConfig;

private:
    HRESULT
    HrCreateConfigOrCurrentEnumeratedConnection (
        IN  BOOL                fIsConfigConnection,
        OUT INetConnection**    ppCon);

    HRESULT
    HrNextOrSkip (
        IN  ULONG               celt,
        OUT INetConnection**    rgelt,
        OUT ULONG*              pceltFetched);

public:
    CInboundConnectionManagerEnumConnection () throw();
    ~CInboundConnectionManagerEnumConnection () throw();

    DECLARE_REGISTRY_RESOURCEID(IDR_INBOUND_CONMAN_ENUM)

    BEGIN_COM_MAP(CInboundConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD (Next) (
        IN  ULONG               celt,
        OUT INetConnection**    rgelt,
        OUT ULONG*              pceltFetched);

    STDMETHOD (Skip) (
        IN  ULONG   celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        OUT IEnumNetConnection**    ppenum);

public:
    static HRESULT CreateInstance (
        IN  NETCONMGR_ENUM_FLAGS    Flags,
        IN  REFIID                  riid,
        OUT VOID**                  ppv);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\lan\conmanl.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"


class ATL_NO_VTABLE CLanConnectionManager :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CLanConnectionManager,
                        &CLSID_LanConnectionManager>,
    public IConnectionPointContainerImpl <CLanConnectionManager>,
    public INetConnectionManager
{
public:
    CLanConnectionManager() throw()
    {
    }
    VOID FinalRelease()
    {
        TraceTag(ttidLanCon, "Destroying LAN Connection Manager");
    }

    DECLARE_CLASSFACTORY_SINGLETON(CLanConnectionManager)
    DECLARE_REGISTRY_RESOURCEID(IDR_LAN_CONMAN)

    BEGIN_COM_MAP(CLanConnectionManager)
        COM_INTERFACE_ENTRY(INetConnectionManager)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CLanConnectionManager)
    END_CONNECTION_POINT_MAP()

    // INetConnectionManager
    STDMETHOD (EnumConnections) (
        IN  NETCONMGR_ENUM_FLAGS    Flags,
        OUT IEnumNetConnection**    ppEnum);

public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\lan\conmanl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N M A N . C P P
//
//  Contents:   Implementation of LAN connection class manager
//
//  Notes:
//
//  Author:     danielwe   2 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "conmanl.h"
#include "enuml.h"

//+---------------------------------------------------------------------------
// INetConnectionManager
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManager::EnumConnections
//
//  Purpose:    Returns an enumerator object for LAN connections
//
//  Arguments:
//      Flags        [in]       Must be NCF_ALL_USERS
//      ppEnum       [out]      Returns enumerator object
//
//  Returns:    S_OK if succeeded, OLE or Win32 error code otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionManager::EnumConnections(IN  NETCONMGR_ENUM_FLAGS Flags,
                                                    OUT IEnumNetConnection** ppEnum)
{
    HRESULT hr = CLanConnectionManagerEnumConnection::CreateInstance(Flags,
                                        IID_IEnumNetConnection,
                                        reinterpret_cast<LPVOID*>(ppEnum));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\lan\lan.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"
#include "nmhnet.h"


extern LONG g_CountLanConnectionObjects;


class ATL_NO_VTABLE CLanConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CLanConnection, &CLSID_LanConnection>,
    public INetConnection,
    public IPersistNetConnection,
    public INetLanConnection,
    public INetConnectionSysTray,
    public INetConnection2
{
private:
    HKEY                    m_hkeyConn;         // hkey for connection root
    BOOL                    m_fInitialized;
    HDEVINFO                m_hdi;
    SP_DEVINFO_DATA         m_deid;
    
    // This is required for checking permission on Firewall etc.
    CComPtr<INetMachinePolicies>    m_pNetMachinePolicies;

    // Home networking support. m_fHNetPropertiesCached is set to TRUE
    // after the first successful call to HrEnsureHNetPropertiesCached.
    //
    BOOL                    m_fHNetPropertiesCached;
    LONG                    m_lHNetModifiedEra;
    LONG                    m_lUpdatingHNetProperties;
    HNET_CONN_PROPERTIES    *m_pHNetProperties;
    

public:
    CLanConnection() throw()
    {
        m_hkeyConn = NULL;
        m_fInitialized = FALSE;
        m_hdi = NULL;
        m_fHNetPropertiesCached = FALSE;
        m_lHNetModifiedEra = 0;
        m_pHNetProperties = NULL;
        m_lUpdatingHNetProperties = 0;
        m_pNetMachinePolicies = NULL;
        InterlockedIncrement(&g_CountLanConnectionObjects);
    }
    ~CLanConnection() throw();

    DECLARE_REGISTRY_RESOURCEID(IDR_LAN_CONNECTION)

    BEGIN_COM_MAP(CLanConnection)
        COM_INTERFACE_ENTRY(INetConnection)
        COM_INTERFACE_ENTRY(IPersistNetConnection)
        COM_INTERFACE_ENTRY(INetLanConnection)
        COM_INTERFACE_ENTRY(INetConnectionSysTray)
        COM_INTERFACE_ENTRY(INetConnection2)
    END_COM_MAP()

    // INetConnection
    HRESULT GetDeviceName(OUT PWSTR* ppszwDeviceName);
    HRESULT GetStatus(OUT NETCON_STATUS*  pStatus);
    HRESULT GetCharacteristics(IN  NETCON_MEDIATYPE ncm, OUT DWORD* pdwFlags);

    STDMETHOD(Connect)();
    STDMETHOD(Disconnect)();
    STDMETHOD(Delete)();
    STDMETHOD(Duplicate) (IN  PCWSTR pszwDuplicateName, OUT INetConnection** ppCon);
    STDMETHOD(GetProperties) (OUT NETCON_PROPERTIES** ppProps);
    STDMETHOD(GetUiObjectClassId)(OUT CLSID *pclsid);
    STDMETHOD(Rename)(PCWSTR pszwNewName);

    //
    // INetLanConnection
    //

    STDMETHOD(GetInfo)(IN  DWORD dwMask, OUT LANCON_INFO* pLanConInfo);
    STDMETHOD(SetInfo)(IN  DWORD dwMask, IN  const LANCON_INFO* pLanConInfo);
    STDMETHOD(GetDeviceGuid)(OUT GUID *pguid);

    //
    // IPersistNetConnection
    //

    STDMETHOD(GetClassID)(OUT CLSID *pclsid);
    STDMETHOD(GetSizeMax)(OUT ULONG *pcbSize);
    STDMETHOD(Load)(IN  const BYTE *pbBuf, IN  ULONG cbSize);
    STDMETHOD(Save)(OUT BYTE *pbBuf, IN  ULONG cbSize);

    // INetConnectionSysTray
    STDMETHOD (ShowIcon) (IN  const BOOL bShowIcon);

    // INetConnectionSysTray
    STDMETHOD (IconStateChanged) ();

    // INetConnection2
    STDMETHOD (GetPropertiesEx)(OUT NETCON_PROPERTIES_EX** ppConnectionPropertiesEx);
    
    //
    // Overrides
    //
    static HRESULT CreateInstance(IN  HDEVINFO hdi, 
                                  IN  const SP_DEVINFO_DATA &deid,
                                  IN  PCWSTR pszPnpId,
                                  IN  REFIID riid, 
                                  OUT LPVOID *ppv);

private:
    HRESULT HrIsConnectionActive(VOID);
    HRESULT HrPutName(IN  PCWSTR szwName);
    HRESULT HrInitialize(IN  PCWSTR pszPnpId);
    HRESULT HrLoad(IN  const GUID &guid);
    HRESULT HrOpenRegistryKeys(IN  const GUID &guid);
    HRESULT HrConnectOrDisconnect(IN  BOOL fConnect);
    HRESULT HrCallSens(IN  BOOL fConnect);
    HRESULT HrLoadDevInfoFromGuid(IN  const GUID &guid);
    HRESULT HrIsAtmAdapterFromHkey(IN  HKEY hkey);
    HRESULT HrIsAtmElanFromHkey(IN  HKEY hkey);
    BOOL FIsMediaPresent(VOID) throw();
    HRESULT HrIsConnectionBridged(OUT BOOL* pfBridged);
    HRESULT HrIsConnectionFirewalled(OUT BOOL* pfFirewalled);
    HRESULT HrIsConnectionNetworkBridge(OUT BOOL* pfBridged);
    HRESULT HrIsConnectionIcsPublic(OUT BOOL* pfIcsPublic);
    HRESULT HrEnsureHNetPropertiesCached(VOID);
    HRESULT HrGetIHNetConnection(OUT IHNetConnection **ppHNetConnection);
    HRESULT HrEnsureValidNlaPolicyEngine();
};

//
// Globals
//

HRESULT HrGetInstanceGuid(IN  HDEVINFO hdi, 
                          IN  const SP_DEVINFO_DATA &deid,
                          OUT LPGUID pguid);
VOID EnsureUniqueConnectionName(IN  PCWSTR pszPotentialName, OUT PWSTR pszNewName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\lan\enuml.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E N U M . C P P
//
//  Contents:   Implementation of LAN connection enumerator object
//
//  Notes:
//
//  Author:     danielwe   2 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enuml.h"
#include "lan.h"
#include "lancmn.h"
#include "ncnetcfg.h"
#include "ncreg.h"
#include "ncsetup.h"

LONG g_CountLanConnectionEnumerators;

HRESULT CLanConnectionManagerEnumConnection::CreateInstance(
                                          IN                NETCONMGR_ENUM_FLAGS Flags,
                                          IN                REFIID riid,
                                          OUT TAKEOWNERSHIP LPVOID *ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CLanConnectionManagerEnumConnection* pObj;

    Assert(ppv);
    *ppv = NULL;

    pObj = new CComObject<CLanConnectionManagerEnumConnection>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid(NULL);
        pObj->InternalFinalConstructAddRef();
        hr = pObj->FinalConstruct();
        pObj->InternalFinalConstructRelease();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface(riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceError("CLanConnectionManagerEnumConnection::CreateInstance", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::~CLanConnectionManagerEnumConnection
//
//  Purpose:    Called when the enumeration object is released for the last
//              time.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
CLanConnectionManagerEnumConnection::~CLanConnectionManagerEnumConnection() throw()
{
    SetupDiDestroyDeviceInfoListSafe(m_hdi);
    InterlockedDecrement(&g_CountLanConnectionEnumerators);
}

//+---------------------------------------------------------------------------
// IEnumNetConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::Next
//
//  Purpose:    Retrieves the next celt LAN connection objects
//
//  Arguments:
//      celt         [in]       Number to retrieve
//      rgelt        [out]      Array of INetConnection objects retrieved
//      pceltFetched [out]      Returns Number in array
//
//  Returns:    S_OK if succeeded, OLE or Win32 error otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionManagerEnumConnection::Next(IN  ULONG celt,
                                                       OUT INetConnection **rgelt,
                                                       OUT ULONG *pceltFetched)
{
    HRESULT     hr = S_OK;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
        goto done;
    }

    // Initialize output parameters.
    //
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }

    // Handle the request for zero elements. Also do nothing if the enumerator
    // was created without valid parameters.
    //
    if (0 == celt || FIsDebugFlagSet(dfidSkipLanEnum))
    {
        hr = S_FALSE;
        goto done;
    }

    hr = HrNextOrSkip(celt, rgelt, pceltFetched);

done:
    TraceError("CLanConnectionManagerEnumConnection::Next",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::Skip
//
//  Purpose:    Skips over celt number of connections
//
//  Arguments:
//      celt [in]   Number of connections to skip
//
//  Returns:    S_OK if successful, otherwise Win32 error
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionManagerEnumConnection::Skip(IN  ULONG celt)
{
    HRESULT     hr = S_OK;

    hr = HrNextOrSkip(celt, NULL, NULL);

    TraceError("CLanConnectionManagerEnumConnection::Skip",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::Reset
//
//  Purpose:    Resets the enumerator to the beginning
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionManagerEnumConnection::Reset()
{
    HRESULT hr;

    m_dwIndex = 0;

    // refresh so that we have a new view of what adapters are installed
    // each time reset is called
    //
    SetupDiDestroyDeviceInfoListSafe(m_hdi);

    hr = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL,
                               DIGCF_PRESENT, &m_hdi);

    TraceError("CLanConnectionManagerEnumConnection::Reset", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::Clone
//
//  Purpose:    Creates a new enumeration object pointing at the same location
//              as this object
//
//  Arguments:
//      ppenum [out]    New enumeration object
//
//  Returns:    S_OK if successful, otherwise OLE or Win32 error
//
//  Author:     danielwe   19 Mar 1998
//
//  Notes:
//
STDMETHODIMP CLanConnectionManagerEnumConnection::Clone(OUT IEnumNetConnection **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Validate parameters.
    //
    if (!ppenum)
    {
        hr = E_POINTER;
    }
    else
    {
        CLanConnectionManagerEnumConnection *   pObj;

        // Initialize output parameter.
        //
        *ppenum = NULL;

        pObj = new CComObject <CLanConnectionManagerEnumConnection>;
        if (pObj)
        {
            hr = S_OK;

            CExceptionSafeComObjectLock EsLock (this);

            // Copy our internal state.
            //
            pObj->m_dwIndex = m_dwIndex;

            // Return the object with a ref count of 1 on this
            // interface.
            pObj->m_dwRef = 1;
            *ppenum = pObj;
        }
    }

    TraceError ("CLanConnectionManagerEnumConnection::Clone", hr);
    return hr;
}

//
// Helper functions
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::HrCreateLanConnectionInstance
//
//  Purpose:    Helper function to create a LAN connection object instance
//
//  Arguments:
//      deid   [in]     Device info data
//      rgelt  [out]    Array of connection objects
//      ulEntry [in]    Index of connection object
//
//  Returns:    S_OK if success, Win32 or OLE error otherwise
//
//  Author:     danielwe   8 Jan 1998
//
//  Notes:
//
HRESULT CLanConnectionManagerEnumConnection::HrCreateLanConnectionInstance(
              IN  SP_DEVINFO_DATA &deid,
              OUT INetConnection **rgelt,
              IN  ULONG ulEntry)
{
    HRESULT hr;
    WCHAR szPnpId[MAX_DEVICE_ID_LEN];

    hr = HrSetupDiGetDeviceInstanceId(m_hdi, &deid, szPnpId,
                MAX_DEVICE_ID_LEN, NULL);
    if (S_OK == hr)
    {
        HDEVINFO hdiCopy;
        SP_DEVINFO_DATA deidCopy;

        hr = HrSetupDiCreateDeviceInfoList(&GUID_DEVCLASS_NET,
                NULL, &hdiCopy);
        if (S_OK == hr)
        {
            BOOL fDestroyCopy = TRUE;

            hr = HrSetupDiOpenDeviceInfo(hdiCopy, szPnpId,
                        NULL, DIOD_INHERIT_CLASSDRVS, &deidCopy);
            if (S_OK == hr)
            {
                fDestroyCopy = FALSE;

                hr = CLanConnection::CreateInstance(hdiCopy,
                                                    deidCopy,
                                                    szPnpId,
                                                    IID_INetConnection,
                                                    reinterpret_cast<LPVOID *>
                                                    (rgelt + ulEntry));
            }

            // CLanConnection::CreateInstance() will hand off the hdiCopy. So
            // even if that fails, we don't want to destroy hdiCopy anymore.
            //
            if (fDestroyCopy)
            {
                // If we fail to continue, free the copy we just made
                //
                (VOID) SetupDiDestroyDeviceInfoList(hdiCopy);
            }
        }
    }

    TraceError("CLanConnectionManagerEnumConnection::"
               "HrCreateLanConnectionInstance", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsHidden
//
//  Purpose:    Returns TRUE if the given hkey references the device instance
//              of a hidden adapter (virtual or otherwise)
//
//  Arguments:
//      hkey [in]   HKEY of device instance for adapter (i.e. {GUID}\0000)
//
//  Returns:    TRUE if it is hidden, FALSE if not
//
//  Author:     danielwe   17 Apr 1998
//
//  Notes:
//
BOOL FIsHidden(IN  HKEY hkey) throw()
{
    DWORD dwCharacter;

    if (S_OK == HrRegQueryDword(hkey, L"Characteristics", &dwCharacter))
    {
        return !!(dwCharacter & NCF_HIDDEN);
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsHiddenElan
//
//  Purpose:    Returns TRUE if the given hkey references the device instance
//              of a hidden ELAN adapter (when the physical ATM adapter is not
//              available)
//
//  Arguments:
//      hdi  [in]   HDEVINFO structure for this adapter
//      hkey [in]   HKEY of device instance for adapter (i.e. {GUID}\0000)
//
//
//  Returns:    TRUE if it is hidden, FALSE if not
//
//  Author:     tongl 9/10/98
//
//  Notes:
//
BOOL FIsHiddenElan(IN  HDEVINFO hdi, IN  HKEY hkey) throw()
{
    BOOL fRet = FALSE;
    HRESULT hr;

    PWSTR pszAtmAdapterPnpId;
    hr = HrRegQuerySzWithAlloc(hkey, L"AtmAdapterPnpId", &pszAtmAdapterPnpId);
    if (S_OK == hr)
    {
        SP_DEVINFO_DATA deid;

        hr = HrSetupDiOpenDeviceInfo(hdi, pszAtmAdapterPnpId, NULL, 0, &deid);
        if (S_OK == hr)
        {
            // Elan should be hidden if the physical adapter is not functioning
            // and is hidden in the folder
            fRet = !FIsFunctioning(&deid);
        }

        MemFree(pszAtmAdapterPnpId);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionManagerEnumConnection::HrNextOrSkip
//
//  Purpose:    Helper function to handle the ::Next or ::Skip method
//              implementation
//
//  Arguments:
//      celt         [in]   Number of items to advance
//      rgelt        [out]   Array in which to place connection objects
//      pceltFetched [out]  Returns number of items fetched
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   8 Jan 1998
//
//  Notes:
//
HRESULT CLanConnectionManagerEnumConnection::HrNextOrSkip(
    IN  ULONG celt,
    OUT INetConnection **rgelt,
    OUT ULONG *pceltFetched)
{
    HRESULT             hr = S_OK;
    SP_DEVINFO_DATA     deid = {0};
    ULONG               ulEntry = 0;

    if (rgelt)
    {
        // Important to initialize rgelt so that in case we fail, we can
        // release only what we put in rgelt.
        //
        ZeroMemory(rgelt, sizeof (*rgelt) * celt);
    }

    Assert(celt > 0);

    if (!m_hdi)
    {
        hr = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL,
                                   DIGCF_PRESENT, &m_hdi);
    }

    while (celt &&
           SUCCEEDED(hr) &&
           SUCCEEDED(hr = HrSetupDiEnumDeviceInfo(m_hdi,m_dwIndex, &deid)))
    {
        HKEY hkey;

        m_dwIndex++;

        hr = HrSetupDiOpenDevRegKey(m_hdi, &deid, DICS_FLAG_GLOBAL, 0,
                                    DIREG_DRV, KEY_READ, &hkey);
        if (SUCCEEDED(hr))
        {
            hr = HrIsLanCapableAdapterFromHkey(hkey);
            if (S_OK == hr)
            {
                if (FIsFunctioning(&deid) && FIsValidNetCfgDevice(hkey) &&
                    !FIsHidden(hkey) && !FIsHiddenElan(m_hdi, hkey))
                {
                    // On Skip, don't create an instance
                    //
                    if (rgelt)
                    {
                        hr = HrCreateLanConnectionInstance(deid, rgelt,
                                                           ulEntry);
                    }

                    ulEntry++;
                    celt--;
                }
            }

            RegCloseKey(hkey);
        }
        else
        {
            // skip device entirely if error trying to open it
            hr = S_OK;
        }
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        TraceTag (ttidLanCon, "Enumerated %lu LAN connections", ulEntry);

        if (pceltFetched)
        {
            *pceltFetched = ulEntry;
        }

        // If celt is positive then we couldn't satisfy the request completely
        hr = (celt > 0) ? S_FALSE : S_OK;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        if (rgelt)
        {
            for (ULONG ulIndex = 0; ulIndex < ulEntry; ulIndex++)
            {
                ReleaseObj(rgelt[ulIndex]);
                rgelt[ulIndex] = NULL;
            }
        }

        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }

    TraceError("CLanConnectionManagerEnumConnection::HrNextOrSkip",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//
// Private helper functions
//

extern const WCHAR c_szRegKeyInterfacesFromInstance[];
extern const WCHAR c_szRegValueUpperRange[];
extern const WCHAR c_szRegValueLowerRange[];
static const WCHAR c_chComma = L',';
extern const WCHAR c_szBiNdis4[];
extern const WCHAR c_szBiNdis5[];
extern const WCHAR c_szBiNdis5Ip[];
extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szBiNdis1394[];
extern const WCHAR c_szBiNdisBda[];
extern const WCHAR c_szBiLocalTalk[];

//+---------------------------------------------------------------------------
//
//  Function:   HrIsLanCapableAdapterFromHkey
//
//  Purpose:    Determines if the given HKEY describes a LAN capable adapter
//
//  Arguments:
//      hkey [in]   HKEY under Control\Class\{GUID}\<instance> (aka driver key)
//
//  Returns:    S_OK if device is LAN capable, S_FALSE if not, Win32 error
//              otherwise
//
//  Author:     danielwe   7 Jan 1998
//
//  Notes:
//
HRESULT HrIsLanCapableAdapterFromHkey(IN HKEY hkey)
{
    HRESULT                     hr = S_OK;
    WCHAR                       szBuf[256];
    DWORD                       cbBuf = sizeof(szBuf);
    list<tstring *>             lstr;
    list<tstring *>::iterator   lstrIter;
    BOOL                        fMatch = FALSE;
    HKEY                        hkeyInterfaces;

    hr = HrRegOpenKeyEx(hkey, c_szRegKeyInterfacesFromInstance,
                        KEY_READ, &hkeyInterfaces);
    if (SUCCEEDED(hr))
    {
        hr = HrRegQuerySzBuffer(hkeyInterfaces, c_szRegValueUpperRange,
                                szBuf, &cbBuf);
        if (SUCCEEDED(hr))
        {
            if (
                FSubstringMatch(szBuf, c_szBiNdis4,    NULL, NULL) ||
                FSubstringMatch(szBuf, c_szBiNdis5,    NULL, NULL) ||
                FSubstringMatch(szBuf, c_szBiNdis5Ip,  NULL, NULL) ||
                FSubstringMatch(szBuf, c_szBiNdisAtm,  NULL, NULL) ||
                FSubstringMatch(szBuf, c_szBiNdis1394, NULL, NULL) ||
                FSubstringMatch(szBuf, c_szBiNdisBda,  NULL, NULL) )
            {
                fMatch = TRUE;
            }
        }

        if (!fMatch)
        {
            cbBuf = sizeof(szBuf);
            hr = HrRegQuerySzBuffer(hkeyInterfaces, c_szRegValueLowerRange,
                                    szBuf, &cbBuf);
            if (SUCCEEDED(hr))
            {
                ConvertStringToColString(szBuf, c_chComma, lstr);

                for (lstrIter = lstr.begin(); lstrIter != lstr.end(); lstrIter++)
                {
                    // See if it matches one of these

                    if (!lstrcmpiW((*lstrIter)->c_str(), c_szBiLocalTalk))
                    {
                        fMatch = TRUE;
                        break;
                    }
                }

                DeleteColString(&lstr);
            }
        }

        RegCloseKey(hkeyInterfaces);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        if (fMatch)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
            "HrIsLanCapableAdapterFromHkey");
    return hr;
}

static const WCHAR c_szKeyFmt[] = L"%s\\%s\\%s";
extern const WCHAR c_szRegValueNetCfgInstanceId[];
extern const WCHAR c_szRegKeyComponentClasses[];
extern const WCHAR c_szRegValueInstallerAction[];

//+---------------------------------------------------------------------------
//
//  Function:   FIsValidNetCfgDevice
//
//  Purpose:    Determines if the given HKEY is that of a valid NetCfg adapter
//
//  Arguments:
//      hkey [in]   HKEY under Control\Class\{GUID}\<instance> (aka driver key)
//
//  Returns:    TRUE if valid, FALSE otherwise
//
//  Author:     danielwe   7 Jan 1998
//
//  Notes:
//
BOOL FIsValidNetCfgDevice(IN  HKEY hkey) throw()
{
    HRESULT hr;
    WCHAR   szGuid[c_cchGuidWithTerm + 1];
    DWORD   cbBuf = sizeof(szGuid);

    hr = HrRegQuerySzBuffer(hkey, c_szRegValueNetCfgInstanceId,
                            szGuid, &cbBuf);

    return (S_OK == hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsFunctioning
//
//  Purpose:    Determines if the given dev node is a functioning device
//
//  Arguments:
//      pdeid [in]  Dev info data for device
//
//  Returns:    TRUE if device is functioning, FALSE if not
//
//  Author:     danielwe   2 Sep 1998
//
//  Notes:      "Functioning" means the device is enabled and started with
//              no problem codes, or it is disabled and stopped with no
//              problem codes.
//
BOOL FIsFunctioning(IN const SP_DEVINFO_DATA * pdeid) throw()
{
    ULONG       ulStatus;
    ULONG       ulProblem;
    CONFIGRET   cfgRet;

    cfgRet = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem, pdeid->DevInst,
                                      0, NULL);

    if (CR_SUCCESS == cfgRet)
    {
        TraceTag(ttidLanCon, "CM_Get_DevNode_Status_Ex (enum): ulProblem "
                 "= 0x%08X, ulStatus = 0x%08X.",
                 ulProblem, ulStatus);

        return FIsDeviceFunctioning(ulProblem);
    }

    // By default return FALSE

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\cmsabcon.cpp ===
#include "pch.h"
#pragma hdrstop
#include "cmsabcon.h"

CSharedAccessBeacon::CSharedAccessBeacon()
{
    m_MediaType = NCM_NONE;
    ZeroMemory(&m_LocalAdapterGUID, sizeof(m_LocalAdapterGUID));
    ZeroMemory(&m_Services, sizeof(m_Services));
    m_UniqueDeviceName = NULL;
}

HRESULT CSharedAccessBeacon::FinalRelease()
{
    for(int i = 0; i < SAHOST_SERVICE_MAX; i++)
    {
        if(NULL != m_Services[i])
        {
            ReleaseObj(m_Services[i]);
        }
    }

    SysFreeString(m_UniqueDeviceName);

    return S_OK;
}

HRESULT CSharedAccessBeacon::SetMediaType(NETCON_MEDIATYPE MediaType)
{
    m_MediaType = MediaType;
    return S_OK;
}

HRESULT CSharedAccessBeacon::SetLocalAdapterGUID(GUID* pGuid)
{
    CopyMemory(&m_LocalAdapterGUID, pGuid, sizeof(GUID));
    return S_OK;
}

HRESULT CSharedAccessBeacon::SetService(ULONG ulService, IUPnPService* pService)
{
    HRESULT hr = S_OK;
    if(SAHOST_SERVICE_MAX > ulService && NULL == m_Services[ulService])
    {
        m_Services[ulService] = pService;
        pService->AddRef();
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CSharedAccessBeacon::SetUniqueDeviceName(BSTR UniqueDeviceName)
{
    HRESULT hr = S_OK;

    m_UniqueDeviceName = SysAllocString(UniqueDeviceName);
    if(NULL == m_UniqueDeviceName)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CSharedAccessBeacon::GetMediaType(NETCON_MEDIATYPE* pMediaType)
{
    *pMediaType = m_MediaType;
    return S_OK;
}

HRESULT CSharedAccessBeacon::GetLocalAdapterGUID(GUID* pGuid)
{
    CopyMemory(pGuid, &m_LocalAdapterGUID, sizeof(GUID));
    return S_OK;
}

HRESULT CSharedAccessBeacon::GetService(SAHOST_SERVICES ulService, IUPnPService** ppService)
{
    HRESULT hr = S_OK;

    *ppService = NULL;

    if(SAHOST_SERVICE_MAX > ulService)
    {
        *ppService = m_Services[ulService];
        if(NULL != *ppService)
        {
            (*ppService)->AddRef();
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CSharedAccessBeacon::GetUniqueDeviceName(BSTR* pUniqueDeviceName)
{
    HRESULT hr = S_OK;

    *pUniqueDeviceName = SysAllocString(m_UniqueDeviceName);
    if(NULL == *pUniqueDeviceName)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\lan\enuml.h ===
#pragma once
#include "nmbase.h"
#include "nmres.h"


extern LONG g_CountLanConnectionEnumerators;


class ATL_NO_VTABLE CLanConnectionManagerEnumConnection :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CLanConnectionManagerEnumConnection,
                        &CLSID_LanConnectionManagerEnumConnection>,
    public IEnumNetConnection
{
private:
    HDEVINFO    m_hdi;
    DWORD       m_dwIndex;

public:
    CLanConnectionManagerEnumConnection() throw()
    {
        m_hdi = NULL;
        m_dwIndex = 0;
        InterlockedIncrement(&g_CountLanConnectionEnumerators);
    }

    ~CLanConnectionManagerEnumConnection() throw();

    DECLARE_REGISTRY_RESOURCEID(IDR_LAN_CONMAN_ENUM)

    BEGIN_COM_MAP(CLanConnectionManagerEnumConnection)
        COM_INTERFACE_ENTRY(IEnumNetConnection)
    END_COM_MAP()

    // IEnumNetConnection
    STDMETHOD(Next)(IN  ULONG celt, OUT INetConnection **rgelt, OUT ULONG *pceltFetched);
    STDMETHOD(Skip)(IN  ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(OUT IEnumNetConnection **ppenum);

private:
    //
    // Private functions
    //

    HRESULT HrNextOrSkip(IN  ULONG celt, 
                         OUT INetConnection **rgelt,
                         OUT ULONG *pceltFetched);
    HRESULT HrCreateLanConnectionInstance(IN  SP_DEVINFO_DATA &deid,
                                          OUT INetConnection **rgelt,
                                          IN  ULONG ulEntry);
public:
    static HRESULT CreateInstance(IN                NETCONMGR_ENUM_FLAGS Flags,
                                  OUT               REFIID riid,
                                  OUT TAKEOWNERSHIP LPVOID *ppv);
};

//
// Helper functions
//

BOOL FIsValidNetCfgDevice(IN  HKEY hkey) throw();
HRESULT HrIsLanCapableAdapterFromHkey(IN  HKEY hkey) throw();
BOOL FIsFunctioning(IN const SP_DEVINFO_DATA * pdeid) throw();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\lan\landiagp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N M D I A G P . C P P
//
//  Contents:   Diagnostics for the netman process
//
//  Notes:
//
//  Author:     danielwe   23 Mar 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "enuml.h"
#include "diag.h"
#include "kkenet.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncstring.h"
#include "netcon.h"
#include "ntddndis.h"

extern const WCHAR c_szRegValueNetCfgInstanceId[];

namespace CMDIRECT
{
    namespace LANCON
    {
        struct LAN_CONNECTION
        {
            GUID            guidId;
            tstring         strName;
            NETCON_STATUS   Status;
            tstring         strDeviceName;
            DWORD           dwMediaState;
            ULONG           ulDevNodeStatus;
            ULONG           ulDevNodeProblem;
            tstring         strPnpName;
        };

        typedef list<LAN_CONNECTION *>                  LAN_CONNECTION_LIST;
        typedef list<LAN_CONNECTION *>::const_iterator  LAN_CONNECTION_LIST_ITERATOR;

        HRESULT HrInitializeConMan(OUT INetConnectionManager **ppConMan)
        {
            HRESULT hr;

            hr = CoCreateInstance(CLSID_LanConnectionManager, NULL,
                                  CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                                  IID_INetConnectionManager,
                                  reinterpret_cast<LPVOID *>(ppConMan));

            return hr;
        }

        HRESULT HrUninitializeConMan(IN  INetConnectionManager *pConMan)
        {
            ReleaseObj(pConMan);

            return S_OK;
        }

        HRESULT HrEnumerateLanConnections(IN  INetConnectionManager *pConMan,
                                          OUT LAN_CONNECTION_LIST &listCon)
        {
            HRESULT     hr = S_OK;

            CIterNetCon         ncIter(pConMan, NCME_DEFAULT);
            INetConnection *    pconn;

            while (SUCCEEDED(hr) &&
                   (S_OK == (ncIter.HrNext(&pconn))))
            {
                NETCON_PROPERTIES * pProps;

                hr = pconn->GetProperties(&pProps);
                if (SUCCEEDED(hr))
                {
                    LAN_CONNECTION *    pLanCon;
                    BOOL                fMediaConnected;
                    WCHAR               szwInstance[_MAX_PATH];

                    pLanCon = new LAN_CONNECTION;
                    if (pLanCon)
                    {
                        pLanCon->guidId = pProps->guidId;
                        pLanCon->strName = pProps->pszwName;
                        pLanCon->Status = pProps->Status;
                        pLanCon->strDeviceName = pProps->pszwDeviceName;

                        if (SUCCEEDED(hr = HrQueryLanMediaState(&pProps->guidId,
                                                                &fMediaConnected)))
                        {
                            pLanCon->dwMediaState = fMediaConnected ?
                                NdisMediaStateConnected : NdisMediaStateDisconnected;
                        }
                        else
                        {
                            pLanCon->dwMediaState = hr;
                        }

                        hr = HrPnpInstanceIdFromGuid(&pProps->guidId, szwInstance,
                                                     celems(szwInstance));
                        if (SUCCEEDED(hr))
                        {
                            DEVINST     devinst;
                            pLanCon->strPnpName = szwInstance;

                            if (CR_SUCCESS == CM_Locate_DevNode(&devinst,
                                                                szwInstance,
                                                                CM_LOCATE_DEVNODE_NORMAL))
                            {
                                ULONG       ulStatus;
                                ULONG       ulProblem;
                                CONFIGRET   cfgRet;

                                cfgRet = CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                                                  devinst, 0, NULL);
                                if (CR_SUCCESS == cfgRet)
                                {
                                    pLanCon->ulDevNodeProblem = ulProblem;
                                    pLanCon->ulDevNodeStatus = ulStatus;
                                }
                            }
                        }

                        listCon.push_back(pLanCon);
                    }

                    FreeNetconProperties(pProps);
                }

                ReleaseObj(pconn);
            }

            return hr;
        }

        HRESULT HrFindLanConnection(IN  INetConnectionManager *pConMan,
                                    IN  PCWSTR szLanConnection,
                                    OUT INetConnection **ppcon)
        {
            HRESULT     hr = S_OK;

            CIterNetCon         ncIter(pConMan, NCME_DEFAULT);
            INetConnection *    pconn;

            *ppcon = NULL;

            while (SUCCEEDED(hr) &&
                   (S_OK == (ncIter.HrNext(&pconn))))
            {
                NETCON_PROPERTIES * pProps;

                hr = pconn->GetProperties(&pProps);
                if (SUCCEEDED(hr))
                {
                    if (!lstrcmpiW(pProps->pszwName, szLanConnection))
                    {
                        *ppcon = pconn;
                        break;
                    }
                    else
                    {
                        ReleaseObj(pconn);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                if (*ppcon == NULL)
                {
                    hr = S_FALSE;
                }
            }

            return hr;
        }

        VOID CmdShowAllDevices(IN const DIAG_OPTIONS *pOptions, 
                               IN INetConnectionManager *pConMan) throw(std::bad_alloc)
        {
            HRESULT             hr;
            DWORD               dwIndex = 0;
            SP_DEVINFO_DATA     deid = {0};
            HDEVINFO            hdi = NULL;
            WCHAR               szBuffer [MAX_PATH];

            hr = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL,
                                       DIGCF_PRESENT, &hdi);

            while (SUCCEEDED(hr = HrSetupDiEnumDeviceInfo(hdi,
                                                          dwIndex,
                                                          &deid)))
            {
                HKEY hkey;

                dwIndex++;

                hr = HrSetupDiOpenDevRegKey(hdi, &deid, DICS_FLAG_GLOBAL, 0,
                                            DIREG_DRV, KEY_READ, &hkey);
                if (SUCCEEDED(hr))
                {
                    ULONG   ulProblem;
                    ULONG   ulStatus;
                    PWSTR   pszName;

                    hr = HrSetupDiGetDeviceName(hdi, &deid, &pszName);
                    if (SUCCEEDED(hr))
                    {
                        g_pDiagCtx->Printf(ttidNcDiag, "Device name:            %S\n", pszName);
                        delete [] reinterpret_cast<BYTE*>(pszName);
                    }

                    (VOID) CM_Get_DevNode_Status_Ex(&ulStatus, &ulProblem,
                                                    deid.DevInst, 0, NULL);

                    tstring     strStatus;

                    SzFromCmStatus(ulStatus, &strStatus);

                    g_pDiagCtx->Printf(ttidNcDiag, "Device CM Status:       (0x%08X) %S\n", ulStatus,
                           strStatus.c_str());
                    g_pDiagCtx->Printf(ttidNcDiag, "Device CM Problem:      (0x%08X) %S\n", ulProblem,
                           SzFromCmProb(ulProblem));

                    g_pDiagCtx->Printf(ttidNcDiag, "Lan capable:            ");
                    if (S_OK == HrIsLanCapableAdapterFromHkey(hkey))
                    {
                        g_pDiagCtx->Printf(ttidNcDiag, "Yes\n");
                    }
                    else
                    {
                        g_pDiagCtx->Printf(ttidNcDiag, "No\n");
                    }

                    HRESULT hr = S_OK;
                    WCHAR   szGuid[c_cchGuidWithTerm] = {0};
                    DWORD   cbBuf = sizeof(szGuid);

                    hr = HrRegQuerySzBuffer(hkey, c_szRegValueNetCfgInstanceId,
                                            szGuid, &cbBuf);

                    g_pDiagCtx->Printf(ttidNcDiag, "Valid NetCfg device:    ");
                    if (S_OK == hr)
                    {
                        g_pDiagCtx->Printf(ttidNcDiag, "Yes\n");
                    }
                    else
                    {
                        g_pDiagCtx->Printf(ttidNcDiag, "No\n");
                    }

                    g_pDiagCtx->Printf(ttidNcDiag, "NetCfg instance ID:     %S\n", szGuid);

                    hr = HrSetupDiGetDeviceInstanceId(hdi, &deid, szBuffer,
                                                      sizeof(szBuffer), NULL);
                    if (SUCCEEDED(hr))
                    {
                        g_pDiagCtx->Printf(ttidNcDiag, "PnP instance ID:        %S\n", szBuffer);
                    }

                    DWORD   dwChars;
                    tstring strChars;

                    if (SUCCEEDED(HrRegQueryDword(hkey, L"Characteristics", &dwChars)))
                    {
                        SzFromCharacteristics(dwChars, &strChars);
                        g_pDiagCtx->Printf(ttidNcDiag, "Characteristics:        (0x%08X) %S\n", dwChars,
                               strChars.c_str());
                    }

                    hr = HrSetupDiGetDeviceRegistryProperty (hdi, &deid,
                            SPDRP_LOCATION_INFORMATION, NULL, (BYTE*)szBuffer,
                            sizeof (szBuffer), NULL);

                    if (S_OK == hr)
                    {
                        g_pDiagCtx->Printf(ttidNcDiag, "Location:               %S\n", szBuffer);
                    }

                    if ((NCF_PHYSICAL & dwChars) && *szGuid)
                    {
                        ULONGLONG MacAddr;
                        hr = HrGetNetCardAddr (szGuid, &MacAddr);
                        if (S_OK == hr)
                        {
                            g_pDiagCtx->Printf(ttidNcDiag, "Mac Address:            0x%012.12I64X\n", MacAddr);
                        }
                    }

                    GUID    guid;
                    BOOL    fMediaConnected;
                    DWORD   dwMediaState;

                    IIDFromString(szGuid, &guid);
                    if (SUCCEEDED(hr = HrQueryLanMediaState(&guid,
                                                            &fMediaConnected)))
                    {
                        dwMediaState = fMediaConnected ?
                            NdisMediaStateConnected : NdisMediaStateDisconnected;
                    }
                    else
                    {
                        dwMediaState = hr;
                    }

                    g_pDiagCtx->Printf(ttidNcDiag, "NDIS media status:      ");
                    switch (dwMediaState)
                    {
                    case NdisMediaStateConnected:
                        g_pDiagCtx->Printf(ttidNcDiag, "Connected\n");
                        break;

                    case NdisMediaStateDisconnected:
                        g_pDiagCtx->Printf(ttidNcDiag, "Disconnected\n");
                        break;

                    default:
                        g_pDiagCtx->Printf(ttidNcDiag, "Error 0x%08X\n", dwMediaState);
                        break;
                    }

                    RegCloseKey(hkey);
                }

                g_pDiagCtx->Printf(ttidNcDiag, "------------------------------------------------------------------------------------\n");
            }

            SetupDiDestroyDeviceInfoListSafe(hdi);
        }

        VOID CmdShowLanConnections(IN  const DIAG_OPTIONS  *pOptions, 
                                   OUT INetConnectionManager *pConMan) throw()
        {
            HRESULT                         hr = S_OK;
            LAN_CONNECTION_LIST             listCon;
            LAN_CONNECTION_LIST_ITERATOR    iterListCon;

            hr = HrEnumerateLanConnections(pConMan, listCon);
            if (SUCCEEDED(hr))
            {
                g_pDiagCtx->Printf(ttidNcDiag, "Current LAN connections\n\n");
                g_pDiagCtx->Printf(ttidNcDiag, "%-20S%-50S%-20S%\n", L"Connection Name", L"Device Name", L"Status");
                g_pDiagCtx->Printf(ttidNcDiag, "----------------------------------------------------------------------------------------\n");

                for (iterListCon = listCon.begin(); iterListCon != listCon.end(); iterListCon++)
                {
                    LAN_CONNECTION * pLanCon;

                    pLanCon = *iterListCon;

                    g_pDiagCtx->Printf(ttidNcDiag, "%-20S%-50S%-20S%\n",
                                       pLanCon->strName.c_str(),
                                       pLanCon->strDeviceName.c_str(),
                                       SzFromNetconStatus(pLanCon->Status));
                }
            }
        }

        VOID CmdShowLanDetails(IN  const DIAG_OPTIONS *pOptions, 
                               OUT INetConnectionManager *pConMan) throw(std::bad_alloc)
        {
            HRESULT                         hr = S_OK;
            LAN_CONNECTION_LIST             listCon;
            LAN_CONNECTION_LIST_ITERATOR    iterListCon;
            BOOL                            fFound = FALSE;

            hr = HrEnumerateLanConnections(pConMan, listCon);
            if (SUCCEEDED(hr))
            {
                for (iterListCon = listCon.begin(); iterListCon != listCon.end(); iterListCon++)
                {
                    LAN_CONNECTION * pLanCon;

                    pLanCon = *iterListCon;
                    if (!lstrcmpiW(pLanCon->strName.c_str(), pOptions->szLanConnection))
                    {
                        WCHAR       szwGuid[c_cchGuidWithTerm];

                        StringFromGUID2(pLanCon->guidId, szwGuid, c_cchGuidWithTerm);

                        g_pDiagCtx->Printf(ttidNcDiag, "Details for %S:\n", pOptions->szLanConnection);
                        g_pDiagCtx->Printf(ttidNcDiag, "------------------------------------------\n\n");
                        g_pDiagCtx->Printf(ttidNcDiag, "Device name:        %S\n", pLanCon->strDeviceName.c_str());
                        g_pDiagCtx->Printf(ttidNcDiag, "Device GUID:        %S\n", szwGuid);
                        g_pDiagCtx->Printf(ttidNcDiag, "PnP Instance ID:    %S\n", pLanCon->strPnpName.c_str());
                        g_pDiagCtx->Printf(ttidNcDiag, "Netman Status:      %S\n", SzFromNetconStatus(pLanCon->Status));

                        g_pDiagCtx->Printf(ttidNcDiag, "NDIS media status:  ");
                        switch (pLanCon->dwMediaState)
                        {
                        case NdisMediaStateConnected:
                            g_pDiagCtx->Printf(ttidNcDiag, "Connected\n");
                            break;

                        case NdisMediaStateDisconnected:
                            g_pDiagCtx->Printf(ttidNcDiag, "Disconnected\n");
                            break;

                        default:
                            g_pDiagCtx->Printf(ttidNcDiag, "Error 0x%08X\n", pLanCon->dwMediaState);
                            break;
                        }

                        tstring     strStatus;

                        SzFromCmStatus(pLanCon->ulDevNodeStatus, &strStatus);

                        g_pDiagCtx->Printf(ttidNcDiag, "CM DevNode Status:  (0x%08X) %S\n",
                               pLanCon->ulDevNodeStatus, strStatus.c_str());
                        g_pDiagCtx->Printf(ttidNcDiag, "CM DevNode Problem: (0x%08X) %S\n",
                               pLanCon->ulDevNodeProblem,
                               SzFromCmProb(pLanCon->ulDevNodeProblem));

                        fFound = TRUE;

                        // No need to keep looping
                        break;
                    }
                }
            }

            if (!fFound)
            {
                g_pDiagCtx->Printf(ttidNcDiag, "Could not find match for connection name: %S\n",
                       pOptions->szLanConnection);
            }
        }

        VOID CmdLanChangeState(IN const DIAG_OPTIONS *pOptions, 
                               IN INetConnectionManager *pConMan) throw ()
        {
            HRESULT                         hr = S_OK;
            INetConnection *                pcon = NULL;

            hr = HrFindLanConnection(pConMan, pOptions->szLanConnection, &pcon);
            if (S_OK == hr)
            {
                NETCON_PROPERTIES * pProps;

                hr = pcon->GetProperties(&pProps);
                if (SUCCEEDED(hr))
                {
                    if (pOptions->fConnect)
                    {
                        if (pProps->Status != NCS_CONNECTED)
                        {
                            pcon->Connect();
                        }
                        else
                        {
                            g_pDiagCtx->Printf(ttidNcDiag, "%S is already connected.\n",
                                   pOptions->szLanConnection);
                        }
                    }
                    else
                    {
                        if (pProps->Status != NCS_DISCONNECTED)
                        {
                            pcon->Disconnect();
                        }
                        else
                        {
                            g_pDiagCtx->Printf(ttidNcDiag, "%S is already disconnected.\n",
                                   pOptions->szLanConnection);
                        }
                    }

                    FreeNetconProperties(pProps);
                }
            }
            else if (S_FALSE == hr)
            {
                g_pDiagCtx->Printf(ttidNcDiag, "Could not find match for connection name: %S\n",
                       pOptions->szLanConnection);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\lan\lan.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N . C P P
//
//  Contents:   Implementation of LAN connection objects
//
//  Notes:
//
//  Author:     danielwe   2 Oct 1997
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include <ncreg.h>
#include <ncsetup.h>
#include "lan.h"
#include "lancmn.h"
#include "nccom.h"
#include "ncmisc.h"
#include "ncnetcon.h"
#include "sensapip.h"       // For SensNotifyNetconEvent
#include "ncstring.h"
#include "ncras.h"
#include "naming.h"
#include "wzcsvc.h"
#include "cobase.h"
#include "gpnla.h"
#include "ncperms.h"
#include "nmpolicy.h"

LONG g_CountLanConnectionObjects;

extern CGroupPolicyNetworkLocationAwareness* g_pGPNLA;

static const WCHAR c_szConnName[]       = L"Name";
static const WCHAR c_szShowIcon[]       = L"ShowIcon";
static const WCHAR c_szAutoConnect[]    = L"AutoConnect";

extern const WCHAR c_szRegKeyInterfacesFromInstance[];
extern const WCHAR c_szRegValueUpperRange[];
static const WCHAR c_chComma = L',';
extern const WCHAR c_szBiNdisAtm[];

static const DWORD c_cchMaxConnNameLen = 256;

static const CLSID CLSID_LanConnectionUi =
    {0x7007ACC5,0x3202,0x11D1,{0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

typedef DWORD (APIENTRY *PFNSENSNOTIFY) (PSENS_NOTIFY_NETCON pEvent);

#define NETCFG_S_NOTEXIST 0x00000002

//
// CComObject overrides
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::CreateInstance
//
//  Purpose:    Static function to create an instance of a LAN connection
//              object
//
//  Arguments:
//      hdi   [in]      Device installer device info
//      deid  [in]      Device installer device info
//      riid  [in]      Initial interface to query for
//      ppv   [out]     Returns the new interface pointer
//
//  Returns:    S_OK if success, otherwise OLE or Win32 error code
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
HRESULT CLanConnection::CreateInstance(IN  HDEVINFO hdi,
                                       IN  const SP_DEVINFO_DATA &deid,
                                       IN  PCWSTR pszPnpId,
                                       IN  REFIID riid, 
                                       OUT LPVOID *ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CLanConnection * pObj;
    pObj = new CComObject<CLanConnection>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_hkeyConn = NULL;
        pObj->m_hdi = hdi;
        pObj->m_deid = deid;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef();
        hr = pObj->FinalConstruct();
        pObj->InternalFinalConstructRelease();

        if (SUCCEEDED(hr))
        {
            hr = pObj->HrInitialize(pszPnpId);
            if (SUCCEEDED(hr))
            {
                hr = pObj->GetUnknown()->QueryInterface(riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    else
    {
        SetupDiDestroyDeviceInfoList(hdi);
    }

    TraceError("CLanConnection::CreateInstance", hr);
    return hr;
}

BOOL VerifyUniqueConnectionName(IN  const CIntelliName *pIntelliName, 
                                IN  PCWSTR pszPotentialName, 
                                OUT NETCON_MEDIATYPE *pncm, 
                                OUT NETCON_SUBMEDIATYPE *pncms)
{
    HRESULT     hr = S_OK;
    DWORD       dwSuffix = 2;
    HKEY        hkey;
    BOOL        fDupFound = FALSE;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\"
                        L"Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}",
                        KEY_READ, &hkey);
    if (S_OK == hr)
    {
        FILETIME    ft;
        DWORD       dwIndex = 0;
        WCHAR       szKeyName[MAX_PATH];
        DWORD       cchName = celems(szKeyName);

        while (!fDupFound && (S_OK == (hr = HrRegEnumKeyEx(hkey, dwIndex, szKeyName,
                                            &cchName, NULL, NULL, &ft))) )
        {
            HKEY    hkeyConn;
            WCHAR   szSubKey[MAX_PATH];

            wsprintfW(szSubKey, L"%s\\Connection", szKeyName);

            hr = HrRegOpenKeyEx(hkey, szSubKey, KEY_READ, &hkeyConn);
            if (S_OK == hr)
            {
                tstring     strName;

                hr = HrRegQueryString(hkeyConn, c_szConnName, &strName);
                if (S_OK == hr)
                {
                    if (!lstrcmpiW(pszPotentialName, strName.c_str()))
                    {
                        fDupFound = TRUE;
                        
                        CLSID guidName;
                        if (SUCCEEDED(CLSIDFromString(szKeyName, &guidName)))
                        {
                            hr = pIntelliName->HrGetPseudoMediaTypes(guidName, pncm, pncms);
                            if (FAILED(hr))
                            {
                                *pncm  = NCM_LAN;
                                *pncms = NCSM_LAN;
                            }
                        }
                        else
                        {
                            AssertSz(FALSE, "This doesn't look like a GUID.");
                        }

                        break;
                    }
                    else
                    {
                        dwIndex++;
                    }
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    // If value doesn't exist, that's ok. This is a new
                    // connection.
                    hr = S_OK;
                    dwIndex++;
                }

                RegCloseKey(hkeyConn);
            }
            else
            {
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    // If key doesn't exist, that's ok. This is not a
                    // connection.
                    hr = S_OK;
                    dwIndex++;
                }
            }

            cchName = celems(szKeyName);
        }

        RegCloseKey(hkey);
    }
    return fDupFound;
}
//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrInitialize
//
//  Purpose:    Initializes the connection object for the first time.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:      This function is only called when the object is created for
//              the very first time and has no identity.
//
HRESULT CLanConnection::HrInitialize(
    IN  PCWSTR pszPnpId)
{
    HRESULT     hr = S_OK;
    GUID        guid;

    AssertSz(m_hdi, "We should have a component at this point!");
    Assert(pszPnpId);

    hr = HrGetInstanceGuid(m_hdi, m_deid, &guid);
    if (S_OK == hr)
    {
        // Open the main connection key. If it doesn't exist, we'll create it
        // here.
        hr = HrOpenConnectionKey(&guid, NULL, KEY_READ_WRITE,
                                 OCCF_CREATE_IF_NOT_EXIST, pszPnpId,
                                 &m_hkeyConn);
        if (SUCCEEDED(hr))
        {
            tstring     strName;

            // First see if a name already exists for this connection
            hr = HrRegQueryString(m_hkeyConn, c_szConnName, &strName);
            if (FAILED(hr))
            {
                // no name?
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    //$ REVIEW (danielwe) 30 Oct 1997: If I can be assured
                    // that get_Name is never called before Rename, I
                    // don't need this function to be called.

                    // Note: (danielwe) 31 Oct 1997: This could result in
                    // duplicate names, but we cannot check for duplicates
                    // without recursing infinitely

                    // Set default connection name

                    CIntelliName IntelliName(_Module.GetResourceInstance(), VerifyUniqueConnectionName);

                    GUID gdDevice;
                    LPWSTR szNewName = NULL;
                    hr = HrGetInstanceGuid(m_hdi, m_deid, &gdDevice);
                    Assert(SUCCEEDED(hr));

                    if (SUCCEEDED(hr))
                    {
                        BOOL fNetworkBridge;
                        hr = HrIsConnectionNetworkBridge(&fNetworkBridge);

                        if (SUCCEEDED(hr) && fNetworkBridge)
                        {
                            hr = IntelliName.GenerateName(gdDevice, NCM_BRIDGE, 0, NULL, &szNewName);
                        }
                        else
                        {
                            hr = IntelliName.GenerateName(gdDevice, NCM_LAN, 0, NULL, &szNewName);
                        }

                        if (SUCCEEDED(hr))
                        {
                            hr = HrRegSetSz(m_hkeyConn, c_szConnName, szNewName);
                            CoTaskMemFree(szNewName);
                        }
                    }

                    Assert(SUCCEEDED(hr));
                }
            }
        }
    }


    if (SUCCEEDED(hr))
    {
        m_fInitialized = TRUE;
    }

    TraceError("CLanConnection::HrInitialize", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrOpenRegistryKeys
//
//  Purpose:    Opens the registry keys that this LAN connection object will
//              use
//
//  Arguments:
//      guid [in]   Guid of adapter that this connection uses
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     danielwe   11 Nov 1997
//
//  Notes:      Keys are expected to exist and this will fail if either do
//              not
//
HRESULT CLanConnection::HrOpenRegistryKeys(IN  const GUID &guid)
{
    HRESULT     hr = S_OK;

    AssertSz(!m_hkeyConn, "Don't call this more than once "
             "on the same connection object!");

    // This should only be called from HrLoad so these keys had better be
    // there.

    hr = HrOpenConnectionKey(&guid, NULL, KEY_READ_WRITE,
            OCCF_NONE, NULL, &m_hkeyConn);

    TraceError("CLanConnection::HrOpenRegistryKeys", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrLoad
//
//  Purpose:    Implements the bulk of IPersistNetConnection::Load.
//
//  Arguments:
//      guid [in]   GUID from which to receive identity
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
HRESULT CLanConnection::HrLoad(IN  const GUID &guid)
{
    HRESULT             hr = S_OK;

    hr = HrLoadDevInfoFromGuid(guid);
    if (SUCCEEDED(hr))
    {
        hr = HrOpenRegistryKeys(guid);
        if (SUCCEEDED(hr))
        {
            // No need to call HrInitialize because this object should
            // already be created properly at a previous time

            m_fInitialized = TRUE;
        }
    }

    TraceError("CLanConnection::HrLoad", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::~CLanConnection
//
//  Purpose:    Called when the connection object is released for the last
//              time.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Oct 1997
//
//  Notes:
//
CLanConnection::~CLanConnection() throw()
{
    RegSafeCloseKey(m_hkeyConn);
    SetupDiDestroyDeviceInfoListSafe(m_hdi);
    InterlockedDecrement(&g_CountLanConnectionObjects);
    CoTaskMemFree(m_pHNetProperties);
}

//
// INetConnection
//


//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Rename
//
//  Purpose:    Changes the name of the connection
//
//  Arguments:
//      pszName [in]     New connection name (must be valid)
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::Rename(IN  PCWSTR pszName)
{
    HRESULT     hr = S_OK;

    if (!pszName)
    {
        hr = E_POINTER;
    }
    else if (!*pszName)
    {
        hr = E_INVALIDARG;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else if (!FIsValidConnectionName(pszName))
    {
        // Bad connection name
        hr = E_INVALIDARG;
    }
    else
    {
        AssertSz(m_hkeyConn, "Why don't I have a connection key?");

        // Get the current name for this connection
        tstring strName;
        hr = HrRegQueryString(m_hkeyConn, c_szConnName, &strName);
        if (S_OK == hr)
        {
            // Only do something if names are different
            if (lstrcmpiW(pszName, strName.c_str()))
            {
                hr = HrPutName(pszName);
            }
        }
    }

    TraceError("CLanConnection::Rename", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrPutName
//
//  Purpose:    Sets the connection name using the given name
//
//  Arguments:
//      pszName [in]    New name for connection
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   31 Oct 1997
//
//  Notes:      Doesn't check if name is already set to this
//
HRESULT CLanConnection::HrPutName(IN  PCWSTR pszName)
{
    HRESULT     hr = S_OK;
    GUID        guid;

    // Get my device guid first
    hr = GetDeviceGuid(&guid);
    if (S_OK == hr)
    {
        hr = HrIsConnectionNameUnique(guid, pszName);
        if (S_OK == hr)
        {
            hr = HrRegSetSz(m_hkeyConn, c_szConnName, pszName);
            if (S_OK == hr)
            {
                LanEventNotify(CONNECTION_RENAMED, NULL, pszName, &guid);
            }
        }
        else if (S_FALSE == hr)
        {
            hr = HRESULT_FROM_WIN32(ERROR_DUP_NAME);
        }
    }

    TraceErrorOptional("CLanConnection::HrPutName", hr,
                       (hr == HRESULT_FROM_WIN32(ERROR_DUP_NAME)));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::FIsMediaPresent
//
//  Purpose:    Determines as best as can be basically whether the cable is
//              plugged in to the network card.
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if cable is plugged in, FALSE if not
//
//  Author:     danielwe   22 Sep 1998
//
//  Notes:      This function returns TRUE by default.
//
BOOL CLanConnection::FIsMediaPresent() throw()
{
    BOOL    fRet = TRUE;
    GUID    guid;

    if (S_OK == GetDeviceGuid(&guid))
    {
        fRet = ::FIsMediaPresent(&guid);
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetStatus
//
//  Purpose:    Returns the status of this LAN connection
//
//  Arguments:
//      pStatus [out]   Returns status value
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   3 Oct 1997
//
//  Notes:
//
HRESULT CLanConnection::GetStatus(OUT NETCON_STATUS *pStatus)
{
    HRESULT hr;

    if (!pStatus)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        GUID guid;

        hr = GetDeviceGuid(&guid);
        if (S_OK == hr)
        {
            hr = HrGetDevInstStatus(m_deid.DevInst, &guid, pStatus);
        }
    }

    TraceError("CLanConnection::GetStatus", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetDeviceName
//
//  Purpose:    Returns the name of the device being used by this connection
//
//  Arguments:
//      ppszwDeviceName [out]   Receives device name
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:      Returned string must be freed with CoTaskMemFree.
//
HRESULT CLanConnection::GetDeviceName(OUT PWSTR* ppszwDeviceName)
{
    Assert (ppszwDeviceName);
    Assert(m_hdi);

    // Initialize the output parameter.
    *ppszwDeviceName = NULL;

    PWSTR  szDesc;
    HRESULT hr = HrSetupDiGetDeviceName(m_hdi, &m_deid, &szDesc);
    if (SUCCEEDED(hr))
    {
        hr = HrCoTaskMemAllocAndDupSz (szDesc, ppszwDeviceName, NETCON_MAX_NAME_LEN);

        delete [] reinterpret_cast<BYTE*>(szDesc);
    }

    TraceError("CLanConnection::GetDeviceName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetCharacteristics
//
//  Purpose:    Returns the characteristics of this connection type
//
//  Arguments:
//      pdwFlags [out]    Returns characteristics flags
//
//  Returns:    S_OK if successful, OLE or Win32 error code otherwise
//
//  Author:     danielwe   3 Oct 1997
//
//  Notes:
//
HRESULT CLanConnection::GetCharacteristics(IN  NETCON_MEDIATYPE ncm, 
                                           OUT DWORD* pdwFlags)
{
    Assert (pdwFlags);

    *pdwFlags = NCCF_ALL_USERS | NCCF_ALLOW_RENAME;

    DWORD   dwValue;
    HRESULT hr = HrRegQueryDword(m_hkeyConn, c_szShowIcon, &dwValue);
    if (SUCCEEDED(hr) && dwValue)
    {
        *pdwFlags |= NCCF_SHOW_ICON;
    }

    BOOL fShared;
    hr = HrIsConnectionIcsPublic(&fShared);
    if(SUCCEEDED(hr) && TRUE == fShared)
    {
        *pdwFlags |= NCCF_SHARED;
    }

    BOOL fBridged;
    hr = HrIsConnectionBridged(&fBridged);
    if(SUCCEEDED(hr) && TRUE == fBridged)
    {
        *pdwFlags |= NCCF_BRIDGED;
    }

    BOOL bFirewalled;
    hr = HrIsConnectionFirewalled(&bFirewalled);
    if(SUCCEEDED(hr) && TRUE == bFirewalled)
    {
        *pdwFlags |= NCCF_FIREWALLED;
    }

    if(NCM_BRIDGE == ncm)
    {
        hr = HrEnsureValidNlaPolicyEngine();
        if(SUCCEEDED(hr))
        {
            BOOL fHasPermission;
            hr = m_pNetMachinePolicies->VerifyPermission(NCPERM_AllowNetBridge_NLA, &fHasPermission);
            if(SUCCEEDED(hr) && fHasPermission)
            {
                *pdwFlags |= NCCF_ALLOW_REMOVAL;
            }
        }
    }


    hr = S_OK;

    TraceError("CLanConnection::GetCharacteristics", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetUiObjectClassId
//
//  Purpose:    Returns the CLSID of the object that handles UI for this
//              connection type
//
//  Arguments:
//      pclsid [out]    Returns CLSID of UI object
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   6 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetUiObjectClassId(OUT CLSID *pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *pclsid = CLSID_LanConnectionUi;
    }

    TraceError("CLanConnection::GetUiObjectClassId", hr);
    return hr;
}

static const WCHAR c_szLibPath[]   = L"sens.dll";
static const CHAR c_szaFunction[]  = "SensNotifyNetconEvent";

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrCallSens
//
//  Purpose:    Calls the external SENS notification DLL to let it know that
//              we connected or disconnected.
//
//  Arguments:
//      fConnect [in]   TRUE if connecting, FALSE if disconnecting
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   16 Jun 1998
//
//  Notes:
//
HRESULT CLanConnection::HrCallSens(IN  BOOL fConnect)
{

    HRESULT         hr = S_OK;
    HMODULE         hmod;
    PFNSENSNOTIFY   pfnSensNotifyNetconEvent;

    hr = HrLoadLibAndGetProc(c_szLibPath, c_szaFunction, &hmod,
                             reinterpret_cast<FARPROC *>(&pfnSensNotifyNetconEvent));
    if (SUCCEEDED(hr))
    {
        DWORD               dwErr;
        SENS_NOTIFY_NETCON  snl = {0};

        snl.eType = fConnect ? SENS_NOTIFY_LAN_CONNECT :
                               SENS_NOTIFY_LAN_DISCONNECT;
        snl.pINetConnection = this;

        TraceTag(ttidLanCon, "Calling SENS to notify of %s.",
                 fConnect ? "connect" : "disconnect");

        dwErr = pfnSensNotifyNetconEvent(&snl);
        if (dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
        else
        {
            TraceTag(ttidLanCon, "Successfully notified SENS.");
        }

        FreeLibrary(hmod);
    }

    TraceError("CLanConnection::HrCallSens", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::HrConnectOrDisconnect
//
//  Purpose:    Connects or disconnects this LAN connection
//
//  Arguments:
//      fConnect [in]   TRUE if connect, FALSE if disconnect
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   4 Dec 1997
//
//  Notes:
//
HRESULT CLanConnection::HrConnectOrDisconnect(IN  BOOL fConnect)
{
    HRESULT     hr = S_OK;

    if (!m_hdi)
    {
        hr = E_UNEXPECTED;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Before attempting to connect, check media state. If it is
        // disconnected, return error code that indicates that network is
        // not present because the cable is unplugged.
        //
        if (fConnect)
        {
            if (!FIsMediaPresent())
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_CONNECTED);
            }
        }

        if (SUCCEEDED(hr))
        {
            //
            // Enable both on global and config-specific profile
            // do global first and see if that succeeded in enabling the device
            // (global enable doesn't mark reboot required if device is still
            // disabled on current config whereas vice-versa isn't true)
            //
            // However, disable in global config only.

            hr = HrSetupDiSendPropertyChangeNotification(m_hdi, &m_deid,
                                      fConnect ? DICS_ENABLE : DICS_DISABLE,
                                      DICS_FLAG_GLOBAL, 0);

            if ( fConnect && SUCCEEDED(hr) )
            {
                hr = HrSetupDiSendPropertyChangeNotification(m_hdi, &m_deid,
                                          DICS_ENABLE,
                                          DICS_FLAG_CONFIGSPECIFIC, 0);
            }

            if (SUCCEEDED(hr))
            {
                NETCON_STATUS   status;

                hr = GetStatus(&status);
                if (SUCCEEDED(hr))
                {
                    if (fConnect)
                    {
                        int nSecondsToWait = 5;
                        HRESULT hrRetry = S_OK;

                        while ((nSecondsToWait) && SUCCEEDED(hrRetry) &&
                               ((NCS_CONNECTING == status) || (NCS_MEDIA_DISCONNECTED == status) || (NCS_INVALID_ADDRESS == status)))
                        {
                            //#300520: check a few more times since the connection is
                            // still coming up
                            Sleep(1000);

                            hrRetry = GetStatus(&status);
                            nSecondsToWait --;
                        }

                        if (status != NCS_CONNECTED)
                        {
                            // did not connect successfully
                            hr = HRESULT_FROM_WIN32(ERROR_RETRY);
                            TraceError("HrConnectOrDisconnect - failed to "
                                       "connect!", hr);
                        }
                    }
                    else
                    {
                        if (status != NCS_DISCONNECTED)
                        {
                            // did not disconnect successfully
                            hr = HRESULT_FROM_WIN32(ERROR_RETRY);
                            TraceError("HrConnectOrDisconnect - failed to "
                                       "disconnect!", hr);
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = HrCallSens(fConnect);
                    if (FAILED(hr))
                    {
                        TraceTag(ttidLanCon, "Failed to notify SENS on %s. "
                                 "Non-fatal 0x%08X",
                                 fConnect ? "connect" : "disconnect", hr);
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceError("CLanConnection::HrConnectOrDisconnect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Connect
//
//  Purpose:    Activates the current LAN connection by telling its underlying
//              adapter to activate itself.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   14 Oct 1997
//
//  Notes:      Causes auto-connect value of TRUE to be written for this
//              connection in the current hardware profile.
//
STDMETHODIMP CLanConnection::Connect()
{
    HRESULT     hr = S_OK;

    hr = HrConnectOrDisconnect(TRUE);

    TraceError("CLanConnection::Connect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Disconnect
//
//  Purpose:    Deactivates the current LAN connection by telling its
//              underlying adapter to deactivate itself.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   14 Oct 1997
//
//  Notes:      Causes auto-connect value of FALSE to be written for this
//              connection in the current hardware profile.
//
STDMETHODIMP CLanConnection::Disconnect()
{
    HRESULT     hr = S_OK;

    hr = HrConnectOrDisconnect(FALSE);

    TraceError("CLanConnection::Disconnect", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Delete
//
//  Purpose:    Delete the LAN/BRIDGE connection.  
//
//  Arguments:
//      (none)
//
//  Returns:    E_UNEXPECTED;
//
//  Author:     shaunco   21 Jan 1998
//
//  Notes:      This function is only expected to be called for a bridge.
//
STDMETHODIMP CLanConnection::Delete()
{
    HRESULT hr;
    NETCON_PROPERTIES* pProperties;
    hr = GetProperties(&pProperties);
    if(SUCCEEDED(hr))
    {
        if(NCM_BRIDGE == pProperties->MediaType)
        {
            IHNetConnection *pHNetConnection;
            IHNetBridge* pNetBridge;

            Assert(m_fInitialized);

            hr = HrGetIHNetConnection(&pHNetConnection);

            if (SUCCEEDED(hr))
            {
                hr = pHNetConnection->GetControlInterface(
                        IID_IHNetBridge,
                        reinterpret_cast<void**>(&pNetBridge)
                        );

                ReleaseObj(pHNetConnection);

                AssertSz(SUCCEEDED(hr), "Unable to retrieve IHNetBridge");
            }

            if(SUCCEEDED(hr))
            {
                hr = pNetBridge->Destroy();
                ReleaseObj(pNetBridge);
            }
        }
        else
        {
            hr = E_FAIL;  // can't delete anything but NCM_BRIDGE
        }
        FreeNetconProperties(pProperties);
    }
    return hr;
}

STDMETHODIMP CLanConnection::Duplicate (
    IN  PCWSTR             pszDuplicateName,
    OUT INetConnection**    ppCon)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetProperties
//
//  Purpose:    Get all of the properties associated with the connection.
//              Returning all of them at once saves us RPCs vs. returning
//              each one individually.
//
//  Arguments:
//      ppProps [out] Returned block of properties.
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   1 Feb 1998
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetProperties (
    OUT NETCON_PROPERTIES** ppProps)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!ppProps)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        // Initialize the output parameter.
        //
        *ppProps = NULL;

        NETCON_PROPERTIES* pProps;
        NETCON_STATUS ncStatus;

        hr = HrCoTaskMemAlloc (sizeof (NETCON_PROPERTIES),
                reinterpret_cast<void**>(&pProps));
        if (SUCCEEDED(hr))
        {
            HRESULT hrT;

            ZeroMemory (pProps, sizeof (NETCON_PROPERTIES));

            // guidId
            //
            hrT = GetDeviceGuid(&pProps->guidId);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // pszwName
            //
            tstring strName;
            hrT = HrRegQueryString(m_hkeyConn, c_szConnName, &strName);
            if (SUCCEEDED(hrT))
            {
                hrT = HrCoTaskMemAllocAndDupSz (strName.c_str(),
                                &pProps->pszwName, NETCON_MAX_NAME_LEN);
            }
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // pszwDeviceName
            //
            PWSTR szDesc;
            hrT = HrSetupDiGetDeviceName(m_hdi, &m_deid, &szDesc);
            if (SUCCEEDED(hrT))
            {
                hrT = HrCoTaskMemAllocAndDupSz (szDesc,
                                &pProps->pszwDeviceName, NETCON_MAX_NAME_LEN);

                delete [] reinterpret_cast<BYTE*>(szDesc);
            }
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // Status
            //
            hrT = GetStatus (&pProps->Status);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // Get additional Status information from 802.1X
            //
            if ((NCS_CONNECTED == pProps->Status) 
                || (NCS_INVALID_ADDRESS == pProps->Status) 
                || (NCS_MEDIA_DISCONNECTED == pProps->Status))
            {
                hrT = WZCQueryGUIDNCSState(&pProps->guidId, &ncStatus);
                if (S_OK == hrT)
                {
                    pProps->Status = ncStatus;
                }
            }

            // Type
            //
            BOOL fNetworkBridge;
            hrT = HrIsConnectionNetworkBridge(&fNetworkBridge);
            if(SUCCEEDED(hrT) && TRUE == fNetworkBridge)
            {
                pProps->MediaType = NCM_BRIDGE;
            }
            else
            {
                pProps->MediaType = NCM_LAN;
            }

            // dwCharacter
            //
            hrT = GetCharacteristics (pProps->MediaType, &pProps->dwCharacter);
            if (FAILED(hrT))
            {
                hr = hrT;
            }

            // clsidThisObject
            //
            pProps->clsidThisObject = CLSID_LanConnection;

            // clsidUiObject
            //
            pProps->clsidUiObject = CLSID_LanConnectionUi;

            // Assign the output parameter or cleanup if we had any failures.
            //
            if (SUCCEEDED(hr))
            {
                *ppProps = pProps;
            }
            else
            {
                Assert (NULL == *ppProps);
                FreeNetconProperties (pProps);
            }
        }
    }
    TraceError ("CLanConnection::GetProperties", hr);
    return hr;
}


//
// INetLanConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetInfo
//
//  Purpose:    Returns information about this connection
//
//  Arguments:
//      dwMask      [in]    Flags that control which fields to return. Use
//                          LCIF_ALL to get all fields.
//      pLanConInfo [out]   Structure that holds returned information
//
//  Returns:    S_OK if success, OLE error code otherwise
//
//  Author:     danielwe   6 Oct 1997
//
//  Notes:      Caller should delete the szwConnName value.
//
STDMETHODIMP CLanConnection::GetInfo(IN  DWORD dwMask, 
                                     OUT LANCON_INFO* pLanConInfo)
{
    HRESULT     hr = S_OK;

    if (!pLanConInfo)
    {
        hr = E_POINTER;
    }
    else if (!m_hdi)
    {
        hr = E_UNEXPECTED;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        ZeroMemory(pLanConInfo, sizeof(LANCON_INFO));

        if (dwMask & LCIF_COMP)
        {
            GUID    guid;

            hr = HrGetInstanceGuid(m_hdi, m_deid, &guid);
            pLanConInfo->guid = guid;
        }

        if (dwMask & LCIF_NAME)
        {
            hr = GetDeviceName(&pLanConInfo->szwConnName);
        }

        if (dwMask & LCIF_ICON)
        {
            if (SUCCEEDED(hr))
            {
                DWORD dwValue;

                hr = HrRegQueryDword(m_hkeyConn, c_szShowIcon, &dwValue);
                // OK if value not there. Default to FALSE always.
                //
                if (S_OK == hr)
                {
                    pLanConInfo->fShowIcon = !!(dwValue);
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    hr = NETCFG_S_NOTEXIST;
                }
            }
        }
    }

    // Mask S_FALSE if it slipped thru.
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError("CLanConnection::GetInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::SetInfo
//
//  Purpose:    Sets information about this connection.
//
//  Arguments:
//      dwMask      [in]    Flags that control which fields to set
//      pLanConInfo [in]    Structure containing information to set
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   6 Oct 1997
//
//  Notes:      The guid member can only be set if the object is not yet
//              initialized.
//              The AutoConnect value is never set because it is set only upon
//              connect or disconnect.
//              If szwConnName is NULL, it is left unchanged.
//
STDMETHODIMP CLanConnection::SetInfo(IN  DWORD dwMask,
                                     IN  const LANCON_INFO* pLanConInfo)
{
    HRESULT     hr = S_OK;

    if (!pLanConInfo)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        // If we're not yet initialized, the only thing we will allow is the
        // flag that gets us initialized
        if (dwMask != LCIF_COMP)
        {
            hr = E_UNEXPECTED;
        }
        else
        {
            hr = HrLoad(pLanConInfo->guid);
            if (SUCCEEDED(hr))
            {
                WCHAR szPnpId[MAX_DEVICE_ID_LEN];

                hr = HrSetupDiGetDeviceInstanceId(m_hdi, &m_deid, szPnpId,
                            MAX_DEVICE_ID_LEN, NULL);
                if (S_OK == hr)
                {
                    hr = HrInitialize(szPnpId);
                }
            }
        }
    }
    else
    {
        if (dwMask & LCIF_NAME)
        {
            AssertSz(pLanConInfo->szwConnName,
                     "If you're going to set it, set it!");

            // Set connection name
            hr = Rename(pLanConInfo->szwConnName);
        }

        if (dwMask & LCIF_ICON)
        {
            if (SUCCEEDED(hr))
            {
                // Set ShowIcon value
                hr = HrRegSetDword(m_hkeyConn, c_szShowIcon,
                                   pLanConInfo->fShowIcon);
            }
        }

        if (SUCCEEDED(hr))
        {
            LanEventNotify(CONNECTION_MODIFIED, this, NULL, NULL);
        }
    }

    TraceError("CLanConnection::SetInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetDeviceGuid
//
//  Purpose:    Returns the instance GUID of the device being used by this
//              connection
//
//  Arguments:
//      pguid [out]     Receives GUID of device
//
//  Returns:    S_OK if success, NetCfg error code otherwise
//
//  Author:     danielwe   2 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetDeviceGuid(OUT GUID *pguid)
{
    HRESULT hr;

    AssertSz(m_hdi, "No component?!");

    if (!pguid)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = HrGetInstanceGuid(m_hdi, m_deid, pguid);
    }

    TraceError("CLanConnection::GetDeviceGuid", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// IPersistNetConnection
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetClassID
//
//  Purpose:    Returns the CLSID of LAN connection objects
//
//  Arguments:
//      pclsid [out]    Returns CLSID to caller
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetClassID(OUT CLSID*  pclsid)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pclsid)
    {
        hr = E_POINTER;
    }
    else
    {
        *pclsid = CLSID_LanConnection;
    }
    TraceError("CLanConnection::GetClassID", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetSizeMax
//
//  Purpose:    Returns the maximum size of the persistence data
//
//  Arguments:
//      pcbSize [out]   Returns size
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::GetSizeMax(OUT ULONG *pcbSize)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!pcbSize)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        *pcbSize = sizeof(GUID);
    }

    TraceError("CLanConnection::GetSizeMax", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Load
//
//  Purpose:    Allows the connection object to initialize (restore) itself
//              from previously persisted data
//
//  Arguments:
//      pbBuf  [in]     Private data to use for restoring
//      cbSize [in]     Size of data
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::Load(IN  const BYTE *pbBuf, 
                                  IN  ULONG cbSize)
{
    HRESULT hr = E_INVALIDARG;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (cbSize != sizeof(GUID))
    {
        hr = E_INVALIDARG;
    }
    // We can only accept one call on this method and only if we're not
    // already initialized.
    //
    else if (m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        GUID    guid;

        CopyMemory(&guid, pbBuf, sizeof(GUID));
        hr = HrLoad(guid);
    }

    TraceError("CLanConnection::Load", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::Save
//
//  Purpose:    Provides the caller with data to use in restoring this object
//              at a later time.
//
//  Arguments:
//      pbBuf  [out]    Returns data to use for restoring
//      cbSize [in]     Size of data buffer
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   4 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnection::Save(OUT  BYTE *pbBuf, IN  ULONG cbSize)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!pbBuf)
    {
        hr = E_POINTER;
    }
    else if (!m_fInitialized || !m_hdi)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        GUID    guid;

        hr = HrGetInstanceGuid(m_hdi, m_deid, &guid);
        if (S_OK == hr)
        {
            CopyMemory(pbBuf, &guid, cbSize);
        }
    }

    TraceError("CLanConnection::Save", hr);
    return hr;
}

//
// Private functions
//

extern const WCHAR c_szRegValueNetCfgInstanceId[];

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuid
//
//  Purpose:    Given device info, returns the NetCfg instance GUID of the
//              connection.
//
//  Arguments:
//      hdi   [in]      SetupAPI data
//      deid  [in]      SetupAPI data
//      pguid [out]     GUID of netcfg component
//
//  Returns:    S_OK if success, Win32 or SetupAPI error otherwise
//
//  Author:     danielwe   7 Jan 1998
//
//  Notes:
//
HRESULT HrGetInstanceGuid(IN  HDEVINFO hdi, 
                          IN  const SP_DEVINFO_DATA &deid,
                          OUT LPGUID pguid)
{
    HRESULT hr;
    HKEY hkey;

    Assert(pguid);

    hr = HrSetupDiOpenDevRegKey(hdi, const_cast<SP_DEVINFO_DATA *>(&deid),
                                DICS_FLAG_GLOBAL, 0,
                                DIREG_DRV, KEY_READ, &hkey);
    if (S_OK == hr)
    {
        WCHAR       szGuid[c_cchGuidWithTerm];
        DWORD       cbBuf = sizeof(szGuid);

        hr = HrRegQuerySzBuffer(hkey, c_szRegValueNetCfgInstanceId,
                                szGuid, &cbBuf);
        if (S_OK == hr)
        {
            IIDFromString(szGuid, pguid);
        }

        RegCloseKey(hkey);
    }

    TraceError("HrInstanceGuidFromDeid", hr);
    return hr;
}

static const WCHAR c_szKeyFmt[] = L"%s\\%s\\%s\\Connection";
extern const WCHAR c_szRegKeyComponentClasses[];
extern const WCHAR c_szRegValuePnpInstanceId[];

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadDevInfoFromGuid
//
//  Purpose:    Given a NetCfg instance GUID, loads the m_hdi and m_deid
//              members from the device installer.
//
//  Arguments:
//      guid [in]   GUID of connection
//
//  Returns:    S_OK if success, Win32 or SetupAPI error otherwise
//
//  Author:     danielwe   7 Jan 1998
//
//  Notes:
//
HRESULT CLanConnection::HrLoadDevInfoFromGuid(IN  const GUID &guid)
{
    HRESULT             hr = S_OK;
    SP_DEVINFO_DATA     deid = {0};
    HKEY                hkeyNetCfg;
    WCHAR               szRegPath[c_cchMaxRegKeyLengthWithNull];
    WCHAR               szGuid[c_cchGuidWithTerm];
    WCHAR               szClassGuid[c_cchGuidWithTerm];

    StringFromGUID2(GUID_DEVCLASS_NET, szClassGuid, c_cchGuidWithTerm);
    StringFromGUID2(guid, szGuid, c_cchGuidWithTerm);
    wsprintfW(szRegPath, c_szKeyFmt, c_szRegKeyComponentClasses,
             szClassGuid, szGuid);

    // Open the Control\Network\{CLASS}\{Instance GUID} key
    //
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegPath,
                        KEY_READ, &hkeyNetCfg);
    if (SUCCEEDED(hr))
    {
        tstring     strInstanceId;

        hr = HrRegQueryString(hkeyNetCfg, c_szRegValuePnpInstanceId,
                              &strInstanceId);
        if (SUCCEEDED(hr))
        {
            hr = HrSetupDiCreateDeviceInfoList(&GUID_DEVCLASS_NET,
                                               NULL, &m_hdi);
            if (SUCCEEDED(hr))
            {
                hr = HrSetupDiOpenDeviceInfo(m_hdi, strInstanceId.c_str(),
                                             NULL, 0, &m_deid);
            }
        }

        RegCloseKey(hkeyNetCfg);
    }

    TraceError("HrLoadDevInfoFromGuid", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsAtmAdapterFromHkey
//
//  Purpose:    Determines if the given HKEY describes an ATM physical adapter
//
//  Arguments:
//      hkey [in]   HKEY under Control\Class\{GUID}\<instance> (aka driver key)
//
//  Returns:    S_OK if device is ATM physical adapter, S_FALSE if not,
//              Win32 error otherwise
//
//  Author:     tongl   10 Dec 1998
//
//  Notes:
//
HRESULT CLanConnection::HrIsAtmAdapterFromHkey(IN  HKEY hkey)
{
    HRESULT                     hr = S_OK;
    WCHAR                       szBuf[256];
    DWORD                       cbBuf = sizeof(szBuf);
    list<tstring *>             lstr;
    list<tstring *>::iterator   lstrIter;
    BOOL                        fMatch = FALSE;
    HKEY                        hkeyInterfaces;

    hr = HrRegOpenKeyEx(hkey, c_szRegKeyInterfacesFromInstance,
                        KEY_READ, &hkeyInterfaces);
    if (SUCCEEDED(hr))
    {
        hr = HrRegQuerySzBuffer(hkeyInterfaces, c_szRegValueUpperRange,
                                szBuf, &cbBuf);
        if (SUCCEEDED(hr))
        {
            ConvertStringToColString(szBuf, c_chComma, lstr);

            for (lstrIter = lstr.begin(); lstrIter != lstr.end(); lstrIter++)
            {
                // See if it matches one of these

                if (!lstrcmpiW((*lstrIter)->c_str(), c_szBiNdisAtm))
                {
                    fMatch = TRUE;
                    break;
                }
            }

            DeleteColString(&lstr);
        }

        RegCloseKey(hkeyInterfaces);
    }

    if (SUCCEEDED(hr))
    {
        if (fMatch)
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    TraceError("HrIsAtmAdapterFromHkey", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsAtmElanFromHkey
//
//  Purpose:    Determines if the given HKEY describes an ATM ELAN adapter
//
//  Arguments:
//      hkey [in]   HKEY under Control\Class\{GUID}\<instance> (aka driver key)
//
//  Returns:    S_OK if device is ELAN capable, S_FALSE if not, Win32 error
//              otherwise
//
//  Author:     tongl   21 Oct 1998
//
//  Notes:
//
HRESULT CLanConnection::HrIsAtmElanFromHkey(IN  HKEY hkey)
{
    HRESULT hr;

    // pszInfId should have enough characters to hold "ms_atmelan".
    // If the registry value is bigger than that, we know we don't have
    // a match.
    //
    WCHAR pszInfId [24];
    DWORD cbInfId = sizeof(pszInfId);

    hr = HrRegQuerySzBuffer(hkey, L"ComponentId", pszInfId, &cbInfId);

    if ((S_OK != hr) || (0 != _wcsicmp(pszInfId, L"ms_atmelan")))
    {
        hr = S_FALSE;
    }

    Assert ((S_OK == hr) || (S_FALSE == hr));

    TraceError("HrIsAtmElanFromHkey", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionBridged
//
//  Purpose:    Determines if connection is a member of a brigde
//
//  Arguments:
//      pfBridged [in]   A boolean for the result
//
//  Returns:    S_OK if pfBridged is valid
//              S_FALSE if pfBridged can't currently be determined
//              Error otherwise
//
//  Author:     kenwic 11 July 2000
//
//  Notes:
//
HRESULT CLanConnection::HrIsConnectionBridged(OUT BOOL* pfBridged)
{
    *pfBridged = FALSE;
    HRESULT hResult = S_OK;

    hResult = HrEnsureHNetPropertiesCached();

    if (S_OK == hResult)
    {
        *pfBridged = m_pHNetProperties->fPartOfBridge;
    }

    return hResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionFirewalled
//
//  Purpose:    Determines if connection is firewalled
//
//  Arguments:
//      pfFirewalled [in]   A boolean for the result
//
//  Returns:    S_OK if pfFirewalled is valid
//              S_FALSE if pfFirewalled can't currently be determined
//              Error otherwise
//
//  Author:     kenwic 11 July 2000
//
//  Notes:
//
HRESULT CLanConnection::HrIsConnectionFirewalled(OUT BOOL* pfFirewalled)
{
    HRESULT hr = S_OK;
    BOOL fHasPermission = FALSE;

    *pfFirewalled = FALSE;

    hr = HrEnsureHNetPropertiesCached();
    if (S_OK == hr)
    {
        *pfFirewalled = m_pHNetProperties->fFirewalled;

        if (*pfFirewalled)
        {
            // A Connection is only firewalled if the firewall is currently running, so
            // we return FALSE if the permission denies the firewall from running.
            hr = HrEnsureValidNlaPolicyEngine();
            TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "CLanConnection::HrIsConnectionFirewalled calling HrEnsureValidNlaPolicyEngine", hr);

            if (SUCCEEDED(hr))
            {
                hr = m_pNetMachinePolicies->VerifyPermission(NCPERM_PersonalFirewallConfig, &fHasPermission);
                if (SUCCEEDED(hr) && !fHasPermission)
                {
                    *pfFirewalled = FALSE;
                }
            }
        }
    }
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionNetworkBridge
//
//  Purpose:    Determines if a brigde
//
//  Arguments:
//      pfNetworkBridge [in]   A boolean for the result
//
//  Returns:    S_OK if pfNetworkBridge is valid
//              S_FALSE if pfNetworkBridge can't currently be determined
//              Error otherwise
//
//  Author:     kenwic 11 July 2000
//
//  Notes:
//
static const WCHAR c_szNetworkBridgeComponentId[] = L"ms_bridgemp";
extern const WCHAR c_szRegValueComponentId[];

HRESULT CLanConnection::HrIsConnectionNetworkBridge(OUT BOOL* pfNetworkBridge)
{
    *pfNetworkBridge = FALSE;
    HRESULT hr = S_OK;

    HKEY hkey;
    hr = HrSetupDiOpenDevRegKey(m_hdi, const_cast<SP_DEVINFO_DATA *>(&m_deid),
                                DICS_FLAG_GLOBAL, 0,
                                DIREG_DRV, KEY_READ, &hkey);
    if (S_OK == hr)
    {
        WCHAR       szComponentId[60]; // if it's bigger than this, it's not the bridge, but make it big to shut up the tracing
        DWORD       cbBuf = sizeof(szComponentId);

        hr = HrRegQuerySzBuffer(hkey, c_szRegValueComponentId,
            szComponentId, &cbBuf);
        if (S_OK == hr || HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
        {
            if(0 == lstrcmp(szComponentId, c_szNetworkBridgeComponentId))
            {
                *pfNetworkBridge = TRUE;
            }

            hr = S_OK;
        }

        RegCloseKey(hkey);
    }

    TraceError("HrIsConnectionNetworkBridge", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrIsConnectionIcsPublic
//
//  Purpose:    Determines if connection is shared (ICS public)
//
//  Arguments:
//      pfIcsPublic [out]   A boolean for the result
//
//  Returns:    S_OK if pfIcsPublic is valid
//              S_FALSE if pfIcsPublic can't currently be determined
//              Error otherwise
//
//  Author:     jonburs 31 July 2000
//
//  Notes:
//
HRESULT CLanConnection::HrIsConnectionIcsPublic(OUT BOOL* pfIcsPublic)
{
    Assert(NULL != pfIcsPublic);
    *pfIcsPublic = FALSE;
    HRESULT hResult = S_OK;

    hResult = HrEnsureHNetPropertiesCached();

    if (S_OK == hResult)
    {
        *pfIcsPublic = m_pHNetProperties->fIcsPublic;
    }

    return hResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrEnsureHNetPropertiesCached
//
//  Purpose:    Makes sure home networking properties are up-to-date
//
//  Arguments:
//
//  Returns:    S_OK if m_pHNetProperties is now valid (success)
//              S_FALSE if it's not currently possible to update the properties
//              (e.g., recursive attempt to update)
//
//  Author:     jonburs 16 August 2000
//
//  Notes:
//
HRESULT CLanConnection::HrEnsureHNetPropertiesCached(VOID)
{
    HRESULT hr = S_OK;

    Assert(TRUE == m_fInitialized);

    if (!m_fHNetPropertiesCached
        || m_lHNetModifiedEra != g_lHNetModifiedEra)
    {
        //
        // Our cached properties are possibly out of date. Check
        // to see that this is not a recursive entry
        //

        if (0 == InterlockedExchange(&m_lUpdatingHNetProperties, 1))
        {
            IHNetConnection *pHNetConn;
            HNET_CONN_PROPERTIES *pProps;

            hr = HrGetIHNetConnection(&pHNetConn);

            if (SUCCEEDED(hr))
            {
                hr = pHNetConn->GetProperties(&pProps);
                ReleaseObj(pHNetConn);

                if (SUCCEEDED(hr))
                {
                    //
                    // Store new properties, and free old. Note that CoTaskMemFree
                    // properly handles NULL input.
                    //

                    pProps =
                        reinterpret_cast<HNET_CONN_PROPERTIES*>(
                            InterlockedExchangePointer(
                                reinterpret_cast<PVOID*>(&m_pHNetProperties),
                                reinterpret_cast<PVOID>(pProps)
                            )
                        );

                    CoTaskMemFree(pProps);

                    //
                    // Update our era, and note that we have valid properties
                    //

                    InterlockedExchange(&m_lHNetModifiedEra, g_lHNetModifiedEra);
                    m_fHNetPropertiesCached = TRUE;

                    hr = S_OK;
                }
            }
            else
            {
                //
                // If we don't yet have a record of this connection w/in the
                // home networking store, HrGetIHNetConnection will fail (as
                // we ask it not to create new entries). We therefore convert
                // failure to S_FALSE, which means we can't retrieve this info
                // right now.
                //

                hr = S_FALSE;
            }

            //
            // We're no longer updating our properties
            //

            InterlockedExchange(&m_lUpdatingHNetProperties, 0);
        }
        else
        {
            //
            // Update is alredy going on (possibly an earlier call on
            // the same thread). Return S_FALSE.
            //

            hr = S_FALSE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetIHNetConnection
//
//  Purpose:    Retrieves the IHNetConnection for this connection
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     jonburs 16 August 2000
//
//  Notes:
//
HRESULT CLanConnection::HrGetIHNetConnection(OUT IHNetConnection **ppHNetConnection)
{
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr;
    GUID guid;

    Assert(ppHNetConnection);

    hr = GetDeviceGuid(&guid);

    if (SUCCEEDED(hr))
    {
        hr = HrGetHNetCfgMgr(&pCfgMgr);
    }

    if (SUCCEEDED(hr))
    {
        hr = pCfgMgr->GetIHNetConnectionForGuid(
                &guid,
                TRUE,
                FALSE,
                ppHNetConnection
                );

        ReleaseObj(pCfgMgr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ShowIcon
//
//  Purpose:    Sets the Icon state for the systray, fires an event to notify
//              NetShell of the Change
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     ckotze 25 September 2000
//
//  Notes:
//
HRESULT CLanConnection::ShowIcon(IN  const BOOL bShowIcon)
{
    HRESULT hr;
    LANCON_INFO lcInfo;

    hr = GetInfo(LCIF_ICON, &lcInfo);

    if (SUCCEEDED(hr))
    {
        lcInfo.fShowIcon = bShowIcon;
        hr = SetInfo(LCIF_ICON, &lcInfo);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IconStateChanged
//
//  Purpose:    Fires an event to notify NetShell of a Change occuring in an
//              incoming connection.
//
//  Arguments:
//
//  Returns:    S_OK on success; error otherwise
//
//  Author:     ckotze 25 September 2000
//
//  Notes:
//
inline
HRESULT CLanConnection::IconStateChanged()
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnection::GetProperties
//
//  Purpose:    Get all of the properties associated with the connection.
//              Returning all of them at once saves us RPCs vs. returning
//              each one individually.
//
//  Arguments:
//      ppProps [out] Returned block of properties.
//
//  Returns:    S_OK or an error.
//
//  Author:     shaunco   1 Feb 1998
//
//  Notes:
//
HRESULT CLanConnection::GetPropertiesEx(OUT NETCON_PROPERTIES_EX** ppConnectionPropertiesEx)
{
    HRESULT hr = S_OK;

    *ppConnectionPropertiesEx = NULL;

    if (!m_fInitialized)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        NETCON_PROPERTIES* pProps;
        NETCON_PROPERTIES_EX* pPropsEx = reinterpret_cast<NETCON_PROPERTIES_EX*>(CoTaskMemAlloc(sizeof(NETCON_PROPERTIES_EX)));

        if (pPropsEx)
        {
            ZeroMemory(pPropsEx, sizeof(NETCON_PROPERTIES_EX));

            hr = GetProperties(&pProps);
            if (SUCCEEDED(hr))
            {
                hr = HrBuildPropertiesExFromProperties(pProps, pPropsEx, dynamic_cast<IPersistNetConnection *>(this));
                if (SUCCEEDED(hr))
                {
                    if (NCM_LAN == pPropsEx->ncMediaType)
                    {
                        CIntelliName inName(NULL, NULL);
                        NETCON_MEDIATYPE    ncm;
                        NETCON_SUBMEDIATYPE ncsm;

                        hr = inName.HrGetPseudoMediaTypes(pPropsEx->guidId, &ncm, &ncsm);
                        if (FAILED(hr))
                        {
                            hr = HrGetPseudoMediaTypeFromConnection(pPropsEx->guidId, &ncsm);
                            TraceError("HrGetPseudoMediaTypeFromConnection failed.", hr);
                            hr = S_OK;
                        }
                        
                        pPropsEx->ncSubMediaType = ncsm;
                        if (NCSM_WIRELESS == ncsm)
                        {
                            LANCON_INFO LanConInfo;

                            hr = GetInfo(LCIF_ICON, &LanConInfo);
                            if (NETCFG_S_NOTEXIST == hr)
                            {
                                LanConInfo.fShowIcon = TRUE;
                                hr = SetInfo(LCIF_ICON, &LanConInfo);
                                TraceError("SetInfo", hr);
                                pPropsEx->dwCharacter |= NCCF_SHOW_ICON;
                                hr = S_OK;
                            }
                        }
                    }
                    else
                    {
                        pPropsEx->ncSubMediaType = NCSM_NONE;
                    }
 
                    if (SUCCEEDED(hr))
                    {
                        *ppConnectionPropertiesEx = pPropsEx;
                    }
                }

                FreeNetconProperties(pProps);
            }

            if (FAILED(hr))
            {
                *ppConnectionPropertiesEx = NULL;
                HrFreeNetConProperties2(pPropsEx);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError ("CLanConnection::GetPropertiesEx", hr);
    return hr;
}

HRESULT CLanConnection::HrEnsureValidNlaPolicyEngine()
{
    HRESULT hr = S_FALSE;  // Assume we already have the object
 
    if (!m_pNetMachinePolicies)
    {
        hr = CoCreateInstance(CLSID_NetGroupPolicies, NULL, CLSCTX_INPROC, IID_INetMachinePolicies, reinterpret_cast<void**>(&m_pNetMachinePolicies));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netman\classman\sharedaccess\cmsaclbk.cpp ===
#include "pch.h"
#pragma hdrstop
#include "cmsaclbk.h"
#include "cmsabcon.h"
#include "saconob.h"
#include "ncnetcon.h"

static const LPWSTR g_szWANIPConnectionService = L"urn:schemas-upnp-org:service:WANIPConnection:1";
static const LPWSTR g_szWANPPPConnectionService = L"urn:schemas-upnp-org:service:WANPPPConnection:1";

CSharedAccessDeviceFinderCallback::CSharedAccessDeviceFinderCallback()
{
    m_pSharedAccessBeacon = NULL;
}

HRESULT CSharedAccessDeviceFinderCallback::FinalRelease()
{
    if(NULL != m_pSharedAccessBeacon)
    {
        m_pSharedAccessBeacon->Release();
    }

    return S_OK;
}

HRESULT CSharedAccessDeviceFinderCallback::GetSharedAccessBeacon(BSTR DeviceId, ISharedAccessBeacon** ppSharedAccessBeacon)
{
    HRESULT hr = S_OK;

    *ppSharedAccessBeacon = NULL;
    
    Lock();
    
    if(NULL != m_pSharedAccessBeacon)
    {
        *ppSharedAccessBeacon = m_pSharedAccessBeacon;
        m_pSharedAccessBeacon->AddRef();
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    
    Unlock();

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::DeviceAdded(LONG lFindData, IUPnPDevice* pDevice)
{
    return E_UNEXPECTED;
}

HRESULT CSharedAccessDeviceFinderCallback::DeviceAddedWithInterface(LONG lFindData, IUPnPDevice* pDevice, GUID* pguidInterface)
{
    HRESULT hr = S_OK;

    if(IsEqualGUID(*pguidInterface, IID_NULL))
    {
#ifndef SHOW_SELF
        hr = E_FAIL;
#endif
    }
    
    if(SUCCEEDED(hr))
    {
        ISharedAccessBeacon* pSharedAccessBeacon;
        hr = GetServices(pDevice, pguidInterface, &pSharedAccessBeacon);
        if(SUCCEEDED(hr))
        {
            CComObject<CSharedAccessConnectionEventSink>* pSplitEventSink;
            hr = CComObject<CSharedAccessConnectionEventSink>::CreateInstance(&pSplitEventSink);
            if(SUCCEEDED(hr))
            {
                pSplitEventSink->AddRef();

                NETCON_MEDIATYPE MediaType;
                hr = pSharedAccessBeacon->GetMediaType(&MediaType);
                if(SUCCEEDED(hr))
                {
                    IUPnPService* pWANConnection;
                    hr = pSharedAccessBeacon->GetService(NCM_SHAREDACCESSHOST_LAN == MediaType ? SAHOST_SERVICE_WANIPCONNECTION : SAHOST_SERVICE_WANPPPCONNECTION, &pWANConnection);
                    if(SUCCEEDED(hr))
                    {
                        hr = pWANConnection->AddCallback(pSplitEventSink);
                        pWANConnection->Release();
                    }
                }
                pSplitEventSink->Release();
            }

            if(SUCCEEDED(hr))
            {

                ISharedAccessBeacon* pSharedAccessBeaconToRelease;
                
                Lock();
                
                pSharedAccessBeaconToRelease = m_pSharedAccessBeacon;
                m_pSharedAccessBeacon = pSharedAccessBeacon;
                m_pSharedAccessBeacon->AddRef();
                
                Unlock();

                if(NULL != pSharedAccessBeaconToRelease)
                {
                    pSharedAccessBeaconToRelease->Release();
                }
                
                CComObject<CSharedAccessConnection>* pSharedAccessConnection; // does this need to be under the lock?
                hr = CComObject<CSharedAccessConnection>::CreateInstance(&pSharedAccessConnection);
                if(SUCCEEDED(hr))
                {
                    pSharedAccessConnection->AddRef();
                    
                    INetConnectionRefresh* pNetConnectionRefresh;
                    hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
                    if(SUCCEEDED(hr))
                    {
                        pNetConnectionRefresh->ConnectionDeleted(&CLSID_SharedAccessConnection);
                        pNetConnectionRefresh->ConnectionAdded(pSharedAccessConnection);
                        pNetConnectionRefresh->Release();
                    }
                    
                    pSharedAccessConnection->Release();
                }
            }

            pSharedAccessBeacon->Release();
        }
    }

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::DeviceRemoved(LONG lFindData, BSTR bstrUDN)
{
    HRESULT hr = S_OK;

    ISharedAccessBeacon* pSharedAccessBeaconToRelease = NULL;
    
    Lock();
    
    if(NULL != m_pSharedAccessBeacon)
    {
        BSTR UniqueDeviceName;
        hr = m_pSharedAccessBeacon->GetUniqueDeviceName(&UniqueDeviceName); // only remove the deivce if it matches
        if(SUCCEEDED(hr))
        {
            if(NULL == bstrUDN || 0 == lstrcmp(UniqueDeviceName, bstrUDN))
            {
                pSharedAccessBeaconToRelease = m_pSharedAccessBeacon;
                m_pSharedAccessBeacon = NULL;
            }
            SysFreeString(UniqueDeviceName);
        }
    }
    
    Unlock();

    if(NULL != pSharedAccessBeaconToRelease)
    {
        pSharedAccessBeaconToRelease->Release();
        INetConnectionRefresh* pNetConnectionRefresh;
        hr = CoCreateInstance(CLSID_ConnectionManager, NULL, CLSCTX_SERVER, IID_INetConnectionRefresh, reinterpret_cast<void**>(&pNetConnectionRefresh));
        if(SUCCEEDED(hr))
        {
            pNetConnectionRefresh->ConnectionDeleted(&CLSID_SharedAccessConnection);
            pNetConnectionRefresh->Release();
        }
    }
    

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::SearchComplete(LONG lFindData)
{
    HRESULT hr = S_OK;

    // don't care

    return hr;
}



HRESULT CSharedAccessDeviceFinderCallback::FindChildDevice(IUPnPDevice* pDevice, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;

    IUPnPDevices* pDevices;
    hr = pDevice->get_Children(&pDevices);
    if(SUCCEEDED(hr))
    {
        hr = FindDevice(pDevices, pszDeviceType, ppChildDevice);
        pDevices->Release();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessDeviceFinderCallback::FindChildDevice");

    return hr;
}


HRESULT CSharedAccessDeviceFinderCallback::FindDevice(IUPnPDevices* pDevices, LPWSTR pszDeviceType, IUPnPDevice** ppChildDevice)
{
    HRESULT hr = S_OK;

    *ppChildDevice = NULL;

    IUnknown* pEnumerator;
    hr = pDevices->get__NewEnum(&pEnumerator);

    if (SUCCEEDED(hr))
    {
        IEnumVARIANT* pVariantEnumerator;
        hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
        if (SUCCEEDED(hr))
        {
            VARIANT DeviceVariant;

            VariantInit(&DeviceVariant);

            pVariantEnumerator->Reset();

            // Traverse the collection.

            while (NULL == *ppChildDevice && S_OK == pVariantEnumerator->Next(1, &DeviceVariant, NULL))
            {
                IDispatch   * pDeviceDispatch = NULL;
                IUPnPDevice * pDevice = NULL;

                pDeviceDispatch = V_DISPATCH(&DeviceVariant);
                hr = pDeviceDispatch->QueryInterface(IID_IUPnPDevice, reinterpret_cast<void **>(&pDevice));
                if (SUCCEEDED(hr))
                {
                    BSTR Type;
                    hr = pDevice->get_Type(&Type);
                    if(SUCCEEDED(hr))
                    {
                        if(0 == lstrcmp(Type, pszDeviceType))
                        {
                            *ppChildDevice = pDevice;
                            pDevice->AddRef();

                        }
                        SysFreeString(Type);
                    }
                    pDevice->Release();
                }
                VariantClear(&DeviceVariant);
            };

            if(NULL == *ppChildDevice)
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
            pVariantEnumerator->Release();
        }
        pEnumerator->Release();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessDeviceFinderCallback::FindDevice");

    return hr;


}

HRESULT CSharedAccessDeviceFinderCallback::FindService(IUPnPDevice* pDevice, LPWSTR pszServiceName, IUPnPService** ppICSService)
{
    HRESULT hr;

    *ppICSService = NULL;

    IUPnPServices* pServices;
    hr = pDevice->get_Services(&pServices);
    if (SUCCEEDED(hr))
    {
        IUnknown* pEnumerator;
        hr = pServices->get__NewEnum(&pEnumerator);
        if (SUCCEEDED(hr))
        {
            IEnumVARIANT* pVariantEnumerator;
            hr = pEnumerator->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(&pVariantEnumerator));
            if (SUCCEEDED(hr))
            {
                VARIANT ServiceVariant;

                VariantInit(&ServiceVariant);

                while (NULL == *ppICSService && S_OK == pVariantEnumerator->Next(1, &ServiceVariant, NULL))
                {
                    IDispatch   * pServiceDispatch = NULL;
                    IUPnPService * pService = NULL;

                    pServiceDispatch = V_DISPATCH(&ServiceVariant);
                    hr = pServiceDispatch->QueryInterface(IID_IUPnPService, reinterpret_cast<void **>(&pService));
                    if (SUCCEEDED(hr))
                    {
                        BOOL bMatch;
                        hr = IsServiceMatch(pService, pszServiceName, &bMatch);
                        if(SUCCEEDED(hr) && TRUE == bMatch)
                        {
                            *ppICSService = pService;
                            pService->AddRef();
                        }
                        pService->Release();
                    }
                    VariantClear(&ServiceVariant);
                }
                if(NULL == *ppICSService)
                {
                    hr = E_FAIL;
                }
                pVariantEnumerator->Release();
            }
            pEnumerator->Release();
        }
        pServices->Release();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessDeviceFinderCallback::FindService");

    return hr;
}


HRESULT CSharedAccessDeviceFinderCallback::GetServices(IUPnPDevice* pDevice, GUID* pInterfaceGUID, ISharedAccessBeacon** ppSharedAccessBeacon)
{
    HRESULT hr = S_OK;

    *ppSharedAccessBeacon = NULL;

    CComObject<CSharedAccessBeacon>* pSharedAccessBeacon;
    hr = CComObject<CSharedAccessBeacon>::CreateInstance(&pSharedAccessBeacon);
    if(SUCCEEDED(hr))
    {
        pSharedAccessBeacon->AddRef();

        BSTR pUniqueDeviceName;
        hr = pDevice->get_UniqueDeviceName(&pUniqueDeviceName);
        if(SUCCEEDED(hr))
        {
            hr = pSharedAccessBeacon->SetUniqueDeviceName(pUniqueDeviceName);
            SysFreeString(pUniqueDeviceName);
        }
        
        if(SUCCEEDED(hr))
        {
        
            pSharedAccessBeacon->SetLocalAdapterGUID(pInterfaceGUID);
            
            IUPnPService* pOSInfoService;
            hr = FindService(pDevice, L"urn:schemas-microsoft-com:service:OSInfo:1", &pOSInfoService); // this service is not required
            if(SUCCEEDED(hr))
            {
                pSharedAccessBeacon->SetService(SAHOST_SERVICE_OSINFO, pOSInfoService);
                pOSInfoService->Release();
            }
            
            IUPnPDevice* pWANDevice;
            hr = FindChildDevice(pDevice, L"urn:schemas-upnp-org:device:WANDevice:1", &pWANDevice);
            if(SUCCEEDED(hr))
            {
                
                IUPnPService* pWANCommonInterfaceConfigService;
                hr = FindService(pWANDevice, L"urn:schemas-upnp-org:service:WANCommonInterfaceConfig:1", &pWANCommonInterfaceConfigService);
                if(SUCCEEDED(hr))
                {
                    pSharedAccessBeacon->SetService(SAHOST_SERVICE_WANCOMMONINTERFACECONFIG, pWANCommonInterfaceConfigService);
                    
                    IUPnPDevice* pWANCommonDevice;
                    hr = FindChildDevice(pWANDevice, L"urn:schemas-upnp-org:device:WANConnectionDevice:1", &pWANCommonDevice);
                    if(SUCCEEDED(hr))
                    {
                        IUPnPService* pWANConnectionService;
                        hr = FindService(pWANCommonDevice, NULL, &pWANConnectionService);
                        if(SUCCEEDED(hr))
                        {
                            BSTR ServiceType;
                            hr = pWANConnectionService->get_ServiceTypeIdentifier(&ServiceType);
                            if(SUCCEEDED(hr))
                            {
                                if(0 == wcscmp(ServiceType, g_szWANPPPConnectionService))
                                {
                                    pSharedAccessBeacon->SetMediaType(NCM_SHAREDACCESSHOST_RAS);
                                    pSharedAccessBeacon->SetService(SAHOST_SERVICE_WANPPPCONNECTION, pWANConnectionService);
                                }
                                else // we can assume this is WANIPConnectionService
                                {
                                    pSharedAccessBeacon->SetMediaType(NCM_SHAREDACCESSHOST_LAN);
                                    pSharedAccessBeacon->SetService(SAHOST_SERVICE_WANIPCONNECTION, pWANConnectionService);
                                }
                                
                                SysFreeString(ServiceType);
                            }
                            pWANConnectionService->Release();
                        }
                        pWANCommonDevice->Release();
                    }
                    pWANCommonInterfaceConfigService->Release();
                }
                pWANDevice->Release();
            }
        }
        if(SUCCEEDED(hr))
        {
            *ppSharedAccessBeacon = static_cast<ISharedAccessBeacon*>(pSharedAccessBeacon);
            (*ppSharedAccessBeacon)->AddRef();
        }
        pSharedAccessBeacon->Release();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessDeviceFinderCallback::GetServices");

    return hr;
}

HRESULT CSharedAccessDeviceFinderCallback::IsServiceMatch(IUPnPService* pService, BSTR SearchCriteria, BOOL* pbMatch)
{
    HRESULT hr = 