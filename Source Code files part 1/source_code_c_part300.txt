ne Description :

    Private routine for computing the memory size required for a pointer to
    anything.  This is the entry point for pointers embedded in structures
    arrays, or unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to stub message.
    pBufferMark - Location in the buffer where a unique or full pointer's id is.
                  Unused for ref pointers.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar   uFlagsSave;
    ulong   MemSize;

    switch ( *pFormat )
        {
        case FC_RP :
            break;

        case FC_UP :
        case FC_OP :
            if ( ! *((long *)pBufferMark) )
                return pStubMsg->MemorySize;
            break;

        case FC_IP:
            if ( IS_BROKEN_INTERFACE_POINTER(pStubMsg->uFlags) )
                {
                // In this case, the whole pointer and pointee are
                // where the pointee should have been.
                // (Treat like toplevel at this point )
                NdrInterfacePointerMemorySize( pStubMsg,
                                               pFormat );
                }
            else
                {
                if ( ! *((long *)pBufferMark) )
                    return pStubMsg->MemorySize;
                NdrpInterfacePointerMemorySize( pStubMsg,
                                                pFormat );                
                }
            return pStubMsg->MemorySize;

        case FC_FP :
            //
            // Check if we've already mem sized this full pointer.
            //
            if ( NdrFullPointerQueryRefId( pStubMsg->FullPtrXlatTables,
                                           *((ulong *)pBufferMark),
                                           FULL_POINTER_MEM_SIZED,
                                           0 ) )
                return pStubMsg->MemorySize;

            break;

        default :
            NDR_ASSERT(0,"NdrpPointerMemorySize : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    //
    // We align all memory pointers on at least a void * boundary.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );

    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        // Pointer to complex type.

        if ( POINTER_DEREF(pFormat[1]) )
            pStubMsg->MemorySize += PTR_MEM_SIZE;

        pFormat += 2;

        pFormat += *((signed short *)pFormat);
        }
    else
        {
        switch ( pFormat[2] )
            {
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :
                // Increment to string's description.
                pFormat += 2;
                break;

            default :
                // Simple type.

                ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(pFormat[2]));
                pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( pFormat[2] );

                switch ( pFormat[2] )
                    {
                    case FC_ENUM16 :
                        //
                        // We can't use the simple type tables for enum16.
                        //
                        LENGTH_ALIGN( pStubMsg->MemorySize, sizeof(int) - 1 );
                        pStubMsg->MemorySize += sizeof(int);
                        break;

                    default :
                        LENGTH_ALIGN( pStubMsg->MemorySize,
                                      SIMPLE_TYPE_ALIGNMENT(pFormat[2]) );
                        pStubMsg->MemorySize += SIMPLE_TYPE_MEMSIZE(pFormat[2]);
                        break;
                    }

                return pStubMsg->MemorySize;
            }
        }

    uFlagsSave = pStubMsg->uFlags;
    RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    MemSize = (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)])
                    ( pStubMsg,
                      pFormat );

    pStubMsg->uFlags = uFlagsSave;

    return MemSize;
}

NDR_MEMSIZE_POINTER_QUEUE_ELEMENT::NDR_MEMSIZE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg,
    uchar             *pBufferMarkNew,
    PFORMAT_STRING     pFormatNew ) :

        pFormat(pFormatNew),
        pBufferMark(pBufferMarkNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags) 
{

}

void 
NDR_MEMSIZE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0!\n");
    NDR_ASSERT( !pStubMsg->PointerLength, "PointerLength is not 0!\n");

    NdrpPointerMemorySizeInternal( pStubMsg,
                                   pBufferMark,
                                   pFormat );

}

#if defined(DBG)
void 
NDR_MEMSIZE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pBufferMark:             %p\n", pBufferMark );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );
}
#endif

void
NdrpEnquePointerMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pBufferMark,
    PFORMAT_STRING     pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {

        NDR_MEMSIZE_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_MEMSIZE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                  pBufferMark,
                                                  pFormat );
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally
}

unsigned long
NdrpPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    PFORMAT_STRING      pFormat )
{
    
    if ( !NdrIsLowStack(pStubMsg) )
        {
        return
        NdrpPointerMemorySizeInternal( pStubMsg,
                                       pBufferMark,
                                       pFormat );      
        }
    
    NdrpEnquePointerMemorySize(
        pStubMsg,
        pBufferMark,
        pFormat );

    return 0;
}


unsigned long RPC_ENTRY
NdrSimpleStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Structure's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   Size;

    Size = *((ushort *)(pFormat + 2));

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , Size );
    pStubMsg->Buffer += Size;

    pStubMsg->MemorySize += Size;

    if ( *pFormat == FC_PSTRUCT )
        {
        // Mark where the structure starts in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat + 4 );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a conformant structure.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    PFORMAT_STRING  pFormatArray;
    ulong           Size;
    uchar           Alignment = pFormat[1];
    // set by the outermost embedding complex struct
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    Size = *((ushort *)(pFormat + 2));

    // Get the conformance count.
    if ( fIsEmbeddedStruct )
        {
        // A bogus struct would set the mark.
        pStubMsg->MaxCount = *((long *)pStubMsg->BufferMark);
        }
    else
        {
        // Align for the conformance count.
        ALIGN(pStubMsg->Buffer,0x3);
        pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;
        }

    // Increment the format string to the offset to array description.
    pFormat += 4;

    // Get the array's description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    // Check bounds.
    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormatArray[4] & 0x0f );

    // check for possible mulitplication overflow attack here.
    Size += MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount, *((ushort *)(pFormatArray + 2) ) );
    
    // Increment the format string past the offset to array description.
    pFormat += 2;

    // Realign for struct 
    ALIGN(pStubMsg->Buffer, Alignment);

    LENGTH_ALIGN( pStubMsg->MemorySize, Alignment );
    
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, Size );
    pStubMsg->Buffer += Size;
    pStubMsg->MemorySize += Size;

    if ( *pFormat == FC_PP )
        {
        // Mark the beginning of the struct in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantVaryingStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a conformant varying structure.

    Used for FC_CVSTRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    PFORMAT_STRING  pFormatArray;
    uchar *         pBufferMark;
    ulong           Size;
    // set by the outermost embedding complex struct
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    Size = *((ushort *)(pFormat + 2));

    // Get the conformance count.
    if ( fIsEmbeddedStruct )
        {
        pStubMsg->MaxCount = *((long *&)pStubMsg->BufferMark);
        }
    else
        {
        ALIGN(pStubMsg->Buffer,0x3);
        pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;
        }

    ALIGN(pStubMsg->Buffer,pFormat[1]);
    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    // Remember the start of the struct in the buffer.
    pBufferMark = pStubMsg->Buffer;

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , Size );
    pStubMsg->Buffer += Size;
 
    pStubMsg->MemorySize += Size;

    pFormat += 4;

    // Get array's format string description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    // We always marshal the array, the outer struct will watch for the done flag.

    if ( *pFormatArray == FC_CVARRAY )
        {
        NdrpConformantVaryingArrayMemorySize( pStubMsg,
                                              pFormatArray );
        }
    else
        {
        NdrpConformantStringMemorySize( pStubMsg,
                                        pFormatArray );
        }

    pFormat += 2;

    if ( *pFormat == FC_PP )
        {
        // Mark the start of the structure in the buffer.
        pStubMsg->Buffer = pBufferMark;
    
        pStubMsg->MaxCount = pStubMsg->ActualCount;
        
        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return pStubMsg->MemorySize;
}


#if 0
unsigned long RPC_ENTRY
NdrHardStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a hard structure.

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ushort      CopySize;

    LENGTH_ALIGN(pStubMsg->MemorySize,pFormat[1]);

    pStubMsg->MemorySize += *((ushort *)&pFormat[2]);

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    CopySize = *((ushort *)&pFormat[10]);

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CopySize );
    pStubMsg->Buffer += CopySize;

    if ( *((short *)&pFormat[14]) )
        {
        pFormat += 14;
        pFormat += *((short *)pFormat);

        (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                        pFormat );
        }

    return pStubMsg->MemorySize;
}
#endif // 0


unsigned long RPC_ENTRY
NdrComplexStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

Notes:
    This routine can calculate the memory size with or without pointees.
    When calculating size with pointees at the top level, the routine calls
    itself recursively to find out where pointees would be and then remember
    the context using pStubMsg->MemorySize and pStubMsg->PointerBufferMark.

--*/
{
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatComplex;
    long            Alignment;
    BOOL            fSetPointerBufferMark;

    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    BOOL            fEmbedConfStructContext;

    //
    // This is fun.  If we're not ignoring embedded pointers and this structure
    // is not embedded inside of another struct or array then we make a
    // recursive call to get a pointer to where the flat part of the structure
    // ends in the buffer.  Then we can properly get to any embedded pointer's
    // pointees.
    //
    if ( fSetPointerBufferMark =
         (! pStubMsg->IgnoreEmbeddedPointers && ! pStubMsg->PointerBufferMark) )
        {
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // This gets clobbered.
        uchar * BufferSave = pStubMsg->Buffer;
        ulong MemorySizeSave = pStubMsg->MemorySize;

        //
        // Get a buffer pointer to where the struct's pointees are.
        //
        (void) NdrComplexStructMemorySize( pStubMsg,
                                           pFormat );


        // Mark where the pointees begin.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->PointerLength     = pStubMsg->MemorySize;

        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        
        pStubMsg->MemorySize = MemorySizeSave;
        pStubMsg->Buffer = BufferSave;
        }

    Alignment = pFormat[1];

    pFormat += 4;

    fEmbedConfStructContext = fIsEmbeddedStruct;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        {
        ulong ConformanceSize;

        pFormatArray = pFormat + *((signed short *)pFormat);

        if ( FixWireRepForDComVerGTE54( pStubMsg ) )
            fEmbedConfStructContext = TRUE;

        if ( !fIsEmbeddedStruct )
            {
            ALIGN(pStubMsg->Buffer,3);

            // conformance count marker
            pStubMsg->BufferMark = pStubMsg->Buffer;

            // Handle multidimensional arrays.
            ConformanceSize = NdrpArrayDimensions( pStubMsg, pFormatArray, FALSE ) * 4;
  
            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , ConformanceSize );
            pStubMsg->Buffer += ConformanceSize;
            }
        }
    else
        {
        pFormatArray = 0;
        }

    // BufferMark may be set by an outer bogus struct.
    pBufferMark = pStubMsg->BufferMark;
    RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Size the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // Simple types.
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
            case FC_IGNORE :
                ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(*pFormat));

                pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( *pFormat );

                pStubMsg->MemorySize += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_POINTER :
                {
                ALIGN(pStubMsg->Buffer,0x3);
                uchar *pPointerId = pStubMsg->Buffer;
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                
                if ( ! pStubMsg->IgnoreEmbeddedPointers )
                    {
                    POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );
                    NdrpPointerMemorySize( pStubMsg,
                                           pPointerId,
                                           pFormatPointers );

                    }

                //
                // We actually do a post alignment of the memory size.
                // Do this to prevent some under-allocations when pointers
                // to strings, or char or short are involved.
                //
                LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );

                pStubMsg->MemorySize += PTR_MEM_SIZE;
                pFormatPointers += 4;
                }

                break;

            //
            // Embedded complex types.
            //
            case FC_EMBEDDED_COMPLEX :
                // Add padding.
                pStubMsg->MemorySize += pFormat[1];

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( FC_IP == *pFormatComplex ) 
                    {
                    ALIGN(pStubMsg->Buffer,0x3);
                    uchar *pPointerId = pStubMsg->Buffer;
                    pStubMsg->Buffer += PTR_WIRE_SIZE;
                
                    if ( ! pStubMsg->IgnoreEmbeddedPointers )
                        {
                        POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );
                        NdrpPointerMemorySize( pStubMsg,
                                               pPointerId,
                                               pFormatComplex );

                        }

                    pStubMsg->MemorySize += PTR_MEM_SIZE;
                    pFormat++;
                    break;

                    }

                // Needed for embedded conf structs
                //
                pStubMsg->BufferMark = pBufferMark;
                if ( fEmbedConfStructContext )
                    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                (void) (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                       ( pStubMsg,
                         pFormatComplex );

                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
                //
                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                //
                pFormat++;

                break;

            case FC_ALIGNM2 :
                LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
                break;

            case FC_ALIGNM4 :
                LENGTH_ALIGN( pStubMsg->MemorySize, 0x3 );
                break;

            case FC_ALIGNM8 :
                LENGTH_ALIGN( pStubMsg->MemorySize, 0x7 );
                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                pStubMsg->MemorySize += (*pFormat - FC_STRUCTPAD1) + 1;
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pStubMsg->MemorySize += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;

            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                goto ComplexMemorySizeEnd;

            default :
                NDR_ASSERT(0,"NdrComplexStructMemorySize : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            }
        }

ComplexMemorySizeEnd :

    if ( pFormatArray && !fIsEmbeddedStruct  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PPRIVATE_MEM_SIZE_ROUTINE   pfnMemSize;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnMemSize = NdrpConformantArrayMemorySize;
                break;

            case FC_CVARRAY :
                pfnMemSize = NdrpConformantVaryingArrayMemorySize;
                break;

            case FC_BOGUS_ARRAY :
                pfnMemSize = NdrpComplexArrayMemorySize;
                break;

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_WSTRING :
            // case FC_C_SSTRING :

            default :
                pfnMemSize = NdrpConformantStringMemorySize;
                break;
            }

        // Set the max count for non-complex conformant arrays.
        pStubMsg->MaxCount = *((ulong *)pBufferMark);

        // Mark where conformance count(s) are.
        pStubMsg->BufferMark = pBufferMark;

        (void) (*pfnMemSize)( pStubMsg,
                              pFormatArray );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer            = pStubMsg->PointerBufferMark;
        pStubMsg->MemorySize        = pStubMsg->PointerLength; 
        pStubMsg->PointerBufferMark = 0;
        pStubMsg->PointerLength     = 0;
        }

    if ( fIsEmbeddedStruct )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrFixedArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a fixed array of any number of dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   Size;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    if ( *pFormat == FC_SMFARRAY )
        {
        pFormat += 2;
        Size = *((ushort *&)pFormat)++;
        }
    else
        {
        pFormat += 2;
        Size = *((ulong UNALIGNED *&)pFormat)++;
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , Size );
    pStubMsg->Buffer += Size;

    pStubMsg->MemorySize += Size;

    if ( *pFormat == FC_PP )
        {
        // Mark the location in the buffer where the array starts.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a top level one dimensional conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    //
    // Get the conformance count.
    //
    ALIGN(pStubMsg->Buffer,0x3);

    pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;

    return NdrpConformantArrayMemorySize( pStubMsg,
                                          pFormat );
}


unsigned long
NdrpConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the memory size of a one dimensional
    conformant array.  This is the entry point for an embedded conformant
    array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   Size;

    if ( ! pStubMsg->MaxCount )
        return pStubMsg->MemorySize;

    // Check bounds.
    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormat[4] & 0x0f );

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    // Increment to element size.
    pFormat += 2;

    // Compute array size.
    // check for possible mulitplication overflow attack here.
    Size = MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount, *((ushort *)pFormat) );

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, Size );
    pStubMsg->Buffer += Size;             

    pStubMsg->MemorySize += Size;

    if ( *pFormat == FC_PP )
        {
        // Mark the location in the buffer where the array starts.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a one dimensional top level conformant
    varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    //
    // Get the conformance count.
    //
    ALIGN(pStubMsg->Buffer,0x3);

    pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;

    return NdrpConformantVaryingArrayMemorySize( pStubMsg,
                                                 pFormat );
}


unsigned long
NdrpConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the memory size of a one dimensional
    conformant varying array.  This is the entry point for memory sizing an
    embedded conformant varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong           BufferSize;
    PFORMAT_STRING  pFormatVar;
    
    //
    // Get the offset and actual count in case needed for pointer sizing.
    //
    ALIGN(pStubMsg->Buffer,0x3);

    pStubMsg->Offset = *((long *&)pStubMsg->Buffer)++;
    pStubMsg->ActualCount = *((long *&)pStubMsg->Buffer)++;

    // Check bounds.
    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormat[4] & 0x0f );

    pFormatVar = pFormat + 8;
    CORRELATION_DESC_INCREMENT( pFormatVar );
    CHECK_BOUND( pStubMsg->ActualCount, *pFormatVar & 0x0f );

    if ( (pStubMsg->MaxCount < (pStubMsg->Offset + pStubMsg->ActualCount)) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    //
    // Do the memory size increment now in case the actual count is 0.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, pFormat[1] );

    // check for possible mulitplication overflow attack here.
    pStubMsg->MemorySize += MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount,  *((ushort *)(pFormat + 2)) );

    if ( ! pStubMsg->ActualCount )
        return pStubMsg->MemorySize;

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    // Increment to element size.
    pFormat += 2;

    BufferSize = pStubMsg->ActualCount * *((ushort *)pFormat);

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer += BufferSize;

    pFormat += 10;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        {
        // Mark the location in the buffer where the array starts.
        pStubMsg->BufferMark = pStubMsg->Buffer - BufferSize;

        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a top level or embedded varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   MemorySize;
    ulong   BufferSize;
    uchar   Alignment;
    long    Elements;

    //
    // Get the offset and actual count.
    //
    ALIGN(pStubMsg->Buffer,0x3);

    pStubMsg->Offset = *((long *&)pStubMsg->Buffer)++;
    pStubMsg->ActualCount = *((long *&)pStubMsg->Buffer)++;

    // Check bounds using the old part of correlation descr.
    CHECK_BOUND( pStubMsg->ActualCount,
                 pFormat[(*pFormat == FC_SMVARRAY) ? 8 : 12] & 0x0f );

    Elements =
        (*pFormat == FC_SMVARRAY) ?
        *((ushort *)(pFormat + 4)) : *((ulong UNALIGNED *)(pFormat + 6));

    if ( (((long)pStubMsg->Offset) < 0) ||
         (Elements < (long)(pStubMsg->ActualCount + pStubMsg->Offset)) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    Alignment = pFormat[1];

    if ( *pFormat == FC_SMVARRAY )
        {
        pFormat += 2;
        MemorySize = (ulong) *((ushort *)pFormat);
        
        pFormat += 4;
        }
    else
        {
        pFormat += 2;
        MemorySize = *((ulong UNALIGNED *)pFormat);
    
        pFormat += 8;
        }

    //
    // Do the memory size increment now in case the actual count is 0 and
    // we have return.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, Alignment );

    pStubMsg->MemorySize += MemorySize;

    if ( ! pStubMsg->ActualCount )
        return pStubMsg->MemorySize;

    ALIGN(pStubMsg->Buffer, Alignment);

    // check for possible mulitplication overflow attack here.
    BufferSize = MultiplyWithOverflowCheck( pStubMsg->ActualCount , *((ushort *)pFormat) );
   
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer += BufferSize;

    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( *pFormat == FC_PP )
        {
        // Mark the start of the array in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - BufferSize;

        pStubMsg->MaxCount = pStubMsg->ActualCount;

        NdrpEmbeddedPointerMemorySize( pStubMsg,
                                       pFormat );
        }

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    BOOL            fSetPointerBufferMark;
    PFORMAT_STRING  pFormatPP;

    //
    // We set this if we're doing a real 'all nodes' sizing, this array
    // is not embedded in another structure or array, and this is not an
    // array of ref pointers.
    //
    pFormatPP = pFormat + 12;
    CORRELATION_DESC_INCREMENT( pFormatPP );
    CORRELATION_DESC_INCREMENT( pFormatPP );

    fSetPointerBufferMark = ! pStubMsg->IgnoreEmbeddedPointers &&
                            ! pStubMsg->PointerBufferMark &&
                            *pFormatPP != FC_RP;

    //
    // More fun.  Make a recursive call so that we have a pointer to the end
    // of the array's flat stuff in the buffer.  Then we can properly get to
    // any embedded pointer members.  We have no way of knowing if there are
    // any embedded pointers so we're stuck doing this all the time.
    //
    if ( fSetPointerBufferMark )
        {
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // Save this since it gets clobbered.
        ulong MemorySizeSave = pStubMsg->MemorySize;
        uchar* pBufferSave = pStubMsg->Buffer;

        //
        // Get a buffer pointer to where the array's pointees are.
        //
        (void) NdrComplexArrayMemorySize( pStubMsg,
                                          pFormat );


        // This is where the array pointees start.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->PointerLength     = pStubMsg->MemorySize;
        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        
        pStubMsg->MemorySize = MemorySizeSave;
        pStubMsg->Buffer = pBufferSave;
        }

    if ( ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff ) &&
         ( pStubMsg->pArrayInfo == 0 ) )
        {
        //
        // The outer most array dimension sets the conformance marker.
        //
        
        ALIGN(pStubMsg->Buffer,0x3);

        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment past conformance count(s).
        pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormat, FALSE ) * 4;

        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

        }

    (void) NdrpComplexArrayMemorySize( pStubMsg,
                                       pFormat );

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer            = pStubMsg->PointerBufferMark;
        pStubMsg->MemorySize        = pStubMsg->PointerLength;
        pStubMsg->PointerLength     = 0;
        pStubMsg->PointerBufferMark = 0;
        }

    return pStubMsg->MemorySize;
}


unsigned long
NdrpComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for computing the memory size of a complex array.  This
    is the entry point for memory sizing an embedded complex array.

    Used for FC_BOGUS_ARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO         pArrayInfo;
    PMEM_SIZE_ROUTINE   pfnMemSize;
    uchar *             pBufferSave;
    PFORMAT_STRING      pFormatSave;
    ulong               Elements;
    ulong               Count, CountSave;
    long                Dimension;
    uchar               Alignment;
    uchar *             pPointerIdMark;

    bool                IsBrokenInterfacePointerFormat = false;
    //
    // Setup if we are the outer dimension.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        NdrpInitArrayInfo(pStubMsg, &ArrayInfo);
        }

    // Used for array of ref pointers only.
    pBufferSave = 0;

    pFormatSave = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    // Get the array alignment.
    Alignment = pFormat[1];

    pFormat += 2;

    // Get number of elements (0 if conformance present).
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = pArrayInfo->BufferConformanceMark[Dimension];

        // Check bounds
        CHECK_BOUND( Elements, *pFormat & 0x0f );
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        long    Offset;

        if ( Dimension == 0 )
            {
            ulong   VarianceSize;

            ALIGN(pStubMsg->Buffer,0x3);

            // Mark where the variance counts are.
            pArrayInfo->BufferVarianceMark = (unsigned long *)pStubMsg->Buffer;

            // Handle multidimensional arrays.
            VarianceSize = NdrpArrayDimensions( pStubMsg, pFormatSave, TRUE ) * 8;

            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , VarianceSize );
            pStubMsg->Buffer += VarianceSize;
            }

        Count = pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1];

        // Check bounds
        CHECK_BOUND( Count, *pFormat & 0x0f );

        Offset = pArrayInfo->BufferVarianceMark[(Dimension * 2)];

        if ( (Offset < 0) || (Elements < (Offset + Count)) )
            RpcRaiseException( RPC_X_INVALID_BOUND );
        }
    else
        {
        Count = Elements;
        }

    CountSave = Count;

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Only align the buffer if at least one element was shipped.
    //
    if ( Count )
        ALIGN(pStubMsg->Buffer,Alignment);

    pPointerIdMark = 0;

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            pfnMemSize = pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)];
            
            if ( FC_IP == *pFormat ) goto HandleInterfacePointer;
            break;

        case FC_IP :
HandleInterfacePointer:
            IsBrokenInterfacePointerFormat = !FixWireRepForDComVerGTE54( pStubMsg );
            pPointerIdMark = pStubMsg->Buffer;

            // Do not leave any space for the pointer if this is
            // the broken format.  But do position the pointee as if the
            // pointer was transmitted.
            if ( pStubMsg->IgnoreEmbeddedPointers ||
                 !IsBrokenInterfacePointerFormat )
                {
                ulong uWireSize = MultiplyWithOverflowCheck( Count , PTR_WIRE_SIZE );
                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, uWireSize );
                pStubMsg->Buffer += uWireSize;
                }
            goto HandleRefPointer;

        case FC_UP :
        case FC_FP :
        case FC_OP :
            pPointerIdMark = pStubMsg->Buffer;

            {
            ulong uWireSize = MultiplyWithOverflowCheck( Count , PTR_WIRE_SIZE );
            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, uWireSize);
            pStubMsg->Buffer += uWireSize;
            }
            // Fall through
        case FC_RP :
HandleRefPointer:
            //
            // Add in the size of the array explicitly.
            //
                {
                LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );
                ulong uSize = MultiplyWithOverflowCheck( Elements, PTR_MEM_SIZE );
                if ( pStubMsg->MemorySize + uSize < pStubMsg->MemorySize )
                    RpcRaiseException ( RPC_X_BAD_STUB_DATA );
                pStubMsg->MemorySize += uSize;
                }
            
            if ( pStubMsg->IgnoreEmbeddedPointers )
                goto ComplexArrayMemSizeEnd;

            pfnMemSize = (PMEM_SIZE_ROUTINE) NdrpPointerMemorySize; 
            break;

        case FC_RANGE:
                {
                ulong uWireSize ;
            LENGTH_ALIGN( pStubMsg->MemorySize, SIMPLE_TYPE_ALIGNMENT( pFormat[1] ) );
            ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( pFormat[1] ) );

            uWireSize = MultiplyWithOverflowCheck( Count, SIMPLE_TYPE_BUFSIZE( pFormat[1] ) );
            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, uWireSize );
            pStubMsg->Buffer +=  uWireSize;
            // SIMPLE_TYPE_BUFSIZE == SIMPLE_TYPE_MEMSIZE except in enum case, which is not allowed in range
            pStubMsg->MemorySize += MultiplyWithOverflowCheck( Elements, SIMPLE_TYPE_MEMSIZE( pFormat[1] ) );
            goto ComplexArrayMemSizeEnd;
            break;
            }
        default :
            {
            ulong ByteCount;

            NDR_ASSERT( IS_SIMPLE_TYPE(*pFormat),
                        "NdrpComplexArrayMemorySize : bad format char" );

            ByteCount = MultiplyWithOverflowCheck( Count , SIMPLE_TYPE_BUFSIZE(*pFormat) );

            CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, ByteCount );
            pStubMsg->Buffer += ByteCount;

            if ( *pFormat == FC_ENUM16 )
                LENGTH_ALIGN( pStubMsg->MemorySize, sizeof(int) - 1 );
            else
                LENGTH_ALIGN( pStubMsg->MemorySize,
                              SIMPLE_TYPE_ALIGNMENT(*pFormat) );

            pStubMsg->MemorySize += MultiplyWithOverflowCheck( Elements, SIMPLE_TYPE_MEMSIZE( * pFormat ) );

            goto ComplexArrayMemSizeEnd;
            }
        }

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        pStubMsg->pArrayInfo = 0;

    if ( pfnMemSize == (PMEM_SIZE_ROUTINE) NdrpPointerMemorySize )
        {

        // If the broken format is used, the pointer and pointee
        // are where the pointee should have been.
        if (IsBrokenInterfacePointerFormat)
            SET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

        POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );
        
        for ( ;  Count--;  pPointerIdMark += PTR_WIRE_SIZE )
            {
            NdrpPointerMemorySize( 
                pStubMsg,
                pPointerIdMark,
                pFormat );
            }

        if (IsBrokenInterfacePointerFormat)
            RESET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

        }
    else
        {
        for ( ; Count--; )
            {
            // Keep track of multidimensional array dimension.
            if ( IS_ARRAY_OR_STRING(*pFormat) )
                pArrayInfo->Dimension = Dimension + 1;

            (*pfnMemSize)( pStubMsg,
                           pFormat );

            }
        }

    if ( pBufferSave )
        {
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer = pBufferSave;
        }

    //
    // If we had variance then we have to make sure and add in the node size
    // of any members that were not shipped.
    //
    if ( (CountSave < Elements) && (*pFormat != FC_RP) )
        {
        long    ElementSize;

        pArrayInfo->Dimension = Dimension + 1;
        pArrayInfo->MaxCountArray = pArrayInfo->BufferConformanceMark;

        pStubMsg->pArrayInfo = pArrayInfo;

        ElementSize = (long)( NdrpMemoryIncrement( pStubMsg,
                                                   0,
                                                   pFormat ) - (uchar*)0 );

        pArrayInfo->MaxCountArray = 0;

        //
        // We don't have the memory alignment anywhere, so align the memory
        // size to 8.  At worse we'll allocate a few extra bytes.
        //
        LENGTH_ALIGN(pStubMsg->MemorySize,0x7);
        pStubMsg->MemorySize += MultiplyWithOverflowCheck( (Elements - CountSave) , ElementSize );
        }

ComplexArrayMemSizeEnd:

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrNonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a non conformant string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, and FC_BSTRING (NT Beta2
    compatability only).

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   BufferSize;
    ulong   MemorySize;

    ALIGN(pStubMsg->Buffer,0x3);

    // Skip the offset.
    pStubMsg->Buffer += 4;

    BufferSize = *((long *&)pStubMsg->Buffer)++;

    MemorySize = *((ushort *)(pFormat + 2));

    if ( MemorySize < BufferSize )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    switch ( *pFormat )
        {
        case FC_WSTRING :
            // Buffer is already aligned on a 4 byte boundary.

            // Align memory just in case.
            LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
            MemorySize = MultiplyWithOverflowCheck( MemorySize, sizeof(wchar_t) );
            BufferSize = MultiplyWithOverflowCheck( BufferSize, sizeof(wchar_t) );
            break;
        case FC_SSTRING :
            MemorySize = MultiplyWithOverflowCheck( MemorySize, pFormat[1] );
            BufferSize = MultiplyWithOverflowCheck ( BufferSize, pFormat[1] );
            break;
        default :
            break;
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer += BufferSize;
    pStubMsg->MemorySize += MemorySize;

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    //
    // Get string size.
    //

    if ( pStubMsg->pArrayInfo != 0 )
        {
        //
        // If this is part of a multidimensional array then we get the location
        // where the conformance is from a special place.
        //
        pStubMsg->MaxCount =
            pStubMsg->pArrayInfo->
                      BufferConformanceMark[pStubMsg->pArrayInfo->Dimension];
        }
    else
        {
        ALIGN(pStubMsg->Buffer,0x3);

        pStubMsg->MaxCount = *((long *&)pStubMsg->Buffer)++;
        }

    return NdrpConformantStringMemorySize( pStubMsg,
                                           pFormat );
}


unsigned long
NdrpConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for determing the memory size of a conformant string.
    This is the entry point for an embedded conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    ulong   MemorySize;
    ulong   BufferSize;

    ALIGN(pStubMsg->Buffer,3);

    // Skip the offset.
    pStubMsg->Buffer += 4;

    BufferSize = *((long *&)pStubMsg->Buffer)++;

    MemorySize = (ulong)pStubMsg->MaxCount;

    // Check bounds.

    if ( (*pFormat != FC_C_SSTRING) && (pFormat[1] == FC_STRING_SIZED) )
        CHECK_BOUND( MemorySize, pFormat[2] & 0xf);

    //
    // Make sure the offset is 0 and the memory size is at least as
    // large as the buffer size.
    //
    if ( *((long *)(pStubMsg->Buffer - 8)) != 0 || 
         (MemorySize < BufferSize) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    switch ( *pFormat )
        {
        case FC_C_WSTRING :
            // Buffer is already aligned on a 4 byte boundary.

            // Align memory just in case.
            LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
            MemorySize = MultiplyWithOverflowCheck( MemorySize, sizeof(wchar_t) );
            BufferSize = MultiplyWithOverflowCheck( BufferSize, sizeof(wchar_t) );
            break;

        case FC_C_SSTRING :
            MemorySize = MultiplyWithOverflowCheck( MemorySize, pFormat[1] );
            BufferSize = MultiplyWithOverflowCheck( BufferSize, pFormat[1] );
            break;
        default :
            break;
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer += BufferSize;

    pStubMsg->MemorySize += MemorySize;

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of an encapsulated union.

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar   SwitchType;

    SwitchType = LOW_NIBBLE(pFormat[1]);

    //
    // No alignment needed.  Add number of bytes to the union.
    //
    pStubMsg->MemorySize += HIGH_NIBBLE(pFormat[1]);

    NO_CORRELATION;

    return NdrpUnionMemorySize( pStubMsg,
                                pFormat + 2,
                                SwitchType );
}


unsigned long RPC_ENTRY
NdrNonEncapsulatedUnionMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size of a non-encapsulated union.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar    SwitchType;

    SwitchType = pFormat[1];

    //
    // Set the format string to the memory size and arm description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    return NdrpUnionMemorySize( pStubMsg,
                                pFormat,
                                SwitchType );
}


unsigned long
NdrpUnionMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               SwitchType )
/*++

Routine Description :

    Private routine for computing the memory size needed for a union.  This
    routine is used for sizing both encapsulated and non-encapsulated unions.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.
    SwitchType  - Union's switch type.

Return :

    The computed memory size.

--*/
{
    long        UnionSize;
    long        SwitchIs;
    long        Arms;
    uchar       Alignment;

    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *&)pStubMsg->Buffer)++;
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *&)pStubMsg->Buffer)++;
            break;
        case FC_SHORT :
        case FC_ENUM16 :
            ALIGN(pStubMsg->Buffer,0x1);
            SwitchIs = (long) *((short *&)pStubMsg->Buffer)++;
            break;
        case FC_USHORT :
        case FC_WCHAR :
            ALIGN(pStubMsg->Buffer,0x1);
            SwitchIs = (long) *((ushort *&)pStubMsg->Buffer)++;
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG
            ALIGN(pStubMsg->Buffer,0x3);
            SwitchIs = *((long *&)pStubMsg->Buffer)++;
            break;
        default :
            NDR_ASSERT(0,"NdrpUnionMemorySize : bad switch type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    //
    // Get the max flat union memory size.
    //
    UnionSize = *((ushort *&)pFormat)++;

    //
    // We're at the union_arms<2> field now, which contains both the
    // Microsoft union aligment value and the number of union arms.
    //

    //
    // Get the union alignment (0 if this is a DCE union).
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    ALIGN(pStubMsg->Buffer,Alignment);

    pStubMsg->MemorySize += UnionSize;

    //
    // Get number of union arms.
    //
    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff );

    //
    // Search for the correct arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        //
        // Raise an exception here.
        //
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm is emtpy.
    //
    if ( ! *((ushort *)pFormat) )
        return pStubMsg->MemorySize;

    //
    // Ok we've got the correct arm now.  The only goal now is to increment
    // the buffer pointer by the correct amount, and possibly add the size
    // of embedded pointers in the chosen union arm to the memory size.
    //

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        unsigned char FcType = pFormat[0];

        ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( FcType ));
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( FcType );

        return pStubMsg->MemorySize;
        }

    pFormat += *((signed short *)pFormat);

    if ( IS_POINTER_TYPE(*pFormat) )
        {

        if ( pStubMsg->IgnoreEmbeddedPointers )
            {
            ALIGN(pStubMsg->Buffer,0x3);
            pStubMsg->Buffer += PTR_WIRE_SIZE;
            return pStubMsg->MemorySize;
            }

        if ( pStubMsg->PointerBufferMark )
            {

            ALIGN(pStubMsg->Buffer,0x3);
            uchar *pPointerId = pStubMsg->Buffer;
            pStubMsg->Buffer += PTR_WIRE_SIZE;
            
            if ( !pStubMsg->IgnoreEmbeddedPointers )
                {
                POINTER_MEMSIZE_SWAP_CONTEXT SwapContext(pStubMsg);
                (void) NdrpPointerMemorySize( pStubMsg,
                                              pPointerId,
                                              pFormat );
                }
            
            return pStubMsg->MemorySize;
            }
        }

    //
    // Add in the size of arm.  We end up adding the size of the flat part
    // of the arm a second time here.
    // We do have to call this however, so that the buffer pointer is properly
    // updated.
    //
    return (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)])
           ( pStubMsg,
             pFormat );
}


unsigned long RPC_ENTRY
NdrXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for the presented type of a
    transmit as or represent as.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size of the presented type object.

--*/
{
    unsigned long           MemorySize;
    unsigned short          QIndex;

    // Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);

    // Memsize the presented object.

    MemorySize = *(unsigned short *)(pFormat + 4);

    // Update our current count in the stub message.
    pStubMsg->MemorySize += MemorySize;

    // Move the pointer in the buffer behind the transmitted object
    // for the next field to be memsized correctly.

    pFormat += 8;
    pFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pFormat ))
        {
        // Simple type.
        ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( *pFormat) );
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( *pFormat );
        }
    else
        {
            uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
            pStubMsg->PointerBufferMark = 0;
            NDR_POINTER_QUEUE *pOldQueue = NULL;

            if ( pStubMsg->pPointerQueueState)
                {
                pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
                pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
                }

            RpcTryFinally
                {
                (*pfnMemSizeRoutines[ ROUTINE_INDEX( *pFormat) ])( pStubMsg, pFormat );
                }
            RpcFinally
                {
                pStubMsg->PointerBufferMark = PointerBufferMarkSave;
                if ( pStubMsg->pPointerQueueState)
                    {
                    pStubMsg->pPointerQueueState->SetActiveQueue(pOldQueue);
                    }
                }
            RpcEndFinally
        }

    return( MemorySize );
}



void
NdrpUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
{

    unsigned long MemorySizeSave;

    // Flat type.
    // Optimization: if we know the wire size, don't walk to size it.

    if ( *(unsigned short *)(pFormat + 6) != 0 )
        {
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + *(unsigned short *)(pFormat + 6));
        pStubMsg->Buffer += *(unsigned short *)(pFormat + 6);
        return;
        }

    // Unknown wire size: we need to step through the buffer.
    // However, the memory size may have nothing to do with
    // the wire type description..
    // so, we need to remember what the current memory size is.

    MemorySizeSave = pStubMsg->MemorySize;

    pFormat += 8;
    pFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pFormat ))
        {
        // Simple type.
        pStubMsg->Buffer += SIMPLE_TYPE_BUFSIZE( *pFormat );
        }
    else
        {
        (*pfnMemSizeRoutines[ ROUTINE_INDEX( *pFormat) ])( pStubMsg, pFormat );
        }

    pStubMsg->MemorySize = MemorySizeSave;

}

void 
NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    NdrpUserMarshalMemorySize( pStubMsg,
                               pFormat );
}
#if defined(DBG)
void 
NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


unsigned long RPC_ENTRY
NdrUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a usr_marshal type.
    See mrshl.c for the description of the layouts.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The memory size of the usr_marshall object.

--*/
{
    unsigned long           MemorySize;

    // The memory sizing routine can be called only when sizing a complex
    // struct for memory allocation.
    // Hence, IgnoreEmbeddedPointer in this case has to be on.

    // Memsize the presented object.

    MemorySize = *(unsigned short *)(pFormat + 4);

    // Update our current count in the stub message.
    pStubMsg->MemorySize += MemorySize;

    // Move the pointer in the buffer behind the transmitted object
    // for the next field to be memsized correctly.

    ALIGN( pStubMsg->Buffer, LOW_NIBBLE( pFormat[1] ) );

    if ( pFormat[1] & USER_MARSHAL_POINTER )
        {

        ulong PointerMarker = 0;

        if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  ||
             ((pFormat[1] & USER_MARSHAL_REF) && pStubMsg->PointerBufferMark) )
            {
            PointerMarker = *((unsigned long * &)pStubMsg->Buffer)++;
            }

        if ( pStubMsg->IgnoreEmbeddedPointers )
            return pStubMsg->MemorySize;

        if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  &&
            !PointerMarker)
           return pStubMsg->MemorySize;

        if ( !pStubMsg->pPointerQueueState ||
             !pStubMsg->pPointerQueueState->GetActiveQueue() )
            {
            // If we are embedded, switch to the pointee buffer.
            POINTER_MEMSIZE_SWAP_CONTEXT NewContext(pStubMsg);

            NdrpUserMarshalMemorySize( 
                pStubMsg,
                pFormat );
            }
        else
            {
            NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT*pElement = 
               new(pStubMsg->pPointerQueueState) 
                   NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT(pFormat );
            pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
            }
        
        return pStubMsg->MemorySize;
        }

    NdrpUserMarshalMemorySize( 
        pStubMsg,
        pFormat );

    return pStubMsg->MemorySize;
}


void
NdrpInterfacePointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size needed for an interface pointer.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The current memory size.

--*/
{

    ALIGN( pStubMsg->Buffer, 3 );
    // Pick up the conformant size and the count field.
    ulong MaxCount = *((unsigned long *&) pStubMsg->Buffer)++;
    ulong Size     = *((unsigned long *&) pStubMsg->Buffer)++;

    //Check the array bounds
    if ( Size != MaxCount )
        RpcRaiseException( RPC_X_BAD_STUB_DATA );

    IStream* pStream = 0;

    RpcTryFinally
    {
        if (MaxCount > 0)
            {
            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, MaxCount );
            if ( IS_WALKIP( pStubMsg->uFlags) )
                {

                pStream = (*NdrpCreateStreamOnMemory)(pStubMsg->Buffer, MaxCount);
                if(pStream == 0)
                    RpcRaiseException(RPC_S_OUT_OF_MEMORY);

                HRESULT hr = (*pfnCoReleaseMarshalData)(pStream);
                
                if(FAILED(hr))
                    RpcRaiseException(hr);
                }
            }

    }
    RpcFinally
        {
        if ( pStream ) pStream->Release();
        pStubMsg->Buffer += MaxCount;
        }
    RpcEndFinally
}

unsigned long RPC_ENTRY
NdrInterfacePointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
{
    ALIGN(pStubMsg->Buffer,0x3);
    ulong PtrValue = *((long *&)pStubMsg->Buffer)++;

    LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );
    pStubMsg->MemorySize += PTR_MEM_SIZE;

    if ( !PtrValue || pStubMsg->IgnoreEmbeddedPointers )
        return pStubMsg->MemorySize;
     
    NdrpInterfacePointerMemorySize( pStubMsg,
                                    pFormat );

    return pStubMsg->MemorySize;
}


void
NdrpEmbeddedPointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for all embedded pointers in an
    array or a structure.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );
    uchar *     pBufPtr;
    uchar *     pBufferMark;
    uchar *     pBufferSave;
    ULONG_PTR   MaxCountSave;

    MaxCountSave = pStubMsg->MaxCount;

    pBufferMark = pStubMsg->BufferMark;

    // Increment past the FC_PP and pad.
    pFormat += 2;

    for (;;)
        {

        if ( *pFormat == FC_END )
            {
            return;
            }

        //
        // Check for FC_FIXED_REPEAT or FC_VARIABLE_REPEAT.
        //
        if ( *pFormat != FC_NO_REPEAT )
            {
            pStubMsg->MaxCount = MaxCountSave;

            pStubMsg->BufferMark = pBufferMark;

            NdrpEmbeddedRepeatPointerMemorySize( pStubMsg,
                                                 &pFormat );

            // Continue to the next pointer.
            continue;
            }

        // Compute the pointer to the pointer id in the buffer to size.
        pBufPtr = (pBufferMark + *((signed short *)(pFormat + 4)));

        // Increment to the pointer description.
        pFormat += 6;

        NdrpPointerMemorySize( 
            pStubMsg,
            pBufPtr,
            pFormat );

        // Increment to next pointer description.
        pFormat += 4;
        } // for
}


void
NdrpEmbeddedRepeatPointerMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING *    ppFormat )
/*++

Routine Description :

    Computes the memory size required for all embedded pointers in an
    array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    uchar *         pBufPtr;
    uchar *         pBufferMark;
    PFORMAT_STRING  pFormat;
    PFORMAT_STRING  pFormatSave;
    ulong           RepeatCount, RepeatIncrement, Pointers, PointersSave;

    pBufferMark = pStubMsg->BufferMark;

    pFormat = *ppFormat;

    switch ( *pFormat )
        {
        case FC_FIXED_REPEAT :
            // Increment past the FC_FIXED_REPEAT and FC_PAD.
            pFormat += 2;

            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = *((ushort *&)pFormat)++;

            break;

        case FC_VARIABLE_REPEAT :
            // Get the total number of times to repeat the pointer marshall.
            RepeatCount = (ulong)pStubMsg->MaxCount;

            pFormat += 2;

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerMemorySize : bad format");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    // Get the increment amount between successive pointers.
    RepeatIncrement = *((ushort *&)pFormat)++;

    // Offset to array is ignored.
    pFormat += 2;

    // Get number of pointers.
    PointersSave = Pointers = *((ushort *&)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop for the number of shipped array elements.
    //
    for ( ; RepeatCount--;
            pBufferMark += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        //
        // Loop for the number of pointer in each array element (which could
        // be greater than 0 for an array of structures).
        //
        for ( ; Pointers--; )
            {
            pFormat += 2;

            // Get the buffer pointer where the pointer id is.
            pBufPtr = pBufferMark + *((signed short *&)pFormat)++;

            NdrpPointerMemorySize( 
                   pStubMsg,
                   pBufPtr,
                   pFormat );

            // Increment to the next the pointer description.
            pFormat += 4;
            }
        }

    // Get the format string pointer past this repeat pointer description.
    *ppFormat = pFormatSave + PointersSave * 8;
}


#ifdef _CS_CHAR
unsigned long RPC_ENTRY
NdrCsTagMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a cs tag.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer to FC_CS_TAG in the format string.

Return :

    The computed memory size.

--*/
{
    // We need to set the tag in the stub message so that it can be used
    // later for sizing/unmarshalling arrays

    NdrpGetSetCSTagUnmarshall(
            pStubMsg,
            (NDR_CS_TAG_FORMAT *) pFormat);

    pStubMsg->Buffer += sizeof( ulong );
    pStubMsg->MemorySize += sizeof( ulong );

    return pStubMsg->MemorySize;
}


unsigned long RPC_ENTRY
NdrCsArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the memory size required for a cs_char array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer to FC_CS_TAG in the format string.

Return :

    The computed memory size.

--*/
{
    NDR_CS_ARRAY_FORMAT            *pCSFormat;
    NDR_CS_SIZE_CONVERT_ROUTINES   *CSRoutines;
    CS_TYPE_LOCAL_SIZE_ROUTINE      LocalSizeRoutine;
    IDL_CS_CONVERT                  ConversionType;
    ulong                           ArraySize;
    ulong                           WireLength;
    error_status_t                  status;

    pCSFormat = (NDR_CS_ARRAY_FORMAT *) pFormat;

    NDR_ASSERT( NULL != pStubMsg->pCSInfo, "cs_char stub info not set up");

    // Get all the info out of the FC_CS_ARRAY structure and bump pFormat
    // to point to the underlying data descriptor

    CSRoutines = pStubMsg->StubDesc->CsRoutineTables->pSizeConvertRoutines;
    LocalSizeRoutine = CSRoutines[ pCSFormat->CSRoutineIndex].pfnLocalSize;

    pFormat += pCSFormat->DescriptionOffset;

    // Get the size of the data on the wire

    WireLength = PtrToUlong( NdrpMemoryIncrement( pStubMsg, 0, pFormat ) );

    LocalSizeRoutine(
            pStubMsg->RpcMsg->Handle,
            pStubMsg->pCSInfo->WireCodeset,
            WireLength,
            &ConversionType,
            &ArraySize,
            &status);

    if ( RPC_S_OK != status )
        RpcRaiseException( status );

    pStubMsg->MemorySize += ArraySize * pCSFormat->UserTypeSize;
    
    return pStubMsg->MemorySize;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\mrshlp.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    mrshlp.c

Abstract :

    This file contains the routines for marshalling an array's or a structure's
    embedded pointers and for computing conformance and variance counts and 
    union switch values.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "attack.h"
#include "interp2.h"
#include "mulsyntx.h"
#include "asyncu.h"
#include "pointerq.h"


PFORMAT_STRING
NdrpEmbeddedPointerMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls an array's or a structure's embedded pointers.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure or array whose embedded pointers 
                  are being marshalled. 
    pFormat     - The format string pointer layout.  Should point to the 
                  pointer layout's beginning FC_PP character upon entry. 

Return :

    Format string pointer after the pointer layout.

 --*/
{
    uchar **        ppMemPtr;
    uchar *         pBufPtr;
    uchar *         pBufferMark;
    uchar *         pMemorySave;
    ULONG_PTR       MaxCountSave;
    long            OffsetSave;

    MaxCountSave = pStubMsg->MaxCount;
    OffsetSave = pStubMsg->Offset;
    
    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

    pMemorySave = pStubMsg->Memory;

    // This is where the embedding structure or array begins in the buffer.
    pBufferMark = pStubMsg->BufferMark;

    //
    // The Memory field in the stub message keeps track of the pointer to 
    // the current embedding structure or array.  This is needed to handle 
    // size/length pointers, so that we can get a pointer to the current 
    // embedding struct when computing conformance and variance.
    //
    pStubMsg->Memory = pMemory;

    // Skip FC_PP and FC_PAD.
    pFormat += 2;

    for (;;) 
        {

        if ( *pFormat == FC_END ) 
            {
            pStubMsg->Memory = pMemorySave;

            return pFormat;
            }

        //
        // Check for FC_FIXED_REPEAT and FC_VARIABLE_REPEAT.
        //
        if ( *pFormat != FC_NO_REPEAT ) 
            {
            pStubMsg->MaxCount = MaxCountSave;
            pStubMsg->Offset = OffsetSave;

            pStubMsg->BufferMark = pBufferMark;

            pFormat = NdrpEmbeddedRepeatPointerMarshall( pStubMsg,
                                                         pMemory,
                                                         pFormat );
            // Continue to the next pointer.
            continue;
            } 

        // Compute the pointer to the pointer to marshall.
        ppMemPtr = (uchar **)(pMemory + *((signed short *)(pFormat + 2)));

        //
        // Compute the location in the buffer where the pointer's value will be 
        // marshalled.  Needed for full pointers.
        //
        pBufPtr = pBufferMark + *((signed short *)(pFormat + 4));

        // Increment to the pointer description.
        pFormat += 6;

        //
        // Now marshall the pointer.  
        //
        NdrpPointerMarshall( pStubMsg,
                             pBufPtr,
                             *ppMemPtr,
                             pFormat );

        // Increment to the next pointer description.
        pFormat += 4;

        } // for
}


PFORMAT_STRING
NdrpEmbeddedRepeatPointerMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls an array's embedded pointers.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array whose embedded pointers are being marshalled.
    pFormat     - Pointer layout format string description.

Return :

    Format string pointer after the pointer layout.

--*/
{
    uchar **        ppMemPtr;
    uchar *         pBufPtr;
    PFORMAT_STRING  pFormatSave;
    uchar *         pMemorySave;
    uchar *         pBufferMark;
    ulong           RepeatCount, RepeatIncrement, Pointers, PointersSave;

    pMemorySave = pStubMsg->Memory;

    //
    // This is where the current embedding structure or array begins in 
    // the buffer.
    //
    pBufferMark = pStubMsg->BufferMark;

    // Get the number of shipped elements in the array.
    switch ( *pFormat ) 
        {
        case FC_FIXED_REPEAT :
            pFormat += 2;

            RepeatCount = *((ushort *)pFormat);

            break;

        case FC_VARIABLE_REPEAT :
            RepeatCount = (ulong)pStubMsg->MaxCount;

            //
            // Check if this variable repeat instance also has a variable
            // offset (this would be the case for a conformant varying array
            // of pointers).  If so then increment the memory pointer by the
            // increment size time the variance offset.
            //
            if ( pFormat[1] == FC_VARIABLE_OFFSET ) 
                pMemory += *((ushort *)(pFormat + 2)) * pStubMsg->Offset;

            // else pFormat[1] == FC_FIXED_OFFSET - do nothing

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Increment format string to increment field.
    pFormat += 2;

    // Get the increment amount between successive pointers.
    // This is actually an increment over the array element.
    RepeatIncrement = *((ushort * &)pFormat)++;

    //
    // Add the offset to the beginning of this array to the Memory
    // pointer.  This is the offset from the current embedding structure
    // or array to the array whose pointers we're marshalling.
    //
    pStubMsg->Memory += *((ushort * &)pFormat)++;

    // Get the number of pointers in this repeat instance.
    PointersSave = Pointers = *((ushort * &)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop over the number of shipped elements of the array.
    //
    for ( ; RepeatCount--;  
            pBufferMark += RepeatIncrement,
            pMemory += RepeatIncrement,
            pStubMsg->Memory += RepeatIncrement ) 
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        //
        // Loop over the number of pointer per array element (could be 
        // greater than one for an array of structures).
        //
        for ( ; Pointers--; ) 
            {
            ppMemPtr = (uchar **)(pMemory + *((signed short * &)pFormat)++); 

            pBufPtr = pBufferMark + *((signed short * &)pFormat)++;

            NdrpPointerMarshall( pStubMsg,
                                 pBufPtr,
                                 *ppMemPtr,
                                 pFormat );

            // Increment to the next pointer's offset_in_memory.
            pFormat += 4;
            }
        }

    pStubMsg->Memory = pMemorySave;

    // Return the format string pointer past the pointer descriptions.
    return pFormatSave + PointersSave * 8;
}


ULONG_PTR 
NdrpComputeConformance ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    This routine computes the conformant size for an array or the switch_is
    value for a union.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array, string, or union whose size or switch_is
                  is being computed.  This is ignored for top level parameters.
    pFormat     - Format string description of the array, string, or union.

Return :

    The array or string size or the union switch_is.

Note:
    Async splitting:
    The only thing that the compiler should generate with the FC_SPLIT_* operations
    should be top level conformance.
    Expr evaluation routines and top level multi-dim sizing is not supported with 
    the async uuid split.

Note64:
    On 64b platform this routine is can return 8 bytes of a iid_is pointer.
    However, the MaxCount field does not need to keep it and it stays as a ulong.
    

--*/
{
    void *          pCount;
    LONG_PTR       Count;

    unsigned char   FormatCopy[4];
    BOOL            fAsyncSplit = FALSE;

    static const uchar    Increments[] = 
                            { 
                            4,              // Conformant array.
                            4,              // Conformant varying array.
                            0, 0,           // Fixed arrays - unused.
                            0, 0,           // Varying arrays - unused.
                            4,              // Complex array.

                            2,              // Conformant char string. 
                            2,              // Conformant byte string.
                            4,              // Conformant stringable struct. 
                            2,              // Conformant wide char string.

                            0, 0, 0, 0,     // Non-conformant strings - unused.

                            0,              // Encapsulated union - unused. 
                            2,              // Non-encapsulated union.
                            2,              // Byte count pointer.
                            0, 0,           // Xmit/Rep as - unused.
                            2               // Interface pointer.
                            };

    //
    // Advance the format string to the size_is, switch_is, iid_is, or
    // byte count description.
    //
    pFormat += Increments[*pFormat - FC_CARRAY];

    pCount = 0;

    //
    // First check if this is a callback.
    //
    if ( pFormat[1] == FC_CALLBACK ) 
        {
        uchar *     pOldStackTop;
        ushort      Index;

        // Index into expression callback routines table.
        Index = *((ushort *)(pFormat + 2));

        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval != 0,
                   "NdrpComputeConformance : no expr eval routines");
        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval[Index] != 0,
                   "NdrpComputeConformance : bad expr eval routine index");

        pOldStackTop = pStubMsg->StackTop;

        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        if ( (*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE ) 
            {
            if ( (*pFormat & 0xf0) == FC_POINTER_CONFORMANCE )
                pMemory = pStubMsg->Memory;
            pStubMsg->StackTop = pMemory;
            }

        //
        // This call puts the result in pStubMsg->MaxCount.
        //
        (*pStubMsg->StubDesc->apfnExprEval[Index])( pStubMsg );

        pStubMsg->StackTop = pOldStackTop;

        return pStubMsg->MaxCount;
        }

    if ( (*pFormat & 0xf0) == FC_NORMAL_CONFORMANCE )
        {
        // Get the address where the conformance variable is in the struct.
        pCount = pMemory + *((signed short *)(pFormat + 2));
        goto ComputeConformantGetCount;
        }

    // See if this is an async split

    if ( pFormat[1] & 0x20 )
        {
        fAsyncSplit = TRUE;
        RpcpMemoryCopy( & FormatCopy[0], pFormat, 4 );
        pFormat = (PFORMAT_STRING) & FormatCopy[0];

        // Remove the async marker
        FormatCopy[1] = pFormat[1] & (unsigned char)~0x20;
        }

    //
    // Get a pointer to the conformance describing variable.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_CONFORMANCE ) 
        {
        //
        // Top level conformance.  For /Os stubs, the stubs put the max
        // count in the stub message.  For /Oi stubs, we get the max count
        // via an offset from the stack top.
        //
        if ( pStubMsg->StackTop ) 
            {
            if ( fAsyncSplit )
                {
                PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg;

                pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE) pStubMsg->pAsyncMsg;

                pCount = pAsyncMsg->BeginStack + *((ushort *)(pFormat + 2));
                }
            else
                pCount = pStubMsg->StackTop + *((ushort *)(pFormat + 2));
            goto ComputeConformantGetCount;
            }
        else
            {
            //
            // If this is top level conformance with /Os then we don't have 
            // to do anything, the proper conformance count is placed in the 
            // stub message inline in the stubs.
            //
            return pStubMsg->MaxCount;
            }
        }

    //
    // If we're computing the size of an embedded sized pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    if ( (*pFormat & 0xf0) == FC_POINTER_CONFORMANCE )
        {
        pMemory = pStubMsg->Memory;
        pCount = pMemory + *((signed short *)(pFormat + 2));
        goto ComputeConformantGetCount;
        }

    //
    // Check for constant size/switch.
    //
    if ( (*pFormat & 0xf0) == FC_CONSTANT_CONFORMANCE )
        {
        //
        // The size/switch is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        Count =  (LONG_PTR) ((ulong)pFormat[1] << 16);
        Count |= (LONG_PTR) *((ushort *)(pFormat + 2));

        goto ComputeConformanceEnd;
        }

    //
    // Check for conformance of a multidimensional array element in 
    // a -Os stub.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE )
        {
        long Dimension;

        if ( fAsyncSplit )
            RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

        //
        // If pArrayInfo is non-null than we have a multi-D array.  If it
        // is null then we have multi-leveled sized pointers.
        //
        if ( pStubMsg->pArrayInfo ) 
            {
            Dimension = pStubMsg->pArrayInfo->Dimension;
            pStubMsg->MaxCount = pStubMsg->pArrayInfo->MaxCountArray[Dimension];
            }
        else
            {
            Dimension = *((ushort *)(pFormat + 2));
            pStubMsg->MaxCount = pStubMsg->SizePtrCountArray[Dimension];
            }

        return pStubMsg->MaxCount;
        }

    NDR_ASSERT(0, "NdrpComputeConformance:, Invalid Conformance type");
    RpcRaiseException( RPC_S_INTERNAL_ERROR );
    return 0; //bogus return

ComputeConformantGetCount:

    //
    // Must check now if there is a dereference op.
    //
    if ( pFormat[1] == FC_DEREFERENCE )
        {
        pCount = *(void **)pCount;
        }

    //
    // Now get the conformance count.
    //
    switch ( *pFormat & 0x0f ) 
        {
        case FC_HYPER :
            // iid_is on 64b platforms only.
            Count = *((LONG_PTR *)pCount);
            break;

        case FC_ULONG :
            Count = (LONG_PTR)*((ulong *)pCount);
            break;

        case FC_LONG :
            Count = *((long *)pCount);
            break;

        case FC_ENUM16:
        case FC_USHORT :
            Count = (long) *((ushort *)pCount);
            break;

        case FC_SHORT :
            Count = (long) *((short *)pCount);
            break;

        case FC_USMALL :
            Count = (long) *((uchar *)pCount);
            break;

        case FC_SMALL :
            Count = (long) *((char *)pCount);
            break;

        default :
            NDR_ASSERT(0,"NdrpComputeConformance : bad count type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        } 

    //
    // Check the operator.
    //
    switch ( pFormat[1] ) 
        {
        case FC_DIV_2 :
            Count /= 2;
            break;
        case FC_MULT_2 :
            Count *= 2;
            break;
        case FC_SUB_1 :
            Count -= 1;
            break;
        case FC_ADD_1 :
            Count += 1;
            break;
        default :
            // OK
            break;
        }

ComputeConformanceEnd:

    // Max count is not used for iid_is.

    pStubMsg->MaxCount = (ulong) Count;

    return (ULONG_PTR) Count;
}


void 
NdrpComputeVariance ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Computes the variance (offset and actual count) for an array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array whose variance is being computed.  This
                  is unused for a top level parameter.
    pFormat     - Format string description of the array.

Return :

    None.

--*/
{
    void *          pLength;
    LONG_PTR        Length;

    unsigned char   FormatCopy[4];
    BOOL            fAsyncSplit = FALSE;

    uchar   FcType = *pFormat;

    //
    // Advance the format string to the variance description.
    //

    static uchar    Increments[] = { 8,     // Conformant varying array.
                                     0, 0,  // Fixed arrays - unsed.
                                     8, 12, // Varying array.
                                     8      // Complex array. 
                                   };

    pFormat += Increments[ FcType - FC_CVARRAY];

    if (FcType == FC_CVARRAY  ||  FcType == FC_BOGUS_ARRAY)
        {
        CORRELATION_DESC_INCREMENT( pFormat );
        }

    pLength = 0;

    //
    // First check if this is a callback.
    //
    if ( pFormat[1] == FC_CALLBACK ) 
        {
        ULONG_PTR   OldMaxCount;
        uchar *     pOldStackTop;
        ushort      Index;

        Index = *((ushort *)(pFormat + 2));

        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval != 0,
                   "NdrpComputeConformance : no expr eval routines");
        NDR_ASSERT(pStubMsg->StubDesc->apfnExprEval[Index] != 0,
                   "NdrpComputeConformance : bad expr eval routine index");

        pOldStackTop = pStubMsg->StackTop;

        // This gets trampled by the callback routine.
        OldMaxCount = pStubMsg->MaxCount;

        //
        // The callback routine uses the StackTop field of the stub message
        // to base it's offsets from.  So if this is a complex attribute for 
        // an embedded field of a structure then set StackTop equal to the 
        // pointer to the structure.
        //
        if ( (*pFormat & 0xf0) != FC_TOP_LEVEL_CONFORMANCE ) 
            {
            if ( (*pFormat & 0xf0) == FC_POINTER_VARIANCE )
                pMemory = pStubMsg->Memory;
            pStubMsg->StackTop = pMemory;
            }

        //
        // This puts the computed offset in pStubMsg->Offset and the length 
        // in pStubMsg->MaxCount.
        //
        (*pStubMsg->StubDesc->apfnExprEval[Index])( pStubMsg );

        // Put the length in the proper field.
        pStubMsg->ActualCount = (ulong)pStubMsg->MaxCount;

        pStubMsg->MaxCount = OldMaxCount;

        pStubMsg->StackTop = pOldStackTop;

        return;
        }

    if (  (*pFormat & 0xf0) == FC_NORMAL_VARIANCE  )
        {
        // Get the address where the variance variable is in the struct.
        pLength = pMemory + *((signed short *)(pFormat + 2));
        goto ComputeVarianceGetCount;
        }

    // See if this is an async split

    if ( pFormat[1] & 0x20 )
        {
        fAsyncSplit = TRUE;
        RpcpMemoryCopy( & FormatCopy[0], pFormat, 4 );
        pFormat = (PFORMAT_STRING) & FormatCopy[0];

        // Remove the async marker
        FormatCopy[1] = pFormat[1] & 0xdf;
        }

    //
    // Get a pointer to the variance variable.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_VARIANCE ) 
        {
        //
        // Top level variance.  For /Os stubs, the stubs put the actual
        // count and offset in the stub message.  For /Oi stubs, we get the 
        // actual count via an offset from the stack top.  The first_is must
        // be zero if we get here.
        //
        if ( pStubMsg->StackTop ) 
            {
            if ( fAsyncSplit )
                {
                PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg;

                pAsyncMsg = (PNDR_DCOM_ASYNC_MESSAGE) pStubMsg->pAsyncMsg;

                pLength = pAsyncMsg->BeginStack + *((signed short *)(pFormat + 2));
                }
            else
                pLength = pStubMsg->StackTop + *((signed short *)(pFormat + 2));
            goto ComputeVarianceGetCount;
            }
        else
            {
            //
            // If this is top level variance with /Os then we don't have 
            // to do anything, the proper variance values are placed in the 
            // stub message inline in the stubs.
            //
            return;
            }
        }

    //
    // If we're computing the length of an embedded size/length pointer then we
    // use the memory pointer in the stub message, which points to the 
    // beginning of the embedding structure.
    //
    if ( (*pFormat & 0xf0) == FC_POINTER_VARIANCE )
        {
        pMemory = pStubMsg->Memory;
        pLength = pMemory + *((signed short *)(pFormat + 2));
        goto ComputeVarianceGetCount;
        }

    //
    // Check for constant length.
    //
    if ( (*pFormat & 0xf0) == FC_CONSTANT_VARIANCE )
        {
        //
        // The length is contained in the lower three bytes of the 
        // long currently pointed to by pFormat.
        //
        Length =  (LONG_PTR) ((ulong)pFormat[1] << 16);
        Length |= (LONG_PTR) *((ushort *)(pFormat + 2));

        goto ComputeVarianceEnd;
        }

    //
    // Check for variance of a multidimensional array element in 
    // a -Os stub.
    //
    if ( (*pFormat & 0xf0) == FC_TOP_LEVEL_MULTID_CONFORMANCE )
        {
        long Dimension;

        if ( fAsyncSplit )
            RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

        //
        // If pArrayInfo is non-null than we have a multi-D array.  If it
        // is null then we have multi-leveled sized pointers.
        //
        if ( pStubMsg->pArrayInfo )
            {
            Dimension = pStubMsg->pArrayInfo->Dimension;

            pStubMsg->Offset = 
                    pStubMsg->pArrayInfo->OffsetArray[Dimension];
            pStubMsg->ActualCount = 
                    pStubMsg->pArrayInfo->ActualCountArray[Dimension];
            }
        else
            {
            Dimension = *((ushort *)(pFormat + 2));

            pStubMsg->Offset = pStubMsg->SizePtrOffsetArray[Dimension];
            pStubMsg->ActualCount = pStubMsg->SizePtrLengthArray[Dimension];
            }

        return;
        }

ComputeVarianceGetCount:

    //
    // Must check now if there is a dereference op.
    //
    if ( pFormat[1] == FC_DEREFERENCE )
        {
        pLength = *(void **)pLength;
        }

    //
    // Now get the conformance count.
    //
    switch ( *pFormat & 0x0f ) 
        {
        case FC_ULONG :
            Length = (LONG_PTR)*((ulong *)pLength);
            break;

        case FC_LONG :
            Length = *((long *)pLength);
            break;

        case FC_USHORT :
            Length = (long) *((ushort *)pLength);
            break;

        case FC_SHORT :
            Length = (long) *((short *)pLength);
            break;

        case FC_USMALL :
            Length = (long) *((uchar *)pLength);
            break;

        case FC_SMALL :
            Length = (long) *((char *)pLength);
            break;

        default :
            NDR_ASSERT(0,"NdrpComputeVariance : bad format");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        } 

    //
    // Check the operator.
    //
    switch ( pFormat[1] ) 
        {
        case FC_DIV_2 :
            Length /= 2;
            break;
        case FC_MULT_2 :
            Length *= 2;
            break;
        case FC_SUB_1 :
            Length -= 1;
            break;
        case FC_ADD_1 :
            Length += 1;
            break;
        default :
            // OK
            break;
        }

ComputeVarianceEnd:

    // Get here if the length was computed directly.
    pStubMsg->Offset = 0;
    pStubMsg->ActualCount = (ulong) Length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\mrshl.cxx ===
/************************************************************************

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    mrshl.c

Abstract :

    This file contains the marshalling routines called by MIDL generated
    stubs and the interpreter.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ***********************************************************************/

#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

unsigned char  *RPC_ENTRY
NdrUDTSimpleTypeMarshall1(
    PMIDL_STUB_MESSAGE    pStubMsg,
    unsigned char *       pMemory,
    PFORMAT_STRING        pFormat
    );

//
// Function table of marshalling routines.
//
extern const PMARSHALL_ROUTINE MarshallRoutinesTable[] =
                    {
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    NdrUDTSimpleTypeMarshall1,
                    
                    NdrPointerMarshall,
                    NdrPointerMarshall,
                    NdrPointerMarshall,
                    NdrPointerMarshall,

                    NdrSimpleStructMarshall,
                    NdrSimpleStructMarshall,
                    NdrConformantStructMarshall,
                    NdrConformantStructMarshall,
                    NdrConformantVaryingStructMarshall,

                    NdrComplexStructMarshall,

                    NdrConformantArrayMarshall,
                    NdrConformantVaryingArrayMarshall,
                    NdrFixedArrayMarshall,
                    NdrFixedArrayMarshall,
                    NdrVaryingArrayMarshall,
                    NdrVaryingArrayMarshall,

                    NdrComplexArrayMarshall,

                    NdrConformantStringMarshall,
                    NdrConformantStringMarshall,
                    NdrConformantStringMarshall,
                    NdrConformantStringMarshall,

                    NdrNonConformantStringMarshall,
                    NdrNonConformantStringMarshall,
                    NdrNonConformantStringMarshall,
                    NdrNonConformantStringMarshall,

                    NdrEncapsulatedUnionMarshall,
                    NdrNonEncapsulatedUnionMarshall,

                    NdrByteCountPointerMarshall,

                    NdrXmitOrRepAsMarshall,    // transmit as
                    NdrXmitOrRepAsMarshall,    // represent as

                    NdrPointerMarshall,

                    NdrMarshallHandle,

                    // New Post NT 3.5 token serviced from here on.

                    0,                       // NdrHardStructMarshall,

                    NdrXmitOrRepAsMarshall,  // transmit as ptr
                    NdrXmitOrRepAsMarshall,  // represent as ptr

                    NdrUserMarshalMarshall,

                    0,   // FC_PIPE 
                    0,   // FC_BLK_HOLE

                    NdrpRangeMarshall,
                    
                    0,   // FC_INT3264
                    0,   // FC_UINT3264

                    0, // NdrCsArrayMarshall,
                    0, // NdrCsTagMarshall
                    };

extern const PMARSHALL_ROUTINE * pfnMarshallRoutines = MarshallRoutinesTable;

unsigned char *
NdrpInterfacePointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat );

RPCRTAPI
unsigned char *RPC_ENTRY
NdrTypeMarshall( 
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PFORMAT_STRING     pFormat )
{
    return
    (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                     pMemory,
                                                     pFormat );
}


__inline unsigned char  *RPC_ENTRY
NdrUDTSimpleTypeMarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      FormatString )
{
    NdrSimpleTypeMarshall(pStubMsg,pMemory,*FormatString);
    return 0;
}
    

void __fastcall NdrpSimpleTypeCharMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory)
{
    ZEROOUT_GAP( pStubMsg->Buffer );
    *(pStubMsg->Buffer)++ = *pMemory;    
}

    
void __fastcall NdrpSimpleTypeShortMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory)
{
    ZEROOUT_GAP( pStubMsg->Buffer );
    ALIGN(pStubMsg->Buffer,1);

    *((ushort *&)pStubMsg->Buffer)++ = *((ushort *)pMemory);
}

    
void __fastcall NdrpSimpleTypeLongMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory)
{
    ZEROOUT_GAP( pStubMsg->Buffer );
    ALIGN(pStubMsg->Buffer,3);

    *((ulong *&)pStubMsg->Buffer)++ = *((ulong *)pMemory);
}

void __fastcall NdrpSimpleTypeHyperMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory)
{
    ZEROOUT_GAP( pStubMsg->Buffer );
    ZeroOutGapAndAlign( pStubMsg ,  7) ;        


     //
     // Let's stay away from casts to double.
     //
     *((ulong *&)pStubMsg->Buffer)++ = *((ulong *)pMemory);
     *((ulong *&)pStubMsg->Buffer)++ = *((ulong *)(pMemory + 4));
}

void __fastcall NdrpSimpleTypeEnum16Marshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory)
{
     if ( *((int *)pMemory) & ~((int)0x7fff) )
        {
        RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
         }

    ZEROOUT_GAP( pStubMsg->Buffer );
    ALIGN(pStubMsg->Buffer,1);

    *((ushort *&)pStubMsg->Buffer)++ = *((ushort *)pMemory);
}

void __fastcall NdrpSimpleTypeIgnoreMarshall (
    PMIDL_STUB_MESSAGE ,
    uchar * )
{
}

void __fastcall NdrpSimpleTypeInvalidMarshall (
    PMIDL_STUB_MESSAGE ,
    uchar *     )
{
    NDR_ASSERT(0,"NdrSimpleTypeMarshall : bad format char");
    RpcRaiseException( RPC_S_INTERNAL_ERROR );
}

// make this extern as this will be call from ClientMarshal & ServerMarshal also.
extern const PSIMPLETYPE_MARSHAL_ROUTINE SimpleTypeMarshallRoutinesTable[] =
                    {
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeCharMarshall,
                    NdrpSimpleTypeCharMarshall,
                    NdrpSimpleTypeCharMarshall,
                    NdrpSimpleTypeCharMarshall,
                    
                    NdrpSimpleTypeShortMarshall,
                    NdrpSimpleTypeShortMarshall,
                    NdrpSimpleTypeShortMarshall,
                    
                    NdrpSimpleTypeLongMarshall,
                    NdrpSimpleTypeLongMarshall,
                    
                    NdrpSimpleTypeLongMarshall,     // FC_FLOAT
                    
                    NdrpSimpleTypeHyperMarshall,
                    NdrpSimpleTypeHyperMarshall,
                    
                    NdrpSimpleTypeEnum16Marshall,   // FC_ENUM16
                    
                    NdrpSimpleTypeLongMarshall,
                    
                    NdrpSimpleTypeIgnoreMarshall,
                    NdrpSimpleTypeLongMarshall,         // fc_error_status_t
                    
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,    // transmit as
                    NdrpSimpleTypeInvalidMarshall,    // represent as

                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,

                    // New Post NT 3.5 token serviced from here on.

                    NdrpSimpleTypeInvalidMarshall,                       // NdrHardStructMarshall,

                    NdrpSimpleTypeInvalidMarshall,  // transmit as ptr
                    NdrpSimpleTypeInvalidMarshall,  // represent as ptr

                    NdrpSimpleTypeInvalidMarshall,

                    NdrpSimpleTypeInvalidMarshall,   // FC_PIPE 
                    NdrpSimpleTypeInvalidMarshall,   // FC_BLK_HOLE

                    NdrpSimpleTypeInvalidMarshall,

#if defined(__RPC_WIN64__)
                    NdrpSimpleTypeLongMarshall,   // FC_INT3264
                    NdrpSimpleTypeLongMarshall,   // FC_UINT3264
#else
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
#endif
                    NdrpSimpleTypeInvalidMarshall, // NdrCsArrayMarshall,
                    NdrpSimpleTypeInvalidMarshall, // NdrCsTagMarshall
                    };
    

void RPC_ENTRY
NdrSimpleTypeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    uchar               FormatChar )
/*++

Routine Description :

    Marshalls a simple type.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data to be marshalled.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
        SimpleTypeMarshallRoutinesTable[ROUTINE_INDEX(FormatChar)](pStubMsg, pMemory );
}


unsigned char * RPC_ENTRY
NdrpRangeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++
--*/
{
    uchar  FcType = pFormat[1] & 0x0f;

    NdrSimpleTypeMarshall( pStubMsg, pMemory, FcType );

    return 0;
}


unsigned char * RPC_ENTRY
NdrPointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level pointer to anything.  Pointers embedded in
    structures, arrays, or unions call NdrpPointerMarshall directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data to be marshalled.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    uchar * pBufferMark;

    //
    // If this is not a ref pointer then set buffer mark and increment the
    // stub message buffer pointer.
    //
    if ( *pFormat != FC_RP )
        {
        ALIGN( pStubMsg->Buffer, 3 );

        // This is where we marshall the node id.
        pBufferMark = pStubMsg->Buffer;

        pStubMsg->Buffer += PTR_WIRE_SIZE;
        }
    else
        pBufferMark = 0;

    //
    // For ref pointers pBufferMark will not be used and can be left
    // unitialized.
    //

    NdrpPointerMarshall( pStubMsg,
                         pBufferMark,
                         pMemory,
                         pFormat );

    return 0;
}


__forceinline void
NdrpPointerMarshallInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for marshalling a pointer and its pointee.  This is the
    entry point for pointers embedded in structures, arrays, and unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pBufferMark - The location in the buffer where the pointer itself is
                  marshalled.  Important for full pointers, unfortunately it's
                  overkill for unique pointers.
    pMemory     - Pointer to the data to be marshalled.
    pFormat     - Pointer format string description.

    pStubMsg->Buffer - the place for the pointee.

Return :

    None.

--*/
{
    //
    // Check the pointer type.
    //
    switch ( *pFormat )
        {
        case FC_RP :
            if ( ! pMemory )
                RpcRaiseException( RPC_X_NULL_REF_POINTER );

            break;

        case FC_UP :
        case FC_OP :
            // Put the pointer in the buffer.
            *((ulong*&)pBufferMark)++ = PTR_WIRE_REP(pMemory, pStubMsg);

            if ( ! pMemory )
                return;

            break;

        case FC_IP :

            if ( IS_BROKEN_INTERFACE_POINTER(pStubMsg->uFlags) )
                {
                // The pointee is effectivly both the pointer
                // and the pointee.

                NdrInterfacePointerMarshall( pStubMsg,
                                             pMemory,
                                             pFormat );
                return;
                }

            // Interface pointers behave like unique pointers
            *((ulong*&)pBufferMark)++ = PTR_WIRE_REP(pMemory, pStubMsg);
            if ( ! pMemory )
                return;

            NdrpInterfacePointerMarshall( pStubMsg,
                                          pMemory,
                                          pFormat );
            return;

        case FC_FP :
            //
            // Marshall the pointer's ref id and see if we've already
            // marshalled the pointer's data.
            //
            if ( NdrFullPointerQueryPointer( pStubMsg->FullPtrXlatTables,
                                             pMemory,
                                             FULL_POINTER_MARSHALLED,
                                             (ulong *) pBufferMark ) )
                return;

            break;

        default :
            NDR_ASSERT(0,"NdrpPointerMarshall : bad pointer type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Check for a pointer to a complex type.
    //
    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        uchar   uFlagsSave;

        if ( POINTER_DEREF(pFormat[1]) )
            pMemory = *((uchar **)pMemory);

        // Increment to offset_to_complex_description<2> field.
        pFormat += 2;

        //
        // Set format string to complex type description.
        // Cast must be to a signed short since some offsets are negative.
        //
        pFormat += *((signed short *)pFormat);

        //
        // Look up the proper marshalling routine in the marshalling function
        // table.
        //
        uFlagsSave = pStubMsg->uFlags;
        RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

        (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                         pMemory,
                                                         pFormat );
        pStubMsg->uFlags = uFlagsSave;
        return;
        }

    //
    // Else it's a pointer to a simple type or a string pointer.
    //

    switch ( pFormat[2] )
        {
        case FC_C_CSTRING :
        case FC_C_BSTRING :
        case FC_C_WSTRING :
        case FC_C_SSTRING :
            NdrConformantStringMarshall( pStubMsg,
                                         pMemory,
                                         pFormat + 2 );
            break;

        default :
            NdrSimpleTypeMarshall( pStubMsg,
                                   pMemory,
                                   pFormat[2] );
            break;
        }
}


NDR_MRSHL_POINTER_QUEUE_ELEMENT::NDR_MRSHL_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pBufferMarkNew,
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :

        pBufferMark(pBufferMarkNew),
        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags) 
{

}

void 
NDR_MRSHL_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0\n");

    NdrpPointerMarshallInternal( pStubMsg,
                                 pBufferMark,
                                 pMemory,
                                 pFormat );
}

#if defined(DBG)
void 
NDR_MRSHL_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pBufferMark:             %p\n", pBufferMark );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );
}
#endif

void 
NdrpEnquePointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );    
    
    RpcTryFinally
    {
        NDR_MRSHL_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_MRSHL_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                pBufferMark,
                                                pMemory,
                                                pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
    }
    RpcFinally
    {
        PointerContext.EndContext();    
    }
    RpcEndFinally
}

void
NdrpPointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pBufferMark,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    
    if ( !NdrIsLowStack(pStubMsg)  )
        {
        NdrpPointerMarshallInternal(  pStubMsg,
                                      pBufferMark,
                                      pMemory,
                                      pFormat );
        return;
        }

    NdrpEnquePointerMarshall( pStubMsg,
                              pBufferMark,
                              pMemory,
                              pFormat );

}


unsigned char * RPC_ENTRY
NdrSimpleStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    uint   StructSize;

    ZeroOutGapAndAlign(pStubMsg,pFormat[1]);

    StructSize = (uint) *((ushort *)(pFormat + 2));

    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    StructSize );

    // Mark the start of the structure in the buffer.
    pStubMsg->BufferMark = pStubMsg->Buffer;

    pStubMsg->Buffer += StructSize;

    // Marshall embedded pointers.
    if ( *pFormat == FC_PSTRUCT )
        {
        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat + 4 );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a conformant structure.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.        - may set the CONF_ARRAY_DONE flag.

Note

    Due to problems with MIDL generated code, the ConformantStruct routine always
    marshals the conformant array. Only a bogus struct can embed a conf struct, 
    and there is a flag that bogus struct watches in order not to marshal the array
    second time.

--*/
{
    PFORMAT_STRING  pFormatArray;
    uint            StructSize;
    uchar           Alignment;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    // Save structure's alignment.
    Alignment = pFormat[1];

    // Increment format string to struct size field.
    pFormat += 2;

    // Get flat struct size and increment format string.
    StructSize = (uint) *((ushort *&)pFormat)++;

    // Set conformant array format string description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    //
    // Compute conformance information.  Pass a memory pointer to the
    // end of the non-conformant part of the structure.
    //
    NdrpComputeConformance( pStubMsg,
                            pMemory + StructSize,
                            pFormatArray );

    // Only a bogus struct can embed a conf struct.

    if ( fIsEmbeddedStruct )
        *(ulong *)pStubMsg->BufferMark = (ulong)pStubMsg->MaxCount;
    else
        {
        // Align the buffer for conformance count marshalling.
        ALIGN(pStubMsg->Buffer,3);

        // Marshall conformance count.
        *((ulong *&)pStubMsg->Buffer)++ = (ulong)pStubMsg->MaxCount;
        }


    // Re-align buffer 
    ZeroOutGapAndAlign(pStubMsg,Alignment);

    // Increment array format string to array element size field.
    pFormatArray += 2;

    // Add the size of the conformant array to the structure size.
    StructSize += (ulong)pStubMsg->MaxCount * *((ushort *)pFormatArray);

    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    StructSize );

    // Update the buffer pointer.
    pStubMsg->Buffer += StructSize;

    // Increment format string past offset to array description field.
    pFormat += 2;

    // Marshall embedded pointers. This covers the struct and the conf array.
    if ( *pFormat == FC_PP )
        {
        // Mark the start of the structure in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - StructSize;

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }

    // Only a complex struct may set up this flag for embedding.
    // Set the reverse flag to signal that array has been marshaled.

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantVaryingStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a structure which contains a conformant varying array.

    Used for FC_CVSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatArray;
    uint            StructSize;
    uchar           Alignment;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    uchar*          pBuffer;

    if ( !fIsEmbeddedStruct )
        {
        // Align the buffer for marshalling conformance info.
        ALIGN(pStubMsg->Buffer,3);

        // Mark the location in the buffer where the conformance will be marshalled.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment buffer pointer past where conformance will be marshalled.
        pStubMsg->Buffer += 4;
        }
    // else BufferMark is set by the ComplexStruct code.

    // Save the structure's alignment.
    Alignment = pFormat[1];

    // Increment format string to struct size field.
    pFormat += 2;

    // Get non-conformance struct size and increment format string.
    StructSize = (uint) *((ushort *&)pFormat)++;

    // Get conformant array's description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    // Align buffer for struct
    ZeroOutGapAndAlign(pStubMsg, Alignment);
    pBuffer = pStubMsg->Buffer;

    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    StructSize );
    // Set stub message buffer pointer past non-conformant part of struct.
    pStubMsg->Buffer += StructSize;

    //
    // Call the correct private array or string marshalling routine.
    // We must pass a memory pointer to the beginning of the array/string.
    //
    if ( *pFormatArray == FC_CVARRAY )
        {
        NdrpConformantVaryingArrayMarshall( pStubMsg,
                                            pMemory + StructSize,
                                            pFormatArray );
        }
    else
        {
        NdrpConformantStringMarshall( pStubMsg,
                                      pMemory + StructSize,
                                      pFormatArray );
        }

    // Increment format string past the offset_to_array_description<2> field.
    pFormat += 2;

    //
    // Marshall embedded pointers.
    //
    if ( *pFormat == FC_PP )
        {
        // Mark the start of the structure in the buffer.
        pStubMsg->BufferMark = pBuffer;

        pStubMsg->MaxCount = pStubMsg->ActualCount;       

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }

    // Only a complex struct may set up this flag for embedding.
    // Set the reverse flag to signal that array has been marshaled.

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}


#if 0
unsigned char * RPC_ENTRY
NdrHardStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a hard structure.

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being marshalled.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pFormat += 8;

    //
    // Do any needed enum16 exception check.
    //
    if ( *((short *)pFormat) != (short) -1 )
        {
        if ( *((int *)(pMemory + *((ushort *)pFormat))) & ~((int)0x7fff) )
            {
            RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
            }
        }

    pFormat += 2;

    RpcpMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    *((ushort *)pFormat) );

    pStubMsg->Buffer += *((ushort *)pFormat)++;

    //
    // See if we have a union.
    //
    if ( *((short *)&pFormat[2]) )
        {
        pMemory += *((ushort *)pFormat)++;

        pFormat += *((short *)pFormat);

        (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                         pMemory,
                                                         pFormat );
        }

    return 0;
}
#endif // 0


unsigned char * RPC_ENTRY
NdrComplexStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being marshalled.
    pFormat     - Structure's format string description.
    
Return :

    None.
    
Notes :

    pStubMsg->BufferMark is set to a place where conformance would be marhaled.
    pStubMsg->pPointerBufferMark is a pointee buffer mark a usual.

--*/
{
    uchar *         pBufferSave;
    uchar *         pBufferMark;
    uchar *         pMemorySave;
    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatSave;
    PFORMAT_STRING  pFormatComplex;
    long            Alignment;
    long            Align8Mod;
    uchar           fSetPointerBufferMark;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    BOOL            fEmbedConfStructContext;
    
    // Get struct's wire alignment.
    Alignment = pFormat[1];

    //
    // This is used for support of structs with doubles passed on an
    // i386 stack.
    //
    // A cast to long is what we need.
    Align8Mod = 0x7 & PtrToLong( pMemory );

    pFormatSave = pFormat;
    pBufferSave = pStubMsg->Buffer;
    pMemorySave = pStubMsg->Memory;

    pStubMsg->Memory = pMemory;

    // Increment to conformant array offset field.
    pFormat += 4;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        {
        pFormatArray = pFormat + *((signed short *)pFormat);

        if ( !fIsEmbeddedStruct )
            {
            // Align for conformance marshalling.
            ALIGN(pStubMsg->Buffer,3);

            // Remember where the conformance count(s) will be marshalled.
            pStubMsg->BufferMark = pStubMsg->Buffer;

            // Increment the buffer pointer 4 bytes for every array dimension.
            pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormatArray, FALSE ) * 4;
            }
        }
    else
        pFormatArray = 0;

    // Mark the place to marshal conformant size(s), this may come from upper levels.
    pBufferMark = pStubMsg->BufferMark;

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    // Align buffer on struct's alignment.
    ZeroOutGapAndAlign(pStubMsg,Alignment);

    //
    // If the the stub message PointerBufferMark field is 0, then determine
    // the position in the buffer where pointees will be marshalled.
    //
    // We have to do this to handle embedded pointers.
    //
    if ( fSetPointerBufferMark = ! pStubMsg->PointerBufferMark )
        {
        BOOL    fOldIgnore;
        ulong   BufferLenOffset;

        fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        //
        // Set BufferLength equal to the current buffer pointer, and then
        // when we return from NdrComplexStructBufferSize it will pointer to
        // the location in the buffer where the pointees should be marshalled.
        //     pStubMsg->BufferLength = pBufferSave;
        // Instead of pointer, we now calculate pointer increment explicitly.

        // Set the pointer alignment as a base.
        // We use pBufferSave as the sizing routine accounts for the conf sizes.
        //
        BufferLenOffset = 0xf & PtrToUlong( pBufferSave );
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->BufferLength = BufferLenOffset;

        NdrComplexStructBufferSize( pStubMsg,
                                    pMemory,
                                    pFormatSave );

        // Pointer increment including alignments.
        BufferLenOffset = pStubMsg->BufferLength - BufferLenOffset;

        // Set the location in the buffer where pointees will be marshalled.
        pStubMsg->PointerBufferMark = pBufferSave + BufferLenOffset;
        pStubMsg->BufferLength = BufferLengthSave;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        // in NDR20, we have trailing pad issue where if a complex struct contains pointer to simple type
        // and trailing simple type, the first pointee will be written immediately after the last element of 
        // the structure, BEFORE we write the last flat element. If we zero out the alignment gap 
        // we only need to zero out when there is pointer in the struct.
        if ( pFormatPointers )
            {
            ULONG_PTR CopyLength = (ulong)( ( (ULONG_PTR)(pBufferSave + BufferLenOffset + 3 ) & ~3) - (ULONG_PTR)pBufferSave);
            // we need to memset always. 
            memset( pBufferSave, 0, CopyLength );
            }
        }

    fEmbedConfStructContext = fIsEmbeddedStruct ||
                              pFormatArray && FixWireRepForDComVerGTE54( pStubMsg );

    RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    //
    // Marshall the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // Simple types.
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_USMALL:
                *(pStubMsg->Buffer)++ = *pMemory;
                pMemory += 1;
                break;
                
            case FC_ENUM16 :
                if ( *((int *)pMemory) & ~((int)0x7fff) )
                    {
                    RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
                    }
                ALIGN(pStubMsg->Buffer,1);

                *((ushort *&)pStubMsg->Buffer)++ = *((ushort *)pMemory);
                pMemory += 4;
                break;
                
            case FC_WCHAR :
            case FC_SHORT :
            case FC_USHORT:
                ALIGN(pStubMsg->Buffer,1);

                *((ushort *&)pStubMsg->Buffer)++ = *((ushort *)pMemory);
                pMemory += 2;
                break;


#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
                ALIGN( pStubMsg->Buffer, 3 );
                * ((ulong *&)pStubMsg->Buffer)++ = *((ulong *)pMemory);
                pMemory += 8;
                break;
#endif
            case FC_LONG :
            case FC_ULONG:
            case FC_FLOAT :
            case FC_ENUM32 :
                ALIGN( pStubMsg->Buffer, 3 );
                * ((ulong *&)pStubMsg->Buffer)++ = *((ulong *)pMemory);
                pMemory += 4;
                break;
                
            case FC_HYPER :
            case FC_DOUBLE :

                ALIGN( pStubMsg->Buffer, 7 );
                *((ulong *&)pStubMsg->Buffer)++ = *((ulong *)pMemory);
                *((ulong *&)pStubMsg->Buffer)++ = *((ulong *)(pMemory + 4));
                pMemory += 8;
                break;
                

            case FC_IGNORE :
                ALIGN(pStubMsg->Buffer,3);
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                pMemory += PTR_MEM_SIZE;
                break;

            case FC_POINTER :
                {
                
                ALIGN( pStubMsg->Buffer, 0x3 );
                uchar *pPointerId = pStubMsg->Buffer;
                pStubMsg->Buffer += PTR_WIRE_SIZE;
                NDR_ASSERT(pFormatPointers, "NdrComplexStructMarshall: pointer field but no pointer layout");

                {
                    POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
                    NdrpPointerMarshall( pStubMsg,
                                         pPointerId,
                                         *((uchar **)pMemory),
                                         pFormatPointers );

                }

                //
                // Increment memory pointers past the pointer.
                //

                pMemory += PTR_MEM_SIZE;

                pFormatPointers += 4;

                break;
                }

            //
            // Embedded complex types.
            //
            case FC_EMBEDDED_COMPLEX :
                // Increment memory pointer by padding.
                pMemory += pFormat[1];

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( FC_IP == *pFormatComplex ) 
                    {

                    // Treat the same as an embedded pointer
                    ALIGN( pStubMsg->Buffer, 0x3 );
                    uchar *pPointerId = pStubMsg->Buffer;
                    pStubMsg->Buffer += PTR_WIRE_SIZE;

                    {
                        POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
                        NdrpPointerMarshall( pStubMsg,
                                             pPointerId,
                                             *((uchar **)pMemory),
                                             pFormatComplex );

                    }
                    pMemory += PTR_MEM_SIZE;
                    pFormat++;
                    break;

                    }

                // Context needed for the embedded conf struct.
                //
                pStubMsg->BufferMark = pBufferMark;
                if ( fEmbedConfStructContext )
                    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                // Marshall complex type.
                (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  pMemory,
                  pFormatComplex );

                //
                // Increment the memory pointer.
                //
                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormatComplex );

                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                //
                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                //
                pFormat++;

                break;

            case FC_ALIGNM2 :
                ALIGN( pMemory, 0x1 );
                break;

            case FC_ALIGNM4 :
                ALIGN( pMemory, 0x3 );
                break;

            case FC_ALIGNM8 :
                //
                // We have to play some tricks for the i386 to handle the case
                // when an 8 byte aligned structure is passed by value.  The
                // alignment of the struct on the stack is not guaranteed to be
                // on an 8 byte boundary.
                //
                pMemory -= Align8Mod;
                ALIGN(pMemory, 0x7 );
                pMemory += Align8Mod;

                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                //
                // Increment memory pointer by amount of padding.
                //
                pMemory += (*pFormat - FC_STRUCTPAD1) + 1;
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pMemory += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;
                
            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                goto ComplexMarshallEnd;

            default :
                NDR_ASSERT(0,"NdrComplexStructMarshall : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            } // switch
        } // for

ComplexMarshallEnd:

    //
    // Marshall conformant array if we have one.
    // .. but not when embedded and not when it had been marshaled by conf struct.
    //
    if ( pFormatArray &&  !fIsEmbeddedStruct  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        // Normal case: top level marshaling.

        PPRIVATE_MARSHALL_ROUTINE   pfnPMarshall;


        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnPMarshall = NdrpConformantArrayMarshall;
                break;

            case FC_CVARRAY :
                pfnPMarshall = NdrpConformantVaryingArrayMarshall;
                break;

            case FC_BOGUS_ARRAY :
                pfnPMarshall = NdrpComplexArrayMarshall;
                break;

            case FC_C_WSTRING :
                ALIGN(pMemory,1);
                // fall through

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_SSTRING :

            default :
                pfnPMarshall = NdrpConformantStringMarshall;
                break;
            }

        //
        // Mark where the conformance count(s) will be marshalled.
        //
        pStubMsg->BufferMark = pBufferMark;

        // Marshall the array.
        (*pfnPMarshall)( pStubMsg,
                         pMemory,
                         pFormatArray );
        }

    //
    // Now fix up the stub message Buffer field if we set the PointerBufferMark
    // field.
    //
    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    pStubMsg->Memory = pMemorySave;

    if ( fIsEmbeddedStruct )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );
    return 0;
}


unsigned char * RPC_ENTRY
NdrNonConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a non conformant string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, and FC_BSTRING (NT Beta2
    compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{
    uint        Count;
    uint        CopySize;

    // Align the buffer for offset and count marshalling.
    ALIGN(pStubMsg->Buffer,3);

    switch ( *pFormat )
        {
        case FC_CSTRING :
        case FC_BSTRING :
            CopySize = Count = MIDL_ascii_strlen((char *)pMemory) + 1;
            break;

        case FC_WSTRING :
            Count = wcslen((wchar_t *)pMemory) + 1;
            CopySize = Count * sizeof(wchar_t);
            break;

        case FC_SSTRING :
            Count = NdrpStringStructLen( pMemory, pFormat[1] ) + 1;
            CopySize = Count * pFormat[1];
            break;

        default :
            NDR_ASSERT(0,"NdrNonConformantStringMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Marshall variance.
    *((ulong *&)pStubMsg->Buffer)++ = 0;
    *((ulong *&)pStubMsg->Buffer)++ = Count;

    // Copy the string.
    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update buffer pointer.
    pStubMsg->Buffer += CopySize;

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Marshalls a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{
    if ( pStubMsg->pArrayInfo != 0 )
        {
        //
        // If this is part of a multidimensional array then we get the location
        // where the conformance is marshalled from a special place.
        //
        pStubMsg->BufferMark = ( uchar * )
            &(pStubMsg->pArrayInfo->
                        BufferConformanceMark[pStubMsg->pArrayInfo->Dimension]);
        }
    else
        {
        // Align the buffer for max count marshalling.
        ALIGN(pStubMsg->Buffer,3);

        // Mark where the max count will be marshalled.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment the buffer past where the max count will be marshalled.
        pStubMsg->Buffer += 4;
        }

    // Call the private marshalling routine.
    NdrpConformantStringMarshall( pStubMsg,
                                  pMemory,
                                  pFormat );

    return 0;
}


void
NdrpConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine description :

    Private routine for marshalling a conformant string.  This is the
    entry point for marshalling an embedded conformant strings.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{
    ulong       MaxCount;
    uint        ActualCount, CopySize;
    BOOL        IsSized;

    IsSized = (pFormat[1] == FC_STRING_SIZED);

    // Compute the element count of the string and the total copy size.
    switch ( *pFormat )
        {
        case FC_C_CSTRING :
        case FC_C_BSTRING :
            CopySize = ActualCount = MIDL_ascii_strlen((char *)pMemory) + 1;
            break;

        case FC_C_WSTRING :
            ActualCount = wcslen((wchar_t *)pMemory) + 1;
            CopySize = ActualCount * sizeof(wchar_t);
            break;

        case FC_C_SSTRING :
            ActualCount = NdrpStringStructLen( pMemory, pFormat[1] ) + 1;
            CopySize = ActualCount * pFormat[1];

            // Redo this check correctly.
            IsSized = (pFormat[2] == FC_STRING_SIZED);
            break;

        default :
            NDR_ASSERT(0,"NdrpConformantStringMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // If the string is sized then compute the max count, otherwise the
    // max count is equal to the actual count.
    //
    if ( IsSized )
        {
        MaxCount =  (ulong) NdrpComputeConformance( pStubMsg,
                                                    pMemory,
                                                    pFormat );
        }
    else
        {
        MaxCount = ActualCount;
        }

    // Marshall the max count.
    *((ulong *)pStubMsg->BufferMark) = MaxCount;

    // Align the buffer for variance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Marshall variance.
    *((ulong *&)pStubMsg->Buffer)++ = 0;
    *((ulong *&)pStubMsg->Buffer)++ = ActualCount;

    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update the Buffer pointer.
    pStubMsg->Buffer += CopySize;
}


unsigned char * RPC_ENTRY
NdrFixedArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a fixed array of any number of dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array to be marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    uint   Size;

    // Align the buffer.
    ZeroOutGapAndAlign(pStubMsg,pFormat[1]);

    // Get total array size.
    if ( *pFormat == FC_SMFARRAY )
        {
        pFormat += 2;
        Size = (ulong) *((ushort *&)pFormat)++;
        }
    else // *pFormat == FC_LGFARRAY
        {
        pFormat += 2;
        Size = *((ulong UNALIGNED *&)pFormat)++;
        }

    // Copy the array.
        RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    Size );

    // Increment stub message buffer pointer.
    pStubMsg->Buffer += Size;

    // Marshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        // Mark the start of the array in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - Size;

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level one dimensional conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    // Align the buffer for conformance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Mark where the conformance will be marshalled.
    pStubMsg->BufferMark = pStubMsg->Buffer;

    // Increment past where the conformance will go.
    pStubMsg->Buffer += 4;

    // Call the private marshalling routine to do the work.
    NdrpConformantArrayMarshall( pStubMsg,
                                 pMemory,
                                 pFormat );

    return 0;
}


void
NdrpConformantArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for marshalling a one dimensional conformant array.
    This is the entry point for marshalling an embedded conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ulong       Count;
    uint        CopySize;

    // Compute conformance information.
    Count = (ulong) NdrpComputeConformance( pStubMsg,
                                            pMemory,
                                            pFormat );

    // Marshall the conformance.
    *((ulong *)pStubMsg->BufferMark) = Count;

    //
    // Return if size is 0.
    //
    if ( ! Count )
        return;

    ZeroOutGapAndAlign(pStubMsg,pFormat[1]);

    // Compute the total array size in bytes.
    CopySize = Count * *((ushort *)(pFormat + 2));

    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update buffer pointer.
    pStubMsg->Buffer += CopySize;

    // Increment to possible pointer layout.
    pFormat += 8;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Marshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        //
        // Mark the start of the array in the buffer.
        //
        pStubMsg->BufferMark = pStubMsg->Buffer - CopySize;

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }
}


unsigned char * RPC_ENTRY
NdrConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level one dimensional conformant varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    // Align the buffer for conformance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Mark where the conformance will be marshalled.
    pStubMsg->BufferMark = pStubMsg->Buffer;

    // Increment past where the conformance will go.
    pStubMsg->Buffer += 4;

    // Call the private marshalling routine to do the work.
    NdrpConformantVaryingArrayMarshall( pStubMsg,
                                        pMemory,
                                        pFormat );

    return 0;
}


void
NdrpConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for marshalling a one dimensional conformant varying array.
    This is the entry point for marshalling an embedded conformant varying
    array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array to be marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    uint        CopyOffset, CopySize;
    ushort      ElemSize;

    // Compute and marshall the conformant size.
    *((ulong *)pStubMsg->BufferMark) = (ulong) NdrpComputeConformance( pStubMsg,
                                                                       pMemory,
                                                                       pFormat );

    // Compute variance offset and count.
    NdrpComputeVariance( pStubMsg,
                         pMemory,
                         pFormat );

    // Align the buffer for variance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Marshall variance.
    *((ulong *&)pStubMsg->Buffer)++ = pStubMsg->Offset;
    *((ulong *&)pStubMsg->Buffer)++ = pStubMsg->ActualCount;

    //
    // Return if length is 0.
    //
    if ( ! pStubMsg->ActualCount )
        return;

    ZeroOutGapAndAlign(pStubMsg, pFormat[1]);

    ElemSize = *((ushort *)(pFormat + 2));

    // Compute byte offset and size for the array copy.
    CopyOffset = pStubMsg->Offset * ElemSize;
    CopySize = pStubMsg->ActualCount * ElemSize;

    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory + CopyOffset,
                    CopySize );

    pStubMsg->Buffer += CopySize;

    // Increment to a possible pointer layout.
    pFormat += 12;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    // Marshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        //
        // Set the MaxCount field equal to the ActualCount field.  The pointer
        // marshalling routine uses the MaxCount field to determine the number
        // of times an FC_VARIABLE_REPEAT pointer is marshalled.  In the face
        // of variance the correct number of time is the ActualCount, not the
        // the MaxCount.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        //
        // Mark the start of the array in the buffer.
        //
        pStubMsg->BufferMark = pStubMsg->Buffer - CopySize;

        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory,
                                     pFormat );
        }
}


unsigned char * RPC_ENTRY
NdrVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level or embedded one dimensional varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    uint        CopyOffset, CopySize;
    ushort      ElemSize;

    // Compute the variance offset and count.
    NdrpComputeVariance( pStubMsg,
                         pMemory,
                         pFormat );

    // Align the buffer for variance marshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Marshall variance.
    *((ulong *&)pStubMsg->Buffer)++ = pStubMsg->Offset;
    *((ulong *&)pStubMsg->Buffer)++ = pStubMsg->ActualCount;

    //
    // Return if length is 0.
    //
    if ( ! pStubMsg->ActualCount )
        return 0;

    ZeroOutGapAndAlign(pStubMsg, pFormat[1]);

    // Increment the format string to the element_size field.
    if ( *pFormat == FC_SMVARRAY )
        pFormat += 6;
    else // *pFormat == FC_LGVARRAY
        pFormat += 10;

    // Get element size.
    ElemSize = *((ushort *)pFormat);

    //
    // Compute the byte offset from the beginning of the array for the copy
    // and the number of bytes to copy.
    //
    CopyOffset = pStubMsg->Offset * ElemSize;
    CopySize = pStubMsg->ActualCount * ElemSize;

    // Copy the array.
    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory + CopyOffset,
                    CopySize );

    // Update buffer pointer.
    pStubMsg->Buffer += CopySize;

    // Increment format string to possible pointer layout.
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Marshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        // Mark the start of the array in the buffer.
        pStubMsg->BufferMark = pStubMsg->Buffer - CopySize;

        //
        // Set the MaxCount field equal to the ActualCount field.  The pointer
        // marshalling routine uses the MaxCount field to determine the number
        // of times an FC_VARIABLE_REPEAT pointer is marshalled.  In the face
        // of variance the correct number of time is the ActualCount, not the
        // the MaxCount.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        //
        // Marshall the embedded pointers.
        // Make sure to pass a memory pointer to the first array element
        // which is actually being marshalled.
        //
        NdrpEmbeddedPointerMarshall( pStubMsg,
                                     pMemory + CopyOffset,
                                     pFormat );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrComplexArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    BOOL            fSetPointerBufferMark;
    PFORMAT_STRING  pFormatPP;

    //
    // Setting this flag means that the array is not embedded inside of
    // another complex struct or array.
    //
    pFormatPP = pFormat + 12;
    CORRELATION_DESC_INCREMENT( pFormatPP );
    CORRELATION_DESC_INCREMENT( pFormatPP );

    fSetPointerBufferMark = (! pStubMsg->PointerBufferMark) &&
                            (*pFormatPP != FC_RP);

    if ( fSetPointerBufferMark )
        {
        BOOL    fOldIgnore;
        ULONG_PTR MaxCountSave;
        ulong   Offset, ActualCount;
        ulong   BufferLenOffset;

        //
        // Save the current conformance and variance fields.  The sizing
        // routine can overwrite them.
        //
        MaxCountSave = pStubMsg->MaxCount;
        Offset = pStubMsg->Offset;
        ActualCount = pStubMsg->ActualCount;

        fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        //
        // Set BufferLength equal to the current buffer pointer, and then
        // when we return from NdrComplexArrayBufferSize it will point to
        // the location in the buffer where the pointers should be marshalled
        // into.
        // Instead of pointer, we now calculate pointer increment explicitly.
        //
        // Set the pointer alignment as a base.

        BufferLenOffset = 0xf & PtrToUlong( pStubMsg->Buffer );
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->BufferLength = BufferLenOffset;

        NdrComplexArrayBufferSize( pStubMsg,
                                   pMemory,
                                   pFormat );

        // Pointer increment including alignments.
        BufferLenOffset = pStubMsg->BufferLength - BufferLenOffset;

        //
        // This is the buffer pointer to the position where embedded pointers
        // will be marshalled.
        //
        pStubMsg->PointerBufferMark = pStubMsg->Buffer + BufferLenOffset;
        pStubMsg->BufferLength = BufferLengthSave;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

        // Restore conformance and variance fields.
        pStubMsg->MaxCount = MaxCountSave;
        pStubMsg->Offset = Offset;
        pStubMsg->ActualCount = ActualCount;
        }

    if ( ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff ) &&
         ( pStubMsg->pArrayInfo == 0 ) )
        {
        //
        // Outer most dimension sets the conformance marker.
        //

        // Align the buffer for conformance marshalling.
        ALIGN(pStubMsg->Buffer,3);

        // Mark where the conformance count(s) will be marshalled.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment past where the conformance will go.
        pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormat, FALSE ) * 4;
        }

    // Call the private marshalling routine to do all the work.
    NdrpComplexArrayMarshall( pStubMsg,
                              pMemory,
                              pFormat );

    if ( fSetPointerBufferMark )
        {
        //
        // This will set the buffer pointer to end of all of the array's
        // unmarshalled data in the buffer.
        //
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    return 0;
}


void
NdrpComplexArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for marshalling a complex array.  This is the entry
    point for marshalling an embedded complex array.

    Used for FC_BOGUS_ARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

    pStubMsg->Buffer            - array pointer
    pStubMsg->BufferMark        - a place to marshal the conformant size
    pStubMsg->BufferPointerMark - a place to marshal the pointees
    
Return :

    None.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO         pArrayInfo;
    PMARSHALL_ROUTINE   pfnMarshall;
    PFORMAT_STRING      pFormatStart;
    uint                Elements;
    uint                Offset, Count;
    uint                MemoryElementSize;
    long                Dimension;
    uchar               Alignment;
    bool                UseBrokenInterfacePointerRep = false;

    //
    // Lots of setup if we are the outer dimension.  All this is for
    // multidimensional array support.  If we didn't have to worry about
    // Beta2 stub compatability we could this much better.
    //
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        NdrpInitArrayInfo(pStubMsg, &ArrayInfo );
        }

    pFormatStart = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    // Get the array's alignment.
    Alignment = pFormat[1];

    pFormat += 2;

    // Get number of elements (0 if the array has conformance).
    Elements = *((ushort *&)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = (ulong) NdrpComputeConformance( pStubMsg,
                                                   pMemory,
                                                   pFormatStart );

        // Marshall this dimension's conformance count.
        pArrayInfo->BufferConformanceMark[Dimension] = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        if ( Dimension == 0 )
            {
            //
            // Set the variance marker.
            //

            ALIGN(pStubMsg->Buffer,0x3);

            // Mark where the variance count(s) will be marshalled.
            pArrayInfo->BufferVarianceMark = (unsigned long *) pStubMsg->Buffer;

            // Increment past where the variance will go.
            pStubMsg->Buffer +=
                    NdrpArrayDimensions( pStubMsg, pFormatStart, TRUE ) * 8;
            }

        NdrpComputeVariance( pStubMsg,
                             pMemory,
                             pFormatStart );

        Offset = pStubMsg->Offset;
        Count = pStubMsg->ActualCount;

        //
        // Marshall the outer dimension's variance.
        //
        pArrayInfo->BufferVarianceMark[Dimension * 2] = Offset;
        pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1] = Count;
        }
    else
        {
        Offset = 0;
        Count = Elements;
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Return if count is 0.
    //
    if ( ! Count )
        goto ComplexArrayMarshallEnd;

    // Align on array's alignment.
    ZeroOutGapAndAlign(pStubMsg,Alignment);

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ( FC_IP == *pFormat )
                goto HandleInterfacePointer;

            // Get the proper marshalling routine.
            pfnMarshall = pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)];

            pArrayInfo->Dimension = Dimension + 1;

            // Compute the size of an array element.
            MemoryElementSize = (uint) (NdrpMemoryIncrement( pStubMsg,
                                                             pMemory,
                                                             pFormat ) - pMemory);
            break;

        case FC_RP :
        case FC_UP :
        case FC_FP :
        case FC_OP :
            pfnMarshall = (PMARSHALL_ROUTINE) NdrpPointerMarshall;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_IP :
HandleInterfacePointer:
            UseBrokenInterfacePointerRep = !FixWireRepForDComVerGTE54( pStubMsg );

            // Probably does not exercise this code path, for IP the compiler
            // generates embedded complex as an array element.
            //
            pfnMarshall = (PMARSHALL_ROUTINE) NdrpPointerMarshall;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_ENUM16 :
            pfnMarshall = 0;

            // Need this in case we have a variant offset.
            MemoryElementSize = sizeof(int);
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
        case FC_UINT3264:
            pfnMarshall = 0;
            MemoryElementSize = sizeof(__int64);
            break;
#endif
        case FC_RANGE:
            // let's just memcpy in marshalling phase: don't need to check value here.
            Count *= SIMPLE_TYPE_BUFSIZE( pFormat[1] );
            pMemory += Offset * SIMPLE_TYPE_MEMSIZE( pFormat[1] );

            RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    Count );

            pStubMsg->Buffer += Count;
            break;
            
        default :
            NDR_ASSERT( IS_SIMPLE_TYPE(*pFormat),
                        "NdrpComplexArrayMarshall : bad format char" );

            Count *= SIMPLE_TYPE_BUFSIZE(*pFormat);

            pMemory += Offset * SIMPLE_TYPE_MEMSIZE(*pFormat);

            // Copy the array.
                RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    Count );

            pStubMsg->Buffer += Count;

            goto ComplexArrayMarshallEnd;
        }

    //
    // If there is variance then increment the memory pointer to the first
    // element actually being marshalled.
    //
    if ( Offset )
        pMemory += Offset * MemoryElementSize;

    //
    // Array of enum16 or int3264.
    //
    if ( ! pfnMarshall )
        {
      #if defined(__RPC_WIN64__)
        if ( *pFormat != FC_ENUM16 )
            {
            for ( ; Count--; )
                *((long * &)pStubMsg->Buffer)++ = (long)*((INT64 * &)pMemory)++;
            }
        else
      #endif
            {
            for ( ; Count--; )
                {
                if ( *((int *)pMemory) & ~((int)0x7fff) )
                    RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);

                *((ushort *&)pStubMsg->Buffer)++ = (ushort) *((int *&)pMemory)++;
                }
            }

        goto ComplexArrayMarshallEnd;
        }

    //
    // For 32b, an array of ref or interface pointers.
    // For 64b, an array of any pointers.
    //
    if ( pfnMarshall == (PMARSHALL_ROUTINE) NdrpPointerMarshall )
        {
        pStubMsg->pArrayInfo = 0;

        uchar * pPointerId = (*pFormat == FC_RP) ? 0 : pStubMsg->Buffer;

        if ( UseBrokenInterfacePointerRep )
            {
            // If were using the broken array format, do no increment the
            // buffer pointer for the flat part, and throw everything
            // where the pointee should go.
            SET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

            POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
            for ( ; Count--; )
                {

                // This effectively calls NdrInterfacePointerMarshall.  Doinging
                // this so another queue structure/callback isn't needed just for
                // this rare code.
                NdrpPointerMarshall( 
                    pStubMsg,
                    pPointerId,
                    *((uchar **&)pMemory)++,
                    pFormat );
                pPointerId += PTR_WIRE_SIZE;
                }
            RESET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );
            }

        else
        {
            {
                POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
                for ( ; Count--; )
                    {

                    NdrpPointerMarshall( 
                        pStubMsg,
                        pPointerId,
                        *((uchar **&)pMemory)++,
                        pFormat );
                    //
                    // Needed only for non ref pointers, but pPointerIds is not used for refs.
                    //
                    pPointerId += PTR_WIRE_SIZE;
                    }
            }
            
            // Increment buffer pointer past the flat part of the array.
            if ( *pFormat != FC_RP )
                pStubMsg->Buffer = pPointerId;

        }


        goto ComplexArrayMarshallEnd;
        }

    //
    // It's an array of complex types.
    //

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        pStubMsg->pArrayInfo = 0;

    // Marshall the array elements.
    for ( ; Count--; )
        {
        // Keep track of multidimensional array dimension.
        if ( IS_ARRAY_OR_STRING(*pFormat) )
            pArrayInfo->Dimension = Dimension + 1;

        (*pfnMarshall)( pStubMsg,
                        pMemory,
                        pFormat );

        // Increment the memory pointer by the element size.
        pMemory += MemoryElementSize;
        }

ComplexArrayMarshallEnd:

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;
}


unsigned char * RPC_ENTRY
NdrEncapsulatedUnionMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls an encapsulated union.

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being marshalled.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;
    uchar   SwitchType;

    NO_CORRELATION;

    SwitchType = LOW_NIBBLE(pFormat[1]);

    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char *)pMemory);
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar *)pMemory);
            break;

        case FC_ENUM16 :
        case FC_SHORT :
            SwitchIs = (long) *((short *)pMemory);
            break;

        case FC_USHORT :
        case FC_WCHAR :
            SwitchIs = (long) *((ushort *)pMemory);
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG
            SwitchIs = *((long *)pMemory);
            break;
        default :
            NDR_ASSERT(0,"NdrEncapsulatedUnionMarshall : bad swith type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Increment the memory pointer to the union.
    pMemory += HIGH_NIBBLE(pFormat[1]);

    NdrpUnionMarshall( pStubMsg,
                       pMemory,
                       pFormat + 2,
                       SwitchIs,
                       SwitchType );

    return 0;
}


unsigned char * RPC_ENTRY
NdrNonEncapsulatedUnionMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a non encapsulated union.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being marshalled.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    long    SwitchIs;
    uchar   SwitchType;

    SwitchType = pFormat[1];

    SwitchIs = (ulong) NdrpComputeSwitchIs( pStubMsg,
                                            pMemory,
                                            pFormat );

    //
    // Set the format string to the memory size and arm description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    NdrpUnionMarshall( pStubMsg,
                       pMemory,
                       pFormat,
                       SwitchIs,
                       SwitchType );

    return 0;
}


void
NdrpUnionMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                SwitchIs,
    uchar               SwitchType )
/*++

Routine Description :

    Private routine for marshalling a union.  This routine is shared for
    both encapsulated and non-encapsulated unions and handles the actual
    marshalling of the proper union arm.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being marshalled.
    pFormat     - The memory size and arm description portion of the format
                  string for the union.
    SwitchIs    - Union's switch is.
    SwitchType  - Union's switch is type.

Return :

    None.

--*/
{
    long    Arms;
    uchar   Alignment;

    // Marshall the switch is value.
    NdrSimpleTypeMarshall( pStubMsg,
                           (uchar *)&SwitchIs,
                           SwitchType );

    // Skip the memory size field.
    pFormat += 2;

    //
    // We're at the union_arms<2> field now, which contains both the
    // Microsoft union aligment value and the number of union arms.
    //

    //
    // Get the union alignment (0 if this is a DCE union).
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    ZeroOutGapAndAlign(pStubMsg,Alignment);

    //
    // Number of arms is the lower 12 bits.
    //
    Arms = (long) ( *((ushort *&)pFormat)++ & 0x0fff);

    //
    // Search for the correct arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED *&)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm is empty.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        NdrSimpleTypeMarshall( pStubMsg,
                               pMemory,
                               pFormat[0] );

        return;
        }

    pFormat += *((signed short *)pFormat);

    //
    // If the union arm we take is a pointer, we have to dereference the
    // current memory pointer since we're passed a pointer to the union
    // (regardless of whether the actual parameter was a by-value union
    // or a pointer to a union).
    //
    // We also have to do a bunch of other special stuff to handle unions
    // embedded inside of strutures.
    //
    if ( IS_POINTER_TYPE(*pFormat) )
        {
        pMemory = *((uchar **)pMemory);
        
        //
        // If we're embedded in a struct or array we have do some extra stuff.
        //
        if ( pStubMsg->PointerBufferMark )
            {

            ALIGN(pStubMsg->Buffer,3);
            uchar *pPointerId = pStubMsg->Buffer;
            pStubMsg->Buffer += PTR_WIRE_SIZE;

            POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

            NdrpPointerMarshall( pStubMsg,
                                 pPointerId,
                                 pMemory,
                                 pFormat );
            return;
            }
        }

    //
    // Union arm of a non-simple type.
    //
    (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])
    ( pStubMsg,
      pMemory,
      pFormat );
}


unsigned char * RPC_ENTRY
NdrByteCountPointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a pointer with the byte count attribute applied to it.

    Used for FC_BYTE_COUNT_POINTER.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the byte count pointer being marshalled.
    pFormat     - Byte count pointer's format string description.

Return :

    None.

--*/
{
    //
    // We don't do anything special here.  Just pass things on to the
    // right marshalling routine.
    //
    if ( pFormat[1] != FC_PAD )
        {
        NdrSimpleTypeMarshall( pStubMsg,
                               pMemory,
                               pFormat[1] );
        }
    else
        {
        pFormat += 6;
        CORRELATION_DESC_INCREMENT( pFormat );
        pFormat += *((signed short *)pFormat);

        (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                         pMemory,
                                                         pFormat );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrXmitOrRepAsMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a transmit as or represent as argument:
        - translate the presented object into a transmitted object
        - marshall the transmitted object
        - free the transmitted object

    Format string layout:

         0  FC_TRANSMIT_AS or FC_REPRESENT_AS
            Oi array flag/alignment<1>
        +2  quintuple index<2>
        +4  pres type mem size<2>
        +6  tran type buf size<2>
        +8  offset<2>

Arguments :

    pStubMsg    - a pointer to the stub message
    pMemory     - presented type translated into transmitted type
                  and than to be marshalled
    pFormat     - format string description

--*/
{
    unsigned char *                pTransmittedType;
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;
    unsigned short                 QIndex;
    BOOL                           fXmitByPtr = *pFormat == FC_TRANSMIT_AS_PTR ||
                                                *pFormat == FC_REPRESENT_AS_PTR;

    // Skip the token itself and Oi flag. Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);

    // First translate the presented type into the transmitted type.
    // This includes an allocation of a transmitted type object.

    pStubMsg->pPresentedType = pMemory;
    pStubMsg->pTransmitType = NULL;
    pQuintuple[ QIndex ].pfnTranslateToXmit( pStubMsg );

    // Marshall the transmitted type.

    pFormat += 8;
    pFormat = pFormat + *(short *) pFormat;

    pTransmittedType = pStubMsg->pTransmitType;
    if ( IS_SIMPLE_TYPE( *pFormat ))
        {
        NdrSimpleTypeMarshall( pStubMsg,
                               pTransmittedType,
                               *pFormat );
        }
    else
        {
        uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        NDR_POINTER_QUEUE *pOldQueue = NULL;

        // Reset the current queue to NULL so that all the pointers
        // in the transmitted type will be queued and marshalled togother.
        if ( pStubMsg->pPointerQueueState )
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormat)])
                ( pStubMsg,
                  fXmitByPtr  ?  *(uchar **)pTransmittedType
                              :  pTransmittedType,
                  pFormat );
            }
        RpcFinally
            {
            pStubMsg->PointerBufferMark = PointerBufferMarkSave;
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally
        }
    pStubMsg->pTransmitType = pTransmittedType;

    // Free the temporary transmitted object (it was allocated by the user).

    pQuintuple[ QIndex ].pfnFreeXmit( pStubMsg );

    return 0;
}


void
NdrpUserMarshalMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    unsigned long *     pWireMarkerPtr )
/*++

Routine Description :

    Marshals a usr_marshall object.

    The format string layout is as follows:

        FC_USER_MARSHAL
        flags & alignment<1>
        quadruple index<2>
        memory size<2>
        wire size<2>
        type offset<2>

    The wire layout description is at the type offset.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the usr_marshall object to marshall.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    const USER_MARSHAL_ROUTINE_QUADRUPLE *  pQuadruple;
    unsigned short                          QIndex;
    unsigned char *                         pUserBuffer;
    USER_MARSHAL_CB                         UserMarshalCB;
    unsigned char *                         pUserBufferSaved;

    pUserBufferSaved = pUserBuffer = pStubMsg->Buffer;

    // We always call user's routine to marshall.
    NdrpInitUserMarshalCB( pStubMsg,
                           pFormat,
                           USER_MARSHAL_CB_MARSHALL,  
                           & UserMarshalCB );

    QIndex     = *(unsigned short *)(pFormat + 2);
    pQuadruple = pStubMsg->StubDesc->aUserMarshalQuadruple;   

    if ((pUserBufferSaved < (uchar *) pStubMsg->RpcMsg->Buffer) ||
        ((unsigned long) (pUserBufferSaved - (uchar *) pStubMsg->RpcMsg->Buffer) 
                                           > pStubMsg->RpcMsg->BufferLength)) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        } 

    pUserBuffer = pQuadruple[ QIndex ].pfnMarshall( (ulong*) &UserMarshalCB,
                                                    pUserBuffer,
                                                    pMemory );

    if ((pUserBufferSaved > pUserBuffer) || 
        ((unsigned long) (pUserBuffer - (uchar *) pStubMsg->RpcMsg->Buffer)
                                      > pStubMsg->RpcMsg->BufferLength )) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    if ( pUserBuffer == pUserBufferSaved )
        {
        // This is valid only if the wire type was a unique type.

        if ( (pFormat[1] & USER_MARSHAL_UNIQUE) )
            {
            *pWireMarkerPtr = 0;
            return;
            }
        else
            RpcRaiseException( RPC_X_NULL_REF_POINTER );
        }

	pStubMsg->Buffer = pUserBuffer;
    return;
}

void 
NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    NdrpUserMarshalMarshall( pStubMsg,
                             pMemory,
                             pFormat,
                             pWireMarkerPtr );
}

#if defined(DBG)
void 
NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pWireMarkerPtr:          %p\n", pWireMarkerPtr );
}
#endif

unsigned char * RPC_ENTRY
NdrUserMarshalMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{
    
    unsigned long *                         pWireMarkerPtr = 0;
    // Align for the object or a pointer to it.

    ZeroOutGapAndAlign( pStubMsg, LOW_NIBBLE(pFormat[1]) );

    if ( pFormat[1] & USER_MARSHAL_POINTER )
        {

        if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  ||
             ((pFormat[1] & USER_MARSHAL_REF) && pStubMsg->PointerBufferMark) )
            {
            pWireMarkerPtr = (unsigned long *) pStubMsg->Buffer;
            *((unsigned long *&)pStubMsg->Buffer)++ = USER_MARSHAL_MARKER;
            }

        if ( !pStubMsg->pPointerQueueState ||
             !pStubMsg->pPointerQueueState->GetActiveQueue() )
            {
            // If we are embedded, switch to the pointee buffer.
            POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

            NdrpUserMarshalMarshall( pStubMsg,
                                     pMemory,
                                     pFormat,
                                     pWireMarkerPtr );
            }
        else
            {
            NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT*pElement = 
               new(pStubMsg->pPointerQueueState) 
                   NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT(pMemory,
                                                             pFormat,
                                                             pWireMarkerPtr);
            pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
            }

        return 0;
        }

    NdrpUserMarshalMarshall( pStubMsg,
                             pMemory,
                             pFormat,
                             pWireMarkerPtr );
    return 0;
}



unsigned char *
NdrpInterfacePointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the interface pointer being marshalled.
    pFormat     - Interface pointer's format string description.

Return :

    None.

Notes : There is now one representation of a marshalled interface pointer.
        The format string contains FC_IP followed by either
        FC_CONSTANT_IID or FC_PAD.

            typedef struct
            {
                unsigned long size;
                [size_is(size)] byte data[];
            }MarshalledInterface;

--*/
{
    HRESULT         hr;
    IID             iid;
    IID *           piid;
    unsigned long * pSize;
    unsigned long * pMaxCount;
    unsigned long   cbData = 0;
    unsigned long   cbMax;
    unsigned long   position;
    IStream *       pStream;
    LARGE_INTEGER   libMove;
    ULARGE_INTEGER  libPosition;

    ALIGN(pStubMsg->Buffer,0x3);
    //
    // Get an IID pointer.
    //
    if ( pFormat[1] != FC_CONSTANT_IID )
        {
        //
        // This is like computing a variance with a long.
        //

        piid = (IID *) NdrpComputeIIDPointer( pStubMsg,
                                              pMemory,
                                              pFormat );
        if(piid == 0)
            RpcRaiseException( RPC_S_INVALID_ARG );
        }
    else
        {
        // 
        // The IID may not be aligned properly in the format string,
        // so we copy it to a local variable.
        //

        // we don't need to zero out the end pad as the size is 16.
        piid = &iid;
        RpcpMemoryCopy( &iid, &pFormat[2], sizeof(iid) );
        }

    // Leave space in the buffer for the conformant size and the size field.

    pMaxCount = (unsigned long *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(unsigned long);

    pSize = (unsigned long *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(unsigned long);

    if(pMemory)
        {

        //Calculate the maximum size of the stream.

        position = (ulong)( pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer);
        cbMax = pStubMsg->RpcMsg->BufferLength - position;

        //Create a stream on memory.

        pStream = NdrpCreateStreamOnMemory(pStubMsg->Buffer, cbMax);
        if(pStream == 0)
            RpcRaiseException(RPC_S_OUT_OF_MEMORY);

        hr = (*pfnCoMarshalInterface)(pStream, *piid, (IUnknown *)pMemory, pStubMsg->dwDestContext, pStubMsg->pvDestContext, 0);
        if(FAILED(hr))
            {
            pStream->Release();
            pStream = 0;
            RpcRaiseException(hr);
            }

        //Calculate the size of the data written

        libMove.LowPart = 0;
        libMove.HighPart = 0;
        pStream->Seek(libMove, STREAM_SEEK_CUR, &libPosition);
        pStream->Release();
        pStream = 0;
        cbData = libPosition.LowPart;
        }

    //Update the array bounds.

    *pMaxCount = cbData;
    *pSize = cbData;

    //Advance the stub message buffer pointer.
    pStubMsg->Buffer += cbData;

    return 0;
}

unsigned char * RPC_ENTRY
NdrInterfacePointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
{

    // Always put the pointer itself on wire, it behaves like a unique.
    //

    // This function is only called for toplevel interface pointers with Os mode,
    // or when being backward compatible with the incorrect wire format.
    // Oicf uses NdrPointerMarshall.

    ALIGN(pStubMsg->Buffer,0x3);
    *((ulong *&)pStubMsg->Buffer)++ = PTR_WIRE_REP(pMemory, pStubMsg );

    // If the pointer is null, it's done.

    if ( pMemory == 0 )
        return 0;


    return
    NdrpInterfacePointerMarshall( 
        pStubMsg,
        pMemory,
        pFormat );
}


//
// Context handle marshalling routines.
//

void RPC_ENTRY
NdrClientContextMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_CCONTEXT        ContextHandle,
    int                 fCheck )
/*++

Routine Description :

    Marshalls a context handle on the client side.

Arguments :

    pStubMsg        - Pointer to stub message.
    ContextHandle   - Context handle to marshall.
    fCheck          - TRUE if an exception check should be made on the handle,
                      FALSE otherwise.

Return :

    None.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called NdrMarshallHandle
    // and can be found in hndl.c

    if ( fCheck && ! ContextHandle )
        RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

    ALIGN(pStubMsg->Buffer,3);

    // This call will check for bogus handles now and will raise
    // an exception when necessary.

    NDRCContextMarshall( ContextHandle, pStubMsg->Buffer );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

void RPC_ENTRY
NdrServerContextMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        ContextHandle,
    NDR_RUNDOWN         RundownRoutine )
/*++

Routine Description :

    Marshalls a context handle on the server side.

Arguments :

    pStubMsg        - Pointer to stub message.
    ContextHandle   - Context handle to marshall.
    RundownRoutine  - The context rundown routine.

Return :

    None.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called NdrMarshallHandle
    // and can be found in hndl.c

    ALIGN(pStubMsg->Buffer,3);

    NDRSContextMarshall2(pStubMsg->RpcMsg->Handle,
                         ContextHandle,
                         pStubMsg->Buffer,
                         RundownRoutine,
                         RPC_CONTEXT_HANDLE_DEFAULT_GUARD,
                         RPC_CONTEXT_HANDLE_DEFAULT_FLAGS );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

void RPC_ENTRY
NdrServerContextNewMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        ContextHandle,
    NDR_RUNDOWN         RundownRoutine,
    PFORMAT_STRING      pFormat )
/*
    This is a non-optimized NDR engine entry for context handle marshaling.
    In particular it is able to handle all the new NT5 context handle flavors.
    The optimized routine follows below.
    
      ContextHandle - note, this is not the user's handle but a
                      NDR_SCONTEXT pointer from the stub local stack. 
                      User's handle is a field in that object.
                
    Note that intepreter calls NdrMarshallHandle. However, we can't use it 
    as it assumes a helper array of saved context handles that we don't need.
   
*/
{   
    void *  pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD   Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pFormat[1] & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pFormat[1] & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pFormat[1] & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    ALIGN( pStubMsg->Buffer, 0x3 );

    NDRSContextMarshall2( 
        pStubMsg->RpcMsg->Handle,
        ContextHandle,
        pStubMsg->Buffer,
        RundownRoutine,
        pGuard,
        Flags );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}


void
NdrpGetArraySizeLength (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long                ElementSize,
    long *              pSize,
    long *              pLength,
    long *              pWireSize )
/*++

Routine Description :

    Return the size and length of an array.

    We need to have this routine rather than just calling BufferSize since
    we need the actual length of the array, not the length plus whatever 
    goop the NDR format puts in from of it.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the local array.
    pFormat     - Pointer to the array to get the size of.

Return :

    The size and length.

Notes:

--*/
{
    switch ( *pFormat )
        {
        case FC_SMFARRAY:
            *pWireSize = * (short *) ( pFormat + 2 );
            *pSize     = *pWireSize;
            *pLength   = *pSize;    
            return;

        case FC_LGFARRAY:
            *pWireSize = * (int *) ( pFormat + 2 );
            *pSize     = *pWireSize;
            *pLength   = *pSize;
            return;

        case FC_CARRAY:
            *pSize     = (long) NdrpComputeConformance( pStubMsg, pMemory, pFormat );
            *pWireSize = *pLength * ElementSize;
            *pLength   = *pSize;
            return;

        case FC_LGVARRAY:
            *pWireSize = * (long *) ( pFormat + 2 );
            *pSize     = * (short *) ( pFormat + 6 );
            NdrpComputeVariance( pStubMsg, pMemory, pFormat );
            *pLength   = pStubMsg->ActualCount;
            return;

        case FC_SMVARRAY:
            *pWireSize = * (short *) ( pFormat + 2 );
            *pSize     = * (short *) ( pFormat + 4 );
            NdrpComputeVariance( pStubMsg, pMemory, pFormat );
            *pLength   = pStubMsg->ActualCount;
            return;

        case FC_CVARRAY:
            *pSize     = (long) NdrpComputeConformance( pStubMsg, pMemory, pFormat );
            *pWireSize = *pSize * ElementSize;
            NdrpComputeVariance( pStubMsg, pMemory, pFormat );
            *pLength   = pStubMsg->ActualCount;
            return;

        case FC_CSTRING:
            *pSize     = strlen( (char*)pMemory ) + 1;
            *pWireSize = *pSize;
            *pLength   = *pSize;
            return;

        case FC_WSTRING:
            *pSize     = wcslen( (wchar_t *) pMemory ) + 1;
            *pWireSize = *pSize * 2;
            *pLength   = *pSize;
            return;
        }

    NDR_ASSERT( 0, "NdrpGetArraySizeLength: Unhandled type" );
    RpcRaiseException( RPC_S_INTERNAL_ERROR );
    *pSize     = 0;
    *pWireSize = 0;
    *pLength   = 0;
}


#ifdef _CS_CHAR_
unsigned char * RPC_ENTRY
NdrCsTagMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a cs tag (i.e. a parameter marked with [cs_stag], [cs_drtag],
    or [cs_rtag].

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the value on the stack.
    pFormat     - Pointer to the FC_CS_TAG entry in the format string.

Return :

    None.

--*/
{
    ulong   Codeset = NdrpGetSetCSTagMarshall( 
                                pStubMsg,
                                pMemory,
                                (NDR_CS_TAG_FORMAT *) pFormat);

    * (ulong *) pStubMsg->Buffer = Codeset;
    pStubMsg->Buffer += sizeof( ulong );
    
    return 0;
}

extern const byte NdrpArrayMarshallFlags[] = 
{
    MARSHALL_CONFORMANCE,                       // Conformant array
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant varying
    0,                                          // Small fixed
    0,                                          // Large fixed
    MARSHALL_VARIANCE,                          // Small varying
    MARSHALL_VARIANCE,                          // Large varying
    MARSHALL_BOGUS,                             // Bogus array
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant C string
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant byte string
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant struct string
    MARSHALL_CONFORMANCE | MARSHALL_VARIANCE,   // Conformant Unicode string
    MARSHALL_VARIANCE,                          // C string
    MARSHALL_VARIANCE,                          // byte string
    MARSHALL_VARIANCE,                          // struct string
    MARSHALL_VARIANCE                           // Unicode string
};
     
    

void 
NdrpUpdateArrayProlog(
    PFORMAT_STRING      pFormat,
    uchar *             BufferMark,
    ulong               WireSize,
    ulong               Offset,
    ulong               WireLength )
{
    int flags;

    NDR_ASSERT( *pFormat >= FC_CARRAY,  "Invalid array descriptor" );
    NDR_ASSERT( *pFormat <= FC_WSTRING, "Invalid array descriptor" );

    // We don't support bogus arrays for now
    NDR_ASSERT( *pFormat != FC_BOGUS_ARRAY, "Bogus arrays are not supported" );

    flags = NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ];

    if ( flags & MARSHALL_CONFORMANCE )
        {
        * (ulong *) BufferMark = WireSize;
        BufferMark += 4;
        }

    if ( flags & MARSHALL_VARIANCE )
        {
        * (ulong *) BufferMark = Offset;
        BufferMark += 4;
        * (ulong *) BufferMark = WireLength;
        }
}


unsigned char * RPC_ENTRY
NdrCsArrayMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Marshalls a [cs_char] array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the local array.
    pFormat     - Pointer to the FC_CSARRAY entry in the format string.

Return :

    None.

Notes :
    
    Arrays of [cs_char] are defined as arrays of bytes on the wire so
    marshalling is pretty simple once you know which bytes to marshall and
    how many of them.  Since the existing array marshalling routines are not
    very general (they don't take size/length parameters) and since the
    overhead of a call to memcpy isn't very high we do the marshalling
    ourselves.

--*/
{
    ulong           SendingCodeset;
    ulong           ReceivingCodeset;
    ulong           ArraySize;
    ulong           ArrayLength;
    ulong           WireSize;
    ulong           WireLength;
    uchar          *BufferMark;
    error_status_t  status;

    NDR_CS_ARRAY_FORMAT            *pCSFormat;
    NDR_CS_SIZE_CONVERT_ROUTINES   *CSRoutines;
    CS_TYPE_NET_SIZE_ROUTINE        NetSizeRoutine;
    CS_TYPE_TO_NETCS_ROUTINE        ToNetCSRoutine;
    IDL_CS_CONVERT                  ConversionType;
    
    pCSFormat = (NDR_CS_ARRAY_FORMAT *) pFormat;

    // Get all the info out of the FC_CS_ARRAY structure and bump pFormat
    // to point to the underlying data descriptor

    NDR_ASSERT( NULL != pStubMsg->pCSInfo, "cs_char info is not set up");

    if ( pStubMsg->IsClient )
        SendingCodeset = pStubMsg->pCSInfo->WireCodeset;
    else
        SendingCodeset = pStubMsg->pCSInfo->DesiredReceivingCodeset;

    CSRoutines = pStubMsg->StubDesc->CsRoutineTables->pSizeConvertRoutines;

    NetSizeRoutine = CSRoutines[pCSFormat->CSRoutineIndex].pfnNetSize;
    ToNetCSRoutine = CSRoutines[pCSFormat->CSRoutineIndex].pfnToNetCs;

    pFormat += pCSFormat->DescriptionOffset;

    // Get the size and length of the unconverted array.

    NdrpGetArraySizeLength( pStubMsg,
                            pMemory,
                            pFormat,
                            pCSFormat->UserTypeSize,
                            (long*)&ArraySize,
                            (long*)&ArrayLength,
                            (long*)&WireSize );

    // Figure out whether we need to convert the data

    WireSize = ArraySize;

    NetSizeRoutine(
                pStubMsg->RpcMsg->Handle,
                SendingCodeset,
                ArraySize,
                &ConversionType,
                NdrpIsConformantArray( pFormat ) ? &WireSize : NULL,
                &status);

    if ( RPC_S_OK != status )
        RpcRaiseException( status );

    // Skip the buffer ahead to where the actual bits will go.  We'll patch
    // up the array prolog later.

    ALIGN( pStubMsg->Buffer, 3 );

    BufferMark = pStubMsg->Buffer;
    pStubMsg->Buffer += NdrpArrayPrologLength( pFormat );

    // If we need to convert do so, otherwise just memcpy
    
//    WireLength = WireSize;
    WireLength = ArrayLength * pCSFormat->UserTypeSize;

    if ( IDL_CS_NO_CONVERT == ConversionType )
        {
        CopyMemory( pStubMsg->Buffer, pMemory, WireLength );
        pStubMsg->Buffer += WireLength;
        }
    else
        {
        ToNetCSRoutine(
                pStubMsg->RpcMsg->Handle,
                SendingCodeset,
                pMemory,
                ArrayLength,
                pStubMsg->Buffer,
//                ! NdrpIsVaryingArray( pFormat ) ? NULL : &WireLength,
                NdrpIsFixedArray( pFormat ) ? NULL : &WireLength,
                &status);

        if ( RPC_S_OK != status )
            RpcRaiseException( status );

        NDR_ASSERT( 
                WireLength <= WireSize, 
                "Buffer overflow during [cs_char] conversion");

        pStubMsg->Buffer += WireLength;
/*
        // For conformant or fixed arrays we must have WireSize bytes on the
        // wire so pad it out if necessary

        if ( ! NdrpIsVaryingArray( pFormat ) && WireLength < WireSize )
            {
            // REVIEW: Is zero'ing necessary?
            ZeroMemory( pStubMsg->Buffer, WireSize - WireLength );
            pStubMsg->Buffer += WireSize - WireLength;
            }
*/
        if ( ! NdrpIsVaryingArray( pFormat ) )
            WireSize = WireLength;
        }

    NdrpUpdateArrayProlog( 
            pFormat, 
            BufferMark, 
            WireSize, 
            pStubMsg->Offset,
            WireLength );

    return 0;
}
#endif // _CS_CHAR


void
RPC_ENTRY
NdrPartialIgnoreClientMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    void *                              pMemory
    )
{
    ALIGN( pStubMsg->Buffer, 0x3 );
    *(ulong *)pStubMsg->Buffer = pMemory ? 1 : 0;
    pStubMsg->Buffer += PTR_WIRE_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\misc.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    misc.c

Abstract :

    Contains miscelaneous helper routines.

Author :

    David Kays  dkays   December 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "attack.h"

uchar *
NdrpMemoryIncrement( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat 
    )
/*++

Routine Description :

    Returns a memory pointer incremeted past a complex data type.  This routine
    is also overloaded to compute the size of a complex data type by passing
    a 0 memory pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the complex type, or 0 if a size is being computed.
    pFormat     - Format string description.

Return :

    A memory pointer incremented past the complex type.  If a 0 memory pointer
    was passed in then the returned value is the size of the complex type.

--*/
{
    long    Elements;
    long    ElementSize;

    switch ( *pFormat )
        {
        //
        // Structs
        //
        case FC_STRUCT :
        case FC_PSTRUCT :
        case FC_HARD_STRUCT :
            pMemory += *((ushort *)(pFormat + 2));
            break;

        case FC_CSTRUCT :
        case FC_CVSTRUCT :
        case FC_CPSTRUCT :
            pMemory += *((ushort *)(pFormat + 2));
        
            // Get conformant array or string description.
            pFormat += 4;
            pFormat += *((signed short *)pFormat);

            // This flag is set by the endianess pass only.
            if ( ! IS_TOPMOST_CONF_STRUCT( pStubMsg->uFlags ) )
                {
                // When embedding in a bogus struct, array is accounted
                // at the conf struct level, due to pointer layout.
                // Get the memory pointer past the conformant array.
                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormat );
                }
            break;

        case FC_BOGUS_STRUCT :
            pMemory += *((ushort *)(pFormat + 2));
            
            pFormat += 4;

            // Check for a conformant array or string in the struct.
            if ( *((signed short *)pFormat) )
                {
                pFormat += *((signed short *)pFormat);

                if ( !IS_EMBED_CONF_STRUCT( pStubMsg->uFlags )  &&
                     ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
                    {
                    // Get the memory pointer past the conformant array.
                    pMemory = NdrpMemoryIncrement( pStubMsg,
                                                   pMemory,
                                                   pFormat );
                    }
                }
            break;

        //
        // Unions
        //
        case FC_ENCAPSULATED_UNION :
            pMemory += HIGH_NIBBLE(pFormat[1]);
            pMemory += *((ushort *)(pFormat + 2));
            break;

        case FC_NON_ENCAPSULATED_UNION :
            // Go to the size/arm description.
            pFormat += 6;
            CORRELATION_DESC_INCREMENT( pFormat );
            pFormat += *((signed short *)pFormat);
        
            pMemory += *((ushort *)pFormat);
            break;

        //
        // Arrays
        //
        case FC_SMFARRAY :
        case FC_SMVARRAY :
            pMemory += *((ushort *)(pFormat + 2));
            break;

        case FC_LGFARRAY :
        case FC_LGVARRAY :
            pMemory += *((ulong UNALIGNED *)(pFormat + 2));
            break;

        case FC_CARRAY:
        case FC_CVARRAY:
                {
                ULONG_PTR ConfSize =  NdrpComputeConformance( pStubMsg, 
                                               pMemory, 
                                               pFormat);
                // check for possible mulitplication overflow attack here.
                pMemory += MultiplyWithOverflowCheck(  ConfSize, *((ushort *)(pFormat + 2)) );
                }
            break;

        case FC_BOGUS_ARRAY :
            {
            PARRAY_INFO pArrayInfo = pStubMsg->pArrayInfo;

            if ( *((long UNALIGNED *)(pFormat + 4)) == 0xffffffff )
                Elements = *((ushort *)(pFormat + 2));
            else
                {
                if ( pArrayInfo && 
                     pArrayInfo->MaxCountArray &&
                     (pArrayInfo->MaxCountArray ==  
                      pArrayInfo->BufferConformanceMark) )
                    {
                    Elements = pArrayInfo->MaxCountArray[pArrayInfo->Dimension];
                    }
                else
                    {
                    Elements = (ulong) NdrpComputeConformance( pStubMsg,
                                                               pMemory,
                                                               pFormat );
                    }
                }

            // Go to the array element's description.
            pFormat += 12;
            CORRELATION_DESC_INCREMENT( pFormat );
            CORRELATION_DESC_INCREMENT( pFormat );

            // 
            // Get the size of one element.
            //
            switch ( *pFormat )
                {
                case FC_ENUM16 :
                    ElementSize = sizeof(int);
                    break;

                case FC_RP :
                case FC_UP :
                case FC_FP :
                case FC_OP :
                    ElementSize = PTR_MEM_SIZE;
                    break;

                case FC_EMBEDDED_COMPLEX :
                    //
                    // It's some complicated thingy.
                    //
                    pFormat += 2;
                    pFormat += *((signed short *)pFormat);

                    if ( (*pFormat == FC_TRANSMIT_AS) || 
                         (*pFormat == FC_REPRESENT_AS) ||
                         (*pFormat == FC_USER_MARSHAL) )
                        {
                        //
                        // Get the presented type size.
                        //
                        ElementSize = *((ushort *)(pFormat + 4));
                        }
                    else
                        {
                        if ( pArrayInfo ) 
                            pArrayInfo->Dimension++;

                        ElementSize = (long)
                                     ( NdrpMemoryIncrement( pStubMsg,
                                                            pMemory,
                                                            pFormat ) - pMemory );

                        if ( pArrayInfo ) 
                            pArrayInfo->Dimension--;
                        }
                    break;

                case FC_RANGE:
                        ElementSize = SIMPLE_TYPE_MEMSIZE( (pFormat[1] & 0x0f) );
                        break;

                default :
                    if ( IS_SIMPLE_TYPE(*pFormat) )
                        {
                        ElementSize = SIMPLE_TYPE_MEMSIZE(*pFormat);
                        break;
                        }

                    NDR_ASSERT(0,"NdrpMemoryIncrement : bad format char");
                    RpcRaiseException( RPC_S_INTERNAL_ERROR );
                    return 0;
                }

            // check for possible mulitplication overflow attack here.
            pMemory += MultiplyWithOverflowCheck(  Elements, ElementSize );
            }

            break;

        //
        // String arrays (a.k.a. non-conformant strings).
        //
        case FC_CSTRING :
        case FC_BSTRING :
        case FC_WSTRING :
                {
                ULONG ElementSize = (*pFormat == FC_WSTRING) ? sizeof(wchar_t) : sizeof(char) ;
                ULONG Elements = *((ushort *)(pFormat + 2)) ;
                // check for possible mulitplication overflow attack here.
                pMemory += MultiplyWithOverflowCheck(  Elements, ElementSize );  
                }
            break;

        case FC_SSTRING :
            // check for possible mulitplication overflow attack here.
            pMemory += MultiplyWithOverflowCheck( pFormat[1], *((ushort *)(pFormat + 2) ) );
            break;

        //
        // Sized conformant strings.
        //
        case FC_C_CSTRING:
        case FC_C_BSTRING:
        case FC_C_WSTRING:
            {
            PARRAY_INFO pArrayInfo = pStubMsg->pArrayInfo;
            ULONG ElementSize =  (*pFormat == FC_C_WSTRING) ? 
                                sizeof(wchar_t) : 
                                sizeof(char);

            NDR_ASSERT(pFormat[1] == FC_STRING_SIZED, 
                       "NdrpMemoryIncrement : called for non-sized string");

            if ( pArrayInfo && 
                 pArrayInfo->MaxCountArray &&
                 (pArrayInfo->MaxCountArray == 
                  pArrayInfo->BufferConformanceMark) )
                {
                Elements = pArrayInfo->MaxCountArray[pArrayInfo->Dimension];
                }
            else
                {
                Elements = (ulong) NdrpComputeConformance( pStubMsg, 
                                                           pMemory, 
                                                           pFormat );
                }

            // check for possible mulitplication overflow attack here.
            pMemory += MultiplyWithOverflowCheck( Elements, ElementSize );
            }
            break;

        case FC_C_SSTRING:
            {
            PARRAY_INFO pArrayInfo = pStubMsg->pArrayInfo;

            if ( pArrayInfo && 
                 pArrayInfo->MaxCountArray &&
                 (pArrayInfo->MaxCountArray == 
                  pArrayInfo->BufferConformanceMark) )
                {
                Elements = pArrayInfo->MaxCountArray[pArrayInfo->Dimension];
                }
            else
                {
                Elements = (ulong) NdrpComputeConformance( pStubMsg, 
                                                           pMemory, 
                                                           pFormat );
                }

            // check for possible mulitplication overflow attack here.
            pMemory += MultiplyWithOverflowCheck( Elements, pFormat[1] );
            }
            break;

        //
        // Transmit as, represent as, user marshal
        //
        case FC_TRANSMIT_AS :
        case FC_REPRESENT_AS :
        case FC_USER_MARSHAL :
            // Get the presented type size.
            pMemory += *((ushort *)(pFormat + 4));
            break;

        case FC_BYTE_COUNT_POINTER:
            //
            // Should only hit this case when called from NdrSrvOutInit().
            // In this case it's the total byte count allocation size we're
            // looking for.
            //
            // We are taking the larger of conformant size and the real data
            // type size, otherwise, we might give user a partially invalid
            // buffer, and that'll come back to bite us during sizing/marshalling
            {
            uchar * pMemory1 = pMemory;
            uchar * pMemory2 = pMemory;
            PFORMAT_STRING pFormat2 = pFormat;

            if ( pFormat[1] != FC_PAD )
                {
                pMemory2 += SIMPLE_TYPE_MEMSIZE( pFormat[1] );
                }
            else
                {

                // go pass the conformance & get to the real type
                pFormat2 += 6;
                CORRELATION_DESC_INCREMENT( pFormat2 );
                pFormat2 += *((signed short *)pFormat2);
            
                pMemory2 = NdrpMemoryIncrement( pStubMsg, 
                                                pMemory2, 
                                                pFormat2 );

                }

            pMemory1 += NdrpComputeConformance( pStubMsg, 
                                                pMemory1, 
                                                pFormat );

            pMemory = ( pMemory1 > pMemory2 )? pMemory1 : pMemory2;
            break;
            }

        case FC_IP :
            pMemory += PTR_MEM_SIZE;
            break;

        case FC_RANGE:
            pMemory += SIMPLE_TYPE_MEMSIZE( (pFormat[1] & 0x0f) );
            break;

#ifdef _CS_CHAR_
        case FC_CSARRAY:
            {
            uchar * OldBuffer = pStubMsg->Buffer;
            ulong   OldSize   = pStubMsg->MemorySize;

            pStubMsg->MemorySize = 0;

            pMemory += NdrCsArrayMemorySize( pStubMsg, pFormat );

            pStubMsg->MemorySize = OldSize;
            pStubMsg->Buffer     = OldBuffer;

            break;
            }

        case FC_CS_TAG:
            pMemory += sizeof( ulong );
            break;
#endif _CS_CHAR_

        default :
            NDR_ASSERT(0,"NdrpMemoryIncrement : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return pMemory;
}

long
NdrpArrayDimensions( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    BOOL                fIgnoreStringArrays 
    )
/*++

Routine description :

    This routine determines the number of dimensions in a complex array, which
    is the only array type which is allowed to have multiple dimensions other
    than an array of multiple fixed dimensions.

Arguments :

    pFormat             - Complex array's format string description.
    fIgnoreStringArrays - TRUE if a string array should not be counted as
                          a dimension, FALSE if it should.

Return :

    The number of dimensions in the array.

--*/
{
    long    Dimensions;

    //
    // Only a complex array can have multiple dimensions.
    //
    if ( *pFormat != FC_BOGUS_ARRAY )
        return 1;

    Dimensions = 1;

    pFormat += 12;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    for ( ; *pFormat == FC_EMBEDDED_COMPLEX; )
        {
        pFormat += 2;
        pFormat += *((signed short *)pFormat);

        //
        // Search for a fixed, complex, or string array.
        //
        switch ( *pFormat ) 
            {
            case FC_SMFARRAY :
                pFormat += 4;
                break;

            case FC_LGFARRAY :
                pFormat += 6;
                break;

            case FC_BOGUS_ARRAY :
                pFormat += 12;
                CORRELATION_DESC_INCREMENT( pFormat );
                CORRELATION_DESC_INCREMENT( pFormat );
                break;

            case FC_CSTRING :
            case FC_BSTRING :
            case FC_WSTRING :
            case FC_SSTRING :
            case FC_C_CSTRING :
            case FC_C_BSTRING :
            case FC_C_WSTRING :
            case FC_C_SSTRING :
                //
                // Can't have any more dimensions after a string array.
                //
                return fIgnoreStringArrays ? Dimensions : Dimensions + 1;

            default :
                return Dimensions;
            }

        Dimensions++;
        }

    //
    // Get here if you have only one dimension.
    //
    return Dimensions;
}

long
NdrpArrayElements( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory, 
    PFORMAT_STRING      pFormat 
    )
/*++

Routine description :

    This routine determines the number of elements (allocation size) in an 
    array.  Used to handle multidimensional arrays.

Arguments :

    pStubMsg    - The stub message.
    pMemory     - The array.
    pFormat     - Array's format string description.

Return :

    The number of elements in the array.

--*/
{
    long    TotalSize;
    long    ElementSize;

    switch ( *pFormat )
        {
        case FC_SMFARRAY :
            TotalSize = (long) *((ushort *)(pFormat + 2));
            pFormat += 4;
            break;

        case FC_LGFARRAY :
            TotalSize = *((long UNALIGNED *)(pFormat + 2));
            pFormat += 6;
            break;
        
        case FC_SMVARRAY :
            return (long) *((ushort *)(pFormat + 4));
            
        case FC_LGVARRAY :
            return *((long UNALIGNED *)(pFormat + 6));
            
        case FC_BOGUS_ARRAY :
            if ( *((long *)(pFormat + 4)) == 0xffffffff )
                return (long) *((ushort *)(pFormat + 2));

            // else fall through

        case FC_CARRAY :
        case FC_CVARRAY :
            return (ulong) NdrpComputeConformance( pStubMsg, 
                                                   pMemory,
                                                   pFormat ); 

        default :
            NDR_ASSERT(0,"NdrpArrayElements : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    //
    // We get here for a non-complex fixed array.
    //
    // Since a fixed array's format string description does not
    // contain the number of elements in the array, we have to compute
    // it by computing the array's element size and dividing this into
    // the total array size.
    //
    // A fixed array's child can only be a nice struct, another
    // fixed array, a pointer, or a simple type.
    //

    //
    // Skip pointer layout if one is present.
    //
    if ( *pFormat == FC_PP )
        pFormat = NdrpSkipPointerLayout( pFormat );

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            //
            // We must be at FC_STRUCT, FC_PSTRUCT, FC_SMFARRAY, or FC_LGFARRAY.
            // All these have the total size as a short at 2 bytes past the 
            // beginning of the description except for large fixed array.
            //
            if ( *pFormat != FC_LGFARRAY )
                ElementSize = (long) *((ushort *)(pFormat + 2));
            else
                ElementSize = *((long UNALIGNED *)(pFormat + 2));
                
            break;
    
        //
        // Simple type (enum16 not possible).
        //
        default :
            ElementSize = SIMPLE_TYPE_MEMSIZE( *pFormat );
            break;
        }

    return TotalSize / ElementSize;
}

void
NdrpArrayVariance( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long *              pOffset,
    long *              pLength
    )
/*++

Routine description :

    This routine determines the offset and length values for an array.  
    Used to handle multidimensional arrays.

Arguments :

    pStubMsg    - The stub message.
    pMemory     - The array.
    pFormat     - Array's format string description.
    pOffset     - Returned offset value.
    pLength     - Returned length value.

Return :

    None.

--*/
{
    switch ( *pFormat )
        {
        case FC_SMFARRAY :
        case FC_LGFARRAY :
        case FC_CARRAY :
            *pOffset = 0;
            *pLength = NdrpArrayElements( pStubMsg,
                                          pMemory, 
                                          pFormat );
            break;

        case FC_BOGUS_ARRAY :
            {
            PFORMAT_STRING  pFormatBAV = pFormat + 8;

            CORRELATION_DESC_INCREMENT( pFormatBAV );

            if ( *((long UNALIGNED *)(pFormatBAV + 8)) == 0xffffffff )
                {
                *pOffset = 0;
                *pLength = NdrpArrayElements( pStubMsg, 
                                              pMemory, 
                                              pFormat );
                return;
                }
            }

            // else fall through

        case FC_CVARRAY :
        case FC_SMVARRAY :
        case FC_LGVARRAY :
            NdrpComputeVariance( pStubMsg, 
                                 pMemory,
                                 pFormat ); 

            *pOffset = (long) pStubMsg->Offset;
            *pLength = (long) pStubMsg->ActualCount;
            break;

        default :
            NDR_ASSERT(0,"NdrpArrayVariance : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}

PFORMAT_STRING
NdrpSkipPointerLayout( 
    PFORMAT_STRING pFormat 
    )
/*--

RoutineDescription :

    Skips a pointer layout format string description.

Arguments :

    pFormat - Format string pointer layout description.  Must currently
              point to the FC_PP beginning the pointer layout.

Return :

    Format string pointer past the pointer layout.

--*/
{
    long    Pointers;

    NDR_ASSERT( *pFormat == FC_PP, 
                "NdrpSkipPointerLayout : format string not at FC_PP" );

    // Skip FC_PP and FC_PAD.
    pFormat += 2;

    for (;;)
        {
        switch ( *pFormat )
            {
            case FC_END :
                return pFormat + 1;

            case FC_NO_REPEAT :
                pFormat += 10;
                break;

            case FC_FIXED_REPEAT :
                pFormat += 2;
                // fall through...

            case FC_VARIABLE_REPEAT :
                pFormat += 6;

                Pointers = *((ushort * &)pFormat)++;

                pFormat += Pointers * 8;
                break;

            default :
                NDR_ASSERT( 0, "NdrpSkipPointerLayout : bad format char" );
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            }
        }
}

long
NdrpStringStructLen( 
    uchar *     pMemory,
    long        ElementSize
    )
/*--

RoutineDescription :

    Determines a stringable struct's length.

Arguments :

    pMemory     - Pointer to stringable struct.
    ElementSize - Number of bytes of each string element.

Return :

    Length of string.

--*/
{
    long    Length;
    uchar   Buffer[256];

    // Note : String struct element size is limited to 256 bytes.

    MIDL_memset( Buffer, 0, 256 );

    for ( Length = 0; ; Length++ )
        {
        if ( memcmp( pMemory, Buffer, ElementSize ) == 0 )
            break;

        pMemory += ElementSize;
        }

    return Length;
}

void
NdrpCheckBound(
    ulong               Bound,
    int                 Type
    )
{
    ulong   Mask;

    switch ( Type )
        {
        case FC_ULONG :

#if defined(__RPC_WIN64__)
        case FC_UINT3264 :
        case FC_INT3264 :
#endif
            //
            // We use a mask here which will raise an exception for counts
            // of 2GB or more since this is the max NT allocation size.
            //
            Mask = 0x80000000UL;
            break;
        case FC_LONG :
            Mask = 0x80000000UL;
            break;
        case FC_USHORT :
            Mask = 0xffff0000UL;
            break;
        case FC_SHORT :
            Mask = 0xffff8000UL;
            break;
        case FC_USMALL :
            Mask = 0xffffff00UL;
            break;
        case FC_SMALL :
            Mask = 0xffffff80UL;
            break;
        case 0 :
            //
            // For variance which requires calling an auxilary expression
            // evaluation routine a type is not emitted in the format string.
            // We have to just give up.
            //
            // The same thing happens with constant conformance type
            // we emit zero on the var type nibble.
            //
            // we should at least check for long. 
            Mask = 0x80000000UL;
            break;
        default :
            NDR_ASSERT( 0, "NdrpCheckBound : bad type" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    if ( Bound & Mask )
        RpcRaiseException( RPC_X_INVALID_BOUND );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\memsizep.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    memsizep.h

Abtract :

    Contains private memory sizing routine definitions.

Author :

    David Kays  dkays   November 1993

Revision History :

--------------------------------------------------------------------*/

typedef     ulong	(RPC_ENTRY * PMEM_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
                        PFORMAT_STRING		pFormat
                    );

typedef     ulong	(* PPRIVATE_MEM_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
                        PFORMAT_STRING		pFormat
                    );

extern const PMEM_SIZE_ROUTINE * pfnMemSizeRoutines;

ulong 
NdrpPointerMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
	uchar *				pBufferMark,
    PFORMAT_STRING		pFormat
	);

ulong 
NdrpConformantArrayMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
	);

ulong 
NdrpConformantVaryingArrayMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
	);

ulong 
NdrpComplexArrayMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
	);

ulong 
NdrpConformantStringMemorySize( 
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
	);

ulong
NdrpUnionMemorySize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat,
	uchar				SwitchIs
    );

void
NdrpEmbeddedPointerMemorySize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING		pFormat
    );

void
NdrpEmbeddedRepeatPointerMemorySize(
	PMIDL_STUB_MESSAGE	pStubMsg,
    PFORMAT_STRING *	ppFormatt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\mulsyntx.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    mulsyntx.cxx

Abstract :

    This file contains multiple transfer syntaxes negotiation related code

Author :

    Yong Qu    yongqu    September 1999.

Revision History :


  ---------------------------------------------------------------------*/


#include "ndrp.h"
#define CINTERFACE
#include "ndrole.h"
#include "rpcproxy.h"
#include "mulsyntx.h"
#include "hndl.h"
#include "auxilary.h"
#include "pipendr.h"
#include "ndr64tkn.h"

const extern PMARSHALL_ROUTINE        MarshallRoutinesTable[];
const extern PUNMARSHALL_ROUTINE      UnmarshallRoutinesTable[];
const extern PSIZE_ROUTINE            SizeRoutinesTable[];
const extern PMEM_SIZE_ROUTINE        MemSizeRoutinesTable[];
const extern PFREE_ROUTINE            FreeRoutinesTable[];
//const extern PWALKIP_ROUTINE          WalkIPRoutinesTable[];

// TODO: move this to ndrpall.h after Preview.
#define MIDL_VERSION_6_0_322   ((6UL << 24) | (0UL << 16) | 322UL)

void RPC_ENTRY
NdrpClientInit(MIDL_STUB_MESSAGE * pStubMsg,
               void *              pReturnValue )
{
    PFORMAT_STRING              pFormatParam;
    ulong                       ProcNum;
    BOOL                        fRaiseExcFlag;
    ulong                       n;
    uchar *                     pArg;
    INTERPRETER_FLAGS           InterpreterFlags;
    PPARAM_DESCRIPTION          Params;
    NDR_PROC_CONTEXT *          pContext = (NDR_PROC_CONTEXT *) pStubMsg->pContext;
    INTERPRETER_OPT_FLAGS       OptFlags = pContext->NdrInfo.pProcDesc->Oi2Flags;
    PFORMAT_STRING              pTypeFormat;

    // When this routine is called from ndrclientcall2, we don't have MIDL_SYNTAX_INFO,
    // so we need to read it from MIDL_STUB_DESC;
    // Note: we need to conenct StubDesc to pStubMsg before calling into here.
    if ( NULL == pContext->pSyntaxInfo )
        pContext->DceTypeFormatString = pStubMsg->StubDesc->pFormatTypes;
    else
        pContext->DceTypeFormatString = pContext->pSyntaxInfo->TypeString;

    InterpreterFlags = pContext->NdrInfo.InterpreterFlags;
    Params = ( PPARAM_DESCRIPTION )pContext->Params;
    pTypeFormat = pContext->DceTypeFormatString;

    if ( InterpreterFlags.FullPtrUsed )
        pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );
    else
        pStubMsg->FullPtrXlatTables = 0;

    if ( InterpreterFlags.RpcSsAllocUsed )
        NdrRpcSmSetClientToOsf( pStubMsg );

    // Set Rpc flags after the call to client initialize.
    pStubMsg->RpcMsg->RpcFlags = pContext->RpcFlags;

    if ( OptFlags.HasPipes )
        NdrpPipesInitialize32( pStubMsg,
                               &pContext->AllocateContext,
                               (PFORMAT_STRING) pContext->Params,
                               ( char * )pContext->StartofStack,
                               pContext->NumberParams  );

    // Must do this before the sizing pass!
    pStubMsg->StackTop = pContext->StartofStack;

    if ( OptFlags.HasExtensions )
        {
        pStubMsg->fHasExtensions  = 1;
        pStubMsg->fHasNewCorrDesc = pContext->NdrInfo.pProcDesc->NdrExts.Flags2.HasNewCorrDesc;
        if ( pContext->NdrInfo.pProcDesc->NdrExts.Flags2.ClientCorrCheck )
            {
            ulong *pCache =
                (ulong*)NdrpAlloca(&pContext->AllocateContext,
                                   NDR_DEFAULT_CORR_CACHE_SIZE );

            NdrCorrelationInitialize( pStubMsg,
                                      pCache,
                                      NDR_DEFAULT_CORR_CACHE_SIZE,
                                      0 /* flags */ );
            }
        }



    //
    // Get the compile time computed buffer size.
    //
    pStubMsg->BufferLength = pContext->NdrInfo.pProcDesc->ClientBufferSize;

    //
    // Check ref pointers and do object proc [out] zeroing.
    //

    fRaiseExcFlag = FALSE;

    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        if ( Params[n].ParamAttr.IsReturn )
            pArg = (uchar *) &pReturnValue;
        else
            pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsSimpleRef && !Params[n].ParamAttr.IsReturn )
            {
            // We cannot raise the exception here,
            // as some out args may not be zeroed out yet.

            if ( ! *((uchar **)pArg) )
                {
                fRaiseExcFlag = TRUE;
                continue;
                }
            }

        // if top level point is FC_RP and the arg is NULL, we'll catch this
        // before the call goes to server.
        // We wouldn't catch all the null ref pointer here, but we should be able
        // to catch the most obvious ones.
        // This code is called from sync & raw async code; in async dcom,
        // we only go through outinit in finish routine so we can't do anything anyhow.
        if ( Params[n].ParamAttr.IsOut && ! Params[n].ParamAttr.IsBasetype  )
            {
            pFormatParam = pTypeFormat + Params[n].TypeOffset;
            if ( * pFormatParam == FC_RP &&  !*((uchar **)pArg) )
                {
                fRaiseExcFlag = TRUE;
                continue;
                }
            }

        //
        // In object procs and complex return types we have to zero
        // out all [out] parameters.  We do the basetype check to
        // cover the [out] simple ref to basetype case.
        //
        if ( ( InterpreterFlags.ObjectProc &&
               ! pContext->IsAsync &&
               ( Params[n].ParamAttr.IsPartialIgnore ||
                 ( ! Params[n].ParamAttr.IsIn &&
                   ! Params[n].ParamAttr.IsReturn &&
                   ! Params[n].ParamAttr.IsPipe ) ) ) ||
             ( pContext->HasComplexReturn &&
                    Params[n].ParamAttr.IsReturn ) )
            {
                if ( Params[n].ParamAttr.IsBasetype )
                    {
                    // [out] only arg can only be ref, we checked that above.
                    MIDL_memset( *(uchar **)pArg,
                                 0,
                                 (size_t)SIMPLE_TYPE_MEMSIZE( Params[n].SimpleType.Type ));
                    }
                else
                    {
                    pFormatParam = pTypeFormat +
                           Params[n].TypeOffset;

                    NdrClientZeroOut(
                    pStubMsg,
                    pFormatParam,
                    *(uchar **)pArg );
                    }
            }
        }

    if ( fRaiseExcFlag )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if ( !OptFlags.ClientMustSize )
        pContext->pfnSizing = (PFNSIZING)NdrpNoopSizing;
}

void RPC_ENTRY
NdrpNoopSizing( MIDL_STUB_MESSAGE *    pStubMsg,
            BOOL                   IsClient )
{
    return;
}


void RPC_ENTRY
NdrpSizing( MIDL_STUB_MESSAGE *    pStubMsg,
            BOOL                   IsClient )
{
    PFORMAT_STRING          pFormatParam;
    ulong                    n;
    uchar *                     pArg;
    NDR_PROC_CONTEXT *      pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION      Params = ( PPARAM_DESCRIPTION )pContext->Params;
    PFORMAT_STRING          pTypeFormat = pContext->DceTypeFormatString;

    //
    // Skip buffer size pass if possible.
    //

        for ( n = 0; n < pContext->NumberParams; n++ )
            {

            if ( !SAMEDIRECTION(IsClient, Params[n]) ||
                 ! Params[n].ParamAttr.MustSize )
                continue;

            if ( IsClient &&
                 Params[n].ParamAttr.IsPartialIgnore )
                {
                LENGTH_ALIGN( pStubMsg->BufferLength, 0x3 );
                pStubMsg->BufferLength += PTR_WIRE_SIZE;
                continue;
                }

            //
            // Note : Basetypes will always be factored into the
            // constant buffer size emitted by in the format strings.
            //

            pFormatParam = pTypeFormat +
                           Params[n].TypeOffset;

            pArg = pContext->StartofStack + Params[n].StackOffset;

            if ( ! Params[n].ParamAttr.IsByValue )
                pArg = *((uchar **)pArg);

            (*SizeRoutinesTable[ROUTINE_INDEX(*pFormatParam)])
			( pStubMsg,
			  pArg,
			  pFormatParam );
            }

}

void RPC_ENTRY
NdrpClientMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject )
{
    ulong n;
    uchar * pArg;
    PFORMAT_STRING              pFormatParam;
    NDR_PROC_CONTEXT *          pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION ) pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;

    //
    // ----------------------------------------------------------
    // Marshall Pass.
    // ----------------------------------------------------------
    //


    for ( n = 0; n < pContext->NumberParams; n++ )
        {

        if (!Params[n].ParamAttr.IsIn ||
             Params[n].ParamAttr.IsPipe )
            continue;

        if ( Params[n].ParamAttr.IsPartialIgnore )
            {

            pArg = pContext->StartofStack + Params[n].StackOffset;

            ALIGN( pStubMsg->Buffer, 0x3 );
            *(ulong*)pStubMsg->Buffer = *(void**)pArg ? 1 : 0;
            pStubMsg->Buffer += PTR_WIRE_SIZE;
            continue;

            }

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for pointer to basetype.
            //
            if ( Params[n].ParamAttr.IsSimpleRef )
                pArg = *((uchar **)pArg);
            else
            {

#if defined(_IA64_) || defined(_AMD64_)
             if ( !IsObject &&
                  Params[n].SimpleType.Type == FC_FLOAT )
                {
                // Due to the fact that NdrClientCall2 is called with the
                // parameters in ... arguments, floats get promoted to doubles.
                // This is not true for DCOM since an assembly langauge wrapper
                // is used that saves the floats as floats.
                //
                // We do not handle this case properly.
                *((float *) pArg) = (float) *((double *)pArg);

                }
#endif
            }

            if ( Params[n].SimpleType.Type == FC_ENUM16 )
                {
                if ( *((int *)pArg) & ~((int)0x7fff) )
                    RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);

                }

        // a fastcall lookup should be faster than possible 3 missing caches, and we can zero out the gap.
            SimpleTypeMarshallRoutinesTable[ROUTINE_INDEX( Params[n].SimpleType.Type)](pStubMsg, pArg );
            continue;
            }

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        if ( ! Params[n].ParamAttr.IsByValue )
            pArg = *((uchar **)pArg);

        (* MarshallRoutinesTable[ROUTINE_INDEX(*pFormatParam)] )
        ( pStubMsg,
	      pArg,
		  pFormatParam );
        }

        if ( pStubMsg->RpcMsg->BufferLength <
                 (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
            {
            NDR_ASSERT( 0, "NdrpClientMarshal marshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }


}

void RPC_ENTRY
NdrpServerMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject )
{
    ulong n;
    uchar * pArg;
    PFORMAT_STRING              pFormatParam;
    NDR_PROC_CONTEXT *          pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION ) pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;

    //
    // ----------------------------------------------------------
    // Marshall Pass.
    // ----------------------------------------------------------
    //


    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        if (!Params[n].ParamAttr.IsOut  ||
             Params[n].ParamAttr.IsPipe )
            continue;

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for pointer to basetype.
            //
            if ( Params[n].ParamAttr.IsSimpleRef )
                pArg = *((uchar **)pArg);

            if ( Params[n].SimpleType.Type == FC_ENUM16 )
                {
                if ( *((int *)pArg) & ~((int)0x7fff) )
                    RpcRaiseException(RPC_X_ENUM_VALUE_OUT_OF_RANGE);

                }


        // a fastcall lookup should be faster than possible 3 missing caches, and we can zero out the gap.
        SimpleTypeMarshallRoutinesTable[ROUTINE_INDEX( Params[n].SimpleType.Type)](pStubMsg, pArg );
            continue;
            }

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        if ( ! Params[n].ParamAttr.IsByValue )
            pArg = *((uchar **)pArg);

        (* MarshallRoutinesTable[ROUTINE_INDEX(*pFormatParam)] )
        ( pStubMsg,
	      pArg,
		  pFormatParam );
        }

        if ( pStubMsg->RpcMsg->BufferLength <
                 (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
            {
            NDR_ASSERT( 0, "NdrpServerMarshal marshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }

}

/*
From:	To:		Marshall:	User Exception:	Cleanup:Rundown:	context handle:
----------	----------------------------------	--------------------------------
Any		NULL		Y		N/A				No		No		INVALID_HANDLE from the server
!NULL	Same value	Any		Any				No		No		Same as before
!NULL	Different 	Any		Any				No		No		New context on the server
!NULL	Any			N/A		Y				No		No		No new context handle is created
NULL	ANY 		N/A		Y				Yes		No		INVALID_HANDLE from the server
NULL	!NULL		Y		N				Yes		Yes		INVALID_HANDLE from the server
NULL	!NULL		N		N				Yes		Yes		INVALID_HANDLE from the server
!NULL	NULL		N		N				Yes		No		No new context handle is created
NULL	NULL		N		N				Yes		No		No new context handle is created

In the OUT only context handle case:
To:		Marshall:	User Exception:	Cleanup:Rundown:	context handle:
--------------------------------------------------------------------------------------
Any		N/A		    Y				N		N		No new context handle is created
NULL	N		    N				N		N		No new context handle is created
NULL	Y		    N				N		N		No new context handle is created
!NULL	N		    N				N		Y		No new context handle is created
!NULL	Y		    N				Y		Y		No new context handle is created


*/
void
NdrpEmergencyContextCleanup(
    MIDL_STUB_MESSAGE  *            pStubMsg,
    PNDR_CONTEXT_HANDLE_ARG_DESC    pCtxtDesc,
    void *                          pArg,
    BOOL                            fManagerRoutineException
    )
{
    int          RtnIndex   = pCtxtDesc->RundownRtnIndex;
    NDR_RUNDOWN  pfnRundown = pStubMsg->StubDesc->apfnNdrRundownRoutines[ RtnIndex ];
    NDR_SCONTEXT SContext   = pStubMsg->SavedContextHandles[ pCtxtDesc->ParamOrdinal ];
    void *       NewHandle  = pArg;

    // if runtime failes during marshalling context handle, we shouldn't call into
    // cleanup routine since it's already cleanup by runtime.
    if ( SContext == (NDR_SCONTEXT )CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER )
        return;


    if ( fManagerRoutineException )
        {
//        NDR_ASSERT( SContext != NULL ||  pCtxtDesc->Flags.IsReturn ,
//            "only return context handle can have null scontext in exception" );

        // if we failed somewhere during unmarshalling, or this is a return context handle,
        // we don't need to cleanup
        if ( SContext == NULL )
            return;

        // in NdrServerOutInit, we initialize the scontext for regular [out] parameters,
        // and runtime has already allocated some memory. But for return context handle,
        // we initialize the scontext during marshalling and saved context is NULL till
        // just before marshalling.
        }
    else
        {
        // haven't unmarshalled yet.
        if ( SContext == NULL )
            {
            if ( NULL == NewHandle )
                return;
            else
                {
                // note : what if the context handle is both return and viaptr?
                NDR_ASSERT( pCtxtDesc->Flags.IsReturn, "has to be return context handle" );
                }
            }
        else
            if ( SContext == (NDR_SCONTEXT )CONTEXT_HANDLE_AFTER_MARSHAL_MARKER )
            {
            // this particular context handle has been marshalled; the exception happens
            // during marshalling other parameters after this one.

            // After marshalling is done, the runtime will release the user context if new context
            // handle is NULL, so we can't reference to the user context at this point.
            NewHandle = NULL;
            }
        else
            {
            if ( pCtxtDesc->Flags.IsViaPtr )
                NewHandle = *((void * UNALIGNED *)pArg);
            }
        // if this is a regular [in,out] or [out] context handle, and it hasn't been marshalled
        // yet, we need to call into runtime to cleanup.
        }


    // Kamen volunteer to process the logic of calling runtime or not. In NDR we just
    // don't call into the routine when it isn't supposed to.
    NDRSContextEmergencyCleanup( pStubMsg->RpcMsg->Handle,
                                 SContext,
                                 pfnRundown,
                                 NewHandle,
                                 fManagerRoutineException );
}

void
NdrpCleanupServerContextHandles(
    MIDL_STUB_MESSAGE *    pStubMsg,
    uchar *                pStartOfStack,
    BOOL                   fManagerRoutineException )
{
    ulong n;
    uchar * pArg;
    PFORMAT_STRING              pFormatParam;
    NDR_PROC_CONTEXT *          pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION ) pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;

    //
    // ------------------------------------------------------------------------
    // Context handle loop: clean up out context handles to prevent leaks.
    //
    // Note, this routine handles only the handles that may have been dropped
    // due to the NDR engine raising exception between a clean return from
    // the manager routine and end of marshaling back of the parameters.
    // This addresses a situation where handles get dropped by NDR without being
    // registered with the runtime and so the server leaks because the rundown
    // routine is never called on the dropped handles.
    // ------------------------------------------------------------------------
    //

    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        if (!Params[n].ParamAttr.IsOut  ||
             Params[n].ParamAttr.IsPipe )
            continue;

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for pointer to basetype.
            //
            continue;
            }

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        if ( ! Params[n].ParamAttr.IsByValue )
            pArg = *((uchar **)pArg);

        // Context handle have their own "via pointer" flag to mark dereference.

        if ( *pFormatParam == FC_BIND_CONTEXT )
            {
            NdrpEmergencyContextCleanup( pStubMsg,
                                         (PNDR_CONTEXT_HANDLE_ARG_DESC) pFormatParam,
                                         pArg,
                                         fManagerRoutineException
                                         );
            }
        } // parameter loop

}

void RPC_ENTRY
NdrpClientUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg,
                void  *                 pReturnValue )
{
    ulong                       n;
    uchar *                     pArg;
    uchar **                    ppArg;
    PFORMAT_STRING              pFormatParam, pFormat;
    NDR_PROC_CONTEXT    *       pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION)pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;

    // we only need to do conversion in NDR32 now: we cut off endian
    // conversion in NDR64.
    // Do endian/floating point conversions if necessary.
    //
    if ( (pStubMsg->RpcMsg->DataRepresentation & 0X0000FFFFUL) !=
          NDR_LOCAL_DATA_REPRESENTATION )
        {
        NdrConvert2( pStubMsg,
                     (PFORMAT_STRING) Params,
                     pContext->NumberParams );
        }

#ifdef TEST_CONVERT
        NdrConvert2( pStubMsg,
                     (PFORMAT_STRING) Params,
                     pContext->NumberParams );
#endif
   //
    // ----------------------------------------------------------
    // Unmarshall Pass.
    // ----------------------------------------------------------
    //

    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        if ( Params[n].ParamAttr.IsPipe )
            continue;

        if ( !Params[n].ParamAttr.IsOut )
            {
            if (    !Params[n].ParamAttr.IsIn
                 && !Params[n].ParamAttr.IsReturn )
                {
                // If a param is not [in], [out], or a return value,
                // then it is a "hidden" client-side only status
                // paramater.  It will get set below if an exception
                // happens.  If everything is ok we need to zero it
                // out here.

                NDR_ASSERT( Params[n].ParamAttr.IsSimpleRef
                                && Params[n].ParamAttr.IsBasetype
                                && FC_ERROR_STATUS_T ==
                                        Params[n].SimpleType.Type,
                            "Apparently not a hidden status param" );

                pArg = pContext->StartofStack + Params[n].StackOffset;

                ** (error_status_t **) pArg = RPC_S_OK;
                }

            continue;
            }

        if ( Params[n].ParamAttr.IsReturn )
            pArg = (uchar *) pReturnValue;
        else
            pArg = pContext->StartofStack + Params[n].StackOffset;

        //
        // This is for returned basetypes and for pointers to
        // basetypes.
        //
        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for a pointer to a basetype.
            //
            if ( Params[n].ParamAttr.IsSimpleRef )
                pArg = *((uchar **)pArg);

            ALIGN( pStubMsg->Buffer,
                   SIMPLE_TYPE_ALIGNMENT(Params[n].SimpleType.Type) );

            #if defined(__RPC_WIN64__)
                // Special case for int3264.

                if ( Params[n].SimpleType.Type == FC_INT3264  ||
                     Params[n].SimpleType.Type == FC_UINT3264 )
                    {
                    if ( Params[n].SimpleType.Type == FC_INT3264 )
                        *((INT64 *)pArg) = *((long * &)pStubMsg->Buffer)++;
                    else
                        *((UINT64 *)pArg) = *((ulong * &)pStubMsg->Buffer)++;
                    continue;
                    }
            #endif

            if ( Params[n].SimpleType.Type == FC_ENUM16 )
                {
                *((int *)(pArg)) = *((int *)pArg) & ((int)0x7fff) ;

                }

            RpcpMemoryCopy(
                pArg,
                pStubMsg->Buffer,
                (uint)SIMPLE_TYPE_BUFSIZE(Params[n].SimpleType.Type) );

            pStubMsg->Buffer +=
                SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );

            continue;
            }


        ppArg = Params[n].ParamAttr.IsByValue ? &pArg : (uchar **)pArg;

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        //
        // Transmit/Represent as can be passed as [out] only, thus
        // the IsByValue check.
        //
        (* UnmarshallRoutinesTable[ROUTINE_INDEX(*pFormatParam)] )
        ( pStubMsg,
          ppArg,
          pFormatParam,
          FALSE );
        }

    if ( pStubMsg->pCorrInfo )
        NdrCorrelationPass( pStubMsg );

    return ;
}

void RPC_ENTRY
NdrpServerUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg )
{
    ulong                        n;
    uchar *                     pArg;
    uchar **                    ppArg;
    PFORMAT_STRING              pFormatParam, pFormat;
    NDR_PROC_CONTEXT    *       pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;
    PPARAM_DESCRIPTION          Params = (PPARAM_DESCRIPTION)pContext->Params;
    PFORMAT_STRING              pTypeFormat = pContext->DceTypeFormatString;


    // we only need to do conversion in NDR32 now: we cut off endian
    // conversion in NDR64.
    // Do endian/floating point conversions if necessary.
    //
    if ( ( pStubMsg->RpcMsg->DataRepresentation & 0X0000FFFFUL) !=
          NDR_LOCAL_DATA_REPRESENTATION )
    {
        NdrConvert2( pStubMsg,
                     (PFORMAT_STRING) Params,
                     (long) pContext->NumberParams );
    }

#ifdef TEST_CONVERT
        NdrConvert2( pStubMsg,
                     (PFORMAT_STRING) Params,
                     pContext->NumberParams );
#endif

    // --------------------------------
    // Unmarshall all of our parameters.
    // --------------------------------

    for ( n = 0; n < pContext->NumberParams; n++ )
        {

        if ( ! Params[n].ParamAttr.IsIn  ||
             Params[n].ParamAttr.IsPipe )
            continue;

        if ( Params[n].ParamAttr.IsPartialIgnore )
            {
            pArg = pContext->StartofStack + Params[n].StackOffset;

            ALIGN( pStubMsg->Buffer, 0x3 );
            *(void**)pArg = *(ulong*)pStubMsg->Buffer ? (void*)1 : (void*)0;
            pStubMsg->Buffer += PTR_WIRE_SIZE;

            continue;
            }

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( Params[n].ParamAttr.IsBasetype )
            {
            //
            // Check for a pointer to a basetype.  Set the arg pointer
            // at the correct buffer location and you're done.
            // Except darn int3264
            if ( Params[n].ParamAttr.IsSimpleRef )
                {
                ALIGN( pStubMsg->Buffer,
                       SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ) );

                #if defined(__RPC_WIN64__)
                // Special case for a ref pointer to int3264.

                if ( Params[n].SimpleType.Type == FC_INT3264  ||
                     Params[n].SimpleType.Type == FC_UINT3264 )
                    {
                    *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext, 8 );

                    if ( Params[n].SimpleType.Type == FC_INT3264 )
                        *(*(INT64**)pArg) = *((long * &)pStubMsg->Buffer)++;
                    else
                        *(*(UINT64**)pArg)= *((ulong * &)pStubMsg->Buffer)++;
                    continue;
                    }
                #endif

                *((uchar **)pArg) = pStubMsg->Buffer;

                pStubMsg->Buffer +=
                    SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );
                }
            else
                {
                NdrUnmarshallBasetypeInline(
                    pStubMsg,
                    pArg,
                    Params[n].SimpleType.Type );

                }

            continue;
            } // IsBasetype

        //
        // This is an initialization of [in] and [in,out] ref pointers
        // to pointers.  These can not be initialized to point into the
        // rpc buffer and we want to avoid doing a malloc of 4 bytes!
        // 32b: a ref pointer to any pointer, we allocate the pointee pointer.
        //
        if ( Params[n].ParamAttr.ServerAllocSize != 0 )
            {
            *((void **)pArg) = NdrpAlloca(& pContext->AllocateContext, PTR_MEM_SIZE );

            // Triple indirection - cool!
            **((void ***)pArg) = 0;
            }

        pStubMsg->ReuseBuffer = Params[n].ParamAttr.IsForceAllocate;
        ppArg = Params[n].ParamAttr.IsByValue ? &pArg : (uchar **)pArg;

        pFormatParam = pTypeFormat +
                       Params[n].TypeOffset;

        (*UnmarshallRoutinesTable[ROUTINE_INDEX(*pFormatParam)])
        ( pStubMsg,
          ppArg,
          pFormatParam,
          Params[n].ParamAttr.IsForceAllocate &&
              !Params[n].ParamAttr.IsByValue );

        pStubMsg->ReuseBuffer = FALSE;

        }

    if ( pStubMsg->pCorrInfo )
        NdrCorrelationPass( pStubMsg );

    if (CheckVerificationTrailer(pStubMsg->Buffer, pStubMsg->BufferEnd, pStubMsg->RpcMsg) == FALSE)
        RpcRaiseException( RPC_S_ACCESS_DENIED );
                
    return ;
}

void RPC_ENTRY
NdrpDcomClientExceptionHandling(  MIDL_STUB_MESSAGE  *      pStubMsg,
                    ulong                                   ProcNum,
                    RPC_STATUS                              ExceptionCode,
                    CLIENT_CALL_RETURN  *                   pReturnValue )
{
    ulong                   NumberParams;
    PPARAM_DESCRIPTION      Params;
    PFORMAT_STRING          pTypeFormat;
    ulong                   n;
    uchar *                 pArg;
    PFORMAT_STRING          pFormatParam;
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

    pReturnValue->Simple = NdrProxyErrorHandler(ExceptionCode);
    if( pStubMsg->dwStubPhase != PROXY_UNMARSHAL)
        return;

    NumberParams = pContext->NumberParams;
    Params = ( PPARAM_DESCRIPTION )pContext->Params;
    // alert: this can't be directly called from ndrclientcall2: we don't have pSyntaxInfo.
    pTypeFormat = pContext->DceTypeFormatString;

    //
    // In OLE, since they don't know about error_status_t and wanted to
    // reinvent the wheel, check to see if we need to map the exception.
    // In either case, set the return value and then try to free the
    // [out] params, if required.
    //
        pStubMsg->BufferStart = 0;
        pStubMsg->BufferEnd   = 0;

        for ( n = 0; n < pContext->NumberParams; n++ )
            {
            //
            // Skip everything but [out] only parameters.  We make
            // the basetype check to cover [out] simple ref pointers
            // to basetypes.
            //

            if ( !Params[n].ParamAttr.IsPartialIgnore )
                {
                if ( Params[n].ParamAttr.IsIn ||
                     Params[n].ParamAttr.IsReturn ||
                     Params[n].ParamAttr.IsBasetype ||
                     Params[n].ParamAttr.IsPipe )
                    continue;
                }

            pArg = pContext->StartofStack + Params[n].StackOffset;

            pFormatParam = pTypeFormat +
                           Params[n].TypeOffset;

            NdrClearOutParameters( pStubMsg,
                                   pFormatParam,
                                   *((uchar **)pArg) );
            }

    return ;
}

void RPC_ENTRY
NdrpClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                    ulong                   ProcNum,
                    RPC_STATUS              ExceptionCode,
                    CLIENT_CALL_RETURN  *   pReturnValue )
{
    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT * ) pStubMsg->pContext;

    NDR_ASSERT( pContext->NdrInfo.InterpreterFlags.HasCommOrFault, 
            " must have comm or fault to catch" );
    NdrClientMapCommFault( pStubMsg,
                           ProcNum,
                           ExceptionCode,
                           (ULONG_PTR*)&pReturnValue->Simple );

    return ;
}

void RPC_ENTRY
NdrpAsyncClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                    ulong                   ProcNum,
                    RPC_STATUS              ExceptionCode,
                    CLIENT_CALL_RETURN  *   pReturnValue  )
{
    NDR_PROC_CONTEXT    *       pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

    if ( pContext->NdrInfo.InterpreterFlags.HasCommOrFault )
        {
        NdrClientMapCommFault( pStubMsg,
                               ProcNum,
                               ExceptionCode,
                               (ULONG_PTR*)&pReturnValue->Simple );
        if ( ExceptionCode == RPC_S_ASYNC_CALL_PENDING )
            {
            // If the call is just pending, force the pending error code
            // to show up in the return value of RpcAsyncCallComplete.

            pReturnValue->Simple = RPC_S_ASYNC_CALL_PENDING;
            }
        }
    else
        {
        RpcRaiseException(ExceptionCode);
        }

    return ;
}


void  RPC_ENTRY
NdrpClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis )
{
    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT * ) pStubMsg->pContext;
    NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

    NdrCorrelationFree( pStubMsg );

    //
    // Free the RPC buffer.
    //
    if ( pThis )
        {
        NdrProxyFreeBuffer( pThis, pStubMsg );
        }
    else
        {
        NdrFreeBuffer( pStubMsg );

    //
    // Unbind if generic handle used.  We do this last so that if the
    // the user's unbind routine faults, then all of our internal stuff
    // will already have been freed.
    //
        if ( pContext->SavedGenericHandle )
        GenericHandleUnbind( pStubMsg->StubDesc,
                             pContext->StartofStack,
                             pContext->pHandleFormatSave,
                             (pContext->HandleType) ? IMPLICIT_MASK : 0,
                             &pContext->SavedGenericHandle );
        }

    NdrpAllocaDestroy( & pContext->AllocateContext );
}


void
NdrpServerInit( PMIDL_STUB_MESSAGE   pStubMsg,
                RPC_MESSAGE *        pRpcMsg,
                PMIDL_STUB_DESC      pStubDesc,
                void *               pThis,
                IRpcChannelBuffer *  pChannel,
                PNDR_ASYNC_MESSAGE   pAsyncMsg )
{
    NDR_PROC_CONTEXT *  pContext = (NDR_PROC_CONTEXT *) pStubMsg->pContext;

    uchar *                 pArg;
    uchar *  pArgBuffer = pContext->StartofStack;

    if ( pContext->pSyntaxInfo == NULL )
        pContext->DceTypeFormatString = pStubDesc->pFormatTypes;
    else
        pContext->DceTypeFormatString = pContext->pSyntaxInfo->TypeString;

    if ( ! pContext->HandleType )
    {
        //
        // For a handle_t parameter we must pass the handle field of
        // the RPC message to the server manager.
        //
        if ( *pContext->pHandleFormatSave == FC_BIND_PRIMITIVE )
        {
            pArg = pArgBuffer + *((ushort *)&pContext->pHandleFormatSave[2]);

            if ( IS_HANDLE_PTR(pContext->pHandleFormatSave[1]) )
                pArg = *((uchar **)pArg);

            *((handle_t *)pArg) = pRpcMsg->Handle;
        }
    }

    //
    // If OLE, put pThis in first dword of stack.
    //
    if ( pThis )
    {
        *((void **)pArgBuffer) =
            (void *)((CStdStubBuffer *)pThis)->pvServerObject;
    }

    //
    // Initialize the Stub message.
    //
    if ( ! pChannel )
        {
        if ( ! pContext->NdrInfo.pProcDesc->Oi2Flags.HasPipes )
           {
            NdrServerInitializeNew( pRpcMsg,
                                    pStubMsg,
                                    pStubDesc );
           }
        else
            NdrServerInitializePartial( pRpcMsg,
                                        pStubMsg,
                                        pStubDesc,
                                        pContext->NdrInfo.pProcDesc->ClientBufferSize );
        }
    else
        {
        // pipe is not supported in obj interface.
        NDR_ASSERT( ! pContext->HasPipe, "Pipe is not supported in dcom" );
        NdrStubInitialize( pRpcMsg,
                           pStubMsg,
                           pStubDesc,
                           pChannel );
        }

    if ( pAsyncMsg )
        {
        pStubMsg->pAsyncMsg = pAsyncMsg;
        pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;
        }

    if ( pContext->NdrInfo.InterpreterFlags.FullPtrUsed )
        pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );
    else
        pStubMsg->FullPtrXlatTables = NULL;


        //
        // Set StackTop AFTER the initialize call, since it zeros the field
        // out.
        //
        pStubMsg->StackTop = pArgBuffer;

        if ( pContext->NdrInfo.pProcDesc->Oi2Flags.HasPipes )
            {
            NdrpPipesInitialize32( pStubMsg,
                                   &pContext->AllocateContext,
                                   (PFORMAT_STRING) pContext->Params,
                                   (char*)pArgBuffer,
                                   pContext->NumberParams );

            }

        //
        // We must make this check AFTER the call to ServerInitialize,
        // since that routine puts the stub descriptor alloc/dealloc routines
        // into the stub message.
        //
        if ( pContext->NdrInfo.InterpreterFlags.RpcSsAllocUsed )
            NdrRpcSsEnableAllocate( pStubMsg );

        if ( pContext->NdrInfo.pProcDesc->Oi2Flags.HasExtensions )
            {
            pStubMsg->fHasExtensions  = 1;
            pStubMsg->fHasNewCorrDesc = pContext->NdrInfo.pProcDesc->NdrExts.Flags2.HasNewCorrDesc;
            if ( pContext->NdrInfo.pProcDesc->NdrExts.Flags2.ServerCorrCheck )
                {

                void * pCorr = NdrpAlloca( &pContext->AllocateContext, NDR_DEFAULT_CORR_CACHE_SIZE );
                NdrCorrelationInitialize( pStubMsg,
                                          pCorr,
                                          NDR_DEFAULT_CORR_CACHE_SIZE,
                                          0  /* flags */ );
                }
            }

}


void NdrpServerOutInit( PMIDL_STUB_MESSAGE pStubMsg )
{
    ulong n;
    NDR_PROC_CONTEXT   *    pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PPARAM_DESCRIPTION      Params = ( PPARAM_DESCRIPTION ) pContext->Params;
    PFORMAT_STRING          pFormatTypes = pContext->DceTypeFormatString;
    uchar *                 pArgBuffer = pContext->StartofStack;
    uchar *                 pArg;
    PFORMAT_STRING          pFormatParam;

        for ( n = 0; n < pContext->NumberParams; n++ )
            {

            if ( !Params[n].ParamAttr.IsPartialIgnore )
                {
                if ( Params[n].ParamAttr.IsIn     ||
                     ( Params[n].ParamAttr.IsReturn && !pContext->HasComplexReturn  ) ||
                     Params[n].ParamAttr.IsPipe  )
                    continue;

                pArg = pArgBuffer + Params[n].StackOffset;
                }
            else
                {
                pArg = pArgBuffer + Params[n].StackOffset;

                if ( !*(void**)pArg )
                    continue;

                }

            //
            // Check if we can initialize this parameter using some of our
            // stack.
            //
            if ( Params[n].ParamAttr.ServerAllocSize != 0 )
                {
                *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext,
                                              Params[n].ParamAttr.ServerAllocSize * 8);

                MIDL_memset( *((void **)pArg),
                             0,
                             Params[n].ParamAttr.ServerAllocSize * 8 );
                continue;
                }
            else if ( Params[n].ParamAttr.IsBasetype )
                {
                *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext, 8 ); 
                MIDL_memset( *((void **)pArg), 0, 8 );
                continue;
                };

            pFormatParam = pFormatTypes + Params[n].TypeOffset;

            NdrOutInit( pStubMsg,
                        pFormatParam,
                        (uchar **)pArg );
            }


}

#if defined( BUILD_NDR64 )
BOOL IsServerSupportNDR64( MIDL_SERVER_INFO *pServerInfo )
{
    if ( ( pServerInfo->pStubDesc->Version > NDR_VERSION ) ||
         ( pServerInfo->pStubDesc->Version < NDR_VERSION_6_0 ) ||
         ( pServerInfo->pStubDesc->MIDLVersion < MIDL_VERSION_6_0_322 ) ||
         ! ( pServerInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES ) )
        return FALSE;
    return TRUE;


}
#endif

RPC_STATUS RPC_ENTRY
NdrClientGetSupportedSyntaxes(
    IN RPC_CLIENT_INTERFACE * pInf,
    OUT ulong * pCount,
    MIDL_SYNTAX_INFO ** pArr )
{
    MIDL_SYNTAX_INFO *pSyntaxInfo;

    NDR_ASSERT( pInf->Flags & RPCFLG_HAS_MULTI_SYNTAXES, "invalid clientif" );
    if ( pInf->Flags & RPCFLG_HAS_CALLBACK )
        {
        // interpreter info is  MIDL_SERVER_INFO
        MIDL_SERVER_INFO * pServerInfo = ( MIDL_SERVER_INFO *) pInf->InterpreterInfo;
        *pCount = ( ulong ) pServerInfo->nCount ;
        *pArr = pServerInfo->pSyntaxInfo;
        }
    else
        {
        MIDL_STUBLESS_PROXY_INFO * pProxyInfo = ( MIDL_STUBLESS_PROXY_INFO *) pInf->InterpreterInfo;
        *pCount = ( ulong ) pProxyInfo->nCount ;
        *pArr = pProxyInfo->pSyntaxInfo;
        }

    return RPC_S_OK;

}

RPC_STATUS RPC_ENTRY
NdrServerGetSupportedSyntaxes(
    IN RPC_SERVER_INTERFACE * pInf,
    OUT ulong * pCount,
    MIDL_SYNTAX_INFO ** pArr,
    OUT ulong * pPrefer)
{
    NDR_ASSERT( pInf->Flags & RPCFLG_HAS_MULTI_SYNTAXES,"invalid serverif" );
    MIDL_SERVER_INFO *pServerInfo = ( MIDL_SERVER_INFO *) pInf->InterpreterInfo;
    *pCount = ( ulong ) pServerInfo->nCount;
    *pArr = pServerInfo->pSyntaxInfo;
    NdrpGetPreferredSyntax( ( ulong )pServerInfo->nCount, pServerInfo->pSyntaxInfo, pPrefer );
    return RPC_S_OK;
}

RPC_STATUS RPC_ENTRY
NdrCreateServerInterfaceFromStub(
            IN IRpcStubBuffer* pStub,
            IN OUT RPC_SERVER_INTERFACE *pServerIf )
{
#if !defined( BUILD_NDR64 )
    return S_OK;
#else
    CInterfaceStubVtbl *    pStubVTable;
    PMIDL_SERVER_INFO       pServerInfo;
    IRpcStubBuffer *        pv = NULL;
    RpcTryExcept
        {
        // filter out non-ndr stub first.
        if ( S_OK != pStub->lpVtbl->QueryInterface(pStub, IID_IPrivStubBuffer, (void **)& pv ) )
            return S_OK;

        pv->lpVtbl->Release(pv);

        pStubVTable = (CInterfaceStubVtbl *)
                  (*((uchar **)pStub) - sizeof(CInterfaceStubHeader));

        pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

        // In /Os mode, we don't have pServerInfo.
        if ( pServerInfo &&
             IsServerSupportNDR64( pServerInfo ) )
            {
            memcpy ( &pServerIf->TransferSyntax, pServerInfo->pTransferSyntax, sizeof( RPC_SYNTAX_IDENTIFIER ) );
            pServerIf->Flags |= RPCFLG_HAS_MULTI_SYNTAXES;
            pServerIf->InterpreterInfo = pServerInfo;
            }
        }
    RpcExcept( 1 )
        {
        }
    RpcEndExcept
#endif

    return S_OK;
}



/*++

Routine Description :

    Read the proc header for different transfer syntax.
    We need to return proc number in dce because for stubs compiled with
    DCE only, proc header is the only place to get the procnum.

    This rountine being called from both client and server. The difference
    is that client side we are reading from the default one; server side we
    are reading from the selected one.
Arguments :


Return :

    none.   Raise exception if something goes wrong. We can't recovered
    from here because we don't have enough information about how the
    stub looks like if we don't have valid proc header.

--*/

ulong RPC_ENTRY
MulNdrpInitializeContextFromProc (
                          SYNTAX_TYPE            SyntaxType,
                          PFORMAT_STRING         pFormat,
                          NDR_PROC_CONTEXT  *    pContext,
                          uchar *                StartofStack,
                          BOOLEAN                IsReset )
{
    ulong                               RpcFlags;
    ulong                               ProcNum = 0;

    if ( !IsReset )
        NdrpInitializeProcContext( pContext );

    pContext->pProcFormat  = pFormat;
    pContext->StartofStack = StartofStack;


    if ( SyntaxType ==  XFER_SYNTAX_DCE )
        {
        PPARAM_DESCRIPTION          Params;
        INTERPRETER_FLAGS           InterpreterFlags;
        PFORMAT_STRING              pNewProcDescr;
        INTERPRETER_OPT_FLAGS       OptFlags;

        pContext->CurrentSyntaxType = XFER_SYNTAX_DCE;

        pContext->HandleType = *pFormat++ ;
        pContext->UseLocator = (FC_AUTO_HANDLE == pContext->HandleType);

        pContext->NdrInfo.InterpreterFlags = *((PINTERPRETER_FLAGS)pFormat++);

        InterpreterFlags = pContext->NdrInfo.InterpreterFlags;

        if ( InterpreterFlags.HasRpcFlags )
            RpcFlags = *(( UNALIGNED ulong* &)pFormat)++;
        else
            RpcFlags = 0;

        ProcNum   = *(ushort *)pFormat; pFormat += 2;
        pContext->StackSize = *(ushort *)pFormat; pFormat += 2;

        pContext->pHandleFormatSave = pFormat;

        pNewProcDescr = pFormat;

        if ( ! pContext->HandleType )
            {
            // explicit handle

            pNewProcDescr += ((*pFormat == FC_BIND_PRIMITIVE) ?  4 :  6);
            }

        pContext->NdrInfo.pProcDesc = (NDR_PROC_DESC *)pNewProcDescr;

        OptFlags = ( (NDR_PROC_DESC *)pNewProcDescr )->Oi2Flags;

        pContext->NumberParams = pContext->NdrInfo.pProcDesc->NumberParams;

        //
        // Parameter descriptions are nicely spit out by MIDL.
        // If there is no extension, Params is in the position of extensions.
        //
        Params = (PPARAM_DESCRIPTION) &( pContext->NdrInfo.pProcDesc->NdrExts );


        // Proc header extentions, from NDR ver. 5.2.
        // Params must be set correctly here because of exceptions.

        if ( OptFlags.HasExtensions )
            {
            pContext->HasComplexReturn = pContext->NdrInfo.pProcDesc->NdrExts.Flags2.HasComplexReturn;

            Params = (PPARAM_DESCRIPTION)((uchar*)Params + pContext->NdrInfo.pProcDesc->NdrExts.Size);
#if defined(_WIN64)
            PNDR_PROC_HEADER_EXTS64 pExts = (PNDR_PROC_HEADER_EXTS64 )&pContext->NdrInfo.pProcDesc->NdrExts;

            pContext->FloatDoubleMask = pExts->FloatArgMask;
#endif

            }

        pContext->Params = Params;

        pContext->IsAsync = OptFlags.HasAsyncUuid ;
        pContext->IsObject = InterpreterFlags.ObjectProc;
        pContext->HasPipe = OptFlags.HasPipes;

        pContext->ExceptionFlag = ! ( InterpreterFlags.IgnoreObjectException ) &&
                                  ( pContext->IsObject || InterpreterFlags.HasCommOrFault );           
        }   // XFER_SYNTAX_DCE

#if defined(BUILD_NDR64)

    else if ( SyntaxType == XFER_SYNTAX_NDR64  )
            {
            NDR64_PROC_FLAGS *  pProcFlags;

            pContext->CurrentSyntaxType = XFER_SYNTAX_NDR64;

            pContext->Ndr64Header = (NDR64_PROC_FORMAT *)pFormat;
            pContext->HandleType =
            NDR64MAPHANDLETYPE( NDR64GETHANDLETYPE( &pContext->Ndr64Header->Flags ) );
            pContext->UseLocator = (FC64_AUTO_HANDLE == pContext->HandleType);

            RpcFlags = pContext->Ndr64Header->RpcFlags;
#if defined(_WIN64)

            pContext->FloatDoubleMask = pContext->Ndr64Header->FloatDoubleMask;
#endif
            pContext->NumberParams = pContext->Ndr64Header->NumberOfParams;
            pContext->Params = (NDR64_PROC_FORMAT *)( (char *) pFormat + sizeof( NDR64_PROC_FORMAT ) + pContext->Ndr64Header->ExtensionSize );
            pContext->StackSize = pContext->Ndr64Header->StackSize;

            pProcFlags = (NDR64_PROC_FLAGS *) &pContext->Ndr64Header->Flags;

            pContext->HasComplexReturn = pProcFlags->HasComplexReturn;
            pContext->IsAsync = pProcFlags->IsAsync;
            pContext->IsObject = pProcFlags->IsObject;
            pContext->HasPipe = pProcFlags->UsesPipes;

            pContext->ExceptionFlag = pContext->IsObject || pProcFlags->HandlesExceptions;
            }   // XFER_SYNTAX_NDR64

#endif

    else
        {
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        NDR_ASSERT( 0, "Invalid transfer syntax.");
        }

    // setup the pipe flag before negotiation.
    if ( pContext->HasPipe )
        {
        RpcFlags &= ~RPC_BUFFER_COMPLETE;
        RpcFlags |= RPC_BUFFER_PARTIAL;
        }

    pContext->RpcFlags = RpcFlags;
    // We need to cleanup the resend flag during initialization in preparation
    // for retry later.
    pContext->NeedsResend = FALSE;

    return ProcNum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\mulsyntx.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    srvcall.c

Abstract :

    This file contains multiple transfer syntaxes negotiation related code

Author :

    Yong Qu    yongqu    September 1999. 

Revision History :


  ---------------------------------------------------------------------*/

#ifndef _MULSYNTX_H
#define _MULSYNTX_H
#include <stddef.h>

typedef struct _NDR_PROC_CONTEXT NDR_PROC_CONTEXT;
typedef struct _NDR_ALLOCA_CONTEXT NDR_ALLOCA_CONTEXT;

#ifdef __cplusplus
extern "C"
{
#endif
typedef void ( RPC_ENTRY * PFNMARSHALLING )( MIDL_STUB_MESSAGE *   pStubMsg,
                                  BOOL                   IsObject 
                                  );

typedef void ( RPC_ENTRY * PFNUNMARSHALLING ) 
              ( MIDL_STUB_MESSAGE *     pStubMsg,
                void *                  pReturnValue
                );

typedef void ( RPC_ENTRY * PFNINIT ) (MIDL_STUB_MESSAGE * pStubMsg,
                           void *              pReturnValue );

typedef void ( RPC_ENTRY * PFNSIZING ) (MIDL_STUB_MESSAGE *     pStubMsg,
             BOOL                   IsClient);

typedef unsigned char * ( RPC_ENTRY * PFNCLIENTGETBUFFER ) (MIDL_STUB_MESSAGE * pStubMsg );
                           
typedef void (* PFNGENERICUNBIND ) (
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    );

typedef unsigned char ( RPC_ENTRY * PFNGETBUFFER ) (
    PMIDL_STUB_MESSAGE      *       pStubMsg,
    unsigned    long                BufferLength );

typedef void ( RPC_ENTRY * PFNSENDRECEIVE ) (
    PMIDL_STUB_MESSAGE      *       pStubMsg );    
    
    
typedef void ( RPC_ENTRY *PFNCLIENT_EXCEPTION_HANDLING )
                 (  MIDL_STUB_MESSAGE  *    pStubMsg,
                    ulong                   ProcNum,
                    RPC_STATUS              ExceptionCode,
                    CLIENT_CALL_RETURN *    pReturnValue);

typedef VOID ( RPC_ENTRY *PFNCLIENTFINALLY )
                (   MIDL_STUB_MESSAGE   *   pStubMsg,
                    void *                  pThis );

// important! the vtbl sequence should match the fields in NDR_PROC_CONTEXT alwyas.
// we can't do anonymous structure in c++.
typedef struct _SYNTAX_DISPATCH_TABLE
{
    PFNINIT                         pfnInit;
    PFNSIZING                       pfnSizing;
    PFNMARSHALLING                  pfnMarshal;
    PFNUNMARSHALLING                pfnUnmarshal;
    PFNCLIENT_EXCEPTION_HANDLING    pfnExceptionHandling;
    PFNCLIENTFINALLY                pfnFinally;
//    PFNGETBUFFER                    pfnGetBuffer;
//    PFNSENDRECEIVE                  pfnSendReceive;
} SYNTAX_DISPATCH_TABLE;


typedef struct _NDR_PROC_DESC 
{
    unsigned short              ClientBufferSize;    // The Oi2 header
    unsigned short              ServerBufferSize;    //
    INTERPRETER_OPT_FLAGS       Oi2Flags;            //
    unsigned char               NumberParams;        //
    NDR_PROC_HEADER_EXTS        NdrExts;
} NDR_PROC_DESC;

typedef struct _NDR_PROC_INFO
{
    INTERPRETER_FLAGS           InterpreterFlags;
    NDR_PROC_DESC    *          pProcDesc;
} NDR_PROC_INFO;

#define NDR_ALLOCA_PREALLOCED_BLOCK_SIZE 512
#define NDR_ALLOCA_MIN_BLOCK_SIZE        4096

typedef struct _NDR_ALLOCA_CONTEXT {
  PBYTE pBlockPointer;
  LIST_ENTRY MemoryList;
  ULONG_PTR BytesRemaining;
#if defined(NDR_PROFILE_ALLOCA)
  SIZE_T AllocaBytes;
  SIZE_T AllocaAllocations;
  SIZE_T MemoryBytes;
  SIZE_T MemoryAllocations;
#endif
  BYTE PreAllocatedBlock[NDR_ALLOCA_PREALLOCED_BLOCK_SIZE];
} NDR_ALLOCA_CONTEXT, *PNDR_ALLOCA_CONTEXT;

// Simulated Alloca

VOID
NdrpAllocaInit(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    );

VOID
NdrpAllocaDestroy(
    PNDR_ALLOCA_CONTEXT pAllocaContext
    );

PVOID
NdrpAlloca(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    UINT Size
    );

class NDR_POINTER_QUEUE_ELEMENT;
typedef struct _NDR_PROC_CONTEXT
{
    SYNTAX_TYPE CurrentSyntaxType;
    union {
        NDR_PROC_INFO               NdrInfo;
        NDR64_PROC_FORMAT *         Ndr64Header;
        } ;
    PFORMAT_STRING                  pProcFormat;        // proc format string.    
    ulong                           NumberParams;    
    void *                          Params;
    uchar *                         StartofStack;
    uchar                           HandleType;
    handle_t                        SavedGenericHandle;    
    PFORMAT_STRING                  pHandleFormatSave;
    PFORMAT_STRING                  DceTypeFormatString;
    ulong                           IsAsync     : 1;
    ulong                           IsObject    : 1;
    ulong                           HasPipe     : 1;
    ulong                           HasComplexReturn :1;
    ulong                           NeedsResend  : 1;
    ulong                           UseLocator   : 1;
    ulong                           Reserved7    :1 ;
    ulong                           Reserved8   : 1;
    ulong                           Reservedleft: 8;
    ulong                           FloatDoubleMask;
    ulong                           ResendCount;
    ulong                           RpcFlags;
    ulong                           ExceptionFlag;
    ulong                           StackSize;
    MIDL_SYNTAX_INFO           *    pSyntaxInfo;
    PFNINIT                         pfnInit;
    PFNSIZING                       pfnSizing;
    PFNMARSHALLING                  pfnMarshal;
    PFNUNMARSHALLING                pfnUnMarshal;
    PFNCLIENT_EXCEPTION_HANDLING    pfnExceptionHandling;
    PFNCLIENTFINALLY                pfnClientFinally;
    NDR_PIPE_DESC              *    pPipeDesc;
    NDR_POINTER_QUEUE_ELEMENT  *    pQueueFreeList;
    NDR_ALLOCA_CONTEXT              AllocateContext;
} NDR_PROC_CONTEXT;

extern const uchar Ndr64HandleTypeMap[]; 

const extern RPC_SYNTAX_IDENTIFIER NDR_TRANSFER_SYNTAX;
const extern RPC_SYNTAX_IDENTIFIER NDR64_TRANSFER_SYNTAX;
const extern RPC_SYNTAX_IDENTIFIER FAKE_NDR64_TRANSFER_SYNTAX;

void
NdrServerSetupNDR64TransferSyntax(
    ulong                   ProcNum,
    MIDL_SYNTAX_INFO  *     pServerInfo,
    NDR_PROC_CONTEXT  *     pContext );

RPC_STATUS RPC_ENTRY
Ndr64ClientNegotiateTransferSyntax(
    void *                       pThis,
    MIDL_STUB_MESSAGE           *pStubMsg,
    MIDL_STUBLESS_PROXY_INFO    *pProxyInfo,
    NDR_PROC_CONTEXT            *pContext );

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall3(
    void *                      pThis,
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void                       *pReturnValue,
    NDR_PROC_CONTEXT        *   pContext,
    unsigned char *             StartofStack
    );

void RPC_ENTRY 
NdrpClientUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg,
                void  *                 pReturnValue );

void RPC_ENTRY 
NdrpServerUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg );


void RPC_ENTRY 
NdrpClientMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject );

void RPC_ENTRY 
NdrpServerMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject );


void RPC_ENTRY
NdrpClientInit( MIDL_STUB_MESSAGE * pStubMsg,
                           void *              pReturnValue );
                
void RPC_ENTRY 
Ndr64pClientUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg,
                void                *   pReturnValue  );

void RPC_ENTRY 
Ndr64pServerUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg  );


void RPC_ENTRY 
Ndr64pClientMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                    IsObject );

void RPC_ENTRY 
Ndr64pServerMarshal( MIDL_STUB_MESSAGE *    pStubMsg  );

void 
Ndr64pServerOutInit( PMIDL_STUB_MESSAGE pStubMsg );

void RPC_ENTRY
Ndr64pClientInit( MIDL_STUB_MESSAGE * pStubMsg,
                           void *              ReturnValue );


void RPC_ENTRY
NdrpClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );

void RPC_ENTRY
NdrpAsyncClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );

void RPC_ENTRY
NdrpDcomClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );

void RPC_ENTRY
NdrpNoopSizing( MIDL_STUB_MESSAGE *    pStubMsg,
            BOOL                   IsClient );

void RPC_ENTRY
NdrpSizing( MIDL_STUB_MESSAGE *     pStubMsg,
             BOOL                   IsClient );

void RPC_ENTRY
Ndr64pSizing( MIDL_STUB_MESSAGE *     pStubMsg,
             BOOL                   IsClient  );
                      
                      
void RPC_ENTRY
Ndr64pClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );
                
void RPC_ENTRY
Ndr64pDcomClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                   ProcNum,
                      RPC_STATUS              ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  );
                

void RPC_ENTRY NdrpClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                                  void *  pThis );

void RPC_ENTRY Ndr64pClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                                    void *  pThis );
                       

typedef handle_t (* PFNEXPLICITBINDHANDLEMGR)(PMIDL_STUB_DESC   pStubDesc,
                                              uchar *           ArgPtr,
                                              PFORMAT_STRING    pFormat,
                                              handle_t *        pSavedGenericHandle); 

typedef handle_t (* PFNIMPLICITBINDHANDLEMGR)(PMIDL_STUB_DESC   pStubDesc,
                                              uchar             HandleType,
                                              handle_t *        pSavedGenericHandle); 

void RPC_ENTRY
Ndr64ClientInitializeContext(
    SYNTAX_TYPE                         SyntaxType,
    const MIDL_STUBLESS_PROXY_INFO *    pProxyInfo,
    ulong                               nProcNum,
    NDR_PROC_CONTEXT *                  pContext,
    uchar *                             StartofStack );

RPC_STATUS RPC_ENTRY
Ndr64pClientSetupTransferSyntax( void * pThis,
                           RPC_MESSAGE  *                   pRpcMsg,
                           MIDL_STUB_MESSAGE  *             pStubMsg,
                           MIDL_STUBLESS_PROXY_INFO *       ProxyInfo,
                           NDR_PROC_CONTEXT *               pContext,
                           ulong                            nProcNum );

HRESULT
MulNdrpBeginDcomAsyncClientCall(
                            MIDL_STUBLESS_PROXY_INFO    *     pProxyInfo,
                            ulong                             nProcNum,
                            NDR_PROC_CONTEXT *                pContext, 
                            void *                            StartofStack );
HRESULT
MulNdrpFinishDcomAsyncClientCall(
                            MIDL_STUBLESS_PROXY_INFO    *     pProxyInfo,
                            ulong                             nProcNum,
                            NDR_PROC_CONTEXT *                pContext,
                            void *                            StartofStack );

void Ndr64SetupClientSyntaxVtbl( PRPC_SYNTAX_IDENTIFIER pSyntax,
                                 NDR_PROC_CONTEXT     * pContext );


ulong RPC_ENTRY
MulNdrpInitializeContextFromProc ( 
                          SYNTAX_TYPE    SyntaxType,
                          PFORMAT_STRING         pFormat,
                          NDR_PROC_CONTEXT  *    pContext,
                          uchar *                StartofStack,
                          BOOLEAN                IsReset = FALSE );

RPC_STATUS RPC_ENTRY
Ndr64SetupServerContext ( NDR_PROC_CONTEXT  * pContext,
                          PFORMAT_STRING      pFormat );

/* rpcndr64.h */
BOOL NdrValidateServerInfo( MIDL_SERVER_INFO *pServerInfo );

void 
NdrpServerInit( PMIDL_STUB_MESSAGE   pStubMsg,
                RPC_MESSAGE *        pRpcMsg,
                PMIDL_STUB_DESC      pStubDesc,
                void *               pThis,
                IRpcChannelBuffer *  pChannel,
                PNDR_ASYNC_MESSAGE   pAsynMsg);

void NdrpServerOutInit( PMIDL_STUB_MESSAGE pStubMsg );


void RPC_ENTRY
Ndr64ProxyInitialize(
    IN  void * pThis,
    IN  PRPC_MESSAGE                    pRpcMsg,
    IN  PMIDL_STUB_MESSAGE              pStubMsg,
    IN  PMIDL_STUBLESS_PROXY_INFO       pProxyInfo,
    IN  unsigned int                    ProcNum );


__forceinline 
PFORMAT_STRING
NdrpGetProcString( PMIDL_SYNTAX_INFO pSyntaxInfo,
                   SYNTAX_TYPE SyntaxType,
                   ulong       nProcNum )
{
   if ( SyntaxType == XFER_SYNTAX_DCE )
      {
        unsigned long nFormatOffset;
        nFormatOffset = (pSyntaxInfo->FmtStringOffset)[nProcNum];
        return (PFORMAT_STRING) &pSyntaxInfo->ProcString[nFormatOffset];
      }
   else 
      {
      return ((PFORMAT_STRING*)(pSyntaxInfo->FmtStringOffset))[nProcNum];      
      }
}

__forceinline 
SYNTAX_TYPE NdrpGetSyntaxType( PRPC_SYNTAX_IDENTIFIER pSyntaxId )
{
    SYNTAX_TYPE SyntaxType = (SYNTAX_TYPE)( * (ulong *)pSyntaxId );
#if !defined( __RPC_WIN64__ ) 
    if ( SyntaxType == XFER_SYNTAX_TEST_NDR64 )
        SyntaxType = XFER_SYNTAX_NDR64;
#endif
//    NDR_ASSERT( SyntaxType == XFER_SYNTAX_NDR64 || SyntaxType == XFER_SYNTAX_DCE,
//                "invliad transfer syntax" );
    return SyntaxType ;

}

__forceinline void
NdrpInitializeProcContext( NDR_PROC_CONTEXT * pContext )
{
    memset( pContext, 0, offsetof( NDR_PROC_CONTEXT, AllocateContext ) );
    NdrpAllocaInit( & pContext->AllocateContext );
}
                                      
#define NDR64GETHANDLETYPE(x) ( ((NDR64_PROC_FLAGS *)x)->HandleType )
#define NDR64MAPHANDLETYPE(x) ( Ndr64HandleTypeMap[ x ] )

#define SAMEDIRECTION(flag , Param ) ( flag ? Param.ParamAttr.IsIn : Param.ParamAttr.IsOut )
#define NDR64SAMEDIRECTION( flag, pParamFlags ) ( flag ? pParamFlags->IsIn : pParamFlags->IsOut )

__forceinline
void NdrpGetPreferredSyntax( ulong nCount,
                             MIDL_SYNTAX_INFO * pSyntaxInfo,
                             ulong * pPrefer )
{
    pSyntaxInfo;
    // ndr64 is always the last one.
#if !defined(__RPC_WIN64__)
    *pPrefer = nCount - 1;
//    *pPrefer = 0; // should be 0 in 32bit. 
#else
    *pPrefer = nCount -1;
#endif 
}

#ifdef __cplusplus
}
#endif

#endif // _MULSYNTX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\ndrole.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    ndrole.h

Abstract:
    OLE routines for interface pointer marshalling.

Author:
    ShannonC    18-Apr-1994

Environment:
    Windows NT and Windows 95.

Revision History:

---------------------------------------------------------------------*/

#ifndef _NDROLE_
#define _NDROLE_


#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

// ProxyFile->TableVersion may be
//    1 for really old junk
//    2 since the time we defined new proxy and stub Buffer2 for delegation
//    6 for async uuid as we treat the previous values as flags.

#define NDR_PROXY_FILE_ASYNC_UUID   0x4

EXTERN_C IStream *__stdcall
NdrpCreateStreamOnMemory( unsigned char *pData, unsigned long cbSize );

// Note, both proxies and stubs have been remapped to the same size,
// as a preparation for some code simplifications.
// This means that some fields may not be used in some circumstances.

// Non-delegated proxy

typedef struct tagCStdProxyBuffer
{
    const struct IRpcProxyBufferVtbl *  lpVtbl;
    const void *                        pProxyVtbl; //Points to Vtbl in CInterfaceProxyVtbl
    long                                RefCount;
    struct IUnknown *                   punkOuter;
    struct IRpcChannelBuffer *          pChannel;
    struct IPSFactoryBuffer    *        pPSFactory; // endof old ProxyBuffer
    struct IRpcProxyBuffer *            Pad_pBaseProxyBuffer;
    struct IPSFactoryBuffer *           Pad_pPSFactory;
    IID                                 Pad_iidBase;
    const struct ICallFactoryVtbl  *    pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    const struct IReleaseMarshalBuffersVtbl  *    pRMBVtbl;
} CStdProxyBuffer;

// Delegated proxy

typedef struct tagCStdProxyBuffer2
{
    const struct IRpcProxyBufferVtbl *  lpVtbl;
    const void *                        pProxyVtbl; //Points to Vtbl in CInterfaceProxyVtbl
    long                                RefCount;
    struct IUnknown *                   punkOuter;
    struct IRpcChannelBuffer *          pChannel;
    struct IUnknown *                   pBaseProxy; // colides with pPSFactory
    struct IRpcProxyBuffer *            pBaseProxyBuffer;
    struct IPSFactoryBuffer *           pPSFactory;
    IID                                 iidBase;    // endof old ProxyBuffer2
    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    const struct IReleaseMarshalBuffersVtbl  *    pRMBVtbl;
} CStdProxyBuffer2;

// Async proxy buffer, one for delegated and non-delegated case.

typedef struct _NdrDcomAsyncFlags
{
    unsigned long                       AsyncMsgSet     : 1;
    unsigned long                       BeginStarted    : 1;
    unsigned long                       BeginDone       : 1;
    unsigned long                       FinishStarted   : 1;
    unsigned long                       FinishDone      : 1;
    unsigned long                       BeginError      : 1;
    unsigned long                       FinishError     : 1;
    unsigned long                       InvokeForwarded : 1;
    unsigned long                       Unused          :24;
} NdrDcomAsyncFlags;

typedef struct _CStdProxyBufferMap
{
    struct IUnknown *                   pBaseProxy;
} CStdProxyBufferMap;

typedef struct _NdrDcomAsyncCallState
{
    unsigned long                       Signature;
    unsigned long                       Lock;
    void *                              pAsyncMsg;
    NdrDcomAsyncFlags                   Flags;
    HRESULT                             Hr;
} NdrDcomAsyncCallState;

typedef struct tagCStdAsyncProxyBuffer
{
    const struct IRpcProxyBufferVtbl *  lpVtbl;
    const void *                        pProxyVtbl; //Points to Vtbl in CInterfaceProxyVtbl
    long                                RefCount;
    struct IUnknown *                   punkOuter;
    struct IRpcChannelBuffer *          pChannel;
    CStdProxyBufferMap                  map;        // the only colision 1<>2
    struct IRpcProxyBuffer *            pBaseProxyBuffer;
    struct IPSFactoryBuffer *           pPSFactory;
    IID                                 iidBase;
    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pSyncIID;  // points to sync iid in async
    // endof new ProxyBuffer,2 

    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
    NdrDcomAsyncCallState               CallState;

} CStdAsyncProxyBuffer;


// This definition is in rpcproxy.h because CStdStubBuffer::pvServerObject is called explicitly
// from /Os stub.
// It is reproduced here for convenience.
// It should be removed from there or may be left but a renamed clone  used internally.

#if 0
typedef struct tagCStdStubBuffer
{
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
} CStdStubBuffer;
#endif

// The plan to rewrite and colapse these structure does involve removing of the
// pvServerObject field completely.
// The channel would supply a pvServerObject pointer on the only call where
// this is really needed, that is on the Invoke call.
// In this model there would be no need whatsover for Connect and Disconnect operations
// on the stub object, both sync stubs and async stub call objects.


typedef struct tagCStdStubBuffer2
{
    const void *                        lpForwardingVtbl;
    struct IRpcStubBuffer *             pBaseStubBuffer;
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;
} CStdStubBuffer2;

typedef struct tagCStdAsyncStubBuffer
{
    void *                              lpForwardingVtbl;
    struct IRpcStubBuffer *             pBaseStubBuffer;
    const struct IRpcStubBufferVtbl *   lpVtbl; //Points to Vtbl field in CInterfaceStubVtbl.
    long                                RefCount;
    struct IUnknown *                   pvServerObject;

    const struct ICallFactoryVtbl *     pCallFactoryVtbl;
    const IID *                         pAsyncIID;
    struct IPSFactoryBuffer *           pPSFactory;
    const struct IReleaseMarshalBuffersVtbl *     pRMBVtbl;

    const struct ISynchronizeVtbl *     pSynchronizeVtbl;

    NdrDcomAsyncCallState               CallState;

} CStdAsyncStubBuffer;



HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_QueryInterface(IRpcProxyBuffer *pThis,REFIID riid, void **ppv);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_AddRef(IRpcProxyBuffer *pThis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel);

void STDMETHODCALLTYPE
CStdProxyBuffer_Disconnect(IRpcProxyBuffer *pThis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_Release(IRpcProxyBuffer *pThis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel);

void STDMETHODCALLTYPE
CStdProxyBuffer2_Disconnect(IRpcProxyBuffer *pThis);


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_RMB_QueryInterface(IReleaseMarshalBuffers *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_RMB_AddRef(IReleaseMarshalBuffers *pthis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_RMB_Release(IReleaseMarshalBuffers *pthis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_RMB_ReleaseMarshalBuffer(IN IReleaseMarshalBuffers *This,RPCOLEMESSAGE * pMsg,DWORD dwFlags,IUnknown *pChnl);

HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_RMB_ReleaseMarshalBuffer(IN IReleaseMarshalBuffers *This,RPCOLEMESSAGE * pMsg,DWORD dwFlags,IUnknown *pChnl);


HRESULT STDMETHODCALLTYPE
IUnknown_QueryInterface_Proxy(
    IN  IUnknown *  This,
    IN  REFIID      riid,
    OUT void **     ppv);

ULONG STDMETHODCALLTYPE
IUnknown_AddRef_Proxy(
    IN  IUnknown *This);

ULONG STDMETHODCALLTYPE
IUnknown_Release_Proxy(
    IN  IUnknown *This);


HRESULT STDMETHODCALLTYPE
Forwarding_QueryInterface(
    IN  IUnknown *  This,
    IN  REFIID      riid,
    OUT void **     ppv);

ULONG STDMETHODCALLTYPE
Forwarding_AddRef(
    IN  IUnknown *This);

ULONG STDMETHODCALLTYPE
Forwarding_Release(
    IN  IUnknown *This);


void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD             * pdwStubPhase);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(IRpcStubBuffer *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(IRpcStubBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(IRpcStubBuffer *pthis, IUnknown *pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(IRpcStubBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(IRpcStubBuffer *pthis,RPCOLEMESSAGE *_prpcmsg,IRpcChannelBuffer *_pRpcChannelBuffer);

IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(IRpcStubBuffer *pthis,REFIID riid);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(IRpcStubBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(IRpcStubBuffer *pthis, void **ppv);

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(IRpcStubBuffer *pthis, void *pv);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_Connect(IRpcStubBuffer *pthis, IUnknown *pUnkServer);

void STDMETHODCALLTYPE
CStdStubBuffer2_Disconnect(IRpcStubBuffer *pthis);

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_CountRefs(IRpcStubBuffer *pthis);

//  Async

extern const IRpcProxyBufferVtbl CStdAsyncProxyBufferVtbl;
extern const IRpcProxyBufferVtbl CStdAsyncProxyBuffer2Vtbl;

extern const IRpcStubBufferVtbl CStdAsyncStubBufferVtbl;
extern const IRpcStubBufferVtbl CStdAsyncStubBuffer2Vtbl;

extern const ISynchronizeVtbl CStdStubBuffer_ISynchronizeVtbl;
extern const ISynchronizeVtbl CStdStubBuffer2_ISynchronizeVtbl;

extern void * const ForwardingVtbl[];


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_CF_QueryInterface(ICallFactory *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_CF_AddRef(ICallFactory *pthis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_CF_Release(ICallFactory *pthis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_CF_CreateCall(ICallFactory *pthis, REFIID riid, IUnknown* punkOuter, REFIID riid2, IUnknown **ppvObject);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_CF_QueryInterface(ICallFactory *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_CF_AddRef(ICallFactory *pthis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_CF_Release(ICallFactory *pthis);

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_CF_CreateCall(ICallFactory *pthis, REFIID riid, IUnknown* punkOuter, REFIID riid2, IUnknown **ppvObject);


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_CF_QueryInterface(ICallFactory *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CF_AddRef(ICallFactory *pthis);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CF_Release(ICallFactory *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_CF_CreateCall(ICallFactory *pthis, REFIID riid, IUnknown* punkOuter, REFIID riid2, IUnknown **ppvObject);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_CF_QueryInterface(ICallFactory *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_CF_AddRef(ICallFactory *pthis);

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_CF_Release(ICallFactory *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_CF_CreateCall(ICallFactory *pthis, REFIID riid, IUnknown* punkOuter, REFIID riid2, IUnknown **ppvObject);


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_RMB_QueryInterface(IReleaseMarshalBuffers *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_RMB_AddRef(IReleaseMarshalBuffers *pthis);

ULONG STDMETHODCALLTYPE
CStdStubBuffer_RMB_Release(IReleaseMarshalBuffers *pthis);

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_RMB_ReleaseMarshalBuffer(IN IReleaseMarshalBuffers *This,RPCOLEMESSAGE * pMsg,DWORD dwFlags,IUnknown *pChnl);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_QueryInterface(IReleaseMarshalBuffers *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_AddRef(IReleaseMarshalBuffers *pthis);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_Release(IReleaseMarshalBuffers *pthis);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_ReleaseMarshalBuffer(IN IReleaseMarshalBuffers *This,RPCOLEMESSAGE * pMsg,DWORD dwFlags,IUnknown *pChnl);


HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_QueryInterface(IRpcProxyBuffer *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdAsyncProxyBuffer_Release(IRpcProxyBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel);

ULONG STDMETHODCALLTYPE
CStdAsyncProxyBuffer2_Release(IRpcProxyBuffer *pThis);

HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer2_Connect(IRpcProxyBuffer *pThis, IRpcChannelBuffer *pChannel);


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_QueryInterface(IRpcStubBuffer *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_AddRef(IRpcStubBuffer *pthis);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Release(IRpcStubBuffer *pthis);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Release(IRpcStubBuffer *pthis);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Connect(IRpcStubBuffer *pthis, IUnknown *pUnkServer);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Connect(IRpcStubBuffer *pthis, IUnknown *pUnkServer);

void STDMETHODCALLTYPE
CStdAsyncStubBuffer_Disconnect(IRpcStubBuffer *pthis );

void STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Disconnect(IRpcStubBuffer *pthis );

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Invoke(IRpcStubBuffer *pthis,RPCOLEMESSAGE *_prpcmsg,IRpcChannelBuffer *_pRpcChannelBuffer);


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_QueryInterface( ISynchronize *pthis, REFIID riid, void **ppvObject);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_AddRef(ISynchronize *pthis);

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Release(ISynchronize *pthis);

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Wait( ISynchronize *pthis, DWORD dwFlags, DWORD mili );

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Signal( ISynchronize *pthis );

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Reset( ISynchronize *pthis );


HRESULT
NdrpAsyncProxySignal(
    CStdAsyncProxyBuffer * pAsyncPB );

HRESULT
NdrpAsyncProxyMsgConstructor(
    CStdAsyncProxyBuffer * pAsyncPB );

HRESULT
NdrpAsyncProxyMsgDestructor(
    CStdAsyncProxyBuffer * pAsyncPB );


HRESULT
NdrpAsyncStubMsgConstructor(
    CStdAsyncStubBuffer * pAsyncSB );

HRESULT
NdrpAsyncStubMsgDestructor(
    CStdAsyncStubBuffer * pAsyncSB );

HRESULT
NdrLoadOleRoutines();

typedef
HRESULT (STDAPICALLTYPE RPC_GET_CLASS_OBJECT_ROUTINE)(
    REFCLSID      rclsid,
    DWORD dwClsContext,
    void *pvReserved,
    REFIID riid,
    void **ppv);

typedef
HRESULT (STDAPICALLTYPE RPC_GET_MARSHAL_SIZE_MAX_ROUTINE)(
    ULONG *     pulSize,
    REFIID      riid,
    LPUNKNOWN   pUnk,
    DWORD       dwDestContext,
    LPVOID      pvDestContext,
    DWORD       mshlflags);

typedef
HRESULT (STDAPICALLTYPE RPC_MARSHAL_INTERFACE_ROUTINE)(
    LPSTREAM    pStm,
    REFIID      riid,
    LPUNKNOWN   pUnk,
    DWORD       dwDestContext,
    LPVOID      pvDestContext,
    DWORD       mshlflags);

typedef
HRESULT (STDAPICALLTYPE RPC_UNMARSHAL_INTERFACE_ROUTINE)(
    LPSTREAM    pStm,
    REFIID      riid,
    LPVOID FAR* ppv);

typedef
HRESULT (STDAPICALLTYPE RPC_STRING_FROM_IID)(
    REFIID rclsid,
    LPOLESTR FAR* lplpsz);

typedef
HRESULT (STDAPICALLTYPE RPC_GET_PS_CLSID)(
    REFIID iid,
    LPCLSID lpclsid);

typedef
HRESULT (STDAPICALLTYPE RPC_CO_CREATE_INSTANCE)(
    REFCLSID    rclsid,
    LPUNKNOWN   pUnkOuter,
    DWORD       dwClsContext,
    REFIID      riid,
    LPVOID *    ppv);

typedef
HRESULT (STDAPICALLTYPE RPC_CO_RELEASEMARSHALDATA)(
    IStream * pStm);

typedef
HRESULT (STDAPICALLTYPE RPC_DCOMCHANNELSETHRESULT)(
        PRPC_MESSAGE pmsg,
        ULONG * ulReserved,
        HRESULT appsHR );


extern  RPC_GET_CLASS_OBJECT_ROUTINE     *  pfnCoGetClassObject;
extern  RPC_GET_MARSHAL_SIZE_MAX_ROUTINE *  pfnCoGetMarshalSizeMax;
extern  RPC_MARSHAL_INTERFACE_ROUTINE    *  pfnCoMarshalInterface;
extern  RPC_UNMARSHAL_INTERFACE_ROUTINE  *  pfnCoUnmarshalInterface;
extern  RPC_STRING_FROM_IID              *  pfnStringFromIID;
extern  RPC_GET_PS_CLSID                 *  pfnCoGetPSClsid;
extern  RPC_CO_CREATE_INSTANCE           *  pfnCoCreateInstance;
extern  RPC_CO_RELEASEMARSHALDATA        *  pfnCoReleaseMarshalData;
extern  RPC_CLIENT_ALLOC                 *  pfnCoTaskMemAlloc;
extern  RPC_CLIENT_FREE                  *  pfnCoTaskMemFree;
extern  RPC_DCOMCHANNELSETHRESULT        *  pfnDcomChannelSetHResult;


HRESULT (STDAPICALLTYPE NdrStringFromIID)(
    REFIID rclsid,
    char * lplpsz);

//------------------------------------------------------------------------
// New async support
// -----------------------------------------------------------------------

void
NdrpAsyncProxyMgrConstructor(
    CStdAsyncProxyBuffer * pAsyncPB );

void
NdrpAsyncStubMgrConstructor(
    CStdAsyncStubBuffer * pAsyncSB );

HRESULT
NdrpAsyncStubSignal(
    CStdAsyncStubBuffer * pAsyncSB );


const IID * RPC_ENTRY
NdrGetProxyIID(
    IN  const void *pThis);


HRESULT NdrpClientReleaseMarshalBuffer(
        IReleaseMarshalBuffers * pRMB,
        RPC_MESSAGE *pRpcMsg,
        DWORD dwIOFlags,
        BOOLEAN fAsync);

HRESULT NdrpServerReleaseMarshalBuffer(
        IReleaseMarshalBuffers *pRMB,
        RPC_MESSAGE *pRpcMsg,
        DWORD dwIOFlags,
        BOOLEAN fAsync);

HRESULT Ndr64pReleaseMarshalBuffer( 
        PRPC_MESSAGE        pRpcMsg,
        PMIDL_SYNTAX_INFO   pSyntaxInfo,
        unsigned long       ProcNum,
        PMIDL_STUB_DESC     pStubDesc,
        DWORD               dwIOFlags,
        BOOLEAN             IsClient );

HRESULT 
NdrpInitializeMutex( I_RPC_MUTEX * pMutex );

EXTERN_C const IID IID_IPrivStubBuffer;
//--------------------
// HookOle Interface
//--------------------
EXTERN_C extern const IID IID_IPSFactoryHook;

#if defined(__cplusplus) && !defined(CINTERFACE)
interface IPSFactoryHook : public IPSFactoryBuffer
{
public:

    STDMETHOD (HkGetProxyFileInfo)
    (
        REFIID          riid,
        PINT            pOffset,
        PVOID           *ppProxyFileInfo
    )=0;
};
typedef IPSFactoryHook *PI_PSFACTORYHOOK;

#else   /* C Style Interface */

    typedef struct IPSFactoryHookVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( __stdcall *QueryInterface )(
            IPSFactoryBuffer *  This,
            /* [in] */ REFIID   riid,
            /* [out] */ void ** ppvObject);

        ULONG ( __stdcall *AddRef )(
            IPSFactoryBuffer *  This);

        ULONG ( __stdcall *Release )(
            IPSFactoryBuffer *  This);

        HRESULT ( __stdcall *CreateProxy )(
            IPSFactoryBuffer            *   This,
            /* [in] */ IUnknown         *   pUnkOuter,
            /* [in] */ REFIID               riid,
            /* [out] */ IRpcProxyBuffer **  ppProxy,
            /* [out] */ void            **  ppv);

        HRESULT ( __stdcall *CreateStub )(
            IPSFactoryBuffer            *   This,
            /* [in] */ REFIID               riid,
            /* [unique][in] */ IUnknown *   pUnkServer,
            /* [out] */ IRpcStubBuffer  **  ppStub);


        HRESULT ( __stdcall *HkGetProxyFileInfo )(
            IPSFactoryBuffer *  This,
            /* [in] */ REFIID   riid,
            /* [out]*/ PINT     pOffset,
            /* [out]*/ PVOID  * ppProxyFileInfo);

        END_INTERFACE
    } IPSFactoryHookVtbl;


    interface IPSFactoryHook
    {
        CONST_VTBL struct IPSFactoryHookVtbl *lpVtbl;
    };

typedef interface IPSFactoryHook *PI_PSFACTORYHOOK;

#ifdef COBJMACROS

#define IPSFactoryHook_QueryInterface(This,riid,ppvObject)    \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPSFactoryHook_AddRef(This)   \
    (This)->lpVtbl -> AddRef(This)

#define IPSFactoryHook_Release(This)  \
    (This)->lpVtbl -> Release(This)


#define IPSFactoryHook_CreateProxy(This,pUnkOuter,riid,ppProxy,ppv)   \
    (This)->lpVtbl -> CreateProxy(This,pUnkOuter,riid,ppProxy,ppv)

#define IPSFactoryHook_CreateStub(This,riid,pUnkServer,ppStub)    \
    (This)->lpVtbl -> CreateStub(This,riid,pUnkServer,ppStub)

#define IPSFactoryHook_HkGetProxyFileInfo(This,riid,pOffset,ppProxyFileInfo)    \
    (This)->lpVtbl -> HkGetProxyFileInfo(This,riid,pOffset,ppProxyFileInfo)

#endif /* COBJMACROS */


#endif  /* C style interface */
//-------------------------
// End - HookOle Interface
//-------------------------

#ifdef __cplusplus
}
#endif

#endif /* _NDROLE_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\mrshlp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

	mrshlp.h

Abtract :
	
	Contains private definitions for mrshl.c.

Author : 
	
	David Kays	dkays 	September 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _MRSHLP_
#define _MRSHLP_

void 
NdrpPointerMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pBufferMark,
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpConformantArrayMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpConformantVaryingArrayMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpComplexArrayMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpConformantStringMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpUnionMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat,
	long						SwitchIs,
	uchar						SwitchType
	);

PFORMAT_STRING
NdrpEmbeddedPointerMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

PFORMAT_STRING 
NdrpEmbeddedRepeatPointerMarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

ULONG_PTR
NdrpComputeConformance(
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);

void 
NdrpComputeVariance(
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat
	);


typedef uchar * (RPC_ENTRY * PMARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar *, 
					PFORMAT_STRING
				);

typedef void 	(* PPRIVATE_MARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar *, 
					PFORMAT_STRING
				);


extern const PSIMPLETYPE_MARSHAL_ROUTINE SimpleTypeMarshallRoutinesTable[];
//
// Function table defined in mrshl.c
//
IMPORTSPEC
extern const PMARSHALL_ROUTINE * pfnMarshallRoutines; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\pipendr.h ===
/************************************************************************

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    pipendr.h

Abstract :

    NDR Pipe related definitions.

Author :

    RyszardK       December 1995

Revision History :

  ***********************************************************************/

#ifndef _PIPENDR_H_
#define _PIPENDR_H_

#include "interp2.h"

typedef struct _NDR_PIPE_DESC * PNDR_PIPE_DESC;


#define PIPE_PARTIAL_BUFFER_SIZE   5000
#define PIPE_ELEM_BUFFER_SIZE      5000
//                  
// Signature and version
//

#define NDR_PIPE_SIGNATURE          (ushort) 0x5667
#define NDR_PIPE_VERSION            (short)  0x3031

//
// Pipe flags
//

#define NDR_IN_PIPE                 0x0001
#define NDR_OUT_PIPE                0x0002
#define NDR_LAST_IN_PIPE            0x0004
#define NDR_LAST_OUT_PIPE           0x0008
#define NDR_OUT_ALLOCED             0x0010
#define NDR_REF_PIPE                0x0020

//
// Pipe Status - global state for individual pipes in the pipe message.
//

typedef enum {
    NDR_PIPE_NOT_OPENED,
    NDR_PIPE_ACTIVE_IN,
    NDR_PIPE_ACTIVE_OUT,
    NDR_PIPE_DRAINED
    } NDR_PIPE_STATUS;


#define PLONG_LV_CAST        *(long * *)&
#define PULONG_LV_CAST       *(ulong * *)&

#define WIRE_PAD(size, al)   ((((ulong)size)&al) ? ((ulong)(al+1)-(((ulong)size)&al)) : 0)

#define REMAINING_BYTES() ((long)pStubMsg->RpcMsg->BufferLength - \
                           (long)(pStubMsg->Buffer - (uchar*)pStubMsg->RpcMsg->Buffer))

// These are the states of the state machine processing the chunks
// in the marshaling buffer.

typedef enum {
    START,
    COPY_PIPE_ELEM,
    RETURN_PARTIAL_ELEM,
    READ_PARTIAL_ELEM,
    VERIFY_TAIL_CHUNK
    } RECEIVE_STATES;


typedef struct _FC_PIPE_DEF
    {
    unsigned char   Fc;

    unsigned char   Align      : 4;     //
    unsigned char   Unused     : 1;     //  Flag and alignment byte
    unsigned char   HasRange   : 1;     // 
    unsigned char   ObjectPipe : 1;     //
    unsigned char   BigPipe    : 1;     //

    short           TypeOffset;
    union
        {
        struct
            {
            unsigned short  MemSize;
            unsigned short  WireSize;
            unsigned long   LowChunkLimit;
            unsigned long   HighChunkLimit;
            } s;
        struct
            {
            unsigned long   MemSize;
            unsigned long   WireSize;
            unsigned long   LowChunkLimit;
            unsigned long   HighChunkLimit;
            } Big;
        };
    } FC_PIPE_DEF;

//
// The NDR_PIPE_*_RTN are templates for the DCE raw runtime routines.
// This should be moved to rpcndr.h when we decide to expose -Os stubs.
//

typedef void
(__RPC_API * NDR_PIPE_PULL_RTN)(
        char          *  state,
        void          *  buf,
        unsigned long    esize,
        unsigned long *  ecount );

typedef  void
(__RPC_API * NDR_PIPE_PUSH_RTN)(
        char          *  state,
        void          *  buf,
        unsigned long    ecount );

typedef void
(__RPC_API * NDR_PIPE_ALLOC_RTN)(
        char             *  state,
        unsigned long       bsize,
        void             ** buf,
        unsigned long    *  bcount );

//
// The NDR_HR_PIPE_*_RTN are templates abstracting DCOM pipe routines 
// and also async raw pipe routine - note that there is an error code returned.
//

typedef RPC_STATUS
(__RPC_API * NDR_HR_PIPE_PULL_RTN)(
        char          *  state,
        void          *  buf,
        unsigned long    esize,
        unsigned long *  ecount );

typedef  RPC_STATUS
(__RPC_API * NDR_HR_PIPE_PUSH_RTN)(
        char          *  state,
        void          *  buf,
        unsigned long    ecount );

typedef RPC_STATUS
(__RPC_API * NDR_HR_PIPE_ALLOC_RTN)(
        char             *  state,
        unsigned long       bsize,
        void             ** buf,
        unsigned long    *  bcount );


typedef struct  _GENERIC_PIPE_TYPE
    {
    NDR_HR_PIPE_PULL_RTN       pfnPull;
    NDR_HR_PIPE_PUSH_RTN       pfnPush;
    NDR_HR_PIPE_ALLOC_RTN      pfnAlloc;
    char  *                    pState;
    } GENERIC_PIPE_TYPE;


#define NDR_DEFAULT_PIPE_HIGH_CHUNK_LIMIT   0x0ffffff /* less than 2GB */

typedef struct {
    int                 CurrentState;
    int                 TotalElemsCount;
    int                 OrigElemsInChunk;
    int                 ElemsInChunk;
    int                 ElemAlign;          
    int                 ElemWireSize;         
    int                 ElemMemSize;
    int                 PartialBufferSize;
    unsigned char *     PartialElem;
    int                 PartialElemSize;
    int                 PartialOffset;
    int                 EndOfPipe : 1;
    int                 EndOfPipePending : 1;
    int                 LowChunkLimit;
    int                 HighChunkLimit;
    BOOL                fBlockCopy;
    int                 ElemPad;
    PFORMAT_STRING      TypeFormat;
    } NDR_PIPE_STATE;

typedef enum _NDR_DCOM_PIPE_STATE 
    {
     NDR_DCOM_NO_PIPES,
     NDR_DCOM_IN_PIPE_PROCESSING,
     NDR_DCOM_IN_PIPES_DRAINED,
     NDR_DCOM_OUT_PIPE_PROCESSING,
     NDR_DCOM_OUT_PIPES_DRAINED,
     NDR_DCOM_PIPES_DONE,
     NDR_DCOM_PIPE_ERROR
    } NDR_DCOM_PIPE_STATE;

typedef struct  _NDR_PIPE_MESSAGE
    {
    unsigned short          Signature;
    unsigned short          PipeId;
    unsigned short          PipeStatus;
    unsigned short          PipeFlags;
    PFORMAT_STRING          pTypeFormat;
    PMIDL_STUB_MESSAGE      pStubMsg;
    GENERIC_PIPE_TYPE    *  pPipeObject;
    } NDR_PIPE_MESSAGE, * PNDR_PIPE_MESSAGE;

//
// Flags helping with the buffer management at the server.
// [in] pipes need to be processed within a separate in buffer.
// This buffer needs to be freed after last [in] pipe.
// [out] pipe processing has to start with a partial RpcGetBuffer.
// Nothing needs to be done with that buffer before return to runtime.
//

typedef struct  _PIPEDESC_FLAGS
    {
    unsigned short          AuxOutBufferAllocated : 1;
    unsigned short          NoBufferCallPending   : 1;
    unsigned short          Reserved              : 1;
    unsigned short          NoMoreBuffersToRead   : 1;
    } PIPEDESC_FLAGS;

#ifdef __cplusplus

class NDR_PIPE_HELPER
{

public:
    // Init functions
    virtual PNDR_PIPE_DESC GetPipeDesc() = 0;

    // Parameter enum functions
    virtual bool InitParamEnum() = 0;
    virtual bool GotoNextParam() = 0;
    virtual unsigned short GetParamPipeFlags() = 0;
    virtual PFORMAT_STRING GetParamTypeFormat() = 0;
    virtual char *GetParamArgument() = 0;

    // Pipe State
    virtual void InitPipeStateWithType( PNDR_PIPE_MESSAGE pPipeMsg) = 0;
    
    // Marshall Unmarshall Functions.
    virtual void MarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                               uchar *pMemory,
                               unsigned long Elements ) = 0;
    virtual void UnmarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements ) = 0;
    virtual void BufferSizeType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements ) = 0;
    virtual void ConvertType( PNDR_PIPE_MESSAGE pPipeMsg,
                              unsigned long Elements ) = 0;

    virtual void BufferSizeChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg ) = 0;

    virtual bool UnmarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong *pOut ) = 0;

    virtual void MarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                       ulong Counter ) = 0;

    virtual void BufferSizeChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg ) = 0;

    virtual void MarshallChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                           ulong Counter ) = 0;

    virtual bool VerifyChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong HeaderCounter ) = 0;
    virtual bool HasChunkTailCounter() = 0;

};

typedef NDR_PIPE_HELPER *PNDR_PIPE_HELPER;

#else // #ifdef __cplusplus

typedef void *PNDR_PIPE_HELPER;

#endif

typedef struct _NDR_ALLOCA_CONTEXT *PNDR_ALLOCA_CONTEXT;

typedef struct  _NDR_PIPE_DESC
    {
    NDR_PIPE_MESSAGE  *     pPipeMsg;
    short                   CurrentPipe;
    short                   PrevPipe;
    short                   InPipes;
    short                   OutPipes;
    short                   TotalPipes;
    short                   PipeVersion;
    PIPEDESC_FLAGS          Flags;
    unsigned long           PipeException;
    unsigned char    *      DispatchBuffer;
    unsigned long           DispatchBufferLength;
    unsigned char    *      LastPartialBuffer;
    unsigned long           LastPartialSize;
    unsigned char           Leftover[8];
    unsigned long           LeftoverSize;
    unsigned char    *      BufferSave;
    unsigned long           LengthSave;
    NDR_PIPE_STATE          RuntimeState;
    void             *      ChainingBuffer;
    unsigned long           ChainingBufferSize;
    PNDR_PIPE_HELPER        pPipeHelper;
    PNDR_ALLOCA_CONTEXT     pAllocContext;
    } NDR_PIPE_DESC, * PNDR_PIPE_DESC;


//
// Most of these prototypes should be exposed when we have -Os stubs.
//

void  RPC_ENTRY
NdrPipeAlloc(
    char             *  pState,
    unsigned long       bsize,
    void            **  buf,
    unsigned long    *  bcount );

RPC_STATUS  RPC_ENTRY
NdrAsyncPipeAlloc(
    char             *  pState,
    unsigned long       bsize,
    void            **  buf,
    unsigned long    *  bcount );


RPCRTAPI
RPC_STATUS  RPC_ENTRY
NdrAsyncPipePull(
    char          *     pState,
    void          *     buf,
    unsigned long       esize,
    unsigned long *     ecount );

RPCRTAPI
RPC_STATUS  RPC_ENTRY
NdrAsyncPipePush(
    char          *     pState,
    void          *     buf,
    unsigned long       ecount );

void
NdrpPipeElementBufferSize( 
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    ulong               ElemCount 
    );

void
NdrpPipeElementConvertAndUnmarshal( 
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar * *           ppMemory,
    long                ElemMemCount,
    long  *             pActCount
    );

BOOL
NdrReadPipeElements(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char *     pTargetBuffer,
    long *              pElementsRead
    );

void
NdrpReadPipeElementsFromBuffer (
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            TargetBuffer,
    long                TargetBufferCount, 
    long *              NumCopied
    );

RPC_STATUS
NdrpPushPipeForClient( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC   *   pPipeDesc,
    BOOL                fPushWholePipe,
    long            *   pActElems );

RPC_STATUS
NdrpPullPipeForClient( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC   *   pPipeDesc,
    BOOL                fPushWholePipe,
    long            *   pActElems,
    BOOL            *   fEndOfPipe );

void
NdrMarkNextActivePipe(
    NDR_PIPE_DESC   *   pPipeDesc );

RPC_STATUS RPC_ENTRY
NdrSend(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    BOOL                fPartial );

void RPC_ENTRY
NdrPartialSend(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg );

void RPC_ENTRY
NdrCompleteSend(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg );

void RPC_ENTRY
NdrReceive(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       Size,
    BOOL                fPartial );

void RPC_ENTRY
NdrPartialReceive(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       Size );

void RPC_ENTRY
NdrPipeSendReceive(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC *     pPipeDesc
    );

void
RPC_ENTRY
NdrIsAppDoneWithPipes(
    PNDR_PIPE_DESC      pPipeDesc
    );

void RPC_ENTRY
NdrPipesInitialize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_PIPE_HELPER    pPipeHelper,
    PNDR_ALLOCA_CONTEXT pAllocContext
    );

void
NdrpPipesInitialize32(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_ALLOCA_CONTEXT pAllocContext,
    PFORMAT_STRING      Params,
    char *              pStackTop,
    unsigned long       NumberParams
    );

void
NdrpPipesInitialize64(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_ALLOCA_CONTEXT pAllocContext,
    PFORMAT_STRING      Params,
    char *              pStackTop,
    unsigned long       NumberParams
    );  

RPCRTAPI
void
RPC_ENTRY
NdrPipePull(
    char          *     pState,
    void          *     buf,
    unsigned long       esize,
    unsigned long *     ecount );

RPCRTAPI
void
RPC_ENTRY
NdrPipePush(
    char          *     pState,
    void          *     buf,
    unsigned long       ecount );

RPCRTAPI
unsigned char *
RPC_ENTRY
NdrGetPipeBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferLength,
    RPC_BINDING_HANDLE  Handle );

RPCRTAPI
void
RPC_ENTRY
NdrGetPartialBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg );

void
NdrpRaisePipeException(
    NDR_PIPE_DESC  *    pPipeDesc,
    RPC_STATUS          Exception );

#endif // PIPENDR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\pickle.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    pickle.cxx

Abstract:

    This module contains pickling related ndr library routines.

Notes:

Author:

    Ryszard K. Kott (ryszardk)  Oct 10, 1993

Revision History:

    ryszardk    Mar 17, 1994    Reworked for midl20


------------------------------------------------------------------------*/

#include <ndrp.h>
#include <rpcdcep.h>
#include "ndrtypes.h"
#include <midles.h>
#include <stdarg.h>
#include <malloc.h>
#include "interp2.h"
#include "mulsyntx.h"

#include "picklep.hxx"
#include "util.hxx" // PerformRpcInitialization

extern const MIDL_FORMAT_STRING __MIDLFormatString;

// DCE puts endianness on the low nibble in the pickling header.

#define NDR_LOCAL_ENDIAN_LOW    (NDR_LOCAL_ENDIAN >> 4)

RPC_STATUS
NdrpPerformRpcInitialization (
    void
    )
{
    return PerformRpcInitialization();
}




// =======================================================================
//    Handle validation
// =======================================================================

void
NdrpValidateMesHandle(
    PMIDL_ES_MESSAGE_EX  pMesMsgEx )
{
    RpcTryExcept
        {
        if ( pMesMsgEx == 0  ||  pMesMsgEx->Signature != MIDL_ES_SIGNATURE  ||
             pMesMsgEx->MesMsg.MesVersion != MIDL_ES_VERSION )
            RpcRaiseException( RPC_S_INVALID_ARG );
        }
    RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
        {
        RpcRaiseException( RPC_S_INVALID_ARG );
        }
    RpcEndExcept
}

RPC_STATUS
NdrpValidateMesHandleReturnStatus(
    PMIDL_ES_MESSAGE_EX  pMesMsgEx )
{
    RPC_STATUS  Status = RPC_S_OK;

    RpcTryExcept
        {
        if ( pMesMsgEx == 0  ||  pMesMsgEx->Signature != MIDL_ES_SIGNATURE  ||
             ( pMesMsgEx->MesMsg.MesVersion != MIDL_ES_VERSION &&
               pMesMsgEx->MesMsg.MesVersion != MIDL_NDR64_ES_VERSION ) )
            Status = RPC_S_INVALID_ARG;
        }
    RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
        {
        Status = RPC_S_INVALID_ARG;
        }
    RpcEndExcept

    return Status;
}



// =======================================================================
//    Handle allocation and freeing.
// =======================================================================

RPC_STATUS
NdrpHandleAllocate(
    handle_t *    pHandle )
/*++
    The reason for having this function here is that
    handle_t is a near pointer on win16 (but not on Dos),
    and we still compile the whole rpcndr20 large for that platform.
    So we need near malloc to be within the default segment.
--*/
{
    RPC_STATUS RpcStatus;

    if ( pHandle == NULL )
        return( RPC_S_INVALID_ARG );

    // Rpc mtrt heap allocation initialization (any platform).
    // This is a macro that returns from NdrpHandleAllocate with
    // out of memory error when it fails.
    // It's under an if only to facilitate testing.


    RpcStatus = NdrpPerformRpcInitialization();
    if ( RpcStatus != RPC_S_OK )
        return(RpcStatus);

    // Now allocate.
    // Mes handle includes stubmsg but we need to add rpcmsg to it.

    *pHandle = new char[ sizeof(MIDL_ES_MESSAGE_EX) ];

    if ( *pHandle == NULL )
        return( RPC_S_OUT_OF_MEMORY );
    return( RPC_S_OK );
}

RPC_STATUS  RPC_ENTRY
MesHandleFree( handle_t  Handle )
/*++
    This routine frees a pickling handle.
--*/
{
    if ( Handle)
        {
        delete Handle;
        }
    return( RPC_S_OK );
}

void RPC_ENTRY
I_NdrMesMessageInit(
    PMIDL_ES_MESSAGE_EX pMesMsgEx )
{
    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsgEx->MesMsg.StubMsg;
    PRPC_MESSAGE        pRpcMsg  = & pMesMsgEx->RpcMsg;

    MIDL_memset( pStubMsg, 0, sizeof(MIDL_STUB_MESSAGE) );
    MIDL_memset( pRpcMsg, 0, sizeof(RPC_MESSAGE) );

    pRpcMsg->DataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;

    pStubMsg->RpcMsg   = pRpcMsg;
    pStubMsg->IsClient = 1;

    NdrSetupLowStackMark( pStubMsg );
}


// =======================================================================

RPC_STATUS RPC_ENTRY
MesEncodeIncrementalHandleCreate(
    void     *    UserState,
    MIDL_ES_ALLOC           Alloc,
    MIDL_ES_WRITE           Write,
    handle_t *    pHandle )
/*++
    This routine creates an encoding incremental pickling handle.
--*/
{
    RPC_STATUS Status;

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_INCREMENTAL_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesIncrementalHandleReset( *pHandle,
                                                  UserState,
                                                  Alloc,
                                                  Write,
                                                  0,
                                                  MES_ENCODE )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}

RPC_STATUS RPC_ENTRY
MesDecodeIncrementalHandleCreate(
    void     *      UserState,
    MIDL_ES_READ    Read,
    handle_t *      pHandle )
/*++
    This routine creates a descoding incrementsl pickling handle.
--*/
{
    RPC_STATUS Status;

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_INCREMENTAL_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesIncrementalHandleReset( *pHandle,
                                                  UserState,
                                                  0,
                                                  0,
                                                  Read,
                                                  MES_DECODE )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}


RPC_STATUS  RPC_ENTRY
MesIncrementalHandleReset(
    handle_t           Handle,
    void *             UserState,
    MIDL_ES_ALLOC      Alloc,
    MIDL_ES_WRITE      Write,
    MIDL_ES_READ       Read,
    MIDL_ES_CODE       Operation )
/*++
    This routine initializes a pickling handle with supplied arguments.
--*/
{
    RPC_STATUS  Status;

    Status = NdrpValidateMesHandleReturnStatus( (PMIDL_ES_MESSAGE_EX)Handle );
    if ( Status != RPC_S_OK )
        return Status;

    PMIDL_ES_MESSAGE  pMesMsg = (PMIDL_ES_MESSAGE) Handle;

    // we support ndr64 pickling now.
    if ( Handle == NULL  ||
         pMesMsg->HandleStyle != MES_INCREMENTAL_HANDLE  ||
         ( Operation != MES_ENCODE  &&  
           Operation != MES_DECODE  &&
           Operation != MES_ENCODE_NDR64 &&
           Operation != MES_DECODE_NDR64 ) )
        return( RPC_S_INVALID_ARG );

    I_NdrMesMessageInit( (PMIDL_ES_MESSAGE_EX) Handle );

    pMesMsg->Operation  = Operation;
    pMesMsg->HandleFlags = 0;
    pMesMsg->ByteCount = 0;
    if ( Operation == MES_ENCODE_NDR64 ||
         Operation == MES_DECODE_NDR64 )
        {
        pMesMsg->MesVersion  = MIDL_NDR64_ES_VERSION;
        }
    else
        {
        pMesMsg->MesVersion  = MIDL_ES_VERSION;
        }

    if ( UserState )
        pMesMsg->UserState = UserState;
    if ( Alloc )
        pMesMsg->Alloc = Alloc;
    if ( Write )
        pMesMsg->Write = Write;
    if ( Read )
        pMesMsg->Read  = Read;

    if ( ( (Operation == MES_ENCODE || Operation == MES_ENCODE_NDR64 ) &&
             (pMesMsg->Alloc == NULL  ||  pMesMsg->Write == NULL) ) ||
         ( (Operation == MES_DECODE  || Operation == MES_DECODE_NDR64 ) && 
            (pMesMsg->Read == NULL))  )
        return( RPC_S_INVALID_ARG );

    return( RPC_S_OK );
}


RPC_STATUS  RPC_ENTRY
MesEncodeFixedBufferHandleCreate(
    char *            Buffer,
    unsigned long     BufferSize,
    unsigned long *   pEncodedSize,
    handle_t  *       pHandle )
{
    RPC_STATUS Status;

    if( (LONG_PTR)Buffer & 0x7 )
        return( RPC_X_INVALID_BUFFER );

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_FIXED_BUFFER_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesBufferHandleReset( *pHandle,
                                             MES_FIXED_BUFFER_HANDLE,
                                             MES_ENCODE,
                                             & Buffer,
                                             BufferSize,
                                             pEncodedSize )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}

RPC_STATUS  RPC_ENTRY
MesEncodeDynBufferHandleCreate(
    char             ** pBuffer,
    unsigned long    *  pEncodedSize,
    handle_t         *  pHandle )
{
    RPC_STATUS Status;

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_DYNAMIC_BUFFER_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesBufferHandleReset( *pHandle,
                                             MES_DYNAMIC_BUFFER_HANDLE,
                                             MES_ENCODE,
                                             pBuffer,
                                             0,
                                             pEncodedSize )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}

RPC_STATUS  RPC_ENTRY
MesDecodeBufferHandleCreate(
    char *          Buffer,
    unsigned long   BufferSize,
    handle_t  *     pHandle )
{
    if ( Buffer == NULL  ||
         BufferSize < MES_CTYPE_HEADER_SIZE + 8 )
        return( RPC_S_INVALID_ARG );

    if( (LONG_PTR)Buffer & 0x7 )
        return( RPC_X_INVALID_BUFFER );

    RPC_STATUS Status;

    if ( (Status = NdrpHandleAllocate( pHandle )) == RPC_S_OK )
        {
        ((PMIDL_ES_MESSAGE) *pHandle)->HandleStyle = MES_FIXED_BUFFER_HANDLE;
        ((PMIDL_ES_MESSAGE) *pHandle)->MesVersion  = MIDL_ES_VERSION;
        ((PMIDL_ES_MESSAGE_EX)*pHandle)->Signature = MIDL_ES_SIGNATURE;

        if ( (Status = MesBufferHandleReset( *pHandle,
                                             MES_FIXED_BUFFER_HANDLE,
                                             MES_DECODE,
                                             & Buffer,
                                             BufferSize,
                                             0            )) != RPC_S_OK )
            {
            MesHandleFree( *pHandle );
            *pHandle = NULL;
            }
        }

    return( Status );
}


// reset a pickling handle. 
RPC_STATUS  RPC_ENTRY
MesBufferHandleReset(
    handle_t            Handle,
    unsigned long       HandleStyle,
    MIDL_ES_CODE        Operation,
    char * *            pBuffer,
    unsigned long       BufferSize,
    unsigned long *     pEncodedSize )
{
    RPC_STATUS  Status;

    Status = NdrpValidateMesHandleReturnStatus( (PMIDL_ES_MESSAGE_EX)Handle );
    if ( Status != RPC_S_OK )
        return Status;

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;

    if ( Handle == NULL ||  pBuffer == NULL  ||
        ( HandleStyle != MES_FIXED_BUFFER_HANDLE  &&
            HandleStyle != MES_DYNAMIC_BUFFER_HANDLE )  ||
        (HandleStyle == MES_FIXED_BUFFER_HANDLE  &&
            (*pBuffer == NULL  ||  BufferSize < MES_MINIMAL_BUFFER_SIZE)) ||
        (Operation == MES_ENCODE  &&  pEncodedSize == NULL)  ||
        (Operation == MES_DECODE  &&
            (*pBuffer == NULL  ||  BufferSize < MES_MINIMAL_BUFFER_SIZE))
       )
        return( RPC_S_INVALID_ARG );

    if ( (Operation == MES_ENCODE_NDR64  &&  pEncodedSize == NULL)  ||
        (Operation == MES_DECODE_NDR64  &&
            (*pBuffer == NULL  ||  BufferSize < MES_MINIMAL_NDR64_BUFFER_SIZE ) ) )
        return( RPC_S_INVALID_ARG );

    I_NdrMesMessageInit( (PMIDL_ES_MESSAGE_EX) Handle );

    pMesMsg->Operation  = Operation;
    pMesMsg->HandleFlags = 0;
    pMesMsg->HandleStyle = HandleStyle;
    pMesMsg->ByteCount = 0;
    if ( Operation == MES_ENCODE_NDR64 ||
         Operation == MES_DECODE_NDR64 )
        {
        pMesMsg->MesVersion  = MIDL_NDR64_ES_VERSION;
        }
    else
        {
        pMesMsg->MesVersion  = MIDL_ES_VERSION;
        }


    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsg->StubMsg;
    PRPC_MESSAGE        pRpcMsg  =   pMesMsg->StubMsg.RpcMsg;

    if ( HandleStyle == MES_FIXED_BUFFER_HANDLE)
        {
        pMesMsg->Buffer         = (uchar *)*pBuffer;

        pRpcMsg->BufferLength = BufferSize;
        pRpcMsg->Buffer       = *pBuffer;

        pStubMsg->Buffer      = (uchar *)*pBuffer;
        pStubMsg->BufferStart = (uchar *)*pBuffer;
        pStubMsg->BufferEnd   = (uchar *)*pBuffer + BufferSize;
        }
    if ( HandleStyle == MES_DYNAMIC_BUFFER_HANDLE)
        {
        pMesMsg->pDynBuffer = (uchar **)pBuffer;
        if (Operation == MES_DECODE || Operation == MES_DECODE_NDR64 )
            {
            pMesMsg->Buffer       = (uchar *)*pBuffer;

            pRpcMsg->BufferLength = BufferSize;
            pRpcMsg->Buffer       = *pBuffer;

            pStubMsg->Buffer      = (uchar *)*pBuffer;
            pStubMsg->BufferStart = (uchar *)*pBuffer;
            pStubMsg->BufferEnd   = (uchar *)*pBuffer + BufferSize;
            }
        else
            {
            *pBuffer = NULL;

            pRpcMsg->BufferLength = 0;
            pRpcMsg->Buffer       = 0;

            pStubMsg->Buffer      = 0;
            pStubMsg->BufferStart = 0;
            pStubMsg->BufferEnd   = 0;
            }
        }
    pMesMsg->BufferSize = BufferSize;
    pMesMsg->pEncodedSize = pEncodedSize;

    return( RPC_S_OK );
}


RPC_STATUS  RPC_ENTRY
MesInqProcEncodingId(
    handle_t                Handle,
    PRPC_SYNTAX_IDENTIFIER  pInterfaceId,
    unsigned long *         pProcNumber )
/*++

    The routine returns an informantion about the last proc encoding.
    Called before an encode, it should return RPC_X_INVALID_ES_ACTION.
    Called after an encode, it should return the last encoding info.
    Called before a decode, it should return the same encoding info.
    Called after a decode, it should return the just decoded encode info.

--*/
{
    RPC_STATUS  Status;

    Status = NdrpValidateMesHandleReturnStatus( (PMIDL_ES_MESSAGE_EX)Handle );
    if ( Status != RPC_S_OK )
        return Status;

    PMIDL_ES_MESSAGE  pMesMsg = (PMIDL_ES_MESSAGE) Handle;

    Status  = RPC_X_INVALID_ES_ACTION;

    if ( Handle == NULL  ||  pInterfaceId == NULL  ||  pProcNumber == NULL )
        return( RPC_S_INVALID_ARG );

    RpcTryExcept
        {
        // Note: because we allow to pickle several procs into the same buffer
        // (using the same handle without resetting), the PEEKED bit may be
        // cleared and the info may still be available.
        // On the other hand, the info bit is always set if we unmarshaled
        // a header. So check the info bit first.

        if ( pMesMsg->Operation == MES_DECODE  &&
             ! GET_MES_INFO_AVAILABLE( pMesMsg ) &&
             ! GET_MES_HEADER_PEEKED( pMesMsg ) )
            {
            NdrpProcHeaderUnmarshallAll( pMesMsg );
            SET_MES_HEADER_PEEKED( pMesMsg );
            }
            
        if ( GET_MES_INFO_AVAILABLE( pMesMsg ) )
            {
            RpcpMemoryCopy( pInterfaceId,
                            & pMesMsg->InterfaceId,
                            sizeof( RPC_SYNTAX_IDENTIFIER ) );
            *pProcNumber = pMesMsg->ProcNumber;
            Status =  RPC_S_OK;
            }
        // else Status = RPC_X_INVALID_ES_ACTION;
        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER)  )
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept

    return( Status );
}


// =======================================================================
//
//   Private Alloc, Read, Write helper routines
//
// =======================================================================

void
NdrpAllocPicklingBuffer(
    PMIDL_ES_MESSAGE    pMesMsg,
    unsigned int        RequiredLen
    )
{
    unsigned int ActualLen;

    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    // Get the marshalling buffer.

    // alert: assuming the return buffer is aligned at 16 in 64bit platform. 
    // ndr64 buffer needs to be aligned at 16.
    switch ( pMesMsg->HandleStyle )
        {
        case MES_INCREMENTAL_HANDLE:
            // Allocating the pickling buffer.

            ActualLen = RequiredLen;
            (pMesMsg->Alloc)( pMesMsg->UserState,
                              (char * *) & pStubMsg->Buffer,
                              & ActualLen );
            if ( ActualLen < RequiredLen )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );

            pStubMsg->RpcMsg->BufferLength = ActualLen;
            pStubMsg->RpcMsg->Buffer       = pStubMsg->Buffer;

            pStubMsg->BufferStart = pStubMsg->Buffer;
            pStubMsg->BufferEnd   = pStubMsg->Buffer + ActualLen;
            break;

        case MES_FIXED_BUFFER_HANDLE:
            break;

        case MES_DYNAMIC_BUFFER_HANDLE:
            {
            // We have to return one buffer for multiple encodings,
            // and a cumulative size along with it.
            // So, we check if we have to copy data to a new buffer.

            uchar * pOldBufferToCopy = NULL;

            if ( pMesMsg->ByteCount )
                {
                RequiredLen += pMesMsg->ByteCount;
                pOldBufferToCopy = *pMesMsg->pDynBuffer;
                }

            pStubMsg->Buffer = (uchar *) pStubMsg->pfnAllocate( RequiredLen );
            if ( pStubMsg->Buffer == NULL )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );

            if ( pOldBufferToCopy )
                {
                RpcpMemoryCopy( pStubMsg->Buffer,
                                pOldBufferToCopy,
                                pMesMsg->ByteCount );

                pStubMsg->pfnFree( pOldBufferToCopy );
                }

            pStubMsg->RpcMsg->BufferLength = RequiredLen;
            pStubMsg->RpcMsg->Buffer       = pStubMsg->Buffer;

            pStubMsg->BufferStart = pStubMsg->Buffer;
            pStubMsg->BufferEnd   = pStubMsg->Buffer + RequiredLen;

            * pMesMsg->pDynBuffer = pStubMsg->Buffer;
            pMesMsg->BufferSize = RequiredLen;

            // We write after the previously written buffer.

            pStubMsg->Buffer += pMesMsg->ByteCount;
            break;
            }
        }

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );
}

void
NdrpReadPicklingBuffer(
    PMIDL_ES_MESSAGE    pMesMsg,
    unsigned int        RequiredLen
    )
{
    unsigned int ActualLen;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    // Read the marshalling buffer.

    if ( pMesMsg->HandleStyle  == MES_INCREMENTAL_HANDLE )
        {
            // Allocating the pickling buffer.

            ActualLen = RequiredLen;
            (pMesMsg->Read)( pMesMsg->UserState,
                             (char **) & pStubMsg->Buffer,
                             & ActualLen );
            if ( ActualLen < RequiredLen )
                RpcRaiseException( RPC_S_OUT_OF_MEMORY );

            pStubMsg->RpcMsg->BufferLength = ActualLen;
            pStubMsg->RpcMsg->Buffer       = pStubMsg->Buffer;

            pStubMsg->BufferStart = pStubMsg->Buffer;
            pStubMsg->BufferEnd   = pStubMsg->Buffer + ActualLen;
        }

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );
}

void
NdrpWritePicklingBuffer(
    PMIDL_ES_MESSAGE    pMesMsg,
    uchar *             pBuffer,
    size_t              WriteLength
    )
{
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    NDR_ASSERT( ! ((LONG_PTR)pStubMsg->Buffer & 0x7), "Misaligned buffer" );
    NDR_ASSERT( ! (WriteLength & 0x7 ), "Length should be multiple of 8" );

    // Write the marshalling buffer.

    if ( pMesMsg->HandleStyle == MES_INCREMENTAL_HANDLE )
        {
        (pMesMsg->Write)( pMesMsg->UserState,
                          (char * ) pBuffer,
                          WriteLength );
        }
    else
        {
        // We return the cumulative length both for the fixed buffer
        // and for the dynamic buffer style.

        pMesMsg->ByteCount += WriteLength;
        * pMesMsg->pEncodedSize = pMesMsg->ByteCount;
        }
}



// =======================================================================
//
//   One call generic routine pickling.
//
// =======================================================================


void
NdrpProcHeaderMarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    // Marshall DCE pickle header.

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    * pStubMsg->Buffer++ = MIDL_ES_VERSION;
    * pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN_LOW;
    *( PSHORT_LV_CAST pStubMsg->Buffer)++ = (short)0xcccc;    // filler

    // Marshall transfer syntax from the stub.

    RpcpMemoryCopy( pStubMsg->Buffer,
                    & ((PRPC_CLIENT_INTERFACE)(pStubMsg->
                          StubDesc->RpcInterfaceInformation))->TransferSyntax,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

    // We need to remember InterfaceId for inquiries.

    RpcpMemoryCopy( & pMesMsg->InterfaceId,
                    & ((PRPC_CLIENT_INTERFACE)(pStubMsg->
                         StubDesc->RpcInterfaceInformation))->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

   // Marshall InterfaceId and ProcNumber from the handle.

    RpcpMemoryCopy( pStubMsg->Buffer + sizeof(RPC_SYNTAX_IDENTIFIER),
                    & pMesMsg->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long) );

    SET_MES_INFO_AVAILABLE( pMesMsg );

    pStubMsg->Buffer += 2 * sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long);

    * pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN_LOW;
    * pStubMsg->Buffer++ = NDR_ASCII_CHAR;
    * pStubMsg->Buffer++ = (char) (NDR_IEEE_FLOAT >> 8);
    * pStubMsg->Buffer++ = 0;   // filler

    // This is non-DCE element as they have just 4 more bytes of filler here.
    // This field is used only when unmarshalling in our incremental style.

    *( PLONG_LV_CAST pStubMsg->Buffer)++ = pStubMsg->BufferLength -
                                                   MES_PROC_HEADER_SIZE;
}

void
NdrpProcHeaderUnmarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    unsigned char *         BufferToRestore;
    PMIDL_STUB_MESSAGE      pStubMsg = &pMesMsg->StubMsg;

    if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
        return;

    NdrpReadPicklingBuffer( pMesMsg, MES_PROC_HEADER_SIZE );

    // Unmarshalling the header

    if ( *pStubMsg->Buffer != MIDL_ES_VERSION )
        RpcRaiseException( RPC_X_WRONG_ES_VERSION );

    BufferToRestore = pStubMsg->Buffer + 4;

    if ( pStubMsg->Buffer[1] != NDR_LOCAL_ENDIAN_LOW )
        {
        // The DCE header has the endianness on the low nibble, while
        // our DataRep has it on the high nibble.
        // We need only endianess to convert the proc header.

        byte Endianness = (pStubMsg->Buffer[1] << 4 );

        pStubMsg->RpcMsg->DataRepresentation = Endianness;

        pStubMsg->Buffer += 4;
        NdrSimpleStructConvert( pStubMsg,
                                &__MIDLFormatString.Format[32],
                                FALSE );
        }

    pStubMsg->Buffer = BufferToRestore;

    // Verify the transfer syntax

    if ( NULL != pStubMsg->StubDesc )
        {
        if (0 != RpcpMemoryCompare( 
                        pStubMsg->Buffer,
                        & ((PRPC_CLIENT_INTERFACE)(pStubMsg->
                            StubDesc->RpcInterfaceInformation))->
TransferSyntax,
                        sizeof(RPC_SYNTAX_IDENTIFIER) ) )
            {
            RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );
            } 
        }

    RpcpMemoryCopy( &((PMIDL_ES_MESSAGE_EX)pMesMsg)->TransferSyntax, 
                      pStubMsg->Buffer,
                      sizeof( RPC_SYNTAX_IDENTIFIER ) );

    pStubMsg->Buffer += sizeof(RPC_SYNTAX_IDENTIFIER);

    // We need to remember the last InterfaceId and ProcNumber for inquiries.

    RpcpMemoryCopy( & pMesMsg->InterfaceId,
                    pStubMsg->Buffer,
                    sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long) );

    pStubMsg->Buffer += sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long);

    SET_MES_INFO_AVAILABLE( pMesMsg );

    unsigned long AlienDataRepresentation =
                        ( (pStubMsg->Buffer[0] << 4)  |           // endianness
                          pStubMsg->Buffer[1]  |                       // chars
                        ((unsigned long)(pStubMsg->Buffer[2]) << 8) ); // float
    pMesMsg->AlienDataRep = AlienDataRepresentation;
    pMesMsg->IncrDataSize = (size_t) *(unsigned long *)
                                                (pStubMsg->Buffer + 4);
    pStubMsg->Buffer += 8;
}

void
NdrpDataBufferInit(
    PMIDL_ES_MESSAGE    pMesMsg,
    PFORMAT_STRING      pProcFormat
    )
{
    size_t              RequiredLen;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        pStubMsg->RpcMsg->DataRepresentation = pMesMsg->AlienDataRep;
        NdrConvert( pStubMsg, pProcFormat );
        }

    // When incremental, this is the non-DCE buffer size.
    // For non incremental RequiredLen will be ignored.

    RequiredLen = pMesMsg->IncrDataSize;

    NdrpReadPicklingBuffer( pMesMsg, RequiredLen );

    pStubMsg->pfnAllocate = pStubMsg->StubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubMsg->StubDesc->pfnFree;
}


void  RPC_VAR_ENTRY
NdrMesProcEncodeDecode(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    ...
    )
/*++

Routine description:

    Sizes and marshalls [in] arguments, unmarshalls [out] arguments.
    Includes a routine header.

Arguments:

    Handle      - a pickling handle
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type.

Note:

    Please note that all the ... arguments here are pointers.
    We will handle them appropriately to access the original arguments.

    The pickling header for the routine is included in the sizing.

--*/
{
    BOOL                fMoreParams;
    PFORMAT_STRING      pProcFormat;
    void            *   pArg;
    va_list             ArgList;
    unsigned char   *   BufferSaved;
    size_t              WriteLength;

    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg  = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsg->StubMsg;

    NDR_ASSERT( *pFormat == FC_BIND_PRIMITIVE  ||  *pFormat == 0,
                "Pickling handle expected" );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    BOOL fEncodeUsed = (pFormat[1] & ENCODE_IS_USED)  &&
                       pMesMsg->Operation == MES_ENCODE;
    BOOL fDecodeUsed = (pFormat[1] & DECODE_IS_USED)  &&
                       pMesMsg->Operation == MES_DECODE;

    NDR_ASSERT( !( fEncodeUsed && fDecodeUsed ),
                "Both encode & decode at the same time" );

    if ( !fEncodeUsed && !fDecodeUsed )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    pStubMsg->FullPtrXlatTables = ( (pFormat[1]  &  Oi_FULL_PTR_USED)
                                    ?  NdrFullPointerXlatInit( 0, XLAT_CLIENT )
                                    :  0 );

    pFormat += HAS_RPCFLAGS(pFormat[1]) ? 6
                                        : 2;

    // We use the proc number only to support MesInqEncodingId. So, set it for
    // encoding only. When decoding it will get picked up from the header.
    //
    if ( fEncodeUsed )
        pMesMsg->ProcNumber = * (unsigned short *) pFormat;

    pFormat +=4;

    if ( *pFormat == FC_BIND_PRIMITIVE )
        pFormat += 4;

    if ( fEncodeUsed )
        {
        //
        // The sizing walk.
        //

        pStubMsg->BufferLength = MES_PROC_HEADER_SIZE;

        // We will be walking this routine's stack.
        // However, for the engine to be able to calculate conformant arrays
        // and such, top of the original routine's stack has to be available
        // via the stub message.

        INIT_ARG( ArgList, pFormat );
        GET_FIRST_ARG( pArg, ArgList );

        pStubMsg->StackTop = *(uchar * *)pArg;
        pProcFormat = pFormat;
        fMoreParams = TRUE;

        for ( ; fMoreParams ; pProcFormat += 2 )
            {
            switch ( *pProcFormat )
                {
                case FC_OUT_PARAM:
                    break;

                case FC_RETURN_PARAM:
                    fMoreParams = FALSE;
                    break;
                default:
                    fMoreParams = FALSE;
                    break;

                case FC_IN_PARAM_BASETYPE :

                    LENGTH_ALIGN( pStubMsg->BufferLength,
                                SIMPLE_TYPE_ALIGNMENT( pProcFormat[1] ));
                    pStubMsg->BufferLength +=
                                SIMPLE_TYPE_BUFSIZE( pProcFormat[1] );
                    break;

                case FC_IN_PARAM:
                case FC_IN_PARAM_NO_FREE_INST:

                    // Other [in] types than simple or ignore
                    // fall through to [in,out].

                case FC_IN_OUT_PARAM:
                    {
                    uchar *         pOrigArg = *(uchar * *)pArg;
                    PFORMAT_STRING  pTypeFormat;
                    unsigned char   FcType;


                    pProcFormat += 2;
                    pTypeFormat = pStubDesc->pFormatTypes +
                                                *(signed short *) pProcFormat;
                    FcType = *pTypeFormat;

                    if ( ! IS_BY_VALUE( FcType ) )
                        pOrigArg = *(uchar * *)pOrigArg;

                    (*pfnSizeRoutines[ ROUTINE_INDEX( FcType ) ])( pStubMsg,
                                                                   pOrigArg,
                                                                   pTypeFormat );
                    }
                    break;
                }

            GET_NEXT_ARG( pArg, ArgList );
            }   // for

        LENGTH_ALIGN( pStubMsg->BufferLength, 7 );

        size_t  LengthSaved;

        NdrpAllocPicklingBuffer( pMesMsg, pStubMsg->BufferLength );
        BufferSaved = pStubMsg->Buffer;
        LengthSaved = pStubMsg->BufferLength;

        //
        // Marshalling.
        //

        NdrpProcHeaderMarshall( pMesMsg );

        INIT_ARG( ArgList, pFormat );
        GET_FIRST_ARG( pArg, ArgList );

        pProcFormat = pFormat;
        fMoreParams = TRUE;

        for ( ; fMoreParams ; pProcFormat += 2 )
            {
            switch ( *pProcFormat )
                {
                case FC_OUT_PARAM:
                    break;

                case FC_RETURN_PARAM:
                default:
                    fMoreParams = FALSE;
                    break;

                case FC_IN_PARAM_BASETYPE :

                    NdrSimpleTypeMarshall( pStubMsg,
                                           *(uchar * *)pArg,
                                           pProcFormat[1] );
                    break;

                case FC_IN_PARAM:
                case FC_IN_PARAM_NO_FREE_INST:
                case FC_IN_OUT_PARAM:
                    {
                    uchar *         pOrigArg = *(uchar * *)pArg;
                    PFORMAT_STRING  pTypeFormat;
                    unsigned char   FcType;

                    pProcFormat += 2;
                    pTypeFormat = pStubDesc->pFormatTypes +
                                                *(signed short *) pProcFormat;
                    FcType = *pTypeFormat;

                    if ( ! IS_BY_VALUE( FcType ) )
                        pOrigArg = *(uchar * *)pOrigArg;

                    (*pfnMarshallRoutines[ ROUTINE_INDEX( FcType )])( pStubMsg,
                                                                      pOrigArg,
                                                                      pTypeFormat );
                    }
                    break;
                }

            GET_NEXT_ARG( pArg, ArgList );
            }

        // Next encoding (if any) starts at aligned to 8.

        ALIGN( pStubMsg->Buffer, 7 );

        // Now manage the actual size of encoded data.

        WriteLength = (size_t)(pStubMsg->Buffer - BufferSaved);
        * (unsigned long *)
                ( BufferSaved + MES_PROC_HEADER_SIZE - 4) =
                                    WriteLength - MES_PROC_HEADER_SIZE;

        if ( LengthSaved < WriteLength )
            {
            NDR_ASSERT( 0, "NdrMesProcEncodeDecode: encode buffer overflow" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            }

        NdrpWritePicklingBuffer( pMesMsg, BufferSaved, WriteLength );
        }

    if ( fDecodeUsed )
        {
        //
        // Unmarshalling.
        //

        if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
            {
            // This makes it possible to encode/decode several procs one after
            // another with the same pickling handle (using the same buffer).

            CLEAR_MES_HEADER_PEEKED( pMesMsg );
            }
        else
            NdrpProcHeaderUnmarshall( pMesMsg );

        NdrpDataBufferInit( pMesMsg, pFormat );

        INIT_ARG( ArgList, pFormat );
        GET_FIRST_ARG( pArg, ArgList );

        pStubMsg->StackTop = *(uchar * *)pArg;
        pProcFormat = pFormat;
        fMoreParams = TRUE;

        for ( ; fMoreParams ; pProcFormat += 2 )
            {
            switch ( *pProcFormat )
                {
                case FC_IN_PARAM_BASETYPE :
                case FC_IN_PARAM:
                case FC_IN_PARAM_NO_FREE_INST:
                    break;

                default:
                    fMoreParams = FALSE;
                    break;

                case FC_RETURN_PARAM_BASETYPE :

                    NdrSimpleTypeUnmarshall( pStubMsg,
                                             *(uchar * *)pArg,
                                             pProcFormat[1] );
                    fMoreParams = FALSE;
                    break;

                case FC_RETURN_PARAM:
                    fMoreParams = FALSE;

                    // fall through to out params.

                case FC_IN_OUT_PARAM:
                case FC_OUT_PARAM:
                    {
                    uchar *         pOrigArg = *(uchar * *)pArg;
                    PFORMAT_STRING  pTypeFormat;
                    unsigned char   FcType;

                    pProcFormat += 2;
                    pTypeFormat = pStubDesc->pFormatTypes +
                                                *(signed short *) pProcFormat;
                    FcType = *pTypeFormat;

                    if ( IS_STRUCT( FcType )  ||  IS_UNION( FcType)  ||
                         IS_XMIT_AS( FcType ) )
                        {
                        // All these are possible only as a return value.
                        pOrigArg = (uchar *) &pOrigArg;
                        }
                    else
                        pOrigArg = (uchar *)pOrigArg;

                    (*pfnUnmarshallRoutines[ ROUTINE_INDEX( FcType )])(
                        pStubMsg,
                        (uchar * *)pOrigArg,
                        pTypeFormat,
                        FALSE );
                    }
                    break;
                }

            GET_NEXT_ARG( pArg, ArgList );
            }   // for

            // Next decoding (if any) starts at aligned to 8.

            ALIGN( pStubMsg->Buffer, 7 );

        }   // if decode

    NdrFullPointerXlatFree( pStubMsg->FullPtrXlatTables );
}


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrMesProcEncodeDecode2(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDescriptor,
    PFORMAT_STRING          pFormat,
    ...
    )
{
    va_list                     ArgList;
    uchar *                     StartofStack;
    PFORMAT_STRING              pFormatParam;
    CLIENT_CALL_RETURN          ReturnValue;
    ulong                       ProcNum;
    uchar *                     pArg;
    void *                      pThis;
    PFORMAT_STRING              pProcFormat = pFormat;
    unsigned char *             BufferSaved;
    size_t                      WriteLength;
    NDR_PROC_CONTEXT            ProcContext;
    PNDR_PROC_HEADER_EXTS       pHeaderExts = 0;

    ReturnValue.Pointer = 0;

    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    //
    INIT_ARG( ArgList, pFormat);

    //
    // Get the address of the stack where the parameters are.
    //
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *) GET_STACK_START(ArgList);

    // StartofStack points to the virtual stack at this point.

    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg  = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsg->StubMsg;

    NDR_ASSERT( *pFormat == FC_BIND_PRIMITIVE  ||  *pFormat == 0,
                "Pickling handle expected" );

    pStubMsg->StubDesc = pStubDescriptor;
    pStubMsg->pfnAllocate = pStubDescriptor->pfnAllocate;
    pStubMsg->pfnFree     = pStubDescriptor->pfnFree;

    ProcNum = MulNdrpInitializeContextFromProc( XFER_SYNTAX_DCE, pFormat, &ProcContext, StartofStack );

    BOOL fEncodeUsed = ( * ( ( uchar *)&ProcContext.NdrInfo.InterpreterFlags ) & ENCODE_IS_USED )  &&
                       pMesMsg->Operation == MES_ENCODE;
    BOOL fDecodeUsed = ( * ( ( uchar *)&ProcContext.NdrInfo.InterpreterFlags ) & DECODE_IS_USED )  &&
                       pMesMsg->Operation == MES_DECODE;

    NDR_ASSERT( !( fEncodeUsed && fDecodeUsed ),
                "Both encode & decode at the same time" );

    if ( !fEncodeUsed && !fDecodeUsed )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( fEncodeUsed )
    pMesMsg->ProcNumber = ProcNum;


   // Must do this before the sizing pass!
   pStubMsg->StackTop = StartofStack;
   pStubMsg->pContext = &ProcContext;

   RpcTryFinally
        {

        // We don't really need to zeroout here, but code is much more cleaner this way, 
        // and ObjectProc is the first check anyhow.
        NdrpClientInit( pStubMsg, &ReturnValue );
        if (fEncodeUsed)
            {

            //
            // ----------------------------------------------------------------
            // Sizing Pass.
            // ----------------------------------------------------------------
            //

            pStubMsg->BufferLength += MES_PROC_HEADER_SIZE;

            //
            // Skip buffer size pass if possible.
            //
            if ( ProcContext.NdrInfo.pProcDesc->Oi2Flags.ClientMustSize )
                {
                NdrpSizing( pStubMsg, 
                            TRUE );     // IsClient
                }

            LENGTH_ALIGN( pStubMsg->BufferLength, 7 );

            size_t  LengthSaved;

            NdrpAllocPicklingBuffer( pMesMsg, pStubMsg->BufferLength );
            BufferSaved = pStubMsg->Buffer;
            LengthSaved = pStubMsg->BufferLength;

            NdrpProcHeaderMarshall( pMesMsg );

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            NdrpClientMarshal( pStubMsg,
                               FALSE ); // IsObject
                           

            // Next encoding (if any) starts at aligned to 8.

            ALIGN( pStubMsg->Buffer, 7 );

            // Now manage the actual size of encoded data.

            WriteLength = (size_t)(pStubMsg->Buffer - BufferSaved);
            * (unsigned long *) ( BufferSaved + MES_PROC_HEADER_SIZE - 4) =
                                    WriteLength - MES_PROC_HEADER_SIZE;

            if ( LengthSaved < WriteLength )
                {
                NDR_ASSERT( 0, "NdrMesProcEncodeDecode: encode buffer overflow" );
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                }

            NdrpWritePicklingBuffer( pMesMsg, BufferSaved, WriteLength );
            }


        if (fDecodeUsed)
            {
            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //

            if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
                {
                // This makes it possible to encode/decode several procs one after
                // another with the same pickling handle (using the same buffer).
    
                CLEAR_MES_HEADER_PEEKED( pMesMsg );
                }
            else    
                NdrpProcHeaderUnmarshall( pMesMsg );
       
            NdrpDataBufferInit( pMesMsg, pFormat );

            NdrpClientUnMarshal( pStubMsg,
                             &ReturnValue );

            // Next decoding (if any) starts at aligned to 8.

            ALIGN( pStubMsg->Buffer, 7 );

            } // if decode

        }
    RpcFinally
        {

        NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

        NdrCorrelationFree( pStubMsg );
        }
   RpcEndFinally

    return ReturnValue;
}


// =======================================================================
//
//   Generic type pickling routines (for non-simple types).
//
// =======================================================================

void
NdrpCommonTypeHeaderSize(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    // This check is to prevent a decoding handle from being used
    // for both encoding and sizing of types.

    if ( pMesMsg->Operation != MES_ENCODE )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( ! GET_COMMON_TYPE_HEADER_SIZED( pMesMsg ) )
        {
        pMesMsg->StubMsg.BufferLength += MES_CTYPE_HEADER_SIZE;

        SET_COMMON_TYPE_HEADER_SIZED( pMesMsg );
        }
}


size_t  RPC_ENTRY
NdrMesTypeAlignSize2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo, 
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormat,
    const void *                    pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )
        
    pStubMsg->fHasExtensions  = 1;

    if ( pPicklingInfo->Flags.HasNewCorrDesc )
        {
        void * pCorrInfo = alloca( NDR_DEFAULT_CORR_CACHE_SIZE );

        NdrCorrelationInitialize( pStubMsg,
                        (unsigned long *) pCorrInfo,
                        NDR_DEFAULT_CORR_CACHE_SIZE,
                        0 /* flags */ );
        }

    return NdrMesTypeAlignSize(Handle, pStubDesc, pFormat, pObject);
}

size_t  RPC_ENTRY
NdrMesTypeAlignSize(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    const void *            pObject
    )
/*++

Routine description:

    Calculates the buffer size of the object relative to the current state
    of the pickling handle.

Arguments:

    Handle      - a pickling handle,
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type
    pObject     - a pointer to the object being sized.

Returns:

    The size.

Note:

    The pickling header is included in the sizing.

--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE)Handle)->StubMsg;
    size_t             OldLength = pStubMsg->BufferLength;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (long)pStubMsg->BufferLength & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    // See if we need to size the common type header.

    NdrpCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );

    // Now the individual type object.

    pStubMsg->BufferLength += MES_HEADER_SIZE;

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void * *)pObject;
        }

    (*pfnSizeRoutines[ ROUTINE_INDEX(*pFormat) ])
                                        ( pStubMsg,
                                        (uchar *)pObject,
                                        pFormat );

   LENGTH_ALIGN( pStubMsg->BufferLength, 7 );

   return( pStubMsg->BufferLength - OldLength );
}



size_t
NdrpCommonTypeHeaderMarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
/*++
    Returns the space used by the common header.
--*/
{
    if ( ! GET_COMMON_TYPE_HEADER_IN( pMesMsg ) )
        {
        PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

        MIDL_memset( pStubMsg->Buffer, 0xcc, MES_CTYPE_HEADER_SIZE );

        *pStubMsg->Buffer++ = MIDL_ES_VERSION;
        *pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN;
        * PSHORT_CAST pStubMsg->Buffer = MES_CTYPE_HEADER_SIZE;

        pStubMsg->Buffer += MES_CTYPE_HEADER_SIZE - 2;

        SET_COMMON_TYPE_HEADER_IN( pMesMsg );
        return( MES_CTYPE_HEADER_SIZE );
        }

    return( 0 );
}


void  RPC_ENTRY
NdrMesTypeEncode2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC *          pStubDesc,
    PFORMAT_STRING                  pFormat,
    const void *                    pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    pStubMsg->fHasExtensions  = 1;

    if ( pPicklingInfo->Flags.HasNewCorrDesc )
        {
        void * pCorrInfo = alloca( NDR_DEFAULT_CORR_CACHE_SIZE );

        NdrCorrelationInitialize( pStubMsg,
                        (unsigned long *) pCorrInfo,
                        NDR_DEFAULT_CORR_CACHE_SIZE,
                        0 /* flags */ );
        }
    RpcTryFinally
        {
        NdrMesTypeEncode(Handle, pStubDesc, pFormat, pObject);
        if ( pStubMsg->pCorrInfo )
            NdrCorrelationPass( pStubMsg );        
        }
    RpcFinally
        {
        // while currently we are not using corrinfo in marshalling pass, we need this 
        // in case we are using corrinfo later (like info for free)
        NdrCorrelationFree( pStubMsg );        
        }
    RpcEndFinally
        
}

void  RPC_ENTRY
NdrMesTypeEncode(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    const void *            pObject
    )
/*++

Routine description:

    Encodes the object to the buffer depending on the state of the handle.
    This means: sizing, allocating buffer, marshalling, writing buffer.

Arguments:

    Handle      - a pickling handle
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type,
    pObject     - a pointer to the object being sized.

Returns:

    The size.

Note:

    The pickling header is included in the sizing.

--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    uchar *             pBufferSaved;
    size_t              RequiredLen, CommonHeaderSize, LengthSaved;

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    // Size and allocate the buffer.
    // The req len includes: (the common header), the header and the data

    // Take the pointer alignment to come up with the right size.

    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    RequiredLen = NdrMesTypeAlignSize( Handle,
                                       pStubDesc,
                                       pFormat,
                                       pObject );

    NdrpAllocPicklingBuffer( pMesMsg, RequiredLen );

    pBufferSaved = pStubMsg->Buffer;
    LengthSaved  = RequiredLen;

    // See if we need to marshall the common type header

    CommonHeaderSize = NdrpCommonTypeHeaderMarshall( pMesMsg );

    // Marshall the header and the object.

    // zero out the type header (will contain type buffer length after
    // encoding is done )
    memset( pStubMsg->Buffer, 0, MES_HEADER_SIZE );
    pStubMsg->Buffer += MES_HEADER_SIZE;

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void * *)pObject;
        }

    (*pfnMarshallRoutines[ ROUTINE_INDEX(*pFormat) ])
                                      ( pStubMsg,
                                        (uchar *)pObject,
                                        pFormat );

    // We adjust the buffer to the next align by 8 and
    // so, we tell the user that we've written out till next mod 8.

    ALIGN( pStubMsg->Buffer, 7 );
    size_t WriteLength = (size_t)(pStubMsg->Buffer - pBufferSaved);

    // We always save the rounded up object length in the type header.

    *(unsigned long *)(pBufferSaved + CommonHeaderSize) =
                     WriteLength - CommonHeaderSize - MES_HEADER_SIZE;

    if ( LengthSaved < WriteLength )
        {
        NDR_ASSERT( 0, "NdrMesTypeEncode: encode buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    NdrpWritePicklingBuffer( pMesMsg, pBufferSaved, WriteLength );
}



void
NdrpCommonTypeHeaderUnmarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    if ( pMesMsg->Operation != MES_DECODE )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( ! GET_COMMON_TYPE_HEADER_IN( pMesMsg ) )
        {
        PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

        NdrpReadPicklingBuffer( pMesMsg, MES_CTYPE_HEADER_SIZE );

        // Check the version number, endianness.

        if ( *pStubMsg->Buffer != MIDL_ES_VERSION )
            RpcRaiseException( RPC_X_WRONG_ES_VERSION );

        if ( pStubMsg->Buffer[1] == NDR_LOCAL_ENDIAN )
            {
            // Read the note about endianess at NdrMesTypeDecode.
            //
            pMesMsg->AlienDataRep = NDR_LOCAL_DATA_REPRESENTATION;
            }
        else
            {
            unsigned char temp = pStubMsg->Buffer[2];
            pStubMsg->Buffer[2] = pStubMsg->Buffer[3];
            pStubMsg->Buffer[3] = temp;

            pMesMsg->AlienDataRep = ( NDR_ASCII_CHAR       |     // chars
                                      pStubMsg->Buffer[1]  |     // endianness
                                      NDR_IEEE_FLOAT );          // float
            }

        pStubMsg->Buffer += MES_CTYPE_HEADER_SIZE;

        SET_COMMON_TYPE_HEADER_IN( pMesMsg );
        }

}

void  RPC_ENTRY
NdrMesTypeDecode2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void                          * pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    pStubMsg->fHasExtensions  = 1;
    RpcTryFinally
        {

    if ( pPicklingInfo->Flags.HasNewCorrDesc )
        {
        void * pCorrInfo = alloca( NDR_DEFAULT_CORR_CACHE_SIZE );

        NdrCorrelationInitialize( pStubMsg,
                        (unsigned long *) pCorrInfo,
                        NDR_DEFAULT_CORR_CACHE_SIZE,
                        0 /* flags */ );
        }

        NdrMesTypeDecode(Handle, pStubDesc, pFormat, pObject);
        if ( pStubMsg->pCorrInfo )
            NdrCorrelationPass( pStubMsg );
        }
    RpcFinally
        {
        NdrCorrelationFree( pStubMsg );
        }
    RpcEndFinally
}

void  RPC_ENTRY
NdrMesTypeDecode(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    void                 *  pObject
    )
/*++

Routine description:

    Decodes the object to the buffer depending on the state of the handle.
    This means: reads the header, reads the buffer, unmarshalls.

Arguments:

    Handle      - a pickling handle
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type,
    pObject     - a pointer to the object being sized.

Returns:

    The size.

Note:

    Endianness and other conversions when decoding *types*.
    Starting with Mac implementation, types have a conversion that
    takes care of different endianness. ASCII and VAX_FLOAT are still
    assummed for types.
    Common header conveys the endianness information. The handle gets the
    endian info from the common header and so when decoding types, the
    handle is used to check if the conversion is needed.

    We cannot convert the whole buffer at the time of processing the common
    header as the buffer may not be there yet (for incremental handle).

--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    size_t              RequiredLen;

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;
    uchar *             BufferSaved;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    // See if we need to unmarshall the common type header.

    NdrpCommonTypeHeaderUnmarshall( pMesMsg );

    // Now the individual data object.

    NdrpReadPicklingBuffer( pMesMsg, MES_HEADER_SIZE );

    // Reading the object. Get the length of the buffer first.

    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        pStubMsg->RpcMsg->DataRepresentation = pMesMsg->AlienDataRep;

        BufferSaved = pStubMsg->Buffer;
        NdrSimpleTypeConvert( pStubMsg, FC_LONG );
        pStubMsg->Buffer = BufferSaved;
        }

    RequiredLen = (size_t) *(unsigned long *)pStubMsg->Buffer;
    pStubMsg->Buffer += MES_HEADER_SIZE;

    NdrpReadPicklingBuffer( pMesMsg, RequiredLen );

    // Now the conversion of the object, if needed.

    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        BufferSaved = pStubMsg->Buffer;
        (*pfnConvertRoutines[ ROUTINE_INDEX( *pFormat) ])
            ( pStubMsg,
              pFormat,
              FALSE );
        pStubMsg->Buffer = BufferSaved;
        }

    // Unmarshalling.

    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    void * pArg = pObject;

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        //
        pArg = *(void **)pArg;
        }

    (*pfnUnmarshallRoutines[ ROUTINE_INDEX( *pFormat )])
                            ( pStubMsg,
                              (uchar * *)&pArg,
                              pFormat,
                              FALSE );

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // Don't drop the pointee, if it was allocated.

        *(void **)pObject = pArg;
        }

    // Next decoding needs to start at aligned to 8.

    ALIGN( pStubMsg->Buffer, 7 );
}




void  RPC_ENTRY
NdrMesTypeFree(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    PFORMAT_STRING          pFormat,
    void                 *  pObject
    )
/*++

Routine description:

    Free the object.

Arguments:

    Handle      - a pickling handle,
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type
    pObject     - a pointer to the object being freed.

Returns:

Note:

    The pickling header is included in the sizing.

--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE)Handle)->StubMsg;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;

    // Now the individual type object.

    if ( IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void * *)pObject;
        }

    (*pfnFreeRoutines[ ROUTINE_INDEX(*pFormat) ])
                                        ( pStubMsg,
                                        (uchar *)pObject,
                                        pFormat );
}

void  RPC_ENTRY
NdrMesTypeFree2(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void                          * pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    pStubMsg->fHasExtensions  = 1;

    if ( pPicklingInfo->Flags.HasNewCorrDesc )
        {
        void * pCorrInfo = alloca( NDR_DEFAULT_CORR_CACHE_SIZE );

        NdrCorrelationInitialize( pStubMsg,
                        (unsigned long *) pCorrInfo,
                        NDR_DEFAULT_CORR_CACHE_SIZE,
                        0 /* flags */ );
        }

    NdrMesTypeFree(Handle, pStubDesc, pFormat, pObject);
}


// =======================================================================
//
//   Ready to use AlignSize routines for simple types
//
// =======================================================================

size_t  RPC_ENTRY
NdrMesSimpleTypeAlignSize(
    handle_t Handle )
/*++
    Size is always 8 bytes for data and there is no header here per data.
    However, the common header gets included for the first object.
--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE) Handle)->StubMsg;

    if( (long)( pStubMsg->BufferLength & 0x7 ) )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    unsigned long OldLength = pStubMsg->BufferLength;

    NdrpCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );
    pStubMsg->BufferLength += 8;

    return( (size_t)(pStubMsg->BufferLength - OldLength) );
}


// =======================================================================
//
//   Ready to use Encode routines for simple types
//
// =======================================================================

void  RPC_ENTRY
NdrMesSimpleTypeEncode(
    handle_t                Handle,
    const MIDL_STUB_DESC *  pStubDesc,
    const void           *  pData,
    short                   Size )
/*++
    Marshall a simple type entity. There is no header here per data.
    However, the common header gets included for the first object.
--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    size_t RequiredLen;

    // Size and allocate the buffer.
    // The req len includes: (the common header) and the data

    // Take the pointer alignment to come up with the right size.

    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    RequiredLen = NdrMesSimpleTypeAlignSize( Handle );
    NdrpAllocPicklingBuffer( pMesMsg, RequiredLen );

    // See if we need to marshall the common type header

    uchar *   pBufferSaved = pStubMsg->Buffer;

    NdrpCommonTypeHeaderMarshall( pMesMsg );

    switch ( Size )
        {
        case 1:
            * PCHAR_CAST pStubMsg->Buffer  = * PCHAR_CAST pData;
            break;

        case 2:
            * PSHORT_CAST pStubMsg->Buffer = * PSHORT_CAST pData;
            break;

        case 4:
            * PLONG_CAST pStubMsg->Buffer  = * PLONG_CAST pData;
            break;

        case 8:
            * PHYPER_CAST pStubMsg->Buffer = * PHYPER_CAST pData;
            break;

        default:
            NDR_ASSERT( 0, " Size generation problem" );
        }
    pStubMsg->Buffer += 8;

    NdrpWritePicklingBuffer( pMesMsg, pBufferSaved, RequiredLen );
}



// =======================================================================
//
//   Ready to use Decode routines for simple types
//
// =======================================================================

void  RPC_ENTRY
NdrMesSimpleTypeDecode(
    handle_t Handle,
    void  *  pData,
    short    FormatChar )
/*++
    Does not include the header for the data.
    However, the common header gets included for the first object.

    Note. Endianness and other conversions for decode.
    This has been deemed as not worthy doing in the Daytona time frame.
    However, to be able to add it in future without backward compatibility
    problems, we have the last argument to be the format character as
    opposed to the size.
    This makes it possible to call NdrSimpleTypeConvert, if needed.
--*/
{
    NdrpValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE)Handle)->StubMsg;
    uchar *             BufferSaved;

    // See if we need to unmarshall the common type header.

    NdrpCommonTypeHeaderUnmarshall( (PMIDL_ES_MESSAGE) Handle );

    // Now the data.

    NdrpReadPicklingBuffer( (PMIDL_ES_MESSAGE) Handle, 8);

    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        pStubMsg->RpcMsg->DataRepresentation = pMesMsg->AlienDataRep;

        BufferSaved = pStubMsg->Buffer;
        NdrSimpleTypeConvert( pStubMsg, (unsigned char)FormatChar );
        pStubMsg->Buffer = BufferSaved;
        }

    switch ( FormatChar )
        {
        case FC_BYTE:
        case FC_CHAR:
        case FC_SMALL:
        case FC_USMALL:
            * PCHAR_CAST  pData = * PCHAR_CAST pStubMsg->Buffer;
            break;

        case FC_WCHAR:
        case FC_SHORT:
        case FC_USHORT:
        case FC_ENUM16:
            * PSHORT_CAST pData = * PSHORT_CAST pStubMsg->Buffer;
            break;

        case FC_LONG:
        case FC_ULONG:
        case FC_FLOAT:
        case FC_ENUM32:
        case FC_ERROR_STATUS_T:
            * PLONG_CAST  pData = * PLONG_CAST pStubMsg->Buffer;
            break;

        case FC_HYPER:
        case FC_DOUBLE:
            * PHYPER_CAST pData = * PHYPER_CAST pStubMsg->Buffer;
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
            *((INT64 *)pData)  = *((long *) pStubMsg->Buffer);
            break;

        case FC_UINT3264:
            *((UINT64 *)pData) = *((ulong *)pStubMsg->Buffer);
            break;
#endif

        default:
            NDR_ASSERT( 0, " Size generation problem for simple types" );
        }

    pStubMsg->Buffer += 8;
}

void
NdrpProcHeaderMarshallAll(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

    // Marshall DCE pickle header.

    if( (LONG_PTR)pStubMsg->Buffer & 0x7 )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    if ( pMesMsg->Operation == MES_ENCODE )
        * pStubMsg->Buffer++ = MIDL_ES_VERSION;
    else
        * pStubMsg->Buffer++ = MIDL_NDR64_ES_VERSION;
        
    * pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN_LOW;
    *( PSHORT_LV_CAST pStubMsg->Buffer)++ = (short)0xcccc;    // filler

    // Marshall transfer syntax from the stub.

    RpcpMemoryCopy( pStubMsg->Buffer,
                    &( ( PMIDL_ES_MESSAGE_EX)pMesMsg )->TransferSyntax,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

    // We need to remember InterfaceId for inquiries.

    RpcpMemoryCopy( & pMesMsg->InterfaceId,
                    & ((PRPC_CLIENT_INTERFACE)(pStubMsg->
                         StubDesc->RpcInterfaceInformation))->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

   // Marshall InterfaceId and ProcNumber from the handle.

    RpcpMemoryCopy( pStubMsg->Buffer + sizeof(RPC_SYNTAX_IDENTIFIER),
                    & pMesMsg->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long) );

    SET_MES_INFO_AVAILABLE( pMesMsg );

    pStubMsg->Buffer += 2 * sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long);

    * pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN_LOW;
    * pStubMsg->Buffer++ = NDR_ASCII_CHAR;
    * pStubMsg->Buffer++ = (char) (NDR_IEEE_FLOAT >> 8);
    * pStubMsg->Buffer++ = 0;   // filler

    // This is non-DCE element as they have just 4 more bytes of filler here.
    // This field is used only when unmarshalling in our incremental style.

    *( PLONG_LV_CAST pStubMsg->Buffer)++ = pStubMsg->BufferLength -
                                                   MES_PROC_HEADER_SIZE;
}

void
NdrpProcHeaderUnmarshallAll(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    unsigned char *         BufferToRestore;
    PMIDL_STUB_MESSAGE      pStubMsg = &pMesMsg->StubMsg;

    if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
        return;

    NdrpReadPicklingBuffer( pMesMsg, MES_PROC_HEADER_SIZE );

    // Unmarshalling the header

    if ( *pStubMsg->Buffer != MIDL_ES_VERSION && 
         *pStubMsg->Buffer != MIDL_NDR64_ES_VERSION)
        RpcRaiseException( RPC_X_WRONG_ES_VERSION );

    BufferToRestore = pStubMsg->Buffer + 4;

    if ( pStubMsg->Buffer[1] != NDR_LOCAL_ENDIAN_LOW )
        {
        // The DCE header has the endianness on the low nibble, while
        // our DataRep has it on the high nibble.
        // We need only endianess to convert the proc header.

        byte Endianness = (pStubMsg->Buffer[1] << 4 );

        pStubMsg->RpcMsg->DataRepresentation = Endianness;

        pStubMsg->Buffer += 4;
        NdrSimpleStructConvert( pStubMsg,
                                &__MIDLFormatString.Format[32],
                                FALSE );
        }

    pStubMsg->Buffer = BufferToRestore;

    // Verify the transfer syntax

    RpcpMemoryCopy( &((PMIDL_ES_MESSAGE_EX)pMesMsg)->TransferSyntax, 
                      pStubMsg->Buffer,
                      sizeof( RPC_SYNTAX_IDENTIFIER ) );

    pStubMsg->Buffer += sizeof(RPC_SYNTAX_IDENTIFIER);

    // We need to remember the last InterfaceId and ProcNumber for inquiries.

    RpcpMemoryCopy( & pMesMsg->InterfaceId,
                    pStubMsg->Buffer,
                    sizeof(RPC_SYNTAX_IDENTIFIER)  );
  
    pStubMsg->Buffer += sizeof(RPC_SYNTAX_IDENTIFIER);

    pMesMsg->ProcNumber = *(ulong *)pStubMsg->Buffer;

    pStubMsg->Buffer += 4;

    SET_MES_INFO_AVAILABLE( pMesMsg );

    unsigned long AlienDataRepresentation =
                        ( (pStubMsg->Buffer[0] << 4)  |           // endianness
                          pStubMsg->Buffer[1]  |                       // chars
                        ((unsigned long)(pStubMsg->Buffer[2]) << 8) ); // float
    pMesMsg->AlienDataRep = AlienDataRepresentation;
    pMesMsg->IncrDataSize = (size_t) *(unsigned long __RPC_FAR *)
                                                (pStubMsg->Buffer + 4);
    pStubMsg->Buffer += 8;
}

extern const MIDL_FORMAT_STRING __MIDLFormatString =
    {
        0,
        {
            
            0x1d,       /* FC_SMFARRAY */
            0x0,        /* 0 */
/*  2 */    0x6, 0x0,   /* 6 */
/*  4 */    0x1,        /* FC_BYTE */
            0x5b,       /* FC_END */
/*  6 */    
            0x15,       /* FC_STRUCT */
            0x3,        /* 3 */
/*  8 */    0x10, 0x0,  /* 16 */
/* 10 */    0x8,        /* FC_LONG */
            0x6,        /* FC_SHORT */
/* 12 */    0x6,        /* FC_SHORT */
            0x3,        /* FC_SMALL */
/* 14 */    0x3,        /* FC_SMALL */
            0x4c,       /* FC_EMBEDDED_COMPLEX */
/* 16 */    0x0,        /* 0 */
            0xef, 0xff, /* Offset= -17 (0) */
            0x5b,       /* FC_END */
/* 20 */    
            0x15,       /* FC_STRUCT */
            0x3,        /* 3 */
/* 22 */    0x14, 0x0,  /* 20 */
/* 24 */    0x4c,       /* FC_EMBEDDED_COMPLEX */
            0x0,        /* 0 */
/* 26 */    0xec, 0xff, /* Offset= -20 (6) */
/* 28 */    0x6,        /* FC_SHORT */
            0x6,        /* FC_SHORT */
/* 30 */    0x5c,       /* FC_PAD */
            0x5b,       /* FC_END */
/* 32 */    
            0x15,       /* FC_STRUCT */
            0x3,        /* 3 */
/* 34 */    0x34, 0x0,  /* 52 */
/* 36 */    0x4c,       /* FC_EMBEDDED_COMPLEX */
            0x0,        /* 0 */
/* 38 */    0xee, 0xff, /* Offset= -18 (20) */
/* 40 */    0x4c,       /* FC_EMBEDDED_COMPLEX */
            0x0,        /* 0 */
/* 42 */    0xea, 0xff, /* Offset= -22 (20) */
/* 44 */    0x8,        /* FC_LONG */
            0x1,        /* FC_BYTE */
/* 46 */    0x1,        /* FC_BYTE */
            0x1,        /* FC_BYTE */
/* 48 */    0x1,        /* FC_BYTE */
            0x38,       /* FC_ALIGNM4 */
/* 50 */    0x8,        /* FC_LONG */
            0x5b,       /* FC_END */

            0x0
        }
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\pipes.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                                   
Copyright (c) 1995-2000 Microsoft Corporation

Module Name :

    pipe.c

Abstract :

    This file contains the idl pipe implementetion code.

Author :

    Ryszard K. Kott     (ryszardk)    Dec 1995

Revision History :

---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY

#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "ndrole.h"
#include "objidl.h"
#include "rpcproxy.h"
#include "interp.h"
#include "interp2.h"
#include "mulsyntx.h"
#include "pipendr.h"
#include "asyncndr.h"

#if DBG

typedef enum 
{
    PIPE_LOG_NONE,
    PIPE_LOG_CRITICAL,
    PIPE_LOG_API,
    PIPE_LOG_NOISE
} NDR_PIPE_LOG_LEVEL;

NDR_PIPE_LOG_LEVEL NdrPipeLogLevel = PIPE_LOG_NONE;

#define NDR_PIPE_LOG( level, args )                    \
    if ( NdrPipeLogLevel > level )                     \
        {                                              \
        DbgPrint( "NdrPipeLog: %d : ", level );        \
        DbgPrint  args  ;                              \
        DbgPrint( "\n" );                              \
        }                                              \
        
#else

#define NDR_PIPE_LOG( level, args )

#endif


RPC_STATUS RPC_ENTRY
NdrSend(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    BOOL                fPartial )
/*++

Routine Description :

    Performs a I_RpcSend in all the context it could be used:
        - pipes,
        - async, no pipes

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

    The new message buffer pointer returned from the runtime after the
    partial Send to the server.

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg;

    pRpcMsg = pStubMsg->RpcMsg;

    if ( pRpcMsg->BufferLength <
                   (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer))
        {
        NDR_ASSERT( 0, "NdrSend : buffer overflow" );
        NdrpRaisePipeException( pPipeDesc, RPC_S_INTERNAL_ERROR );
        }

    pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

    pStubMsg->fBufferValid = FALSE;

    if ( fPartial )
        pRpcMsg->RpcFlags |= RPC_BUFFER_PARTIAL;
    else
        pRpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;

    if ( pStubMsg->pRpcChannelBuffer )
        {
        ((IRpcChannelBuffer3 *)pStubMsg->pRpcChannelBuffer)->lpVtbl->Send(
                                (IRpcChannelBuffer3 *)pStubMsg->pRpcChannelBuffer,
                                (RPCOLEMESSAGE *)pRpcMsg,
                                (unsigned long*) &Status );
        NDR_ASSERT( Status != RPC_S_SEND_INCOMPLETE, "Unexpected channel error" );
        }
    else
        Status = I_RpcSend( pRpcMsg );

    if ( ! ( Status == RPC_S_OK  ||
             (Status == RPC_S_SEND_INCOMPLETE  &&  fPartial) ) )
        {
        if ( pStubMsg->pAsyncMsg )
            pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;
        else if ( fPartial  &&  ! pStubMsg->IsClient )
            {
            // The buffer on which it failed has been freed by the runtime.
            // The stub has to return to runtime with the original buffer.
            // See ResetToDispatchBuffer for more info.

            pRpcMsg->Buffer = pPipeDesc->DispatchBuffer;
            pStubMsg->BufferStart = pPipeDesc->DispatchBuffer;
            pStubMsg->BufferEnd   = pPipeDesc->DispatchBuffer +
                                    pPipeDesc->DispatchBufferLength;
            }


        NdrpRaisePipeException( pPipeDesc,  Status );
        }

    // in the server side, after send succeed, pRpcMsg passed in from runtime is freed and 
    // shouldn't be accessed.
    if ( pStubMsg->IsClient || Status != RPC_S_OK ) 
        {
        pStubMsg->Buffer = (uchar*) pRpcMsg->Buffer;
        pStubMsg->fBufferValid = TRUE;
        }

    return( Status );
}


void RPC_ENTRY
NdrPartialSend(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg )
/*++

Routine Description :

    Performs a partial I_RpcSend. It's used in the following contexts:
        - synchronous pipes
        - async pipes

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

    The new message buffer pointer returned from the runtime after the
    partial Send to the server.

Note:
    The partial I_RpcSend sends out full packets, the data from the last
    packet is left over and stays in the same buffer.
    That buffer can later be "reallocated" or reallocated for the new size.
    This is done in the NdrGetPartialBuffer.

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;

    // This routine needs to send only multiple of 8s now.

    pPipeDesc->LeftoverSize = PtrToUlong(pStubMsg->Buffer) & 0x7;

    if ( pPipeDesc->LeftoverSize )
        {
        pStubMsg->Buffer -= pPipeDesc->LeftoverSize;
        RpcpMemoryCopy( pPipeDesc->Leftover,
                        pStubMsg->Buffer,
                        pPipeDesc->LeftoverSize );
        }

    Status = NdrSend( pPipeDesc,
                      pStubMsg,
                      TRUE );    // send partial

    // Handle unsent buffer case.

    if ( Status == RPC_S_SEND_INCOMPLETE )
        {
        pPipeDesc->LastPartialBuffer = (uchar*) pRpcMsg->Buffer;
        pPipeDesc->LastPartialSize   = pRpcMsg->BufferLength;

        NDR_ASSERT( ((LONG_PTR)pRpcMsg->Buffer & 0x7) == 0,
                    "unsent buffer should still be a multiple of 8" );
        }
    else
        {
        // means no buffer left behind.

        pPipeDesc->LastPartialBuffer = NULL;
        pPipeDesc->LastPartialSize   = 0;
        }

    //  Handle the modulo 8 leftover.

    if ( pPipeDesc->LeftoverSize )
        {
        pPipeDesc->LastPartialBuffer = (uchar*) pRpcMsg->Buffer;
        pPipeDesc->LastPartialSize  += pPipeDesc->LeftoverSize;
        }
}


void RPC_ENTRY
NdrCompleteSend(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg )
/*++

Routine Description :

    Performs a complete send via I_RpcSend.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

Note :

    I_RpcSend with partial bit zeroed out is a rough equivalant
    of RpcSendReceive; this also covers the way the buffer is handled.
    The runtime takes care of the sent buffer, returns a buffer with
    data that needs to be freed later by the stub.
    If the buffer coming back is partial, the partial Receives take
    care of it and only the last one needs to be freed w/RpcFreeBuffer.

--*/
{
    NdrSend( pPipeDesc,
             pStubMsg,
             FALSE );    // send not partial

    pPipeDesc->LastPartialBuffer = NULL;
    pPipeDesc->LastPartialSize   = 0;

}


void RPC_ENTRY
NdrReceive(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       Size,
    BOOL                fPartial )
/*++

Routine Description :

    Performs a partial I_RpcReceive.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

--*/
{
    RPC_STATUS      Status;
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;
    unsigned long   CurOffset  = 0;

    pStubMsg->fBufferValid = FALSE;

    if ( ! pStubMsg->pRpcChannelBuffer )
        {
        // Channel sets the flag on the last, complete send
        // so we cannot assert for channel for now.
        NDR_ASSERT( !(pRpcMsg->RpcFlags & RPC_BUFFER_COMPLETE), "no more buffers" );
        }

    if ( fPartial )
        {
        pRpcMsg->RpcFlags |= RPC_BUFFER_PARTIAL;
        pRpcMsg->RpcFlags &= ~RPC_BUFFER_EXTRA;

        // For partials, the current offset will be zero.
        }
    else
        {
        pRpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;

        // The extra flag may be set or cleared by the caller.
        // On the client
        //    it should be cleared if there is no out pipes
        //    it should be set only on the last receive after out pipes
        // On the server
        //    it should be set on the initial receives that get non pipe data
        //    it should cleared on all the other receives.

        // For a complete with extra (i.e. appending new data),
        // the current offset needs to be preserved.
        // For a complete without extra, the offset is zero
        // as the receive follows immediately after a send call.

        CurOffset = (ulong)(pStubMsg->Buffer - (uchar*)pRpcMsg->Buffer);
        }

    if ( pStubMsg->pRpcChannelBuffer )
        {
        ((IRpcChannelBuffer3 *)pStubMsg->pRpcChannelBuffer)->lpVtbl->Receive(
                                (IRpcChannelBuffer3 *)pStubMsg->pRpcChannelBuffer,
                                (RPCOLEMESSAGE *)pRpcMsg,
                                Size,
                                (unsigned long *)&Status );
        }
    else
        Status = I_RpcReceive( pRpcMsg, Size );

    if ( Status )
        {
        // Pending is also OK: if so, we should not touch the state,
        // just return from the call to the app.

        if ( Status != RPC_S_ASYNC_CALL_PENDING )
            {
            // Real bug happened, the state will be teared down etc.

            if ( ! pStubMsg->IsClient )
                {
                // The buffer on which it failed has been freed by the runtime.
                // See ResetToDispatchBuffer for explanations why we do this.
                // Also note, on server we never call with async-nonpipe context.

                pRpcMsg->Buffer       = pPipeDesc->DispatchBuffer;
                pStubMsg->BufferStart = pPipeDesc->DispatchBuffer;
                pStubMsg->BufferEnd   = pPipeDesc->DispatchBuffer +
                                        pPipeDesc->DispatchBufferLength;
                }

            if ( pStubMsg->pAsyncMsg )
                {
                // raw rpc: if async, prevent calling abort later.

                if ( pStubMsg->pAsyncMsg )
                    pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;
                }
            }
        else
            {
            //
            // Even though the runtime did not return a buffer, we need to mark
            // the buffer as valid.  This is necessary to ensure proper call cleanup
            // when the user call RpcAsyncCompleteCall upon receiving
            // an async failure.
            //
            // This only affects async pipes.
            //
            NDR_ASSERT(pRpcMsg->Buffer == NULL,
                       "Rpc runtime returned RPC_S_ASYNC_CALL_PENDING and a buffer." );
            pStubMsg->fBufferValid = TRUE;
            }

        NdrpRaisePipeException( pPipeDesc, Status);
        }

    NDR_ASSERT( 0 == pRpcMsg->BufferLength ||
                NULL != pRpcMsg->Buffer,
                "Rpc runtime returned an invalid buffer." ); 

    if ( fPartial )
        {
        NDR_ASSERT( pRpcMsg->BufferLength, "a partial buffer can't be empty" );
        if ( pRpcMsg->BufferLength == 0)
            RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    pStubMsg->Buffer = (uchar*) pRpcMsg->Buffer + CurOffset;

    pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferEnd   = (uchar*)pRpcMsg->Buffer + pRpcMsg->BufferLength;
    pStubMsg->fBufferValid = TRUE;

}


void RPC_ENTRY
NdrPartialReceive(
    NDR_PIPE_DESC   *   pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       Size )
/*++

Routine Description :

    Performs a partial I_RpcReceive.

Arguments :

    pStubMsg    - Pointer to stub message structure.
    pBufferEnd  - taken as StubMsg->Buffer

Return :

--*/
{
    //
    // On the server we need to keep the dispatch buffer as the non-pipe
    // arguments may actually reside in the buffer.
    //    pPipeDesc->DispatchBuffer always points to the original buffer.
    //
    // Note that the runtime would free any buffer passed in the receive call
    // unless the extra flag is set.
    // Buffer being zero means a request for a new buffer.

    if ( pPipeDesc->Flags.NoMoreBuffersToRead )
        NdrpRaisePipeException( pPipeDesc,  RPC_X_BAD_STUB_DATA );

    if ( ! pStubMsg->IsClient  &&
         (pPipeDesc->DispatchBuffer == pStubMsg->RpcMsg->Buffer ) )
        {
        // Setup a request for a new buffer.

        pStubMsg->RpcMsg->Buffer = NULL;
        }

    NdrReceive( pPipeDesc,
                pStubMsg,
                Size,
                TRUE );  // partial

    if ( !( pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE )  &&
         ( pStubMsg->RpcMsg->BufferLength & 0x7 ) )
        {
        NDR_ASSERT( 0, "Partial buffer length not multiple of 8");
        NdrpRaisePipeException( pPipeDesc,  RPC_S_INTERNAL_ERROR );
        }

    if ( pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE )
        pPipeDesc->Flags.NoMoreBuffersToRead = 1;

}


unsigned char * RPC_ENTRY
NdrGetPipeBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferLength,
    RPC_BINDING_HANDLE  Handle )
/*++

Routine Description :

    This is the first call at the client or server side. Needs to be
    different from NdrGetBuffer as later calls to get buffer are different.
     - raw: the buffer will be reallocated by means of I_RpcReallocPipeBuffer

--*/
{
    unsigned char * pBuffer;
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;

    pRpcMsg->RpcFlags &= ~RPC_BUFFER_COMPLETE;
    pRpcMsg->RpcFlags |= RPC_BUFFER_PARTIAL;
//#if !defined(__RPC_WIN64__)
    pRpcMsg->ProcNum  |= RPC_FLAGS_VALID_BIT;
//#endif    

    pBuffer = NdrGetBuffer( pStubMsg, BufferLength, Handle );

    return  pBuffer;
}


void RPC_ENTRY
NdrGetPartialBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg )
/*++

Routine Description :

    Gets the next buffer for a partial send depending on the pipe state.
    Because of the way partial I_RpcSend works, this routine takes care
    of the leftover from the last send by means of setting the buffer
    pointer to the first free position.
    See NdrPartialSend for more comments.

Return :

--*/
{
    RPC_STATUS      Status    = RPC_S_OK;
    NDR_PIPE_DESC * pPipeDesc = (NDR_PIPE_DESC *) pStubMsg->pContext->pPipeDesc;

    pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_COMPLETE;
    pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_PARTIAL;

    Status = I_RpcReallocPipeBuffer( pStubMsg->RpcMsg,
                                     pStubMsg->BufferLength );

    if ( Status != RPC_S_OK )
        {
        // Raw rpc: if async, don't call runtime to abort later.

        if ( pStubMsg->pAsyncMsg )
            pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;

        NdrpRaisePipeException( pPipeDesc,  Status );
        }

    ASSERT( pStubMsg->RpcMsg->BufferLength >= pStubMsg->BufferLength );

    pStubMsg->Buffer = (uchar*) pStubMsg->RpcMsg->Buffer +
                                pPipeDesc->LastPartialSize;

    if ( pPipeDesc->LeftoverSize )
        {
        // Because of sizing, LastPartialSize already had LeftoverSize in it.

        RpcpMemoryCopy( pStubMsg->Buffer - pPipeDesc->LeftoverSize,
                        pPipeDesc->Leftover,
                        pPipeDesc->LeftoverSize );
        }
}


void RPC_ENTRY
NdrPipesInitialize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_PIPE_HELPER    pPipeHelper,
    PNDR_ALLOCA_CONTEXT pAllocContext
    )
/*+
    Initializes all the pipe structures.
    Only standard RPC (non-DCOM) pipes are supported now.

+*/
{
    NDR_PIPE_STATE *    pRuntimeState;
        
    NDR_ASSERT( ! pStubMsg->pRpcChannelBuffer, "DCOM pipes not supported" );

    NDR_PIPE_DESC *pPipeDesc = pPipeHelper->GetPipeDesc();
    
    MIDL_memset( pPipeDesc, 0, sizeof(NDR_PIPE_DESC) );

    pPipeDesc->pPipeHelper   = pPipeHelper;
    pPipeDesc->pAllocContext = pAllocContext;

    pStubMsg->pContext->pPipeDesc = pPipeDesc;

    // See how many pipes we have and what the maximum wire size is.

    if ( pPipeHelper->InitParamEnum() )
        {

        do
            {
            unsigned short PipeFlags = pPipeHelper->GetParamPipeFlags();

            if ( PipeFlags )
                {

                if ( PipeFlags & NDR_IN_PIPE )
                    pPipeDesc->InPipes++;
                
                if ( PipeFlags & NDR_OUT_PIPE )
                    pPipeDesc->OutPipes++;

                pPipeDesc->TotalPipes++;
                }

            }
            while ( pPipeHelper->GotoNextParam() );

        }


    pPipeDesc->pPipeMsg = 
        (NDR_PIPE_MESSAGE *)NdrpAlloca( pPipeDesc->pAllocContext, 
                                        pPipeDesc->TotalPipes * sizeof( NDR_PIPE_MESSAGE ) );

    MIDL_memset( pPipeDesc->pPipeMsg,
                 0,
                 pPipeDesc->TotalPipes * sizeof( NDR_PIPE_MESSAGE ));

    pPipeDesc->CurrentPipe = -1;
    pPipeDesc->PrevPipe    = -1;
    pPipeDesc->PipeVersion = NDR_PIPE_VERSION;


    // Now set the individual pipe messages.

    NDR_PIPE_MESSAGE *pLastInPipe   = NULL;
    NDR_PIPE_MESSAGE *pLastOutPipe  = NULL;

    int PipeNo = 0;
    if ( pPipeHelper->InitParamEnum() )
        {

        do
            {
            unsigned short PipeFlags = pPipeHelper->GetParamPipeFlags();

            if ( !PipeFlags)
                continue;

            NDR_PIPE_MESSAGE * pPipe = & pPipeDesc->pPipeMsg[ PipeNo ];

            if ( PipeFlags & NDR_IN_PIPE )
                pLastInPipe  = pPipe;
            if ( PipeFlags & NDR_OUT_PIPE )
                pLastOutPipe = pPipe;
                
            pPipe->Signature   = NDR_PIPE_SIGNATURE;
            pPipe->PipeId      = (ushort)PipeNo;
            pPipe->PipeStatus  = NDR_PIPE_NOT_OPENED;
            pPipe->PipeFlags   = PipeFlags;
            pPipe->pTypeFormat = pPipeHelper->GetParamTypeFormat(); 
            pPipe->pStubMsg    = pStubMsg;

            pPipe->pPipeObject = (GENERIC_PIPE_TYPE *) pPipeHelper->GetParamArgument();

#if defined(_AMD64_)
            // in the server side, we need to allocate the GENERIC_PIPE_TYPE as it's not no stack now. 
            // don't want to check non-amd64 code so I just exclude the code path for NDR_REF_PIPE
            if ( ! (pPipe->PipeFlags & NDR_REF_PIPE ) ) 
                {
                if (!pStubMsg->IsClient )
                    {
                    void * temp = NdrpAlloca( pPipeDesc->pAllocContext,
                                          sizeof(GENERIC_PIPE_TYPE ) );

                    MIDL_memset( temp, 0, sizeof( GENERIC_PIPE_TYPE ) );

                    *(void **)pPipe->pPipeObject = (void **)temp;
                    pPipe->pPipeObject = (GENERIC_PIPE_TYPE *)temp;
                    }
                else
                    pPipe->pPipeObject = *(GENERIC_PIPE_TYPE **)pPipe->pPipeObject ;
                }
                
#endif

            if ( pPipe->PipeFlags & NDR_REF_PIPE )
                {
                // dereference the argument to get the pipe control block.

                if ( ! pStubMsg->IsClient )
                    {
                    // For the server, under interpreter, we don't have
                    // the actual pipe object that is referenced.
                    // The stack argument should be null.

                    NDR_ASSERT( ! *(void **)pPipe->pPipeObject,
                                "null expected for out pipe by ref" );

                    // The pipe object is not a real parameter in the 
                    // same sense as the other RPC parameters. The user 
                    // can not free the object.

                    void * temp = NdrpAlloca( pPipeDesc->pAllocContext,
                                              sizeof(GENERIC_PIPE_TYPE ) );

                    MIDL_memset( temp, 0, sizeof( GENERIC_PIPE_TYPE ) );

                    *(void **)pPipe->pPipeObject = temp;

                    pPipe->PipeFlags |= NDR_OUT_ALLOCED;
                    }

                  pPipe->pPipeObject = *(GENERIC_PIPE_TYPE **)pPipe->pPipeObject;
               }

            // For raw async rpc set up the pipe arg on both sides.
            // For non-async raw set up the pipe on server only.

            if (  pStubMsg->IsClient )
                {
                if ( pStubMsg->pAsyncMsg )
                    {
                    GENERIC_PIPE_TYPE * pPipeType = pPipe->pPipeObject;

                    pPipeType->pfnPull = NdrAsyncPipePull;
                    pPipeType->pfnPush = NdrAsyncPipePush;
                    pPipeType->pfnAlloc= NdrAsyncPipeAlloc;
                    pPipeType->pState  = (char *)pPipe;
                    }
                }
            else
                {
                GENERIC_PIPE_TYPE * pPipeType = pPipe->pPipeObject;

                if ( pStubMsg->pAsyncMsg )
                    {
                    pPipeType->pfnPull = NdrAsyncPipePull;
                    pPipeType->pfnPush = NdrAsyncPipePush;
                    pPipeType->pfnAlloc= NdrAsyncPipeAlloc;
                    pPipeType->pState  = (char *)pPipe;
                    }
                else
                    {
                    pPipeType->pfnPull = (NDR_HR_PIPE_PULL_RTN) NdrPipePull;
                    pPipeType->pfnPush = (NDR_HR_PIPE_PUSH_RTN) NdrPipePush;
                    pPipeType->pfnAlloc= (NDR_HR_PIPE_ALLOC_RTN)NdrPipeAlloc;
                    pPipeType->pState  = (char *)pPipe;
                    }
                }

            PipeNo++;

            } while ( pPipeHelper->GotoNextParam() ); 
        }

    // Mark the last in and out pipes.

    if ( pLastInPipe )
         pLastInPipe->PipeFlags |= NDR_LAST_IN_PIPE;
    if ( pLastOutPipe )
         pLastOutPipe->PipeFlags |= NDR_LAST_OUT_PIPE;

    // Set up structures for receiving pipes.

    pPipeDesc->DispatchBuffer       = (uchar *) pStubMsg->RpcMsg->Buffer;
    pPipeDesc->DispatchBufferLength =           pStubMsg->RpcMsg->BufferLength;

    if ( pPipeDesc->OutPipes  &&  pStubMsg->IsClient  ||
         pPipeDesc->InPipes   &&  ! pStubMsg->IsClient )
        {
        pRuntimeState = & pPipeDesc->RuntimeState;
        pRuntimeState->CurrentState      = START;
        pRuntimeState->TotalElemsCount   = 0;
        pRuntimeState->PartialElem       = 0;       // temp buf for elem
        pRuntimeState->PartialBufferSize = 0;       // temp buf for elem
        }

    if ( ! pStubMsg->IsClient  &&
         (pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE ))
        pPipeDesc->Flags.NoMoreBuffersToRead = 1;

}


class NDR_PIPE_HELPER32 : public NDR_PIPE_HELPER
{

private:

    PMIDL_STUB_MESSAGE pStubMsg;
    char *pStackTop;

    unsigned long NumberParameters;
    PPARAM_DESCRIPTION pFirstParameter;

    PPARAM_DESCRIPTION pCurrentParameter;
    unsigned long CurrentParamNumber;

    NDR_PIPE_DESC PipeDesc;

public:

    void *operator new( size_t stAllocateBlock, PNDR_ALLOCA_CONTEXT pAllocContext )
    {
        return NdrpAlloca( pAllocContext, (UINT)stAllocateBlock );
    }
    // Do nothing since the memory will be deleted automatically
    void operator delete(void *pMemory) {}

    NDR_PIPE_HELPER32( PMIDL_STUB_MESSAGE  pStubMsg,
                       PFORMAT_STRING      Params,
                       char *              pStackTop,
                       unsigned long       NumberParams )
    {
        NDR_PIPE_HELPER32::pStubMsg  = pStubMsg;
        NDR_PIPE_HELPER32::pStackTop = pStackTop; 
        pFirstParameter  = (PPARAM_DESCRIPTION)Params;
        NumberParameters = NumberParams;

    }

    virtual PNDR_PIPE_DESC GetPipeDesc() 
        {
        return &PipeDesc;
        }

    virtual bool InitParamEnum() 
        {
        pCurrentParameter = pFirstParameter;
        CurrentParamNumber = 0;
        return NumberParameters > 0;
        }

    virtual bool GotoNextParam() 
        {
        if ( CurrentParamNumber + 1 >= NumberParameters )
            {
            return false;
            }
        
        CurrentParamNumber++;
        pCurrentParameter = pFirstParameter + CurrentParamNumber;
        return true;
        }

    virtual unsigned short GetParamPipeFlags()
        {
            if ( !pCurrentParameter->ParamAttr.IsPipe )
                return 0;

            unsigned short Flags = 0;

            if ( pCurrentParameter->ParamAttr.IsIn )
                Flags |= NDR_IN_PIPE;
            if ( pCurrentParameter->ParamAttr.IsOut )
                Flags |= NDR_OUT_PIPE;

            if ( pCurrentParameter->ParamAttr.IsSimpleRef )
                Flags |= NDR_REF_PIPE;

            return Flags;
        }

    virtual PFORMAT_STRING GetParamTypeFormat() 
        {
            return pStubMsg->StubDesc->pFormatTypes +
                   pCurrentParameter->TypeOffset;
        }

    virtual char *GetParamArgument() 
        {
            return pStackTop + pCurrentParameter->StackOffset;
        }

    virtual void InitPipeStateWithType( PNDR_PIPE_MESSAGE pPipeMsg )
        {

        FC_PIPE_DEF *   pPipeFc  = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
        NDR_PIPE_STATE *pState   = & PipeDesc.RuntimeState;

        pState->LowChunkLimit = 0;
        pState->HighChunkLimit = NDR_DEFAULT_PIPE_HIGH_CHUNK_LIMIT;
        pState->ElemAlign = pPipeFc->Align;
        if ( pPipeFc->BigPipe )
            {
            pState->ElemMemSize  = * (long UNALIGNED *) & pPipeFc->Big.MemSize;
            pState->ElemWireSize = * (long UNALIGNED *) & pPipeFc->Big.WireSize;
            if ( pPipeFc->HasRange )
                {
                pState->LowChunkLimit  = * (long UNALIGNED *) &pPipeFc->Big.LowChunkLimit;
                pState->HighChunkLimit = * (long UNALIGNED *) &pPipeFc->Big.HighChunkLimit;
                }
            }
        else
            {
            pState->ElemMemSize  = pPipeFc->s.MemSize;
            pState->ElemWireSize = pPipeFc->s.WireSize;
            if ( pPipeFc->HasRange )
                {
                pState->LowChunkLimit  = * (long UNALIGNED *) &pPipeFc->s.LowChunkLimit;
                pState->HighChunkLimit = * (long UNALIGNED *) &pPipeFc->s.HighChunkLimit;
                }
            }

        pState->ElemPad     = WIRE_PAD( pState->ElemWireSize, pState->ElemAlign );
        pState->fBlockCopy  = (pState->ElemMemSize == 
                               pState->ElemWireSize + pState->ElemPad); 
        }
    
    virtual void MarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                               uchar *pMemory,
                               unsigned long Elements )
        {

            unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
            
            FC_PIPE_DEF *   pPipeFc      = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
            PFORMAT_STRING  pElemFormat  =
                       (uchar *) & pPipeFc->TypeOffset + pPipeFc->TypeOffset;

            while( Elements-- )
                {
                (*pfnMarshallRoutines[ROUTINE_INDEX(*pElemFormat)])
                   ( pPipeMsg->pStubMsg,
                     pMemory,
                     pElemFormat);
                pMemory += ElemMemSize;
                }
        }
    
    virtual void UnmarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements )
        {

            unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
            
            FC_PIPE_DEF *   pPipeFc      = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
            PFORMAT_STRING  pElemFormat  =
                       (uchar *) & pPipeFc->TypeOffset + pPipeFc->TypeOffset;

            while( Elements-- )
                {
                (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pElemFormat)])
                   ( pPipeMsg->pStubMsg,
                     &pMemory,
                     pElemFormat,
                     FALSE );
                pMemory += ElemMemSize;
                }

        }
    
    virtual void BufferSizeType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements )
        { 
        
        unsigned long ElemMemSize = PipeDesc.RuntimeState.ElemMemSize;
        
        FC_PIPE_DEF *   pPipeFc      = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
        PFORMAT_STRING  pElemFormat  =
                   (uchar *) & pPipeFc->TypeOffset + pPipeFc->TypeOffset;

        while( Elements-- )
            {
            (*pfnSizeRoutines[ROUTINE_INDEX(*pElemFormat)])
               ( pPipeMsg->pStubMsg,
                 pMemory,
                 pElemFormat);
            pMemory += ElemMemSize;
            }

        }
    
    virtual void ConvertType( PNDR_PIPE_MESSAGE pPipeMsg,
                              unsigned long Elements ) 
        {

        unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
        
        FC_PIPE_DEF *   pPipeFc      = (FC_PIPE_DEF *) pPipeMsg->pTypeFormat;
        PFORMAT_STRING  pElemFormat  =
                   (uchar *) & pPipeFc->TypeOffset + pPipeFc->TypeOffset;

        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;

        if ( pStubMsg->RpcMsg->DataRepresentation
                               == NDR_LOCAL_DATA_REPRESENTATION )
            return;

        uchar * BufferSaved = pStubMsg->Buffer;

        // We can end up here for any object.

        while ( Elements-- )
            {
            if ( IS_SIMPLE_TYPE( *pElemFormat) )
                {
                NdrSimpleTypeConvert( pStubMsg, *pElemFormat );
                }
            else
                {
                (*pfnConvertRoutines[ ROUTINE_INDEX( *pElemFormat ) ])
                            ( pStubMsg,
                              pElemFormat,
                              FALSE );  // embedded pointers
                }
            }

        pStubMsg->Buffer = BufferSaved;

        }

    virtual void BufferSizeChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg ) 
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        LENGTH_ALIGN( pStubMsg->BufferLength, 3 );
        pStubMsg->BufferLength += sizeof(ulong);
    }

    virtual bool UnmarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong *pOut )
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        ALIGN( pStubMsg->Buffer, 3);
       
        if ( 0 == REMAINING_BYTES() )
           {
           return false;
           }

        // transition: end of src

        if (REMAINING_BYTES() < sizeof(DWORD))
            {
            // with packet sizes being a multiple of 8,
            // this cannot happen.

            NDR_ASSERT( 0, "Chunk counter split is not possible.");

            NdrpRaisePipeException( &PipeDesc,  RPC_S_INTERNAL_ERROR );
            return false;
            }

        if ( pStubMsg->RpcMsg->DataRepresentation
                               != NDR_LOCAL_DATA_REPRESENTATION )
            {
            uchar * BufferSaved = pStubMsg->Buffer;

            NdrSimpleTypeConvert( pStubMsg, FC_LONG );
            pStubMsg->Buffer = BufferSaved;
            }

        ulong Value = *(ulong*)pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(ulong);

        CHECK_BOUND( Value, FC_ULONG );
        *pOut = Value;
        return true;
    }

    virtual void MarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                       ulong Counter )
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        CHECK_BOUND( Counter, FC_ULONG );
        
        ALIGN( pStubMsg->Buffer, 3);
        *(ulong*)pStubMsg->Buffer = Counter;
        pStubMsg->Buffer += sizeof(ulong);
    }

    virtual void BufferSizeChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg ) { pPipeMsg; };

    virtual void MarshallChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                           ulong Counter ) { pPipeMsg; Counter; }

    virtual bool VerifyChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong HeaderCounter ) 
    { 
        pPipeMsg; HeaderCounter; 
        return true;
    }

    virtual bool HasChunkTailCounter() { return FALSE; }


};

typedef NDR_PIPE_HELPER *PNDR_PIPE_HELPER;


void
NdrpPipesInitialize32(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_ALLOCA_CONTEXT pAllocContext,
    PFORMAT_STRING      Params,
    char *              pStackTop,
    unsigned long       NumberParams
    )
{

/* C wrapper to initialize the 32 pipe helper and call NdrPipesInitialize*/
    NDR_PIPE_HELPER32 *pPipeHelper =
        new( pAllocContext ) NDR_PIPE_HELPER32( pStubMsg,
                                                Params,
                                                pStackTop,
                                                NumberParams );
    
    NdrPipesInitialize( pStubMsg,
                        pPipeHelper,
                        pAllocContext );
}


void  RPC_ENTRY
ResetToDispatchBuffer(
    NDR_PIPE_DESC *     pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg
    )
/*
    This is a server side routine that makes sure that
    the original dispatch buffer is restored to the rpc message.

    These are the rules:
    - the engine can return to the runtime with the original or a new
      buffer; if it's a new buffer it has to be valid (not freed yet).
      When exception happens, the runtime will be freeing any buffer
      that is different from the original buffer.
    - when I_RpcReceive or I_RpcSend fail, they free the current
      buffer, and so the stub cannot free it. If this is the second
      buffer, the original dispatch buffer pointer should be restored
      in the rpcmsg.
    - the second buffer does not have to be freed in case of a
      normal return or an exception clean up in a situation different
      from above. The runtime will free it.

    Note that we never free the original dispatch buffer.
*/
{
    PRPC_MESSAGE    pRpcMsg = pStubMsg->RpcMsg;

    // If the dispatch buffer was replaced by a partial buffer,
    // free the partial buffer and restore the dispatch buffer.

    if ( pPipeDesc->DispatchBuffer != pRpcMsg->Buffer )
        {
        I_RpcFreePipeBuffer( pRpcMsg );

        pRpcMsg->Buffer = pPipeDesc->DispatchBuffer;
        pStubMsg->BufferStart = pPipeDesc->DispatchBuffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pPipeDesc->DispatchBufferLength;
        }
}


void  RPC_ENTRY
NdrPipeSendReceive(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_PIPE_DESC  *      pPipeDesc
    )
/*+
    Complete send-receive routine for client pipes.
    It takes over with a buffer filled with non-pipe args,
    sends [in] pipes, receives [out] pipes and then receives
    the buffer with non-pipe args.
+*/
{
    int                 CurrentPipe;
    NDR_PIPE_MESSAGE *  pPipeMsg;
    RPC_STATUS          Status;

    // Service the in pipes

    if ( pPipeDesc->InPipes )
        {
        // Once we know we have an [in] pipe, we can send the non-pipe
        // arguments via a partial I_RpcSend.
        // It is OK to call that with the BufferLength equal zero.

        NdrPartialSend( pPipeDesc, pStubMsg );


        for ( CurrentPipe = 0; CurrentPipe < pPipeDesc->TotalPipes; CurrentPipe++ )
            {
            long    LastChunkSent;

            pPipeMsg = & pPipeDesc->pPipeMsg[ CurrentPipe ];

            if ( ! (pPipeMsg->PipeFlags & NDR_IN_PIPE) )
                continue;

            pPipeDesc->CurrentPipe = (short) CurrentPipe;
            pPipeMsg->PipeStatus   = (ushort) NDR_PIPE_ACTIVE_IN;

            Status = NdrpPushPipeForClient( pStubMsg,
                                           pPipeDesc,
                                           TRUE,   // whole pipe
                                           &LastChunkSent );

            // The call above would raise an exception for any case other than
            // dcom async pipe case. This covers sync usage of this code path.
            // So, if we are here, the call succeeded, the status should be ok
            // and last chunk zero, as we requested to push the whole pipe.

            NDR_ASSERT( Status == RPC_S_OK  &&  LastChunkSent == 0,
                        "should process all or raise exception" );

            pPipeMsg->PipeStatus = NDR_PIPE_DRAINED;

            } // for [in] pipes
        }

    NdrCompleteSend( pPipeDesc, pStubMsg );

    // The above call uses I_RpcSend and requires that I_RpcReceive is called
    // later. This has to be done regardless whether any data is expected
    // in the buffer or not.
    // The receive call is complete or partial depending on the context.

    if ( pPipeDesc->OutPipes == 0 )
        {
        // After send we would still have the [in] buffer around so we
        // need to clear the extra flag to avoid appending.

        pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_EXTRA;

        NdrReceive( pPipeDesc,
                    pStubMsg,
                    0,         // size, ignored for complete calls
                    FALSE );   // complete buffer
        return;
        }

    // Service the out pipes
    // Partial calls always clear up the extra flag before calling runtime.

    NdrPartialReceive( pPipeDesc,
                       pStubMsg,
                       PIPE_PARTIAL_BUFFER_SIZE );

    // The buffer has some pipe elemements

    pPipeDesc->BufferSave = pStubMsg->Buffer;
    pPipeDesc->LengthSave = pStubMsg->RpcMsg->BufferLength;

    for ( CurrentPipe = 0; CurrentPipe < pPipeDesc->TotalPipes; CurrentPipe++ )
        {
        long    LastChunk;
        BOOL    EndOfPipe;

        pPipeMsg = & pPipeDesc->pPipeMsg[ CurrentPipe ];

        if ( ! (pPipeMsg->PipeFlags & NDR_OUT_PIPE) )
            continue;

        pPipeDesc->CurrentPipe = (short) CurrentPipe;
        pPipeMsg->PipeStatus   = NDR_PIPE_ACTIVE_OUT;

        Status = NdrpPullPipeForClient( pStubMsg,
                                        pPipeDesc,
                                        TRUE,   // whole pipe
                                        & LastChunk,
                                        & EndOfPipe );

        NDR_ASSERT( Status == RPC_S_OK  &&  EndOfPipe,
                    "should process all or raise exception" );

        pPipeMsg->PipeStatus = NDR_PIPE_DRAINED;

        } // for [out] pipes

    // After all the partial receives, have the last one that is complete.

    if ( ! (pStubMsg->RpcMsg->RpcFlags & RPC_BUFFER_COMPLETE) )
        {
        // On the last call at client we need the extra flag as some
        // non-pipe data may have already been received.

        pStubMsg->RpcMsg->RpcFlags |= RPC_BUFFER_EXTRA;

        NdrReceive( pPipeDesc,
                    pStubMsg,
                    0,         // size, ignored for complete calls
                    FALSE );   // complete buffer
        }
}


RPC_STATUS
NdrpPushPipeForClient(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC   *   pPipeDesc,
    BOOL                fWholePipe,
    long            *   pLastChunkSent )
{
    PFORMAT_STRING  pElemFormat;
    ulong           ElemAlign, ElemMemSize, ElemWireSize, ElemPad;
    ulong           PipeAllocSize, CopySize;
    BOOL            fBlockCopy;
    RPC_STATUS      Status = RPC_S_OK;

    NDR_PIPE_LOG(PIPE_LOG_NOISE, ("NdrpPushPipeForClient: pStubMsg->Buffer %p", pStubMsg->Buffer) );

    RpcTryExcept
        {
        NDR_PIPE_MESSAGE * pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];

        // Service an in pipe.

        GENERIC_PIPE_TYPE * pPipeType = pPipeMsg->pPipeObject;
        
        pPipeDesc->pPipeHelper->InitPipeStateWithType( pPipeMsg );

        ElemAlign    = pPipeDesc->RuntimeState.ElemAlign;
        ElemMemSize  = pPipeDesc->RuntimeState.ElemMemSize;
        ElemWireSize = pPipeDesc->RuntimeState.ElemWireSize;
        ElemPad      = pPipeDesc->RuntimeState.ElemPad;
        fBlockCopy   = pPipeDesc->RuntimeState.fBlockCopy;

        if ( PIPE_PARTIAL_BUFFER_SIZE < ElemMemSize )
            PipeAllocSize = ElemMemSize;
        else
            PipeAllocSize = PIPE_PARTIAL_BUFFER_SIZE;

        uchar *             pMemory;
        unsigned long       bcChunkSize;
        unsigned long       ActElems, ReqElems;

        NDR_HR_PIPE_PULL_RTN    pfnPull  = pPipeType->pfnPull;
        NDR_HR_PIPE_ALLOC_RTN   pfnAlloc = pPipeType->pfnAlloc;
        void                  * pThis    = pPipeType->pState;

        do
            {
            HRESULT Hr;

            // Get memory for the pipe elements

            Hr = (*pfnAlloc)( (char *)pThis,
                              PipeAllocSize,
                              (void **) & pMemory,
                              & bcChunkSize );

            if ( pMemory == 0 )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_APP_MEMORY );

            // Get the pipe elements to the buffer.

            ActElems = bcChunkSize / ElemMemSize;
            ReqElems = ActElems;

            if ( ActElems == 0 )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_INVALID_BUFFER );

            Hr = (*pfnPull)( (char *)pThis,
                             pMemory,
                             ActElems,
                             & ActElems );

            NDR_PIPE_LOG( PIPE_LOG_NOISE, ("NdrpPushPipeForClient: pfnPull returned %d ActElems", ActElems) );

            if ( ReqElems < ActElems )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_INVALID_BUFFER );

            //
            // Size the chunk and get the marshaling buffer
            //

            pStubMsg->BufferLength = pPipeDesc->LastPartialSize;

            pPipeDesc->pPipeHelper->BufferSizeChunkCounter( pPipeMsg );
            
            CopySize = ( ActElems - 1) * (ElemWireSize + ElemPad)
                          + ElemWireSize;

            if ( ActElems )
                {
                LENGTH_ALIGN( pStubMsg->BufferLength, ElemAlign );

                if ( fBlockCopy )
                    pStubMsg->BufferLength += CopySize;
                else
                    {
                    NdrpPipeElementBufferSize( pPipeDesc,
                                               pStubMsg,
                                               pMemory,
                                               ActElems );
                    }
                }

            pPipeDesc->pPipeHelper->BufferSizeChunkTailCounter( pPipeMsg );

            // Get the new buffer, put the frame leftover in it.

            NdrGetPartialBuffer( pStubMsg );

            //
            // Marshal the chunk
            //

            pPipeDesc->pPipeHelper->MarshallChunkCounter( pPipeMsg,
                                                          ActElems );

            NDR_PIPE_LOG( PIPE_LOG_NOISE, ( "Writting pipe chunk: %d", ActElems ) );

            if ( ActElems )
                {
                ALIGN( pStubMsg->Buffer, ElemAlign );

                if ( fBlockCopy )
                    {
                    RpcpMemoryCopy( pStubMsg->Buffer,
                                    pMemory,
                                    CopySize );
                    pStubMsg->Buffer += CopySize;
                    }
                else
                    {
                    // Again: only complex is possible

                    pPipeDesc->pPipeHelper->MarshallType( pPipeMsg,
                                                          pMemory,
                                                          ActElems );
                    pMemory += ActElems * ElemMemSize;
                    
                    }
                }

            pPipeDesc->pPipeHelper->MarshallChunkTailCounter( pPipeMsg, 
                                                              ActElems );

            // Send it if it is not the last partial send.

            if ( !(pPipeMsg->PipeFlags & NDR_LAST_IN_PIPE)  ||
                 ((pPipeMsg->PipeFlags & NDR_LAST_IN_PIPE)  &&  ActElems)
               )
                NdrPartialSend( pPipeDesc, pStubMsg );

            }
        while( fWholePipe  &&  ActElems > 0 );

        *pLastChunkSent = ActElems;

        NDR_PIPE_LOG( PIPE_LOG_NOISE, ("NdrpPushPipeForClient: exit *pLastChunkSent", *pLastChunkSent ) );

        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();

        NdrpRaisePipeException( pPipeDesc,  Status );
        }
    RpcEndExcept

    return Status;
}


RPC_STATUS
NdrpPullPipeForClient(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_PIPE_DESC   *   pPipeDesc,
    BOOL                fWholePipe,
    long            *   pActElems,
    BOOL            *   pEndOfPipe )
{
    PFORMAT_STRING  pElemFormat;
    ulong           ElemAlign, ElemMemSize, ElemWireSize, ElemPad;
    BOOL            fBlockCopy;
    long            ActElems;
    RPC_STATUS      Status = RPC_S_OK;

    RpcTryExcept
        {
        NDR_PIPE_MESSAGE * pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];

        // Service an out pipe

        pPipeDesc->pPipeHelper->InitPipeStateWithType( pPipeMsg );
        pPipeDesc->RuntimeState.EndOfPipe = 0;

        ElemAlign    = pPipeDesc->RuntimeState.ElemAlign;
        ElemMemSize  = pPipeDesc->RuntimeState.ElemMemSize;
        ElemWireSize = pPipeDesc->RuntimeState.ElemWireSize;
        ElemPad      = pPipeDesc->RuntimeState.ElemPad;
        fBlockCopy   = pPipeDesc->RuntimeState.fBlockCopy;

        GENERIC_PIPE_TYPE  *    pPipeType = pPipeMsg->pPipeObject;

        NDR_HR_PIPE_PUSH_RTN    pfnPush  = pPipeType->pfnPush;
        NDR_HR_PIPE_ALLOC_RTN   pfnAlloc = pPipeType->pfnAlloc;
        void                  * pThis    = pPipeType->pState;

        BOOL                    EndOfPipe;

        // RequestedSize estimates a reasonable size for pfnAlloc call.

        HRESULT     Hr;
        ulong       RequestedSize;
        uchar     * pMemory;

        if (ElemWireSize< PIPE_PARTIAL_BUFFER_SIZE)
            RequestedSize = (PIPE_PARTIAL_BUFFER_SIZE / ElemWireSize)
                                 * ElemMemSize;
        else
            RequestedSize = 2 * ElemMemSize;

        do
            {
            unsigned long   bcChunkSize;

            // Get a chunk of memory for pipe elements to push

            Hr = (*pfnAlloc)( (char *)pThis,
                              RequestedSize,
                              (void **) & pMemory,
                              & bcChunkSize );

            if ( pMemory == 0 )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_APP_MEMORY );

            ActElems = bcChunkSize / ElemMemSize;

            if ( ActElems == 0 )
                NdrpRaisePipeException( pPipeDesc,  RPC_X_INVALID_BUFFER );

            EndOfPipe = NdrReadPipeElements( pPipeDesc,
                                             pStubMsg,
                                             pMemory,
                                             & ActElems );

            Hr = (*pfnPush)( (char *)pThis,
                             pMemory,
                             ActElems );
            }
        while ( fWholePipe  &&  ActElems  &&  ! EndOfPipe );

        if ( ActElems )
            {
            Hr = (*pfnPush)( (char *)pThis,
                             pMemory + ActElems * ElemMemSize,
                             0 );
            }

        *pActElems = ActElems;
        *pEndOfPipe = EndOfPipe;
        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();

        NdrpRaisePipeException( pPipeDesc,  Status );
        }
    RpcEndExcept

    return Status;
}


void
NdrMarkNextActivePipe(
    NDR_PIPE_DESC  *  pPipeDesc )
/*

Description:

    This routine is used on the server side sync calls, or on both side of async
    calls to manage the proper sequence of pipes to service.

Note:

    When the last possible pipe is done, this routine restores the
    original dispatch buffer to the rpc message.

*/
{
    unsigned long   Mask;
    int             NextPipe    = 0;
    int             CurrentPipe = pPipeDesc->CurrentPipe;

    if ( CurrentPipe == -1 )
        {
        // This means an initial call at any side.
        // Find the first in pipe, or if none, find first out pipe.

        Mask = pPipeDesc->InPipes ?  NDR_IN_PIPE
                                  :  NDR_OUT_PIPE;
        }
    else
        {
        // Switching from one active pipe to another.

        NDR_PIPE_MESSAGE *  pPipeMsg;
        unsigned short      LastPipeStatus;

        pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];

        LastPipeStatus       = pPipeMsg->PipeStatus;
        pPipeMsg->PipeStatus = NDR_PIPE_DRAINED;

        // Mark no active pipe.

        pPipeDesc->PrevPipe    = pPipeDesc->CurrentPipe;
        pPipeDesc->CurrentPipe = -1;

        // See if the drained pipe was the last possible pipe.

        if ( (LastPipeStatus == NDR_PIPE_ACTIVE_OUT)  &&
             (pPipeMsg->PipeFlags  &  NDR_LAST_OUT_PIPE) )
            {
            return;
            }

        // See if the drained pipe was the last in pipe.
        // Set how to look for the next active pipe.

        if ( (LastPipeStatus == NDR_PIPE_ACTIVE_IN)  &&
             (pPipeMsg->PipeFlags  &  NDR_LAST_IN_PIPE) )
            {
            ResetToDispatchBuffer( pPipeDesc, pPipeMsg->pStubMsg );

            if (pPipeDesc->OutPipes == 0)
                return;

            // Change direction after the last in pipe.
            // The search will be from the beginning.

            Mask = NDR_OUT_PIPE;
            }
        else
            {
            // Same direction, start the search with the next pipe.

            NextPipe = CurrentPipe + 1;
            Mask = (LastPipeStatus == NDR_PIPE_ACTIVE_IN) ?  NDR_IN_PIPE
                                                          :  NDR_OUT_PIPE;
            }
        }

    // First fit. We are here only when there is another pipe to service.

    while( NextPipe < pPipeDesc->TotalPipes )
        {
        if ( pPipeDesc->pPipeMsg[NextPipe].PipeFlags  &  Mask )
           {
           pPipeDesc->CurrentPipe = (short) NextPipe;
           if ( Mask == NDR_IN_PIPE )
               {
               pPipeDesc->pPipeMsg[NextPipe].PipeStatus = NDR_PIPE_ACTIVE_IN;
               }
           else
               {
               pPipeDesc->pPipeMsg[NextPipe].PipeStatus = NDR_PIPE_ACTIVE_OUT;
               }

           pPipeDesc->pPipeHelper->InitPipeStateWithType( &pPipeDesc->pPipeMsg[NextPipe] );
           pPipeDesc->RuntimeState.EndOfPipe = 0;
           break;
           }
        NextPipe++;
        }

    // If it is the first out pipe on server, get the buffer.

    PMIDL_STUB_MESSAGE  pStubMsg = pPipeDesc->pPipeMsg[NextPipe].pStubMsg;

    if ( ! pStubMsg->IsClient  &&
         Mask == NDR_OUT_PIPE  &&
         ! pPipeDesc->Flags.AuxOutBufferAllocated )
        {
        NdrGetPipeBuffer( pStubMsg,
                          PIPE_PARTIAL_BUFFER_SIZE,
                          pStubMsg->SavedHandle );

        pPipeDesc->Flags.AuxOutBufferAllocated = 1;
        }

}


void
NdrpVerifyPipe( char  *  pState )
/*
    This routine verifies the context for server application calling
    pull or push emtries of the engine.
*/
{
    NDR_PIPE_MESSAGE *  pPipeMsg = (NDR_PIPE_MESSAGE *) pState;

    if ( ! pPipeMsg           ||
         ! pPipeMsg->pStubMsg ||
         pPipeMsg->Signature != NDR_PIPE_SIGNATURE )
        RpcRaiseException( RPC_X_INVALID_PIPE_OBJECT );

    NDR_PIPE_DESC * pPipeDesc = (NDR_PIPE_DESC *) pPipeMsg->pStubMsg->pContext->pPipeDesc;

    if ( ! pPipeDesc )
        RpcRaiseException( RPC_X_INVALID_PIPE_OBJECT );

    // An exception occured on the pipe call, but the app
    // for some unknown reason is trying to call Rpc again.
    // Just rethrow the exception that the app received the first time.
    if ( 0 != pPipeDesc->PipeException )
        RpcRaiseException( pPipeDesc->PipeException );

   // See if a different pipe is currently active.

   if ( pPipeDesc->CurrentPipe != -1  &&
        & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ] != pPipeMsg )
      NdrpRaisePipeException( pPipeDesc,  RPC_X_WRONG_PIPE_ORDER );

}

void RPC_ENTRY
NdrIsAppDoneWithPipes(
    NDR_PIPE_DESC  *    pPipeDesc
    )
/*
    This routine is called from the engine after the manager code returned
    to the engine to see if all the pipes have been processed.
    It is also called from NdrCompleteAsyncClientCall.
    It is not called from the synchronous client as it is the stub
    that manages the pipe processing for synchronous case.
*/
{
    // It is possible for the server in sync rpc and both side in async rpc
    // to receive an error, ignore it and continue. 
    // To prevent this, rethrow the exception if an exception was hit before.
    
    if ( pPipeDesc->PipeException )
        RpcRaiseException( pPipeDesc->PipeException );
    
    if ( pPipeDesc->CurrentPipe != -1 )
        NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_DISCIPLINE_ERROR );

    for (int i = 0; i < pPipeDesc->TotalPipes; i++ )
        if ( pPipeDesc->pPipeMsg[i].PipeStatus != NDR_PIPE_DRAINED )
            NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_DISCIPLINE_ERROR );
}


void RPC_ENTRY
NdrPipePull(
    char          * pState,
    void          * buf,
    unsigned long   esize,
    unsigned long * ecount )
/*+
    Server side [in] pipe arguments.
-*/
{

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrPipePull: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    buf %p, esize %u", buf, esize ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    ecount %p", ecount ) );

    NdrpVerifyPipe( pState );

    NDR_PIPE_MESSAGE *  pPipeMsg  = (NDR_PIPE_MESSAGE *) pState;
    PMIDL_STUB_MESSAGE  pStubMsg  = pPipeMsg->pStubMsg;
    NDR_PIPE_DESC *     pPipeDesc = (NDR_PIPE_DESC *) pStubMsg->pContext->pPipeDesc;

    if ( pPipeDesc->CurrentPipe == -1  &&
         & pPipeDesc->pPipeMsg[ pPipeDesc->PrevPipe ] == pPipeMsg )
        {
        // An attempt to read from the pipe that was the last one used.

        NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_EMPTY );
        }

    // Pulling in pipe on async raw client, out pipe on any server

    if ( pPipeMsg->PipeStatus == NDR_PIPE_ACTIVE_IN  &&  pStubMsg->IsClient  ||
         pPipeMsg->PipeStatus == NDR_PIPE_ACTIVE_OUT && !pStubMsg->IsClient )
        NdrpRaisePipeException( pPipeDesc,  RPC_X_WRONG_PIPE_ORDER );

    if ( esize == 0 )
        NdrpRaisePipeException( pPipeDesc,  RPC_S_INVALID_ARG );

    long  ElemCount = (long) esize;

    *ecount = 0;
    if ( pPipeDesc->RuntimeState.EndOfPipe )
        {
        NdrMarkNextActivePipe( pPipeDesc );
        return;
        }

    uchar * pMemory   = (uchar*) buf;
    BOOL    EndOfPipe;

    EndOfPipe = NdrReadPipeElements( pPipeDesc,
                                     pStubMsg,
                                     pMemory,
                                     & ElemCount );

    NDR_ASSERT( ElemCount <= (long)esize, "read more than asked for" );

    *ecount = ElemCount;

    if ( EndOfPipe  &&  ElemCount == 0 )
        NdrMarkNextActivePipe( pPipeDesc );
}


void  RPC_ENTRY
NdrPipePush(
    char          * pState,
    void          * buf,
    unsigned long   ecount )
/*+
    Server side [out] pipe arguments.
-*/
{
    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrPipePush: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    Buf %p, ecount %u", buf, ecount ) );

    NdrpVerifyPipe( pState );

    NDR_PIPE_MESSAGE *  pPipeMsg  = (NDR_PIPE_MESSAGE *) pState;
    PMIDL_STUB_MESSAGE  pStubMsg  = pPipeMsg->pStubMsg;
    NDR_PIPE_DESC *     pPipeDesc = (NDR_PIPE_DESC *) pStubMsg->pContext->pPipeDesc;
   
    if ( pPipeDesc->CurrentPipe == -1  &&
         & pPipeDesc->pPipeMsg[ pPipeDesc->PrevPipe ] == pPipeMsg )
        {
        // An attempt to write the pipe that was the last one used.

        NdrpRaisePipeException( pPipeDesc,  RPC_X_PIPE_CLOSED );
        }

    // Pushing out pipe on async raw client, in pipe on any server

    if ( pPipeMsg->PipeStatus == NDR_PIPE_ACTIVE_OUT &&  pStubMsg->IsClient  ||
         pPipeMsg->PipeStatus == NDR_PIPE_ACTIVE_IN  && !pStubMsg->IsClient )
        NdrpRaisePipeException( pPipeDesc,  RPC_X_WRONG_PIPE_ORDER );

    ulong   ElemAlign    = pPipeDesc->RuntimeState.ElemAlign;
    ulong   ElemMemSize  = pPipeDesc->RuntimeState.ElemMemSize;
    ulong   ElemWireSize = pPipeDesc->RuntimeState.ElemWireSize;
    ulong   ElemPad      = pPipeDesc->RuntimeState.ElemPad;
    BOOL    fBlockCopy   = pPipeDesc->RuntimeState.fBlockCopy;

    // Size the chunk and get the marshaling buffer
    //

    pStubMsg->BufferLength = pPipeDesc->LastPartialSize;

    pPipeDesc->pPipeHelper->BufferSizeChunkCounter( pPipeMsg );

    ulong  CopySize = ( ecount - 1) * (ElemWireSize + ElemPad)
                                                    + ElemWireSize;
    uchar * pMemory   = (uchar*) buf;

    if ( ecount )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, ElemAlign );

        if ( fBlockCopy )
            pStubMsg->BufferLength += CopySize;
        else
            {
            NdrpPipeElementBufferSize( pPipeDesc,
                                       pStubMsg,
                                       pMemory,
                                       ecount );
            }
        }


    pPipeDesc->pPipeHelper->BufferSizeChunkTailCounter( pPipeMsg );

    // Get the new buffer, put the frame leftover in it.

    NdrGetPartialBuffer( pStubMsg );

    // Marshal the chunk

    pPipeDesc->pPipeHelper->MarshallChunkCounter( pPipeMsg, ecount );

    if ( ecount )
        {
        ALIGN( pStubMsg->Buffer, ElemAlign );

        if ( fBlockCopy )
           {
           RpcpMemoryCopy( pStubMsg->Buffer,
                           pMemory,
                           CopySize );
           pStubMsg->Buffer += CopySize;
           }
        else
           {
           // Again: only complex is possible

           pPipeDesc->pPipeHelper->MarshallType( pPipeMsg,
                                                 pMemory,
                                                 ecount );
           pMemory += ElemMemSize * ecount;
           
           }
       }

    pPipeDesc->pPipeHelper->MarshallChunkTailCounter( pPipeMsg, ecount );

    // If it is not the last terminator, use a partial send.
    // On client (async only) the last send should be complete,
    // On server (sync or async) the complete send will happen after marshaling
    // non-pipe out data.
    // Channel requires the last call on server.

    if ( pStubMsg->IsClient )
        {
        if ( ecount == 0  &&  (pPipeMsg->PipeFlags & NDR_LAST_IN_PIPE))
            NdrCompleteSend( pPipeDesc, pStubMsg );
        else
            NdrPartialSend( pPipeDesc, pStubMsg );
        }
    else
        NdrPartialSend( pPipeDesc, pStubMsg );

    if ( ecount == 0 )
        NdrMarkNextActivePipe( pPipeDesc );
}


void  RPC_ENTRY
NdrPipeAlloc(
    char          * pState,
    unsigned long   bsize,
    void          **buf,
    unsigned long * bcount )
/*
    This method has been introduced to support pipe chaining - when
    a server becomes a client and passes a pipe argument along.
    Only one buffer is ever there: next call releases the previous one.
*/
{

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrPipeAlloc: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    bsize %d, buf %p", bsize, buf ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    bcount %p", bcount ) );

    NdrpVerifyPipe( pState );

    NDR_PIPE_MESSAGE *  pPipeMsg  = (NDR_PIPE_MESSAGE *) pState;
    PMIDL_STUB_MESSAGE  pStubMsg  = pPipeMsg->pStubMsg;
    NDR_PIPE_DESC *     pPipeDesc = (NDR_PIPE_DESC *) pStubMsg->pContext->pPipeDesc;

    if ( pPipeDesc->ChainingBuffer )
        {
        if ( pPipeDesc->ChainingBufferSize >= bsize )
            {
            *bcount = pPipeDesc->ChainingBufferSize;
            *buf    = pPipeDesc->ChainingBuffer;
            return;
            }
        else
            {
            NdrpPrivateFree( pPipeDesc->pAllocContext, pPipeDesc->ChainingBuffer );
            pPipeDesc->ChainingBuffer = NULL;
            pPipeDesc->ChainingBufferSize = 0;
            }
        }

    RpcTryExcept
        {
        pPipeDesc->ChainingBuffer = NdrpPrivateAllocate( pPipeDesc->pAllocContext, bsize );
        }
    RpcExcept( RpcExceptionCode() == RPC_S_OUT_OF_MEMORY )
        {
        NdrpRaisePipeException( pPipeDesc,  RPC_S_OUT_OF_MEMORY );
        }
    RpcEndExcept

    *bcount = bsize;
    *buf = pPipeDesc->ChainingBuffer;
}


void
NdrpAsyncHandlePipeError(
    char      * pState,
    RPC_STATUS  Status )
/*++
Routine Description :

    Forces the connect to close by either freeing the buffer
    or aborting the call on an async pipe error.

Arguments :

    pState  - Supplies the pipe state.
    Statue  - Supplies the error code.

Return :

    None.

--*/

{
    
   NDR_PIPE_MESSAGE    *pPipeMsg;
   MIDL_STUB_MESSAGE   *pStubMsg;
   PNDR_ASYNC_MESSAGE  pAsyncMsg;

   // Pending isn't really an error.
   if ( RPC_S_ASYNC_CALL_PENDING == Status )
      return;

   if ( !pState )
      {
      return;
      }

   pPipeMsg = (NDR_PIPE_MESSAGE *)pState;

   if ( ! pPipeMsg->pStubMsg ||
        pPipeMsg->Signature != NDR_PIPE_SIGNATURE )
      return;

   pStubMsg = pPipeMsg->pStubMsg;
   
   if ( !pStubMsg->pAsyncMsg )
      {
      return;
      }

   pAsyncMsg = pStubMsg->pAsyncMsg;

   RpcTryExcept
      {
      if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
         {
            if ( pStubMsg->IsClient )
               {
               NdrFreeBuffer( pStubMsg );      
               }
            else 
               {
               I_RpcAsyncAbortCall( pAsyncMsg->AsyncHandle, Status);
               }
         }
      }
   RpcExcept(! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
      {
      // Ignore and exceptions that occured
      }
   RpcEndExcept
   pAsyncMsg->Flags.RuntimeCleanedUp = 1;

}



RPC_STATUS RPC_ENTRY
NdrAsyncPipePull(
    char          * pState,
    void          * buf,
    unsigned long   esize,
    unsigned long * ecount )
{
    RPC_STATUS Status = RPC_S_OK;

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrAsyncPipePull: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    buf %p, esize %u", buf, esize ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    ecount %u", ecount ) );

    RpcTryExcept
        {
        NdrPipePull( pState, buf, esize, ecount );
        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();
        NdrpAsyncHandlePipeError( pState, Status );
        }
    RpcEndExcept

    return Status;
}

RPC_STATUS  RPC_ENTRY
NdrAsyncPipePush(
    char          * pState,
    void          * buf,
    unsigned long   ecount )
{
    RPC_STATUS Status = RPC_S_OK;

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrAsyncPipePush: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    buf %p, count %u", buf, ecount ) );

    RpcTryExcept
        {
        NdrPipePush( pState, buf, ecount );
        }
    RpcExcept( ! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
        {
        Status = RpcExceptionCode();
        NdrpAsyncHandlePipeError( pState, Status );
        }
    RpcEndExcept

    return Status;
}

RPC_STATUS  RPC_ENTRY
NdrAsyncPipeAlloc(
    char          * pState,
    unsigned long   bsize,
    void          **buf,
    unsigned long * bcount )
/*
*/
{
    RPC_STATUS Status = RPC_S_OK;

    NDR_PIPE_LOG( PIPE_LOG_API, ( "NdrAsyncPipeAlloc: pState %p", pState ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    bsize %u, buf %p", bsize, buf ) );
    NDR_PIPE_LOG( PIPE_LOG_API, ( "    bcount %p", bcount ) );

    RpcTryExcept
        {
        NdrPipeAlloc( pState, bsize, buf, bcount );
        }
    RpcExcept( RpcExceptionCode() == RPC_S_OUT_OF_MEMORY )
        {
        Status = RpcExceptionCode();
        NdrpAsyncHandlePipeError( pState, Status );
        }
    RpcEndExcept

    return Status;
}



void
NdrpPipeElementBufferSize(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    ulong               ElemCount
    )
/*++

Routine Description :

    Computes the needed buffer size for the pipe elements.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{

    if ( ElemCount == 0 )
        return;

    // We can end up here only for complex objects.
    // For objects without unions, we may be forced to size because
    // of different packing levels.

    if ( pPipeDesc->RuntimeState.ElemWireSize )
        {
        // There is a fixed WireSize, so use it.

        ulong WireSize = pPipeDesc->RuntimeState.ElemWireSize;
        ulong WireAlign = pPipeDesc->RuntimeState.ElemAlign;

        pStubMsg->BufferLength +=
              (ElemCount -1) * (WireSize + WIRE_PAD( WireSize, WireAlign )) +
                                  WireSize;
        }
    else
        {
        NDR_PIPE_MESSAGE * pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];

        pPipeDesc->pPipeHelper->BufferSizeType(  pPipeMsg,
                                                 pMemory,
                                                 ElemCount );
        }
}


void
NdrpPipeElementConvertAndUnmarshal(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar * *           ppMemory,
    long                ActElems,
    long  *             pActCount
    )
/*++

Routine Description :

    Computes the needed buffer size for the pipe elements.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    NDR_PIPE_STATE *    state    = & pPipeDesc->RuntimeState;
    NDR_PIPE_MESSAGE *  pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];
    uchar *             pMemory  = *ppMemory;

    ulong   ElemWireSize = state->ElemWireSize;
    ulong   ElemPad      = state->ElemPad;
    BOOL    fBlockCopy   = state->fBlockCopy;

    NDR_PIPE_LOG( PIPE_LOG_NOISE, ( " NdrpPipeElementConvertAndUnmarshal: ActElems %d", ActElems ) );
    NDR_PIPE_LOG( PIPE_LOG_NOISE, ("    pStubMsg->Buffer %p, pMemory %p", pStubMsg->Buffer, pMemory ) );

    if ( ActElems )
        {
        pPipeDesc->pPipeHelper->ConvertType( pPipeMsg,
                                             ActElems );


        // Unmarshal the chunk

        ALIGN( pStubMsg->Buffer, state->ElemAlign );

        if ( fBlockCopy )
            {
            ulong  CopySize  = ( ActElems - 1) * (ElemWireSize + ElemPad)
                                               + ElemWireSize;
            RpcpMemoryCopy( pMemory,
                            pStubMsg->Buffer,
                            CopySize );
            pStubMsg->Buffer += CopySize;
            }
        else
            {
            // Only complex and enum is possible here.

            pPipeDesc->pPipeHelper->UnmarshallType( pPipeMsg,
                                                    pMemory,
                                                    ActElems );
            pMemory += state->ElemMemSize;
            
            }

        *ppMemory += state->ElemMemSize * ActElems;
        }

    *pActCount += ActElems;
}



BOOL
NdrReadPipeElements(
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char *     pTargetBuffer,
    long *              pElementsRead
    )
/*
    This procedure encapsulates reading pipe elements from the RPC runtime.

*/
{
    NDR_PIPE_STATE * pRuntimeState = & pPipeDesc->RuntimeState;
    ulong            ElemWireSize  = pRuntimeState->ElemWireSize;

    // Get the temporary buffers

    if ( ( pRuntimeState->PartialBufferSize / ElemWireSize ) == 0 )
        {
        // buffer too small.
        // We preallocate a buffer that is of an arbitrary big size.
        // If the element is even bigger, we allocate a buffer big
        // enough for one element.

        if ( pRuntimeState->PartialElem )
            NdrpPrivateFree( pPipeDesc->pAllocContext, pRuntimeState->PartialElem );

        if ( PIPE_PARTIAL_BUFFER_SIZE < ElemWireSize )
            pRuntimeState->PartialBufferSize = ElemWireSize;
        else
            pRuntimeState->PartialBufferSize = PIPE_PARTIAL_BUFFER_SIZE;

        // We allocate more for alignment padding.

        RpcTryExcept
            {
            pRuntimeState->PartialElem =  (uchar *)
                NdrpPrivateAllocate( pPipeDesc->pAllocContext, 
                                     pRuntimeState->PartialBufferSize + 8);
            }
        RpcExcept(! (RPC_BAD_STUB_DATA_EXCEPTION_FILTER) )
            {
            if ( ! pRuntimeState->PartialElem )
                NdrpRaisePipeException( pPipeDesc,  RPC_S_OUT_OF_MEMORY );             
            }
        RpcEndExcept

        }

    long ElemsToRead = *pElementsRead;
    long LeftToRead  = *pElementsRead;
    long ElemsRead   = 0;

    *pElementsRead = 0;

    // New semantics - unmarshal only what we have at hand, don't call
    // for the next buffer unless it would mean giving back 0 elems.

    while ( ( LeftToRead > 0  &&  ! pPipeDesc->RuntimeState.EndOfPipe ) ||
            pPipeDesc->RuntimeState.EndOfPipePending )
        {
        // See if there is a buffer to process first

        if ( ! pPipeDesc->Flags.NoBufferCallPending )
            {
            // Read elements from the marshaling buffer (the StubMsg->Buffer)
            // to the user's target buffer (converted and unmarshaled).
            // ElemsRead would be cumulative across the calls when looping.

            NdrpReadPipeElementsFromBuffer( pPipeDesc,
                                            pStubMsg,
                                            & pTargetBuffer,
                                            LeftToRead,
                                            & ElemsRead );
            }

        LeftToRead = ElemsToRead - ElemsRead;

        if ( ( LeftToRead > 0   &&  ! pPipeDesc->RuntimeState.EndOfPipe ) ||
             pPipeDesc->RuntimeState.EndOfPipePending  )
            {
            // We ran out of data in the current buffer.
            // Check if we unmarshaled some elems already - if so, don't read.

            if ( ElemsRead == 0 )
                {
                pPipeDesc->Flags.NoBufferCallPending = 1;

                NdrPartialReceive( pPipeDesc,
                                   pStubMsg,
                                   pRuntimeState->PartialBufferSize );

                pPipeDesc->Flags.NoBufferCallPending = 0;
                continue;
                }
            }

        break;
        }

    *pElementsRead = ElemsRead;
    return  pPipeDesc->RuntimeState.EndOfPipe;
}


void NdrpReadPipeElementsFromBuffer (
    NDR_PIPE_DESC  *    pPipeDesc,
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            pTargetBuffer,
    long                ElemsToRead,
    long *              NumCopied
    )
{
    NDR_PIPE_STATE *    state   = & pPipeDesc->RuntimeState;
    NDR_PIPE_MESSAGE * pPipeMsg = & pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe ];
    BOOL fHasChunkTailCounter   = pPipeDesc->pPipeHelper->HasChunkTailCounter();

    long                len;
    uchar *             BufferSave;

    NDR_ASSERT( state->CurrentState == START ||
                state->PartialElemSize  < state->ElemWireSize,
                "when starting to read pipe elements" );

    NDR_PIPE_LOG( PIPE_LOG_NOISE, ( "NdrpReadPipeElementsFromBuffer: ElemsToRead %x", ElemsToRead ) );
    NDR_PIPE_LOG( PIPE_LOG_NOISE, ( "    pStubMsg->Buffer %p", pStubMsg->Buffer ) );

    if ( ( ElemsToRead == 0 ) &&
         ( !state->EndOfPipePending ) )
        {
        return ;
        }

    while (1)
        {
        switch( state->CurrentState )
            {
            case  START:

                NDR_PIPE_LOG( PIPE_LOG_NOISE, ( " START: pStubMgs->Buffer %p", pStubMsg->Buffer ) );

                ASSERT(pStubMsg->Buffer >= pStubMsg->RpcMsg->Buffer);
                ASSERT(pStubMsg->Buffer - pStubMsg->RpcMsg->BufferLength <= pStubMsg->RpcMsg->Buffer);

                // The state to read the chunk counter.

                state->PartialElemSize = 0 ;

                // Read the element count.
                {
                    ulong ElemsInChunk;
                    if ( !pPipeDesc->pPipeHelper->UnmarshallChunkCounter( pPipeMsg, 
                                                                          &ElemsInChunk ) )
                    return;
                 
                    state->ElemsInChunk = state->OrigElemsInChunk = ElemsInChunk;
                }
                
                NDR_PIPE_LOG( PIPE_LOG_NOISE, ("Read pipe chuck: %d", state->ElemsInChunk ) );

                if (state->ElemsInChunk == 0)
                    {
                    
                    if ( fHasChunkTailCounter )
                        {
                        state->EndOfPipePending = 1;
                        state->CurrentState = VERIFY_TAIL_CHUNK;

                        NDR_PIPE_LOG( PIPE_LOG_NOISE, ("Waiting for duplicate 0...") );
                        }
                    else
                        {
                        state->EndOfPipe = 1;                        
                        return;
                        }
                    
                    }
                else
                    {
                    if ( state->LowChunkLimit > state->ElemsInChunk  ||
                         state->HighChunkLimit < state->ElemsInChunk )
                        NdrpRaisePipeException( pPipeDesc,  RPC_X_INVALID_BOUND );

                    state->CurrentState = COPY_PIPE_ELEM;
                    }
                break;

            case  COPY_PIPE_ELEM:

                NDR_PIPE_LOG( PIPE_LOG_NOISE, (" COPY_PIPE_ELEM: state->ElemsInChunk %d", state->ElemsInChunk ) );
                NDR_PIPE_LOG( PIPE_LOG_NOISE, ("     pStubMsg->Buffer %p, ElemsToRead %d", pStubMsg->Buffer, ElemsToRead ) );
                
                // The state with some elements in the current chunk left.
                // The elements may not be in the current buffer, though.

                NDR_ASSERT( state->ElemsInChunk != 0xbaadf00d, "bogus chunk count" );
                NDR_ASSERT( state->ElemsInChunk, "empty chunk!" );

                ALIGN( pStubMsg->Buffer, state->ElemAlign );

                if ( state->ElemWireSize <= REMAINING_BYTES() )
                    {
                    // There is enough on wire to unmarshal at least one.

                    if ( ElemsToRead )
                        {
                        long ElemsReady, ActCount, EffectiveSize, WirePad;

                        WirePad = WIRE_PAD( state->ElemWireSize, state->ElemAlign );

                        EffectiveSize = state->ElemWireSize + WirePad;

                        ElemsReady = (REMAINING_BYTES() + WirePad) /
                                                            EffectiveSize;
                        if ( ElemsReady > state->ElemsInChunk )
                            ElemsReady = state->ElemsInChunk;
                        if ( ElemsReady > ElemsToRead )
                            ElemsReady = ElemsToRead;

                        ActCount   = 0;
                        NdrpPipeElementConvertAndUnmarshal( pPipeDesc,
                                                            pStubMsg,
                                                            pTargetBuffer,
                                                            ElemsReady,
                                                            & ActCount );

                        ElemsToRead         -= ActCount;
                        state->ElemsInChunk -= ActCount;
                        *NumCopied          += ActCount;

                        if (state->ElemsInChunk == 0)
                            {

                            state->CurrentState =  fHasChunkTailCounter ? 
                                                       VERIFY_TAIL_CHUNK :
                                                       START;

                            if ( ElemsToRead == 0 )
                                return;
                            }
                        }
                    else
                        {
                        // End of target buffer: return the count.
                        // Keep the same state for the next round.

                        return;
                        }
                    }
                else
                    {
                    // Not enough wire bytes to unmarshal element.

                    if ( REMAINING_BYTES() )
                        {
                        NDR_ASSERT( 0 < REMAINING_BYTES(),
                                    "buffer pointer not within the buffer" );

                        state->CurrentState = RETURN_PARTIAL_ELEM;
                        }
                    else
                        {
                        state->PartialElemSize = 0;
                        return;
                        }
                    }
                break;

            case RETURN_PARTIAL_ELEM:

                NDR_PIPE_LOG( PIPE_LOG_NOISE, (" RETURN_PARTIAL_ELEM: state->ElemsInChunk %d", state->ElemsInChunk ) );

                // This happens when there is no whole element left
                // during copying. The chunk has some elements.

                NDR_ASSERT( state->ElemsInChunk, "empty chunk" );

                len = REMAINING_BYTES();

                NDR_ASSERT( 0 < len  &&  len < state->ElemWireSize,
                            "element remnant expected" );

                // Save the remnants of the elem in PartialElem;
                // Pay attention to the alignment of the remnant, though.

                state->PartialOffset   = 0;
                state->PartialElemSize = 0;

                if ( len )
                    {
                    // we need to simulate the original alignment by
                    // means of an offset in the PartialElem buffer.

                    state->PartialOffset = 0x7 & PtrToUlong( pStubMsg->Buffer );

                    RpcpMemoryCopy( state->PartialElem + state->PartialOffset,
                                    pStubMsg->Buffer,
                                    len );
                    pStubMsg->Buffer      += len;
                    state->PartialElemSize = len;
                    }
                state->CurrentState = READ_PARTIAL_ELEM ;
                return;


            case READ_PARTIAL_ELEM:     //also a start state

                NDR_PIPE_LOG( PIPE_LOG_NOISE, (" READ_PARTIAL_ELEM: state->ElemsInChunk %d", state->ElemsInChunk ) );

                NDR_ASSERT( state->PartialElemSize > 0 &&
                            state->PartialElemSize < state->ElemWireSize,
                            "element remnant expected" );

                NDR_ASSERT( ElemsToRead, "no elements to read" );

                len = state->ElemWireSize - state->PartialElemSize;

                if ( len > REMAINING_BYTES() )
                    {
                    // Add another piece to the partial element,
                    // then wait for another round in the same state.

                    RpcpMemoryCopy( state->PartialElem + state->PartialOffset
                                       + state->PartialElemSize,
                                    pStubMsg->Buffer,
                                    REMAINING_BYTES() );
                    pStubMsg->Buffer       += REMAINING_BYTES();
                    state->PartialElemSize += REMAINING_BYTES();

                    return;
                    }

                // Assemble a complete partial element, unmarshal it,
                // then switch to the regular element copying.

                RpcpMemoryCopy( state->PartialElem  + state->PartialOffset
                                   + state->PartialElemSize,
                                pStubMsg->Buffer,
                                len );
                pStubMsg->Buffer       += len;
                state->PartialElemSize  += len;  

                // Assemble a fake STUB_MESSAGE and RPC_MESSAGE so that
                // the buffer looks likes the a regular RPC buffer.
                {
                    // Save modified fields.
                    void          *   RpcBufferSave    = pStubMsg->RpcMsg->Buffer;                   
                    unsigned int      RpcBufferLength  = pStubMsg->RpcMsg->BufferLength;
                    unsigned char *   BufferSave       = pStubMsg->Buffer;
                    unsigned char *   BufferStartSave  = pStubMsg->BufferStart;
                    unsigned char *   BufferEndSave    = pStubMsg->BufferEnd;
                    
                     
                    RpcTryFinally
                        {

                        pStubMsg->RpcMsg->Buffer       = state->PartialElem + state->PartialOffset;
                        pStubMsg->RpcMsg->BufferLength = state->PartialElemSize; 

                        pStubMsg->Buffer      = (unsigned char *)pStubMsg->RpcMsg->Buffer;
                        pStubMsg->BufferStart = pStubMsg->Buffer;
                        pStubMsg->BufferEnd   = pStubMsg->Buffer + pStubMsg->RpcMsg->BufferLength;

                        len = 0;
                        NdrpPipeElementConvertAndUnmarshal( pPipeDesc,
                                                            pStubMsg,
                                                            pTargetBuffer,
                                                            1,
                                                            & len );


                        NDR_ASSERT( len == 1, "partial element count" );
                        ElemsToRead         -= 1;
                        state->ElemsInChunk -= 1;
                        *NumCopied          += 1 ;
                        
        				
                        // reset partial element state.
                        state->PartialOffset    = 0;
                        state->PartialElemSize  = 0;
                        
                        }

                    RpcFinally 
                        {

                        // Switch back to regular elem unmarshaling.
        
                        pStubMsg->RpcMsg->Buffer       = RpcBufferSave;
                        pStubMsg->RpcMsg->BufferLength = RpcBufferLength; 

                        pStubMsg->Buffer      = BufferSave;
                        pStubMsg->BufferStart = BufferStartSave;
                        pStubMsg->BufferEnd   = BufferEndSave;
                        }
                    RpcEndFinally
                }  

                if ( state->ElemsInChunk == 0 )
                    {
                    state->CurrentState =  fHasChunkTailCounter ? 
                           VERIFY_TAIL_CHUNK :
                           START;

                    if ( ElemsToRead == 0 )
                        return;
                    }
                else
                    state->CurrentState = COPY_PIPE_ELEM;

                break;

            case  VERIFY_TAIL_CHUNK:
                
                NDR_PIPE_LOG( PIPE_LOG_NOISE, (" VERIFY_TAIL_CHUNK: state->OrigElemsInChunk %d", state->OrigElemsInChunk ) );
                NDR_PIPE_LOG( PIPE_LOG_NOISE, ("    pStubMsg->Buffer %p", pStubMsg->Buffer ) );

                ASSERT(pStubMsg->Buffer >= pStubMsg->RpcMsg->Buffer);
                ASSERT(pStubMsg->Buffer - pStubMsg->RpcMsg->BufferLength <= pStubMsg->RpcMsg->Buffer);

                // The state to verify the tail chunk counter.

                state->PartialElemSize = 0 ;
                
                if (! pPipeDesc->pPipeHelper->VerifyChunkTailCounter( pPipeMsg,
                                                                      state->OrigElemsInChunk ) )
                    {
                    NDR_PIPE_LOG( PIPE_LOG_NOISE, ( "Not enough buffer for tail chunk counter..Leaving state machine."))
                    return;
                    }

                // Get read for the next chunk.
                state->CurrentState = START;

                if ( state->EndOfPipePending )
                    {
                    state->EndOfPipePending = 0;
                    state->EndOfPipe = 1;
                    return;
                    }
                break;


            default:
                NDR_ASSERT(0, "unknown state") ;
                break;
            }
        }
}

void
NdrpRaisePipeException(
    NDR_PIPE_DESC  *    pPipeDesc,
    RPC_STATUS          Exception )
{
    // Remember the first exception that happened,
    // ignore all the subsequent exceptions by reraising the first one.

    if ( Exception != RPC_S_ASYNC_CALL_PENDING && pPipeDesc )
        {
        
        if ( pPipeDesc->PipeException == 0 )
           
           pPipeDesc->PipeException = Exception;

        RpcRaiseException( pPipeDesc->PipeException );
        
        }
    else
        RpcRaiseException( Exception );
}

//  private API called from runtime to validate the current status of call
// 
RPC_STATUS RPC_ENTRY 
NdrCheckAsyncPipeStatus( 
    IN char *   AsyncHandle,
    OUT long *    pState )
{
    long Mask = 0;

    // This function can be called indirectly from COM via I_RpcSetAsyncHandle.  If that
    // is done, StubInfo will be NULL.  We will just return RPC_X_INVALID_PIPE_OBJECT.
    if ( ((PRPC_ASYNC_STATE)AsyncHandle)->StubInfo == NULL )
        return RPC_X_INVALID_PIPE_OBJECT;

    // There is no need to validate the async handle since
    // this API can only be called from the RPC runtime or COM.

    PNDR_ASYNC_MESSAGE   pAsyncMsg = (PNDR_ASYNC_MESSAGE) ((PRPC_ASYNC_STATE)AsyncHandle)->StubInfo;
    NDR_PROC_CONTEXT   *    pContext       = & pAsyncMsg->ProcContext;
    if ( !pContext->HasPipe  )
        return RPC_X_INVALID_PIPE_OBJECT;

    NDR_PIPE_DESC * pPipeDesc = pContext->pPipeDesc;
    if ( ! pPipeDesc )
        return RPC_X_INVALID_PIPE_OBJECT;

    if ( pPipeDesc->CurrentPipe == -1 )
        {
        // This is the first pipe to be processed. 
        if ( pPipeDesc->PrevPipe == -1 )
            {
            Mask = pPipeDesc->InPipes? NDR_PIPE_ACTIVE_IN: NDR_PIPE_ACTIVE_OUT;
            }
        else
            // we are done with the last pipe
            return RPC_X_INVALID_PIPE_OBJECT;
        }

    // after the first pipe, pipemsg are initialized.
    NDR_PIPE_MESSAGE * pPipeMsg = &pPipeDesc->pPipeMsg[ pPipeDesc->CurrentPipe];
    Mask = pPipeMsg->PipeStatus;

    if ( Mask == NDR_PIPE_DRAINED )
        return RPC_X_INVALID_PIPE_OBJECT;

    *pState = (long) Mask;
    return RPC_S_OK;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\pointerq.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    pointerq.h

Abstract :

    This file contains the routines for pointer queues.
    
Author :

    Mike Zoran  mzoran   Jun 2000.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"

#if !defined(__POINTERQ_H__)
#define  __POINTERQ_H__

template<class T>
class SAVE_CONTEXT
{
    const T OldValue;
    T & LocationToRestore;
public:
    __forceinline SAVE_CONTEXT(T & Location) :
        OldValue( Location ),
        LocationToRestore( Location )
    {}
    __forceinline SAVE_CONTEXT(T & Location, T NewValue) :
        OldValue( Location ),
        LocationToRestore( Location )
    { 
        Location = NewValue;
    }
    __forceinline ~SAVE_CONTEXT()
    {
        LocationToRestore = OldValue;
    }
};

class POINTER_BUFFER_SWAP_CONTEXT
{
    MIDL_STUB_MESSAGE *pStubMsg;
    uchar *pBufferSave;
    const bool DoSwap;
public:
    __forceinline POINTER_BUFFER_SWAP_CONTEXT( MIDL_STUB_MESSAGE *pStubMsgNew ) :
        pStubMsg( pStubMsgNew ),
        DoSwap( pStubMsg->PointerBufferMark != NULL )
    {
       if ( DoSwap )
           {
           pBufferSave = pStubMsg->Buffer;
           pStubMsg->Buffer = pStubMsg->PointerBufferMark;
           pStubMsg->PointerBufferMark = 0;
           }
    }
    __forceinline ~POINTER_BUFFER_SWAP_CONTEXT()
    {
        if ( DoSwap ) 
            {
            pStubMsg->PointerBufferMark = pStubMsg->Buffer;
            pStubMsg->Buffer = pBufferSave;
            }
    }
};

class POINTER_BUFFERLENGTH_SWAP_CONTEXT
{
    MIDL_STUB_MESSAGE *pStubMsg;
    ulong LengthSave;
    const bool DoSwap;
public:
    __forceinline POINTER_BUFFERLENGTH_SWAP_CONTEXT( MIDL_STUB_MESSAGE *pStubMsgNew ) :
        pStubMsg( pStubMsgNew ),
        DoSwap( pStubMsg->PointerBufferMark != NULL )
    {
       if ( DoSwap )
           {
           LengthSave = pStubMsg->BufferLength;
           pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
           pStubMsg->PointerBufferMark = 0;
           }
    }
    __forceinline ~POINTER_BUFFERLENGTH_SWAP_CONTEXT()
    {
        if ( DoSwap ) 
            {
            pStubMsg->PointerBufferMark = (uchar *) UlongToPtr(pStubMsg->BufferLength);
            pStubMsg->BufferLength = LengthSave;
            }
    }
};

class POINTER_MEMSIZE_SWAP_CONTEXT
{
    MIDL_STUB_MESSAGE *pStubMsg;
    ulong MemorySave;
    uchar *pBufferSave;
    const bool DoSwap;
public:
    __forceinline POINTER_MEMSIZE_SWAP_CONTEXT( MIDL_STUB_MESSAGE *pStubMsgNew ) :
        pStubMsg( pStubMsgNew ),
        DoSwap( pStubMsg->PointerBufferMark != 0 )
    {
       if ( DoSwap )
           {
           MemorySave  = pStubMsg->MemorySize;
           pBufferSave = pStubMsg->Buffer;
           pStubMsg->MemorySize = pStubMsg->PointerLength;
           pStubMsg->Buffer     = pStubMsg->PointerBufferMark;
           pStubMsg->PointerBufferMark = 0;
           pStubMsg->PointerLength = 0;
           }
    }
    __forceinline ~POINTER_MEMSIZE_SWAP_CONTEXT()
    {
        if ( DoSwap ) 
            {
            pStubMsg->PointerBufferMark = pStubMsg->Buffer;
            pStubMsg->PointerLength     = pStubMsg->MemorySize;
            pStubMsg->Buffer            = pBufferSave;
            pStubMsg->MemorySize        = MemorySave;
            }
    }
};

class NDR_POINTER_QUEUE;

struct NDR_POINTER_QUEUE_STATE;

class NDR_POINTER_QUEUE_ELEMENT
{
public:
   NDR_POINTER_QUEUE_ELEMENT *pNext;
   
   virtual void Dispatch( MIDL_STUB_MESSAGE *pStubMsg ) = 0;
   
#if defined(DBG)
   virtual void Print() = 0;
#endif

   // All of these elements are allocated from a special memory pool.
   // Define these after NDR_POINTER_QUEUE_STATE is defined.
   
   void * operator new( size_t /*stAllocateBlock */, NDR_POINTER_QUEUE_STATE *pAllocator );
   void operator delete( void *pThis, NDR_POINTER_QUEUE_STATE *pAllocator );
};

class NDR_MRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pBufferMark;
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const Memory;
    const uchar uFlags;

public:

    NDR_MRSHL_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                     uchar * const pBufferMarkNew,
                                     uchar * const pMemoryNew,
                                     const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    unsigned long * const pWireMarkerPtr;
public:
    NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                               PFORMAT_STRING pFormatNew,
                                               unsigned long *pWireMarkerPtrNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew ),
        pWireMarkerPtr( pWireMarkerPtrNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};


class NDR_BUFSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const Memory;
    const uchar uFlags;

public:

    NDR_BUFSIZE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                       uchar * const pMemoryNew,
                                       const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
public:
    NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                 PFORMAT_STRING pFormatNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR_FREE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const Memory;
    const uchar uFlags;

public:

    NDR_FREE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                    uchar * const pMemoryNew,
                                    const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_PFNFREE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
public:
    typedef void (__RPC_API * FREEFUNC)(void *);
private:
    FREEFUNC pfnFree;
    uchar *pMemory;
public:
    NDR_PFNFREE_POINTER_QUEUE_ELEMENT(
        FREEFUNC pfnFreeNew,
        uchar *pMemoryNew) :
        pfnFree(pfnFreeNew),
        pMemory(pMemoryNew)

    {
    }

    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg) {(*pfnFree)(pMemory);}
    virtual void Print() 
        {
        DbgPrint("NDR_PFNFREE_POINTER_QUEUE_ELEMENT\n");
        DbgPrint("pfnFree:                 %p\n", pfnFree );
        DbgPrint("pMemory:                 %p\n", pMemory );
        }
};

class NDR_UNMRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar ** const ppMemory;
    uchar * const pMemory;
    long * const pBufferPointer;
    const PFORMAT_STRING pFormat;
    uchar * const Memory;
    const uchar uFlags;
    const int fInDontFree;
    uchar * const pCorrMemory;
    NDR_ALLOC_ALL_NODES_CONTEXT *const pAllocAllNodesContext;
public:

    NDR_UNMRSHL_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                       uchar **            ppMemoryNew,      
                                       uchar *             pMemoryNew,
                                       long  *             pBufferPointerNew,
                                       PFORMAT_STRING      pFormatNew );
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
public:
    NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                 PFORMAT_STRING pFormatNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR_MEMSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING pFormat;
    uchar * const pBufferMark;
    uchar * const Memory;
    const uchar uFlags;

public:

    NDR_MEMSIZE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                       uchar *            pBufferMarkNew,
                                       PFORMAT_STRING      pFormatNew );
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR_CONVERT_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING pFormat;
    uchar * const pBufferMark;
    const uchar uFlags;

public:

    NDR_CONVERT_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                       uchar *            pBufferMarkNew,
                                       PFORMAT_STRING      pFormatNew );
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print() {};
#endif

};

class NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING pFormat;
public:
    NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT( PFORMAT_STRING pFormatNew ) :
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

//
// NDR64 Queue Elements

class NDR64_MRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    NDR64_PTR_WIRE_TYPE * const pBufferMark;
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const pCorrMemory;
    const uchar uFlags;
public:

    NDR64_MRSHL_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                     NDR64_PTR_WIRE_TYPE * const pBufferMarkNew,
                                     uchar * const pMemoryNew,
                                     const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    NDR64_PTR_WIRE_TYPE * const pWireMarkerPtr;
public:
    NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                 PFORMAT_STRING pFormatNew,
                                                 NDR64_PTR_WIRE_TYPE *pWireMarkerPtrNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew ),
        pWireMarkerPtr( pWireMarkerPtrNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    NDR64_PTR_WIRE_TYPE *pBufferMark;
    uchar *         pMemory;
    PFORMAT_STRING  pFormat;
    uchar *         pCorrMemory;
    uchar           uFlags;

public:

    NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                         uchar * const pMemoryNew,
                                         const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};


class NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
public:
    NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                   PFORMAT_STRING pFormatNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew ) 
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING  pFormat;   
    const uchar           uFlags;
    NDR64_PTR_WIRE_TYPE * const pBufferMark;
public:

    NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                         PFORMAT_STRING      pFormatNew,
                                         NDR64_PTR_WIRE_TYPE *pBufferMarkNew ) :
        pFormat( pFormatNew ),
        uFlags( pStubMsg->uFlags ),
        pBufferMark( pBufferMarkNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

class NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    const PFORMAT_STRING pFormat;
public:
    NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT(  PFORMAT_STRING pFormatNew ) :
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    NDR64_PTR_WIRE_TYPE WirePtr;
    uchar **        ppMemory;
    uchar *         pMemory;
    PFORMAT_STRING  pFormat;
    uchar *         pCorrMemory;
    NDR_ALLOC_ALL_NODES_CONTEXT *pAllocAllNodesContext; 
    BOOL            fInDontFree;    
    uchar           uFlags;
public:

    NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg,
                                         uchar **            ppMemoryNew,      
                                         uchar *             pMemoryNew,
                                         NDR64_PTR_WIRE_TYPE WirePtrNew,
                                         PFORMAT_STRING      pFormatNew );
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};


class NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
public:
    NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT( uchar * pMemoryNew,
                                                 PFORMAT_STRING pFormatNew ) :
        pMemory( pMemoryNew ),
        pFormat( pFormatNew )
    {}
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif
};

class NDR64_FREE_POINTER_QUEUE_ELEMENT : public NDR_POINTER_QUEUE_ELEMENT
{
private:
    uchar * const pMemory;
    const PFORMAT_STRING pFormat;
    uchar * const pCorrMemory;
    const uchar uFlags;

public:

    NDR64_FREE_POINTER_QUEUE_ELEMENT( MIDL_STUB_MESSAGE *pStubMsg, 
                                      uchar * const pMemoryNew,
                                      const PFORMAT_STRING pFormatNew);
    virtual void Dispatch(MIDL_STUB_MESSAGE *pStubMsg);
#if defined(DBG)
    virtual void Print();
#endif

};

const SIZE_T Ndr32MaxPointerQueueElement = 
    max(sizeof(NDR_MRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_BUFSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_FREE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_PFNFREE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_UNMRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_MEMSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT),
        0)))))))));

const SIZE_T Ndr64MaxPointerQueueElement =
    max(sizeof(NDR64_MRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT),
    max(sizeof(NDR64_FREE_POINTER_QUEUE_ELEMENT),
        0)))))))));

const SIZE_T NdrMaxPointerQueueElement = 
    max(Ndr32MaxPointerQueueElement,
    max(Ndr64MaxPointerQueueElement,
        0));

struct NDR_POINTER_QUEUE_STATE 
{
private:
   NDR_POINTER_QUEUE *pActiveQueue;
   ARRAY_INFO ArrayInfo;

public:

   NDR_POINTER_QUEUE_STATE(void) :
       pActiveQueue(NULL)
      {
      }

   virtual NDR_POINTER_QUEUE_ELEMENT *Allocate() = 0;
   virtual void Free(NDR_POINTER_QUEUE_ELEMENT *pElement) = 0;
                

   NDR_POINTER_QUEUE* GetActiveQueue() { return pActiveQueue; }
   void SetActiveQueue(NDR_POINTER_QUEUE *pNewQueue) { pActiveQueue = pNewQueue; }  
   ARRAY_INFO * GetArrayInfo( ) {return &ArrayInfo;}

}; 

inline void * 
NDR_POINTER_QUEUE_ELEMENT::operator new( 
   size_t /*stAllocateBlock */, 
   NDR_POINTER_QUEUE_STATE *pAllocator )
{
   return pAllocator->Allocate(); 
}

inline void 
NDR_POINTER_QUEUE_ELEMENT::operator delete(
   void *pThis, 
   NDR_POINTER_QUEUE_STATE *pAllocator )
{
   pAllocator->Free( (NDR_POINTER_QUEUE_ELEMENT*)pThis );
}


class NDR32_POINTER_QUEUE_STATE : public NDR_POINTER_QUEUE_STATE
{    
public:
   // Make this private for a C compiler bug.
   static const ItemsToAllocate = 100;

private:

   NDR_POINTER_QUEUE_ELEMENT *pFreeList;

   struct AllocationElement
       {
       SIZE_T ItemsAllocated;
       struct AllocationElement *pNext;
       // Should be pointer aligned
       char Data[ItemsToAllocate][NdrMaxPointerQueueElement];
       } *pAllocationList;

   void FreeAll(); 
   NDR_POINTER_QUEUE_ELEMENT *InternalAllocate();

public:
   NDR32_POINTER_QUEUE_STATE( MIDL_STUB_MESSAGE *pStubMsg ) :
       pFreeList(NULL),
       pAllocationList(NULL)
   {
   }
   ~NDR32_POINTER_QUEUE_STATE() { if ( pAllocationList ) FreeAll(); }

   NDR_POINTER_QUEUE_ELEMENT *Allocate();
   void Free(NDR_POINTER_QUEUE_ELEMENT *pElement);

   void* operator new(size_t, void *pMemory) { return pMemory; }
   void operator delete(void *,void *) {return; }
   void operator delete(void *) {}
};

#if defined(BUILD_NDR64)

class NDR64_POINTER_QUEUE_STATE : public NDR_POINTER_QUEUE_STATE
{
private:
   NDR_PROC_CONTEXT * const pProcContext;

public:
    NDR64_POINTER_QUEUE_STATE( 
        MIDL_STUB_MESSAGE *pStubMsg ) :
        pProcContext( (NDR_PROC_CONTEXT*)pStubMsg->pContext )
    {
    }

    NDR_POINTER_QUEUE_ELEMENT *Allocate();
    void Free(NDR_POINTER_QUEUE_ELEMENT *pElement);
    
    void* operator new(size_t, void *pMemory) { return pMemory;}
    void operator delete(void *,void *) {}
    void operator delete(void *) {}
};

#endif

class NDR_POINTER_QUEUE
{
    PMIDL_STUB_MESSAGE pStubMsg;
    NDR_POINTER_QUEUE_STATE *pQueueState;

    class STORAGE 
    {
        NDR_POINTER_QUEUE_ELEMENT *pHead, *pPrevHead;
        NDR_POINTER_QUEUE_ELEMENT **pInsertPointer, **pPrevInsertPointer;
        
    public:
        STORAGE( );
        void MergeContext();
        void NewContext(); 
        void InsertTail( NDR_POINTER_QUEUE_ELEMENT *pNewNode );
        NDR_POINTER_QUEUE_ELEMENT *RemoveHead();
    } Storage;

public:
    NDR_POINTER_QUEUE( PMIDL_STUB_MESSAGE pStubMsg, NDR_POINTER_QUEUE_STATE *pQueueState );

    void Enque( NDR_POINTER_QUEUE_ELEMENT *pElement );
    void Dispatch();

    void* operator new(size_t, void *pMemory) { return pMemory; }
    void operator delete(void *,void *) {return; }
    void operator delete(void *) {}
    
};

template<class T>
class NDR_POINTER_CONTEXT
{
private:

    bool bNewState;
    bool bNewQueue;
    
    MIDL_STUB_MESSAGE * const pStubMsg;
    // Should be pointer aligned
    char PointerQueueStateStorage[sizeof(T)];

    NDR_POINTER_QUEUE *pActiveQueue;
    // Should be pointer aligned
    char PointerQueueStorage[sizeof(NDR_POINTER_QUEUE)];
    
public:
    __forceinline NDR_POINTER_QUEUE_STATE *GetActiveState() { return pStubMsg->pPointerQueueState; }
private:    
    __forceinline bool IsStateActive() { return NULL != GetActiveState();}

public:


    NDR_POINTER_CONTEXT( MIDL_STUB_MESSAGE *pStubMsgNew ) :
        pStubMsg( pStubMsgNew ),
        bNewState( false ),
        bNewQueue( false ),
        pActiveQueue( NULL )
    {
        NDR_ASSERT( NdrIsLowStack( pStubMsg ), "Created Pointer context too early.\n");
        if ( !IsStateActive() )
            {
            // The queue state wasn't created. 
            pStubMsg->pPointerQueueState =
                new(PointerQueueStateStorage) T(pStubMsg);
            pActiveQueue =
                new(PointerQueueStorage) NDR_POINTER_QUEUE( pStubMsg, GetActiveState() );
            GetActiveState()->SetActiveQueue( pActiveQueue );
            bNewState = bNewQueue = true;
                
            return;
            }

        // State already exists
        pActiveQueue = GetActiveState()->GetActiveQueue();
        if ( pActiveQueue )
            return;

        // Already have a state, but no active queue.
        // Activate the queue.

        pActiveQueue = new(PointerQueueStorage) NDR_POINTER_QUEUE( pStubMsg, GetActiveState() );
        GetActiveState()->SetActiveQueue( pActiveQueue );
        bNewQueue = true;

    }
    __forceinline void DispatchIfRequired( )
    {
        if ( bNewQueue )
            {
            pActiveQueue->Dispatch();
            }
    }
    __forceinline bool ShouldEnque() { return pActiveQueue != NULL; }
    __forceinline void Enque( NDR_POINTER_QUEUE_ELEMENT *pElement ) 
        { 
        pActiveQueue->Enque( pElement ); 
        
        }

    // REVIEW: Replace with a destructor once native
    // exception handling is enabled for ndr.
    __forceinline void EndContext()
    {
        if ( bNewQueue )
            {
            GetActiveState()->SetActiveQueue(NULL);
            }
        
        if ( bNewState)   
            {
            delete (T*)GetActiveState();
            pStubMsg->pPointerQueueState = NULL;
            }
    }
};

typedef NDR_POINTER_CONTEXT<NDR32_POINTER_QUEUE_STATE> NDR32_POINTER_CONTEXT;

#if defined(BUILD_NDR64)
typedef NDR_POINTER_CONTEXT<NDR64_POINTER_QUEUE_STATE> NDR64_POINTER_CONTEXT;
#endif

#endif // __POINTER32_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\ndrp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993-2000 Microsoft Corporation

Module Name :

    ndrp.h

Abtract :

    Contains private definitions for Ndr files in this directory.  This
    file is included by all source files in this directory.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _NDRP_
#define _NDRP_

#include <sysinc.h>
#include "rpc.h"
#include "rpcndr.h"

// Get new token definitions for 64b.
#define RPC_NDR_64
#include "ndrtypes.h"
#include "ndr64types.h"

#include "ndrpall.h"


#ifdef   NDR_IMPORT_NDRP
#define  IMPORTSPEC EXTERN_C DECLSPEC_IMPORT
#else
#define  IMPORTSPEC EXTERN_C
#endif

#include "ndr64types.h"
#include "mrshlp.h"
#include "unmrshlp.h"
#include "bufsizep.h"
#include "memsizep.h"
#include "freep.h"
#include "endianp.h"
#include "fullptr.h"
#include "pipendr.h"
#include "mulsyntx.h"
#include "util.hxx"

long
NdrpArrayDimensions(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    BOOL                fIgnoreStringArrays
    );

long
NdrpArrayElements(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat
    );

void
NdrpArrayVariance(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    long *              pOffset,
    long *              pLength
    );

PFORMAT_STRING
NdrpSkipPointerLayout(
    PFORMAT_STRING      pFormat
    );

long
NdrpStringStructLen(
    uchar *             pMemory,
    long                ElementSize
    );

void
NdrpCheckBound(
    ulong               Bound,
    int                 Type
    );

RPCRTAPI
void
RPC_ENTRY
NdrpRangeBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char *     pMemory,
    PFORMAT_STRING      pFormat
    );

void
NdrpRangeConvert(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    uchar               fEmbeddedPointerPass
    );

void RPC_ENTRY
NdrpRangeFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat
    );

unsigned long RPC_ENTRY
NdrpRangeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat );

unsigned char * RPC_ENTRY
NdrpRangeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat );

unsigned long
FixWireRepForDComVerGTE54(
    PMIDL_STUB_MESSAGE   pStubMsg );

RPC_STATUS
NdrpPerformRpcInitialization (
    void
    );

PVOID
NdrpPrivateAllocate(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    UINT Size 
    );

void
NdrpPrivateFree(
    PNDR_ALLOCA_CONTEXT pAllocaContext,
    void *pMemory 
    );

void
NdrpInitUserMarshalCB(
    MIDL_STUB_MESSAGE *pStubMsg,
    PFORMAT_STRING     pFormat,
    USER_MARSHAL_CB_TYPE CBType,
    USER_MARSHAL_CB   *pUserMarshalCB
    );

void  
NdrpCleanupServerContextHandles( 
    MIDL_STUB_MESSAGE *    pStubMsg,
    uchar *                pStartOfStack,
    BOOL                   fManagerRoutineException
    );

RPC_STATUS
CheckForRobust (
    RPC_SERVER_INTERFACE * pRpcServerIf );

DWORD
NdrpCheckMIDLRobust( IN const MIDL_SERVER_INFO * pMServerInfo, ulong ProcCount , BOOL IsObjectIntf );

EXTERN_C
void
NdrpInitArrayInfo( PMIDL_STUB_MESSAGE pStubMsg, ARRAY_INFO * pArrayInfo );

// Checking bounds etc.
// The bound value check below is independent of anything.

#define CHECK_BOUND( Bound, Type )  NdrpCheckBound( Bound, (int)(Type) )

// check for overflow when calculating the total size. 
ULONG MultiplyWithOverflowCheck( ULONG_PTR Count, ULONG_PTR ElemSize );



// These end of buffer checks can be performed on a receiving side only.
// The necessary setup is there for memorysize, unmarshal and convert walks.
// This also includes pickling walk.
// Don't use this on the sending side.

// Checks if the pointer is past the end of the buffer.  Do not check for wraparound.

#define CHECK_EOB_RAISE_BSD( p )                                      \
    {                                                                 \
       if( (uchar *)(p) > pStubMsg->BufferEnd )                       \
           {                                                          \
           RpcRaiseException( RPC_X_BAD_STUB_DATA );                  \
           }                                                          \
    }

#define CHECK_EOB_RAISE_IB( p )                                       \
    {                                                                 \
        if( (uchar *)(p) > pStubMsg->BufferEnd )                      \
            {                                                         \
            RpcRaiseException( RPC_X_INVALID_BOUND );                 \
            }                                                         \
    }

// Checks if p + incsize is past the end of the bufffer.
// Correctly handle wraparound.

#define CHECK_EOB_WITH_WRAP_RAISE_BSD( p, incsize )                   \
    {                                                                 \
        unsigned char *NewBuffer = ((uchar *)(p)) + (SIZE_T)(incsize);\
        if( (NewBuffer > pStubMsg->BufferEnd) || (NewBuffer < (p)) )  \
             {                                                        \
             RpcRaiseException( RPC_X_BAD_STUB_DATA );                \
             }                                                        \
    }

#define CHECK_EOB_WITH_WRAP_RAISE_IB( p, incsize )                    \
    {                                                                 \
        unsigned char *NewBuffer = ((uchar *)(p)) + (SIZE_T)(incsize);\
        if(  (NewBuffer > pStubMsg->BufferEnd) || (NewBuffer < (p)) ) \
             {                                                        \
             RpcRaiseException( RPC_X_INVALID_BOUND );                \
             }                                                        \
    }

                                                     

#define CHECK_ULONG_BOUND( v )   if ( 0x80000000 & (unsigned long)(v) ) \
                                        RpcRaiseException( RPC_X_INVALID_BOUND );

#define REUSE_BUFFER(pStubMsg) (! pStubMsg->IsClient)

// This would be appropriate on the sending side for marshaling.

#define CHECK_SEND_EOB_RAISE_BSD( p )  \
        if ( pStubMsg->RpcMsg->Buffer + pStubMsg->RpcMsg->BufferLength < p ) \
            RpcRaiseException( RPC_X_BAD_STUB_DATA )

#define NdrpComputeSwitchIs( pStubMsg, pMemory, pFormat )   \
            NdrpComputeConformance( pStubMsg,   \
                                    pMemory,    \
                                    pFormat )

#define NdrpComputeIIDPointer( pStubMsg, pMemory, pFormat )   \
            NdrpComputeConformance( pStubMsg,   \
                                    pMemory,    \
                                    pFormat )

//
// Defined in global.c
//
IMPORTSPEC extern const unsigned char SimpleTypeAlignment[];
IMPORTSPEC extern const unsigned char SimpleTypeBufferSize[];
IMPORTSPEC extern const unsigned char SimpleTypeMemorySize[];
IMPORTSPEC extern const unsigned long NdrTypeFlags[];

#define UNIQUE_POINTER_SHIFT 2
// Add a incremental count for unique pointers to work around HP interop issue
#define PTR_WIRE_REP(p, pStubMsg)  (ulong)(p ?  UNIQUE_POINTER_MARK + ( (pStubMsg->UniquePtrCount++) << UNIQUE_POINTER_SHIFT ): 0)
//#define PTR_WIRE_REP(p, pStubMsg)  (ulong)(p ?  UNIQUE_POINTER_MARK +  (pStubMsg->UniquePtrCount++): 0)
#if defined(__RPC_WIN64__)
#define UNMARSHAL_PTR_WIRE_REP(p)  (ulong)(p ?  PtrToUlong( p ) : 0)
#else
#define UNMARSHAL_PTR_WIRE_REP(p)  (ulong)p
#endif

//
// Proc info flags macros.
//
#define IS_OLE_INTERFACE(Flags)         ((Flags) & Oi_OBJECT_PROC)

#define HAS_RPCFLAGS(Flags)             ((Flags) & Oi_HAS_RPCFLAGS)

#define DONT_HANDLE_EXCEPTION(Flags)    \
                    ((Flags) & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING)


//
// Routine index macro.
//
#define ROUTINE_INDEX(FC)       ((FC) & 0x3F)

#include <ndrmisc.h>

//
// Union hack helper. (used to be MAGIC_UNION_BYTE 0x80)
//
#define IS_MAGIC_UNION_BYTE(pFmt) \
    ((*(unsigned short *)pFmt & (unsigned short)0xff00) == MAGIC_UNION_SHORT)

// User marshal marker on wire.

#define USER_MARSHAL_MARKER     0x72657355


#define BOGUS_EMBED_CONF_STRUCT_FLAG     ( ( unsigned char ) 0x01 )

// compute buffer size for the pointees of a complex struct or complex array
// specifically excluding the flat parts.
#define POINTEE_BUFFER_LENGTH_ONLY_FLAG  ( ( unsigned char ) 0x02 )
#define TOPMOST_CONF_STRUCT_FLAG         ( ( unsigned char ) 0x04 )
#define REVERSE_ARRAY_MARSHALING_FLAG    ( ( unsigned char ) 0x08 )
#define WALKIP_FLAG                      ( ( unsigned char ) 0x10 )
#define BROKEN_INTERFACE_POINTER_FLAG    ( ( unsigned char ) 0x20 )
#define SKIP_REF_CHECK_FLAG              ( ( unsigned char ) 0x40 )


#define IS_EMBED_CONF_STRUCT( f )     ( ( f ) & BOGUS_EMBED_CONF_STRUCT_FLAG )
#define SET_EMBED_CONF_STRUCT( f )     ( f ) |= BOGUS_EMBED_CONF_STRUCT_FLAG
#define RESET_EMBED_CONF_STRUCT( f )   ( f ) &= ~BOGUS_EMBED_CONF_STRUCT_FLAG

#define COMPUTE_POINTEE_BUFFER_LENGTH_ONLY( Flags )          ( ( Flags ) & POINTEE_BUFFER_LENGTH_ONLY_FLAG )
#define SET_COMPUTE_POINTEE_BUFFER_LENGTH_ONLY( Flags )      ( ( Flags ) |= POINTEE_BUFFER_LENGTH_ONLY_FLAG )
#define RESET_COMPUTE_POINTEE_BUFFER_LENGTH_ONLY( Flags )    ( ( Flags ) &= ~POINTEE_BUFFER_LENGTH_ONLY_FLAG )

#define IS_TOPMOST_CONF_STRUCT( f )       ( ( f ) & TOPMOST_CONF_STRUCT_FLAG )
#define SET_TOPMOST_CONF_STRUCT( f )      ( ( f ) |= TOPMOST_CONF_STRUCT_FLAG )
#define RESET_TOPMOST_CONF_STRUCT( f )    ( ( f ) &= ~TOPMOST_CONF_STRUCT_FLAG )

#define IS_CONF_ARRAY_DONE( f )      ( ( f ) & REVERSE_ARRAY_MARSHALING_FLAG )
#define SET_CONF_ARRAY_DONE( f )     ( ( f ) |= REVERSE_ARRAY_MARSHALING_FLAG )
#define RESET_CONF_ARRAY_DONE( f )   ( ( f ) &= ~REVERSE_ARRAY_MARSHALING_FLAG )

#define IS_WALKIP( f )    ( ( f ) & WALKIP_FLAG )
#define SET_WALKIP( f )   ( ( f ) |= WALKIP_FLAG )
#define RESET_WALKIP( f ) ( ( f ) &= ~WALKIP_FLAG )

#define IS_SKIP_REF_CHECK( f ) ( ( f ) & SKIP_REF_CHECK_FLAG )
#define SET_SKIP_REF_CHECK( f ) ( ( f ) |= SKIP_REF_CHECK_FLAG )
#define RESET_SKIP_REF_CHECK( f ) ( ( f ) &= ~SKIP_REF_CHECK_FLAG )


#define IS_BROKEN_INTERFACE_POINTER( f )    ( ( f ) & BROKEN_INTERFACE_POINTER_FLAG )
#define SET_BROKEN_INTERFACE_POINTER( f )   ( ( f ) |= BROKEN_INTERFACE_POINTER_FLAG )
#define RESET_BROKEN_INTERFACE_POINTER( f ) ( ( f ) &= ~BROKEN_INTERFACE_POINTER_FLAG )

#define RESET_CONF_FLAGS_TO_STANDALONE( f )  (f) &= ~( BOGUS_EMBED_CONF_STRUCT_FLAG | \
                                                       TOPMOST_CONF_STRUCT_FLAG |     \
                                                       REVERSE_ARRAY_MARSHALING_FLAG )

//
// Environment dependent macros
//

#define SIMPLE_TYPE_BUF_INCREMENT(Len, FC)      Len += 16

#define EXCEPTION_FLAG  \
            ( (!(RpcFlags & RPCFLG_ASYNCHRONOUS)) &&        \
              (!InterpreterFlags.IgnoreObjectException) &&  \
              (StubMsg.dwStubPhase != PROXY_SENDRECEIVE) )



#endif // _NDRP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\ndrpall.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 2000 Microsoft Corporation

Module Name :

    ndrpall.h

Abtract :

    Contains private definitions which are common to both
    ndr20 and ndr64

Author :

    mzoran   May 31, 2000

Revision History :

--------------------------------------------------------------------*/

#if !defined(__NDRPALL_H__)
#define __NDRPALL_H__

//
// The MIDL version is contained in the stub descriptor starting with
// MIDL version 2.00.96 (pre NT 3.51 Beta 2, 2/95) and can be used for a finer
// granularity of compatability checking.  The MIDL version was zero before
// MIDL version 2.00.96.  The MIDL version number is converted into
// an integer long using the following expression :
//     ((Major << 24) | (Minor << 16) | Revision)
//
#define MIDL_NT_3_51           ((2UL << 24) | (0UL << 16) | 102UL)
#define MIDL_VERSION_3_0_39    ((3UL << 24) | (0UL << 16) |  39UL)
#define MIDL_VERSION_3_2_88    ((3UL << 24) | (2UL << 16) |  88UL)
#define MIDL_VERSION_5_0_136   ((5UL << 24) | (0UL << 16) | 136UL)
#define MIDL_VERSION_5_2_202   ((5UL << 24) | (2UL << 16) | 202UL)

// Shortcut typedefs.
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;
typedef unsigned __int64    uint64;

#if defined(NDRFREE_DEBUGPRINT)
// force a debug print and a breakpoint on a free build
#define NDR_ASSERT( exp, S ) \
    if (!(exp)) { DbgPrint( "%s(%s)\n", __FILE__, __LINE__ );DbgPrint( S## - Ryszard's private rpcrt4.dll\n", NULL );DebugBreak(); }
#define NDR_CORRUPTION_ASSERT( exp, S ) NDR_ASSERT( exp, S )
#else
// Just use the RPC runtime assert
#define NDR_ASSERT( exp, S )   \
    { ASSERT( ( S, (exp) ) ); }
#define NDR_CORRUPTION_ASSERT( exp, S )   \
    { CORRUPTION_ASSERT( ( S, (exp) ) ); }
#endif

#define NDR_MEMORY_LIST_SIGNATURE 'MEML'
// work around a HP RPC bug that'll coredump if the value of wire unique pointer marker is some certain value. 
// I can't really figure out the exact pattern and finally decide to choose one that works
#define UNIQUE_POINTER_MARK 0x20000

typedef struct _NDR_MEMORY_LIST_TAIL_NODE {
   ULONG Signature;
   void *pMemoryHead;
   struct _NDR_MEMORY_LIST_TAIL_NODE *pNextNode;
} NDR_MEMORY_LIST_TAIL_NODE, *PNDR_MEMORY_LIST_TAIL_NODE;

struct NDR_ALLOC_ALL_NODES_CONTEXT {
   unsigned char       *   AllocAllNodesMemory;
   unsigned char       *   AllocAllNodesMemoryBegin;
   unsigned char       *   AllocAllNodesMemoryEnd;
};

void
NdrpFreeMemoryList(
    PMIDL_STUB_MESSAGE  pStubMsg
    );

void
NdrpGetIIDFromBuffer(
    PMIDL_STUB_MESSAGE  pStubMsg,
    IID **              ppIID
    );

void
NDRSContextEmergencyCleanup (
    IN RPC_BINDING_HANDLE   BindingHandle,
    IN OUT NDR_SCONTEXT     hContext,
    IN NDR_RUNDOWN          userRunDownIn,
    IN PVOID                NewUserContext,
    IN BOOL                 fManagerRoutineException
    );

void
NdrpEmergencyContextCleanup(
    MIDL_STUB_MESSAGE  *            pStubMsg,
    PNDR_CONTEXT_HANDLE_ARG_DESC    pCtxtDesc,
    void *                          pArg,
    BOOL                            fManagerRoutineException );


//
// Alignment macros.
//

#define ALIGN( pStuff, cAlign ) \
                pStuff = (uchar *)((LONG_PTR)((pStuff) + (cAlign)) \
                                   & ~ ((LONG_PTR)(cAlign)))

#define LENGTH_ALIGN( Length, cAlign ) \
                Length = (((Length) + (cAlign)) & ~ (cAlign))

#if defined(_IA64_)
#include "ia64reg.h"

#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
#pragma intrinsic (__getReg)

#ifdef __cplusplus
} // extern "C"
#endif

#endif

#if defined(_X86_)
__forceinline
void*
NdrGetCurrentStackPointer(void)
{
   _asm{ mov eax, esp }
}

__forceinline
void
NdrSetupLowStackMark( PMIDL_STUB_MESSAGE pStubMsg )
{
    pStubMsg->LowStackMark = (uchar*)NdrGetCurrentStackPointer() - 0x1000; //4KB
}

__forceinline
BOOL
NdrIsLowStack(MIDL_STUB_MESSAGE *pStubMsg ) {
    return (SIZE_T)NdrGetCurrentStackPointer() < (SIZE_T)pStubMsg->LowStackMark;
    }

#elif defined(_AMD64_)

__forceinline
void*
NdrGetCurrentStackPointer(void)
{
    PVOID TopOfStack;

    return (&TopOfStack + 1);
}

__forceinline
void
NdrSetupLowStackMark( PMIDL_STUB_MESSAGE pStubMsg )
{
    pStubMsg->LowStackMark = (uchar*)NdrGetCurrentStackPointer() - 0x1000; //4KB
}

__forceinline
BOOL
NdrIsLowStack(MIDL_STUB_MESSAGE *pStubMsg ) {
    return (SIZE_T)NdrGetCurrentStackPointer() < (SIZE_T)pStubMsg->LowStackMark;
    //return false;
    }

#elif defined(_IA64_)

__forceinline
void*
NdrGetCurrentStackPointer(void)
{
    return (void*)__getReg(CV_IA64_IntSp);
}

__forceinline
void*
NdrGetCurrentBackingStorePointer(void)
{
    return (void*)__getReg(CV_IA64_RsBSP);
}

__forceinline
void
NdrSetupLowStackMark( PMIDL_STUB_MESSAGE pStubMsg )
{
   // a backing store pointer which is used to store the stack based registers.
   // The normal stack grows downward and the backing store pointer grows upward.
        pStubMsg->LowStackMark = (uchar*)NdrGetCurrentStackPointer() - 0x4000;
        pStubMsg->BackingStoreLowMark =
       (uchar*)NdrGetCurrentBackingStorePointer() + 0x4000; //16KB  // IA64 really has 2 stack pointers.  The normal stack pointer and
}

__forceinline
BOOL
NdrIsLowStack(MIDL_STUB_MESSAGE *pStubMsg ) {
    return ((SIZE_T)NdrGetCurrentBackingStorePointer() > (SIZE_T)pStubMsg->BackingStoreLowMark) ||
           ((SIZE_T)NdrGetCurrentStackPointer() < (SIZE_T)pStubMsg->LowStackMark);
    //return false;
    }

#else
#error Unsupported Architecture
#endif

__forceinline
void
NdrRpcSetNDRSlot( void * pStubMsg )
{
    RPC_STATUS rc = I_RpcSetNDRSlot( pStubMsg ) ;
    if ( rc!= RPC_S_OK )
        RpcRaiseException(rc );
}

BOOL
IsWriteAV (
    IN struct _EXCEPTION_POINTERS *ExceptionPointers
    );

int RPC_ENTRY
NdrServerUnmarshallExceptionFlag(
    IN struct _EXCEPTION_POINTERS *ExceptionPointers
);

#define ZEROOUT_GAP( x ) if ( !((LONG_PTR)x & 3) )  {*( (long *&)(x) ) = 0;}
// zero out 4 bytes if the alignement is 7

void __forceinline
ZeroOutGapAndAlign( PMIDL_STUB_MESSAGE pStubMsg, ulong Alignment ) 
{
    if ( (~((ULONG_PTR)(pStubMsg->Buffer - 1) & 4 )) & (Alignment & 4 ) ) 
            {
            ALIGN(pStubMsg->Buffer,3); 
            *((ulong *)pStubMsg->Buffer) = 0; 
            };

    ALIGN(pStubMsg->Buffer, Alignment );
}


typedef void ( __fastcall * PSIMPLETYPE_MARSHAL_ROUTINE)(
                        IN PMIDL_STUB_MESSAGE,
                        IN uchar * );

// memory copy routine used in marshalling to zero out trailing 4 bytes 
// if the memcpy doesn't end on 4 byte boundary. 
// we are sure the buffer buffer copy size could not be 0. midl will reject
// empty structure and 0 length array. 
void __forceinline 
RpcpMarshalMemoryCopy(
    OUT void  * Destination,
    IN  void  * Source,
    IN  size_t  Length
    )
{
    NDR_ASSERT( Length != 0, "invalid buffer length");
    uchar *pEndofData = (uchar *)Destination + Length;
    ALIGN(pEndofData, 3 );
    // decide to add an IF statement to marshalling memcpy:
    // the place where this might have relatively more perf panelty
    // is only simple struct (with pointer ). All others we either have to
    // check anyhow or the code is complicated enough adding one 
    // if doesn't really hurt. 
    if ( pEndofData -4 >= Destination )
        *(long *)(pEndofData -4) = 0;

    RpcpMemoryCopy(Destination, Source, Length );
}
#endif // __NDRPALL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\pointerq.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    pointerq.cxx

Abstract :

    This file contains the routines for the pointer queues
    
Author :

    Mike Zoran  mzoran   Jun 2000.

Revision History :

  ---------------------------------------------------------------------*/
#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

void 
NDR32_POINTER_QUEUE_STATE::Free(
    NDR_POINTER_QUEUE_ELEMENT *pElement 
    ) 
{
    #if defined(DBG)
    memset( pElement, 0xBD, NdrMaxPointerQueueElement);
    #endif
    
    pElement->pNext = pFreeList;
    pFreeList = pElement;
}

NDR_POINTER_QUEUE_ELEMENT *
NDR32_POINTER_QUEUE_STATE::Allocate()
{
    NDR_POINTER_QUEUE_ELEMENT *pNewElement;
    if ( pFreeList )
        {
        pNewElement = pFreeList;
        pFreeList = pNewElement->pNext;
        }
    else
        {
        pNewElement = InternalAllocate();
        }
#if defined(DBG)
     memset( pNewElement, 0xDB, NdrMaxPointerQueueElement );
#endif
    return pNewElement;
}


void 
NDR32_POINTER_QUEUE_STATE::FreeAll() 
{
    while ( pAllocationList )
        {
        AllocationElement *pThisAlloc = pAllocationList;
        pAllocationList = pAllocationList->pNext;
        I_RpcFree( pThisAlloc );
        }    
}

NDR_POINTER_QUEUE_ELEMENT * 
NDR32_POINTER_QUEUE_STATE::InternalAllocate()
{
    if ( !pAllocationList || 
         (ItemsToAllocate == pAllocationList->ItemsAllocated ) )
        {

        struct AllocationElement *pElement =
            (struct AllocationElement *)I_RpcAllocate( sizeof(AllocationElement) );
        if ( !pElement )
            {
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );
            }

        pElement->pNext          = pAllocationList;
        pElement->ItemsAllocated = 0;
        pAllocationList          = pElement;
        }

    return (NDR_POINTER_QUEUE_ELEMENT*)
        (NDR_POINTER_QUEUE_ELEMENT*)pAllocationList->Data[pAllocationList->ItemsAllocated++];
 
}

#if defined(BUILD_NDR64)

NDR_POINTER_QUEUE_ELEMENT *
NDR64_POINTER_QUEUE_STATE::Allocate()
{
    NDR_POINTER_QUEUE_ELEMENT *pNewElement;
    if ( pProcContext->pQueueFreeList )
        {
        pNewElement = pProcContext->pQueueFreeList;
        pProcContext->pQueueFreeList = pNewElement->pNext;
        }
    else
        {
        pNewElement = (NDR_POINTER_QUEUE_ELEMENT *)
            NdrpAlloca( &pProcContext->AllocateContext, 
                        NdrMaxPointerQueueElement );
        }
#if defined(DBG)
     memset( pNewElement, 0xDB, NdrMaxPointerQueueElement );
#endif

     return pNewElement;
}

void 
NDR64_POINTER_QUEUE_STATE::Free(
    NDR_POINTER_QUEUE_ELEMENT *pElement 
    ) 
{
    #if defined(DBG)
    memset( pElement, 0xBD, NdrMaxPointerQueueElement);
    #endif
    
    pElement->pNext = pProcContext->pQueueFreeList;
    pProcContext->pQueueFreeList = pElement;
}

#endif

inline NDR_POINTER_QUEUE::STORAGE::STORAGE( ) :
    pHead(NULL),
    pPrevHead(NULL),
    pPrevInsertPointer(NULL),
    pInsertPointer(&pHead)
{
}

inline void NDR_POINTER_QUEUE::STORAGE::MergeContext()
{
    // Add old list to end of this list.
    if ( pPrevHead )
        {
        // Append list
        *pInsertPointer = pPrevHead;
        // Set insert pointer to end of old list
        pInsertPointer = pPrevInsertPointer;
        }
    
    pPrevHead = NULL;
    pPrevInsertPointer = NULL;
}

inline void NDR_POINTER_QUEUE::STORAGE::NewContext()
{

    pPrevHead          = pHead;
    pPrevInsertPointer = pInsertPointer;

    pHead           = NULL;
    pInsertPointer  = &pHead;

}

inline void NDR_POINTER_QUEUE::STORAGE::InsertTail( NDR_POINTER_QUEUE_ELEMENT *pNewNode )
{
    *pInsertPointer = pNewNode;
    pNewNode->pNext = NULL;
    pInsertPointer  = &pNewNode->pNext;
}

inline NDR_POINTER_QUEUE_ELEMENT *NDR_POINTER_QUEUE::STORAGE::RemoveHead()
{

    NDR_POINTER_QUEUE_ELEMENT *pOldHead = pHead;

    if (!pHead)
        {
        return pHead;
        }

    if ( !pHead->pNext )
        {
        // Last item, reinitialize list. 
        pHead = NULL;
        pInsertPointer = &pHead->pNext;
        }
    else 
        {
        pHead = pHead->pNext;
        }

    return pOldHead;
}



#if defined(DBG)
ulong NdrPointerQueueLogLevel;
#endif

void NDR_POINTER_QUEUE::Enque( NDR_POINTER_QUEUE_ELEMENT * pElement )
{

    Storage.InsertTail( pElement );

#if defined(DBG)
    if ( NdrPointerQueueLogLevel )
        {
        DbgPrint( "Queing Element %p\n", pElement );
        pElement->Print();
        }
#endif

}

void NDR_POINTER_QUEUE::Dispatch()
{
    while ( 1 )
        {

        NDR_POINTER_QUEUE_ELEMENT *pHead = Storage.RemoveHead();

        if ( !pHead )
            return;

#if defined(DBG)
        if ( NdrPointerQueueLogLevel )
            {
            DbgPrint( "Dispatching Element: %p\n", pHead );
            pHead->Print();
            }
#endif
        
        Storage.NewContext();
        pHead->Dispatch( pStubMsg );
        pQueueState->Free( pHead );        
        Storage.MergeContext();

        }
}

NDR_POINTER_QUEUE::NDR_POINTER_QUEUE( PMIDL_STUB_MESSAGE pNewStubMsg,
                                      NDR_POINTER_QUEUE_STATE *pNewState ) :
    pStubMsg( pNewStubMsg ),
    Storage(),
    pQueueState(pNewState)
    {
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\proxy.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    proxy.c

Abstract:
    Implements the IRpcProxyBuffer interface.

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT and Windows 95 and PowerMac.
    We do not support DOS, Win16 and Mac.

Revision History:

--*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>
#include <stddef.h>

CStdProxyBuffer * RPC_ENTRY
NdrGetProxyBuffer(
    void *pThis);

const IID * RPC_ENTRY
NdrGetProxyIID(
    const void *pThis);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer_Release(
    IN  IRpcProxyBuffer *This);

ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_Release(
    IN  IRpcProxyBuffer *This);

BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList, 
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex );


// The channel wrapper
//

typedef struct tagChannelWrapper
{
    const IRpcChannelBufferVtbl *lpVtbl;
    long                         RefCount;
    const IID *                  pIID;
    struct IRpcChannelBuffer *   pChannel;
} ChannelWrapper;


HRESULT STDMETHODCALLTYPE
CreateChannelWrapper
(
    const IID *          pIID,
    IRpcChannelBuffer *  pChannel,
    IRpcChannelBuffer ** pChannelWrapper
);

HRESULT STDMETHODCALLTYPE
CreateAsyncChannelWrapper
(
    const IID *          pIID,
    IRpcChannelBuffer *  pChannel,
    IRpcChannelBuffer ** pChannelWrapper
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_QueryInterface
(
    IRpcChannelBuffer3 * This,
    REFIID               riid,
    void **              ppvObject
);

ULONG STDMETHODCALLTYPE
ChannelWrapper_AddRef
(
    IRpcChannelBuffer3 * This
);

ULONG STDMETHODCALLTYPE
ChannelWrapper_Release
(
    IRpcChannelBuffer3 * This
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetBuffer
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    REFIID              riid
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_SendReceive
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG *             pStatus
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_FreeBuffer
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetDestCtx
(
    IRpcChannelBuffer3 * This,
    DWORD *             pdwDestContext,
    void **             ppvDestContext
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_IsConnected
(
    IRpcChannelBuffer3 * This
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetProtocolVersion
(
    IRpcChannelBuffer3 * This,
    DWORD             * pdwVersion
);

HRESULT STDMETHODCALLTYPE
ChannelWrapper_Send(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG *             pStatus
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_Receive(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG               ulSize,
    ULONG *             pStatus
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_Cancel(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetCallContext(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    REFIID              riid,
    void    **          pInterface
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetDestCtxEx(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    DWORD *             pdwDestContext,
    void **             ppvDestContext
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetState(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    DWORD         *     pState
    );

HRESULT STDMETHODCALLTYPE
ChannelWrapper_RegisterAsync(
    IRpcChannelBuffer3 *    This,
    RPCOLEMESSAGE *         pMessage,
    IAsyncManager *         pAsyncMgr
    );



HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_QueryInterface
(
    IAsyncRpcChannelBuffer  *   This,
    REFIID                      riid,
    void **                     ppvObject
);

ULONG STDMETHODCALLTYPE
AsyncChannelWrapper_AddRef
(
    IAsyncRpcChannelBuffer  *   This
);

ULONG STDMETHODCALLTYPE
AsyncChannelWrapper_Release
(
    IAsyncRpcChannelBuffer  *   This
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetBuffer
(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    REFIID                      riid
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_SendReceive
(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    ULONG *                     pStatus
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_FreeBuffer
(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetDestCtx
(
    IAsyncRpcChannelBuffer  *   This,
    DWORD *                     pdwDestContext,
    void **                     ppvDestContext
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_IsConnected
(
    IAsyncRpcChannelBuffer  *   This
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetProtocolVersion
(
    IAsyncRpcChannelBuffer  *   This,
    DWORD                   *   pdwVersion
);

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_Send(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    ISynchronize *              pSynchronize,
    ULONG *                     pStatus
    );

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_Receive(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    ULONG *                     pStatus
    );

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetDestCtxEx
(
    IAsyncRpcChannelBuffer  *   This,
    RPCOLEMESSAGE *             pMessage,
    DWORD *                     pdwDestContext,
    void **                     ppvDestContext
);


//+-------------------------------------------------------------------------
//
//  Global data
//
//--------------------------------------------------------------------------

// ProxyBuffer vtables for non-delegaed and delegated case.

extern const IRpcProxyBufferVtbl CStdProxyBufferVtbl = {
    CStdProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdProxyBuffer_Release,
    CStdProxyBuffer_Connect,
    CStdProxyBuffer_Disconnect };

extern const IRpcProxyBufferVtbl CStdProxyBuffer2Vtbl = {
    CStdProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdProxyBuffer2_Release,
    CStdProxyBuffer2_Connect,
    CStdProxyBuffer2_Disconnect };

// ICallFactory interface on the ProxyBuffer objects.
// ICallFactory is an interface on a sync proxy only.
// It has been introduced for NT5 beta2.

extern const ICallFactoryVtbl CStdProxyBuffer_CallFactoryVtbl = {
    CStdProxyBuffer_CF_QueryInterface,
    CStdProxyBuffer_CF_AddRef,
    CStdProxyBuffer_CF_Release,
    CStdProxyBuffer_CF_CreateCall };

extern const ICallFactoryVtbl CStdProxyBuffer2_CallFactoryVtbl = {
    CStdProxyBuffer_CF_QueryInterface,
    CStdProxyBuffer_CF_AddRef,
    CStdProxyBuffer_CF_Release,
    CStdProxyBuffer2_CF_CreateCall };

extern const IReleaseMarshalBuffersVtbl CStdProxyBuffer_ReleaseMarshalBuffersVtbl = {
    CStdProxyBuffer_RMB_QueryInterface,
    CStdProxyBuffer_RMB_AddRef,
    CStdProxyBuffer_RMB_Release,
    CStdProxyBuffer_RMB_ReleaseMarshalBuffer };

extern const IReleaseMarshalBuffersVtbl CStdAsyncProxyBuffer_ReleaseMarshalBuffersVtbl = {
    CStdProxyBuffer_RMB_QueryInterface,
    CStdProxyBuffer_RMB_AddRef,
    CStdProxyBuffer_RMB_Release,
    CStdAsyncProxyBuffer_RMB_ReleaseMarshalBuffer };

// Async proxy buffer vtables

extern const IRpcProxyBufferVtbl CStdAsyncProxyBufferVtbl = {
    CStdAsyncProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdAsyncProxyBuffer_Release,
    CStdAsyncProxyBuffer_Connect,
    CStdProxyBuffer_Disconnect };

extern const IRpcProxyBufferVtbl CStdAsyncProxyBuffer2Vtbl = {
    CStdAsyncProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdAsyncProxyBuffer2_Release,
    CStdAsyncProxyBuffer2_Connect,
    CStdProxyBuffer2_Disconnect };

// Channel wrapper is used for delegetion only.


extern const IRpcChannelBuffer3Vtbl ChannelWrapperVtbl = {
    ChannelWrapper_QueryInterface,
    ChannelWrapper_AddRef,
    ChannelWrapper_Release,
    ChannelWrapper_GetBuffer,
    ChannelWrapper_SendReceive,
    ChannelWrapper_FreeBuffer,
    ChannelWrapper_GetDestCtx,
    ChannelWrapper_IsConnected,
    ChannelWrapper_GetProtocolVersion,
    ChannelWrapper_Send,
    ChannelWrapper_Receive,
    ChannelWrapper_Cancel,
    ChannelWrapper_GetCallContext,
    ChannelWrapper_GetDestCtxEx,
    ChannelWrapper_GetState,
    ChannelWrapper_RegisterAsync
    };

extern const IAsyncRpcChannelBufferVtbl AsyncChannelWrapperVtbl = {
    AsyncChannelWrapper_QueryInterface,
    AsyncChannelWrapper_AddRef,
    AsyncChannelWrapper_Release,
    AsyncChannelWrapper_GetBuffer,
    AsyncChannelWrapper_SendReceive,
    AsyncChannelWrapper_FreeBuffer,
    AsyncChannelWrapper_GetDestCtx,
    AsyncChannelWrapper_IsConnected,
    AsyncChannelWrapper_GetProtocolVersion,
    AsyncChannelWrapper_Send,
    AsyncChannelWrapper_Receive,
    AsyncChannelWrapper_GetDestCtxEx
    };

//+-------------------------------------------------------------------------
//
//  End of Global data
//
//--------------------------------------------------------------------------


#pragma code_seg(".orpc")

// __inline
CStdProxyBuffer * RPC_ENTRY
NdrGetProxyBuffer(
    IN  void *pThis)
/*++

Routine Description:
    The "this" pointer points to the pProxyVtbl field in the
    CStdProxyBuffer structure.  The NdrGetProxyBuffer function
    returns a pointer to the top of the CStdProxyBuffer
    structure.

Arguments:
    pThis - Supplies a pointer to the interface proxy.

Return Value:
    This function returns a pointer to the proxy buffer.

--*/
{
    unsigned char *pTemp;

    pTemp = (unsigned char *) pThis;
    pTemp -= offsetof(CStdProxyBuffer, pProxyVtbl);

    return (CStdProxyBuffer *)pTemp;
}

//__inline
const IID * RPC_ENTRY
NdrGetProxyIID(
    IN  const void *pThis)
/*++

Routine Description:
    The NDRGetProxyIID function returns a pointer to IID.

Arguments:
    pThis - Supplies a pointer to the interface proxy.

Return Value:
    This function returns a pointer to the IID.

--*/
{
    unsigned char **    ppTemp;
    unsigned char *     pTemp;
    CInterfaceProxyVtbl *pProxyVtbl;

    //Get a pointer to the proxy vtbl.
    ppTemp = (unsigned char **) pThis;
    pTemp = *ppTemp;
    pTemp -= sizeof(CInterfaceProxyHeader);
    pProxyVtbl = (CInterfaceProxyVtbl *) pTemp;

    return pProxyVtbl->header.piid;
}


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_QueryInterface(
    IN  IRpcProxyBuffer *   This,
    IN  REFIID              riid,
    OUT void **             ppv)
/*++

Routine Description:
    Query for an interface on the proxy.  This function provides access
    to both internal and external interfaces.

Arguments:
    riid - Supplies the IID of the requested interface.
        ppv  - Returns a pointer to the requested interface.

Return Value:
    S_OK
        E_NOINTERFACE

--*/
{
    CStdProxyBuffer   * pCThis  = (CStdProxyBuffer *) This;
    HRESULT             hr = E_NOINTERFACE;
    const IID *         pIID;

    *ppv = 0;

    if( (memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcProxyBuffer, sizeof(IID)) == 0) )
    {
        //This is an internal interface. Increment the internal reference count.
        InterlockedIncrement( &pCThis->RefCount);
        *ppv = This;
        hr = S_OK;
        return hr;   
    }
    else if ( pCThis->pCallFactoryVtbl != 0  && 
              memcmp(&riid, &IID_ICallFactory, sizeof(IID)) == 0 )
        {
        // This is an exposed interface so go through punkOuter ot addref.
        pCThis->punkOuter->lpVtbl->AddRef(pCThis->punkOuter);

        *ppv = (void *) & pCThis->pCallFactoryVtbl;
        hr = S_OK;
        return hr;
        }
    else if ( pCThis->pRMBVtbl && 
              (memcmp(&riid, &IID_IReleaseMarshalBuffers,sizeof(IID)) == 0))
    {
        InterlockedIncrement( &pCThis->RefCount);

        *ppv = (void *) & pCThis->pRMBVtbl;
        hr = S_OK;
        return hr;
    }

    pIID = NdrGetProxyIID(&pCThis->pProxyVtbl);

    if( memcmp(&riid, pIID, sizeof(IID)) == 0)
    {
        //Increment the reference count.

        pCThis->punkOuter->lpVtbl->AddRef(pCThis->punkOuter);
        *ppv = (void *) &pCThis->pProxyVtbl;
        hr = S_OK;
    }

    return hr;
};


HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_QueryInterface(
    IN  IRpcProxyBuffer *   This,
    IN  REFIID              riid,
    OUT void **             ppv)
/*++

Routine Description:
    Query for an interface on the proxy.  This function provides access
    to both internal and external interfaces.
    
Used for
    CStdAsyncProxyBuffer2 as well.

Arguments:
    riid - Supplies the IID of the requested interface.
        ppv  - Returns a pointer to the requested interface.

Return Value:
    S_OK
        E_NOINTERFACE

--*/
{
    CStdProxyBuffer   * pCThis  = (CStdProxyBuffer *) This;
    HRESULT             hr = E_NOINTERFACE;
    const IID *         pIID;

    *ppv = 0;

    if( (memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcProxyBuffer, sizeof(IID)) == 0))
    {
        //This is an internal interface. Increment the internal reference count.
        InterlockedIncrement( &pCThis->RefCount);
        *ppv = This;
        hr = S_OK;
        return hr;   
    }
    else if ( pCThis->pRMBVtbl && 
              (memcmp(&riid, &IID_IReleaseMarshalBuffers,sizeof(IID)) == 0))
    {
        InterlockedIncrement( &pCThis->RefCount);

        *ppv = (void *) & pCThis->pRMBVtbl;
        hr = S_OK;
        return hr;
    }

    if(memcmp(&riid, &IID_ISynchronize, sizeof(IID)) == 0)
    {
        hr = pCThis->punkOuter->lpVtbl->QueryInterface( pCThis->punkOuter,
                                                        IID_ISynchronize,
                                                        ppv);
    }

    pIID = NdrGetProxyIID(&pCThis->pProxyVtbl);

    if(memcmp(&riid, pIID, sizeof(IID)) == 0)
    {
        //Increment the reference count.
        pCThis->punkOuter->lpVtbl->AddRef(pCThis->punkOuter);
        
        *ppv = (void *) &pCThis->pProxyVtbl;
        hr = S_OK;
    }

    return hr;
};


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_AddRef(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Increment reference count.

Used for
    CStdProxyBuffer2
    CStdAsyncProxyBuffer
    CStdAsuncProxyBuffer2

Arguments:

Return Value:
    Reference count.

--*/
{
    // We do not need to go through punkOuter for ICallFactory.

    CStdProxyBuffer   *  pCThis  = (CStdProxyBuffer *) This;

    InterlockedIncrement(&pCThis->RefCount);

    return (ULONG) pCThis->RefCount;
};



ULONG STDMETHODCALLTYPE
CStdProxyBuffer_Release(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG count;
    IPSFactoryBuffer *pFactory;

    NDR_ASSERT(((CStdProxyBuffer *)This)->RefCount > 0, "Invalid reference count");

    count = (unsigned long) ((CStdProxyBuffer *)This)->RefCount - 1;


    if(InterlockedDecrement(&((CStdProxyBuffer *)This)->RefCount) == 0)
    {
        count = 0;

        pFactory = (IPSFactoryBuffer *) ((CStdProxyBuffer *)This)->pPSFactory;

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release(pFactory);

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset(This,  '\0', sizeof(CStdProxyBuffer));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(This);
    }

    return count;
};


ULONG STDMETHODCALLTYPE
CStdProxyBuffer2_Release(
    IN  IRpcProxyBuffer *   This)
/*++

Routine Description:
    Decrement reference count.  This function is used by proxies
    which delegate to the base interface.

Arguments:
    This - Points to a CStdProxyBuffer2.

Return Value:
    Reference count.

--*/
{
    ULONG               count;
    IPSFactoryBuffer *  pFactory;
    IRpcProxyBuffer *   pBaseProxyBuffer;
    IUnknown *          pBaseProxy;

    NDR_ASSERT(((CStdProxyBuffer2 *)This)->RefCount > 0, "Invalid reference count");

    count = (ULONG) ((CStdProxyBuffer2 *)This)->RefCount - 1;

    if(InterlockedDecrement(&((CStdProxyBuffer2 *)This)->RefCount) == 0)
    {
        count = 0;

        //Delegation support.
        pBaseProxy = ((CStdProxyBuffer2 *)This)->pBaseProxy;
        if(pBaseProxy != 0)
        {
// Shannon - why?
            //This is a weak reference, so we don't release it.
            //pBaseProxy->lpVtbl->Release(pBaseProxy);
        }

        pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

        if( pBaseProxyBuffer != 0)
        {
            pBaseProxyBuffer->lpVtbl->Release(pBaseProxyBuffer);
        }

        //Decrement the DLL reference count.
        pFactory = (IPSFactoryBuffer *) ((CStdProxyBuffer2 *)This)->pPSFactory;
        pFactory->lpVtbl->Release(pFactory);

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset(This,  '\0', sizeof(CStdProxyBuffer2));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(This);
    }

    return count;
};


ULONG STDMETHODCALLTYPE
CStdAsyncProxyBuffer_Release(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    // We do not need to go through punkOuter for ICallFactory
    // and so everything is local.

    CStdAsyncProxyBuffer * pAsyncPB = (CStdAsyncProxyBuffer *)This;
    ULONG                  count;


    NDR_ASSERT( pAsyncPB->RefCount > 0, "Async proxy Invalid reference count");

    count = (unsigned long) pAsyncPB->RefCount - 1;


    if ( InterlockedDecrement(&pAsyncPB->RefCount) == 0)
        {
        IPSFactoryBuffer * pFactory = pAsyncPB->pPSFactory;

        count = 0;

        // Release the pAsyncMsg and the related state
        NdrpAsyncProxyMsgDestructor( pAsyncPB );

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release( pFactory );

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset( pAsyncPB,  '\32', sizeof(CStdAsyncProxyBuffer));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(pAsyncPB);
        }

    return count;
};


ULONG STDMETHODCALLTYPE
CStdAsyncProxyBuffer2_Release(
    IN  IRpcProxyBuffer *   This)
/*++

Routine Description:
    Decrement reference count.  This function is used by proxies
    which delegate to the base interface.

Arguments:
    This - Points to a CStdProxyBuffer2.

Return Value:
    Reference count.

--*/
{
    CStdAsyncProxyBuffer * pAsyncPB = (CStdAsyncProxyBuffer *)This;
    ULONG                  count;

    NDR_ASSERT( pAsyncPB->RefCount > 0, "Invalid reference count");

    count = (ULONG) pAsyncPB->RefCount - 1;

    if ( InterlockedDecrement(&pAsyncPB->RefCount) == 0)
        {
        IRpcProxyBuffer *   pBaseProxyBuffer ;
        IPSFactoryBuffer *  pFactory = pAsyncPB->pPSFactory;

        count = 0;

        // Delegation support - release the base async proxy.

        if( pAsyncPB->map.pBaseProxy != 0)
            {
            // Shannon - why?
            //This is a weak reference, so we don't release it.
            //pBaseProxy->lpVtbl->Release(pBaseProxy);
            }

        pBaseProxyBuffer = pAsyncPB->pBaseProxyBuffer;

        if( pBaseProxyBuffer != 0)
            pBaseProxyBuffer->lpVtbl->Release(pBaseProxyBuffer);

        // Release the pAsyncMsg and the related state
        NdrpAsyncProxyMsgDestructor( (CStdAsyncProxyBuffer*)This );

        // Then clean up the async proxy itself.

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release(pFactory);

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset(pAsyncPB,  '\32', sizeof(CStdAsyncProxyBuffer));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(pAsyncPB);
        }

    return count;
};


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_RMB_QueryInterface(
    IN  IReleaseMarshalBuffers   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub IReleaseMarshalBuffers pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works the same way for ProxyBuffer2 and AsyncProxyBuffer.
--*/
{
    CStdProxyBuffer * pSyncPB = (CStdProxyBuffer *)
                        ((uchar *)This - offsetof(CStdProxyBuffer,pRMBVtbl));

    return pSyncPB->lpVtbl->QueryInterface( (IRpcProxyBuffer *)pSyncPB,
                                            riid,
                                            ppvObject );
}


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_RMB_AddRef(
    IN  IReleaseMarshalBuffers *This)
/*++

Routine Description:
    Implementation of AddRef for interface proxy.

Arguments:

Return Value:
    Reference count.
    
--*/
{
    ULONG  count;

    CStdProxyBuffer * pSyncPB = (CStdProxyBuffer *)
                        ((uchar *)This - offsetof(CStdProxyBuffer,pRMBVtbl));

    // It needs to go through punkOuter.

    count = pSyncPB->lpVtbl->AddRef((IRpcProxyBuffer *) pSyncPB );
    return count;
};


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_RMB_Release(
    IN  IReleaseMarshalBuffers *This)
/*++

Routine Description:
    Implementation of Release for interface proxy.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG               count;

    CStdProxyBuffer2 * pSyncPB = (CStdProxyBuffer2 *)
                        ((uchar *)This - offsetof(CStdProxyBuffer2,pRMBVtbl));

    count = pSyncPB->lpVtbl->Release( (IRpcProxyBuffer *)pSyncPB);

    return count;
};


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_RMB_ReleaseMarshalBuffer(
    IN IReleaseMarshalBuffers *This,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwFlags,
    IN IUnknown *pChnl)
{
    CStdProxyBuffer *      pSyncPB;
    HRESULT hr;
    if (NULL != pChnl)
        return E_INVALIDARG;

    // [in] only in client side.
    if (dwFlags)
        return E_INVALIDARG;
             
    hr = NdrpClientReleaseMarshalBuffer(This,
                                        (RPC_MESSAGE *)pMsg, 
                                        dwFlags,
                                        FALSE );    // SYNC 

    return hr;
}

#define IN_BUFFER           0
#define OUT_BUFFER          1

// the pRMBVtbl member is in the same position is both CStdProxyBuffer(2) and 
//     CStdAsyncProxyBuffer so we can cast it anyway.
HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_RMB_ReleaseMarshalBuffer(
    IN IReleaseMarshalBuffers *This,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwIOFlags,
    IN IUnknown *pChnl)
{
    HRESULT hr;
    if (NULL != pChnl)
        return E_INVALIDARG;

    // [in] only in client side.
    if (dwIOFlags != IN_BUFFER)
        return E_INVALIDARG;
             
    hr = NdrpClientReleaseMarshalBuffer(This,
                                        (RPC_MESSAGE *)pMsg, 
                                        dwIOFlags,
                                        TRUE);      // is async

    return hr;
}



HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_Connect(
    IN  IRpcProxyBuffer *   This,
    IN  IRpcChannelBuffer * pChannel)
/*++

Routine Description:
    Connect the proxy to the channel.

Arguments:
    pChannel - Supplies a pointer to the channel.

Return Value:
    S_OK

--*/
{
    CStdProxyBuffer   *     pCThis  = (CStdProxyBuffer *) This;
    HRESULT                 hr;
    IRpcChannelBuffer *     pTemp = 0;

    //
    // Get a pointer to the new channel.
    //
    hr = pChannel->lpVtbl->QueryInterface(
        pChannel, IID_IRpcChannelBuffer, (void **) &pTemp);

    if(hr == S_OK)
    {
        //
        // Save the pointer to the new channel.
        //
        pTemp = (IRpcChannelBuffer *) InterlockedExchangePointer(
            (PVOID *) &pCThis->pChannel, (PVOID) pTemp);

        if(pTemp != 0)
        {
            //
            //Release the old channel.
            //
            pTemp->lpVtbl->Release(pTemp);
            pTemp = 0;
        }
    }
    return hr;
};


HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer_Connect(
    IN  IRpcProxyBuffer *   This,
    IN  IRpcChannelBuffer * pChannel)
/*++

Routine Description:
    Connect the proxy to the channel.

Arguments:
    pChannel - Supplies a pointer to the channel.

Return Value:
    S_OK

--*/
{
    CStdProxyBuffer   *     pCThis  = (CStdProxyBuffer *) This;
    HRESULT                 hr;
    IRpcChannelBuffer *    pTemp = 0;

    // Get a pointer to the new channel.
    // Note, the async proxy is not aggregated with the channel,
    // It simply keeps the channel pointer.
    //
    hr = pChannel->lpVtbl->QueryInterface(
        pChannel, IID_IAsyncRpcChannelBuffer, (void **) &pTemp);

    if(hr == S_OK)
    {
        //
        // Save the pointer to the new channel.
        //
        pTemp = (IRpcChannelBuffer *) InterlockedExchangePointer(
            (PVOID *) &pCThis->pChannel, (PVOID) pTemp);

        if(pTemp != 0)
        {
            //
            //Release the old channel.
            //
            pTemp->lpVtbl->Release(pTemp);
            pTemp = 0;
        }
    }
    return hr;
};



HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_Connect(
    IN  IRpcProxyBuffer *   This,
    IN  IRpcChannelBuffer * pChannel)
/*++

Routine Description:
    Connect the proxy to the channel.  Supports delegation.

Arguments:
    pChannel - Supplies a pointer to the channel.

Return Value:
    S_OK
        E_NOINTERFACE
        E_OUTOFMEMORY

--*/
{
    HRESULT                 hr;
    IRpcProxyBuffer *       pBaseProxyBuffer;
    IRpcChannelBuffer *     pWrapper;
    const IID *             pIID;

    hr = CStdProxyBuffer_Connect(This, pChannel);

    if(SUCCEEDED(hr))
    {
        pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

        if(pBaseProxyBuffer != 0)
        {
           pIID = NdrGetProxyIID(&((CStdProxyBuffer2 *)This)->pProxyVtbl);

            hr = CreateChannelWrapper(pIID,
                                      pChannel,
                                      &pWrapper);
            if(SUCCEEDED(hr))
            {
                hr = pBaseProxyBuffer->lpVtbl->Connect(pBaseProxyBuffer, pWrapper);
                // HACKALERT: OleAutomation returns NULL pv in CreateProxy
                // in cases where they don't know whether to return an NDR
                // proxy or a custom-format proxy. So we have to go connect
                // the proxy first then Query for the real interface once that
                // is done.
                if((NULL == ((CStdProxyBuffer2 *)This)->pBaseProxy) &&
                   SUCCEEDED(hr))
                {
                    IUnknown *pv;

                    hr = pBaseProxyBuffer->lpVtbl->QueryInterface(pBaseProxyBuffer,
                                                                  ((CStdProxyBuffer2 *)This)->iidBase,
                                                                  (void **) &pv);
                    if(SUCCEEDED(hr))
                    {
                        //Release our reference here.
                        pv->lpVtbl->Release(pv);

                        //We keep a weak reference to pv.
                        ((CStdProxyBuffer2 *)This)->pBaseProxy = pv;
                    }
                }
                pWrapper->lpVtbl->Release(pWrapper);
            }
        }
    }

    return hr;
};


HRESULT STDMETHODCALLTYPE
CStdAsyncProxyBuffer2_Connect(
    IN  IRpcProxyBuffer *   This,
    IN  IRpcChannelBuffer * pChannel)
/*++

Routine Description:
    Connect the proxy to the channel.  Supports delegation.

Arguments:
    pChannel - Supplies a pointer to the channel.

Return Value:
    S_OK
        E_NOINTERFACE
        E_OUTOFMEMORY

--*/
{
    HRESULT                 hr;
    IRpcProxyBuffer *       pBaseProxyBuffer;
    IRpcChannelBuffer *     pWrapper;
    const IID *             pIID;

    hr = CStdAsyncProxyBuffer_Connect(This, pChannel);

    if(SUCCEEDED(hr))
    {
        // Note that all the fields from CStdProxyBuffer2 that we indicate below
        // have the same offsets in CStdAsyncProxyBuffer that is being handled.
        // So I leave the cast unchanged to make future code merge easier.
        //
        pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

        if(pBaseProxyBuffer != 0)
        {
            pIID = NdrGetProxyIID(&((CStdProxyBuffer2 *)This)->pProxyVtbl);

            // We need a pChannel that is guaranteed to be IAsyncRpcChannelBuffer -
            // but note, this is exactly what we obtained in the Connect call above.

            hr = CreateAsyncChannelWrapper( pIID,
                                           ((CStdProxyBuffer2*)This)->pChannel,
                                            &pWrapper);
            if(SUCCEEDED(hr))
            {
                hr = pBaseProxyBuffer->lpVtbl->Connect(pBaseProxyBuffer, pWrapper);

                // This hack alert is rather for future.
                // HACKALERT: OleAutomation returns NULL pv in CreateProxy
                // in cases where they don't know whether to return an NDR
                // proxy or a custom-format proxy. So we have to go connect
                // the proxy first then Query for the real interface once that
                // is done.
                if((NULL == ((CStdProxyBuffer2 *)This)->pBaseProxy) &&
                   SUCCEEDED(hr))
                {
                    IUnknown *pv;

                    hr = pBaseProxyBuffer->lpVtbl->QueryInterface(pBaseProxyBuffer,
                                                                  ((CStdProxyBuffer2 *)This)->iidBase,
                                                                  (void **) &pv);
                    if(SUCCEEDED(hr))
                    {
                        //Release our reference here.
                        pv->lpVtbl->Release(pv);

                        //We keep a weak reference to pv.
                        ((CStdProxyBuffer2 *)This)->pBaseProxy = pv;
                    }
                }
                pWrapper->lpVtbl->Release(pWrapper);
            }
        }
    }

    return hr;
};


void STDMETHODCALLTYPE
CStdProxyBuffer_Disconnect(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Disconnect the proxy from the channel.
    
Also used for:
    CStdAsyncProxyBuffer_Disconnect

Arguments:

Return Value:
    None.

--*/
{
    CStdProxyBuffer   * pCThis  = (CStdProxyBuffer *) This;
    IRpcChannelBuffer * pOldChannel;

    pOldChannel = (IRpcChannelBuffer *) InterlockedExchangePointer(
                                        (PVOID *) &pCThis->pChannel, 0);

    if(pOldChannel != 0)
    {
        //Release the old channel.
        //
        pOldChannel->lpVtbl->Release(pOldChannel);
    }
};

void STDMETHODCALLTYPE
CStdProxyBuffer2_Disconnect(
    IN  IRpcProxyBuffer *This)
/*++

Routine Description:
    Disconnect the proxy from the channel.

Also used for:
    CStdAsyncProxyBuffer2_Disconnect

Arguments:

Return Value:
    None.

--*/
{
    IRpcProxyBuffer *pBaseProxyBuffer;

    CStdProxyBuffer_Disconnect(This);

    pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

    if(pBaseProxyBuffer != 0)
        pBaseProxyBuffer->lpVtbl->Disconnect(pBaseProxyBuffer);
};


HRESULT
NdrpCreateNonDelegatedAsyncProxy( 
//CStdProxyBuffer_CreateAsyncProxy(
    IN  IRpcProxyBuffer         *This, 
    IN  REFIID                  riid, // async IID
    IN  IUnknown *              punkOuter, // controlling unknown
    OUT CStdAsyncProxyBuffer ** ppAsyncProxy
    )
/*
    Creates a call object, i.e. an async proxy object.
    An async proxy doesn't have a pSynchronize, just passes it.
    
    Note, because the call comes via a CStdProxyBuffer, not Buffer2,
    we know that we need to create only a non-delegated async proxy.
    This is because CStdProxyBuffer itself is a non-delegated proxy.
*/
{
    BOOL                    fFound;
    long                    j;   // if index
    const ProxyFileInfo *   pProxyFileInfo;

    CStdProxyBuffer *       pSyncPB = (CStdProxyBuffer *)This;

    *ppAsyncProxy = 0;
    
    if ( ! pSyncPB->pCallFactoryVtbl  ||  !pSyncPB->pAsyncIID )
        return E_NOINTERFACE;

    // Check if sync and async iids match.

    if ( memcmp( &riid, pSyncPB->pAsyncIID, sizeof(IID)) != 0 )
        return E_NOINTERFACE;

    // same file, so we can use the sync pPSFactory.

    fFound = NdrpFindInterface( ((CStdPSFactoryBuffer *)pSyncPB->pPSFactory)->pProxyFileList, 
                                riid, 
                                &pProxyFileInfo, 
                                & j);
    if ( !fFound )
        return E_NOINTERFACE;

    CStdAsyncProxyBuffer *pAsyncPB = 
        (CStdAsyncProxyBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdAsyncProxyBuffer));
        
    if( ! pAsyncPB )
        return E_OUTOFMEMORY;

    memset( pAsyncPB, 0, sizeof(CStdAsyncProxyBuffer));
    //
    //  Everything gets zeroed out regardless of their position
    //  when mapping CStdBuffer vs. CstdBuffer2 into CStdAsyncBuffer

    // Non-delegated case.

    pAsyncPB->lpVtbl     = & CStdAsyncProxyBufferVtbl;
    pAsyncPB->pProxyVtbl = & pProxyFileInfo->pProxyVtblList[j]->Vtbl;
    pAsyncPB->RefCount   = 1;
    pAsyncPB->punkOuter  = punkOuter ? punkOuter 
                                     : (IUnknown *) pAsyncPB;
                                         
    pAsyncPB->pSyncIID   = NdrGetProxyIID( &pSyncPB->pProxyVtbl );
    // Note, no connection to channel yet.
    // Actually we never call create call on the channel.
                                  
    NdrpAsyncProxyMsgConstructor( pAsyncPB );

    // Increment the DLL reference count for DllCanUnloadNow.
    // Same dll, so we can use the sync pPSFactory.
    //
    pSyncPB->pPSFactory->lpVtbl->AddRef( pSyncPB->pPSFactory );
    // This is in the "map".
    ((CStdProxyBuffer *)pAsyncPB)->pPSFactory = pSyncPB->pPSFactory;

    // Just have it in both places.
    pAsyncPB->pPSFactory = pSyncPB->pPSFactory;

    *ppAsyncProxy = pAsyncPB;

    return S_OK;
}


HRESULT
// CStdProxyBuffer2_CreateAsyncProxy(
NdrpCreateDelegatedAsyncProxy(
    IN  IRpcProxyBuffer         *This, 
    IN  REFIID                  riid, // async IID
    IN  IUnknown *              punkOuter, // controlling unknown
    OUT CStdAsyncProxyBuffer ** ppAsyncProxy   
    )
/*
    Creates a call object, i.e. an async proxy object.
    
    Note, because the call comes via a CStdProxyBuffer2, not Buffer,
    we know that we need to create only a delegated async proxy.
*/
{
    HRESULT                 hr;
    BOOL                    fFound;
    long                     j;   // if index
    const ProxyFileInfo *   pProxyFileInfo;

    CStdProxyBuffer2 *      pSyncPB = (CStdProxyBuffer2 *)This;
    CStdAsyncProxyBuffer    *pBaseAsyncPB;

    ICallFactory *          pCallFactory;

    *ppAsyncProxy = 0;
    
    if ( ! pSyncPB->pCallFactoryVtbl  ||  !pSyncPB->pAsyncIID )
        return E_NOINTERFACE;

    if ( memcmp( &riid, pSyncPB->pAsyncIID, sizeof(IID)) != 0 )
        return E_NOINTERFACE;

    // same file, so we can use the sync pPSFactory.

    fFound = NdrpFindInterface( ((CStdPSFactoryBuffer *)pSyncPB->pPSFactory)->pProxyFileList, 
                                riid, 
                                &pProxyFileInfo, 
                                & j);
    if ( !fFound )
        return E_NOINTERFACE;

    // Create async proxy.

    CStdAsyncProxyBuffer *pAsyncPB = 
        (CStdAsyncProxyBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdAsyncProxyBuffer));
        
    if( ! pAsyncPB )
        return E_OUTOFMEMORY;

    memset( pAsyncPB, 0, sizeof(CStdAsyncProxyBuffer));
    //
    //  Everything gets zeroed out regardless of their position
    //  when mapping CStdBuffer vs. CstdBuffer2 into CStdAsyncBuffer

    // Fill in for a delegated case.

    pAsyncPB->lpVtbl     = & CStdAsyncProxyBuffer2Vtbl;
    pAsyncPB->pProxyVtbl = & pProxyFileInfo->pProxyVtblList[j]->Vtbl;
    pAsyncPB->RefCount   = 1;
    pAsyncPB->punkOuter  = punkOuter ? punkOuter 
                                     : (IUnknown *) pAsyncPB;
    pAsyncPB->iidBase    = *pProxyFileInfo->pDelegatedIIDs[j];
    pAsyncPB->pPSFactory = pSyncPB->pPSFactory;
    pAsyncPB->pSyncIID   = NdrGetProxyIID( &pSyncPB->pProxyVtbl );
                                 
    // Note, no connection to channel yet.
    // So we cannot call create call on the channel.

    NdrpAsyncProxyMsgConstructor( pAsyncPB );

    // Create an async proxy for the base interface.
    // We don't know if the base is delegated, so we have to use base call factory.
    // Get the call factory from the base proxy.

    hr = pSyncPB->pBaseProxyBuffer->lpVtbl->QueryInterface(
                                                   pSyncPB->pBaseProxyBuffer,
                                                   IID_ICallFactory,
                                                   (void**)& pCallFactory );

    if ( SUCCEEDED(hr) )
        {
        const IID * pBaseAsyncIID;

        pBaseAsyncIID = *(const IID **)( (uchar*)pSyncPB->pBaseProxyBuffer
                                         + offsetof(CStdProxyBuffer, pAsyncIID));

        // Aggregate the base async proxy with the current async proxy,
        // not with the channel's punkOuter.
    
        hr = pCallFactory->lpVtbl->CreateCall( pCallFactory,
                                               *pBaseAsyncIID,
                                               (IUnknown*) pAsyncPB,
                                               IID_IUnknown,
                                               (IUnknown**)& pBaseAsyncPB );
        pCallFactory->lpVtbl->Release( pCallFactory );
        }


    if ( SUCCEEDED(hr) )
        {
        // Increment the DLL reference count for DllCanUnloadNow.
        // Same dll, so we can use the sync pPSFactory.
        //
        pSyncPB->pPSFactory->lpVtbl->AddRef( pSyncPB->pPSFactory );

        // Hook up the base async proxy.
    
        pAsyncPB->pBaseProxyBuffer = (IRpcProxyBuffer*) pBaseAsyncPB;
        pAsyncPB->map.pBaseProxy   = (IUnknown *) & pBaseAsyncPB->pProxyVtbl;

        *ppAsyncProxy = pAsyncPB;
        }
    else
        {
        (*pfnCoTaskMemFree)( pAsyncPB );
        }

    return hr;
}


//
//  ICallFactory interface on the sync ProxyBuffer and ProxyBuffer2 objects.
//

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_CF_QueryInterface(
    IN  ICallFactory   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works the same way for ProxyBuffer2 and AsyncProxyBuffer.
--*/
{
    CStdProxyBuffer * pSyncPB = (CStdProxyBuffer *)
                        ((uchar *)This - offsetof(CStdProxyBuffer,pCallFactoryVtbl));

    return pSyncPB->punkOuter->lpVtbl->QueryInterface( pSyncPB->punkOuter,
                                                       riid,
                                                       ppvObject );
}


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_CF_AddRef(
    IN  ICallFactory *This)
/*++

Routine Description:
    Implementation of AddRef for interface proxy.

Arguments:

Return Value:
    Reference count.
    
--*/
{
    ULONG  count;

    CStdProxyBuffer * pSyncPB = (CStdProxyBuffer *)
                        ((uchar *)This - offsetof(CStdProxyBuffer,pCallFactoryVtbl));

    // It needs to go through punkOuter.

    count = pSyncPB->punkOuter->lpVtbl->AddRef( pSyncPB->punkOuter );
    return count;
};


ULONG STDMETHODCALLTYPE
CStdProxyBuffer_CF_Release(
    IN  ICallFactory *This)
/*++

Routine Description:
    Implementation of Release for interface proxy.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG               count;

    CStdProxyBuffer2 * pSyncPB = (CStdProxyBuffer2 *)
                        ((uchar *)This - offsetof(CStdProxyBuffer2,pCallFactoryVtbl));

    count = pSyncPB->punkOuter->lpVtbl->Release( pSyncPB->punkOuter );

    return count;
};


HRESULT STDMETHODCALLTYPE
CStdProxyBuffer_CF_CreateCall(
    IN  ICallFactory *This, 
    IN  REFIID        riid, 
    IN  IUnknown *    punkOuter, // controlling unknown
    IN  REFIID        riid2, 
    OUT IUnknown **   ppv   
    )
/*
    Creates a call object, i.e. an async proxy object.
    
    Note, because the call comes via a CStdProxyBuffer, not Buffer2,
    we know that we need to create only a non-delegated async proxy.
*/
{
    CStdProxyBuffer * pSyncPB;

    if ( memcmp( &riid2, &IID_IUnknown, sizeof(IID)) != 0 )
        return E_INVALIDARG;
              
    pSyncPB = (CStdProxyBuffer *)
                  (((uchar *)This) - offsetof( CStdProxyBuffer, pCallFactoryVtbl ));
    
    return NdrpCreateNonDelegatedAsyncProxy( (IRpcProxyBuffer*) pSyncPB, 
                                      riid,
                                      punkOuter,
                                      (CStdAsyncProxyBuffer**) ppv );
}

HRESULT STDMETHODCALLTYPE
CStdProxyBuffer2_CF_CreateCall(
    IN  ICallFactory *This, 
    IN  REFIID        riid, 
    IN  IUnknown *    punkOuter, // controlling unknown
    IN  REFIID        riid2, 
    OUT IUnknown **   ppv   
    )
/*
    Creates a call object, i.e. an async proxy object.

    Note, because the virtual call comes via a CStdProxyBuffer2,
    we know that we need to create only a delegated async proxy.
*/
{
    CStdProxyBuffer2 *      pSyncPB;

    if ( memcmp( &riid2, &IID_IUnknown, sizeof(IID)) != 0 )
        return E_INVALIDARG;
              
    pSyncPB = (CStdProxyBuffer2 *)
                  (((uchar *)This) - offsetof( CStdProxyBuffer2, pCallFactoryVtbl ));

    return NdrpCreateDelegatedAsyncProxy( (IRpcProxyBuffer*) pSyncPB, 
                                          riid,
                                          punkOuter,
                                          (CStdAsyncProxyBuffer**) ppv );
}
/*
HRESULT STDAPICALLTYPE
NdrClientReleaseMarshalBuffer(
    IN IRpcProxyBuffer *pProxy,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwFlags,
    IN IUnknown *pChnl)
{
    CStdProxyBuffer *      pSyncPB;
    void * This = NULL;
    HRESULT hr;

    if (NULL != pChnl)
        return E_INVALIDARG;

    if (dwFlags)
        return E_INVALIDARG;

    hr = pProxy->lpVtbl->QueryInterface(pProxy,&IID_IReleaseMarshalBuffers, &This);
    if (FAILED(hr))
        return E_NOTIMPL;
             
    pSyncPB = (CStdProxyBuffer *)
                  (((uchar *)This) - offsetof( CStdProxyBuffer, lpVtbl ));

    hr = NdrpClientReleaseMarshalBuffer(pSyncPB,(RPC_MESSAGE *)pMsg, dwFlags);
    ((IRpcProxyBuffer *)This)->lpVtbl->Release(This);

    return hr;
}

*/

//
//   IUknown Query, AddRef and Release.
//
HRESULT STDMETHODCALLTYPE
IUnknown_QueryInterface_Proxy(
    IN  IUnknown *  This,
    IN  REFIID      riid,
    OUT void **     ppv)
/*++

Routine Description:
    Implementation of QueryInterface for interface proxy.

Arguments:
    riid - Supplies the IID of the requested interface.
    ppv  - Returns a pointer to the requested interface.

Return Value:
    S_OK
        E_NOINTERFACE

--*/
{
    HRESULT             hr = E_NOINTERFACE;
    CStdProxyBuffer *   pProxyBuffer;

    pProxyBuffer = NdrGetProxyBuffer(This);

    hr = pProxyBuffer->punkOuter->lpVtbl->QueryInterface(
                                pProxyBuffer->punkOuter, riid, ppv);

    return hr;
};


ULONG STDMETHODCALLTYPE
IUnknown_AddRef_Proxy(
    IN  IUnknown *This)
/*++

Routine Description:
    Implementation of AddRef for interface proxy.

Arguments:

Return Value:
    Reference count.

--*/
{
    CStdProxyBuffer *   pProxyBuffer;
    ULONG               count;

    pProxyBuffer = NdrGetProxyBuffer(This);
    count = pProxyBuffer->punkOuter->lpVtbl->AddRef(pProxyBuffer->punkOuter);

    return count;
};


ULONG STDMETHODCALLTYPE
IUnknown_Release_Proxy(
    IN  IUnknown *This)
/*++

Routine Description:
    Implementation of Release for interface proxy.

Arguments:

Return Value:
    Reference count.

--*/
{
    CStdProxyBuffer *   pProxyBuffer;
    ULONG               count;

    pProxyBuffer = NdrGetProxyBuffer(This);
    count = pProxyBuffer->punkOuter->lpVtbl->Release(pProxyBuffer->punkOuter);

    return count;
};



void RPC_ENTRY
NdrProxyInitialize(
    IN  void * pThis,
    IN  PRPC_MESSAGE        pRpcMsg,
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PMIDL_STUB_DESC     pStubDescriptor,
    IN  unsigned int        ProcNum )
/*++

Routine Description:
    Initialize the MIDL_STUB_MESSAGE.

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pRpcMsg
        pStubMsg
        pStubDescriptor
        ProcNum

Return Value:

--*/
{
    CStdProxyBuffer *   pProxyBuffer;
    HRESULT             hr;

    pProxyBuffer = NdrGetProxyBuffer(pThis);

    //
    // Initialize the stub message fields.
    //
    NdrClientInitializeNew(
        pRpcMsg,
        pStubMsg,
        pStubDescriptor,
        ProcNum );

    //Note that NdrClientInitializeNew sets RPC_FLAGS_VALID_BIT in the ProcNum.
    //We don't want to do this for object interfaces, so we clear the flag here.
    pRpcMsg->ProcNum &= ~RPC_FLAGS_VALID_BIT;

    pStubMsg->pRpcChannelBuffer = pProxyBuffer->pChannel;

    //Check if we are connected to a channel.
    if(pStubMsg->pRpcChannelBuffer != 0)
    {
        //AddRef the channel.
        //We will release it later in NdrProxyFreeBuffer.
        pStubMsg->pRpcChannelBuffer->lpVtbl->AddRef(pStubMsg->pRpcChannelBuffer);

        //Get the destination context from the channel
        hr = pStubMsg->pRpcChannelBuffer->lpVtbl->GetDestCtx(
            pStubMsg->pRpcChannelBuffer, &pStubMsg->dwDestContext, &pStubMsg->pvDestContext);
    }
    else
    {
        //We are not connected to a channel.
        RpcRaiseException(CO_E_OBJNOTCONNECTED);
    }
}


void RPC_ENTRY
NdrProxyGetBuffer(
    IN  void *              pThis,
    IN  PMIDL_STUB_MESSAGE  pStubMsg)
/*++

Routine Description:
    Get a message buffer from the channel

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pStubMsg

Return Value:
    None.  If an error occurs, this function will raise an exception.

--*/
{
    HRESULT     hr;

    const IID * pIID = NdrGetProxyIID(pThis);
    LENGTH_ALIGN(pStubMsg->BufferLength, 3);
    pStubMsg->RpcMsg->BufferLength = pStubMsg->BufferLength;
    pStubMsg->RpcMsg->DataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;
    pStubMsg->dwStubPhase = PROXY_GETBUFFER;

    hr = pStubMsg->pRpcChannelBuffer->lpVtbl->GetBuffer(
        pStubMsg->pRpcChannelBuffer,
        (RPCOLEMESSAGE *) pStubMsg->RpcMsg,
        *pIID);

    pStubMsg->dwStubPhase = PROXY_MARSHAL;

    if(FAILED(hr))
    {
        RpcRaiseException(hr);
    }
    else
    {
        NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                    "marshaling buffer misaligned" );

        pStubMsg->Buffer = (unsigned char *) pStubMsg->RpcMsg->Buffer;
        pStubMsg->fBufferValid = TRUE;
    }
}


void RPC_ENTRY
NdrProxySendReceive(
    IN  void *              pThis,
    IN  MIDL_STUB_MESSAGE * pStubMsg)
/*++

Routine Description:
    Send a message to server, then wait for reply message.

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pStubMsg

Return Value:
        None.  If an error occurs, this function will raise an exception.

--*/
{
    HRESULT hr;
    DWORD   dwStatus;

    //Calculate the number of bytes to send.

    if ( pStubMsg->RpcMsg->BufferLength <
            (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer))
        {
        NDR_ASSERT( 0, "NdrProxySendReceive : buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    pStubMsg->RpcMsg->BufferLength = (ulong)( pStubMsg->Buffer -
                                   (unsigned char *) pStubMsg->RpcMsg->Buffer );

    pStubMsg->fBufferValid = FALSE;
    pStubMsg->dwStubPhase = PROXY_SENDRECEIVE;

    hr = pStubMsg->pRpcChannelBuffer->lpVtbl->SendReceive(
        pStubMsg->pRpcChannelBuffer,
        (RPCOLEMESSAGE *) pStubMsg->RpcMsg, &dwStatus);

    pStubMsg->dwStubPhase = PROXY_UNMARSHAL;

    if(FAILED(hr))
    {
        switch(hr)
        {
        case RPC_E_FAULT:
            RpcRaiseException(dwStatus);
            break;

        default:
            RpcRaiseException(hr);
            break;
        }
    }
    else
    {
        NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                    "marshaling buffer misaligned" );

        pStubMsg->Buffer = (uchar*)pStubMsg->RpcMsg->Buffer;
        pStubMsg->BufferStart = pStubMsg->Buffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pStubMsg->RpcMsg->BufferLength;
        pStubMsg->fBufferValid = TRUE;
    }
}


void RPC_ENTRY
NdrProxyFreeBuffer(
    IN  void *              pThis,
    IN  MIDL_STUB_MESSAGE * pStubMsg)
/*++

Routine Description:
    Free the message buffer.

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pStubMsg

Return Value:
    None.

--*/
{
    if(pStubMsg->pRpcChannelBuffer != 0)
    {
        //Free the message buffer.
        if(pStubMsg->fBufferValid == TRUE)
            {
            // If pipes, we need to reset the partial bit for some reason.

            pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;

            pStubMsg->pRpcChannelBuffer->lpVtbl->FreeBuffer(
                pStubMsg->pRpcChannelBuffer, (RPCOLEMESSAGE *) pStubMsg->RpcMsg);
            }

        //Release the channel.
        pStubMsg->pRpcChannelBuffer->lpVtbl->Release(pStubMsg->pRpcChannelBuffer);
        pStubMsg->pRpcChannelBuffer = 0;
    }
}

HRESULT RPC_ENTRY
NdrProxyErrorHandler(
    IN  DWORD dwExceptionCode)
/*++

Routine Description:
    Maps an exception code into an HRESULT failure code.

Arguments:
    dwExceptionCode

Return Value:
   This function returns an HRESULT failure code.

--*/
{
    HRESULT hr = dwExceptionCode;

    if(FAILED((HRESULT) dwExceptionCode))
        hr = (HRESULT) dwExceptionCode;
    else
        hr = HRESULT_FROM_WIN32(dwExceptionCode);

    return hr;
}


HRESULT STDMETHODCALLTYPE
CreateChannelWrapper
/*++

Routine Description:
    Creates a wrapper for the channel.  The wrapper ensures
        that we use the correct IID when the proxy for the base
        interface calls GetBuffer.

Arguments:
    pIID
        pChannel
        pChannelWrapper

Return Value:
    S_OK
        E_OUTOFMEMORY

--*/
(
    const IID *             pIID,
    IRpcChannelBuffer *     pChannel,
    IRpcChannelBuffer **    ppChannelWrapper
)
{
    HRESULT hr;
    ChannelWrapper *pWrapper = 
        (ChannelWrapper*)(*pfnCoTaskMemAlloc)(sizeof(ChannelWrapper));

    if(pWrapper != 0)
    {
        hr = S_OK;
        pWrapper->lpVtbl = (IRpcChannelBufferVtbl*) &ChannelWrapperVtbl;
        pWrapper->RefCount = 1;
        pWrapper->pIID = pIID;
        pChannel->lpVtbl->AddRef(pChannel);
        pWrapper->pChannel = pChannel;
        *ppChannelWrapper = (IRpcChannelBuffer *) pWrapper;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppChannelWrapper = 0;
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
CreateAsyncChannelWrapper
/*++

Routine Description:
    Creates a wrapper for the channel.  The wrapper ensures
        that we use the correct IID when the proxy for the base
        interface calls GetBuffer.

Arguments:
    pIID
        pChannel
        pChannelWrapper

Return Value:
    S_OK
        E_OUTOFMEMORY

--*/
(
    const IID *             pIID,
    IRpcChannelBuffer *     pChannel,
    IRpcChannelBuffer **    ppChannelWrapper
)
{
    HRESULT hr;
    ChannelWrapper *pWrapper = 
        (ChannelWrapper*)(*pfnCoTaskMemAlloc)(sizeof(ChannelWrapper));

    if(pWrapper != 0)
    {
        hr = S_OK;
        pWrapper->lpVtbl = (IRpcChannelBufferVtbl*) &AsyncChannelWrapperVtbl;
        pWrapper->RefCount = 1;
        pWrapper->pIID = pIID;
        pChannel->lpVtbl->AddRef(pChannel);
        pWrapper->pChannel = pChannel;
        *ppChannelWrapper = (IRpcChannelBuffer *) pWrapper;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppChannelWrapper = 0;
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_QueryInterface
/*++

Routine Description:
    The channel wrapper supports the IUnknown and IRpcChannelBuffer interfaces.

Arguments:
    riid
        ppvObject

Return Value:
    S_OK
        E_NOINTERFACE

--*/
(
    IRpcChannelBuffer3 * This,
    REFIID riid,
    void **ppvObject
)
{
    HRESULT hr;

    if((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer2, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer3, sizeof(IID)) == 0))
    {
        hr = S_OK;
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = 0;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_QueryInterface
/*++

Routine Description:
    The channel wrapper supports the IUnknown and IRpcChannelBuffer interfaces.

Arguments:
    riid
        ppvObject

Return Value:
    S_OK
        E_NOINTERFACE

--*/
    (
    IAsyncRpcChannelBuffer *    This,
    REFIID                      riid,
    void **                     ppvObject
    )
{
    HRESULT hr;

    if((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcChannelBuffer2, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IAsyncRpcChannelBuffer, sizeof(IID)) == 0))
    {
        hr = S_OK;
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppvObject = 0;
    }

    return hr;
}


ULONG STDMETHODCALLTYPE
ChannelWrapper_AddRef
/*++

Routine Description:
    Increment reference count.

Arguments:

Return Value:
    Reference count.

--*/
(
    IRpcChannelBuffer3 * This
)
{
    ChannelWrapper *pWrapper = (ChannelWrapper *) This;

    InterlockedIncrement(&pWrapper->RefCount);

    return (ULONG) pWrapper->RefCount;

}

ULONG STDMETHODCALLTYPE
AsyncChannelWrapper_AddRef(
    IAsyncRpcChannelBuffer * This
    )
{
    return ChannelWrapper_AddRef( (IRpcChannelBuffer3 *) This );
}


ULONG STDMETHODCALLTYPE
ChannelWrapper_Release
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
(
    IRpcChannelBuffer3 * This
)
{
    unsigned long           count;
    IRpcChannelBuffer *     pChannel;

    NDR_ASSERT(((ChannelWrapper *)This)->RefCount > 0, "Invalid reference count");

    count = (unsigned long) ((ChannelWrapper *)This)->RefCount - 1;

    if(InterlockedDecrement(&((ChannelWrapper *)This)->RefCount) == 0)
    {
        count = 0;

        pChannel = ((ChannelWrapper *)This)->pChannel;

        if(pChannel != 0)
            pChannel->lpVtbl->Release(pChannel);

#if DBG == 1
        //In debug builds, zero fill the memory.
        memset(This,  '\0', sizeof(ChannelWrapper));
#endif

        //Free the memory
        (*pfnCoTaskMemFree)(This);
    }

    return count;
}

ULONG STDMETHODCALLTYPE
AsyncChannelWrapper_Release(
    IAsyncRpcChannelBuffer * This
    )
{
    return ChannelWrapper_Release( (IRpcChannelBuffer3 *) This );
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetBuffer
/*++

Routine Description:
    Get a message buffer from the channel.
    
    This is the reason we have the ChannelWrapper at all.
    We replace the riid of the current proxy by the one from the Wrapper.

Arguments:
    pMessage
        riid

Return Value:

--*/
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *      pMessage,
    REFIID               riid
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;
    const IID *         pIID;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    pIID = ((ChannelWrapper *)This)->pIID;

    hr = pChannel->lpVtbl->GetBuffer(pChannel,
                                     pMessage,
                                     *pIID);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetBuffer(
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *      pMessage,
    REFIID               riid
    )
{
    return ChannelWrapper_GetBuffer( (IRpcChannelBuffer3 *) This,
                                     pMessage,
                                     riid );
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_SendReceive
/*++

Routine Description:
    Get a message buffer from the channel

Arguments:
    pMessage
        pStatus

Return Value:
    S_OK

--*/
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *      pMessage,
    ULONG *              pStatus
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->SendReceive(pChannel,
                                       pMessage,
                                       pStatus);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_SendReceive(
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *      pMessage,
    ULONG *              pStatus
    )
{
    // This can never happen for an async call stub.
    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_FreeBuffer
/*++

Routine Description:
    Free the message buffer.

Arguments:
    pMessage

Return Value:
    S_OK

--*/
(
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *pMessage
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->FreeBuffer(pChannel,
                                      pMessage);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_FreeBuffer(
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *         pMessage
    )
{
    return ChannelWrapper_FreeBuffer( (IRpcChannelBuffer3 *) This,
                                      pMessage );
}



HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetDestCtx
/*++

Routine Description:
    Get the destination context from the channel

Arguments:
    pdwDestContext
        ppvDestContext

Return Value:
    S_OK

--*/
(
    IRpcChannelBuffer3 * This,
    DWORD              * pdwDestContext,
    void              ** ppvDestContext
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->GetDestCtx(pChannel,
                                      pdwDestContext,
                                      ppvDestContext);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetDestCtx(
    IAsyncRpcChannelBuffer * This,
    DWORD *                 pdwDestContext,
    void **                 ppvDestContext
    )
{
    return ChannelWrapper_GetDestCtx( (IRpcChannelBuffer3 *) This,
                                      pdwDestContext,
                                      ppvDestContext );
}



HRESULT STDMETHODCALLTYPE
ChannelWrapper_IsConnected
/*++

Routine Description:
    Determines if the channel is connected.

Arguments:

Return Value:
    S_TRUE
        S_FALSE

--*/
(
    IRpcChannelBuffer3 * This
)
{
    HRESULT             hr;
    IRpcChannelBuffer * pChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->IsConnected(pChannel);
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_IsConnected(
    IAsyncRpcChannelBuffer * This
    )
{
    return ChannelWrapper_IsConnected( (IRpcChannelBuffer3 *) This );
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetProtocolVersion
/*++

Routine Description:
    Returns the protocol version if available.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
(
    IRpcChannelBuffer3 * This,
    DWORD             * pdwVersion
)
{
    HRESULT             hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer2 * pChannel2;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer2, (void**)&pChannel2);
    if (S_OK == hr)
    {
        hr = pChannel2->lpVtbl->GetProtocolVersion(pChannel2, pdwVersion);
        pChannel2->lpVtbl->Release(pChannel2);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetProtocolVersion(
    IAsyncRpcChannelBuffer * This,
    DWORD                  * pdwVersion
    )
{
    return ChannelWrapper_GetProtocolVersion( (IRpcChannelBuffer3 *) This,
                                              pdwVersion );
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_Send
/*++

Routine Description:
    Executes an asynchronous or partial send.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    (
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG *             pStatus 
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface( pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3 );
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->Send(pChannel3, pMessage, pStatus);
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_Send(
/*++

Routine Description:
    Executes an asynchronous or partial send.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *         pMessage,
    ISynchronize *          pSynchronize,
    ULONG *                 pStatus 
    )
{
    HRESULT                  hr;
    IRpcChannelBuffer  *     pChannel;
    IAsyncRpcChannelBuffer * pAsChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface( pChannel, 
                                           IID_IAsyncRpcChannelBuffer, 
                                           (void**)&pAsChannel );
    if (S_OK == hr)
    {
        hr = pAsChannel->lpVtbl->Send( pAsChannel, 
                                       pMessage, 
                                       pSynchronize,
                                       pStatus);
        pAsChannel->lpVtbl->Release( pAsChannel);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_Receive
/*++

Routine Description:
    Executes an asynchronous or partial receive.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    (
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG               ulSize,
    ULONG *             pStatus 
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->Receive( pChannel3, pMessage, ulSize, pStatus );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_Receive(
/*++

Routine Description:
    Executes an asynchronous or partial receive.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *     pMessage,
    ULONG *             pStatus 
    )
{
    HRESULT                 hr;
    IRpcChannelBuffer  *    pChannel;
    IAsyncRpcChannelBuffer *pAsChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface( pChannel, 
                                           IID_IAsyncRpcChannelBuffer, 
                                           (void**)&pAsChannel);
    if (S_OK == hr)
    {
        hr = pAsChannel->lpVtbl->Receive( pAsChannel, 
                                          pMessage, 
                                          pStatus );
        pAsChannel->lpVtbl->Release(pAsChannel);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_Cancel(
/*++

Routine Description:
    Executes an asynchronous Cancel.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->Cancel( pChannel3, pMessage );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetCallContext(
/*++

Routine Description:
    Gets an asynchronous call context.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    REFIID              riid,
    void    **          ppInterface
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->GetCallContext( pChannel3, pMessage, riid, ppInterface );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
AsyncChannelWrapper_GetDestCtxEx(
/*++

Routine Description:
    Gets an asynchronous call context.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IAsyncRpcChannelBuffer * This,
    RPCOLEMESSAGE *         pMessage,
    DWORD *                 pdw,
    void **                 ppv
    )
{
    HRESULT                     hr;
    IRpcChannelBuffer  *        pChannel;
    IAsyncRpcChannelBuffer *    pAsChannel;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface( pChannel, 
                                           IID_IAsyncRpcChannelBuffer, 
                                           (void**)&pAsChannel);
    if (S_OK == hr)
    {
        hr = pAsChannel->lpVtbl->GetDestCtxEx( pAsChannel, 
                                               pMessage, 
                                               pdw, 
                                               ppv );
        pAsChannel->lpVtbl->Release(pAsChannel);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetDestCtxEx(
/*++

Routine Description:
    Gets the new destination context.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    DWORD *             pdwDestContext,
    void **             ppvDestContext
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->GetDestCtxEx( pChannel3, pMessage, pdwDestContext, ppvDestContext );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
ChannelWrapper_GetState(
/*++

Routine Description:
    Gets the call state.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    DWORD         *     pState
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->GetState( pChannel3, pMessage, pState );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE
ChannelWrapper_RegisterAsync(
/*++

Routine Description:
    Registers the async manager object and call with the channel.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE
--*/
    IRpcChannelBuffer3 * This,
    RPCOLEMESSAGE *     pMessage,
    IAsyncManager *     pAsyncMgr
    )
{
    HRESULT              hr;
    IRpcChannelBuffer  * pChannel;
    IRpcChannelBuffer3 * pChannel3;

    pChannel = ((ChannelWrapper *)This)->pChannel;
    hr = pChannel->lpVtbl->QueryInterface(pChannel, IID_IRpcChannelBuffer3, (void**)&pChannel3);
    if (S_OK == hr)
    {
        hr = pChannel3->lpVtbl->RegisterAsync( pChannel3, pMessage, pAsyncMgr );
        pChannel3->lpVtbl->Release(pChannel3);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\round.cxx ===
/* file:  round.c */

/*
**
**                         COPYRIGHT (c) 1989 BY
**           DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.
**                          ALL RIGHTS RESERVED.
**
**  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED
**  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE
**  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER
**  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
**  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY
**  TRANSFERRED.
**
**  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE
**  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT
**  CORPORATION.
**
**  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS
**  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
**
*/

/*
**++
**  Facility:
**
**      CVT Run-Time Library
**
**  Abstract:
**
**      This module is an include file.
**
**      This module rounds CVT floating point data to any specified position.
**      Any of the following rounding modes can be applied:
**
**      Note: None of the following implementations ever perform true truncation
**            on their values.  Whenever truncation becomes necessary - either
**            by being specified directly or by being required indirectly
**            through rounding - values are actually left untouched.  Users
**            of this routine must zero out fractional fields themselves if
**            true truncation is needed.
**
**         VAX ROUNDING
**
**              Input data are rounded such that the representable value nearest
**              the infinitely precise result is delivered; if two representable
**              values are equally near, the one greatest in magnitude is
**              delivered.
**
**         ROUND TO NEAREST
**
**              Input data are rounded such that the representable value nearest
**              the infinitely precise result is delivered; if two representable
**              values are equally near, the one with its least significant bit
**              zero is delivered.
**
**         ROUND TO POSITIVE INFINITY
**
**              Input data are rounded such that the representable value closest
**              to and no less than the infinitely precise result is delivered.
**
**         ROUND TO NEGATIVE INFINITY
**
**              Input data are rounded such that the representable value closest
**              to and no greater than the infinitely precise result is
**              delivered.
**
**         TRUNCATION (ROUND TOWARDS ZERO)
**
**              True truncation is not implemented here.  Input values are
**              delivered in their original, untouched form.
**
**              A definition of "true" truncation follows:  Truncation, or
**              rounding towards zero, implies input data are rounded such
**              that the representable value closest to and no greater in
**              magnitude than the infinitely precise result is delivered.
**
**  Authors:
**
**      Math RTL
**
**  Creation Date:     December 5, 1989.
**
**  Modification History:
**
**      1-001   Original created.
**              MRTL 5-Dec-1989.
**
**--
*/

/*
**
**  Implicit input/output:
**
**      r                       On input, a valid CVT floating point number.
**                              On output, a rounded representation of the
**                              input.
**
**
**  Implicit input:
**
**      round_bit_position      An integer specifying the position to round to.
**                              0 <= round_bit_position <= 127.
**
**                              Note: Valid CVT mantissa bits are addressed as 1
**                              through 128.  Accordingly, specifying 0 as a
**                              position to round to implies an exponent
**                              increase whenever rounding occurs.  As for
**                              truncation: truncation allways leaves a CVT
**                              number untouched.
**
**      options                 A valid CVT options bit mask in which at least
**                              one, and only one, CVT rounding mode is
**                              specified.  If no rounding mode is specified,
**                              results are unpredictable.  Rounding is
**                              performed in accordance with this mask.
**
**      i                       An uninitialized integer used for indexing.
**
**
**  Note: for efficiency this routine performs no explicit error checking.
**
*/


{
  int roundup, more_bits;
  unsigned long  bit_mask;


      /* Check TRUNCATE option */

  if ( ! (options & CVT_C_TRUNCATE) ) {

           /* Determine which word the round bit resides in */

      i = (round_bit_position >> 5) + 1;

           /* Create a mask isolating the round bit */

      bit_mask = 0x1L << (31 - (round_bit_position & 0x1FL));

           /* Check VAX ROUNDING option */

      if (options & CVT_C_VAX_ROUNDING)
          roundup = r[i] & bit_mask;

      else {
          roundup = 0;
          switch ( r[i] & bit_mask ) {

                /* If round bit is clear, and ROUND TO NEAREST option */
                /* is selected we truncate */

          case  0 : if (options & CVT_C_ROUND_TO_NEAREST)
                      break;

                /* Otherwise, make note of wheather there are any bits set */
                /* after the round bit, and then check the remaining cases */

          default : if ( ! (more_bits = r[i] & (bit_mask - 1)) )
                      switch ( i ) {
                        case  1 : more_bits = r[2];
                        case  2 : more_bits |= r[3];
                        case  3 : more_bits |= r[4];
                        default : break;
                      }

                /* Re-check ROUND TO NEAREST option.  NOTE: if we've reached  */
                /* this point and ROUND TO NEAREST has been selected, the     */
                /* round bit is set. */

                    if (options & CVT_C_ROUND_TO_NEAREST) {
                        if ( ! ( roundup = more_bits ) )
                            if ( bit_mask << 1 )
                               roundup = r[i] & (bit_mask << 1);
                            else if (i != 1)
                               roundup = r[i-1] & 1;

                /* Check ROUND TO POSITIVE INFINITY option */

                    } else if (options & CVT_C_ROUND_TO_POS) {
                        if ( !(r[U_R_FLAGS] & U_R_NEGATIVE) )
                          roundup = (r[i] & bit_mask) | more_bits;

                /* Check ROUND TO NEGITIVE INFINITY option */

                    } else if (r[U_R_FLAGS] & U_R_NEGATIVE)
                        roundup = (r[i] & bit_mask) | more_bits;
          }
      }


      if ( roundup ) {          /* Perform rounding if necessary */

               /* Add 1 at round position */

         bit_mask <<= 1;
         r[i] = (r[i] & ~(bit_mask - 1)) + bit_mask;

               /* Propagate any carry */

         while ( ! r[i] )
           r[--i] += 1;

               /* If carry reaches exponent MSB gets zeroed and must be reset */

         if ( ! i )
           r[1] = 0x80000000L;
      }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\rpcssm.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name:

    rpcssm.cxx

Abstract:

    RpcS* memory package routines are implemented here.
    These corespond to DCE rpc_ss_* and rpc_sm_* routines.

Author:

    Michael Montague (mikemon) 12-Apr-1993

Revision History:

    Ryszardk    Nov 30, 1993    added rpc_sm_* package,
                                rewrote rpc_ss_* package

-------------------------------------------------------------------*/

#include <assert.h>
#include <ndrp.h>           // rpcndr.h and  NDR_ASSERT

void NdrRpcDeleteAllocationContext();
void ForceNdrCleanupSegIntoMemory();
#include "util.hxx"
#include "rpcssm.hxx"


// =======================================================================
//      RpcSs Package
// =======================================================================

// This structure is being initialized with (plain) malloc and free
// by an assignement in NdrClientInitializeNew.
// It is used only by the client side.
// We need a pointer, too, because of a C compiler problem on Dos.

MALLOC_FREE_STRUCT      RpcSsDefaults = { 0, 0 };
MALLOC_FREE_STRUCT   * pRpcSsDefaults = &RpcSsDefaults;


EXTERN_C void NdrpSetRpcSsDefaults(RPC_CLIENT_ALLOC *pfnAlloc,
                      RPC_CLIENT_FREE *pfnFree)
{
    pRpcSsDefaults->pfnAllocate = pfnAlloc;
    pRpcSsDefaults->pfnFree     = pfnFree;
}

// These are default allocator and deallocator used by the client side
// when the memory package hasn't been enabled. They map to C-runtime
// malloc and free.
// When the client side executes in an enabled environment, the client
// doesn't use these two routines; instead, it uses the same default
// allocator that the server does (NdrRpcSsDefaultAllocate/Free).
// Those map into I_RpcAllocate/I_RpcFree, and those in turn map into
// system Rtl* routines.

static void * __RPC_API
DefaultAllocate (
    IN size_t Size
    )
{
    if ( RpcSsDefaults.pfnAllocate == NULL )
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

    return( RpcSsDefaults.pfnAllocate( Size ) ) ;
}

static void __RPC_API
DefaultFree (
    IN void * Ptr
    )
{
    if ( RpcSsDefaults.pfnFree == NULL )
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );

    RpcSsDefaults.pfnFree( Ptr );
}

// -----------------------------------------------------------------


PALLOCATION_CONTEXT
GetCreateAllocationContext (
    )
/*++

Return Value:

    The allocation information for this thread is returned.  If there is
    no allocation information context for this thread, one gets allocated.
    If there is insufficient memory, an exception is raised.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.

Notes.

    pBlocDescr == 0  means that the memory package is disabled.

--*/
{
    PALLOCATION_CONTEXT  AllocationContext =  GetAllocContext();;

    if ( AllocationContext == 0 )
        {
        if ( NdrpPerformRpcInitialization() == RPC_S_OK )
            {
            AllocationContext = (PALLOCATION_CONTEXT)
                            I_RpcAllocate( sizeof(ALLOCATION_CONTEXT) );
            }

        if ( AllocationContext == 0 )
            {
            RpcRaiseException(RPC_S_OUT_OF_MEMORY);
            }

        InitializeCriticalSection( &(AllocationContext->CriticalSection) );
        AllocationContext->ClientAlloc = DefaultAllocate;
        AllocationContext->ClientFree  = DefaultFree;
        AllocationContext->EnableCount = 0;

        SYSTEM_INFO   SystemInfo;

        AllocationContext->ThreadCount = 1;
        AllocationContext->pInitialStacks = 0;
        AllocationContext->pEnableStack = 0;
        AllocationContext->pBlockDescr = 0;
        GetSystemInfo( &SystemInfo );
        AllocationContext->PageSize = SystemInfo.dwPageSize;
        AllocationContext->Granularity = SystemInfo.dwAllocationGranularity;

        SetAllocContext( AllocationContext );   // Tls
        }

    return( AllocationContext );
}


// -----------------------------------------------------------------

void *
FindBlockForTheChunk(
    PALLOCATION_CONTEXT AllocationContext,
    size_t       Size )
/*++

Routine Description:

    This routine returns the pointer to the allocated chunk of memory.
    If it cannot allocate a chunk it returns NULL.
    This is used only in Win32 version.

Note:

    This is called within the critical section.

--*/
{
    char *              AllocationBlock;
    DWORD               SizeToAllocate;
    unsigned long       i, BlockSize;
    PALLOC_BLOCK_DESCR  pDescrTemp;
    char *              pChunk;

    // Round the size to a multiple of 8, so that
    // each memory chunk is always on an aligned by 8 boundary.

    Size = ALIGN_TO_8( Size );

    // If the size is 0, allocate 8 bytes anyways to guarantee uniqueness
    // and to prevent aliasing problems.

    if ( Size == 0 )
        Size = 8;

    // See if the chunk can be allocated within an existing block.
    // We use the first fit algorithm to do that.

    BlockSize = AllocationContext->PageSize;

    if ( Size < BlockSize )
        {
        for ( i = 0;  i < AllocationContext->FFIndex; i++ )
            {
            pDescrTemp = & AllocationContext->pBlockDescr[i];
            if ( pDescrTemp->SizeLeft >= Size )
                {
                pChunk = pDescrTemp->FirstFree;
                pDescrTemp->FirstFree += Size;
                pDescrTemp->SizeLeft  -= Size;

                #if defined( DEBUGRPC )
                    pDescrTemp->Counter ++;
                #endif

                return( pChunk );
                }
            }
        // Doesn't fit anywhere: allocate a new block.

        SizeToAllocate = BlockSize;
        }
    else
        {
        // Size is too big to fit in leftovers.
        // Round it up to the block size boundary.

        size_t Alignment = BlockSize - 1;

        SizeToAllocate = (Size + Alignment) & ~Alignment;
        }

    //
    // Being here means a need to allocate a new block of pages.
    //

    if ( AllocationContext->FFIndex >= AllocationContext->DescrSize )
        {
        // need to reallocate the array of descriptors first.

        size_t NewDescrSize = AllocationContext->DescrSize +
                                        DESCR_ARRAY_INCR;
        pDescrTemp = (PALLOC_BLOCK_DESCR)
                     I_RpcAllocate( NewDescrSize * sizeof( ALLOC_BLOCK_DESCR ));
        if ( pDescrTemp == 0 )
            {
            return( NULL );
            }

        RpcpMemoryCopy( pDescrTemp,
                        AllocationContext->pBlockDescr,
                        (size_t)(AllocationContext->FFIndex
                                            * sizeof( ALLOC_BLOCK_DESCR )) );

        if ( AllocationContext->pBlockDescr !=
                AllocationContext->pInitialStacks->DescrStack )
            I_RpcFree( AllocationContext->pBlockDescr );

        AllocationContext->pBlockDescr = pDescrTemp;
        AllocationContext->DescrSize = NewDescrSize;
        }

    // Now allocate the new block.

    AllocationBlock = (char *) VirtualAlloc( NULL,  // new pages
                                             SizeToAllocate,
                                             MEM_COMMIT,
                                             PAGE_READWRITE );
    if ( AllocationBlock == 0 )
        {
        return( NULL );
        }

    NDR_ASSERT( ((ULONG_PTR)AllocationBlock & 0x7) == 0,
                "buffer alignment error at allocation time" );

    pDescrTemp = & AllocationContext->pBlockDescr[ AllocationContext->FFIndex ];
    pDescrTemp->AllocationBlock = AllocationBlock;
    pDescrTemp->FirstFree = AllocationBlock + Size;
    pDescrTemp->SizeLeft  = SizeToAllocate - Size;

    #if defined( DEBUGRPC )
        pDescrTemp->Counter = 1;
    #endif

    AllocationContext->FFIndex++;

    return( AllocationBlock );
}


void * RPC_ENTRY
RpcSsAllocate (
    IN size_t Size
    )
/*++

Routine Description:

    Allocate memory within the allocation context fot the thread. A call to
    RpcSsEnableAllocate sets up an allocation context for the calling thread.
    When the application (and/or the stubs) call RpcSsDisableAllocate,
    any memory allocated by RpcSsAllocate in the context which has not been
     freed (by RpcSsFree) will be freed, and the context will be freed.

Arguments:

    Size - Supplies the amount of memory required in bytes.

Return Value:

    A pointer to the allocated block of memory will be returned.

Note:

    This is Win32 version.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
                          will be raised.
    RPC_S_INVALID_ARG   - If no allocation context yet.

--*/
{
    void *                  AllocatedChunk = 0;
    PALLOCATION_CONTEXT     AllocationContext = GetAllocContext();

    if ( AllocationContext == 0 )
        {
        RpcRaiseException( RPC_S_INVALID_ARG );
        }

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    if ( AllocationContext->EnableCount )
        AllocatedChunk = FindBlockForTheChunk( AllocationContext, Size );

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    if ( AllocatedChunk == NULL )
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        }

    return( AllocatedChunk );
}


static void
NdrpReleaseMemory(
    PALLOCATION_CONTEXT  AllocationContext
    )
/*++

Routine Description:

    Releases all the memory related to the package except for the
    control block itself.

Note:

    This is Win32 version and is called from the critical section
    in disable allocate and set thread.
--*/
{
    unsigned long i;

    for ( i = 0;  i < AllocationContext->FFIndex; i++ )
        {
        VirtualFree( AllocationContext->pBlockDescr[i].AllocationBlock,
                     0,  // free all of it
                     MEM_RELEASE );
        }
    I_RpcFree( AllocationContext->pInitialStacks );
    if ( AllocationContext->pEnableStack !=
            AllocationContext->pInitialStacks->EnableStack )
        I_RpcFree( AllocationContext->pEnableStack );
    if ( AllocationContext->pBlockDescr !=
            AllocationContext->pInitialStacks->DescrStack )
        I_RpcFree( AllocationContext->pBlockDescr );

    AllocationContext->pInitialStacks = 0;
    AllocationContext->pEnableStack = 0;
    AllocationContext->StackMax = 0;
    AllocationContext->StackTop = 0;
    AllocationContext->pBlockDescr = 0;
    AllocationContext->DescrSize = 0;
    AllocationContext->FFIndex = 0;
    AllocationContext->ClientAlloc = DefaultAllocate;
    AllocationContext->ClientFree  = DefaultFree;

    NDR_ASSERT( AllocationContext->ThreadCount, "when relesing all memory" );
    AllocationContext->ThreadCount--;
}

static void
NdrpDisableAllocate(
    BOOL    fCalledFromStub
    )
/*++

Routine Description:

    Multiple enable/disable are allowed and the EnableCount is used to keep
    track of it.
    We disable only when counter comes back to 0.
    We ignore too many disables.

    This routine will free memory associated with the allocation context
    for this thread as well as the allocation context.

    However, the routine frees only blocks allocated with the default
    allocator. Other blocks are considered to be allocated
    with a swapped/set user allocator and so we leave them alone.
    Allocation context gets freed when process detaches.

Note:

    This is Win32 version.
--*/
{
    PALLOCATION_CONTEXT  AllocationContext = GetAllocContext();
    unsigned long        NewLevel;
    BOOL                 fTooManyDisables = FALSE;
    BOOL                 fLastThreadGoingAway = FALSE;

    if ( AllocationContext == 0 )
        return;

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    if ( fCalledFromStub )
        {
        NDR_ASSERT( AllocationContext->StackTop, "mismatch in stub calls" );
        NewLevel = AllocationContext
                            ->pEnableStack[ -- AllocationContext->StackTop ];
        }
    else
        NewLevel = AllocationContext->EnableCount - 1;

    // We are forcing the EnableCount to get the value from the EnableStack,
    // when possible.

    if ( AllocationContext->EnableCount )
        AllocationContext->EnableCount = NewLevel;
    else
        {
        // doesn't fall below zero.

        fTooManyDisables = TRUE;
        }

    if ( AllocationContext->EnableCount == 0 )
        {
        // First free everything except the control block.

        if ( !fTooManyDisables )
            NdrpReleaseMemory( AllocationContext );

        // Now see if we need to free the context itself.

        // Because of the thread reusage in the runtime, and consequently,
        // some threads hanging around forever, we need to dispose
        // of this, even though it costs a new allocation later.

        if ( AllocationContext->ThreadCount == 0 )
            {
            fLastThreadGoingAway = TRUE;
            SetAllocContext( NULL );
            }
        }

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    if ( fLastThreadGoingAway)
        {
        DeleteCriticalSection( &(AllocationContext->CriticalSection) );
        I_RpcFree( AllocationContext );
        }

}



void RPC_ENTRY
RpcSsDisableAllocate (
    void
    )
/*++

Routine Description:

    See the description of NdrpDisableAllocate.

Note:

    This is Win32 version.
--*/
{
    NdrpDisableAllocate( FALSE );
}


static void
NdrpEnableAllocate (
    BOOL    fCalledFromStub
    )
/*++

Routine Description:

    This routine will set up an allocation context for this thread.

Note:

    The behavior is such that it is valid to call EnableAllocate
    several times in a row without calling DisableAllocate.
    The number to calls to Disable has to much that of Enable.

    This is Win32 version.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.
--*/
{
    PALLOCATION_CONTEXT  AllocationContext =  GetCreateAllocationContext();
    int  Successful = 1;

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    if ( AllocationContext->EnableCount == 0 )
        {
        AllocationContext->pInitialStacks = (INIT_STACKS_BLOCK *)
            I_RpcAllocate( sizeof( INIT_STACKS_BLOCK ) );

        if ( AllocationContext->pInitialStacks )
            {
            AllocationContext->pEnableStack =
                AllocationContext->pInitialStacks->EnableStack;
            AllocationContext->StackMax = ENABLE_STACK_SIZE;
            AllocationContext->StackTop = 0;

            AllocationContext->pBlockDescr =
                AllocationContext->pInitialStacks->DescrStack;
            AllocationContext->DescrSize = DESCR_ARRAY_SIZE;
            AllocationContext->FFIndex = 0;

            AllocationContext->ClientAlloc = RpcSsAllocate;
            AllocationContext->ClientFree  = RpcSsFree;
            }
        else
            Successful = 0;
        }

    if ( Successful )
        {
        if ( fCalledFromStub )
            {
            // Push the current enable level on the EnableStack to have
            // a point to come back when disabling from the server stub.

            if ( AllocationContext->StackTop >= AllocationContext->StackMax )
                {
                // Need to reallocate the EnableStack first.

                ulong   NewMax;
                ulong * pStackTemp;

                NewMax = AllocationContext->StackMax + ENABLE_STACK_SIZE;
                pStackTemp = (ulong *) I_RpcAllocate( NewMax * sizeof(ulong) );

                if ( pStackTemp )
                    {
                    RpcpMemoryCopy( pStackTemp,
                                    AllocationContext->pEnableStack,
                                    AllocationContext->StackMax * sizeof(ulong) );
                    if ( AllocationContext->pEnableStack !=
                             AllocationContext->pInitialStacks->EnableStack )
                         I_RpcFree( AllocationContext->pEnableStack );

                    AllocationContext->pEnableStack = pStackTemp;
                    AllocationContext->StackMax = NewMax;
                    }
                else
                    Successful = 0;
                }

            if ( Successful )
                AllocationContext->pEnableStack[ AllocationContext->StackTop++ ]
                     = AllocationContext->EnableCount;
            else
                if ( AllocationContext->EnableCount == 0 )
                    {
                    // just allocated the stuff ..
                    I_RpcFree( AllocationContext->pInitialStacks );
                    AllocationContext->pInitialStacks = 0;
                    AllocationContext->pEnableStack = 0;
                    AllocationContext->pBlockDescr = 0;
                    }
            }

        // Increment the counter to a new level.

        if ( Successful )
            {
            AllocationContext->EnableCount++;
            }
        }

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    if ( ! Successful )
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        }
}


void RPC_ENTRY
RpcSsEnableAllocate (
    void
    )
/*++

Routine Description:

    This routine will set up an allocation context for this thread.

Note:

    The behavior is such that it is valid to call EnableAllocate
    several times in a row without calling DisableAllocate.
    The number to calls to Disable should much that of Enable.

    This is Win32 version.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.
--*/
{
    NdrpEnableAllocate( FALSE );
}


void RPC_ENTRY
RpcSsFree (
    IN void * NodeToFree
    )
/*++

Routine Description:

    When a block of memory allocated by RpcSsAllocate is no longer needed,
    it can be freed using RpcSsFree.
    Actually, for win32 we do nothing
        -  all blocks will be freed at the Disable time as we want speed.

Arguments:

    NodeToFree - Supplies the block of memory, allocated by RpcSsAllocate, to
        be freed.

Note:

    This is Win32 version.
--*/
{
    PALLOCATION_CONTEXT     AllocationContext = GetAllocContext();

    if ( AllocationContext == 0 )
        {
        #if defined( DEBUGRPC )
            RpcRaiseException( RPC_S_INVALID_ARG );
        #else
            return;
        #endif
        }
}


// -----------------------------------------------------------------


RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSsGetThreadHandle (
    void
    )
/*++

Return Value:

    A handle to the allocation context for this thread will be returned.
    This makes it possible for two threads to share an allocation context.
    See RpcSsSetThreadHandle as well.

    != NULL     - only when the environement is actually enabled.

--*/
{
    PALLOCATION_CONTEXT  AllocationContext = GetAllocContext();
    RPC_SS_THREAD_HANDLE Handle = 0;

    if ( AllocationContext == 0 )
        return( 0 );

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    // Check if the memory environement is enabled.

    if ( AllocationContext->EnableCount > 0 )
         Handle = AllocationContext;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    return( Handle );
}


void RPC_ENTRY
RpcSsSetClientAllocFree (
    IN RPC_CLIENT_ALLOC * ClientAlloc,
    IN RPC_CLIENT_FREE  * ClientFree
    )
/*++

Routine Description:

    The routines to be used by the client to allocate and free memory can
    be set using this routine.  See also RpcSsSwapClientAllocFree.

Arguments:

    ClientAlloc - Supplies the routine to use to allocate memory.
    ClientFree  - Supplies the routine to use to free memory.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.

Note. Back door to enable.

    DCE (DEC's intrepretation of DCE) has this weird requirement that
    the user can set (or swap in) his private allocator pair without first
    enabling the package. This makes it possible for the client side stub
    to use a private allocator (instead of malloc/free (in osf mode)) to
    allocate when unmarshalling.

    However, that doesn't enable the package. So, issuing a regular API like
    RpcSsAllocate still fails.

    The expected behavior is to Enable the package, set or swap private
    allocators and then RpcSsAllocate is a valid call.

    This has some impact on the disable behavior. The implementation allows
    for multiple enables and disables. To prevent leaking/passing on an
    non-empty memory context with a thread when the thread is reused,
    there is a control mechanism (the enable stack) that makes sure that
    disbling from the stubs resets the enable level to the one at the
    enable time.

    Now, when the (server) stub issues enable, the corresponding disable
    will do the right thing, regardless of what the user might have messed up.
    If there weren't eanough disables, it will free everything; if there were
    too many disables, it would quietly do nothing.

    When the user issues an enable, the matching disable will clean up
    everything. If there is insufficient number of disable call on the client,
    there is a leak and we cannot do anything about it. Too many calls are ok.

    Now at last. If the user issues set/swap, an (empty) context is created
    with the disabled state. If the package has never been enabled, this empty
    context won't be deleted by a disable (this would be a disable too many).
    This is harmul both on client and server so I leave it as it is.


--*/
{
    PALLOCATION_CONTEXT  AllocationContext = GetCreateAllocationContext();

    // The only reason we enter the critical section here is to keep
    // the pair consistent.

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    AllocationContext->ClientAlloc = ClientAlloc;
    AllocationContext->ClientFree = ClientFree;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );
}


void RPC_ENTRY
RpcSsSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    )
/*++

Routine Description:

    The allocation context for this thread will set to be the supplied
    allocation context.
    For 32bit environment, the ThreadReCount is updated.

Arguments:

    Id - Supplies the allocation context to use for this thread.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.

--*/
{
    // This is 32bit and 64b code.

    // DCE doesn't really specify any means to support some kind of thread
    // ref counting and so additional semantics has been defined for this
    // API.
    // In order to define some orderly behavior for the apps passing
    // thread handles around, we keep track of how many threads can
    // access an allocation context. For an app to be clean, each thread
    // that issues set call(s) with non-zero argument should signal it's
    // done with a single set call with 0.

    // The ThreadCount has a special flavor here, which is to
    // count the threads that can access the context, not the references
    // in the sense of set calls.
    // The original thread doesn't issue a set but we still have to
    // account for it. So we start the ThreadCount with 1, and then
    // the last disable (the one that frees the memory) decrements the count.
    // Which means that the thread issuing the last disable effectively
    // does a set to zero at the same time.

    // The rules below support decrementing the ThreadCount by means
    // of calling the routine with thread id == 0, or with thread id being
    // different from the current one.
    // If this happens to be the call that would remove the last chance
    // to reference the context, we force to free everything, including
    // the control block.
    // In other words, set 0 on the last thread does the disable.


    PALLOCATION_CONTEXT pOldContext = GetAllocContext();
    PALLOCATION_CONTEXT pNewContext = (PALLOCATION_CONTEXT) Id;

    if ( pOldContext != pNewContext )
        {
        if ( pOldContext )
            {
            BOOL fLastThreadGoingAway = FALSE;

            EnterCriticalSection( &(pOldContext->CriticalSection) );

            if ( pOldContext->ThreadCount == 1 )
                {
                // delete the memory and decrease the ref count

                NdrpReleaseMemory( pOldContext );

                fLastThreadGoingAway = TRUE;
                SetAllocContext( NULL );
                }

            LeaveCriticalSection( &(pOldContext->CriticalSection) );

            if ( fLastThreadGoingAway)
                {
                DeleteCriticalSection( &(pOldContext->CriticalSection) );
                I_RpcFree( pOldContext );
                }
            }

        if ( pNewContext )
            {
            EnterCriticalSection( &(pNewContext->CriticalSection) );
            pNewContext->ThreadCount++;
            LeaveCriticalSection( &(pNewContext->CriticalSection) );
            }
        }

    SetAllocContext( pNewContext );
}


void RPC_ENTRY
RpcSsSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC  *   ClientAlloc,
    IN RPC_CLIENT_FREE   *   ClientFree,
    OUT RPC_CLIENT_ALLOC * * OldClientAlloc,
    OUT RPC_CLIENT_FREE  * * OldClientFree
    )
/*++

Routine Description:

    The routines to be used by the client to allocate and free memory can
    be set using this routine.  The previous values of these routines will
    be returned.  See also RpcSsSetClientAllocFree.

Arguments:

    ClientAlloc    - Supplies the routine to use to allocate memory.
    ClientFree     - Supplies the routine to use to free memory.
    OldClientAlloc - Returns the old value of the client allocator.
    OldClientFree  - Returns the old value of the client deallocator.

Exceptions:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available, this exception
        will be raised.

--*/
{
    PALLOCATION_CONTEXT  AllocationContext = GetCreateAllocationContext();

    // The only reason we enter the critical section here is to keep
    // the pairs consistent.

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    *OldClientAlloc = AllocationContext->ClientAlloc;
    *OldClientFree = AllocationContext->ClientFree;
    AllocationContext->ClientAlloc = ClientAlloc;
    AllocationContext->ClientFree = ClientFree;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );
}


/*++ -----------------------------------------------------------------------
//
//    RpcSm* functions are wrappers over RpcSs*
//
//    What was earlier: a hen or an egg?
//    We wrap RpcSm* over RpcSs* because RpcSs* are a basic staple for stubs
//    and so this makes the critical path shorter.
//    Admittedly, RpcSm*  take then longer than they could.
//
--*/

void * RPC_ENTRY
RpcSmAllocate (
    IN  size_t          Size,
    OUT RPC_STATUS *    pStatus
    )
/*++

Routine Description:

    Same as RpcSsAllocate, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    Size    - Supplies the amount of memory required in bytes.
    pStatus - Returns an error code:
                RPC_S_OK or RPC_S_OUT_OF_MEMORY

Return Value:

    A pointer to the allocated block of memory or NULL will be returned.

Exceptions:

    This routine catches exceptions and returns an error code.
--*/
{
    void * AllocatedNode = 0;
    RpcTryExcept
        {
        AllocatedNode = RpcSsAllocate( Size );
        *pStatus = RPC_S_OK;
        }
    RpcExcept(1)
        {
        *pStatus = RpcExceptionCode();
        }
    RpcEndExcept
    return( AllocatedNode );
}


RPC_STATUS RPC_ENTRY
RpcSmClientFree (
    IN  void * pNodeToFree
    )
/*++

Routine Description:

    Same as RpcSsClientFree, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    pNodeToFree  - a memory chunk to free

Return Value:

    error code - RPC_S_OK or exception code

Exceptions:

    This routine catches exceptions and returns an error code.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        NdrRpcSmClientFree( pNodeToFree );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept

    return( Status );
}


RPC_STATUS RPC_ENTRY
RpcSmDisableAllocate (
    void
    )
/*++

Routine Description:

    Same as RpcSsDisableAllocate, except that this one returns an error code,
    as opposed to raising an exception.

Return Value:

    error code - RPC_S_OK or exception code

Exceptions:

    Exceptions are catched and an error code is returned.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsDisableAllocate();
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_STATUS RPC_ENTRY
RpcSmDestroyClientContext (
    IN  void * * pContextHandle
    )
/*++

Routine Description:

    Frees the memory related to unused context handle.

Arguments:

    ContextHandle  - a context handle to be destroyed

Return Value:

    error code - RPC_S_OK or exception code

Exceptions:

    This routine catches exceptions and returns an error code.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsDestroyClientContext( pContextHandle );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept

    return( Status );
}


RPC_STATUS RPC_ENTRY
RpcSmEnableAllocate (
    void
    )
/*++

Routine Description:

    Same as RpcSsEnableAllocate, except that this one returns an error code,
    as opposed to raising an exception.

Exceptions:

    Exceptions are catched and an error code is returned.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsEnableAllocate();
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_STATUS  RPC_ENTRY
RpcSmFree (
    IN void * NodeToFree
    )
/*++

Routine Description:

    Same as RpcSsFree, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    NodeToFree - Supplies the block of memory, allocated by RpcSmAllocate, to
                 be freed.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsFree( NodeToFree );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_SS_THREAD_HANDLE RPC_ENTRY
RpcSmGetThreadHandle (
    OUT RPC_STATUS *    pStatus
    )
/*++

Arguments:

    pStatus - error code

Return Value:

    Same as RpcSsGetThreadHandle, except that this one returns an error code,
    as opposed to raising an exception.

--*/
{
    RPC_SS_THREAD_HANDLE  Handle = 0;
    *pStatus = RPC_S_OK;
    RpcTryExcept
        {
        Handle = RpcSsGetThreadHandle();
        }
    RpcExcept(1)
        {
        *pStatus = RpcExceptionCode();
        }
    RpcEndExcept
    return( Handle );
}


RPC_STATUS  RPC_ENTRY
RpcSmSetClientAllocFree (
    IN RPC_CLIENT_ALLOC * ClientAlloc,
    IN RPC_CLIENT_FREE  * ClientFree
    )
/*++

Routine Description:

    Same as RpcSsSetClientAllocFree, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    ClientAlloc - Supplies the routine to use to allocate memory.
    ClientFree  - Supplies the routine to use to free memory.

Return Value:

    error code - RPC_S_OK or exception code

Exceptions:

    Exceptions are catched and an error code is returned.
--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsSetClientAllocFree( ClientAlloc, ClientFree );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_STATUS  RPC_ENTRY
RpcSmSetThreadHandle (
    IN RPC_SS_THREAD_HANDLE Id
    )
/*++

Routine Description:

    Same as RpcSsSetThreadHandle, except that this one returns an error code,
    as opposed to raising an exception.

Arguments:

    Id - Supplies the allocation context to use for this thread.

Return Value:

    error code - RPC_S_OK or exception code (RPC_S_OUT_OF_MEMORY)

Exceptions:

    Exceptions are catched and an error code is returned.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsSetThreadHandle( Id );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


RPC_STATUS  RPC_ENTRY
RpcSmSwapClientAllocFree (
    IN RPC_CLIENT_ALLOC     * ClientAlloc,
    IN RPC_CLIENT_FREE      * ClientFree,
    OUT RPC_CLIENT_ALLOC  * * OldClientAlloc,
    OUT RPC_CLIENT_FREE   * * OldClientFree
    )
/*++

Routine Description:

    Same as RpcSsSwapClientAllocFree, except that this one returns an error
    code, as opposed to raising an exception.

Arguments:

    ClientAlloc     - Supplies the routine to use to allocate memory.
    ClientFree      - Supplies the routine to use to free memory.
    OldClientAlloc  - Returns the old value of the client allocator.
    OldClientFree   - Returns the old value of the client deallocator.

Return Value:

    error code - RPC_S_OK or exception code (RPC_S_OUT_OF_MEMORY)

Exceptions:

    Exceptions are catched and an error code is returned.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RpcTryExcept
        {
        RpcSsSwapClientAllocFree( ClientAlloc,
                                  ClientFree,
                                  OldClientAlloc,
                                  OldClientFree );
        }
    RpcExcept(1)
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    return( Status );
}


// =======================================================================
//     Package initialization
// =======================================================================

// default: win32 now


DWORD RpcAllocTlsIndex = 0xFFFFFFFF;

PALLOCATION_CONTEXT
GetAllocContext (
    )
/*++

Return Value:

    The allocation context pointer for this thread will be returned.  Use
    SetAllocContext to set the allocation context pointer for this thread.
    If GetAllocContext is called before SetAllocContext has been called, zero
    will be returned.

--*/
{
    if (RpcAllocTlsIndex == 0xFFFFFFFF)
        {
        GlobalMutexRequestExternal();
        if (RpcAllocTlsIndex == 0xFFFFFFFF)
            {
            RpcAllocTlsIndex = TlsAlloc();
            if (RpcAllocTlsIndex == 0xFFFFFFFF)
                {
                GlobalMutexClearExternal();
                RpcRaiseException(RPC_S_OUT_OF_MEMORY);
                }
            }
        GlobalMutexClearExternal();
        }

    return( (PALLOCATION_CONTEXT) TlsGetValue(RpcAllocTlsIndex));
}

void
SetAllocContext (
    PALLOCATION_CONTEXT AllocContext
    )
/*++

Arguments:

    AllocContext - Supplies a new allocation context pointer for this thread.
        Use GetAllocContext to retrieve the allocation context pointer for
        a thread.

--*/
{
    if ( ! TlsSetValue(RpcAllocTlsIndex, AllocContext) )
        RpcRaiseException( GetLastError() );
}


//
// We can't rely on a call like that in Win32 as some threads hang for ever.
// The runtime doesn't call us when a thread goes away and into recycling.
//
//void
//NdrRpcDeleteAllocationContext()
//{
//}



// =======================================================================
//     Private entry points for stubs
// =======================================================================
//

void RPC_ENTRY
NdrRpcSsEnableAllocate(
    PMIDL_STUB_MESSAGE  pMessage )
{
    NdrpEnableAllocate( TRUE );

    pMessage->pfnAllocate = RpcSsAllocate;
    pMessage->pfnFree     = RpcSsFree;
}

void RPC_ENTRY
NdrRpcSsDisableAllocate(
    PMIDL_STUB_MESSAGE  pMessage )
{
    NdrpDisableAllocate( TRUE );

    pMessage->pfnAllocate = NdrRpcSsDefaultAllocate;
    pMessage->pfnFree     = NdrRpcSsDefaultFree;
}

void RPC_ENTRY
NdrRpcSmSetClientToOsf(
    PMIDL_STUB_MESSAGE  pMessage )
{
    pMessage->pfnAllocate = NdrRpcSmClientAllocate;
    pMessage->pfnFree     = NdrRpcSmClientFree;
}


void *  RPC_ENTRY
NdrRpcSsDefaultAllocate (
    IN size_t Size
    )
{
    return I_RpcAllocate( Size );
}

void  RPC_ENTRY
NdrRpcSsDefaultFree (
    IN void * NodeToFree
    )
{
    I_RpcFree( NodeToFree );
}


void *  RPC_ENTRY
NdrRpcSmClientAllocate (
    IN size_t Size
    )
/*++
    This is the client stub private entry point that checks if a memory
    manager has been enabled. If not, a default or a user's private
    allocator is called.
--*/
{

    RPC_CLIENT_ALLOC *      ClientAlloc;
    PALLOCATION_CONTEXT     AllocationContext = GetAllocContext();

    if ( AllocationContext == 0 )
        {
        return( DefaultAllocate( Size ));
        }

    // User's ClientAlloc may encapsulate a RpcSsAllocate call.

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    ClientAlloc = AllocationContext->ClientAlloc;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    return (*ClientAlloc)( Size );
}


void  RPC_ENTRY
NdrRpcSmClientFree (
    IN void * NodeToFree
    )
{
    RPC_CLIENT_FREE *   ClientFree;
    PALLOCATION_CONTEXT     AllocationContext = GetAllocContext();

    if ( AllocationContext == 0 )
        {
        DefaultFree( NodeToFree );
        return;
        }

    EnterCriticalSection( &(AllocationContext->CriticalSection) );

    ClientFree = AllocationContext->ClientFree;

    LeaveCriticalSection( &(AllocationContext->CriticalSection) );

    (* ClientFree)( NodeToFree );
}


// =======================================================================
//     Private entry point for test
// =======================================================================


#if defined( DEBUGRPC )

void *  RPC_ENTRY
RpcSsGetInfo(
    void )
{
    return( GetAllocContext() );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\sh.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Copyright (c) 1989 Microsoft Corporation

 Module Name:

 	sh.c
	
 Abstract:

	stub helper routines.

 Notes:

	simple routines for handling pointer decisions, comm and fault
	status etc.

 History:

 	Dec-12-1993		VibhasC		Created.
 ----------------------------------------------------------------------------*/

/****************************************************************************
 *	include files
 ***************************************************************************/

#include "ndrp.h"

/****************************************************************************
 *	local definitions
 ***************************************************************************/
/****************************************************************************
 *	local data
 ***************************************************************************/

/****************************************************************************
 *	externs
 ***************************************************************************/
/****************************************************************************/

RPC_STATUS RPC_ENTRY
NdrMapCommAndFaultStatus(
/*

  Note on mapping.

   - Some errors are defined by DCE.
     These appear as mapped to DCE values on wire.
     They are mapped back to platform specific values by the rpc runtime.

   - other codes are defined by RPC runtime or by an app using rpc.
     These are not mapped, and appear both on the wire and on the client
     same as their original codes at server.

*/
	PMIDL_STUB_MESSAGE		pMessage,
	unsigned long 		*	pComm,
	unsigned long		*	pFault,
	RPC_STATUS				RetVal )
	{

// For errors that are mapped through DCE values, we use constants that
// resolve to platform specific error codes.
// For others, we have to use absolute values as the codes on wire are NT
// values set by RPC.
// We don't map any app specific error codes, of course.
//

static const long CommStatArray[] = 
    {
    RPC_X_SS_CONTEXT_MISMATCH
    ,RPC_S_INVALID_BINDING
    ,RPC_S_UNKNOWN_IF
    ,RPC_S_SERVER_UNAVAILABLE
    ,RPC_S_SERVER_TOO_BUSY
    ,RPC_S_CALL_FAILED_DNE
    ,RPC_S_PROTOCOL_ERROR
    ,RPC_S_UNSUPPORTED_TRANS_SYN
    ,RPC_S_UNSUPPORTED_TYPE
    ,RPC_S_PROCNUM_OUT_OF_RANGE
    ,EPT_S_NOT_REGISTERED
    ,RPC_S_COMM_FAILURE
    ,RPC_S_ASYNC_CALL_PENDING
    };

	int Mid;
	int Low	= 0;
	int High	= (sizeof(CommStatArray)/sizeof( unsigned long)) - 1;
	BOOL		  fCmp;
	BOOL		  fCommStat = FALSE;

    // Check if there was no error.

	if( RetVal == 0 )
		return RetVal;

    // Find a comm error mapping.

	while( Low <= High )
		{
		Mid = (Low + High) / 2;
		fCmp = (long)RetVal - (long) CommStatArray[ Mid ];

		if( fCmp < 0 )
			{
			High = Mid - 1;
			}
		else if( fCmp > 0 )
			{
			Low = Mid + 1;
			}
		else
			{
			fCommStat = TRUE;
			break;
			}
		}

    // If there was a comm error, return it in the pComm, if possible;
    // If it was a non-comm error, return it in the pFault, if possible.

	if( fCommStat )
		{
		if( pComm )
			{
			*pComm = RetVal;
			RetVal = 0;
			}
		}
	else
		{
		if( pFault )
			{
			*pFault = RetVal;
			RetVal = 0;
			}
		}
	return RetVal;
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\srvcall.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    srvcall.c

Abstract :

    This file contains the single call Ndr routine for the server side.

Author :

    David Kays    dkays    October 1993.

Revision History :

    brucemc     11/15/93    Added struct by value support, corrected varargs
                            use.
    brucemc     12/20/93    Binding handle support.
    brucemc     12/22/93    Reworked argument accessing method.
    ryszardk    3/12/94     Handle optimization and fixes.

  ---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include "ndrp.h"
#include "ndrole.h"
#include "rpcproxy.h"
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"
#include "attack.h"

#include <stdarg.h>

#if defined(DEBUG_WALKIP)
HRESULT NdrpReleaseMarshalBuffer(
        RPC_MESSAGE *pRpcMsg,
        PFORMAT_STRING pFormat,
        PMIDL_STUB_DESC pStubDesc,
        DWORD dwFlags,
        BOOLEAN fServer);
#endif

#pragma code_seg(".orpc")

#if !defined(__RPC_WIN64__)
// No support for the old interpreter on 64b platforms.

void RPC_ENTRY
NdrServerCall(
    PRPC_MESSAGE    pRpcMsg
    )
/*++

Routine Description :

    Older Server Interpreter entry point for regular RPC procs.

Arguments :

    pRpcMsg     - The RPC message.

Return :

    None.
--*/
{
    ulong dwStubPhase = STUB_UNMARSHAL;

    NdrStubCall( 0,
                 0,
                 pRpcMsg,
                 &dwStubPhase );
}

long RPC_ENTRY
NdrStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase
    )
/*++

Routine Description :

    Older Server Interpreter entry point for object RPC procs.  Also called by
    NdrServerCall, the entry point for regular RPC procs.

Arguments :

    pThis           - Object proc's 'this' pointer, 0 for non-object procs.
    pChannel        - Object proc's Channel Buffer, 0 for non-object procs.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

--*/
{
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    PMIDL_STUB_DESC         pStubDesc;
    const SERVER_ROUTINE  * DispatchTable;
    unsigned int            ProcNum;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;

    ushort                  StackSize;

    MIDL_STUB_MESSAGE       StubMsg;

    double                  ArgBuffer[ARGUMENT_COUNT_THRESHOLD];
    REGISTER_TYPE *         pArg;
    ARG_QUEUE_ELEM          QueueElements[QUEUE_LENGTH];
    ARG_QUEUE               ArgQueue;

    int                     ArgNumModifier;
    BOOL                    fUsesSsAlloc;

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    NDR_SCONTEXT            CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    //
    // Initialize the argument queue which is used by NdrServerUnmarshall,
    // NdrServerMarshall, and NdrServerFree.
    //
    ArgQueue.Length = 0;
    ArgQueue.Queue = QueueElements;

    StubMsg.pArgQueue = &ArgQueue;

    ProcNum = pRpcMsg->ProcNum;

    //
    // If OLE, Get a pointer to the stub vtbl and pServerInfo. Else
    // just get the pServerInfo the usual way.
    //
    if ( pThis )
        {
        //
        // pThis is (in unison now!) a pointer to a pointer to a vtable.
        // We want some information in this header, so dereference pThis
        // and assign that to a pointer to a vtable. Then use the result
        // of that assignment to get at the information in the header.
        //
        IUnknown *              pSrvObj;
        CInterfaceStubVtbl *    pStubVTable;

        pSrvObj = (IUnknown * )((CStdStubBuffer *)pThis)->pvServerObject;

        DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

        pStubVTable = (CInterfaceStubVtbl *)
                      (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

        pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;
        }
    else
        {
        pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
        pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
        DispatchTable = pServerInfo->DispatchTable;
        }

    pStubDesc = pServerInfo->pStubDesc;

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat = &((pServerInfo->ProcString)[FormatOffset]);

    StackSize = HAS_RPCFLAGS(pFormat[1]) ?
                        *(ushort *)&pFormat[8] :
                        *(ushort *)&pFormat[4];

    fUsesSsAlloc = pFormat[1] & Oi_RPCSS_ALLOC_USED;

    //
    // Set up for context handle management.
    //
    StubMsg.SavedContextHandles = CtxtHndl;
    memset( CtxtHndl, 0, sizeof(CtxtHndl) );

    pArg = (REGISTER_TYPE *) ArgBuffer;

    if ( (StackSize / sizeof(REGISTER_TYPE)) > QUEUE_LENGTH )
        {
        ArgQueue.Queue =
            (ARG_QUEUE_ELEM *)I_RpcAllocate( ((StackSize / sizeof(REGISTER_TYPE)) + 1) *
                                            sizeof(ARG_QUEUE_ELEM) );
        }

    if ( StackSize > MAX_STACK_SIZE )
        {
        pArg = (int*)I_RpcAllocate( StackSize );
        }

    //
    // Zero this in case one of the above allocations fail and we raise an exception
    // and head to the freeing code.
    //
    StubMsg.FullPtrXlatTables = 0;

    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    RpcTryFinally
       {
        if ( ! ArgQueue.Queue || ! pArg )
            RpcRaiseException( RPC_S_OUT_OF_MEMORY );

        //
        // Zero out the arg buffer.  We must do this so that parameters
        // are properly zeroed before we start unmarshalling.  If we catch
        // an exception before finishing the unmarshalling we can not leave
        // parameters in an unitialized state since we have to do a freeing
        // pass.
        //
        MIDL_memset( pArg,
                     0,
                     StackSize );

        //
        // If OLE, put pThis in first dword of stack.
        //
        if (pThis != 0)
            pArg[0] = (REGISTER_TYPE)((CStdStubBuffer *)pThis)->pvServerObject;

        StubMsg.fHasReturn = FALSE;

        //
        // Unmarshall all of our parameters.
        //

        ArgNumModifier = NdrServerUnmarshall( pChannel,
                                              pRpcMsg,
                                              &StubMsg,
                                              pStubDesc,
                                              pFormat,
                                              pArg );

        //
        // OLE interfaces use pdwStubPhase in the exception filter.
        // See CStdStubBuffer_Invoke in rpcproxy.c.
        //
        if( pFormat[1] & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING )
            *pdwStubPhase = STUB_CALL_SERVER_NO_HRESULT;
        else
            *pdwStubPhase = STUB_CALL_SERVER;

        //
        // Check for a thunk.  Compiler does all the setup for us.
        //
        if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            pServerInfo->ThunkTable[ProcNum]( &StubMsg );
            }
        else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;

            if ( pRpcMsg->ManagerEpv )
                pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
            else
                pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

            ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.  It may also be increased in some cases
            // to cover backward compatability with older stubs which sometimes
            // had wrong stack sizes.
            //
            if ( ArgNum )
                ArgNum += ArgNumModifier;

            NdrCallServerManager( pFunc,
                                  (double *)pArg,
                                  ArgNum,
                                  StubMsg.fHasReturn );
            }

        *pdwStubPhase = STUB_MARSHAL;

        NdrServerMarshall( pThis,
                           pChannel,
                           &StubMsg,
                           pFormat );
        }
    RpcFinally
        {
        //
        // Skip procedure stuff and the per proc binding information.
        //
        pFormat += HAS_RPCFLAGS(pFormat[1]) ? 10 : 6;

        if ( IS_HANDLE(*pFormat) )
            pFormat += (*pFormat == FC_BIND_PRIMITIVE) ?  4 : 6;

        NdrServerFree( &StubMsg,
                       pFormat,
                       pThis );

        //
        // Disable rpcss allocate package if needed.
        //
        if ( fUsesSsAlloc )
            NdrRpcSsDisableAllocate( &StubMsg );

        if ( ((StackSize / sizeof(REGISTER_TYPE)) > QUEUE_LENGTH) &&
             ArgQueue.Queue )
            {
            I_RpcFree( ArgQueue.Queue );
            }

        if ( (StackSize > MAX_STACK_SIZE) && pArg )
            {
            I_RpcFree( pArg );
            }
        }
    RpcEndFinally

    return S_OK;
}

#pragma code_seg()

int RPC_ENTRY
NdrServerUnmarshall(
    struct IRpcChannelBuffer *      pChannel,
    PRPC_MESSAGE                    pRpcMsg,
    PMIDL_STUB_MESSAGE              pStubMsg,
    PMIDL_STUB_DESC                 pStubDescriptor,
    PFORMAT_STRING                  pFormat,
    void *                          pParamList
    )
{
    PFORMAT_STRING      pFormatParam;
    long                StackSize;
    void *              pArg;
    void **             ppArg;
    uchar *             ArgList;
    PARG_QUEUE          pArgQueue;
    PARG_QUEUE_ELEM     pQueue;
    long                Length;
    int                 ArgNumModifier;
    BOOL                fIsOleInterface;
    BOOL                fXlatInit;
    BOOL                fInitRpcSs;
    BOOL                fUsesNewInitRoutine;

  RpcTryExcept
    {
    ArgNumModifier = 0;

    fIsOleInterface     = IS_OLE_INTERFACE( pFormat[1] );
    fXlatInit           = pFormat[1] & Oi_FULL_PTR_USED;
    fInitRpcSs          = pFormat[1] & Oi_RPCSS_ALLOC_USED;
    fUsesNewInitRoutine = pFormat[1] & Oi_USE_NEW_INIT_ROUTINES;

    // Skip to the explicit handle description, if any.
    pFormat += HAS_RPCFLAGS(pFormat[1]) ? 10 : 6;

    //
    // For a handle_t parameter we must pass the handle field of
    // the RPC message to the server manager.
    //
    if ( *pFormat == FC_BIND_PRIMITIVE )
        {
        pArg = (char *)pParamList + *((ushort *)&pFormat[2]);

        if ( IS_HANDLE_PTR(pFormat[1]) )
            pArg = *((void **)pArg);

        *((handle_t *)pArg) = pRpcMsg->Handle;
        }

    // Skip to the param format string descriptions.
    if ( IS_HANDLE(*pFormat) )
        pFormat += (*pFormat == FC_BIND_PRIMITIVE) ?  4 : 6;

    //
    // Set ArgList pointing at the address of the first argument.
    // This will be the address of the first element of the structure
    // holding the arguments in the caller stack.
    //
    ArgList = (uchar*)pParamList;

    //
    // If it's an OLE interface, skip the first long on stack, since in this
    // case NdrStubCall put pThis in the first long on stack.
    //
    if ( fIsOleInterface )
        GET_NEXT_S_ARG(ArgList, REGISTER_TYPE);

    // Initialize the Stub message.
    //
    if ( ! pChannel )
        {
        if ( fUsesNewInitRoutine )
            {
            NdrServerInitializeNew( pRpcMsg,
                                    pStubMsg,
                                    pStubDescriptor );
            }
        else
            {
            NdrServerInitialize( pRpcMsg,
                                 pStubMsg,
                                 pStubDescriptor );
            }
        }
    else
        {
        NdrStubInitialize( pRpcMsg,
                           pStubMsg,
                           pStubDescriptor,
                           pChannel );
        }

    // Call this after initializing the stub.

    if ( fXlatInit )
        pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

    //
    // Set StackTop AFTER the initialize call, since it zeros the field
    // out.
    //
    pStubMsg->StackTop = (uchar*)pParamList;

    //
    // We must make this check AFTER the call to ServerInitialize,
    // since that routine puts the stub descriptor alloc/dealloc routines
    // into the stub message.
    //
    if ( fInitRpcSs )
        NdrRpcSsEnableAllocate( pStubMsg );

    //
    // Do endian/floating point conversions if needed.
    //
    if ( (pRpcMsg->DataRepresentation & 0X0000FFFFUL) !=
          NDR_LOCAL_DATA_REPRESENTATION )
        NdrConvert( pStubMsg, pFormat );

    pArgQueue = (PARG_QUEUE) pStubMsg->pArgQueue;

    //
    // --------------------------------------------------------------------
    // Unmarshall Pass.
    // --------------------------------------------------------------------
    //
    pStubMsg->ParamNumber = 0;

    for ( pQueue = pArgQueue->Queue;
          ;
          pStubMsg->ParamNumber++, pArgQueue->Length++, pQueue++ )
        {
        //
        // Clear out flags IsReturn, IsBasetype, IsIn, IsOut,
        // IsOutOnly, IsDeferredFree, IsDontCallFreeInst.
        //
        *((long *)(((char *)pQueue) + 0xc)) = 0;

        //
        // Zero this so that if we catch an exception before finishing the
        // unmarshalling and [out] init passes we won't try to free a
        // garbage pointer.
        //
        pQueue->pArg = 0;

        //
        // Context handles need the parameter number.
        //
        pQueue->ParamNum = (short) pStubMsg->ParamNumber;

        switch ( *pFormat )
            {
            case FC_IN_PARAM_BASETYPE :
                pQueue->IsBasetype = TRUE;

                //
                // We have to inline the simple type unmarshall so that on
                // Alpha, negative longs get properly sign extended.
                //
                switch ( pFormat[1] )
                    {
                    case FC_CHAR :
                    case FC_BYTE :
                    case FC_SMALL :
                        *((REGISTER_TYPE *)ArgList) =
                                (REGISTER_TYPE) *(pStubMsg->Buffer)++;
                        break;

                    case FC_ENUM16 :
                    case FC_WCHAR :
                    case FC_SHORT :
                        ALIGN(pStubMsg->Buffer,1);

                        *((REGISTER_TYPE *)ArgList) =
                                (REGISTER_TYPE) *((ushort *&)pStubMsg->Buffer)++;
                        break;

                    // case FC_FLOAT : not supported on -Oi
                    case FC_LONG :
                    case FC_ENUM32 :
                    case FC_ERROR_STATUS_T:
                        ALIGN(pStubMsg->Buffer,3);

                        *((REGISTER_TYPE *)ArgList) =
                                (REGISTER_TYPE) *((long *&)pStubMsg->Buffer)++;
                        break;

                    // case FC_DOUBLE : not supported on -Oi
                    case FC_HYPER :
                        ALIGN(pStubMsg->Buffer,7);

                        // Let's stay away from casts to doubles.
                        //
                        *((ulong *)ArgList) =
                                *((ulong *&)pStubMsg->Buffer)++;
                        *((ulong *)(ArgList+4)) =
                                *((ulong *&)pStubMsg->Buffer)++;
                        break;

                    case FC_IGNORE :
                        break;

                    default :
                        NDR_ASSERT(0,"NdrServerUnmarshall : bad format char");
                        RpcRaiseException( RPC_S_INTERNAL_ERROR );
                        return 0;
                    } // switch ( pFormat[1] )

                pQueue->pFormat = &pFormat[1];
                pQueue->pArg = ArgList;

                GET_NEXT_S_ARG( ArgList, REGISTER_TYPE);

                if ( pFormat[1] == FC_HYPER )
                    GET_NEXT_S_ARG( ArgList, REGISTER_TYPE);

                pFormat += 2;
                continue;

            case FC_IN_PARAM_NO_FREE_INST :
                pQueue->IsDontCallFreeInst = TRUE;
                // Fall through...

            case FC_IN_PARAM :
                //
                // Here, we break out of the switch statement to the
                // unmarshalling code below.
                //
                break;

            case FC_IN_OUT_PARAM :
                pQueue->IsOut = TRUE;
                //
                // Here, we break out of the switch statement to the
                // unmarshalling code below.
                //
                break;

            case FC_OUT_PARAM :
                pQueue->IsOut = TRUE;
                pQueue->IsOutOnly = TRUE;

                pFormat += 2;
                pFormatParam = pStubDescriptor->pFormatTypes +
                               *((short *)pFormat);
                pFormat += 2;

                pQueue->pFormat = pFormatParam;
                pQueue->ppArg = (uchar **)ArgList;

                //
                // An [out] param ALWAYS eats up 4 bytes of stack space.
                //
                GET_NEXT_S_ARG(ArgList, REGISTER_TYPE);
                continue;

            case FC_RETURN_PARAM :
                pQueue->IsOut = TRUE;
                pQueue->IsReturn = TRUE;

                pFormatParam = pStubDescriptor->pFormatTypes +
                               *((short *)(pFormat + 2));

                pQueue->pFormat = pFormatParam;

                if ( IS_BY_VALUE(*pFormatParam) )
                    {
                    pQueue->pArg = (uchar *) ArgList;
                    pQueue->ppArg = &(pQueue->pArg);
                    }
                else
                    pQueue->ppArg = (uchar **) ArgList;

                //
                // Context handle returned by value is the only reason for
                // this case here as a context handle has to be initialized.
                // A context handle cannot be returned by a pointer.
                //
                if ( *pFormatParam == FC_BIND_CONTEXT )
                    {
                    pStubMsg->SavedContextHandles[pStubMsg->ParamNumber] =
                        NdrContextHandleInitialize(
                            pStubMsg,
                            pFormatParam);
                            }
                        //
                // The return variable is used in modifying the stacksize
                // given us by midl, in order to compute how many
                // REGISTER_SIZE items to pass into the manager function.
                //
                ArgNumModifier--;

                pStubMsg->fHasReturn = TRUE;

                pArgQueue->Length++;

                goto UnmarshallLoopExit;

            case FC_RETURN_PARAM_BASETYPE :
                pQueue->IsOut = TRUE;
                pQueue->IsReturn = TRUE;
                pQueue->IsBasetype = TRUE;

                pQueue->pFormat = &pFormat[1];
                pQueue->pArg = ArgList;

                //
                // The return variable is used in modifying the stacksize
                // given us by midl, in order to compute how many
                // REGISTER_SIZE items to pass into the manager function.
                //
                ArgNumModifier--;

                pStubMsg->fHasReturn = TRUE;

                pArgQueue->Length++;

                goto UnmarshallLoopExit;

            default :
                goto UnmarshallLoopExit;
            } // end of unmarshall pass switch

        //
        // Now get what ArgList points at and increment over it.
        // In the current implementation, what we want is not on the stack
        // of the manager function, but is a local in the manager function.
        // Thus the code for ppArg below.
        //
        ppArg = (void **)ArgList;
        GET_NEXT_S_ARG( ArgList, REGISTER_TYPE);

        //
        // Get the parameter's format string description.
        //
        pFormat += 2;
        pFormatParam = pStubDescriptor->pFormatTypes + *((short *)pFormat);

        //
        // Increment main format string past offset field.
        //
        pFormat += 2;

        //
        // We must get a double pointer to structs, unions and xmit/rep as.
        //
        // On MIPS and PPC, an 8 byte aligned structure is passed at an 8 byte
        // boundary on the stack.  On PowerPC 4 bytes aligned structures which
        // are 8 bytes or larger in size are also passed at an 8 byte boundary.
        // We check for these cases here and increment our ArgList pointer
        // an additional 'int' if necessary to get to the structure.
        //
        if ( IS_BY_VALUE(*pFormatParam) )
            {
            pArg = ppArg;
            ppArg = &pArg;
            }

        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatParam)])
        ( pStubMsg,
          (uchar **)ppArg,
          pFormatParam,
          FALSE );

        pQueue->pFormat = pFormatParam;
        pQueue->pArg = (uchar*)*ppArg;

        //
        // The second byte of a param's description gives the number of
        // ints occupied by the param on the stack.
        //
        StackSize = pFormat[-3] * sizeof(int);

        if ( StackSize > sizeof(REGISTER_TYPE) )
            {
            StackSize -= sizeof(REGISTER_TYPE);
            ArgList += StackSize;
            }
        } // Unmarshalling loop.

UnmarshallLoopExit:

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsOutOnly )
            {
            pStubMsg->ParamNumber = pQueue->ParamNum;

            NdrOutInit( pStubMsg,
                        pQueue->pFormat,
                        pQueue->ppArg );

            pQueue->pArg = *(pQueue->ppArg);
            }
        }
    }
  RpcExcept( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
    {
    // Filter set in rpcndr.h to catch one of the following
    //     STATUS_ACCESS_VIOLATION
    //     STATUS_DATATYPE_MISALIGNMENT
    //     RPC_X_BAD_STUB_DATA

    RpcRaiseException( RPC_X_BAD_STUB_DATA );
    }
  RpcEndExcept

    if ( pRpcMsg->BufferLength  <
         (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
        {
        NDR_ASSERT( 0, "NdrStubCall unmarshal: buffer overflow!" );
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    return ArgNumModifier;
}

void RPC_ENTRY
NdrServerMarshall(
    struct IRpcStubBuffer *    pThis,
    struct IRpcChannelBuffer * pChannel,
    PMIDL_STUB_MESSAGE         pStubMsg,
    PFORMAT_STRING             pFormat )
{
    PFORMAT_STRING      pFormatParam;
    PARG_QUEUE          pArgQueue;
    PARG_QUEUE_ELEM     pQueue;
    long                Length;

    pArgQueue = (PARG_QUEUE)pStubMsg->pArgQueue;

    //
    // Remove?
    //
    pStubMsg->Memory = 0;

    //
    // -------------------------------------------------------------------
    // Sizing Pass.
    // -------------------------------------------------------------------
    //

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsOut )
            {
            //
            // Must do some special handling for return values.
            //
            if ( pQueue->IsReturn )
                {
                if ( pQueue->IsBasetype )
                    {
                    //
                    // Add worse case size of 16 for a simple type return.
                    //
                    pStubMsg->BufferLength += 16;
                    continue;
                    }

                //
                // Get the value returned by the server.
                //
                pQueue->pArg = *(pQueue->ppArg);

                //
                // We have to do an extra special step for context handles
                // which are function return values.
                //
                // In the unmarshalling phase, we unmarshalled the context
                // handle for the return case. But the function we called put
                // the user context in the arglist buffer. Before we marshall
                // the context handle, we have to put the user context in it.
                //
                if ( pQueue->pFormat[0] == FC_BIND_CONTEXT )
                    {
                    NDR_SCONTEXT    SContext;
                    long            ParamNum;

                    ParamNum = pQueue->ParamNum;

                    SContext = pStubMsg->SavedContextHandles[ParamNum];

                    *((uchar **)NDRSContextValue(SContext)) = pQueue->pArg;
                    }
                }

            pFormatParam = pQueue->pFormat;

            (*pfnSizeRoutines[ROUTINE_INDEX(*pFormatParam)])
            ( pStubMsg,
              pQueue->pArg,
              pFormatParam );
            }
        }

    if ( ! pChannel )
        NdrGetBuffer( pStubMsg,
                      pStubMsg->BufferLength,
                      0 );
    else
        NdrStubGetBuffer( pThis,
                          pChannel,
                          pStubMsg );

    //
    // -------------------------------------------------------------------
    // Marshall Pass.
    // -------------------------------------------------------------------
    //

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsOut )
            {
            if ( pQueue->IsBasetype )
                {
                //
                // Only possible as a return value.
                //
                NdrSimpleTypeMarshall( pStubMsg,
                                       pQueue->pArg,
                                       pQueue->pFormat[0] );
                }
            else
                {
                pFormatParam = pQueue->pFormat;

                //
                // We need this if we're marshalling a context handle.
                //
                pStubMsg->ParamNumber = pQueue->ParamNum;

                (*pfnMarshallRoutines[ROUTINE_INDEX(*pFormatParam)])
                ( pStubMsg,
                  pQueue->pArg,
                  pFormatParam );
                }
            }
        }

    if ( pStubMsg->RpcMsg->BufferLength  <
         (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
        {
        NDR_ASSERT( 0, "NdrStubCall marshal: buffer overflow!" );
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    pStubMsg->RpcMsg->BufferLength =
            pStubMsg->Buffer - (uchar *) pStubMsg->RpcMsg->Buffer;
}

void
NdrServerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat,
    void *              pThis
    )
{
    PARG_QUEUE          pArgQueue;
    PARG_QUEUE_ELEM     pQueue;
    long                Length;
    PFORMAT_STRING      pFormatParam;
    uchar *             pArg;

    pArgQueue = (PARG_QUEUE)pStubMsg->pArgQueue;

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsBasetype )
            continue;

        pFormatParam = pQueue->pFormat;

        //
        // We have to defer the freeing of pointers to base types in case
        // the parameter is [in,out] or [out] and is the size, length, or
        // switch specifier for an array, a pointer, or a union.  This is
        // because we can't free the pointer to base type before we free
        // the data structure which uses the pointer to determine it's size.
        //
        // Note that to make the check as simple as possible [in] only
        // pointers to base types will be included, as will string pointers
        // of any direction.
        //
        if ( IS_BASIC_POINTER(*pFormatParam) &&
             SIMPLE_POINTER(pFormatParam[1]) )
            {
            pQueue->IsDeferredFree = TRUE;
            continue;
            }

        pStubMsg->fDontCallFreeInst =
                pQueue->IsDontCallFreeInst;

        (*pfnFreeRoutines[ROUTINE_INDEX(*pFormatParam)])
        ( pStubMsg,
          pQueue->pArg,
          pFormatParam );

        //
        // Have to explicitly free arrays and strings.  But make sure it's
        // non-null and not sitting in the buffer.
        //
        if ( IS_ARRAY_OR_STRING(*pFormatParam) )
            {
            pArg = pQueue->pArg;

            //
            // We have to make sure the array/string is non-null in case we
            // get an exception before finishing our unmarshalling.
            //
            if ( pArg &&
                 ( (pArg < pStubMsg->BufferStart) ||
                   (pArg > pStubMsg->BufferEnd) ) )
                (*pStubMsg->pfnFree)( pArg );
            }
        }

    for ( Length = pArgQueue->Length, pQueue = pArgQueue->Queue;
          Length--;
          pQueue++ )
        {
        if ( pQueue->IsDeferredFree )
            {
            NDR_ASSERT( IS_BASIC_POINTER(*(pQueue->pFormat)),
                        "NdrServerFree : bad defer logic" );

            NdrPointerFree( pStubMsg,
                            pQueue->pArg,
                            pQueue->pFormat );
            }
        }

    //
    // Free any full pointer resources.
    //
    if ( pStubMsg->FullPtrXlatTables )
        NdrFullPointerXlatFree( pStubMsg->FullPtrXlatTables );
}

#endif // !defined(__RPC_WIN64__)

#pragma code_seg(".orpc")

void
NdrUnmarshallBasetypeInline(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pArg,
    uchar               Format
    )
{
    switch ( Format )
        {
        case FC_CHAR :
        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            *((REGISTER_TYPE *)pArg) = (REGISTER_TYPE)
                                       *(pStubMsg->Buffer)++;
            break;

        case FC_ENUM16 :
        case FC_WCHAR :
        case FC_SHORT :
        case FC_USHORT :
            ALIGN(pStubMsg->Buffer,1);

            *((REGISTER_TYPE *)pArg) = (REGISTER_TYPE)
                                       *((ushort *&)pStubMsg->Buffer)++;
            break;

        case FC_FLOAT : 
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);

            *((REGISTER_TYPE *)pArg) = (REGISTER_TYPE)
                                       *((long *&)pStubMsg->Buffer)++;
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264: 
            ALIGN(pStubMsg->Buffer,3);
            *((REGISTER_TYPE *)pArg) = (REGISTER_TYPE)
                                       *((long *&)pStubMsg->Buffer)++;
            break;

        case FC_UINT3264: 
            // REGISTER_TYPE is a signed integral.
            ALIGN(pStubMsg->Buffer,3);
            *((UINT64 *)pArg) = (UINT64) *((ulong * &)pStubMsg->Buffer)++;
            break;
#endif

        case FC_DOUBLE :
        case FC_HYPER :
            ALIGN(pStubMsg->Buffer,7);

            *((ulong *)pArg) = *((ulong *&)pStubMsg->Buffer)++;
            *((ulong *)(pArg+4)) = *((ulong *&)pStubMsg->Buffer)++;
            break;

        default :
            NDR_ASSERT(0,"NdrUnmarshallBasetypeInline : bad format char");
            break;
        }
}

#if !defined(__RPC_WIN64__)

void
NdrCallServerManager(
    MANAGER_FUNCTION    pFtn,
    double *            pArgs,
    ulong               NumRegisterArgs,
    BOOL                fHasReturn )
{

    REGISTER_TYPE       returnValue;
    REGISTER_TYPE     * pArg;

    pArg = (REGISTER_TYPE *)pArgs;

    //
    // If we don't have a return value, make sure we don't write past
    // the end of our argument buffer!
    //
    returnValue = Invoke(pFtn, 
                         (REGISTER_TYPE *) pArgs, 
                         NumRegisterArgs);

    if ( fHasReturn )
            pArg[NumRegisterArgs] = returnValue;

}

#endif // !defined(__RPC_WIN64__)

void RPC_ENTRY
NdrServerCall2(
    PRPC_MESSAGE    pRpcMsg
    )
/*++

Routine Description :

    Server Interpreter entry point for regular RPC procs.

Arguments :

    pRpcMsg     - The RPC message.

Return :

    None.

--*/
{
    ulong dwStubPhase = STUB_UNMARSHAL;

    NdrStubCall2( 0,
                  0,
                  pRpcMsg,
                  &dwStubPhase );
}

long RPC_ENTRY
NdrStubCall2(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase
    )
/*++

Routine Description :

    Server Interpreter entry point for object RPC procs.  Also called by
    NdrServerCall, the entry point for regular RPC procs.

Arguments :

    pThis           - Object proc's 'this' pointer, 0 for non-object procs.
    pChannel        - Object proc's Channel Buffer, 0 for non-object procs.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

--*/
{
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    PMIDL_STUB_DESC         pStubDesc;
    const SERVER_ROUTINE  * DispatchTable;
    ushort                  ProcNum;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;

    MIDL_STUB_MESSAGE       StubMsg;

    uchar *                 pArgBuffer;
    uchar *                 pArg;
#if defined(_M_IX86) && (_MSC_FULL_VER <= 13008982)
    volatile BOOL           fBadStubDataException = FALSE;
#else
    BOOL                    fBadStubDataException = FALSE;
#endif
    ulong                   n;

    PNDR_PROC_HEADER_EXTS   pHeaderExts = 0;
    boolean                 NotifyAppInvoked = FALSE;
    NDR_PROC_CONTEXT        ProcContext;

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    NDR_SCONTEXT            CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    ProcNum = (ushort) pRpcMsg->ProcNum;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    //
    // If OLE, Get a pointer to the stub vtbl and pServerInfo. Else
    // just get the pServerInfo the usual way.
    //
    if ( pThis )
    {
        //
        // pThis is (in unison now!) a pointer to a pointer to a vtable.
        // We want some information in this header, so dereference pThis
        // and assign that to a pointer to a vtable. Then use the result
        // of that assignment to get at the information in the header.
        //
        IUnknown *              pSrvObj;
        CInterfaceStubVtbl *    pStubVTable;

        pSrvObj = (IUnknown * )((CStdStubBuffer *)pThis)->pvServerObject;

        DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

        pStubVTable = (CInterfaceStubVtbl *)
                      (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

        pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;
    }
    else
    {
        pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
        pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
        DispatchTable = pServerInfo->DispatchTable;
    }

    pStubDesc = pServerInfo->pStubDesc;

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat      = &((pServerInfo->ProcString)[FormatOffset]);

    MulNdrpInitializeContextFromProc( XFER_SYNTAX_DCE, pFormat, &ProcContext, NULL );
    
    //
    // Yes, do this here outside of our RpcTryFinally block.  If we
    // can't allocate the arg buffer there's nothing more to do, so
    // raise an exception and return control to the RPC runtime.
    //
    // Alloca throws an exception on an error.
    
    pArgBuffer = (uchar*)NdrpAlloca(&ProcContext.AllocateContext, ProcContext.StackSize);

    //
    // Zero out the arg buffer.  We must do this so that parameters
    // are properly zeroed before we start unmarshalling.  If we catch
    // an exception before finishing the unmarshalling we can not leave
    // parameters in an unitialized state since we have to do a freeing
    // pass.
    //
    MIDL_memset( pArgBuffer,
                 0,
                 ProcContext.StackSize );

    // we have to setup this again because we don't know the size when
    // initializing the proc context.
    ProcContext.StartofStack = pArgBuffer;
    StubMsg.pContext = &ProcContext;
    // We need to setup stack AFTER proc header is read so we can
    // know how big the virtual stack is.
    

    //
    // Set up for context handle management.
    //
    StubMsg.SavedContextHandles = CtxtHndl;
    memset( CtxtHndl, 0, sizeof(CtxtHndl) );

    if ( ProcContext.NdrInfo.pProcDesc->Oi2Flags.HasExtensions )
        pHeaderExts = &ProcContext.NdrInfo.pProcDesc->NdrExts;
    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    RpcTryFinally
    {
        // General server initializaiton (NULL async message)
        NdrpServerInit( &StubMsg, pRpcMsg, pStubDesc, pThis, pChannel, NULL );

        // Raise exceptions after initializing the stub.

        RpcTryExcept
            {

            // --------------------------------
            // Unmarshall all of our parameters.
            // --------------------------------

            NdrpServerUnMarshal( &StubMsg );
            
            if ( pRpcMsg->BufferLength  <
                 (uint)(StubMsg.Buffer - (uchar *)pRpcMsg->Buffer) )
                {
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
                }

            }
        RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
            {
            // Filter set in rpcndr.h to catch one of the following
            //     STATUS_ACCESS_VIOLATION
            //     STATUS_DATATYPE_MISALIGNMENT
            //     RPC_X_BAD_STUB_DATA

            fBadStubDataException = TRUE;
            NdrpFreeMemoryList( &StubMsg );

            if ( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
            else
                RpcRaiseException( RpcExceptionCode() );
            }
        RpcEndExcept

        NdrpServerOutInit( &StubMsg );
        //
        // Do [out] initialization.
        //

        //
        // Unblock the first pipe; this needs to be after unmarshalling
        // because the buffer may need to be changed to the secondary one.
        // In the out only pipes case this happens immediately.
        //

        if ( ProcContext.HasPipe )
            NdrMarkNextActivePipe( ProcContext.pPipeDesc );

        //
        // OLE interfaces use pdwStubPhase in the exception filter.
        // See CStdStubBuffer_Invoke in rpcproxy.c.
        //
        if( pFormat[1] & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING )
            *pdwStubPhase = STUB_CALL_SERVER_NO_HRESULT;
        else
            *pdwStubPhase = STUB_CALL_SERVER;

        NotifyAppInvoked = TRUE;
        //
        // Check for a thunk.  Compiler does all the setup for us.
        //
        if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            pServerInfo->ThunkTable[ProcNum]( &StubMsg );
            }
        else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       returnValue;

            if ( pRpcMsg->ManagerEpv )
                pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
            else
                pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

            ArgNum = (long) ProcContext.StackSize / sizeof(REGISTER_TYPE);
           
            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && 
                 ProcContext.NdrInfo.pProcDesc->Oi2Flags.HasReturn && 
                 !ProcContext.HasComplexReturn )
                ArgNum--;

            returnValue = Invoke( pFunc, 
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_WIN64)
                                  pHeaderExts != NULL ? ((PNDR_PROC_HEADER_EXTS64)pHeaderExts)->FloatArgMask
                                                      : 0,
#endif
                                  ArgNum);

            if( ProcContext.NdrInfo.pProcDesc->Oi2Flags.HasReturn)            
                {
                if ( !ProcContext.HasComplexReturn )
                    ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = returnValue;

                // Pass the app's return value to OLE channel
                if ( pThis )
                    (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                                 NULL,   // reserved
                                                 (HRESULT) returnValue );
                }
            }

        // Important for context handle cleanup.
        *pdwStubPhase = STUB_MARSHAL;

            if ( ProcContext.HasPipe )
                {
                NdrIsAppDoneWithPipes( ProcContext.pPipeDesc );
                StubMsg.BufferLength += ProcContext.NdrInfo.pProcDesc->ServerBufferSize;
                }
            else
                StubMsg.BufferLength = ProcContext.NdrInfo.pProcDesc->ServerBufferSize;
    
            if ( ProcContext.NdrInfo.pProcDesc->Oi2Flags.ServerMustSize )
                {
                //
                // Buffer size pass.
                //
                NdrpSizing( &StubMsg, 
                            FALSE );    // is server
                }
    
            if ( ProcContext.HasPipe && ProcContext.pPipeDesc->OutPipes ) 
                {
                NdrGetPartialBuffer( & StubMsg );
                StubMsg.RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
                }
            else
                {
                if ( ! pChannel )
                    {
                    NdrGetBuffer( &StubMsg,
                                  StubMsg.BufferLength,
                                  0 );
                    }
                else
                    NdrStubGetBuffer( pThis,
                                      pChannel,
                                      &StubMsg );
                }
    
            //
            // Marshall pass.
            //
            NdrpServerMarshal( &StubMsg,
                               ( pThis != NULL ) );
                               
            pRpcMsg->BufferLength = (ulong) ( StubMsg.Buffer - (uchar *) pRpcMsg->Buffer );

#if defined(DEBUG_WALKIP)
        if ( pChannel )
            {
            NdrpReleaseMarshalBuffer(
                StubMsg.RpcMsg,
                pFormat,
                StubMsg.StubDesc,
                1, //BUFFER_OUT
                true );
            }
#endif

        }
    RpcFinally
        {
        // clean up context handles if exception is thrown in either marshalling or 
        // manager routine. 

        if ( RpcAbnormalTermination()  && ! pChannel )
            {
            NdrpCleanupServerContextHandles( &StubMsg,
                                             pArgBuffer,
                                             STUB_MARSHAL != *pdwStubPhase);
            }

        // If we died because of bad stub data, don't free the params here since they
        // were freed using a linked list of memory in the exception handler above.

        if ( ! fBadStubDataException )
            {
            NdrpFreeParams( &StubMsg,
                            ProcContext.NumberParams,
                            ( PARAM_DESCRIPTION * )ProcContext.Params,
                            pArgBuffer );
            }

        //
        // Deferred frees.  Actually, this should only be necessary if you
        // had a pointer to enum16 in a *_is expression.
        //

        //
        // Free any full pointer resources.
        //
        NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );

        //
        // Disable rpcss allocate package if needed.
        //
        if ( ProcContext.NdrInfo.InterpreterFlags.RpcSsAllocUsed )
            NdrRpcSsDisableAllocate( &StubMsg );

        //
        // Clean up pipe objects
        //

        NdrCorrelationFree( &StubMsg );

        NdrpAllocaDestroy( &ProcContext.AllocateContext );
         
        if ( pHeaderExts != 0  
             && ( pHeaderExts->Flags2.HasNotify 
                    || pHeaderExts->Flags2.HasNotify2 ) )
            {
            NDR_NOTIFY_ROUTINE     pfnNotify;

            pfnNotify = StubMsg.StubDesc->NotifyRoutineTable[ pHeaderExts->NotifyIndex ];

            if ( pHeaderExts->Flags2.HasNotify2 )
                {
                ((NDR_NOTIFY2_ROUTINE)pfnNotify)(NotifyAppInvoked);
                }
            else
                pfnNotify();
            }
        }
    RpcEndFinally

    return S_OK;
}

void
NdrpFreeParams(
    MIDL_STUB_MESSAGE       * pStubMsg,
    long                    NumberParams,
    PPARAM_DESCRIPTION      Params,
    uchar *                 pArgBuffer 
    )
/*++

Routine Description :

    Frees the memory associated with function parameters as required.

Arguments :

    pStubMsg     - Supplies a pointer to the stub message.
    NumberParams - Supplies the number of parameters for this procedure.
    Params       - Supplies a pointer to the parameter list for this function.
    pArgBuffer   - Supplies a pointer to the virtual stack.
    pParamFilter - Supplies a filter that is used to determine which functions
                   are to be considered.  This function should return TRUE if
                   the parameter should be considered.   If pParamFilter is NULL,
                   the default filter is used which is all parameters that have
                   MustFree set. 

Return :

    None.

--*/
{

    long n;
    PMIDL_STUB_DESC         pStubDesc      = pStubMsg->StubDesc;

    PFORMAT_STRING          pFormatParam;
    uchar *                 pArg;

    for ( n = 0; n < NumberParams; n++ )
        {
        
        if ( ! Params[n].ParamAttr.MustFree )
            continue;

        pArg = pArgBuffer + Params[n].StackOffset;

        if ( ! Params[n].ParamAttr.IsByValue )
            pArg = *((uchar **)pArg);

        pFormatParam = pStubDesc->pFormatTypes +
                       Params[n].TypeOffset;

        if ( pArg )
            {
            pStubMsg->fDontCallFreeInst =
                    Params[n].ParamAttr.IsDontCallFreeInst;

            (*pfnFreeRoutines[ROUTINE_INDEX(*pFormatParam)])
                ( pStubMsg,
                  pArg,
                  pFormatParam );
            }

        //
        // We have to check if we need to free any simple ref pointer,
        // since we skipped it's NdrPointerFree call.  We also have
        // to explicitly free arrays and strings.  But make sure it's
        // non-null and not sitting in the buffer.
        //
        if ( Params[n].ParamAttr.IsSimpleRef ||
             IS_ARRAY_OR_STRING(*pFormatParam) )
            {
            //
            // Don't free [out] params that we're allocated on the
            // interpreter's stack.
            //

            if ( Params[n].ParamAttr.ServerAllocSize != 0 )
                continue;

            //
            // We have to make sure the array/string is non-null in case we
            // get an exception before finishing our unmarshalling.
            //
            if ( pArg &&
                 ( (pArg < pStubMsg->BufferStart) ||
                   (pArg > pStubMsg->BufferEnd) ) )
                (*pStubMsg->pfnFree)( pArg );
            }
        } // for
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\srvout.cxx ===
/************************************************************************

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    srvout.c

Abstract :

    Contains routines for support of [out] parameters on server side during 
    unmarshalling phase. This includes deferral, allocation and handle 
    initialization.

Author :     

    Bruce McQuistan (brucemc)   12/93.

Revision History :

    DKays   10/94   Major comment and code clean up.

 ***********************************************************************/

#include "ndrp.h"
#include "hndl.h"
#include "interp.h"

void
NdrOutInit(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    uchar **                ppArg
    )
/*++

Routine Description :        

    This routine is called to manage server side issues for [out] params 
    such as allocation and context handle initialization. Due to the fact 
    that for [out] conformant objects on stack, their size descriptors may 
    not have been unmarshalled when we need to know their size, this routine 
    must be called after all other unmarshalling has occurred. Really, we 
    could defer only [out], conformant data, but the logic in walking the 
    format string to determine if an object is conformant does not warrant 
    that principle, so all [out] data is deferred.

Arguments :      

    pStubMsg    - Pointer to stub message.
    pFormat     - Format string description for the type.
    ppArg       - Location of argument on stack.

Return :

    None.

 --*/
{
    // This must be a signed long!
    LONG_PTR    Size;  

    //
    // Check for a non-Interface pointer (they have a much different format 
    // than regular pointers).
    //
    if ( IS_BASIC_POINTER(*pFormat) )
        {
        //
        // Check for a pointer to a basetype (we don't have to worry about
        // a non-sized string pointer because these are not allowed as [out]
        // only.
        //
        if ( SIMPLE_POINTER(pFormat[1]) )
            {
            Size = SIMPLE_TYPE_MEMSIZE(pFormat[2]);
            goto DoAlloc;
            }

        //
        // Check for a pointer to a pointer.
        //
        if ( POINTER_DEREF(pFormat[1]) )
            {
            Size = PTR_MEM_SIZE;
            goto DoAlloc;
            }

        // We have a pointer to complex type.

        pFormat += 2;
        pFormat += *(signed short *)pFormat;
        }

    if ( *pFormat == FC_BIND_CONTEXT )
        {
        NDR_SCONTEXT    Context;

        Context = NdrContextHandleInitialize( pStubMsg,
                                              pFormat );

        if ( ! Context )
            RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

        NdrSaveContextHandle(
            pStubMsg,
            Context,
            ppArg,
            pFormat );

        return;
        }

    //
    // Don't initialize tag params if they have a tag routine since they
    // aren't on the stack in this case.
    //
    if ( FC_CS_TAG == *pFormat )
        {
        NDR_CS_TAG_FORMAT  *pTagFormat = (NDR_CS_TAG_FORMAT *) pFormat;

        if ( NDR_INVALID_TAG_ROUTINE_INDEX != pTagFormat->TagRoutineIndex )
            return;
        }

    //
    // If we get here we have to make a call to size a complex type.
    //
    Size = (LONG_PTR) NdrpMemoryIncrement( pStubMsg,
                                          0, 
                                          pFormat );

DoAlloc:

    //
    // Check for a negative size.  This an application error condition for
    // signed size specifiers.
    //
    if ( Size < 0 )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    *ppArg = (uchar*)NdrAllocate( pStubMsg, (size_t) Size);

    MIDL_memset( *ppArg, 0, (size_t) Size );

    // We are almost done, except for an out ref to ref to ... etc.
    // If this is the case keep allocating pointees of ref pointers.

    if ( *pFormat == FC_RP  &&  POINTER_DEREF(pFormat[1]) )
        {
        pFormat += 2;
        pFormat += *(signed short *)pFormat;

        if ( *pFormat == FC_RP )
            NdrOutInit( pStubMsg, pFormat, (uchar **) *ppArg );
        }
}

void
NdrPartialIgnoreServerInitialize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    void **                             ppMemory,
    PFORMAT_STRING                      pFormat
    )
{
    if ( *ppMemory)
        {

        NdrOutInit( pStubMsg, 
                    pFormat,
                    (uchar**)ppMemory );


        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\relmrl.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1998 - 1999 Microsoft Corporation

Module Name :

    relmrl.c

Abstract :

    This file contains release of Marshaled Data (called before unmarshal).

Author :

    Yong Qu (yongqu@microsoft.com) Nov 1998

Revision History :

  ---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE
#include "ndrp.h"
#include "ndrole.h"
#include "rpcproxy.h"
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"
#include "attack.h"
#include "mulsyntx.h"

#include <stddef.h>
#include <stdarg.h>


/* client side: we only care about the [in] part. 
   it's basically like unmarshal on the server side, just that
   we immediately free the buffer (virtual stack) after unmarshalling.
   The call it not necessary always OLE call: one side raw RPC and 
   the other side OLE call is possible: do we support this?

   mostly code from NdrStubCall2, remove irrelavant code. 
*/

#define IN_BUFFER           0
#define OUT_BUFFER          1

#define IsSameDir(dwFlags,param) ((dwFlags == IN_BUFFER)? param.IsIn :param.IsOut)

HRESULT NdrpReleaseMarshalBuffer(
        RPC_MESSAGE *pRpcMsg,
        PFORMAT_STRING pFormat,
        PMIDL_STUB_DESC pStubDesc,
        DWORD dwFlags,
        BOOLEAN fServer)
{
    ushort		            StackSize;

    MIDL_STUB_MESSAGE       StubMsg;

    PPARAM_DESCRIPTION      Params;
    INTERPRETER_FLAGS       InterpreterFlags;
    INTERPRETER_OPT_FLAGS   OptFlags;
    long                    NumberParams;

    long                    n;
    PNDR_PROC_HEADER_EXTS   pHeaderExts = 0;
    HRESULT                 hr = S_OK;

    uchar *             pBuffer;
    PFORMAT_STRING      pFormatComplex;
    PFORMAT_STRING      pFormatTypes;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    // must be auto handle.
    if (FC_AUTO_HANDLE != pFormat[0])
        return E_NOTIMPL;

    InterpreterFlags = *((PINTERPRETER_FLAGS)&pFormat[1]);
    pFormat += InterpreterFlags.HasRpcFlags ? 8 : 4;
    StackSize = *((ushort * &)pFormat)++;

    memset(&StubMsg,0,sizeof(MIDL_STUB_MESSAGE));
    StubMsg.FullPtrXlatTables = 0;


    //
    // Get new interpreter info.
    //
    NdrServerInitialize(pRpcMsg,&StubMsg,pStubDesc);
    SET_WALKIP( StubMsg.uFlags ); 

    OptFlags = *((PINTERPRETER_OPT_FLAGS)&pFormat[4]);

    NumberParams = (long) pFormat[5];

    Params = (PPARAM_DESCRIPTION) &pFormat[6];

    // Proc header extentions, from NDR ver. 5.2.
    // Params must be set correctly here because of exceptions.
    // need to setup correlation information.

    if ( OptFlags.HasExtensions )
        {
        pHeaderExts = (NDR_PROC_HEADER_EXTS *)Params;
        Params = (PPARAM_DESCRIPTION)((uchar*)Params + pHeaderExts->Size);
        StubMsg.fHasExtensions  = 1;
        StubMsg.fHasNewCorrDesc = pHeaderExts->Flags2.HasNewCorrDesc;
        }


    if ( InterpreterFlags.FullPtrUsed )
        StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

    //
    // context handle is not supported in object
    //

        pFormatTypes = pStubDesc->pFormatTypes;



    // Save the original buffer pointer to restore later.
        pBuffer = StubMsg.Buffer;

    // Get the type format string.
    RpcTryFinally
    {

        RpcTryExcept
        {
        //
        // Check if we need to do any walking .
        //
        if ( (fServer && dwFlags == OUT_BUFFER)
              &&
             (pRpcMsg->DataRepresentation & 0X0000FFFFUL) !=
                      NDR_LOCAL_DATA_REPRESENTATION )
                    {
                    NdrConvert2( &StubMsg,
                                 (PFORMAT_STRING) Params,
                                 NumberParams );
                    }

        for ( n = 0; n < NumberParams; n++ )
            {

            if ( (dwFlags == IN_BUFFER ) &&
                 Params[n].ParamAttr.IsPartialIgnore )
                {
                PMIDL_STUB_MESSAGE pStubMsg = &StubMsg;
                ALIGN( StubMsg.Buffer, 0x3 );
                StubMsg.Buffer += PTR_WIRE_SIZE;
                CHECK_EOB_RAISE_BSD( StubMsg.Buffer );
                continue;
                }

            if ( ! IsSameDir(dwFlags,Params[n].ParamAttr) ||
                    Params[n].ParamAttr.IsPipe)
                continue;

            if ( Params[n].ParamAttr.IsBasetype )
                {
                ALIGN(StubMsg.Buffer, SIMPLE_TYPE_ALIGNMENT( Params[n].SimpleType.Type ));
                StubMsg.Buffer += SIMPLE_TYPE_BUFSIZE( Params[n].SimpleType.Type );
                }
            else
                {
                //
                // Complex type or pointer to complex type.
                //
                pFormatComplex = pFormatTypes + Params[n].TypeOffset;

                (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                    ( &StubMsg,
                      pFormatComplex);
                };
            }
        }
        RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        {
             hr = HRESULT_FROM_WIN32(RpcExceptionCode());
        }
        RpcEndExcept

    }
    RpcFinally
    {
        NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );

        StubMsg.Buffer = pBuffer;
    }
    RpcEndFinally

    return hr;

}


HRESULT NdrpClientReleaseMarshalBuffer(
        IReleaseMarshalBuffers *pRMB,
        RPC_MESSAGE *pRpcMsg,
        DWORD dwIOFlags,
        BOOLEAN  fAsync )
{
    CStdProxyBuffer *           pProxyBuffer;
    PMIDL_STUBLESS_PROXY_INFO   pProxyInfo;
    CInterfaceProxyHeader *     ProxyHeader;
    long                        ParamSize;
    ushort                      ProcNum;
    ushort                      FormatOffset;
    PFORMAT_STRING              pFormat;
    PMIDL_STUB_DESC             pStubDesc;
    void *                      This;
    HRESULT hr;

    pProxyBuffer = (CStdProxyBuffer *)
                  (((uchar *)pRMB) - offsetof( CStdProxyBuffer, pRMBVtbl ));

    // The channel queries for IReleaseMarshalBuffers interface and gets the interface pointer
    // only when proxy is the new proxy with bigger header, with ProxyInfo.
    // Just in case, check this condition again.
    if ( pRMB == 0 )
        return E_NOTIMPL;

    // quite often OLE pass in NULL buffer. Do an additional check here. 
    if ( NULL == pRpcMsg->Buffer )
        return E_INVALIDARG;    
    
    This = (void *)pProxyBuffer->pProxyVtbl;

    ProxyHeader = (CInterfaceProxyHeader *)
                  ( (char *)This - sizeof(CInterfaceProxyHeader));
    pProxyInfo = (PMIDL_STUBLESS_PROXY_INFO) (ProxyHeader->pStublessProxyInfo);


    // Hack just in case, the bit should not be set up, actually.
    ProcNum = pRpcMsg->ProcNum & ~RPC_FLAGS_VALID_BIT;

    // RPCMSG always has the synchronous proc number;
    if ( fAsync )
        ProcNum = 2 * ProcNum - 3;  // Begin method #

    if ( dwIOFlags != IN_BUFFER )
        return E_NOTIMPL;


    pStubDesc = pProxyInfo->pStubDesc;

#if defined(BUILD_NDR64)
    // check out ndr64
    if ( pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )   
        {
        SYNTAX_TYPE             SyntaxType;
        long           i;
        MIDL_SYNTAX_INFO    *   pSyntaxInfo;
        
        SyntaxType = NdrpGetSyntaxType( pRpcMsg->TransferSyntax );

        // branch into ndr64 if SyntaxType is NDR64. fall through otherwise
        if ( XFER_SYNTAX_NDR64 == SyntaxType )
            {
            for ( i = 0; i < (long)pProxyInfo->nCount; i++ )
            {
            if ( SyntaxType == NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) )
                {
                pSyntaxInfo = &pProxyInfo->pSyntaxInfo[i];
                break;
                }
            }
            return Ndr64pReleaseMarshalBuffer( pRpcMsg, pSyntaxInfo, ProcNum, pStubDesc, dwIOFlags, FALSE );
            }
        }
#endif
        
    FormatOffset = pProxyInfo->FormatStringOffset[ProcNum];
    pFormat      = &((pProxyInfo->ProcFormatString)[FormatOffset]);

    // only support Oicf mode
    if ( (MIDL_VERSION_3_0_39 > pStubDesc->MIDLVersion ) ||
         !(pFormat[1] &  Oi_OBJ_USE_V2_INTERPRETER ))
         return E_NOTIMPL;

    hr = NdrpReleaseMarshalBuffer( pRpcMsg,
                                   pFormat,
                                   pStubDesc,
                                   dwIOFlags, 
                                   FALSE );    // client

    return hr;        
}


HRESULT NdrpServerReleaseMarshalBuffer(
        IReleaseMarshalBuffers *pRMB,
        RPC_MESSAGE *pRpcMsg,
        DWORD dwIOFlags,
        BOOLEAN fAsync)
{
    CStdStubBuffer *        pStubBuffer ;
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    ushort                  ProcNum;

    IUnknown *              pSrvObj;
    CInterfaceStubVtbl *    pStubVTable;

    ushort                  FormatOffset;
    PFORMAT_STRING          pFormat;
    PMIDL_STUB_DESC         pStubDesc;
    HRESULT                 hr;


    pStubBuffer = (CStdStubBuffer *) (((uchar *)pRMB) -
                                    offsetof(CStdStubBuffer, pRMBVtbl));

    // The channel queries for IReleaseMarshalBuffers interface and gets the interface pointer
    // only when proxy is the new proxy with bigger header, with ProxyInfo.
    // Just in case, check this condition again.
    if ( pRMB == 0 )
        return E_NOTIMPL;

    if ( NULL == pRpcMsg->Buffer )
        return E_INVALIDARG;
    
    pSrvObj = (IUnknown * )((CStdStubBuffer *)pStubBuffer)->pvServerObject;

    pStubVTable = (CInterfaceStubVtbl *)
                  ((uchar *)pStubBuffer->lpVtbl - sizeof(CInterfaceStubHeader));

    pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;


    // Hack just in case, this should not be set up, actually.
    ProcNum = pRpcMsg->ProcNum & ~RPC_FLAGS_VALID_BIT;
    
    // RPCMSG always has the synchronous proc number;
    if ( fAsync )
        {
        ProcNum = 2 * ProcNum - 3;  // Begin method #

        if ( dwIOFlags != IN_BUFFER )
            ProcNum++;              // Finish method
        }

    pStubDesc = pServerInfo->pStubDesc;

#if defined(BUILD_NDR64)    
    if ( pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )   
        {
        SYNTAX_TYPE             SyntaxType;
        long                    i;
        MIDL_SYNTAX_INFO    *   pSyntaxInfo;
        
        SyntaxType = NdrpGetSyntaxType( pRpcMsg->TransferSyntax );

        if ( XFER_SYNTAX_NDR64 == SyntaxType )
            {
            for ( i = 0; i < (long)pServerInfo->nCount; i++ )
            {
            if ( SyntaxType == NdrpGetSyntaxType( &pServerInfo->pSyntaxInfo[i].TransferSyntax ) )
                {
                pSyntaxInfo = &pServerInfo->pSyntaxInfo[i];
                break;
                }
            }
            return Ndr64pReleaseMarshalBuffer( pRpcMsg, pSyntaxInfo, ProcNum, pStubDesc, dwIOFlags, TRUE );
            }
        }
#endif

    FormatOffset = pServerInfo->FmtStringOffset[ProcNum];
    pFormat = &((pServerInfo->ProcString)[FormatOffset]);
    
    // only support Oicf mode
    if ( (MIDL_VERSION_3_0_39 > pStubDesc->MIDLVersion ) ||
         !(pFormat[1] &  Oi_OBJ_USE_V2_INTERPRETER ))
         return E_NOTIMPL;
         
    hr = NdrpReleaseMarshalBuffer(pRpcMsg,pFormat,pStubDesc,dwIOFlags,TRUE);

    return hr;        
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Steve Wood (stevewo) 12-Apr-1989

Revision History:

!ENDIF


TARGETNAME=rpcndr20
TARGETPATH=obj
TARGETTYPE=LIBRARY
386_STDCALL=1

MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=$(INCLUDES);..;..\..\ndr20;..\..\midl\inc;..\..\runtime\mtrt;$(PROJECT_ROOT)\inc\ndrshared

SOURCES=        \
    ..\async.cxx   \
    ..\asyncu.cxx  \
    ..\attack.cxx  \
    ..\auxilary.cxx\
    ..\bufsize.cxx \
    ..\chkrobust.cxx\
    ..\cltcall.cxx \
    ..\cvtf.cxx    \
    ..\cvtg.cxx    \
    ..\cvtglo.cxx  \
    ..\cvtibm.cxx  \
    ..\endian.cxx  \
    ..\factory.cxx \
    ..\free.cxx    \
    ..\fullptr.cxx \
    ..\global.cxx  \
    ..\hndl.cxx    \
    ..\iid.cxx     \
    ..\memsize.cxx \
    ..\misc.cxx    \
    ..\mrshl.cxx   \
    ..\mrshlp.cxx  \
    ..\pickle.cxx  \
    ..\pipes.cxx   \
    ..\proxy.cxx   \
    ..\registry.cxx\
    ..\rpcssm.cxx  \
    ..\sh.cxx      \
    ..\srvcall.cxx \
    ..\srvout.cxx  \
    ..\stream.cxx  \
    ..\stub.cxx    \
    ..\tiutil.cxx  \
    ..\typeinfo.cxx \
    ..\udt.cxx      \
    ..\unmrshl.cxx  \
    ..\relmrl.cxx \
    ..\unmrshlp.cxx \
    ..\mulsyntx.cxx \
    ..\pointerq.cxx

!ifdef DOSWIN32RPC
RPCENV=$(RPCENV) -DDOSWIN32RPC -DWIN32RPC
!else
RPCENV=$(RPCENV) -DNTENV
!endif

# define TEST_CONVERT to force endian conversion pass in regular run
# C_DEFINES=$(RPCENV) -D_RPCRT4_ -DTEST_CONVERT
C_DEFINES=$(RPCENV) -D_RPCRT4_ 

!if $(IA64) || $(AMD64)
BUILD_NDR64=1
!endif


!ifdef BUILD_NDR64FAKE
BUILD_NDR64=1
!endif

!ifdef BUILD_NDR64
C_DEFINES=$(C_DEFINES) -DBUILD_NDR64
!endif

!ifdef BUILD_NDR64FAKE
C_DEFINES=$(C_DEFINES) -DBUILD_NDR64FAKE
!endif

UMTYPE=console
UMTEST=testc
UMLIBS=$(O)\rpcndr20.lib $(SDK_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\rpcrt4.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\registry.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    registry.cxx

Abstract:
    Registers the interfaces contained in the proxy DLL.

Public Functions:
    DllRegisterServer
    NdrDllRegisterProxy
    NdrDllUnregisterProxy

Private Functions:
    NdrpGetClassID
    NdrpRegisterClass
    NdrpRegisterInterface
    NdrpUnregisterClass
    NdrpUnregisterInterface

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT and Windows 95.

Revision History:

    RyszardK    Nov 1997    Changes for async registration.

--------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE
#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>
#include <stdlib.h>

EXTERN_C HINSTANCE g_hRpcrt4 = 0;

HRESULT NdrpGetClassID(
    OUT LPSTR                    pszClassID, 
    IN  const CLSID *            pclsid,
    IN  const ProxyFileInfo **   pProxyFileList);

HRESULT NdrpRegisterClass(
    IN LPCSTR    pszClassID, 
    IN LPCTSTR   pszClassName,
    IN LPCTSTR   pszDllFileName,
    IN LPCTSTR   pszThreadingModel);

HRESULT NdrpRegisterInterface(
    IN HKEY         hKeyInterface,
    IN REFIID       riid, 
    IN LPCSTR       pszInterfaceName,
    IN LPCSTR       pszClassID,
    IN long         NumMethods,
    IN const IID *  riidAsync 
    );

HRESULT NdrpRegisterAsyncInterface(
    IN HKEY     hKeyInterface,
    IN REFIID   riid, 
    IN LPCSTR   pszSyncInterfaceName,
    IN long     SyncNumMethods,
    IN REFIID   riidAsync
    );

HRESULT NdrpUnregisterClass(
    IN LPCSTR    pszClassID,
    IN LPCTSTR   pszDllFileName);

HRESULT NdrpUnregisterInterface(
    IN HKEY         hKeyInterface,
    IN REFIID       riid,
    IN LPCSTR       pszClassID,
    IN const IID *  riidAsync );


HRESULT RPC_ENTRY NdrDllRegisterProxy (
    IN HMODULE                hDll,
    IN const ProxyFileInfo ** pProxyFileList, 
    IN const CLSID *          pclsid OPTIONAL)
/*++

Routine Description:
    Creates registry entries for the interfaces contained in the proxy DLL.

Arguments:
    hDll            - Supplies a handle to the proxy DLL.
    pProxyFileList  - Supplies a list of proxy files to be registered.
    pclsid          - Supplies the classid for the proxy DLL.  May be zero.

Return Value:
    S_OK

See Also:
    DllRegisterServer
    NdrDllUnregisterProxy

--*/ 
{
    HRESULT hr;
    long    i, j;
    HKEY    hKeyInterface;
    DWORD   dwDisposition;
    TCHAR   szDllFileName[MAX_PATH+1];
    long    error;
    ULONG   length;
    char    szClassID[39];

    if(hDll != 0)
    {
        //Get the proxy dll name.
        length = GetModuleFileName(hDll,
                                   szDllFileName,
                                   MAX_PATH);

        if( (length > 0) && ( length != MAX_PATH ) )
        {
            szDllFileName[MAX_PATH]='\0';
            NDR_ASSERT(GetLastError() == NO_ERROR, "incorrect GetModuleFileName return" );
            hr = S_OK;
        }
        else
        {
            NDR_ASSERT(GetLastError() != NO_ERROR, "incorrect GetModuleFileName return" );            
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        //The proxy DLL's DLL_PROCESS_ATTACH did not initialize hProxyDll.
        hr = E_HANDLE;
    }

    if(SUCCEEDED(hr))
    {
        //Convert the class ID to to a registry key name.
        hr = NdrpGetClassID(szClassID, pclsid, pProxyFileList);
    }

    if(SUCCEEDED(hr))
    {
        //Register the class
        hr = NdrpRegisterClass(szClassID,
                               TEXT("PSFactoryBuffer"),
                               szDllFileName,
                               TEXT("Both"));
    }

    if(SUCCEEDED(hr))
    {
        //Create the Interface key.
        error = RegCreateKeyEx(HKEY_CLASSES_ROOT, 
                               TEXT("Interface"),
                               0, 
                               TEXT("REG_SZ"), 
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE,
                               0,
                               &hKeyInterface,
                               &dwDisposition);

        if(!error)
        {
            HRESULT hr2;
            // the only purpose of this call is to setup gfRpcVerifierEnabled flag. 
            // this call can be called later again disregard the function succeeded or not here.
            NdrpPerformRpcInitialization();

            //iterate over the list of proxy files in the proxy DLL.
            for(i = 0; 
                pProxyFileList[i] != 0;
                i++)
                {
                if ( pProxyFileList[i]->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)
                    {
                    // Iterate through sync and async interfaces.

                    for(j = 0;
                        pProxyFileList[i]->pProxyVtblList[j] != 0;
                        j++)
                        {
                        if ( gfRPCVerifierEnabledWithBreaks )
                            {
                            if ( NdrpCheckMIDLRobust( pProxyFileList[i]->pStubVtblList[j]->header.pServerInfo, 
                                                                    pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                                    TRUE ) )
                                {
                                RPC_VERIFIER_WARNING_MSG("Possible security threat: Server registers an interface compiled without /robust option",
                                                         RPC_VERIFIER_REGISTERING_NONROBUST_IF);

                                DbgPrint("RPC: Unsecure interface UUID: ");
                                PrintUUID((UUID *)pProxyFileList[i]->pStubVtblList[j]->header.piid);
                                DbgPrint("\n");
                                RPC_VERIFIER_PRINT_OFFENDING_STACK(2, 4);
                                }                          
                            }
                        
                        if ( pProxyFileList[i]->pAsyncIIDLookup[j] == 0)
                            {
                            // just a sync interface, no async counterpart.
                            hr2 = NdrpRegisterInterface(hKeyInterface, 
                                                        *pProxyFileList[i]->pStubVtblList[j]->header.piid, 
                                                        pProxyFileList[i]->pNamesArray[j], 
                                                        szClassID,
                                                        pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                        0 /* no async */);
                  
                            if(FAILED(hr2) && SUCCEEDED(hr))
                                hr = hr2;
                            }
                        else if ( (ULONG_PTR) pProxyFileList[i]->pAsyncIIDLookup[j] != -1 )
                            {
                            // Register an sync-async pair of interfaces.

                            hr2 = NdrpRegisterInterface(hKeyInterface, 
                                                        *pProxyFileList[i]->pStubVtblList[j]->header.piid, 
                                                        pProxyFileList[i]->pNamesArray[j], 
                                                        szClassID,
                                                        pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                        pProxyFileList[i]->pAsyncIIDLookup[j]);
                  
                            if(FAILED(hr2) && SUCCEEDED(hr))
                                hr = hr2;

                            hr2 = NdrpRegisterAsyncInterface(hKeyInterface, 
                                                             *pProxyFileList[i]->pStubVtblList[j]->header.piid, 
                                                             pProxyFileList[i]->pNamesArray[j], 
                                                             pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                             *pProxyFileList[i]->pAsyncIIDLookup[j] );
                  
                            if(FAILED(hr2) && SUCCEEDED(hr))
                                hr = hr2;
                            }
                        }
                    }
                else
                    {
                    // Plain old style sync interfaces only.
                    // iterate over the list of interfaces in the proxy file.
                    for(j = 0;
                        pProxyFileList[i]->pProxyVtblList[j] != 0;
                        j++)
                        {
                        if ( gfRPCVerifierEnabledWithBreaks )
                            {
                            if ( NdrpCheckMIDLRobust( pProxyFileList[i]->pStubVtblList[j]->header.pServerInfo, 
                                                                    pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                                    TRUE ) )
                                {
                                RPC_VERIFIER_WARNING_MSG("Possible security threat: Server registers an interface compiled without /robust option",
                                                         RPC_VERIFIER_REGISTERING_NONROBUST_IF);

                                DbgPrint("RPC: Unsecure interface UUID: ");
                                PrintUUID((UUID *)pProxyFileList[i]->pStubVtblList[j]->header.piid);
                                DbgPrint("\n");
                                RPC_VERIFIER_PRINT_OFFENDING_STACK(2, 4);
                                
                                }
                            }
                            
                        hr2 = NdrpRegisterInterface(hKeyInterface, 
                                                    *pProxyFileList[i]->pStubVtblList[j]->header.piid, 
                                                    pProxyFileList[i]->pNamesArray[j], 
                                                    szClassID,
                                                    pProxyFileList[i]->pStubVtblList[j]->header.DispatchTableCount,
                                                    0 /* no async */);

                        if(FAILED(hr2) && SUCCEEDED(hr))
                            hr = hr2;
                        }
                    }
                }

            RegCloseKey(hKeyInterface);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }
    }
    return hr;
 }

HRESULT CheckInprocServer32(
    IN HKEY  hKeyIID,
    IN LPCTSTR pszDllFileName)
{
    HRESULT hr;
    HKEY    hKey;
    TCHAR   szDll[MAX_PATH];
    long    cbData = sizeof(szDll);
    long    error;
    DWORD   dwType;

    //Open the InprocServer32 key.
    error = RegOpenKeyEx(hKeyIID, 
                         TEXT("InprocServer32"),
                         0, 
                         KEY_READ,
                         &hKey);

    if(!error)
    {
        error = RegQueryValueEx(hKey,
                                TEXT(""),
                                0,
                                &dwType,
                                (BYTE*)szDll,
                                (ulong*)&cbData);

        if(!error)
        {
            if(0 == lstrcmpi(pszDllFileName,
                            szDll))
                hr = S_OK;
            else
                hr = REGDB_E_INVALIDVALUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }

        RegCloseKey(hKey);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(error);
    }

    return hr;
}


HRESULT NdrpCheckClass(
    IN LPCSTR    pszClassID, 
    IN LPCTSTR   pszDllFileName)
{
    HRESULT hr;
    long    error;
    HKEY    hKeyCLSID;

    //open the CLSID key
    error = RegOpenKeyEx(HKEY_CLASSES_ROOT, 
                         TEXT("CLSID"),
                         0, 
                         KEY_WRITE,
                         &hKeyCLSID);

    if(!error)
    { 
        HKEY hKeyClassID;

        //open registry key for class ID string
        error = RegOpenKeyExA(hKeyCLSID, 
                              pszClassID,
                              0, 
                              KEY_WRITE,
                              &hKeyClassID);

        if(!error)
        {
            hr = CheckInprocServer32(hKeyClassID,
                                     pszDllFileName);

            RegCloseKey(hKeyClassID);          
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }

        RegCloseKey(hKeyCLSID);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(error);
    }

    return hr;
}


HRESULT RPC_ENTRY NdrDllUnregisterProxy (
    IN HMODULE                  hDll,
    IN const ProxyFileInfo **   pProxyFileList, 
    IN const CLSID *            pclsid OPTIONAL)
/*++

Routine Description:
    Removes registry entries for the interfaces contained in the proxy DLL.

Arguments:
    hDll            - Supplies a handle to the proxy DLL.
    pProxyFileList  - Supplies a list of proxy files to be unregistered.
    pclsid          - Supplies the classid for the proxy DLL.  May be zero.

Return Value:
    S_OK

See Also:
    DllUnregisterServer
    NdrDllRegisterProxy

--*/ 
{
    HRESULT hr;
    HKEY    hKeyInterface;
    long    i, j;
    long    error;
    TCHAR   szDllFileName[MAX_PATH];
    ULONG   length;
    char    szClassID[39];

    if(hDll != 0)
    {
        //Get the proxy dll name.
        length = GetModuleFileName(hDll, szDllFileName, sizeof(szDllFileName));

        if(length > 0)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        //The DLL_PROCESS_ATTACH in the proxy DLL failed to initialize hProxyDll.
        hr = E_HANDLE;
    }

    if(SUCCEEDED(hr))
    {
        //Convert the class ID to a registry key name.
        hr = NdrpGetClassID(szClassID, pclsid, pProxyFileList);
    }

    if(SUCCEEDED(hr))
    {
        //Check the class
        hr = NdrpCheckClass(szClassID, szDllFileName);
    }

    if(SUCCEEDED(hr))
    {
        HRESULT hr2;

        //Open the Interface key.
        error = RegOpenKeyEx(HKEY_CLASSES_ROOT, 
                             TEXT("Interface"),
                             0, 
                             KEY_WRITE,
                             &hKeyInterface);

        if (!error)
            {
            //iterate over the list of proxy files in the proxy DLL.
            for(i = 0; 
                pProxyFileList[i] != 0;
                i++)
                {
                if ( pProxyFileList[i]->TableVersion  &  NDR_PROXY_FILE_ASYNC_UUID)
                    {
                    // Iterate through sync and async interfaces.
                    for(j = 0;
                        pProxyFileList[i]->pProxyVtblList[j] != 0;
                        j++)
                        {
                        if ( (ULONG_PTR) pProxyFileList[i]->pAsyncIIDLookup[j] != -1 )
                            {
                            // Unegister a single sync only interface or an sync-async
                            // pair of interfaces. Skip async interfaces.

                            NdrpUnregisterInterface( hKeyInterface, 
                                                     *pProxyFileList[i]->pStubVtblList[j]->header.piid,
                                                     szClassID,
                                                     pProxyFileList[i]->pAsyncIIDLookup[j]);
                            }
                        }
                    }
                else
                    {
                    //iterate over the list of interfaces in the proxy file.
                    for(j = 0;
                        pProxyFileList[i]->pProxyVtblList[j] != 0;
                        j++)
                        {
                        NdrpUnregisterInterface(hKeyInterface, 
                                                *pProxyFileList[i]->pStubVtblList[j]->header.piid,
                                                szClassID,
                                                0 /* no async */);
                        }
                    }
                }

            RegCloseKey(hKeyInterface);
            }
        else
            {
            hr = HRESULT_FROM_WIN32(error);
            }

        //Unregister the class
        hr2 = NdrpUnregisterClass(szClassID, szDllFileName);

       if(FAILED(hr2) && SUCCEEDED(hr))
           hr = hr2;
    }

    return hr;
}


HRESULT NdrpGetClassID(
    OUT LPSTR                    pszClassID, 
    IN  const CLSID *            pclsid,
    IN  const ProxyFileInfo **   pProxyFileList)
/*++

Routine Description:
    Gets a string specifying the Class ID for the PSFactoryBuffer.
    If pclsid is NULL, then this function will use the IID of the 
    first interface as the class ID.

Arguments:
    pszClassID      - The Class ID string is returned in this buffer.
    pclsid          - Specifies the class ID.  May be zero.
    pProxyFileList  - Points to a list of ProxyFiles.

Return Value:
    S_OK
    E_NOINTERFACE

--*/ 
{
    HRESULT hr;
    long i, j;

    //If necessary, use the IID of the first interface as the CLSID.
    for(i = 0; 
        (pProxyFileList[i] != 0) && (!pclsid);
        i++)
    {
        for(j = 0;
            (pProxyFileList[i]->pProxyVtblList[j] != 0) && (!pclsid);
            j++)
        {
            pclsid = pProxyFileList[i]->pStubVtblList[j]->header.piid;
        }
    }

    if(pclsid != 0)
    {
        hr = NdrStringFromIID( *pclsid, pszClassID );
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}


HRESULT NdrpRegisterClass(
    IN LPCSTR    pszClassID, 
    IN LPCTSTR   pszClassName OPTIONAL,
    IN LPCTSTR   pszDllFileName,
    IN LPCTSTR   pszThreadingModel OPTIONAL)

/*++

Routine Description:
    Creates a registry entry for an in-process server class.

Arguments:
    pszClassID          - Supplies the class ID.
    pszClassName        - Supplies the class name.  May be NULL.
    pszDllFileName      - Supplies the DLL file name.
    pszThreadingModel   - Supplies the threading model. May be NULL.
                          The threading model should be one of the following:
                          "Apartment", "Both", "Free".

Return Value:
    S_OK

See Also:
    NdrDllRegisterProxy  
    NdrpUnregisterClass

--*/ 
{
    HRESULT hr;
    long error;
    HKEY hKeyCLSID;
    HKEY hKeyClassID;
    HKEY hKey;
    DWORD dwDisposition;

    //create the CLSID key
    error = RegCreateKeyEx(HKEY_CLASSES_ROOT, 
                           TEXT("CLSID"),
                           0, 
                           TEXT("REG_SZ"), 
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           0,
                           &hKeyCLSID,
                           &dwDisposition);

    if(!error)
    {  
        //Create registry key for class ID 
        error = RegCreateKeyExA(hKeyCLSID, 
                                pszClassID,
                                0, 
                                "REG_SZ", 
                                REG_OPTION_NON_VOLATILE,
                                KEY_WRITE,
                                0,
                                &hKeyClassID,
                                &dwDisposition);

        if(!error)
        {
            //Create InProcServer32 key for the proxy dll
            error = RegCreateKeyEx(hKeyClassID, 
                                   TEXT("InProcServer32"),
                                   0, 
                                   TEXT("REG_SZ"), 
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   0,
                                   &hKey,
                                   &dwDisposition);

            if(!error)
            {
                //register the proxy DLL filename
                error = RegSetValueEx(hKey, 
                                      TEXT(""), 
                                      0, 
                                      REG_SZ,  
                                      (BYTE*)pszDllFileName,
                                      strlen(pszDllFileName) + 1);

                if((!error) && (pszThreadingModel != 0))
                {
                    //register the threading model for the proxy DLL.
                    error = RegSetValueEx(hKey, 
                                          TEXT("ThreadingModel"), 
                                          0, 
                                          REG_SZ, 
                                          (BYTE*)pszThreadingModel,
                                          strlen(pszThreadingModel) + 1);
                }

                RegCloseKey(hKey);
            }

            if((!error) && (pszClassName != 0))
            {
    	        // put the class name in an unnamed value
                error = RegSetValueEx(hKeyClassID, 
                                      TEXT(""), 
                                      0, 
                                      REG_SZ, 
                                      (BYTE*)pszClassName,
                                      strlen(pszClassName) + 1);
            }

            RegCloseKey(hKeyClassID);          
        }

        RegCloseKey(hKeyCLSID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}

HRESULT NdrpRegisterInterface(
    IN HKEY         hKeyInterface,
    IN REFIID       riid, 
    IN LPCSTR       pszInterfaceName,
    IN LPCSTR       pszClassID,
    IN long         NumMethods,
    IN const IID *  riidAsync )

/*++

Routine Description:
    Creates a registry entry for an interface proxy.

Arguments:
    hKeyInterface
    riid
    pszInterfaceName
    pszClassID
    NumMethods
    riidAsync - async iid, may be null.

Return Value:
    S_OK

See Also:
    NdrDllRegisterProxy
    NdrpUnregisterInterface
--*/ 
{
    HRESULT hr;
    long    error;
    char    szIID[39];
    char    szNumMethods[6];
    DWORD   dwDisposition;
    HKEY    hKey;
    HKEY    hKeyIID;

    //convert the IID to a registry key name.
    NdrStringFromIID( riid, szIID );

    //create registry key for the interface
    error = RegCreateKeyExA(hKeyInterface, 
                            szIID,
                            0, 
                            "REG_SZ", 
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            0,
                            &hKeyIID,
                            &dwDisposition);

    if (!error)
    {
        //create ProxyStubClsid32 key.
        error = RegCreateKeyEx(hKeyIID, 
                               TEXT("ProxyStubClsid32"),
                               0,  
                               TEXT("REG_SZ"), 
                               REG_OPTION_NON_VOLATILE,
                               KEY_WRITE,
                               0,
                               &hKey,
                               &dwDisposition);

        if (!error)
        {
            //Set the class id for the PSFactoryBuffer.
            error = RegSetValueExA(hKey, 
                                   "", 
                                   0, 
                                   REG_SZ, 
                                   (BYTE*)pszClassID,
                                   strlen(pszClassID) + 1);

            RegCloseKey(hKey);
        }
    
    	// put the interface name in the unnamed value
        if(!error)
        {
            error = RegSetValueExA(hKeyIID, 
                                   "", 
                                   0, 
                                   REG_SZ, 
                                   (BYTE*)pszInterfaceName,
                                   strlen(pszInterfaceName) + 1);
        }

        //create NumMethods key.
        if(!error)
        {
            error = RegCreateKeyEx(hKeyIID, 
                                   TEXT("NumMethods"),
                                   0, 
                                   TEXT("REG_SZ"), 
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   0,
                                   &hKey,
                                   &dwDisposition);

            if(!error)
            {
                //Set the number of methods
                RpcItoa( NumMethods, szNumMethods, 10 );

                error = RegSetValueExA(hKey, 
                                       "", 
                                       0, 
                                       REG_SZ, 
                                       (UCHAR *) szNumMethods,
                                       strlen(szNumMethods) + 1);

                RegCloseKey(hKey);
            }
        }


        if ( riidAsync )
            {
            //create AsynchronousInterface key under the interface.
            if(!error)
                {
                error = RegCreateKeyEx( hKeyIID, 
                                        TEXT("AsynchronousInterface"),
                                        0, 
                                        TEXT("REG_SZ"), 
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE,
                                        0,
                                        &hKey,
                                        &dwDisposition);
    
                if(!error)
                    {
                    // Set the iid as value for the string.

                    NdrStringFromIID( *riidAsync, szIID );

                    error = RegSetValueExA( hKey, 
                                            "", 
                                            0, 
                                            REG_SZ, 
                                            (UCHAR *) szIID,
                                            strlen(szIID) + 1);
    
                    RegCloseKey(hKey);
                    }
                }
            }

        RegCloseKey(hKeyIID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}

HRESULT NdrpRegisterAsyncInterface(
    IN HKEY     hKeyInterface,
    IN REFIID   riid, 
    IN LPCSTR   pszSyncInterfaceName,
    IN long     SyncNumMethods,
    IN REFIID   riidAsync )

/*++

Routine Description:
    Creates a registry entry for an async interface proxy.

Arguments:
    hKeyInterface
    riid
    pszInterfaceName
    pszClassID
    NumMethods
    riidAsync

Return Value:
    S_OK

See Also:
    NdrDllRegisterProxy
    NdrpUnregisterInterface
--*/ 
{
    HRESULT hr;
    long    error;
    char    szIID[39];
    char    szNumMethods[6];
    DWORD   dwDisposition;
    HKEY    hKey;
    HKEY    hKeyIID;

    //convert the IID to a registry key name.
    NdrStringFromIID( riidAsync, szIID );

    //create registry key for the interface
    error = RegCreateKeyExA(hKeyInterface, 
                            szIID,
                            0, 
                            "REG_SZ", 
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            0,
                            &hKeyIID,
                            &dwDisposition);

    // By definition, for async interfaces do not create Clsid32 key.

    // put the interface name in the unnamed value
    if(!error)
    {
        char *  pszAsyncInterfaceName;
        int     len;

        len = 5 + strlen(pszSyncInterfaceName) + 1; /* 5 is strlen("Async") */

        pszAsyncInterfaceName = (char*)alloca(len);
        
        RpcpMemoryCopy( pszAsyncInterfaceName, "Async", 5 );
        RpcpMemoryCopy( pszAsyncInterfaceName + 5, pszSyncInterfaceName, len - 5 );

        error = RegSetValueExA(hKeyIID, 
                               "", 
                               0, 
                               REG_SZ, 
                               (BYTE*)pszAsyncInterfaceName,
                               len);

        //create NumMethods key.
        if(!error)
        {
            long AsyncNumMethods = 2 * SyncNumMethods - 3;
    
            error = RegCreateKeyEx(hKeyIID, 
                                   TEXT("NumMethods"),
                                   0, 
                                   TEXT("REG_SZ"), 
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   0,
                                   &hKey,
                                   &dwDisposition);
    
            if(!error)
            {
                //Set the number of methods
                RpcItoa( AsyncNumMethods, szNumMethods, 10 );
    
                error = RegSetValueExA(hKey, 
                                       "", 
                                       0, 
                                       REG_SZ, 
                                       (UCHAR *) szNumMethods,
                                       strlen(szNumMethods) + 1);
    
                RegCloseKey(hKey);
            }
        }

        //create SynchronousInterface key under the interface.
        if(!error)
            {
            error = RegCreateKeyEx( hKeyIID, 
                                    TEXT("SynchronousInterface"),
                                    0, 
                                    TEXT("REG_SZ"), 
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_WRITE,
                                    0,
                                    &hKey,
                                    &dwDisposition);
    
            if(!error)
                {
                // Set the iid as value for the string.

                NdrStringFromIID( riid, szIID );

                error = RegSetValueExA( hKey, 
                                        "", 
                                        0, 
                                        REG_SZ, 
                                        (UCHAR *) szIID,
                                        strlen(szIID) + 1);
    
                RegCloseKey(hKey);
                }
            }

        RegCloseKey(hKeyIID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}



HRESULT NdrpUnregisterClass(
    IN LPCSTR    pszClassID, 
    IN LPCTSTR   pszDllFileName)
/*++

Routine Description:
    Removes an in-process server class from the registry.

Arguments:
    pszClassID - Supplies the class ID.

Return Value:
    S_OK

See Also:
  NdrDllUnregisterProxy
  NdrpRegisterClass

--*/ 
{
    HRESULT hr;
    HKEY    hKeyCLSID;
    HKEY    hKeyClassID;
    long    error;
 
    //open the CLSID key
    error = RegOpenKeyEx(HKEY_CLASSES_ROOT, 
                         TEXT("CLSID"),
                         0, 
                         KEY_WRITE,
                         &hKeyCLSID);

    if(!error)
    { 
        //open registry key for class ID string
        error = RegOpenKeyExA(hKeyCLSID, 
                              pszClassID,
                              0, 
                              KEY_WRITE,
                              &hKeyClassID);

        if(!error)
        {
            hr = CheckInprocServer32(hKeyClassID,
                                     pszDllFileName);

            if(SUCCEEDED(hr))
            {
                //delete InProcServer32 key. 
                error = RegDeleteKey(hKeyClassID,
                                     TEXT("InProcServer32"));

                if(error != 0)
                {
                    hr = HRESULT_FROM_WIN32(error);
                }
            }

            RegCloseKey(hKeyClassID);          
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }

        if(SUCCEEDED(hr))
        {
            error = RegDeleteKeyA(hKeyCLSID, pszClassID);

            if(error != 0)
            {
                hr = HRESULT_FROM_WIN32(error);
            }
        }

        RegCloseKey(hKeyCLSID);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(error);
    }

    return hr;
}

HRESULT CheckProxyStubClsid32(
    IN HKEY   hKeyIID,
    IN LPCSTR pszClassID)
{
    HRESULT hr;
    HKEY    hKey;
    char    szClassID[39];
    long    cbData = sizeof(szClassID);
    long    error;
    DWORD   dwType;

    //Open the ProxyStubClsid32 key.
    error = RegOpenKeyEx(hKeyIID, 
                         TEXT("ProxyStubClsid32"),
                         0, 
                         KEY_READ,
                         &hKey);

    if(!error)
    {
        error = RegQueryValueExA(hKey,
                                 "",
                                 0,
                                 &dwType,
                                 (BYTE*)szClassID,
                                 (ulong*)&cbData);

        if(!error)
        {
            if(0 == memcmp(szClassID, pszClassID, cbData))
                hr = S_OK;
            else
                hr = REGDB_E_INVALIDVALUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(error);
        }

        RegCloseKey(hKey);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(error);
    }

    return hr;
}

HRESULT NdrpUnregisterInterface(
    IN HKEY         hKeyInterface,
    IN REFIID       riid, 
    IN LPCSTR       pszClassID,
    IN const IID *  riidAsync )

/*++

Routine Description:
    Unregisters an interface proxy.

Arguments:
    hKeyInterface
    riid

Return Value:
    S_OK


See Also:
    NdrDllUnregisterProxy
    NdrpRegisterInterface

--*/ 
{
    HRESULT hr = S_OK;
    long    error;
    char    szIID[39];
    HKEY    hKeyIID;

    //convert the IID to a registry key name.
    NdrStringFromIID( riid, szIID );

    //Open the IID key.
    error = RegOpenKeyExA(hKeyInterface, 
                          szIID,
                          0, 
                          KEY_WRITE,
                          &hKeyIID);

    if (!error)
        {
        // As we call for sync singles or sync pairs (sync-async),
        // we always have the class id.

        hr = CheckProxyStubClsid32(hKeyIID, pszClassID);
        if(SUCCEEDED(hr))
            {
            // Once the class id matches, just attempt to delete
            // every possible key that may happen under the sync entry.

            // Note that additional key may be present due to oleauto
            // registering a TLB.

            RegDeleteKey(hKeyIID, TEXT("NumMethods"));
            RegDeleteKey(hKeyIID, TEXT("ProxyStubClsid32"));
            RegDeleteKey(hKeyIID, TEXT("AsynchronousInterface"));

            // Now remove the matching async interface entry, if there is one.

            if ( riidAsync )
                {
                char    szAsyncIID[39];
                HKEY    hKeyAsyncIID;

                //convert the IID to a registry key name.
                NdrStringFromIID( *riidAsync, szAsyncIID );
            
                //Open the IID key.
                error = RegOpenKeyExA(hKeyInterface, 
                                      szAsyncIID,
                                      0, 
                                      KEY_WRITE,
                                      &hKeyAsyncIID);

                if ( !error )
                    {
                    RegDeleteKey( hKeyAsyncIID, TEXT("NumMethods"));
                    RegDeleteKey( hKeyAsyncIID, TEXT("SynchronousInterface"));
        
                    RegCloseKey(hKeyAsyncIID);
                    RegDeleteKeyA(hKeyInterface, szAsyncIID);
                    }
            
                }
            }
        else
            hr = S_FALSE;

        //Close the IID key.
        RegCloseKey(hKeyIID);
        RegDeleteKeyA(hKeyInterface, szIID);
        }    

    return hr;
}

STDAPI DllRegisterServer(void)
/*++

Routine Description:
    Creates registry entries for the classes contained in rpcrt4.dll.

Return Value:
    S_OK

--*/ 
{
    HRESULT hr;
    TCHAR   szDllFileName[MAX_PATH];
    ULONG   length;

    if(!g_hRpcrt4)
        return E_HANDLE;

    //Get the proxy dll name.
    length = GetModuleFileName(g_hRpcrt4,
                               szDllFileName,
                               sizeof(szDllFileName));

    if(length > 0)
    {
        //Register the class
        hr = NdrpRegisterClass(TEXT("{b5866878-bd99-11d0-b04b-00c04fd91550}"),
                               TEXT("TypeFactory"),
                               szDllFileName,
                               TEXT("Both"));
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\stream.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994 Microsoft Corporation.  All rights reserved.

Module Name:
    stream.cxx

Abstract:
    Implements the IStream interface on a memory buffer.

Author:
    ShannonC    09-Mar-1994

Environment:
    Windows NT and Windows 95.  We do not support DOS and Win16.

Revision History:
    12-Oct-94   ShannonC    Reformat for code review.

--*/

#include <ndrp.h>
#include <ndrole.h>

class CNdrStream : public IStream
{
public:
    virtual HRESULT STDMETHODCALLTYPE 
    QueryInterface(
        IN  REFIID riid, 
        OUT void **ppvObj);

    virtual ULONG STDMETHODCALLTYPE 
    AddRef();

    virtual ULONG STDMETHODCALLTYPE 
    Release();

    virtual HRESULT STDMETHODCALLTYPE 
    Read(
        IN  void *  pv, 
        IN  ULONG   cb, 
        OUT ULONG * pcbRead);

    virtual HRESULT STDMETHODCALLTYPE 
    Write(
        IN  void const *pv, 
        IN  ULONG       cb, 
        OUT ULONG *     pcbWritten);

    virtual HRESULT STDMETHODCALLTYPE 
    Seek(
        IN  LARGE_INTEGER   dlibMove, 
        IN  DWORD           dwOrigin, 
        OUT ULARGE_INTEGER *plibNewPosition);

    virtual HRESULT STDMETHODCALLTYPE 
    SetSize(
        IN  ULARGE_INTEGER libNewSize);

    virtual HRESULT STDMETHODCALLTYPE 
    CopyTo(
        IN  IStream *       pstm,
        IN  ULARGE_INTEGER  cb,
        OUT ULARGE_INTEGER *pcbRead,
        OUT ULARGE_INTEGER *pcbWritten);

    virtual HRESULT STDMETHODCALLTYPE 
    Commit(
        IN  DWORD grfCommitFlags);

    virtual HRESULT STDMETHODCALLTYPE 
    Revert();

    virtual HRESULT STDMETHODCALLTYPE 
    LockRegion(
        IN  ULARGE_INTEGER  libOffset,
        IN  ULARGE_INTEGER  cb,
        IN  DWORD           dwLockType);

    virtual HRESULT STDMETHODCALLTYPE 
    UnlockRegion(
        IN  ULARGE_INTEGER  libOffset,
        IN  ULARGE_INTEGER  cb,
        IN  DWORD           dwLockType);

    virtual HRESULT STDMETHODCALLTYPE 
    Stat(
        OUT STATSTG *   pstatstg, 
        IN  DWORD       grfStatFlag);

    virtual HRESULT STDMETHODCALLTYPE 
    Clone(
        OUT IStream **ppstm);

    CNdrStream(
        IN  unsigned char * pData, 
        IN  unsigned long   cbMax);

private:
    long            RefCount;
    unsigned char * pBuffer;
    unsigned long   cbBufferLength;
    unsigned long   position;
};

EXTERN_C IStream *STDAPICALLTYPE 
NdrpCreateStreamOnMemory(
    IN  unsigned char * pData, 
    IN  unsigned long   cbSize)
/*++

Routine Description:
    This function creates a stream on the specified memory buffer.

Arguments:
    pData   - Supplies pointer to memory buffer.
    cbSize  - Supplies size of memory buffer.

Return Value:
    This function returns a pointer to the newly created stream.

--*/ 
{
    CNdrStream *pStream = new CNdrStream(pData, cbSize);
    return (IStream *)pStream;
}

CNdrStream::CNdrStream(
    IN  unsigned char * pData, 
    IN  unsigned long   cbMax)
    : pBuffer(pData), cbBufferLength(cbMax)
/*++

Routine Description:
    This function creates a stream on the specified memory buffer.

Arguments:
    pData - Supplies pointer to memory buffer.
    cbMax - Supplies size of memory buffer.

Return Value:
    None.

--*/ 
{
    RefCount = 1;
    position = 0;
}


ULONG STDMETHODCALLTYPE 
CNdrStream::AddRef()
/*++

Routine Description:
    Increment the reference count.

Arguments:

Return Value:
    Reference count.

--*/ 
{
    InterlockedIncrement(&RefCount);
    return (ULONG) RefCount;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Clone(
    OUT IStream **ppstm)
/*++

Routine Description:
    Create a new IStream object.  The new IStream gets an 
    independent seek pointer but it shares the underlying
    data buffer with the original IStream object.

Arguments:
    ppstm - Pointer to the new stream.

Return Value:
    S_OK            - The stream was successfully copied.
    E_OUTOFMEMORY   - The stream could not be copied due to lack of memory.

--*/ 
{
    HRESULT     hr;
    CNdrStream *pStream = new CNdrStream(pBuffer, cbBufferLength);

    if(pStream != 0)
    {
        pStream->position = position;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    *ppstm = (IStream *) pStream;

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Commit(
    IN DWORD grfCommitFlags)
/*++

Routine Description:
    This stream does not support transacted mode.  This function does nothing.

Arguments:
    grfCommitFlags

Return Value:
    S_OK

--*/ 
{
  return S_OK;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::CopyTo(
    IN  IStream *       pstm,
    IN  ULARGE_INTEGER  cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Routine Description:
    Copies data from one stream to another stream.

Arguments:
    pstm        - Specifies the destination stream.
    cb          - Specifies the number of bytes to be copied to the destination stream.
    pcbRead     - Returns the number of bytes read from the source stream.
    pcbWritten  - Returns the number of bytes written to the destination stream.

Return Value:
    S_OK        - The data was successfully copied.
    Other errors from IStream::Write.

--*/ 
{
    HRESULT         hr;
    unsigned char * pSource;
    unsigned long   cbRead;
    unsigned long   cbWritten;
    unsigned long   cbRemaining;

    //Check if we are going off the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if((cb.HighPart == 0) && (cb.LowPart <= cbRemaining))
        cbRead = cb.LowPart;
    else
        cbRead = cbRemaining;

    pSource = pBuffer + position;

    //copy the data
    hr = pstm->Write(pSource, cbRead, &cbWritten);

    //advance the current position
    position += cbRead;

    if (pcbRead != 0)
    {
        pcbRead->LowPart = cbRead;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten != 0)
    {
        pcbWritten->LowPart = cbWritten;
        pcbWritten->HighPart = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::LockRegion(
    IN ULARGE_INTEGER   libOffset,
    IN ULARGE_INTEGER   cb,
    IN DWORD            dwLockType)
/*++

Routine Description:
    Range locking is not supported by this stream.

Return Value:
    STG_E_INVALIDFUNCTION.

--*/ 
{
    return STG_E_INVALIDFUNCTION;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::QueryInterface( 
    REFIID riid, 
    void **ppvObj)
/*++

Routine Description:
    Query for an interface on the stream.  The stream supports
    the IUnknown and IStream interfaces.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

--*/ 
{
    HRESULT hr;

    if ((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
       (memcmp(&riid, &IID_IStream, sizeof(IID)) == 0))
    {
        this->AddRef();
        *ppvObj = (IStream *) this;
        hr = S_OK;
    }
    else
    {
        *ppvObj = 0;
        hr = E_NOINTERFACE;
    }
    
    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Read(
    OUT void * pv,
    IN  ULONG  cb, 
    OUT ULONG *pcbRead)
/*++

Routine Description:
    Reads data from the stream starting at the current seek pointer.

Arguments:
    pv      - Returns the data read from the stream.
    cb      - Supplies the number of bytes to read from the stream.
    pcbRead - Returns the number of bytes actually read from the stream.

Return Value:
    S_OK    - The data was successfully read from the stream.
    S_FALSE - The number of bytes read was smaller than the number requested.

--*/ 
{
    HRESULT         hr;
    unsigned long   cbRead;
    unsigned long   cbRemaining;

    //Check if we are reading past the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if(cb <= cbRemaining)
    {
        cbRead = cb;
        hr = S_OK;
    }
    else
    {
        cbRead = cbRemaining;
        hr = S_FALSE;
    }

    //copy the data
    RpcpMemoryCopy(pv, pBuffer + position, cbRead);

    //advance the current position
    position += cbRead;
    
    if(pcbRead != 0)
        *pcbRead = cbRead;

    return hr;
}

ULONG STDMETHODCALLTYPE 
CNdrStream::Release()
/*++

Routine Description:
    Decrement the reference count.  When the reference count
    reaches zero, the stream is deleted.

Arguments:

Return Value:
    Reference count.

--*/ 
{
    unsigned long count;

    count = RefCount - 1;
    if(InterlockedDecrement(&RefCount) == 0)
    {
        count = 0;
        delete this;
    }

    return count;
}


HRESULT STDMETHODCALLTYPE 
CNdrStream::Revert()
/*++

Routine Description:
    This stream does not support transacted mode.  This function does nothing.

Arguments:
    None.

Return Value:
    S_OK.

--*/ 
{
  return S_OK;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Seek(
    IN  LARGE_INTEGER   dlibMove,
    IN  DWORD           dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition)
/*++

Routine Description:
    Sets the position of the seek pointer.  It is an error to seek
    before the beginning of the stream or past the end of the stream.

Arguments:
    dlibMove        - Supplies the offset from the position specified in dwOrigin.
    dwOrigin        - Supplies the seek mode.
    plibNewPosition - Returns the new position of the seek pointer.

Return Value:
    S_OK                    - The seek pointer was successfully adjusted.
    STG_E_INVALIDFUNCTION   - dwOrigin contains invalid value.
    STG_E_SEEKERROR         - The seek pointer cannot be positioned before the
                              beginning of the stream or past the 
                              end of the stream.

--*/ 
{
    HRESULT         hr;
    long            high;
    long            low;
    unsigned long   offset;
    unsigned long   cbRemaining;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        //Set the seek position relative to the beginning of the stream.
        if((dlibMove.HighPart == 0) && (dlibMove.LowPart <= cbBufferLength))
        {
            position = dlibMove.LowPart;
            hr = S_OK;
        }
        else
        {
            //It is an error to seek past the end of the stream.
            hr = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:
        //Set the seek position relative to the current position of the stream.
        high = (long) dlibMove.HighPart;
        if(high < 0)
        {
            //Negative offset
            low = (long) dlibMove.LowPart;
            offset = -low;
            
            if((high == -1) && (offset <= position))
            {
                position -= offset;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek before the beginning of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        else
        {
            //Positive offset
            if(position < cbBufferLength)
                cbRemaining = cbBufferLength - position;
            else
                cbRemaining = 0;
    
            if((dlibMove.HighPart == 0) && (dlibMove.LowPart <= cbRemaining))
            {
                position += dlibMove.LowPart;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek past the end of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        break;

    case STREAM_SEEK_END:
    //Set the seek position relative to the end of the stream.
        high = (long) dlibMove.HighPart;
        if(high < 0)
        {
            //Negative offset
            low = (long) dlibMove.LowPart;
            offset = -low;
            
            if((high == -1) && (offset <= cbBufferLength))
            {
                position = cbBufferLength - offset;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek before the beginning of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        else if(dlibMove.QuadPart == 0)
        {
            position = cbBufferLength;
            hr = S_OK;
        }
        else
        {
            //Positive offset
            //It is an error to seek past the end of the stream.
            hr = STG_E_SEEKERROR;
        }
        break;

    default:
        //dwOrigin contains an invalid value.
        hr = STG_E_INVALIDFUNCTION;
    }

    if (plibNewPosition != 0)
    {
        plibNewPosition->LowPart = position;
        plibNewPosition->HighPart = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::SetSize(
    IN ULARGE_INTEGER libNewSize)
/*++

Routine Description:
    Changes the size of the stream.  

Arguments:
    libNewSize - Supplies the new size of the stream.

Return Value:
    S_OK                - The stream size was successfully changed.
    STG_E_MEDIUMFULL    - The stream size could not be changed.

--*/ 
{
    HRESULT hr;

    if((libNewSize.HighPart == 0) && (libNewSize.LowPart <= cbBufferLength))
    {
        cbBufferLength = libNewSize.LowPart;
        hr = S_OK;
    }
    else
    {
        hr = STG_E_MEDIUMFULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Stat(
    OUT STATSTG *   pstatstg, 
    IN  DWORD       grfStatFlag)
/*++

Routine Description:
    This function gets information about this stream.

Arguments:
    pstatstg    - Returns information about this stream.
    grfStatFlg  - Specifies the information to be returned in pstatstg.

Return Value:
    S_OK.

--*/ 
{
    memset(pstatstg, 0, sizeof(STATSTG));
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = cbBufferLength;
    pstatstg->cbSize.HighPart = 0;
       
    return S_OK;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::UnlockRegion(
    IN ULARGE_INTEGER   libOffset,
    IN ULARGE_INTEGER   cb,
    IN DWORD            dwLockType)
/*++

Routine Description:
    Range locking is not supported by this stream.

Return Value:
    STG_E_INVALIDFUNCTION.

--*/ 
{
    return STG_E_INVALIDFUNCTION;
}

HRESULT STDMETHODCALLTYPE 
CNdrStream::Write(
    IN  void const *pv,
    IN  ULONG       cb,
    OUT ULONG *     pcbWritten)
/*++

Routine Description:
    Write data to the stream starting at the current seek pointer.

Arguments:
    pv          - Supplies the data to be written to the stream.
    cb          - Specifies the number of bytes to be written to the stream.
    pcbWritten  - Returns the number of bytes actually written to the stream.

Return Value:
    S_OK                - The data was successfully written to the stream.
    STG_E_MEDIUMFULL    - Data cannot be written past the end of the stream.

--*/ 
{
    HRESULT         hr;
    unsigned long   cbRemaining;
    unsigned long   cbWritten;

    //Check if we are writing past the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;
    
    if(cb <= cbRemaining)
    {
        cbWritten = cb;
        hr = S_OK;
    }
    else
    {
        cbWritten = cbRemaining;
        hr = STG_E_MEDIUMFULL;
    }

    // Write the data.
    RpcpMemoryCopy(pBuffer + position, pv, cbWritten);

    //Advance the current position
    position += cbWritten;

    //update pcbWritten
    if (pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\tiutil.h ===
// Copyright (c) 1993-1999 Microsoft Corporation

#ifndef _TIUTIL_H_
#define _TIUTIL_H_

// This is a special value that is used internally for marshaling interfaces
#define VT_INTERFACE (VT_CLSID+1)
#define VT_MULTIINDIRECTIONS (VT_TYPEMASK - 1)

#define IfFailGo(expression, label)	\
    { hresult = (expression);		\
      if(FAILED(hresult))	\
	goto label;         		\
    }

#define IfFailRet(expression)		\
    { HRESULT hresult = (expression);	\
      if(FAILED(hresult))	\
	return hresult;			\
    }

class PARAMINFO;

HRESULT 
VarVtOfTypeDesc(
    IN  ITypeInfo * pTypeInfo,
    IN  TYPEDESC  * pTypeDesc,
    OUT PARAMINFO * pParamInfo);

HRESULT 
VarVtOfUDT(
    IN  ITypeInfo  * pTypeInfo,
    IN  TYPEDESC   * pTypeDesc,
    OUT  PARAMINFO * pParamInfo);

HRESULT VarVtOfIface(
    IN  ITypeInfo * pTypeInfo,
    IN  TYPEATTR  * pTypeAttr,
    OUT PARAMINFO * pParamInfo);


#endif //_TIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\typegen.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       typegen.h
//
//  Contents:   Generates a type format string from an ITypeInfo.
//
//  Classes:    CTypeGen
//
//  History:    26-Apr-97 ShannonC  Created
//
//----------------------------------------------------------------------------
#ifndef _TYPEGEN_H_
#define _TYPEGEN_H_

#include <ndrtypes.h>
#include <tiutil.h>

#ifndef _PARAMINFO
#define _PARAMINFO

class PARAMINFO
{
public:
    PARAMINFO() 
        {vt = VT_ILLEGAL;
         pTypeInfo = NULL; 
         pArray = NULL; 
         pTypeAttr = NULL; 
         cbAlignment = 7; 
         lLevelCount = 0;
         realvt = VT_ILLEGAL;
         }
    DWORD   wIDLFlags;
    VARTYPE vt;
    ITypeInfo *  pTypeInfo;
    TYPEATTR* pTypeAttr;
    USHORT cbAlignment;
    LONG   lLevelCount;
    VARTYPE realvt;
    union
    {
        IID         iid;
        ARRAYDESC *pArray;
    };
    ~PARAMINFO() {
// this header file is included form both typeinfo.h, where CINTERFACE is defined, 
// and udt.cxx, where CINTERFACE is NOT defined. 
#ifndef CINTERFACE
        if (pTypeInfo)
        {
            if (pTypeAttr)   // we got it from TKIND_ALIAS. need to free both
                pTypeInfo->ReleaseTypeAttr(pTypeAttr);
            pTypeInfo->Release();
        }
#else
        if (pTypeInfo)
        {
            if (pTypeAttr)   // we got it from TKIND_ALIAS. need to free both
                pTypeInfo->lpVtbl->ReleaseTypeAttr(pTypeInfo,pTypeAttr);
            pTypeInfo->lpVtbl->Release(pTypeInfo);
        }
#endif
    }

};


#endif

// memory/wire information about different data types
// short is enough as the biggest struct size is 64k.
typedef struct _MemoryInfo
{
USHORT MemorySize;
USHORT MemoryAlignment;
USHORT WireSize;
USHORT WireAlignment;
} MemoryInfo;

// When changing the MIDL compiler version to 5.1.158 or higher, please remember to fix
// the RpcFlags in typeinfo.cxx\GetProcFormat routine.

#define rmj 3
#define rmm 0
#define rup 44
#define MIDL_VERSION_3_0_44 (rmj<<24 | rmm << 16 | rup)
class CTypeGen
{
private:
    PFORMAT_STRING _pTypeFormat;
    USHORT         _cbTypeFormat;
    USHORT         _offset;
    ULONG          _uStructSize;

    void Init();

    HRESULT GrowTypeFormat(
        IN  USHORT cb);

    HRESULT PushStruct(
        IN  PARAMINFO        * parainfo,
        IN  FORMAT_CHARACTER   fcStruct,
        IN  VARDESC         ** ppVarDesc,
        IN  USHORT           * poffsets,
        IN  MemoryInfo            * pFieldInfos,
        IN  USHORT             size, 
        OUT USHORT           * pOffset,
        OUT MemoryInfo            * pStructInfo);
		
    HRESULT PushByte(
        IN  byte b);

    HRESULT PushShort(
        IN  USHORT s);

    HRESULT PushOffset(
        IN  USHORT s);

    HRESULT PushIID(
        IN  IID iid);

    HRESULT PushLong(
        IN  ULONG s);
    
    HRESULT SetShort(
        IN  USHORT offset,
        IN  USHORT data);

    HRESULT SetByte(
        IN  USHORT offset,
        IN  BYTE   data);

    HRESULT GetShort(
        IN  USHORT  offset,
        OUT USHORT* data);
	    
    HRESULT GetByte(
        IN  USHORT offset,
        OUT BYTE * data);

    HRESULT RegisterInterfacePointer(
        IN  PARAMINFO * parainfo,
        OUT USHORT    * pOffset);

    HRESULT GetMemoryInfoForSimpleType(
        VARTYPE vt,
        MemoryInfo *pSimpleTypeInfo);
    
    HRESULT GenStructSimpleTypesFormatString(
        IN  PARAMINFO * parainfo,
        IN  VARDESC   * pVarDesc,
        OUT USHORT    * pad);
	    
    
    HRESULT RegisterSafeArray(
        IN  PARAMINFO * parainfo,
        OUT USHORT    * pOffset);

    HRESULT RegisterStruct(
        IN  PARAMINFO * parainfo,
    	OUT USHORT    * pOffset,
    	OUT MemoryInfo     * pStructInfo);

    HRESULT RegisterUDT(
        IN  PARAMINFO * parainfo,
    	OUT USHORT    * pOffset,
    	OUT MemoryInfo     * pStructInfo);

    HRESULT ConvertStructToBogusStruct(
        IN  USHORT offset);

    HRESULT ParseStructMembers(
        IN PARAMINFO *parainfo,
        IN OUT FORMAT_CHARACTER *pfcStruct,
        IN VARDESC **ppVarDesc,
        IN USHORT *poffsets,
        IN MemoryInfo *pFieldInfos,
        IN USHORT uNumElements,
        OUT MemoryInfo *pStructInfo);
    
	USHORT Alignment(DWORD dwReq,DWORD dwMax);

public:
    CTypeGen();

    ~CTypeGen();

    HRESULT RegisterType(
        IN  PARAMINFO * parainfo,
        OUT USHORT    * pOffset,
        OUT MemoryInfo     * pStructInfo);

    HRESULT GetOffset(
        IN  USHORT   addr,
        OUT USHORT * poffset);
		
    HRESULT GetTypeFormatString(
        OUT PFORMAT_STRING * pTypeFormatString,
        OUT USHORT         * pLength);
        
    // Simple, non-destructive version of GetTypeFormatString
    PFORMAT_STRING GetFormatString()    {return _pTypeFormat;}

    HRESULT RegisterCArray(
        IN PARAMINFO * parainfo,
    	OUT USHORT   * pOffset,
        OUT MemoryInfo    * pStructInfo);
        
    HRESULT AdjustTopLevelRef(USHORT offset);

    ULONG GetStructSize()       {return _uStructSize;}

    void UpdateStructInfo( MemoryInfo *pStructInfo, 
                                              VARTYPE vtnoref,
                                              long IsRef,
                                              USHORT maxMemoryAlignment );
};

HRESULT ReleaseTypeFormatString(
    PFORMAT_STRING pTypeFormat);

#endif // _TYPEGEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\stub.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994-2000 Microsoft Corporation.  All rights reserved.

Module Name:
    stub.c

Abstract:
    Implements the IRpcStubBuffer interface.

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT and Windows 95.  We do not support DOS and Win16.

Revision History:

--*/

#define USE_STUBLESS_PROXY
#define CINTERFACE
                 
#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>
#include <stddef.h>
#include "ndrtypes.h"

EXTERN_C const IID IID_IPrivStubBuffer = { /* 3e0ac23f-eff6-41f3-b44b-fbfa4544265f */
    0x3e0ac23f,
    0xeff6,
    0x41f3,
    {0xb4, 0x4b, 0xfb, 0xfa, 0x45, 0x44, 0x26, 0x5f}
  };

const IID * RPC_ENTRY
NdrpGetStubIID(
    IRpcStubBuffer *This);

void
MakeSureWeHaveNonPipeArgs(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferSize );


BOOL NdrpFindInterface(
    IN  const ProxyFileInfo **  pProxyFileList,
    IN  REFIID                  riid,
    OUT const ProxyFileInfo **  ppProxyFileInfo,
    OUT long *                  pIndex );

extern void ReleaseTemplateForwardVtbl(void ** pVtbl);

//+-------------------------------------------------------------------------
//
//  Global data
//
//--------------------------------------------------------------------------

// ICallFactory interface on the StubBuffer objects.
// ICallFactory is an interface on a sync stub only.
// It has been introduced for NT5 beta2.

extern const ICallFactoryVtbl CStdStubBuffer_CallFactoryVtbl = {
    CStdStubBuffer_CF_QueryInterface,
    CStdStubBuffer_CF_AddRef,
    CStdStubBuffer_CF_Release,
    CStdStubBuffer_CF_CreateCall };

extern const ICallFactoryVtbl CStdStubBuffer2_CallFactoryVtbl = {
    CStdStubBuffer_CF_QueryInterface,
    CStdStubBuffer_CF_AddRef,
    CStdStubBuffer_CF_Release,
    CStdStubBuffer2_CF_CreateCall };

extern const IReleaseMarshalBuffersVtbl CStdStubBuffer_ReleaseMarshalBuffersVtbl = {
    CStdStubBuffer_RMB_QueryInterface,
    CStdStubBuffer_RMB_AddRef,
    CStdStubBuffer_RMB_Release,
    CStdStubBuffer_RMB_ReleaseMarshalBuffer};

extern const IReleaseMarshalBuffersVtbl CStdAsyncStubBuffer_ReleaseMarshalBuffersVtbl = {
    CStdStubBuffer_RMB_QueryInterface,
    CStdStubBuffer_RMB_AddRef,
    CStdStubBuffer_RMB_Release,
    CStdAsyncStubBuffer_RMB_ReleaseMarshalBuffer };

extern const ISynchronizeVtbl CStdAsyncStubBuffer_ISynchronizeVtbl = {
    CStdAsyncStubBuffer_Synchronize_QueryInterface,
    CStdAsyncStubBuffer_Synchronize_AddRef,
    CStdAsyncStubBuffer_Synchronize_Release,
    CStdAsyncStubBuffer_Synchronize_Wait,
    CStdAsyncStubBuffer_Synchronize_Signal,
    CStdAsyncStubBuffer_Synchronize_Reset };



//+-------------------------------------------------------------------------
//
//  End of Global data
//
//--------------------------------------------------------------------------


#pragma code_seg(".orpc")

//
//  ICallFactory interface on the sync stub object.
//

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_CF_QueryInterface(
    IN  ICallFactory   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdStubBuffer,
        CStdStubBuffer2,
        CStdAsyncStubBuffer,


--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pCallFactoryVtbl) - offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->QueryInterface( pStubBuffer,
                                                riid,
                                                ppvObject );
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CF_AddRef(
    IN  ICallFactory   *This )
/*++

Routine Description:
    No need to go through punkOuter.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pCallFactoryVtbl) - offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->AddRef( pStubBuffer );
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CF_Release(
    IN  ICallFactory   *This )
/*++

Routine Description:

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pCallFactoryVtbl) - offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->Release( pStubBuffer );
}



HRESULT
NdrpCreateNonDelegatedAsyncStub(
    IN  IRpcStubBuffer     *This,
    IN  REFIID              riid,      // async IID
    IN  IUnknown *          punkOuter, // controlling unknown
    OUT IRpcStubBuffer **   ppAsyncStub
    )
{
    BOOL                    fFound;
    long                    j;   // if index
    const ProxyFileInfo *   pProxyFileInfo;

    CStdStubBuffer *        pSyncSB = (CStdStubBuffer *)This;
    CStdAsyncStubBuffer *   pAsyncSB;

    *ppAsyncStub = 0;

    if ( ! pSyncSB->pCallFactoryVtbl  ||  !pSyncSB->pAsyncIID )
        return E_NOINTERFACE;

    if ( memcmp( &riid, pSyncSB->pAsyncIID, sizeof(IID)) != 0 )
        return E_NOINTERFACE;

    if ( 0 == pSyncSB->pvServerObject )
        return CO_E_OBJNOTCONNECTED;

    if ( 0 != punkOuter )
        return CLASS_E_NOAGGREGATION;

    // same file, so we can use the sync pPSFactory.

    fFound = NdrpFindInterface( ((CStdPSFactoryBuffer *)pSyncSB->pPSFactory)->pProxyFileList,
                                riid,
                                &pProxyFileInfo,
                                & j);
    if ( !fFound )
        return E_NOINTERFACE;

    pAsyncSB = (CStdAsyncStubBuffer *)(*pfnCoTaskMemAlloc)(sizeof(CStdAsyncStubBuffer));

    if( ! pAsyncSB )
        return E_OUTOFMEMORY;

    memset( pAsyncSB, 0, sizeof(CStdAsyncStubBuffer));

    //Initialize the new stub buffer.
    pAsyncSB->lpVtbl   = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
    pAsyncSB->RefCount = 1;
    pAsyncSB->pSynchronizeVtbl = & CStdAsyncStubBuffer_ISynchronizeVtbl;

    // Create the stub disconnected from the server call object.
    // There will be a separate Connect call later.
    //      pAsyncSB->pvServerObject = 0;

    NdrpAsyncStubMsgConstructor( pAsyncSB );

    //Increment the DLL reference count for DllCanUnloadNow.
    pSyncSB->pPSFactory->lpVtbl->AddRef( pSyncSB->pPSFactory );
    pAsyncSB->pPSFactory = pSyncSB->pPSFactory;

    *ppAsyncStub = (IRpcStubBuffer *) & pAsyncSB->lpVtbl;

    return S_OK;
}


HRESULT
NdrpCreateDelegatedAsyncStub(
    IN  IRpcStubBuffer         *This,
    IN  REFIID                  riid,      // async IID
    IN  IUnknown *              punkOuter, // controlling unknown
    OUT IRpcStubBuffer **       ppAsyncStub
    )
{
    HRESULT                 hr;
    BOOL                    fFound;
    long                    j;   // if index
    const ProxyFileInfo *   pProxyFileInfo;
    BOOL                    fDelegate = FALSE;

    CStdStubBuffer2 *       pSyncSB = (CStdStubBuffer2 *)This;
    CStdAsyncStubBuffer  *  pAsyncSB;
    ICallFactory *          pCallFactory;
    IRpcStubBuffer *        pBaseSyncSB;

    *ppAsyncStub = 0;

    pSyncSB = (CStdStubBuffer2 *) ((uchar*)This -
                                  offsetof(CStdStubBuffer2,lpVtbl)) ;

    if ( ! pSyncSB->pCallFactoryVtbl  ||  !pSyncSB->pAsyncIID )
        return E_NOINTERFACE;

    if ( memcmp( &riid, pSyncSB->pAsyncIID, sizeof(IID)) != 0 )
        return E_NOINTERFACE;

    if ( 0 == pSyncSB->pvServerObject )
        return CO_E_OBJNOTCONNECTED;

    if ( 0 != punkOuter )
        return CLASS_E_NOAGGREGATION;

    // same file, so we can use the sync pPSFactory.

    fFound = NdrpFindInterface( ((CStdPSFactoryBuffer *)pSyncSB->pPSFactory)->pProxyFileList,
                                riid,
                                &pProxyFileInfo,
                                & j);
    if ( !fFound )
        return E_NOINTERFACE;

    pAsyncSB = (CStdAsyncStubBuffer*)(*pfnCoTaskMemAlloc)(sizeof(CStdAsyncStubBuffer));

    if( ! pAsyncSB )
        return E_OUTOFMEMORY;

    memset( pAsyncSB, 0, sizeof(CStdAsyncStubBuffer));

    //Initialize the new stub buffer.
    pAsyncSB->lpVtbl   = &pProxyFileInfo->pStubVtblList[j]->Vtbl;
    pAsyncSB->RefCount = 1;
    pAsyncSB->pSynchronizeVtbl = & CStdAsyncStubBuffer_ISynchronizeVtbl;

    // As the Connect connects to real server we don't need that.
    // pAsyncSB->lpForwardingVtbl = & ForwardingVtbl;

    // Create the stub disconnected from the server call object.
    // There will be a separate Connect call later.
    //      pAsyncSB->pvServerObject = 0;

    // Create an async stub for the base interface.
    // We don't know if the base is delegated, so we have to use
    //  the base create call method.
    // The base async stub will also be disconnected.

    pBaseSyncSB = pSyncSB->pBaseStubBuffer;

    hr = pBaseSyncSB->lpVtbl->QueryInterface( pBaseSyncSB,
                                              IID_ICallFactory,
                                              (void**)& pCallFactory );

    if ( SUCCEEDED(hr) )
        {
        // Aggregate the base async stub with the current async stub,
        // not with the channel's punkOuter.
        // We should not need it, and the base stub is aggregated with
        // upper stub mostly for debug tracing.

        const IID * pBaseAsyncIID;

        pBaseAsyncIID = *(const IID **) ( (uchar*)pBaseSyncSB
                                           + offsetof(CStdStubBuffer, pAsyncIID) );

        hr = pCallFactory->lpVtbl->CreateCall( pCallFactory,
                                               *pBaseAsyncIID,
                                               0, // no need for punkOuter (IUnknown*) & pAsyncSB->lpVtbl,
                                               IID_IUnknown,
                                               (IUnknown**)& pAsyncSB->pBaseStubBuffer );

        pCallFactory->lpVtbl->Release( pCallFactory );
        }

    if(SUCCEEDED(hr))
        {
        NdrpAsyncStubMsgConstructor( pAsyncSB );

        //Increment the DLL reference count for DllCanUnloadNow.
        pSyncSB->pPSFactory->lpVtbl->AddRef( pSyncSB->pPSFactory );
        pAsyncSB->pPSFactory = pSyncSB->pPSFactory;

        *ppAsyncStub = (IRpcStubBuffer *) & pAsyncSB->lpVtbl;
        }
    else
        {
        (*pfnCoTaskMemFree)(pAsyncSB);
        }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_CF_CreateCall(
    IN  ICallFactory *This,
    IN  REFIID        riid,
    IN  IUnknown *    punkOuter, // controlling unknown
    IN  REFIID        riid2,
    OUT IUnknown **   ppv
    )
/*
    Creates a call object, i.e. an async stub object.

    Note, because the call comes via a CStdStubBuffer, not Buffer2,
    we know that we need to create only a non-delegated async stub.
*/
{
    IRpcStubBuffer * pStubBuffer;

    if ( memcmp( &riid2, & IID_IUnknown, sizeof(IID)) != 0 )
        return E_INVALIDARG;

    pStubBuffer = (IRpcStubBuffer*) (((uchar *)This)
                            - offsetof(CStdStubBuffer, pCallFactoryVtbl)
                            + offsetof(CStdStubBuffer, lpVtbl) );

    return NdrpCreateNonDelegatedAsyncStub( pStubBuffer,
                                            riid,
                                            punkOuter,
                                            (IRpcStubBuffer **) ppv );
}

HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_CF_CreateCall(
    IN  ICallFactory *This,
    IN  REFIID        riid,
    IN  IUnknown *    punkOuter, // controlling unknown
    IN  REFIID        riid2,
    OUT IUnknown **   ppv
    )
/*
    Creates a call object, i.e. an async stub object.

    Note, because the call comes via a CStdStubBuffer, not Buffer2,
    we know that we need to create only a non-delegated async stub.
*/
{
    IRpcStubBuffer * pStubBuffer;

    if ( memcmp( &riid2, & IID_IUnknown, sizeof(IID)) != 0 )
        return E_INVALIDARG;

    pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This
                            - offsetof(CStdStubBuffer2, pCallFactoryVtbl)
                            + offsetof(CStdStubBuffer2, lpVtbl) );

    return NdrpCreateDelegatedAsyncStub( pStubBuffer,
                                         riid,
                                         punkOuter,
                                         (IRpcStubBuffer **) ppv );
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_RMB_QueryInterface(
    IN  IReleaseMarshalBuffers   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdStubBuffer,
        CStdStubBuffer2,
        CStdAsyncStubBuffer,


--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pRMBVtbl) - 
                                    offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->QueryInterface( pStubBuffer,
                                                riid,
                                                ppvObject );
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_RMB_AddRef(
    IN  IReleaseMarshalBuffers   *This )
/*++

Routine Description:
    No need to go through punkOuter.

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pRMBVtbl) - 
                                    offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->AddRef( pStubBuffer );
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_RMB_Release(
    IN  IReleaseMarshalBuffers   *This )
/*++

Routine Description:

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) (((uchar *)This) -
                                    (offsetof(CStdStubBuffer, pRMBVtbl) - 
                                    offsetof(CStdStubBuffer,lpVtbl)) );

    return pStubBuffer->lpVtbl->Release( pStubBuffer );
}



HRESULT STDMETHODCALLTYPE
CStdStubBuffer_RMB_ReleaseMarshalBuffer(
    IN IReleaseMarshalBuffers *pRMB,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwIOFlags,
    IN IUnknown *pChnl)
{
    HRESULT hr;
    CStdStubBuffer * pStubBuffer = (CStdStubBuffer *) (((uchar *)pRMB) -
                                    offsetof(CStdStubBuffer, pRMBVtbl));

    hr = NdrpServerReleaseMarshalBuffer(pRMB,(RPC_MESSAGE *)pMsg,dwIOFlags,FALSE);
    
    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_RMB_ReleaseMarshalBuffer(
    IN IReleaseMarshalBuffers *pRMB,
    IN RPCOLEMESSAGE * pMsg,
    IN DWORD dwIOFlags,
    IN IUnknown *pChnl)
{
    HRESULT hr;
    CStdStubBuffer * pStubBuffer = (CStdStubBuffer *) (((uchar *)pRMB) -
                                    offsetof(CStdStubBuffer, pRMBVtbl));

    hr = NdrpServerReleaseMarshalBuffer(pRMB,(RPC_MESSAGE *)pMsg,dwIOFlags,TRUE);
    
    return hr;
}


//
//   The ISynchronize interface on an async stub object
//

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_QueryInterface(
    IN  ISynchronize   *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works for delegated and non-delegated async stubs.
    ISynchronize is public, go through punkOuter.
--*/
{
    IRpcStubBuffer  * pStubBuffer;

    pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This
                             - offsetof(CStdAsyncStubBuffer,pSynchronizeVtbl)
                             + offsetof(CStdAsyncStubBuffer,lpVtbl) );

   return pStubBuffer->lpVtbl->QueryInterface( pStubBuffer,
                                               riid,
                                               ppvObject );
}

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_AddRef(
    IN  ISynchronize   *This )
/*++

Routine Description:

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    IRpcStubBuffer  * pStubBuffer;

    pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This
                             - offsetof(CStdAsyncStubBuffer,pSynchronizeVtbl)
                             + offsetof(CStdAsyncStubBuffer,lpVtbl) );

    return pStubBuffer->lpVtbl->AddRef( pStubBuffer );
}

ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Release(
    IN  ISynchronize   *This )
/*++

Routine Description:

Arguments:

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    IRpcStubBuffer  * pStubBuffer;

    pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This
                             - offsetof(CStdAsyncStubBuffer,pSynchronizeVtbl)
                             + offsetof(CStdAsyncStubBuffer,lpVtbl) );

    return pStubBuffer->lpVtbl->Release( pStubBuffer );
}



HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Wait(
    IN  ISynchronize   *This,
    IN  DWORD           dwFlags,
    IN  DWORD           dwMilisec )
/*++

Routine Description:
    It should never be called.
Arguments:
Return Value:
Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This -
                        (offsetof(CStdAsyncStubBuffer, pSynchronizeVtbl) - offsetof(CStdAsyncStubBuffer, lpVtbl)) );

    // It should never be called.
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Signal(
    IN  ISynchronize   *This )
/*++

Routine Description:
    Query for an interface on the interface stub CallFactory pointer.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    CStdAsyncStubBuffer *   pAsyncSB;
    HRESULT                 hr;

    RpcTryExcept
        {
        pAsyncSB = (CStdAsyncStubBuffer *) ( (uchar *)This -
                      offsetof(CStdAsyncStubBuffer, pSynchronizeVtbl) );

    // It causes the Finish call to happen.
        hr = NdrpAsyncStubSignal( pAsyncSB );
        }
    RpcExcept( EXCEPTION_EXECUTE_HANDLER)
        {
        hr = NdrStubErrorHandler( RpcExceptionCode() );
        }
    RpcEndExcept
    

    return hr;
}

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Synchronize_Reset(
    IN  ISynchronize   *This )
/*++

Routine Description:
    This is called by the Server's Call Object as part of its Begin_* method.

Arguments:

Return Value: Always S_OK.

Note:
    Works for delegated and non-delegated async stubs.

--*/
{
    IRpcStubBuffer * pStubBuffer = (IRpcStubBuffer *) ( (uchar *)This -
                        (offsetof(CStdAsyncStubBuffer, pSynchronizeVtbl) - offsetof(CStdAsyncStubBuffer, lpVtbl)) );

    // Server's Call object gets S_OK...
    return S_OK;
}


//
//  Implementation of the stub buffer itself.
//

HRESULT STDMETHODCALLTYPE
CStdStubBuffer_QueryInterface(
    IN  IRpcStubBuffer *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub.  The interface
    stub supports the IUnknown and IRpcStubBuffer interfaces.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdStubBuffer,
        CStdStubBuffer2,
    This is correct for the stubs supporting async_uuid.
--*/
{
    HRESULT hr;

    if ((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcStubBuffer, sizeof(IID)) == 0))
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
        hr = S_OK;
    }
    else if ( ((CStdStubBuffer*)This)->pCallFactoryVtbl != 0  &&
              memcmp(&riid, &IID_ICallFactory, sizeof(IID)) == 0 )
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = ( (uchar *)This +
                     (offsetof(CStdStubBuffer, pCallFactoryVtbl) - offsetof(CStdStubBuffer,lpVtbl)) );
        hr = S_OK;
    }
    else if ( (((CStdStubBuffer*)This)->pRMBVtbl) && 
              (memcmp(&riid, &IID_IReleaseMarshalBuffers,sizeof(IID)) == 0))
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = ( (uchar *)This + offsetof(CStdStubBuffer,pRMBVtbl)) ;
        hr = S_OK;
    }   
    else if ( riid == IID_IPrivStubBuffer )
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
        hr = S_OK;        
    }
    else
    {
        *ppvObject = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_QueryInterface(
    IN  IRpcStubBuffer *This,
    IN  REFIID          riid,
    OUT void **         ppvObject)
/*++

Routine Description:
    Query for an interface on the interface stub.  The interface
    stub supports the IUnknown and IRpcStubBuffer interfaces.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdAsyncStubBuffer
    So this works for AsyncStubBuffer2_QueryInterface.

--*/
{
    HRESULT hr = E_NOINTERFACE;

    *ppvObject = 0;

    if ((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&riid, &IID_IRpcStubBuffer, sizeof(IID)) == 0))
        {
        *ppvObject = This;
        hr = S_OK;
        }
    else if ( memcmp(&riid, &IID_ISynchronize, sizeof(IID)) == 0 )
        {
        // For pSynchronize return  &pAsyncSB->pSynchronizeVtbl.
        *ppvObject = ( (uchar *)This +
                     (offsetof(CStdAsyncStubBuffer, pSynchronizeVtbl) - offsetof(CStdAsyncStubBuffer,lpVtbl)) );

        hr = S_OK;
    }
    else if ( (((CStdStubBuffer*)This)->pRMBVtbl) && 
              (memcmp(&riid, &IID_IReleaseMarshalBuffers,sizeof(IID)) == 0))
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = (void *)((CStdStubBuffer*)This)->pRMBVtbl;
        hr = S_OK;
    }   
    else if ( riid == IID_IPrivStubBuffer )
    {
        This->lpVtbl->AddRef(This);
        *ppvObject = This;
        hr = S_OK;        
    }


    if ( SUCCEEDED(hr) )
        ((IUnknown*)*ppvObject)->lpVtbl->AddRef( (IUnknown*)*ppvObject );

    // This is async stub, the channel would never call a query
    // for anything else.

    return hr;
}



ULONG STDMETHODCALLTYPE
CStdStubBuffer_AddRef(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Increment reference count.

Arguments:

Return Value:
    Reference count.

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdStubBuffer,
        CStdStubBuffer2,

--*/
{
        InterlockedIncrement(&((CStdStubBuffer *)This)->RefCount);
        return (ULONG) ((CStdStubBuffer *)This)->RefCount;
}


ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_AddRef(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Increment reference count.

Arguments:

Return Value:
    Reference count.

Note:
    The relative position of lpVtbl and pCallFactoryVtbl is the same for
        CStdAsyncStubBuffer,

--*/
{
// ok: ISynchronize is not really public

    InterlockedIncrement(&((CStdStubBuffer *)This)->RefCount);

    return (ULONG) ((CStdStubBuffer *)This)->RefCount;
}



//
// This is needed and used only by the synchronous stubs.
//

HRESULT STDMETHODCALLTYPE
Forwarding_QueryInterface(
    IN  IUnknown *  This,
    IN  REFIID      riid,
    OUT void **     ppv)
{
    *ppv = This;
    return S_OK;
}

ULONG STDMETHODCALLTYPE
Forwarding_AddRef(
    IN  IUnknown *This)
{
    return 1;
}

ULONG STDMETHODCALLTYPE
Forwarding_Release(
    IN  IUnknown *This)
{
   return 1;
}


ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer_Release(
    IN  IRpcStubBuffer *    This,
    IN  IPSFactoryBuffer *  pFactory)
/*++

Routine Description:
    Decrement reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG       count;

    NDR_ASSERT(((CStdStubBuffer *)This)->RefCount > 0, "Invalid reference count");

    count = (ULONG) ((CStdStubBuffer *)This)->RefCount - 1;

    if(InterlockedDecrement(&((CStdStubBuffer *)This)->RefCount) == 0)
    {
        count = 0;

#if DBG == 1
        memset(This,  '\0', sizeof(CStdStubBuffer));
#endif

        //Free the stub buffer
        NdrOleFree(This);

        //Decrement the DLL reference count.
        ((CStdPSFactoryBuffer*)pFactory)->lpVtbl->Release( pFactory );
    }

    return count;
}


ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer_Release(
    IN  IRpcStubBuffer *    This
    )
{
    CStdAsyncStubBuffer * pAsyncSB;
    ULONG                 count;

    pAsyncSB = (CStdAsyncStubBuffer*)((uchar*)This
                                      - offsetof(CStdAsyncStubBuffer,lpVtbl));

    NDR_ASSERT(pAsyncSB->RefCount > 0, "Async stub Invalid reference count");

    count = (ULONG) pAsyncSB->RefCount - 1;

    if ( InterlockedDecrement( &pAsyncSB->RefCount) == 0)
        {
        IPSFactoryBuffer *  pFactory = pAsyncSB->pPSFactory;

        count = 0;

        NdrpAsyncStubMsgDestructor( pAsyncSB );

#if DBG == 1
        memset( pAsyncSB, '\33', sizeof(CStdAsyncStubBuffer));
#endif

        //Free the stub buffer
        NdrOleFree( pAsyncSB );

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release( pFactory );
        }

    return count;
}



ULONG STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Release(
    IN  IRpcStubBuffer *    This
    )
{
    // O well, the main desctructor for the delegated async stub.

    CStdAsyncStubBuffer *   pAsyncSB;
    ULONG                   count;

    pAsyncSB = (CStdAsyncStubBuffer*)((uchar*)This
                                      - offsetof(CStdAsyncStubBuffer,lpVtbl));

    NDR_ASSERT(pAsyncSB->RefCount > 0, "Async stub Invalid reference count");

    count = (ULONG) pAsyncSB->RefCount - 1;

    if ( InterlockedDecrement(&pAsyncSB->RefCount) == 0)
        {
        IPSFactoryBuffer * pFactory      = pAsyncSB->pPSFactory;
        IRpcStubBuffer * pBaseStubBuffer = pAsyncSB->pBaseStubBuffer;

        count = 0;

        if( pBaseStubBuffer != 0)
            pBaseStubBuffer->lpVtbl->Release( pBaseStubBuffer );

        NdrpAsyncStubMsgDestructor( pAsyncSB );

#if DBG == 1
        memset( pAsyncSB, '\33', sizeof(CStdAsyncStubBuffer));
#endif

        //Free the stub buffer
        NdrOleFree( pAsyncSB );

        //Decrement the DLL reference count.
        pFactory->lpVtbl->Release( pFactory );
        }

    return count;
}



ULONG STDMETHODCALLTYPE
NdrCStdStubBuffer2_Release(
    IN  IRpcStubBuffer *    This,
    IN  IPSFactoryBuffer *  pFactory)
/*++

Routine Description:
    Decrement reference count.  This function supports delegation to the stub
    for the base interface.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG       count;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    NDR_ASSERT(pStubBuffer->RefCount > 0, "Invalid reference count");

    count = (ULONG) pStubBuffer->RefCount - 1;

    if(InterlockedDecrement(&pStubBuffer->RefCount) == 0)
    {
        count = 0;

        pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

        if(pBaseStubBuffer != 0)
            pBaseStubBuffer->lpVtbl->Release(pBaseStubBuffer);

#if DBG == 1
        memset(pStubBuffer,  '\0', sizeof(CStdStubBuffer2));
#endif

        if (pStubBuffer->lpForwardingVtbl)
        ReleaseTemplateForwardVtbl((void **)pStubBuffer->lpForwardingVtbl);
        //Free the stub buffer
        NdrOleFree(pStubBuffer);

        //Decrement the DLL reference count.
        ((CStdPSFactoryBuffer*)pFactory)->lpVtbl->Release( pFactory );
    }

    return count;
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Connect(
    IN  IRpcStubBuffer *This,
    IN  IUnknown *      pUnkServer)
/*++

Routine Description:
    Connect the stub buffer to the server object.
    This is the non-delegated case.

Arguments:

Return Value:

Notes:
    This works for CStdAsyncBuffer_Connect

--*/
{
    HRESULT hr;
    const IID *pIID;
    IUnknown *punk = 0;

    NDR_ASSERT(pUnkServer != 0, "pUnkServer parameter is invalid.");

    pIID = NdrpGetStubIID(This);
    hr = pUnkServer->lpVtbl->QueryInterface(pUnkServer, *pIID, (void**)&punk);

    punk = (IUnknown *) InterlockedExchangePointer(
        (PVOID *) &((CStdStubBuffer *) This)->pvServerObject, (PVOID) punk);

    if(punk != 0)
    {
        //The stub was already connected.  Release the old interface pointer.
        punk->lpVtbl->Release(punk);
    }

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Connect(
    IN  IRpcStubBuffer *This,
    IN  IUnknown *      punkServer)
/*++

Routine Description:
    Connect the stub buffer to the server object.
    This is the non-delegated case.

Arguments:
    punkServer - this is a pointer to AsyncIFoo already queried by the channel.
                 (when delegation same thing)

Return Value:

Notes:
    This works the same as for StubBuffer_Connect.

    Note that an async stub is always created disconnected.
    It also always keep a pointer to the real server not
    to a forwarder object.
--*/
{
    IUnknown *punk = 0;

    NDR_ASSERT(punkServer != 0, "pUnkServer parameter is invalid.");

    punkServer->lpVtbl->AddRef( punkServer );

    punk = (IUnknown *) InterlockedExchangePointer(
        (PVOID *) &((CStdStubBuffer *) This)->pvServerObject, (PVOID) punkServer);

    if( punk != 0 )
        {
        // The stub was already connected.  Release the old interface pointer.
        punk->lpVtbl->Release(punk);
        }

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer2_Connect(
    IN  IRpcStubBuffer *This,
    IN  IUnknown *      pUnkServer)
/*++

Routine Description:
    Connect the stub buffer to the server object.
    This is the delegated case.

Arguments:

Return Value:

--*/
{
    HRESULT             hr;
    unsigned char *     pTemp;
    CStdStubBuffer2 *   pStubBuffer;
    IRpcStubBuffer *    pBaseStubBuffer;

    hr = CStdStubBuffer_Connect(This, pUnkServer);

    if(SUCCEEDED(hr))
    {
        //Connect the stub for the base interface.
        pTemp = (unsigned char *)This;
        pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
        pStubBuffer = (CStdStubBuffer2 *) pTemp;

        pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

        if(pBaseStubBuffer != 0)
        {
            hr = pBaseStubBuffer->lpVtbl->Connect(pBaseStubBuffer,
                                                  (IUnknown *) &pStubBuffer->lpForwardingVtbl);
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Connect(
    IN  IRpcStubBuffer *This,
    IN  IUnknown *      pUnkServer)
/*++

Routine Description:
    Connect the stub buffer to the server object.
    This is the delegated case.

Arguments:

Return Value:

Notes:
    This is different from CStdAsyncBuffer2_Connect
    as the base is connected to the real server here.

    Note that an async stub is always created disconnected.
    It also always keep a pointer to the real server not
    to a forwarder object.

--*/
{
    HRESULT             hr;
    unsigned char *     pTemp;
    CStdStubBuffer2 *   pStubBuffer;
    IRpcStubBuffer *    pBaseStubBuffer;

    hr = CStdAsyncStubBuffer_Connect(This, pUnkServer);

    if(SUCCEEDED(hr))
    {
        //Connect the stub for the base interface.
        pTemp = (unsigned char *)This;
        pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
        pStubBuffer = (CStdStubBuffer2 *) pTemp;

        pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

        if(pBaseStubBuffer != 0)
        {
            hr = pBaseStubBuffer->lpVtbl->Connect(
                                     pBaseStubBuffer,
                                     pUnkServer );
        }
    }
    return hr;
}


void STDMETHODCALLTYPE
CStdStubBuffer_Disconnect(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Disconnect the stub from the server object.

Arguments:

Return Value:
    None.

Notes:
    This works for CStdAsyncBuffer_Disconnect

--*/
{
    IUnknown *          punk;

    //Set pvServerObject to zero.
    punk = (IUnknown *) InterlockedExchangePointer(
                        (PVOID*) &((CStdStubBuffer *)This)->pvServerObject, 0);

    if(punk != 0)
    {
        //
        // Free the old interface pointer.
        //
        punk->lpVtbl->Release(punk);
    }
}

void STDMETHODCALLTYPE
CStdAsyncStubBuffer_Disconnect(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Disconnect the stub from the server object.

Arguments:

Return Value:
    None.
--*/
{
    // Same as Buffer_Disconnect

    IUnknown *          punk;

    //Set pvServerObject to zero.
    punk = (IUnknown *) InterlockedExchangePointer(
                        (PVOID*) &((CStdStubBuffer *)This)->pvServerObject, 0);

    // Free the old interface pointer.
    if(punk != 0)
        punk->lpVtbl->Release(punk);
}

void STDMETHODCALLTYPE
CStdStubBuffer2_Disconnect(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Disconnect the stub buffer from the server object.

Arguments:

Return Value:
    None.

--*/
{
    IUnknown *          punk;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    //Disconnect the stub for the base interface.
    pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

    if(pBaseStubBuffer != 0)
        pBaseStubBuffer->lpVtbl->Disconnect(pBaseStubBuffer);

    //Set pvServerObject to zero.
    punk = (IUnknown *) InterlockedExchangePointer(
                        (PVOID*) &pStubBuffer->pvServerObject, 0);

    if(punk != 0)
    {
        //
        // Free the old interface pointer.
        //
        punk->lpVtbl->Release(punk);
    }
}

void STDMETHODCALLTYPE
CStdAsyncStubBuffer2_Disconnect(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Disconnect the stub buffer from the server object.

Arguments:

Return Value:
    None.

--*/
{
    IUnknown *          punk;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    //Disconnect the stub for the base interface.
    pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

    if(pBaseStubBuffer != 0)
        pBaseStubBuffer->lpVtbl->Disconnect(pBaseStubBuffer);

    //Set pvServerObject to zero.
    punk = (IUnknown *) InterlockedExchangePointer(
                (PVOID*) &pStubBuffer->pvServerObject, 0);

    // Free the old interface pointer.
    if(punk != 0)
        punk->lpVtbl->Release(punk);
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_Invoke(
    IN  IRpcStubBuffer *    This,
    IN  RPCOLEMESSAGE *     prpcmsg,
    IN  IRpcChannelBuffer * pRpcChannelBuffer)
/*++

Routine Description:
    Invoke a stub function via the dispatch table.

Arguments:

Return Value:

--*/
{
    HRESULT             hr = S_OK;
    unsigned char **    ppTemp;
    unsigned char *     pTemp;
    CInterfaceStubVtbl *pStubVtbl;
    unsigned long       dwServerPhase = STUB_UNMARSHAL;

    //Get a pointer to the stub vtbl.
    ppTemp = (unsigned char **) This;
    pTemp = *ppTemp;
    pTemp -= sizeof(CInterfaceStubHeader);
    pStubVtbl = (CInterfaceStubVtbl *) pTemp;

    RpcTryExcept

        //
        //Check if procnum is valid.
        //
        if((prpcmsg->iMethod >= pStubVtbl->header.DispatchTableCount) ||
           (prpcmsg->iMethod < 3))
        {
            RpcRaiseException(RPC_S_PROCNUM_OUT_OF_RANGE);
        }

        // null indicates pure-interpreted
        if ( pStubVtbl->header.pDispatchTable != 0)
        {
            (*pStubVtbl->header.pDispatchTable[prpcmsg->iMethod])(
                This,
                pRpcChannelBuffer,
                (PRPC_MESSAGE) prpcmsg,
                &dwServerPhase);
        }
        else
        {
            PMIDL_SERVER_INFO   pServerInfo;
            PMIDL_STUB_DESC     pStubDesc;

            pServerInfo = (PMIDL_SERVER_INFO) pStubVtbl->header.pServerInfo;
            pStubDesc = pServerInfo->pStubDesc;

#ifdef BUILD_NDR64
            if ( pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )
            {

                NdrStubCall3(This,
                             pRpcChannelBuffer,
                             (PRPC_MESSAGE) prpcmsg,
                             &dwServerPhase);
            }
            else
#endif
            if ( MIDL_VERSION_3_0_39 <= pServerInfo->pStubDesc->MIDLVersion )
                {
                // Since MIDL 3.0.39 we have a proc flag that indicates
                // which interpeter to call. This is because the NDR version
                // may be bigger than 1.1 for other reasons.

                PFORMAT_STRING pProcFormat;
                unsigned short ProcOffset;

                ProcOffset = pServerInfo->FmtStringOffset[ prpcmsg->iMethod ];
                pProcFormat = & pServerInfo->ProcString[ ProcOffset ];

                if ( pProcFormat[1]  &  Oi_OBJ_USE_V2_INTERPRETER )
                    {
                    NdrStubCall2(
                        This,
                        pRpcChannelBuffer,
                        (PRPC_MESSAGE) prpcmsg,
                        &dwServerPhase );
                    }
                else
                    {
#if defined(__RPC_WIN64__)
                    RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
#else
                    NdrStubCall(
                        This,
                        pRpcChannelBuffer,
                        (PRPC_MESSAGE) prpcmsg,
                        &dwServerPhase );
#endif
                    }
                }
            else
                {
                // Prior to that, the NDR version (on per file basis)
                // was the only indication of -Oi2.

                if ( pStubDesc->Version <= NDR_VERSION_1_1 )
                    {
#if defined(__RPC_WIN64__)
                    RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
#else
                    NdrStubCall(
                        This,
                        pRpcChannelBuffer,
                        (PRPC_MESSAGE) prpcmsg,
                        &dwServerPhase );
#endif
                    }
                else
                    {
                    NdrStubCall2(
                        This,
                        pRpcChannelBuffer,
                        (PRPC_MESSAGE) prpcmsg,
                        &dwServerPhase );
                    }
                }
        }
    RpcExcept(dwServerPhase == STUB_CALL_SERVER ?
        EXCEPTION_CONTINUE_SEARCH :
        EXCEPTION_EXECUTE_HANDLER)
        hr = NdrStubErrorHandler( RpcExceptionCode() );
    RpcEndExcept

    return hr;
}


HRESULT STDMETHODCALLTYPE
CStdAsyncStubBuffer_Invoke(
    IN  IRpcStubBuffer *    This,
    IN  RPCOLEMESSAGE *     prpcmsg,
    IN  IRpcChannelBuffer * pRpcChannelBuffer)
/*++

Routine Description:
    Invoke a stub function via the dispatch table.

Arguments:

Return Value:

--*/
{
    HRESULT             hr = S_OK;
    unsigned char **    ppTemp;
    unsigned char *     pTemp;
    CInterfaceStubVtbl *pStubVtbl;
    unsigned long       dwServerPhase = STUB_UNMARSHAL;

    //Get a pointer to the stub vtbl.
    ppTemp = (unsigned char **) This;
    pTemp = *ppTemp;
    pTemp -= sizeof(CInterfaceStubHeader);
    pStubVtbl = (CInterfaceStubVtbl *) pTemp;

    RpcTryExcept
        {
        PMIDL_SERVER_INFO  pServerInfo;

        // Check if procnum is valid.
        // Note, this is a sync proc number.
        //
        if((prpcmsg->iMethod >= pStubVtbl->header.DispatchTableCount) ||
           (prpcmsg->iMethod < 3))
            {
            RpcRaiseException(RPC_S_PROCNUM_OUT_OF_RANGE);
            }

        // Async DCOM is supported only in the new interpreter,
        // and only since MIDL 5.0.+

        pServerInfo = (PMIDL_SERVER_INFO) pStubVtbl->header.pServerInfo;

        if ( pServerInfo->pStubDesc->MIDLVersion < MIDL_VERSION_5_0_136 )
            RpcRaiseException( RPC_S_INTERNAL_ERROR );

        // Non null would indicate an -Os stub or a delegation case.
        if ( pStubVtbl->header.pDispatchTable != 0)
            {
            (*pStubVtbl->header.pDispatchTable[prpcmsg->iMethod])(
                This,
                pRpcChannelBuffer,
                (PRPC_MESSAGE) prpcmsg,
                &dwServerPhase);
            }
        else
            {
#if defined(BUILD_NDR64)
            if ( pServerInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES )
                {
                switch ( NdrpGetSyntaxType( ( (PRPC_MESSAGE) prpcmsg )->TransferSyntax ) )
                    {
                    case XFER_SYNTAX_DCE:
                        NdrDcomAsyncStubCall( This,
                                  pRpcChannelBuffer,
                                  (PRPC_MESSAGE) prpcmsg,
                                  &dwServerPhase );
                        break;

                    case XFER_SYNTAX_NDR64:
                        Ndr64DcomAsyncStubCall( This,
                                        pRpcChannelBuffer,
                                       (PRPC_MESSAGE) prpcmsg,
                                       &dwServerPhase );
                        break;
                    }
                }
            else
#endif
                NdrDcomAsyncStubCall( This,
                                  pRpcChannelBuffer,
                                  (PRPC_MESSAGE) prpcmsg,
                                  &dwServerPhase );
            }
        }
    RpcExcept(dwServerPhase == STUB_CALL_SERVER ?
        EXCEPTION_CONTINUE_SEARCH :
        EXCEPTION_EXECUTE_HANDLER)
        hr = NdrStubErrorHandler( RpcExceptionCode() );
    RpcEndExcept

    return hr;
}


IRpcStubBuffer * STDMETHODCALLTYPE
CStdStubBuffer_IsIIDSupported(
    IN  IRpcStubBuffer *This,
    IN  REFIID          riid)
/*++

Routine Description:
    If the stub buffer supports the specified interface,
    then return an IRpcStubBuffer *.  If the interface is not
    supported, then return zero.

Arguments:

Return Value:

Notes:
    This works for CStdAsyncStubBuffer,CStdAsyncStubBuffer2.

--*/
{
    CStdStubBuffer   *  pCThis  = (CStdStubBuffer *) This;
    const IID *         pIID;
    IRpcStubBuffer *    pInterfaceStub = 0;

    pIID = NdrpGetStubIID(This);

    if(memcmp(&riid, pIID, sizeof(IID)) == 0)
    {
        if(pCThis->pvServerObject != 0)
        {
            pInterfaceStub = This;
            pInterfaceStub->lpVtbl->AddRef(pInterfaceStub);
        }
    }

    return pInterfaceStub;
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer_CountRefs(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Count the number of references to the server object.

Arguments:

Return Value:

Notes:
    This works for CStdAsyncStubBuffer.

--*/
{
    ULONG   count = 0;

    if(((CStdStubBuffer *)This)->pvServerObject != 0)
        count++;

    return count;
}

ULONG STDMETHODCALLTYPE
CStdStubBuffer2_CountRefs(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    Count the number of references to the server object.

Arguments:

Return Value:

Notes:
    This works for CStdAsyncStubBuffer2.

--*/
{
    ULONG           count;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    count = CStdStubBuffer_CountRefs(This);

    pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

    if(pBaseStubBuffer != 0)
        count += pBaseStubBuffer->lpVtbl->CountRefs(pBaseStubBuffer);

    return count;
}


HRESULT STDMETHODCALLTYPE
CStdStubBuffer_DebugServerQueryInterface(
    IN  IRpcStubBuffer *This,
    OUT void **ppv)
/*++

Routine Description:
    Return the interface pointer to the server object.

Arguments:

Return Value:

--*/
{
    HRESULT hr;

    *ppv = ((CStdStubBuffer *)This)->pvServerObject;

    if(*ppv != 0)
        hr = S_OK;
    else
        hr = CO_E_OBJNOTCONNECTED;

    return hr;
}

void STDMETHODCALLTYPE
CStdStubBuffer_DebugServerRelease(
    IN  IRpcStubBuffer *This,
    IN  void *pv)
/*++

Routine Description:
    Release a pointer previously obtained via
    DebugServerQueryInterface.  This function does nothing.

Arguments:
    This
    pv

Return Value:
    None.

--*/
{
}


const IID * RPC_ENTRY
NdrpGetStubIID(
    IN  IRpcStubBuffer *This)
/*++

Routine Description:
    This function returns a pointer to the IID for the interface stub.

Arguments:

Return Value:

--*/
{
    unsigned char **    ppTemp;
    unsigned char *     pTemp;
    CInterfaceStubVtbl *pStubVtbl;

    //Get a pointer to the stub vtbl.
    ppTemp = (unsigned char **) This;
    pTemp = *ppTemp;
    pTemp -= sizeof(CInterfaceStubHeader);
    pStubVtbl = (CInterfaceStubVtbl *) pTemp;

    return pStubVtbl->header.piid;
}


void RPC_ENTRY
NdrStubInitialize(
    IN  PRPC_MESSAGE         pRpcMsg,
    IN  PMIDL_STUB_MESSAGE   pStubMsg,
    IN  PMIDL_STUB_DESC      pStubDescriptor,
    IN  IRpcChannelBuffer *  pRpcChannelBuffer )
/*++

Routine Description:
    This routine is called by the server stub before unmarshalling.
    It sets up some stub message fields.

Arguments:
    pRpcMsg
    pStubMsg
    pStubDescriptor
    pRpcChannelBuffer

Return Value:
    None.

--*/
{
    NdrServerInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor);

    pStubMsg->pRpcChannelBuffer = pRpcChannelBuffer;

    // This exception should be raised after initializing StubMsg.

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ServerInitializePartial : bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    pRpcChannelBuffer->lpVtbl->GetDestCtx( pRpcChannelBuffer,
                                           &pStubMsg->dwDestContext,
                                           &pStubMsg->pvDestContext);
}

void RPC_ENTRY
NdrStubInitializePartial(
    IN  PRPC_MESSAGE         pRpcMsg,
    IN  PMIDL_STUB_MESSAGE   pStubMsg,
    IN  PMIDL_STUB_DESC      pStubDescriptor,
    IN  IRpcChannelBuffer *  pRpcChannelBuffer,
    IN  unsigned long        RequestedBufferSize )
/*++

Routine Description:
    This routine is called by the server stub before unmarshalling.
    It sets up some stub message fields.

Arguments:
    pRpcMsg
    pStubMsg
    pStubDescriptor
    pRpcChannelBuffer

Return Value:
    None.

--*/
{
    NdrServerInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDescriptor);

    pStubMsg->pRpcChannelBuffer = pRpcChannelBuffer;

    pRpcChannelBuffer->lpVtbl->GetDestCtx( pRpcChannelBuffer,
                                           &pStubMsg->dwDestContext,
                                           &pStubMsg->pvDestContext);

    MakeSureWeHaveNonPipeArgs( pStubMsg, RequestedBufferSize );
}

void RPC_ENTRY
NdrStubGetBuffer(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PMIDL_STUB_MESSAGE  pStubMsg)
/*++

Routine Description:
    Get a message buffer from the channel

Arguments:
    This
    pChannel
    pStubMsg

Return Value:
    None.  If an error occurs, this functions raises an exception.

--*/
{
    HRESULT     hr;
    const IID * pIID;

    pIID = NdrpGetStubIID(This);
    pStubMsg->RpcMsg->BufferLength = pStubMsg->BufferLength;
    pStubMsg->RpcMsg->DataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;
    hr = pChannel->lpVtbl->GetBuffer(pChannel, (RPCOLEMESSAGE *) pStubMsg->RpcMsg, *pIID);

    if(FAILED(hr))
    {
        RpcRaiseException(hr);
    }

    pStubMsg->Buffer = (unsigned char *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;
}


HRESULT RPC_ENTRY
NdrStubErrorHandler(
    IN  DWORD dwExceptionCode)
/*++

Routine Description:
    Map exceptions into HRESULT failure codes.  If we caught an
    exception from the server object, then propagate the
    exception to the channel.

Arguments:
    dwExceptionCode

Return Value:
    This function returns an HRESULT failure code.

--*/
{
    HRESULT hr;

    if(FAILED((HRESULT) dwExceptionCode))
        hr = (HRESULT) dwExceptionCode;
    else
        hr = HRESULT_FROM_WIN32(dwExceptionCode);

    return hr;
}

EXTERN_C void RPC_ENTRY
NdrStubInitializeMarshall (
    IN  PRPC_MESSAGE        pRpcMsg,
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  IRpcChannelBuffer * pRpcChannelBuffer )
/*++

Routine Description:
    This routine is called by the server stub before marshalling.  It
    sets up some stub message fields.

Arguments:
    pRpcMsg
    pStubMsg
    pRpcChannelBuffer

Return Value:
    None.

--*/
{
    pStubMsg->BufferLength = 0;

    pStubMsg->IgnoreEmbeddedPointers = FALSE;

    pStubMsg->fDontCallFreeInst = 0;

    pStubMsg->StackTop = 0;

    pRpcChannelBuffer->lpVtbl->GetDestCtx(
        pRpcChannelBuffer,
        &pStubMsg->dwDestContext,
        &pStubMsg->pvDestContext);
}


void __RPC_STUB NdrStubForwardingFunction(
    IN  IRpcStubBuffer *    This,
    IN  IRpcChannelBuffer * pChannel,
    IN  PRPC_MESSAGE        pmsg,
    OUT DWORD           *   pdwStubPhase)
/*++

Routine Description:
    This function forwards a call to the stub for the base interface.

Arguments:
    pChannel
    pmsg
    pdwStubPhase

Return Value:
    None.

--*/
{
    HRESULT hr;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;
    pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

    hr = pBaseStubBuffer->lpVtbl->Invoke(pBaseStubBuffer,
                                         (RPCOLEMESSAGE *) pmsg,
                                         pChannel);
    if(FAILED(hr))
        RpcRaiseException(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\typeinfo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       typeinfo.h
//
//  Contents:   Generates -Oi2 proxies and stubs from an ITypeInfo.
//
//  Classes:    CTypeGen
//              CProcGen
//
//  History:    26-Apr-96 ShannonC  Created
//
//----------------------------------------------------------------------------
#ifndef _TYPEINFO_H_
#define _TYPEINFO_H_

#define USE_STUBLESS_PROXY
#define CINTERFACE
#include <ndrp.h>
#include <ndrole.h>
#include <rpcproxy.h>
#include <typegen.h>


struct TypeInfoVtbl
{
    LONG                     cRefs;
    IID                      iid;
    BOOL                     fIsDual;
    MIDL_STUB_DESC           stubDesc;
    MIDL_SERVER_INFO         stubInfo;
    CInterfaceStubVtbl       stubVtbl;
    MIDL_STUBLESS_PROXY_INFO proxyInfo;
    CInterfaceProxyVtbl      proxyVtbl;
}; 

struct TypeInfoCache
{
    IID iid;
    TypeInfoVtbl *pVtbl;
    DWORD dwTickCount;
};

typedef struct tagMethodInfo 
{
    FUNCDESC  * pFuncDesc;
    ITypeInfo * pTypeInfo;
} MethodInfo;


class CProcGen{
private:
    PFORMAT_STRING _pProcFormatString;
    USHORT         _offset;
    USHORT         _stackSize;
    ULONG          _clientBufferSize;
    ULONG          _serverBufferSize;
    BOOL           _fClientMustSize;
    BOOL           _fServerMustSize;
    BOOL           _fClientCorrCheck;
    BOOL           _fServerCorrCheck;
    USHORT         _usFloatArgMask;
    USHORT         _usFloatSlots;
    CTypeGen     * _pTypeGen;

    HRESULT CalcSize(
        IN  VARTYPE    vt,
        IN  DWORD      wIDLFlags,
        IN  ULONG      nParam);

    HRESULT GenParamDescriptor(
    	IN  PARAMINFO *pInfo,
    	OUT BOOLEAN *fChangeSize);

    HRESULT PushByte(
        IN  byte b);

    HRESULT PushShort(
        IN  USHORT s);

    HRESULT PushLong(
        IN  ULONG s);

    HRESULT SetShort(
        IN  USHORT offset,
        IN  USHORT data);

#if defined(__RPC_WIN64__)
    void AnalyzeFloatTypes(
        IN  USHORT ParamOffset,
        IN  USHORT offset);

    bool IsHomogeneous(
        IN  PFORMAT_STRING pFormat, 
        IN  FORMAT_CHARACTER fc);

    bool IsHomogeneousMemberLayout(
        IN  PFORMAT_STRING pFormat, 
        IN  FORMAT_CHARACTER fc);
#endif

public:
    HRESULT GetProcFormat(
        IN  CTypeGen     * pTypeGen,
        IN  ITypeInfo    * pTypeInfo,
        IN  FUNCDESC     * pFuncDesc,
        IN  USHORT         iMethod,
        OUT PFORMAT_STRING pProcFormatString,
        OUT USHORT       * pcbFormat);
};

HRESULT GetProxyVtblFromTypeInfo
(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT BOOL *              pfIsDual,
    OUT void **             ppVtbl
);

HRESULT GetStubVtblFromTypeInfo
(
    IN  ITypeInfo *           pTypeInfo,
    IN  REFIID                riid,
    OUT BOOL *                pfIsDual,
    OUT IRpcStubBufferVtbl ** ppVtbl
);

HRESULT GetVtbl(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT TypeInfoVtbl **     ppVtbl);

HRESULT CreateVtblFromTypeInfo(
    IN  REFIID              riid,
    IN  BOOL                fIsDual,
    IN  USHORT              numMethods,
    IN  MethodInfo   *      pMethodInfo,
    OUT TypeInfoVtbl **     ppVtbl);

HRESULT GetFuncDescs(
    IN  ITypeInfo *pTypeInfo,
    OUT MethodInfo *pMethodInfo);

HRESULT ReleaseFuncDescs(
    IN  USHORT cMethods,
    OUT MethodInfo *pMethodInfo);

HRESULT ReleaseProxyVtbl(void * pVtbl);

HRESULT ReleaseStubVtbl(void * pVtbl);

HRESULT ReleaseVtbl(TypeInfoVtbl *pInfo);

HRESULT CountMethods(
    IN  ITypeInfo * pTypeInfo,
    OUT USHORT    * pNumMethods);


EXTERN_C HRESULT NdrpCreateProxy(
    IN  REFIID              riid, 
    IN  IUnknown *          punkOuter, 
    OUT IRpcProxyBuffer **  ppProxy, 
    OUT void **             ppv);


ULONG STDMETHODCALLTYPE
CStdProxyBuffer3_Release(
    IN  IRpcProxyBuffer *   This);

ULONG STDMETHODCALLTYPE
CStdStubBuffer3_Release(
    IN  IRpcStubBuffer *    This);

//Cache functions.
HRESULT CacheRegister(IID riid,TypeInfoVtbl ** pVtbl);
HRESULT CacheLookup(REFIID riid, TypeInfoVtbl **pVtbl);
void ReleaseList(TypeInfoVtbl *pFirst);

EXTERN_C HRESULT NdrpCreateStub(
    IN  REFIID              riid, 
    IN  IUnknown *          punkServer, 
    OUT IRpcStubBuffer **   ppStub);

HRESULT	NdrLoadOleAutomationRoutines();

extern const IRpcStubBufferVtbl CStdStubBuffer2Vtbl;
extern USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[3];

extern USER_MARSHAL_SIZING_ROUTINE        pfnLPSAFEARRAY_UserSize;
extern USER_MARSHAL_MARSHALLING_ROUTINE   pfnLPSAFEARRAY_UserMarshal;
extern USER_MARSHAL_UNMARSHALLING_ROUTINE pfnLPSAFEARRAY_UserUnmarshal;

typedef unsigned long
(__RPC_USER * PFNSAFEARRAY_SIZE)
    (ULONG * pFlags, 
     ULONG Offset, 
     LPSAFEARRAY * ppSafeArray,
     const IID *piid);

typedef unsigned char *
(__RPC_USER * PFNSAFEARRAY_MARSHAL)
    (ULONG * pFlags, 
     BYTE * pBuffer, 
     LPSAFEARRAY * ppSafeArray,
     const IID *piid);

typedef unsigned char *
(__RPC_USER * PFNSAFEARRAY_UNMARSHAL)
    (ULONG * pFlags, 
     BYTE * pBuffer, 
     LPSAFEARRAY * ppSafeArray,
     const IID *piid);

extern PFNSAFEARRAY_SIZE      pfnLPSAFEARRAY_Size;
extern PFNSAFEARRAY_MARSHAL   pfnLPSAFEARRAY_Marshal;
extern PFNSAFEARRAY_UNMARSHAL pfnLPSAFEARRAY_Unmarshal;

#define VTABLE_BASE 0

#endif // _TYPEINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\typeinfo.cxx ===
//************************************************************************
//
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:       typeinfo.cxx
//
//  Contents:   Generates -Oi2 proxies and stubs from an ITypeInfo.
//
//  Functions:  CacheRegister
//              CacheRelease
//              CacheLookup
//
//  History:    26-Apr-96 ShannonC  Created
//              June 1997 YongQu    Add UDT support
//              Oct  1998 YongQu    arbitrary length vtbl
//
//----------------------------------------------------------------------------
#include <typeinfo.h>
#include <interp.h>
#include <stddef.h>
#include <ndrtypes.h>
#include <tiutil.h>
#ifdef DOSWIN32RPC
#include <critsec.hxx>
#endif
#include <sysinc.h>
#include <limits.h>
#include "fmtstr.h"

#define GetWireSize(x) (x->WireSize)
#define GetMemorySize(x) (x->MemorySize)
#define GetMemoryAlignment(x) (x->MemoryAlignment)
#define GetWireAlignment(x) (x->WireAlignment)

extern const IRpcProxyBufferVtbl CStdProxyBuffer3Vtbl = {
    CStdProxyBuffer_QueryInterface,
    CStdProxyBuffer_AddRef,
    CStdProxyBuffer3_Release,
    CStdProxyBuffer2_Connect,
    CStdProxyBuffer2_Disconnect };


HRESULT NdrpInitializeStublessVtbl(ULONG numMethods);
void GetTemplateVtbl(void *** pVtbl);
void ReleaseTemplateVtbl(void ** pVtbl);
void GetTemplateForwardVtbl(void *** pVtbl);
void ReleaseTemplateForwardVtbl(void ** pVtbl);
extern const IReleaseMarshalBuffersVtbl CStdProxyBuffer_ReleaseMarshalBuffersVtbl;
extern const IReleaseMarshalBuffersVtbl CStdStubBuffer_ReleaseMarshalBuffersVtbl;


static I_RPC_MUTEX TypeInfoMutex = 0;

//#define CACHE_BLOCK  32
//#define INIT_HIGH_MARK  20
//#define THRASHING_TIME  1000*30    // 30 sec

//The constants can be tunable instead of constants.
static LONG CACHE_BLOCK=32;
static ULONG INIT_HIGH_MARK = 20;
static ULONG IDLE_TIME= 1000 * 60 *5;   // 5 minutes.

#define THRASHING_TIME  1000*30
#define DELTA_MARK 4       // shrink 25% each time.



HINSTANCE       hOleAut32 = 0;
// local to this file only
static TypeInfoCache*  g_pCache = NULL;//array of cache entries.
static LONG            g_lActiveCacheRef = 0;
static LONG            g_lCacheSize = 0;
static LONG            g_lTotalCacheRef = 0;
#ifdef DEBUGRPC
static LONG            g_lCount = 0;
#endif

#if defined(_IA64_)

#define ARGS_IN_REGISTERS 8

#elif defined(_AMD64_)

#define ARGS_IN_REGISTERS 4

#endif

//+---------------------------------------------------------------------------
//
//  Function:   CreateProxyFromTypeInfo
//
//  Synopsis:   Creates an interface proxy using the type information supplied
//              in pTypeInfo.
//
//  Arguments:
//    pTypeInfo   - Supplies the ITypeInfo * describing the interface.
//    punkOuter   - Specifies the controlling unknown.
//    riid        - Specifies the interface ID.
//    ppProxy     - Returns a pointer to the IRpcProxyBuffer interface.
//    ppv         - Returns a pointer to the specified interface.
//
//  Returns:
//    S_OK
//    E_NOINTERFACE
//    E_OUTOFMEMORY
//
//----------------------------------------------------------------------------
HRESULT STDAPICALLTYPE
CreateProxyFromTypeInfo
(
    IN  ITypeInfo *         pTypeInfo,
    IN  IUnknown *          punkOuter,
    IN  REFIID              riid,
    OUT IRpcProxyBuffer **  ppProxy,
    OUT void **             ppv
)
{
    HRESULT hr = E_FAIL;
    BOOL    fIsDual;
    void  * pVtbl;

    *ppProxy = NULL;
    *ppv = NULL;

    //Get the proxy vtable.
    hr = GetProxyVtblFromTypeInfo(pTypeInfo, riid, &fIsDual, &pVtbl);

    if(SUCCEEDED(hr))
    {
        //Create the proxy.
        CStdProxyBuffer2 *pProxyBuffer;

        pProxyBuffer = new CStdProxyBuffer2;
        if(pProxyBuffer != NULL)
        {
            memset(pProxyBuffer, 0, sizeof(CStdProxyBuffer2));
            pProxyBuffer->lpVtbl = &CStdProxyBuffer3Vtbl;
            pProxyBuffer->RefCount = 1;
            pProxyBuffer->punkOuter = punkOuter ?
                                      punkOuter : (IUnknown *) pProxyBuffer;
            pProxyBuffer->pProxyVtbl = pVtbl;
            pProxyBuffer->pRMBVtbl = &CStdProxyBuffer_ReleaseMarshalBuffersVtbl;

            if(fIsDual)
            {
                pProxyBuffer->iidBase = IID_IDispatch;

                //Create the proxy for the base interface.
                hr = NdrpCreateProxy(IID_IDispatch,
                                     (IUnknown *) pProxyBuffer,
                                     &pProxyBuffer->pBaseProxyBuffer,
                                     (void **)&pProxyBuffer->pBaseProxy);
            }
            else
            {
                hr = S_OK;
            }

            if(SUCCEEDED(hr))
            {
                *ppProxy = (IRpcProxyBuffer *) pProxyBuffer;
                pProxyBuffer->punkOuter->lpVtbl->AddRef(pProxyBuffer->punkOuter);
                *ppv = &pProxyBuffer->pProxyVtbl;
            }
            else
            {
                delete pProxyBuffer;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(FAILED(hr))
        {
            ReleaseProxyVtbl(pVtbl);
        }

    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetProxyVtblFromTypeInfo
//
//  Synopsis: Get a pointer to the proxy vtbl. The proxy vtbl should be
//            released via ReleaseProxyVtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT GetProxyVtblFromTypeInfo

(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT BOOL *              pfIsDual,
    OUT void **             ppVtbl
)
{
    HRESULT hr = E_FAIL;
    TypeInfoVtbl *pInfo;

    //Get the vtbl.
    hr = GetVtbl(pTypeInfo, riid, &pInfo);
    if(SUCCEEDED(hr))
    {
        *pfIsDual = pInfo->fIsDual;
        *ppVtbl = &pInfo->proxyVtbl.Vtbl;
    }
    else
    {
        *ppVtbl = NULL;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateStubFromTypeInfo
//
//  Synopsis:   Create an interface stub from the type information
//              supplied in pTypeInfo.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT STDAPICALLTYPE
CreateStubFromTypeInfo
(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    IN  IUnknown *          punkServer,
    OUT IRpcStubBuffer **   ppStub
)
{
    HRESULT hr = E_FAIL;
    BOOL    fIsDual;
    IRpcStubBufferVtbl *pVtbl;
    void ** pForwardingVtbl;


    *ppStub = NULL;

    //Get the stub vtable.
    hr = GetStubVtblFromTypeInfo(pTypeInfo, riid, &fIsDual, &pVtbl);

    if(SUCCEEDED(hr))
    {
        //Create the stub
        IUnknown *              punkForward;

        CStdStubBuffer2 *pStubBuffer = new CStdStubBuffer2;

        if(pStubBuffer != NULL)
        {
            GetTemplateForwardVtbl(&pForwardingVtbl);

            //Initialize the new stub buffer.
            pStubBuffer->lpForwardingVtbl = pForwardingVtbl;
            pStubBuffer->pBaseStubBuffer = 0;
            pStubBuffer->lpVtbl = pVtbl;
            pStubBuffer->RefCount= 1;
            pStubBuffer->pvServerObject = 0;
            pStubBuffer->pRMBVtbl = &CStdStubBuffer_ReleaseMarshalBuffersVtbl;

            *ppStub = (IRpcStubBuffer *) &pStubBuffer->lpVtbl;

             //Connect the stub to the server object.
            if(punkServer != 0)
            {
                hr = punkServer->lpVtbl->QueryInterface(
                        punkServer,
                        riid,
                        (void **) &pStubBuffer->pvServerObject);
            }
            else
            {
                hr = S_OK;
            }

            if(SUCCEEDED(hr))
            {
                if(punkServer != 0)
                    punkForward = (IUnknown *) &pStubBuffer->lpForwardingVtbl;
                else
                    punkForward = 0;

                if(fIsDual)
                {
                    //Create a stub for the base interface
                    hr = NdrpCreateStub(IID_IDispatch,
                                        punkForward,
                                        &pStubBuffer->pBaseStubBuffer);
                }

                if(FAILED(hr))
                {
                    if(pStubBuffer->pvServerObject)
                        pStubBuffer->pvServerObject->lpVtbl->Release(pStubBuffer->pvServerObject);
                    NdrOleFree(pStubBuffer);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if(FAILED(hr))
        {
            ReleaseTemplateForwardVtbl(pForwardingVtbl);
            ReleaseStubVtbl(pVtbl);
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetStubVtblFromTypeInfo
//
//  Synopsis: Get a pointer to the stub vtbl. The stub vtbl should be
//            released via ReleaseStubVtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT GetStubVtblFromTypeInfo(
    IN  ITypeInfo *           pTypeInfo,
    IN  REFIID                riid,
    OUT BOOL  *               pfIsDual,
    OUT IRpcStubBufferVtbl ** ppVtbl)
{
    HRESULT hr = E_FAIL;
    TypeInfoVtbl *pInfo;

    //Get the vtbl.
    hr = GetVtbl(pTypeInfo, riid, &pInfo);
    if(SUCCEEDED(hr))
    {
        *pfIsDual = pInfo->fIsDual;
        *ppVtbl = &pInfo->stubVtbl.Vtbl;
    }

    return hr;
}


HRESULT CheckTypeInfo(
    IN  ITypeInfo  *pTypeInfo,
    OUT ITypeInfo **pptinfoProxy,
    OUT USHORT     *pcMethods,
    OUT BOOL       *pfIsDual)
{
    HRESULT      hr;
    TYPEATTR   * pTypeAttr;
    HREFTYPE     hRefType;
    UINT         cbSizeVft = 0;
    ITypeInfo   *ptinfoProxy = NULL;
    USHORT       cMethods;

    *pfIsDual = FALSE;

    hr = pTypeInfo->lpVtbl->GetTypeAttr(pTypeInfo, &pTypeAttr);
    if(SUCCEEDED(hr))
    {
        if(pTypeAttr->wTypeFlags & TYPEFLAG_FDUAL)
        {
            *pfIsDual = TRUE;

            if(TKIND_DISPATCH == pTypeAttr->typekind)
            {
                //Get the TKIND_INTERFACE type info.
                hr = pTypeInfo->lpVtbl->GetRefTypeOfImplType(pTypeInfo, (UINT) -1, &hRefType);
                if(SUCCEEDED(hr))
                {
                    hr = pTypeInfo->lpVtbl->GetRefTypeInfo(pTypeInfo, hRefType, &ptinfoProxy);
                    if(SUCCEEDED(hr))
                    {
                        TYPEATTR * ptattrProxy;
                        hr = ptinfoProxy->lpVtbl->GetTypeAttr(ptinfoProxy, &ptattrProxy);
                        if(SUCCEEDED(hr))
                        {
                            cbSizeVft = ptattrProxy->cbSizeVft;
                            ptinfoProxy->lpVtbl->ReleaseTypeAttr(ptinfoProxy, ptattrProxy);
                        }
                    }
                }
            }
            else if (TKIND_INTERFACE == pTypeAttr->typekind)
            {
                pTypeInfo->lpVtbl->AddRef(pTypeInfo);
                ptinfoProxy = pTypeInfo;
                cbSizeVft = pTypeAttr->cbSizeVft;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else if((pTypeAttr->wTypeFlags & TYPEFLAG_FOLEAUTOMATION) &&
                (TKIND_INTERFACE == pTypeAttr->typekind))
        {
            pTypeInfo->lpVtbl->AddRef(pTypeInfo);
            ptinfoProxy = pTypeInfo;
            cbSizeVft = pTypeAttr->cbSizeVft;
        }
        else
        {
            hr = E_FAIL;
        }
        pTypeInfo->lpVtbl->ReleaseTypeAttr(pTypeInfo, pTypeAttr);
    }

    cMethods = (USHORT) ( (cbSizeVft - VTABLE_BASE) / sizeof(void *) );

    if(SUCCEEDED(hr))
    {
        *pptinfoProxy = ptinfoProxy;

        //Calculate the number of methods in the vtable.
        *pcMethods = cMethods;
    }
    else
    {
        *pptinfoProxy = NULL;

        if(ptinfoProxy != NULL)
        {
            ptinfoProxy->lpVtbl->Release(ptinfoProxy);
        }
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetVtbl
//
//  Synopsis: Get a pointer to the vtbl structure.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT GetVtbl(
    IN  ITypeInfo *         pTypeInfo,
    IN  REFIID              riid,
    OUT TypeInfoVtbl **     ppVtbl)
{
    HRESULT hr;
    RPC_STATUS   rc;
    USHORT       numMethods;
    MethodInfo * aMethodInfo;
    BOOL         fIsDual = FALSE;
    ITypeInfo  * ptinfoProxy = NULL;

    *ppVtbl = NULL;

    rc = NdrpPerformRpcInitialization();

    if (RPC_S_OK != rc)
        return HRESULT_FROM_WIN32(rc);

    // the other two mutexes will be initialized in NdrpInitializeStublessVtbl
    if ( TypeInfoMutex == NULL )
        {
        hr = NdrpInitializeMutex( &TypeInfoMutex );
        if ( FAILED( hr ) )
            return hr;
        }
	
    //Check the cache.
    I_RpcRequestMutex(&TypeInfoMutex);
    hr = CacheLookup(riid, ppVtbl);
    I_RpcClearMutex(TypeInfoMutex);

    if(FAILED(hr))
    {
        //We didn't find the interface in the cache.
        //Create a vtbl from the ITypeInfo.
        hr = CheckTypeInfo(pTypeInfo, &ptinfoProxy, &numMethods, &fIsDual);

        if(SUCCEEDED(hr))
        {
            //allocate space for per-method data.
            aMethodInfo = (MethodInfo *) alloca(numMethods * sizeof(MethodInfo));
            if(aMethodInfo != NULL)
            {
                memset(aMethodInfo, 0, numMethods * sizeof(MethodInfo));

                //Get the per-method data.
                hr = GetFuncDescs(ptinfoProxy, aMethodInfo);
                if(SUCCEEDED(hr))
                {
                    hr = CreateVtblFromTypeInfo(riid, fIsDual, numMethods, aMethodInfo, ppVtbl);
                    if(SUCCEEDED(hr))
                    {
                        hr = CacheRegister(riid,ppVtbl);
                    }
                }
                ReleaseFuncDescs(numMethods, aMethodInfo);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            ptinfoProxy->lpVtbl->Release(ptinfoProxy);
        }
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateVtblFromTypeInfo
//
//  Synopsis:   Create a vtbl structure from the type information.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT CreateVtblFromTypeInfo(
    IN  REFIID          riid,
    IN  BOOL            fIsDual,
    IN  USHORT          numMethods,
    IN  MethodInfo    * pMethodInfo,
    OUT TypeInfoVtbl ** ppVtbl)
{
    HRESULT hr = S_OK;
    USHORT  iMethod;
    ULONG   cbVtbl;
    ULONG   cbOffsetTable;
    USHORT  cbProcFormatString = 0;
    ULONG   cbSize;
    TypeInfoVtbl *pInfo = NULL;
    byte *pTemp;
    PFORMAT_STRING pTypeFormatString = NULL;
    PFORMAT_STRING pProcFormatString;
    unsigned short *pFormatStringOffsetTable;
    CTypeGen typeGen;
    CProcGen procGen;
    USHORT   cbFormat;
    USHORT offset = 0;
    ULONG cbDelegationTable;
    void **pDispatchTable = NULL;
    void **pStublessClientVtbl = NULL;
    void **pForwardingVtbl = NULL;

    *ppVtbl = NULL;

#ifdef DEBUGRPC
    InterlockedIncrement(&g_lCount);
#endif

    //Compute the size of the vtbl structure;
    cbVtbl = numMethods * sizeof(void *);

    if(fIsDual)
        cbDelegationTable = cbVtbl;
    else
        cbDelegationTable = 0;

    cbOffsetTable = numMethods * sizeof(USHORT);

    //Compute the size of the proc format string.
    for(iMethod = 3;
        iMethod < numMethods;
        iMethod++)
    {
        if(pMethodInfo[iMethod].pFuncDesc != NULL)
        {
#if !defined(__RPC_WIN64__)
            cbProcFormatString += 22;
#else
            // proc format string in 64bit is longer
            cbProcFormatString += 22 + sizeof(NDR_PROC_HEADER_EXTS64);
#endif
            cbProcFormatString += pMethodInfo[iMethod].pFuncDesc->cParams * 6;
        }
    }

    cbSize = sizeof(TypeInfoVtbl) + cbVtbl + cbDelegationTable + cbOffsetTable + cbProcFormatString;

    //Allocate the structure
    pInfo = (TypeInfoVtbl *) I_RpcAllocate(cbSize);

    if(pInfo != NULL)
    {
        memset(pInfo, 0, cbSize);

        pTemp = (byte *) pInfo->proxyVtbl.Vtbl + cbVtbl;

        if(cbDelegationTable != 0)
        {
            pDispatchTable = (void **) pTemp;
            pInfo->stubVtbl.header.pDispatchTable = (const PRPC_STUB_FUNCTION *) pDispatchTable;
            pTemp += cbDelegationTable;
        }

        pFormatStringOffsetTable = (unsigned short *) pTemp;
        pTemp += cbOffsetTable;
        pProcFormatString = (PFORMAT_STRING) pTemp;


        pInfo->proxyVtbl.Vtbl[0] = IUnknown_QueryInterface_Proxy;
        pInfo->proxyVtbl.Vtbl[1] = IUnknown_AddRef_Proxy;
        pInfo->proxyVtbl.Vtbl[2] = IUnknown_Release_Proxy;

        hr = NdrpInitializeStublessVtbl((ULONG)numMethods);
        if (FAILED(hr))
        {
            if (pInfo)
                I_RpcFree(pInfo);
            return hr;
        }

        //Get the format strings.
        //Generate -Oi2 proc format string from the ITypeInfo.
        GetTemplateVtbl(&pStublessClientVtbl);
        GetTemplateForwardVtbl(&pForwardingVtbl);
        for(iMethod = 3;
            SUCCEEDED(hr) && iMethod < numMethods;
            iMethod++)
        {
            if(pMethodInfo[iMethod].pFuncDesc != NULL)
            {
                pFormatStringOffsetTable[iMethod] = offset;
                hr = procGen.GetProcFormat(&typeGen,
                                           pMethodInfo[iMethod].pTypeInfo,
                                           pMethodInfo[iMethod].pFuncDesc,
                                           iMethod,
                                           (PFORMAT_STRING)pTemp,
                                           &cbFormat);

                if (FAILED(hr))
                {
                    ReleaseTemplateVtbl(pStublessClientVtbl);
                    ReleaseTemplateForwardVtbl(pForwardingVtbl);
                    if (pInfo)
                        I_RpcFree(pInfo);
                    return hr;
                }
                pTemp += cbFormat;
                offset += cbFormat;

                //Stubless client function.
                pInfo->proxyVtbl.Vtbl[iMethod] = pStublessClientVtbl[iMethod];
                if(pDispatchTable != NULL)
                {
                    //Interpreted server function.
                    pDispatchTable[iMethod] = NdrStubCall2;
                }
            }
            else
            {
                pFormatStringOffsetTable[iMethod] = (USHORT) -1;

                //Proxy delegation forwarding function.
                pInfo->proxyVtbl.Vtbl[iMethod] =  pForwardingVtbl[iMethod];

                if(pDispatchTable != NULL)
                {
                    //Stub delegation forwarding function.
                    pDispatchTable[iMethod] = NdrStubForwardingFunction;
                }
            }
        }

        ReleaseTemplateForwardVtbl(pForwardingVtbl);
        ReleaseTemplateVtbl(pStublessClientVtbl);

        if(SUCCEEDED(hr))
        {
            USHORT length;

            hr = typeGen.GetTypeFormatString(&pTypeFormatString, &length);
        }

        if(SUCCEEDED(hr))
        {
            //Initialize the vtbl.
            pInfo->cRefs = 1;

            //Initialize the iid.
            pInfo->iid = riid;
            pInfo->fIsDual = fIsDual;

            //Initialize the MIDL_STUB_DESC.
            pInfo->stubDesc.pfnAllocate = NdrOleAllocate;
            pInfo->stubDesc.pfnFree = NdrOleFree;
            //pInfo->stubDesc.apfnExprEval = ExprEvalRoutines;
            pInfo->stubDesc.pFormatTypes = pTypeFormatString;
#if !defined(__RPC_WIN64__)
            pInfo->stubDesc.Version = 0x20000; /* Ndr library version */
            pInfo->stubDesc.MIDLVersion = MIDL_VERSION_3_0_44;
#else
            pInfo->stubDesc.Version = 0x50002; /* Ndr library version */
            pInfo->stubDesc.MIDLVersion = MIDL_VERSION_5_2_202;
#endif
            pInfo->stubDesc.aUserMarshalQuadruple = UserMarshalRoutines;

            //Initialize the MIDL_SERVER_INFO.
            pInfo->stubInfo.pStubDesc = &pInfo->stubDesc;
            pInfo->stubInfo.ProcString = pProcFormatString;
            pInfo->stubInfo.FmtStringOffset = pFormatStringOffsetTable;

            //Initialize the stub vtbl.
            pInfo->stubVtbl.header.piid = &pInfo->iid;
            pInfo->stubVtbl.header.pServerInfo = &pInfo->stubInfo;
            pInfo->stubVtbl.header.DispatchTableCount = numMethods;

            //Initialize stub methods.
            memcpy(&pInfo->stubVtbl.Vtbl, &CStdStubBuffer2Vtbl, sizeof(CStdStubBuffer2Vtbl));
            pInfo->stubVtbl.Vtbl.Release = CStdStubBuffer3_Release;

            //Initialize the proxy info.
            pInfo->proxyInfo.pStubDesc = &pInfo->stubDesc;
            pInfo->proxyInfo.ProcFormatString = pProcFormatString;
            pInfo->proxyInfo.FormatStringOffset = pFormatStringOffsetTable;

            //Initialize the proxy vtbl.
            pInfo->proxyVtbl.header.pStublessProxyInfo = &pInfo->proxyInfo;
            pInfo->proxyVtbl.header.piid = &pInfo->iid;

            *ppVtbl = pInfo;
        }
        else
        {
            //Free the memory.
            I_RpcFree(pInfo);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;

}


//+---------------------------------------------------------------------------
//
//  Function:   GetFuncDescs
//
//  Synopsis:   Get the funcdesc for each method.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT GetFuncDescs(
    IN  ITypeInfo *pTypeInfo,
    OUT MethodInfo *pMethodInfo)
{
    HRESULT hr;
    TYPEATTR *pTypeAttr;
    HREFTYPE hRefType;
    ITypeInfo *pRefTypeInfo;

    hr = pTypeInfo->lpVtbl->GetTypeAttr(pTypeInfo, &pTypeAttr);

    if(SUCCEEDED(hr))
    {
        if(IsEqualIID(IID_IUnknown, pTypeAttr->guid))
        {
            hr = S_OK;
        }
        else if(IsEqualIID(IID_IDispatch, pTypeAttr->guid))
        {
            hr = S_OK;
        }
        else
        {
            //This is an oleautomation interface.
            ULONG i, iMethod;
            FUNCDESC *pFuncDesc;

            if(pTypeAttr->cImplTypes)
            {
                //Recursively get the inherited member functions.
                hr = pTypeInfo->lpVtbl->GetRefTypeOfImplType(pTypeInfo, 0, &hRefType);
                if(SUCCEEDED(hr))
                {
                    hr = pTypeInfo->lpVtbl->GetRefTypeInfo(pTypeInfo, hRefType, &pRefTypeInfo);
                    if(SUCCEEDED(hr))
                    {
                        hr = GetFuncDescs(pRefTypeInfo, pMethodInfo);
                        pRefTypeInfo->lpVtbl->Release(pRefTypeInfo);
                    }
                }
            }

            //Get the member functions.
            for(i = 0; SUCCEEDED(hr) && i < pTypeAttr->cFuncs; i++)
            {
                hr = pTypeInfo->lpVtbl->GetFuncDesc(pTypeInfo, i, &pFuncDesc);
                if(SUCCEEDED(hr))
                {
                    iMethod = (pFuncDesc->oVft - VTABLE_BASE) / sizeof(void *);
                    pMethodInfo[iMethod].pFuncDesc = pFuncDesc;
                    pTypeInfo->lpVtbl->AddRef(pTypeInfo);
                    pMethodInfo[iMethod].pTypeInfo = pTypeInfo;
                }
            }
        }

        pTypeInfo->lpVtbl->ReleaseTypeAttr(pTypeInfo, pTypeAttr);
   }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseFuncDescs
//
//  Synopsis:   Release the funcdescs.
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT ReleaseFuncDescs(USHORT numMethods, MethodInfo *pMethodInfo)
{
    USHORT iMethod;

    //Release the funcdescs.
    if(pMethodInfo != NULL)
    {
        for(iMethod = 0;
            iMethod < numMethods;
            iMethod++)
        {
            if(pMethodInfo[iMethod].pFuncDesc != NULL)
            {
                 //Release the funcdesc.
                 pMethodInfo[iMethod].pTypeInfo->lpVtbl->ReleaseFuncDesc(
                     pMethodInfo[iMethod].pTypeInfo,
                      pMethodInfo[iMethod].pFuncDesc);

                 pMethodInfo[iMethod].pFuncDesc = NULL;

                 //release the type info
                 pMethodInfo[iMethod].pTypeInfo->lpVtbl->Release(
                     pMethodInfo[iMethod].pTypeInfo);

                 pMethodInfo[iMethod].pTypeInfo = NULL;
            }
        }
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseProxyVtbl
//
//  Synopsis:   Releases the proxy vtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT ReleaseProxyVtbl(void * pVtbl)
{
    HRESULT hr = S_OK;
    byte *pTemp;
    TypeInfoVtbl *pInfo;

    pTemp = (byte *)pVtbl - offsetof(TypeInfoVtbl, proxyVtbl.Vtbl);
    pInfo = (TypeInfoVtbl *) pTemp;

    hr = ReleaseVtbl(pInfo);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReleaseStubVtbl
//
//  Synopsis:   Releases the stub vtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT ReleaseStubVtbl(void * pVtbl)
{
    HRESULT hr = S_OK;
    byte *pTemp;
    TypeInfoVtbl *pInfo;

    pTemp = (byte *)pVtbl - offsetof(TypeInfoVtbl, stubVtbl.Vtbl);
    pInfo = (TypeInfoVtbl *) pTemp;

    hr = ReleaseVtbl(pInfo);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseTypeFormatString
//
//  Synopsis:   Frees the type format string.
//
//----------------------------------------------------------------------------
HRESULT ReleaseTypeFormatString(
    PFORMAT_STRING pTypeFormat)
{
    if((pTypeFormat != 0) &&
       (pTypeFormat != __MIDL_TypeFormatString.Format))
    {
        I_RpcFree((void *)pTypeFormat);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CStdProxyBuffer3_Release
//
//  Synopsis:   Decrement the proxy's reference count
//
//  Returns:    Reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CStdProxyBuffer3_Release(
    IN  IRpcProxyBuffer *   This)
{
    ULONG               count;
    IRpcProxyBuffer *   pBaseProxyBuffer;

    count = (ULONG) ((CStdProxyBuffer2 *)This)->RefCount - 1;

    if(InterlockedDecrement(&((CStdProxyBuffer2 *)This)->RefCount) == 0)
    {
        count = 0;

        ReleaseProxyVtbl((void *) ((CStdProxyBuffer2 *)This)->pProxyVtbl);

        //Delegation support.
        pBaseProxyBuffer = ((CStdProxyBuffer2 *)This)->pBaseProxyBuffer;

        if( pBaseProxyBuffer != 0)
        {
            pBaseProxyBuffer->lpVtbl->Release(pBaseProxyBuffer);
        }

        //Free the memory
        delete (CStdProxyBuffer2 *)This;
    }

    return count;
};


//+---------------------------------------------------------------------------
//
//  Function:   CStdStubBuffer3_Release
//
//  Synopsis:   Decrement the proxy's reference count
//
//  Returns:    Reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CStdStubBuffer3_Release(
    IN  IRpcStubBuffer *    This)
{
    ULONG       count;
    unsigned char *pTemp;
    CStdStubBuffer2 * pStubBuffer;
    IRpcStubBuffer *pBaseStubBuffer;

    pTemp = (unsigned char *)This;
    pTemp -= offsetof(CStdStubBuffer2, lpVtbl);
    pStubBuffer = (CStdStubBuffer2 *) pTemp;

    count = (ULONG) pStubBuffer->RefCount - 1;

    if(InterlockedDecrement(&pStubBuffer->RefCount) == 0)
    {
        count = 0;

        ReleaseStubVtbl((void *) This->lpVtbl);

        pBaseStubBuffer = pStubBuffer->pBaseStubBuffer;

        if(pBaseStubBuffer != 0)
            pBaseStubBuffer->lpVtbl->Release(pBaseStubBuffer);

        //Free the stub buffer
        if (pStubBuffer->lpForwardingVtbl)
        ReleaseTemplateForwardVtbl((void **)pStubBuffer->lpForwardingVtbl);
        delete pStubBuffer;

    }

    return count;
}

//+---------------------------------------------------------------------------
//
//  Function:   GrowCacheIfNecessary
//
//  Synopsis:   increase the size of cache array if it's too small.
//
//  Arguments:
//
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT GrowCacheIfNecessary()
{
    TypeInfoCache *pTemp = NULL;
    DWORD *pIndex = NULL;
    if (NULL == g_pCache)
    {
        g_pCache = (TypeInfoCache *)I_RpcAllocate(CACHE_BLOCK * sizeof(TypeInfoCache));
        if (g_pCache )
        {
            memset(g_pCache,0,CACHE_BLOCK * sizeof(TypeInfoCache));
            g_lCacheSize = CACHE_BLOCK;
            return S_OK;
        }
        else
            return E_OUTOFMEMORY;

    }

    if (g_lCacheSize <= g_lTotalCacheRef)
    {
        pTemp = (TypeInfoCache *)I_RpcAllocate((g_lCacheSize + CACHE_BLOCK)* sizeof(TypeInfoCache));

        if (NULL == pTemp)
            return E_OUTOFMEMORY;

        memset(pTemp,0,(g_lCacheSize + CACHE_BLOCK)* sizeof(TypeInfoCache));
        memcpy(pTemp,g_pCache,g_lCacheSize*sizeof(TypeInfoCache));
        I_RpcFree(g_pCache);
        g_pCache = pTemp;
        g_lCacheSize += CACHE_BLOCK;
    }

    return S_OK;


}

void swapCache(ULONG src, ULONG dest)
{
    if (src == dest)
        return;

    TypeInfoCache temp;
    memcpy(&temp,&g_pCache[src],sizeof(TypeInfoCache));
    memcpy(&g_pCache[src],&g_pCache[dest],sizeof(TypeInfoCache));
    memcpy(&g_pCache[dest],&temp,sizeof(TypeInfoCache));
}

//+---------------------------------------------------------------------------
//
//  Function:   CacheRegister
//
//  Synopsis:   add a new instance of interface into the cache list. before
//                  inserting the newly generated vtbl, make sure no other thread
//                  has generated it first. If existing, discard the one this
//                  thread generated and use the one already in the list. Otherwise
//                  put it at the end of the array and adjust cache length.
//
//  Arguments:  riid,
//              pVtbl
//
//  Returns:
//
//----------------------------------------------------------------------------
HRESULT CacheRegister(
    IID riid,
    TypeInfoVtbl ** ppVtbl)
{
    HRESULT hr = E_FAIL;
    TypeInfoVtbl *pVtbl = *ppVtbl;

    // this exact same item has been registered by others while we
    // are busying building our own: use the existing one instead.
    I_RpcRequestMutex(&TypeInfoMutex);
    if (CacheLookup(riid,ppVtbl) == S_OK)
    {
        if(pVtbl->stubDesc.pFormatTypes != __MIDL_TypeFormatString.Format)
        {
            I_RpcFree((void *) pVtbl->stubDesc.pFormatTypes);
        }
        I_RpcFree(pVtbl);
        I_RpcClearMutex(TypeInfoMutex);
        return S_OK;
    }

    hr = GrowCacheIfNecessary();
    if (SUCCEEDED(hr))
    {
        g_pCache[g_lTotalCacheRef].iid = (*ppVtbl)->iid;
        g_pCache[g_lTotalCacheRef].dwTickCount = 0;
        g_pCache[g_lTotalCacheRef].pVtbl = *ppVtbl;

        swapCache(g_lTotalCacheRef,g_lActiveCacheRef);
        g_lTotalCacheRef++;
        g_lActiveCacheRef++;
    }


    I_RpcClearMutex(TypeInfoMutex);
    return hr;

}


void swap(ULONG *dwDelta,
          ULONG *dwIndex,
          ULONG src,
          ULONG dest)
{
    if (src == dest)
        return;

    ULONG temp;
    temp = dwDelta[src];
    dwDelta[src] = dwDelta[dest];
    dwDelta[dest] = temp;

    temp = dwIndex[src];
    dwIndex[src] = dwIndex[dest];
    dwIndex[dest] = temp;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindEntrysToShrink
//
//  Synopsis:   find the largest ulPivot number of entrys in the array.
//              a modification of algorithm due to C.A.R. Hoare in Programming
//              Pearls in Novermber 1985 Communications of ACM.
//
//  Arguments:
//
//  Returns:
//
//----------------------------------------------------------------------------

void  FindEntrysToShrink(ULONG *dwDelta,
                         ULONG *dwIndex,
                         ULONG ulPivot)
{
    ULONG ulLow = 0 , ulUp , ulSeq;
    ULONG ulMid ,ulIndex;
    ulUp = g_lTotalCacheRef - g_lActiveCacheRef -1 ;
    while (ulLow < ulUp)
    {
        ulSeq = ulLow;
        // pick a random number and assume it's the kth largest.
        ulIndex = ulLow + ((GetTickCount() & 0xff)*(ulUp-ulLow)/0xff);
        ulMid = dwDelta[ulIndex];
        swap(dwDelta,dwIndex,ulIndex,ulLow);
        for (ULONG i = ulLow + 1; i <= ulUp; i++)
        {
            if (dwDelta[i] >= ulMid)
                swap(dwDelta,dwIndex,++ulSeq,i);
        }
        // ulSeq is the ulSeq'th largest.
        swap(dwDelta,dwIndex,ulSeq,ulLow);
        if (ulSeq == ulPivot)
            break;  // done
        if (ulSeq < ulPivot)
            ulLow = ulSeq + 1 ;
        else
            ulUp = ulSeq - 1;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ShrinkReleasedCacheIfNecessary
//
//  Synopsis:   adjust the released cache size if necessary.
//              the algorithm:
//              find the eldest DELTA_MARK released interfaces. to avoid thrashing,
//                  increase the released cache size if eldest one is released within
//                  30 sec. fill the empty spots with active entries.
//
//  Arguments:
//
//  Returns:    S_OK. leave the HRESULT return for possible future change.
//
//----------------------------------------------------------------------------

HRESULT ShrinkReleasedCacheIfNecessary(TypeInfoVtbl*** pppVtbl, DWORD *dwLength)
{
    static ULONG dwHigh = INIT_HIGH_MARK;
    HRESULT hr = E_FAIL;
    ULONG dwShrink ;
    ULONG *dwDelta = NULL;
    ULONG *dwIndex = NULL;
    TypeInfoVtbl **ppvtbl = NULL;
    ULONG dwTime = GetTickCount(), dwMax = 0;
    ULONG i,j, dwMin=0xffffffff;
    ULONG dwReleasedCache = g_lTotalCacheRef - g_lActiveCacheRef;

    // doesn't need to shrink
    if (dwReleasedCache <= dwHigh)
        return S_FALSE;

    dwShrink = (ULONG)(dwHigh / DELTA_MARK); // number to shrink
    dwDelta = (ULONG *)I_RpcAllocate(dwReleasedCache * sizeof(ULONG));
    dwIndex = (ULONG *)I_RpcAllocate(dwReleasedCache * sizeof(ULONG));
    ppvtbl = (TypeInfoVtbl **)I_RpcAllocate(dwShrink * sizeof(TypeInfoVtbl *));

    if ( ( NULL == ppvtbl ) || ( NULL == dwDelta ) || ( NULL == dwIndex ) )
    {
        if ( NULL != dwDelta ) I_RpcFree( dwDelta );
        if ( NULL != dwIndex ) I_RpcFree( dwIndex );
        if ( NULL != ppvtbl ) I_RpcFree( ppvtbl );
        return E_OUTOFMEMORY;
    }

    for ( i = 0; i < dwReleasedCache; i++)
    {
        dwDelta[i] = dwTime - g_pCache[g_lActiveCacheRef+i].dwTickCount;
        dwIndex[i] = g_lActiveCacheRef+i;
        // basic book keeping to find the eldest and latest release.
        if (dwDelta[i] > dwMax)
            dwMax = dwDelta[i];
        if (dwDelta[i] < dwMin)
            dwMin = dwDelta[i];
    }

    // don't reclaim those released entries if it's thrashing.
    if (dwMax <= THRASHING_TIME)
    {
        dwHigh += (ULONG)(dwHigh / DELTA_MARK);
        return S_FALSE;
    }

    FindEntrysToShrink(dwDelta,dwIndex,dwShrink);


    // cleanup the entries to be removed.
    for (i = 0; i < dwShrink; i++)
    {
        ppvtbl[i] = g_pCache[dwIndex[i]].pVtbl;
        ASSERT(ppvtbl[i]->cRefs == 0);
        g_pCache[dwIndex[i]].pVtbl = 0;
    }


    // fill in the empty spots.
    j = g_lTotalCacheRef -1;
    for (i = 0; i < dwShrink; i++)
    {

        while (j > 0 && (g_pCache[j].pVtbl == 0)) j--;
        if (j > dwIndex[i])
        {
            memcpy(&g_pCache[dwIndex[i]],&g_pCache[j],sizeof(TypeInfoCache));
            memset(&g_pCache[j],0,sizeof(TypeInfoCache));
            j--;
        }
        else
            memset(&g_pCache[dwIndex[i]],0,sizeof(TypeInfoCache));

    }
    g_lTotalCacheRef -= dwShrink;

#ifdef DEBUGRPC
    for (i = 0; (LONG)i < g_lTotalCacheRef; i++)
        ASSERT(g_pCache[i].pVtbl != 0);
#endif

    if (dwMin > IDLE_TIME)
    {
        dwHigh -= (ULONG)(dwHigh / DELTA_MARK);
        if (dwHigh < INIT_HIGH_MARK)
            dwHigh = INIT_HIGH_MARK;
    }

    // don't free those vtbls: do it out of CS
    *pppVtbl = ppvtbl;
    *dwLength = dwShrink;
    return S_OK;

}



//+---------------------------------------------------------------------------
//
//  Function:   ReleaseVtbl
//
//  Synopsis:   Releases the vtbl.
//
//  Arguments:
//
//  Returns:
//    S_OK
//
//----------------------------------------------------------------------------
HRESULT ReleaseVtbl(TypeInfoVtbl *pInfo)
{
    TypeInfoVtbl **ppvtbl = NULL;
    DWORD dwLength = 0;
    LONG i;
    HRESULT hr = E_FAIL;

    I_RpcRequestMutex(&TypeInfoMutex);
    if (0 == --pInfo->cRefs)
    {
        for (i = 0 ; i < g_lTotalCacheRef; i++)
        {
            if (IsEqualIID(pInfo->iid,g_pCache[i].iid))
            {
                g_pCache[i].dwTickCount = GetTickCount();
                g_lActiveCacheRef--;
                swapCache(i,g_lActiveCacheRef);
                hr = ShrinkReleasedCacheIfNecessary(&ppvtbl,&dwLength);
                break;
             }
        }
    }
    else
    {
        I_RpcClearMutex(TypeInfoMutex);
        return S_OK;
    }
    I_RpcClearMutex(TypeInfoMutex);

    // free the vtbl outof mutex.
    if (S_OK == hr)
    {
        for (i = 0; i < (LONG)dwLength; i++)
        {

            if((ppvtbl[i])->stubDesc.pFormatTypes != __MIDL_TypeFormatString.Format)
            {
                I_RpcFree((void *) (ppvtbl[i])->stubDesc.pFormatTypes);
            }

            I_RpcFree((void *) ppvtbl[i]);
        }
        I_RpcFree(ppvtbl);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CacheLookup
//
//  Synopsis:   look up a TypeInfoVtbl from cache array using IID.
//              adjust the cache state if the entry is released.
//
//  Arguments:  riid
//              ppInfo
//
//  Returns:    S_OK if an entry is found in cache. E_NOINTERFACE is not.
//
//----------------------------------------------------------------------------
HRESULT CacheLookup(
    REFIID riid,
    TypeInfoVtbl **ppInfo)
{
    HRESULT hr = E_NOINTERFACE;
    LONG i;

    if (NULL == g_pCache)
        goto Exit;

    for ( i = 0; i < g_lTotalCacheRef; i++)
    {
        if (IsEqualIID(riid,g_pCache[i].iid))
        {
            *ppInfo = g_pCache[i].pVtbl;
            if (0 == (*ppInfo)->cRefs++)
            {
                g_pCache[i].dwTickCount = 0;
                swapCache(i,g_lActiveCacheRef++);
            }
            hr = S_OK;
            goto Exit;
        }
    }

Exit:
    return hr;

}


//+---------------------------------------------------------------------------
//
//  Function:   NdrpGetTypeGenCookie
//
//  Synopsis:   Allocate a cookie that can be used in subsequent calls to
//              NdrpGetProcFormatString, NdrpGetTypeFormatString, and
//              NdrpReleaseTypeGenCookie.
//
//  Parameters:
//
//  Returns:    ppvTypeGenCookie: A type gen cookie
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpGetTypeGenCookie(void **ppvTypeGenCookie)
{
	HRESULT hr = S_OK;
	CTypeGen *pTypeGen;

	if (ppvTypeGenCookie == NULL)
		return E_POINTER;

    // Ensure that everything is initialized.
    RPC_STATUS sc = NdrpPerformRpcInitialization();
    if (sc != RPC_S_OK)
        return HRESULT_FROM_WIN32(sc);

	pTypeGen = new CTypeGen;
	if (pTypeGen)
		*ppvTypeGenCookie = pTypeGen;
	else
		hr = E_OUTOFMEMORY;

	return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrpReleaseTypeGenCookie
//
//  Synopsis:   Free memory associeated with type gen cookie allocated with
//              NdrpGetTypeGenCookie
//
//  Parameters: pvTypeGenCookie: cookie returned from NdrpGetTypeGenCookie
//
//  Returns:
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpReleaseTypeGenCookie(void *pvTypeGenCookie)
{
	CTypeGen *pTypeGen = (CTypeGen *)pvTypeGenCookie;

	delete pTypeGen;

	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrpGetProcFormatString
//
//  Synopsis:   Generate proc format string and type format string for specified
//              function.
//
//  Parameters: pTypeGenCookie: Type format generator object
//              pTypeInfo:      ITypeInfo interface.
//              pFuncDesc:      Function descriptor.
//              iMethod:        # of methods.
//
//  Returns:    pProcFormatString: Address for proc format string.
//              pcbFormat: Size of format string.
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpGetProcFormatString(IN  void      *pvTypeGenCookie,
								IN  ITypeInfo *pTypeInfo,
								IN  FUNCDESC  *pFuncDesc,
								IN  USHORT     iMethod,
								OUT PFORMAT_STRING pProcFormatString,
								OUT USHORT    *pcbFormat)
{
	CProcGen proc;
	CTypeGen *pTypeGen = (CTypeGen *)pvTypeGenCookie;

	if (pTypeGen == NULL)
		return E_INVALIDARG;
	else
		return proc.GetProcFormat(pTypeGen, pTypeInfo, pFuncDesc, iMethod,
								  pProcFormatString, pcbFormat);
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrpGetTypeFormatString
//
//  Synopsis:   Get the MIDL_TYPE_FORMAT_STRING.
//
//  Arguments:  pvTypeGenCookie - cookie allocated with NdrpGetTypeGenCookie
//                                and used in subsequent NdrpGetProcFormatString
//                                calls.
//
//              ppTypeFormatString - Returns a pointer to the type format
//                                   string.
//
//              pLength - Returns the length of the format string.
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpGetTypeFormatString(IN void *pvTypeGenCookie,
								OUT PFORMAT_STRING * pTypeFormatString,
								OUT USHORT *         pLength)
{
	CTypeGen *pTypeGen = (CTypeGen *)pvTypeGenCookie;

	if (pTypeGen == NULL)
		return E_INVALIDARG;
	else
		return pTypeGen->GetTypeFormatString(pTypeFormatString, pLength);
}

//+---------------------------------------------------------------------------
//
//  Function:   NdrpReleaseTypeFormatString
//
//  Synopsis:   Free the memory returned from NdrpGetTypeFormatString function.
//
//  Parameters: pTypeFormatString: Address of format string returned from
//                                 NdrpGetTypeFormatString.
//
//----------------------------------------------------------------------------
EXTERN_C
HRESULT NdrpReleaseTypeFormatString(PFORMAT_STRING pTypeFormatString)
{
	if (pTypeFormatString)
	{
		if(pTypeFormatString != __MIDL_TypeFormatString.Format)
		{
			I_RpcFree((void *)pTypeFormatString);
		}	
	}

	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetProcFormat
//
//  Synopsis:   Generate proc format string and type format string for specified
//              function.
//
//  Parameters: pTeypGen: Type format generator object
//              pTypeInfo: ITypeInfo interface.
//              pFuncDesc: Function descriptor.
//              iMethod:   # of methods.
//
//  Returns:    pProcFormatString: Address for proc format string.
//
//----------------------------------------------------------------------------
HRESULT CProcGen::GetProcFormat(
    IN  CTypeGen     * pTypeGen,
    IN  ITypeInfo    * pTypeInfo,
    IN  FUNCDESC     * pFuncDesc,
    IN  USHORT         iMethod,
    OUT PFORMAT_STRING pProcFormatString,
    OUT USHORT       * pcbFormat)
{
    HRESULT hr = S_OK;
    USHORT  iParam;
    INTERPRETER_FLAGS OiFlags ;
    INTERPRETER_OPT_FLAGS Oi2Flags ;
    INTERPRETER_OPT_FLAGS2 Oi2Flags2;
    PARAMINFO *aParamInfo;
    BOOLEAN fChangeSize,fNeedChange = FALSE;
    USHORT offset;

    aParamInfo = new PARAMINFO[pFuncDesc->cParams];

    if(0 == aParamInfo)
    {
        return E_OUTOFMEMORY;
    }

    for(iParam = 0;
        iParam < pFuncDesc->cParams;
        iParam++)
    {
        hr = VarVtOfTypeDesc(pTypeInfo,
                             &pFuncDesc->lprgelemdescParam[iParam].tdesc,
                             &aParamInfo[iParam]);

        if(SUCCEEDED(hr))
        {
            // PARAMFlags should give us enough information.
            DWORD wIDLFlags = pFuncDesc->lprgelemdescParam[iParam].idldesc.wIDLFlags;

            if(wIDLFlags & IDLFLAG_FRETVAL)
            {
                wIDLFlags |= IDLFLAG_FOUT;
            }

            if(!(wIDLFlags & (IDLFLAG_FIN | IDLFLAG_FOUT)))
            {
                //Set the direction flags.
                if(aParamInfo[iParam].vt & (VT_BYREF | VT_ARRAY))
                {
                    wIDLFlags |= IDLFLAG_FIN | IDLFLAG_FOUT;
                }
                else
                {
                    wIDLFlags |= IDLFLAG_FIN;
                }
            }

            aParamInfo[iParam].wIDLFlags = wIDLFlags;
        }
        else
        {
            goto Error;
        }
    }


    _pTypeGen = pTypeGen;
    _offset = 0;
    _pProcFormatString = pProcFormatString;
    _fClientMustSize  = FALSE;
    _fServerMustSize  = FALSE;
    _fClientCorrCheck = FALSE;
    _fServerCorrCheck = FALSE;
    _clientBufferSize = 0;
    _serverBufferSize = 0;
    _usFloatArgMask   = 0;
    _usFloatSlots     = 0;

    // The "this" pointer uses 8 bytes of stack on Alpha and 64bit platforms
    // and 4 bytes of stack on other platforms.
    _stackSize = sizeof(REGISTER_TYPE);


    //Compute the size of the parameters. leave out structures. We can only determine
    // the size later.
    // Also, we calculate the Oi2 extension flags / FloatMask for 64bit
    for(iParam = 0;
        SUCCEEDED(hr) && iParam < pFuncDesc->cParams;
        iParam++)
    {
        hr = CalcSize(aParamInfo[iParam].vt,
                      aParamInfo[iParam].wIDLFlags,
                      iParam);
    }

    if(SUCCEEDED(hr))
    {
        //Compute the size of the HRESULT return value.
        _stackSize += sizeof(REGISTER_TYPE);

        LENGTH_ALIGN(_serverBufferSize, 3);
        _serverBufferSize += 8;     // HRESULT is simple type, overestimate it also

        //Handle type
        PushByte(FC_AUTO_HANDLE);

        //Oi interpreter flags
        OiFlags.FullPtrUsed           = FALSE;
        OiFlags.RpcSsAllocUsed        = FALSE;
        OiFlags.ObjectProc            = TRUE;
        OiFlags.HasRpcFlags           = TRUE;
        OiFlags.IgnoreObjectException = FALSE;
        OiFlags.HasCommOrFault        = TRUE;
        OiFlags.UseNewInitRoutines    = TRUE;
        OiFlags.Unused                = FALSE;
        PushByte(*((byte *) &OiFlags));

        PushLong(0);       // RpcFlags

        //Method number
        PushShort(iMethod);

        offset = _offset;   // _stackSize,_clientBufferSize and _serverBufferSize could be
        //Stack size
        PushShort(_stackSize);

        //Size of client RPC message buffer.
        // place holder if there is a UDT parameter
        if(_clientBufferSize <= 65535)
            PushShort((USHORT) _clientBufferSize);
        else
        {
            hr = E_FAIL;
            goto Error;
        }

        //Size of server RPC message buffer.
        if(_serverBufferSize <= 65535)
            PushShort((USHORT) _serverBufferSize);
        else
        {
            hr = E_FAIL;
            goto Error;
        }

        //Oi2 interpreter flags
        *(byte*)&Oi2Flags = 0;
        Oi2Flags.ServerMustSize = _fServerMustSize;
        Oi2Flags.ClientMustSize = _fClientMustSize;
        Oi2Flags.HasReturn = TRUE;
        Oi2Flags.HasPipes = FALSE;
        Oi2Flags.Unused = 0;

#if defined(__RPC_WIN64__)
//      robust is only availble in 64bit tlb
        Oi2Flags.HasExtensions = TRUE;
#endif
        PushByte(*((byte *) &Oi2Flags));

        //Number of parameters + return value.
        PushByte(pFuncDesc->cParams + 1);

#if defined(__RPC_WIN64__)
//      robust is only availble in 64bit tlb
        if ( Oi2Flags.HasExtensions )
            {
            *(byte*)&Oi2Flags2 = 0;
            Oi2Flags2.HasNewCorrDesc = _fClientCorrCheck | _fServerCorrCheck ;
            Oi2Flags2.ClientCorrCheck = _fClientCorrCheck;
            Oi2Flags2.ServerCorrCheck = _fServerCorrCheck;
            PushByte( sizeof(NDR_PROC_HEADER_EXTS64) );   // header extension size
            PushByte( *( (byte *) &Oi2Flags2 ) ); // extension flags
            PushShort(0);   // client correlation count
            PushShort(0);   // server collrelation count
            PushShort(0);   // notify index
            PushShort(0);   // placeholder for WIN64 float mask
            }
#endif

        // only a place holder for now if there are struct parameters.
        //Generate the parameter info.

        //The "this" pointer uses 8 bytes of stack on Alpha
        //and 4 bytes of stack on other platforms.
        _stackSize = sizeof(REGISTER_TYPE);

        for(iParam = 0;
            SUCCEEDED(hr) && iParam < pFuncDesc->cParams;
            iParam++)
        {
            hr = GenParamDescriptor(&aParamInfo[iParam],&fChangeSize);
            if (fChangeSize)    // there are structs as parameters.
            // _stackSize etc. might need to be changed.
            {
                fNeedChange = TRUE;
            }
        }


        if(SUCCEEDED(hr))
        {
            //Generate the HRESULT return value.
            PushShort( 0x70); //IsOut, IsReturn, IsBaseType
            PushShort(_stackSize);
            PushByte(FC_LONG);
            PushByte(0);
            *pcbFormat = _offset;
        }

         if (fNeedChange)
         {
            //Compute the size of the HRESULT return value.
            LENGTH_ALIGN(_serverBufferSize, 3);
            _serverBufferSize += 4;
            _stackSize += sizeof(REGISTER_TYPE);
            SetShort(offset,_stackSize);
            SetShort(offset + sizeof(SHORT),(USHORT)_clientBufferSize);
            SetShort(offset + 2*sizeof(SHORT),(USHORT)_serverBufferSize);
            if (_clientBufferSize > _UI16_MAX || _serverBufferSize > _UI16_MAX)
            {
                hr = E_FAIL;
                goto Error;
            }
         }

#if defined(__RPC_WIN64__)
         // Set the WIN64 floatarg mask
         SetShort(24, _usFloatArgMask);
#endif
   }
Error:
    delete [] aParamInfo;
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   CProcGen::CalcSize
//
//  Synopsis:   calculate the stack size of current parameter in a method, also
//              calculate Oi2 extension flags for 64bit
//
//
//  Arguments:
//    IN VARTYPE vt       - vt type of current parameter
//    IN DWORD wIDLFlags  - IDL flags of this paramter
//    IN ULONG nParam     - parameter number
//
//  Returns:
//    S_OK
//    DISP_E_BADVARTYPE
//
//----------------------------------------------------------------------------
HRESULT CProcGen::CalcSize(
        IN  VARTYPE vt,
        IN  DWORD   wIDLFlags,
        IN  ULONG   nParam)
{
    HRESULT    hr = S_OK;

    switch(vt & (~VT_BYREF))
    {
    case VT_I1:
    case VT_UI1:
        _stackSize += sizeof(REGISTER_TYPE);

         if(wIDLFlags & IDLFLAG_FIN)
         {
            _clientBufferSize += 1;
         }

         if(wIDLFlags & IDLFLAG_FOUT)
         {
            _serverBufferSize += 1;
         }
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        _stackSize += sizeof(REGISTER_TYPE);

         if(wIDLFlags & IDLFLAG_FIN)
         {
            _clientBufferSize = (_clientBufferSize + 1) & ~1;
            _clientBufferSize += 4;
         }

         if(wIDLFlags & IDLFLAG_FOUT)
         {
            _serverBufferSize = (_serverBufferSize + 1) & ~1;
            _serverBufferSize += 4;
         }
        break;

    case VT_R4:
#if defined(_WIN64)
        // setup float mask for WIN64
        if ( !( vt & VT_BYREF ) && ( _stackSize/sizeof(REGISTER_TYPE)  < ARGS_IN_REGISTERS ) ) 
            _usFloatArgMask |= 1 << ( 2 * _stackSize/sizeof(REGISTER_TYPE)  );
#endif
    case VT_I4:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:
    case VT_ERROR:
    case VT_HRESULT:
        _stackSize += sizeof(REGISTER_TYPE);

         if(wIDLFlags & IDLFLAG_FIN)
         {
            _clientBufferSize = (_clientBufferSize + 3) & ~3;
            _clientBufferSize += 8;
         }

         if(wIDLFlags & IDLFLAG_FOUT)
         {
            _serverBufferSize = (_serverBufferSize + 3) & ~3;
            _serverBufferSize += 8;
         }
        break;

    case VT_R8:
    case VT_DATE:
#if defined(_WIN64)
        // setup float mask for WIN64
        if ( !( vt & VT_BYREF )  && ( _stackSize/sizeof(REGISTER_TYPE)  < ARGS_IN_REGISTERS ) ) 
            _usFloatArgMask |= 1 << ( 2 * _stackSize/sizeof(REGISTER_TYPE) + 1 );
#endif
    case VT_CY:
    case VT_I8:
    case VT_UI8:
        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            _stackSize += 8;
        }

        if(wIDLFlags & IDLFLAG_FIN)
        {
            _clientBufferSize = (_clientBufferSize + 7) & ~7;
            _clientBufferSize += 16;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _serverBufferSize = (_serverBufferSize + 7) & ~7;
            _serverBufferSize += 16;
        }
        break;

    case VT_DECIMAL:
        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            // On WIN64 no need to align when size is up to 8 bytes
#if defined(_AMD64_)
            _stackSize += sizeof(REGISTER_TYPE);
#else
            _stackSize += sizeof(DECIMAL);
#endif
        }

        // overestimate the alignment to avoid buffer underrun during marshalling
        if(wIDLFlags & IDLFLAG_FIN)
        {
            _clientBufferSize = (_clientBufferSize + 7) & ~7;
            _clientBufferSize += sizeof(DECIMAL)  + 8;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _serverBufferSize = (_serverBufferSize + 7) & ~7;
            _serverBufferSize += sizeof(DECIMAL)  + 8;
        }
        break;

    case VT_VARIANT:
        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
// in new spec, VARIANT is aligned to 8 again.
#if defined(_WIN64)
            LENGTH_ALIGN(_stackSize, 7);
#endif
#if defined(_AMD64_)
            _stackSize += sizeof(REGISTER_TYPE );
#else
            _stackSize += sizeof(VARIANT);
#endif
        }

        if(wIDLFlags & IDLFLAG_FIN)
        {
            _fClientMustSize = TRUE;
            _fServerCorrCheck= TRUE;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _fServerMustSize = TRUE;
            _fClientCorrCheck= TRUE;
        }
        break;

    case VT_INTERFACE:
    case VT_UNKNOWN:
    case VT_DISPATCH:
    case VT_STREAM:
    case VT_STORAGE:
    // structure
    case VT_USERDEFINED:
    case VT_BSTR:
    case VT_MULTIINDIRECTIONS:
    case VT_CARRAY:
        // set robust check for interfaces
        if(wIDLFlags & IDLFLAG_FIN)
        {
            _fServerCorrCheck= TRUE;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _fClientCorrCheck= TRUE;
        }
        // fall through for sizing

    case VT_LPSTR:
    case VT_LPWSTR:
        _stackSize += sizeof(REGISTER_TYPE);

        if(wIDLFlags & IDLFLAG_FIN)
        {
            _fClientMustSize = TRUE;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _fServerMustSize = TRUE;
        }
        break;

    case VT_FILETIME:
        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            _stackSize += sizeof(FILETIME);
        }

        if(wIDLFlags & IDLFLAG_FIN)
        {
            _clientBufferSize = (_clientBufferSize + 3) & ~3;
            _clientBufferSize += sizeof(FILETIME) + 4;
        }

        if(wIDLFlags & IDLFLAG_FOUT)
        {
            _serverBufferSize = (_serverBufferSize + 3) & ~3;
            _serverBufferSize += sizeof(FILETIME) + 4;
        }
        break;

    default:
        if(vt & VT_ARRAY)
        {
            _stackSize += sizeof(REGISTER_TYPE);

            if(wIDLFlags & IDLFLAG_FIN)
            {
                _fClientMustSize = TRUE;
                _fServerCorrCheck= TRUE;
            }

            if(wIDLFlags & IDLFLAG_FOUT)
            {
                _fServerMustSize = TRUE;
                _fClientCorrCheck= TRUE;
            }
        }
        else
        {
            hr = DISP_E_BADVARTYPE;
        }
        break;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   GenParamDescriptor
//
//  Synopsis:   generate proc string and format string for one parameter.
//
//  Parameter:  parainfo. the parameter information. vt for VARTYPE,
//                  IID if VARTYPE is interface,
//                  ITypeInfo if VARTYPE is UDT
//
//  Returns:    fChangeSize. TRUE if the parameter is a UDT. member variable of
//              CProcGen (_stackSize,_clientBufferSize and _serverBufferSize need to
//              be written back)
//
//----------------------------------------------------------------------------
HRESULT
CProcGen::GenParamDescriptor(
    IN  PARAMINFO  *parainfo,
    OUT BOOLEAN  * fChangeSize)
{
    HRESULT hr = S_OK;
    PARAM_ATTRIBUTES attr;
    USHORT     offset;
    *fChangeSize = FALSE;
    VARTYPE vt = parainfo->vt;
    VARTYPE vtnoref = vt & (~VT_BYREF) ;
    MemoryInfo ProcMemInfo;
    USHORT ParamOffset = _stackSize;

    memset( &attr, 0, sizeof(attr) );
    memset( &ProcMemInfo, 0, sizeof( ProcMemInfo ) );
    attr.IsIn = (parainfo->wIDLFlags & IDLFLAG_FIN) ? 1 : 0;
    attr.IsOut = (parainfo->wIDLFlags & IDLFLAG_FOUT) ? 1 : 0;

    switch(vtnoref)
    {
    case VT_I1:
    case VT_UI1:
    case VT_I2:
    case VT_BOOL:
    case VT_UI2:
    case VT_I4:
    case VT_INT:
    case VT_ERROR:
    case VT_HRESULT:
    case VT_UINT:
    case VT_UI4:
    case VT_R4:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        PushShort(VT_FC_MAP[vtnoref] );
        break;

    case VT_I8:
    case VT_UI8:
    case VT_CY:
    case VT_R8:
    case VT_DATE:
        attr.IsBasetype = TRUE;
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            PushShort(_stackSize);
            _stackSize += 8;
        }

        PushShort(VT_FC_MAP[vtnoref] );
        break;
    case VT_DISPATCH:
    case VT_UNKNOWN:
    case VT_INTERFACE:
    case VT_STREAM:
    case VT_STORAGE:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        hr = _pTypeGen->RegisterType(parainfo, &offset, &ProcMemInfo );
        PushShort(offset);
        break;

    case VT_BSTR:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;

        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        else
        {
            attr.IsByValue = TRUE;
        }

        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        hr = _pTypeGen->RegisterType(parainfo, &offset, &ProcMemInfo );
        PushShort(offset);
        break;

    case VT_VARIANT:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;

#if defined(_AMD64_)
        // in amd64, variant is always passed by reference. 
        vt |= VT_BYREF;
        parainfo->vt  |= VT_BYREF;
#endif
        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                // size of VARIANT in 64bit is larger.
                attr.ServerAllocSize = (sizeof(VARIANT) +7 ) >> 3;
            }
        }
        else
        {
            attr.IsByValue = TRUE;
        }

        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
#if defined(_WIN64)
            LENGTH_ALIGN(_stackSize, 7);
#endif 
            PushShort(_stackSize);
            _stackSize += sizeof(VARIANT);
        }

        hr = _pTypeGen->RegisterType(parainfo, &offset, &ProcMemInfo );
        PushShort(offset);
        break;

    case VT_LPSTR:
    case VT_LPWSTR:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;

        if(vt & VT_BYREF)
        {
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        else
        {
            attr.IsSimpleRef = TRUE;
        }

        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        hr = _pTypeGen->RegisterType(parainfo, &offset, &ProcMemInfo );
        PushShort(offset);
        break;

    case VT_DECIMAL:
        attr.MustFree = TRUE;
#if defined(_AMD64_)
        // in amd64, decimal is always passed by reference.
        vt |= VT_BYREF;
        parainfo->vt |= VT_BYREF;
#endif

        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = (sizeof( DECIMAL ) + 7 ) >> 3;
            }
        }
        else
        {
            attr.IsByValue = TRUE;
        }

        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            // On WIN64 no need to align when size is up to 8 bytes
            PushShort(_stackSize);
            _stackSize += sizeof(DECIMAL);
        }

        hr = _pTypeGen->RegisterType(parainfo, &offset, &ProcMemInfo );
        PushShort(offset);
        break;

    case VT_FILETIME:
        attr.MustFree = TRUE;

        if(vt & VT_BYREF)
        {
            attr.IsSimpleRef = TRUE;
            if(!attr.IsIn)
            {
                attr.ServerAllocSize = 1;
            }
        }
        else
        {
            attr.IsByValue = TRUE;
        }

        PushShort(*((short *) &attr));

        if(vt & VT_BYREF)
        {
            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            // On WIN64 no need to align when size is up to 8 bytes
            PushShort(_stackSize);
            _stackSize += sizeof(FILETIME);
        }

        hr = _pTypeGen->RegisterType(parainfo, &offset, &ProcMemInfo );
        PushShort(offset);
        break;

    case VT_CARRAY:
    case VT_USERDEFINED:
        {
        SHORT WireAlignment,length;
        BOOL   IsByRef = FALSE;
#if defined(_AMD64_)        
        IsByRef = vt & VT_BYREF;

        if ( vt & VT_USERDEFINED )
            {
            parainfo->vt |= VT_BYREF;
            }
#endif        
        hr = _pTypeGen->RegisterType(parainfo, &offset,&ProcMemInfo);
        if (FAILED(hr))
            break;
        WireAlignment = ProcMemInfo.WireAlignment;
        length = ProcMemInfo.MemorySize;

#if defined(_AMD64_)
        // we need to roll back if the struct size is 1,2,4,8
        if ( !IsByRef && length <= 8 &&  !(length & (length-1) ) )
            {
            parainfo->vt &= ~VT_BYREF;
            hr = _pTypeGen->GetOffset(offset + 2 * sizeof (BYTE), &offset);
            if(FAILED(hr))
                    break;
            }
        else    // otherwise, it's effecitvely pass by reference
            vt |= VT_BYREF;
            
#endif
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;
        if ((vt & (~VT_BYREF)) != VT_CARRAY)
        {
            // this is code for server alloc field in proc format string. 
            // optimization to reduce the allocation for small top level struct
            if(vt & VT_BYREF)
            {
                USHORT serverSize = length + 7;
                serverSize = serverSize >> 3;
                if (serverSize < 8 && !attr.IsIn)
                    attr.ServerAllocSize = serverSize;
                attr.IsSimpleRef = TRUE;
                hr = _pTypeGen->GetOffset(offset + 2 * sizeof (BYTE), &offset);
                if(FAILED(hr))
                    break;
            }
            else
            {
                attr.IsByValue = TRUE;
            }
        }

        PushShort(*((short *) &attr));
        PushShort(_stackSize);
        PushShort(offset);

        if(vt & VT_BYREF)
        {
            _stackSize += sizeof(REGISTER_TYPE);
        }
        else
        {
            if (vt == VT_CARRAY)
                _stackSize += sizeof(REGISTER_TYPE);
            else
            {
                USHORT ualign = sizeof(REGISTER_TYPE) -1;
#if defined(_AMD64_)
                _stackSize += sizeof(REGISTER_TYPE);
#else                
                _stackSize += length;
#endif
                _stackSize = (_stackSize + ualign) & ~ualign;
            #if defined(__RPC_WIN64__)
                // only check for floatmask if it UDT. top level float/double is handled already
                AnalyzeFloatTypes(ParamOffset, offset);
            #endif
            }
        }

        // over estimate the buffersize to avoid buffer underrun during marshalling
        if (parainfo->wIDLFlags & IDLFLAG_FIN)
        {
            _clientBufferSize += WireAlignment+ 1;
        }
        if (parainfo->wIDLFlags & IDLFLAG_FOUT)
        {
            _serverBufferSize += WireAlignment + 1;
        }


        *fChangeSize = TRUE;
        }
        break;

    case VT_MULTIINDIRECTIONS:
        attr.MustSize = TRUE;
        attr.MustFree = TRUE;
        PushShort(*((short *) &attr));

        PushShort(_stackSize);
        _stackSize += sizeof(REGISTER_TYPE);

        // top level double pointers should be FC_RP FC_ALLOCED_ON_STACK|DEREF
        // we have to change the type format string here because RegisterType
        // doesn't know if the ** is in top level or embedded
        hr = _pTypeGen->RegisterType(parainfo, &offset, &ProcMemInfo);
        if (SUCCEEDED(hr))
            {
            hr = _pTypeGen->AdjustTopLevelRef(offset);
            }
        if (SUCCEEDED(hr))
            {
            PushShort(offset);
            }
        break;

    default:
        {
        if(vt & VT_ARRAY)
            {
            attr.MustSize = TRUE;
            attr.MustFree = TRUE;

            if(vt & VT_BYREF)
                {
                attr.IsSimpleRef = TRUE;
                if(!attr.IsIn)
                    {
                    attr.ServerAllocSize = 1;
                    }
                }
            else
                {
                attr.IsByValue = TRUE;
                }

            PushShort(*((short *) &attr));

            PushShort(_stackSize);
            _stackSize += sizeof(REGISTER_TYPE);

            hr = _pTypeGen->RegisterType(parainfo, &offset, &ProcMemInfo );
            PushShort(offset);
            }
        else
            {
            if (vt & VT_VECTOR)
                {
                NDR_ASSERT(0, "VT_VECTOR is not supported");
                }
            hr = DISP_E_BADVARTYPE;
            }
            break;
        }// end default
    }


    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CProcGen::IsHomogeneous
//
//  Synopsis:   Determine if a type is a homogeneous floating point type
//
//  Parameter:  pFormat     -- The type info string
//              fc          -- FC_FLOAT or FC_DOUBLE
//
//  Returns:    true if the type is a homogeneous type of the specified
//              FC_FLOAT or FC_DOUBLE
//
//  Notes:      Base types are homogeneous.  Structs are homogeneous if each
//              member is homogeneous.
//
//----------------------------------------------------------------------------
#if defined(__RPC_WIN64__)
bool CProcGen::IsHomogeneous(PFORMAT_STRING pFormat, FORMAT_CHARACTER fc)
{
    switch (*pFormat)
    {
    case FC_FLOAT:
    case FC_DOUBLE:
        return ( *pFormat == fc );

    case FC_STRUCT:
        return IsHomogeneousMemberLayout(pFormat + 4, fc);

    case FC_BOGUS_STRUCT:
        return IsHomogeneousMemberLayout(pFormat + 8, fc);

    }

    return false;
}
#endif // __RPC_WIN64__


//+---------------------------------------------------------------------------
//
//  Method:     CProcGen::IsHomogeneousMemberLayout
//
//  Synopsis:   Determine if a member layout is homogeneous
//
//  Parameter:  pFormat     -- The type info string
//              fc          -- FC_FLOAT or FC_DOUBLE
//
//  Returns:    true if the type is a homogeneous layout of the specified
//              FC_FLOAT or FC_DOUBLE
//
//  Notes:      Base types are homogeneous.  Structs are homogeneous if each
//              member is homogeneous.
//
//----------------------------------------------------------------------------
#if defined(__RPC_WIN64__)
bool CProcGen::IsHomogeneousMemberLayout(PFORMAT_STRING pFormat, FORMAT_CHARACTER fc)
{
    while (*pFormat != FC_END)
    {
        switch (*pFormat)
        {           
        case FC_FLOAT:
        case FC_DOUBLE:
            if ( *pFormat != fc )
                return false;

            ++pFormat;
            break;

        case FC_EMBEDDED_COMPLEX:
            pFormat += 2;
            if ( !IsHomogeneous( pFormat + *(short UNALIGNED  *)pFormat, fc ) )
                return false;

            pFormat += 2;
            break;

        case FC_PAD:
            pFormat += 1;
            break;

        default:
            return false;
        }
    }

    return true;
}
#endif __RPC_WIN64__



//+---------------------------------------------------------------------------
//
//  Method:     CProcGen::AnalyzeFloatTypes
//
//  Synopsis:   Analyse a type to see if it is a homogeneous floating point
//              type and adjust the floating point mask accordingly.
//
//  Parameter:  ParamOffset -- Offset of the param from the stack top
//              offset      -- The offset into the type string of the type
//
//----------------------------------------------------------------------------
#if defined(__RPC_WIN64__)
void CProcGen::AnalyzeFloatTypes(USHORT ParamOffset, USHORT offset)
{
    enum FloatType
    {
        NonFloat    = 0,
        Single      = 1,
        Double      = 2,
        DualSingle  = 3
    }
    type;

    PFORMAT_STRING pFormat = _pTypeGen->GetFormatString() + offset;

    bool issingle = IsHomogeneous(pFormat, FC_FLOAT);
    bool isdouble = IsHomogeneous(pFormat, FC_DOUBLE);

    if ( issingle || isdouble )
    {
        ULONG   paramSlot = ParamOffset /= sizeof(REGISTER_TYPE);
        long    members;

        if ( FC_FLOAT == *pFormat || FC_DOUBLE == *pFormat )
            members = 1;
        else
            members = _pTypeGen->GetStructSize() / ( isdouble ? 8 : 4 );
        
        while (members > 0 && _usFloatSlots < 8 && paramSlot < 8)
        {
            if ( isdouble )
                type = Double;
            else if ( members > 1 && _usFloatSlots < 7 )
                type = DualSingle;
            else
                type = Single;
            
            _usFloatArgMask |= type << (paramSlot * 2);

            paramSlot     += 1;
            members       -= 1 + (DualSingle == type);
            _usFloatSlots += 1 + (DualSingle == type);
        }
    }
}
#endif // __RPC_WIN64__


HRESULT CProcGen::PushByte(
    IN  byte b)
{
    BYTE *pb = (BYTE *) &_pProcFormatString[_offset];

    *pb = b;

    _offset += sizeof(b);

    return S_OK;
}

HRESULT CProcGen::PushShort(
    IN  USHORT s)
{
    short UNALIGNED *ps = (UNALIGNED short*)&_pProcFormatString[_offset];

    *ps = s;

    _offset += sizeof(s);

    return S_OK;
}

HRESULT CProcGen::PushLong(
    IN  ULONG s)
{
    long UNALIGNED *ps = (UNALIGNED long*)&_pProcFormatString[_offset];

    *ps = s;

    _offset += sizeof(s);

    return S_OK;
}


HRESULT CProcGen::SetShort(
    IN  USHORT offset,
    IN  USHORT data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *((UNALIGNED short *) &_pProcFormatString[offset]) = data;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::CTypeGen
//
//  Synopsis:   Constructor for type generator.
//
//----------------------------------------------------------------------------
CTypeGen::CTypeGen()
{
    Init();
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::Init
//
//  Synopsis:   Initialize the type generator.
//
//----------------------------------------------------------------------------
void CTypeGen::Init()
{
    _pTypeFormat = __MIDL_TypeFormatString.Format;

    _cbTypeFormat = TYPE_FORMAT_STRING_SIZE;

    //The _offset must be aligned on a 4 byte boundary.
    //Note that this may result in _offset > _cbTypeFormat.
    _offset = (TYPE_FORMAT_STRING_SIZE + 3) & ~3;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::~CTypeGen
//
//  Synopsis:   Destructor for type generator.
//
//----------------------------------------------------------------------------
CTypeGen::~CTypeGen()
{
    ReleaseTypeFormatString(_pTypeFormat);
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::GetTypeFormatString
//
//  Synopsis:   Get the MIDL_TYPE_FORMAT_STRING.
//
//  Arguments:  ppTypeFormatString - Returns a pointer to the type format
//                                   string.
//
//              pLength - Returns the length of the format string.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::GetTypeFormatString(
    OUT PFORMAT_STRING * ppTypeFormatString,
    OUT USHORT         * pLength)
{
    HRESULT hr = S_OK;

    *ppTypeFormatString = _pTypeFormat;

    if(_offset < _cbTypeFormat)
    {
        *pLength = _offset;
    }
    else
    {
        *pLength = _cbTypeFormat;
    }

    //Clear the type format string.
    Init();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::UpdateStructInfo
//
//  Synopsis:   Update the memory information of the specified vt type. 
//
//  Arguments:  uPackingLevel: packing level specified by tlb. Same as /Zp setting in MIDL
//                  packing level is the maximum alignment  in memory. It doesn't affect wire format but
//                  it could force a structure to be bogus.
//
//
//----------------------------------------------------------------------------
void
CTypeGen::UpdateStructInfo( MemoryInfo *pStructInfo, 
                                                          VARTYPE vtnoref,
                                                          long IsRef,
                                                          ushort uPackingLevel )
{
    MemoryInfo const*pInfo;
    if ( IsRef )
        pInfo = &VarMemInfo[VT_PTR];
    else
        pInfo = &VarMemInfo[vtnoref];

    pStructInfo->MemorySize = pInfo->MemorySize;
    if ( pInfo->MemoryAlignment > uPackingLevel )
        pStructInfo->MemoryAlignment = uPackingLevel;
    else
        pStructInfo->MemoryAlignment = pInfo->MemoryAlignment;
    pStructInfo->WireAlignment = pInfo->WireAlignment;
    pStructInfo->WireSize = pInfo->WireSize;    
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterType
//
//  Synopsis:   Registers a top-level type in the type format string.
//
//  Arguments:  pTypeDesc - Supplies the type descriptor.
//              pOffset - Returns the offset in the type format string.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterType(
    IN  PARAMINFO * parainfo,
    OUT USHORT    * pOffset,
    OUT MemoryInfo     * pStructInfo)
{
    HRESULT hr = S_OK;
    VARTYPE vt = parainfo->vt;
    VARTYPE vtnoref = vt & (~VT_BYREF);
    long IsRef = (vt & VT_BYREF) ? 1 : 0;
    
    IID *piid = &(parainfo->iid);
    USHORT uPackingLevel = parainfo->cbAlignment;

    // we don't support vector; vt_array is safearray, treated separately
    if ( vt & (VT_ARRAY | VT_VECTOR | VT_RESERVED ) )
    {
        if(vt & VT_ARRAY)
        {
            hr = RegisterSafeArray(parainfo, pOffset);
        }
        else
        {
            hr = DISP_E_BADVARTYPE;
        }
        vtnoref = VT_SAFEARRAY;
        if ( SUCCEEDED(hr ) )
            {
            // safearray is pointer.
            UpdateStructInfo( pStructInfo, VT_SAFEARRAY,  FALSE , uPackingLevel );
            }
        return hr;
     }

    // it's at the end and we can't folk this into the offset array.
    if ( vt == VT_MULTIINDIRECTIONS )
        {
        // realvt is already VT_BYREF | something.
        // in multiple indirections case, we generate multiple
        // FC_UP FC_POINTER_DEREF. It'll be fixed up if it's
        // top level parameter.
        parainfo->vt = parainfo->realvt;
        ASSERT(parainfo->vt != VT_MULTIINDIRECTIONS);
        hr = RegisterType( parainfo,pOffset, pStructInfo );
        parainfo->vt = VT_MULTIINDIRECTIONS;
        vtnoref = parainfo->realvt;

        if (SUCCEEDED(hr))
            {
            USHORT tmpOffset = *pOffset;
            USHORT prevOffset;
            ASSERT(parainfo->lLevelCount > 0);

            for (LONG i = 0; i < parainfo->lLevelCount; i++ )
                {
                prevOffset = _offset;
                PushByte(FC_UP);
                PushByte(FC_POINTER_DEREF);
                PushOffset(tmpOffset);
                tmpOffset = prevOffset;
                }
            *pOffset = prevOffset;
            //  this is multiple indirection case, it's a pointer.
            UpdateStructInfo( pStructInfo, VT_PTR, TRUE, uPackingLevel );
            }
        }
    else
        {
        *pOffset = OffsetArray[vtnoref][IsRef];   
        UpdateStructInfo( pStructInfo, vtnoref, IsRef, uPackingLevel );

        // take care of special cases and invalid cases.
        if ( *pOffset == 0xffff )
            {
            switch ( vtnoref )
                {
                case VT_INTERFACE:
                    hr = RegisterInterfacePointer(parainfo, pOffset);
                    break;

                case VT_USERDEFINED:
                    hr = RegisterUDT(parainfo, pOffset, pStructInfo);
                    break;

                case VT_I8:
                case VT_UI8:
                case VT_CY:
                    if ( IsRef )
                    {
                        *pOffset = _offset;
                        PushByte(FC_UP);
                        PushByte(FC_SIMPLE_POINTER);
                        PushByte(FC_HYPER);
                        PushByte(FC_PAD);
                    }
                    break;

                case VT_CARRAY:
                    hr = RegisterCArray(parainfo,pOffset,pStructInfo);
                    break;
                default:
                    NDR_ASSERT(0, "invalid vartype");
                    hr = DISP_E_BADVARTYPE;
                }
            }        
        }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterInterfacePointer
//
//  Synopsis:   Register an interface pointer in the type format string.
//
//  Arguments:  riid - Supplies the IID of the interface.
//              pOffset - Returns the type offset of the interface pointer.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterInterfacePointer(
    IN  PARAMINFO* parainfo,
    OUT USHORT    *pOffset)
{
    HRESULT hr = E_FAIL;
    USHORT  offset;
    VARTYPE vt = parainfo->vt;
    IID* piid = &(parainfo->iid);

    offset = _offset;
    hr = PushByte(FC_IP);
    if(FAILED(hr))
        return hr;

    hr = PushByte(FC_CONSTANT_IID);
    if(FAILED(hr))
        return hr;

    hr = PushIID(*piid);
    if(FAILED(hr))
        return hr;

    if(vt & VT_BYREF)
    {
        *pOffset = _offset;
        hr = PushByte(FC_RP);
        if(FAILED(hr))
            return hr;

        hr = PushByte(FC_POINTER_DEREF);
        if(FAILED(hr))
            return hr;

        hr = PushOffset(offset);
    }
    else
    {
        *pOffset = offset;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterCArray
//
//  Synopsis:   generate format string for a fixed size array. 
//
//  Arguments:  pTypeDesc - Supplies the type descriptor.
//              pOffset - Returns the offset in the type format string.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterCArray(
    IN  PARAMINFO* parainfo,
    OUT USHORT   *pOffset,
    OUT MemoryInfo *pStructInfo)
{
    HRESULT hr = S_OK;
    ARRAYDESC *padesc = parainfo->pArray;
    VARTYPE vt = padesc->tdescElem.vt;
    ULONG ulCount=1;
    USHORT WireAlignment = 0,ussize = 0,offset;
    BYTE fcElem,fcStruct;
    PARAMINFO iteminfo;
    USHORT uPackingLevel = parainfo->cbAlignment;
    MemoryInfo MemInfo;

    for ( int i = 0; i < padesc->cDims; i++)
        ulCount *= padesc->rgbounds[i].cElements ;

    memset( &MemInfo, 0, sizeof( MemoryInfo ) );
    if ( vt > VT_VERSIONED_STREAM )
        {
        NDR_ASSERT(0, "invalid c-array type");
        hr = DISP_E_BADVARTYPE;
        goto Error;
        }

    
    fcElem = VT_FC_MAP[vt];
    MemInfo = VarMemInfo[vt];
    // for simple types, wire size is the same as memory size;
    // for complex data, it's bogus array and the value here is irrelavant.

    // take care of special case here.
    if ( fcElem == FC_ZERO )
        {
        switch (vt)
            {
            case VT_USERDEFINED:
            case VT_INTERFACE:
            case VT_PTR:
            case VT_CARRAY:
            // we need some more information other than vt type.
                {
                ITypeInfo* pTempInfo = parainfo->pTypeInfo;
                fcElem = FC_EMBEDDED_COMPLEX;
                hr = VarVtOfTypeDesc(parainfo->pTypeInfo,&(padesc->tdescElem),&iteminfo);
                if (SUCCEEDED(hr))
                {
                    hr = RegisterType(&iteminfo,&offset,&MemInfo);
                     // it's a bogus array if wire size is diffrent from memorysize
                }
                if (FAILED(hr))
                    goto Error;
                }
                if ( offset == 0 )
                    {
                    fcElem = VT_FC_MAP[iteminfo.vt];
                    }
                break;
            default:
                hr = DISP_E_BADVARTYPE;
                goto Error;
            }
        }
    else
        if ( fcElem == FC_EMBEDDED_COMPLEX )
            {
            iteminfo.vt = vt;
            hr = RegisterType(&iteminfo,&offset, &MemInfo);
            if (FAILED(hr))
                goto Error;
            }

    ussize = MemInfo.MemorySize;
    WireAlignment = MemInfo.WireAlignment;
    *pOffset = _offset;
    // simple array. ulCount is the total size(same for wire & mem)
    if (fcElem != FC_EMBEDDED_COMPLEX)
    {
        ulCount *= ussize;
        if (ulCount <= _UI16_MAX)
        {
            PushByte(FC_SMFARRAY);
            PushByte((BYTE)WireAlignment);
            PushShort((SHORT)ulCount);
            PushByte(fcElem);
        }
        else
        {
            PushByte(FC_LGFARRAY);
            PushByte((BYTE)WireAlignment);
            PushLong(ulCount);
            PushByte(fcElem);
        }
    }
    else
    {
        hr = GetByte(offset,&fcStruct);
        if (FAILED(hr))
            goto Error;
        switch (fcStruct)
        {
        case FC_STRUCT:
            ulCount *= ussize;
            if ( ulCount <= _UI16_MAX )
                {
                PushByte(FC_SMFARRAY);
                PushByte((BYTE)WireAlignment);
                PushShort((SHORT)ulCount);     // total size
                PushByte(FC_EMBEDDED_COMPLEX);
                PushByte(0);
                PushOffset(offset);
                PushByte(FC_PAD);
                }
            else
                {
                PushByte(FC_LGFARRAY);
                PushByte((BYTE)WireAlignment);
                PushLong(ulCount);     // total size
                PushByte(FC_EMBEDDED_COMPLEX);
                PushByte(0);
                PushOffset(offset);
                PushByte(FC_PAD);
                }
            break;

        // FC_EMBEDDED_COMPLEX-FC_UP within a complex array
        // should be the same as FC_BOGUSY_ARRAY-FC_UP directly
        case FC_UP:
        case FC_RP:
            {
            byte fctmp,bflag;
            USHORT tmpoffset;

            PushByte(FC_BOGUS_ARRAY);
            PushByte((BYTE)WireAlignment);
            PushShort((SHORT)ulCount); // this is the count
            PushLong(0xffffffff);   // no conformance description
#if defined(__RPC_WIN64__)
            PushShort(0);           // 6 bytes description in /robust
#endif
            PushLong(0xffffffff);   // no variance description
#if defined(__RPC_WIN64__)
            PushShort(0);
#endif
            GetByte(offset, &fctmp);
            PushByte(fctmp);
            GetByte(offset+1, &bflag);
            PushByte(bflag);
            GetOffset(offset+2, &tmpoffset);
            PushOffset(tmpoffset);
            PushByte(FC_PAD);
            ulCount *= PTR_MEM_SIZE;
            break;
            }

        case FC_BOGUS_STRUCT:
        case FC_USER_MARSHAL:
        case FC_IP:
            PushByte(FC_BOGUS_ARRAY);
            PushByte((BYTE)WireAlignment);
            PushShort((SHORT)ulCount); // this is the count
            PushLong(0xffffffff);   // no conformance description
#if defined(__RPC_WIN64__)
            PushShort(0);
#endif
            PushLong(0xffffffff);   // no variance description
#if defined(__RPC_WIN64__)
            PushShort(0);       // correlation description
#endif
            PushByte(FC_EMBEDDED_COMPLEX);
            PushByte(0);        // the first element
            PushOffset(offset);
            PushByte(FC_PAD);
            ulCount *= ussize;
            break;
        default:
            hr = DISP_E_BADVARTYPE;
        }

    }
    PushByte(FC_END);

    if (parainfo->vt & VT_BYREF)
    {
        USHORT uTemp = _offset;
        PushByte(FC_UP);
        PushByte(0);
        PushOffset(*pOffset);
        *pOffset = uTemp;
        UpdateStructInfo(pStructInfo, vt, TRUE, uPackingLevel);  // isbyref
    }
    else
    {
        UpdateStructInfo( pStructInfo, vt, FALSE,  uPackingLevel);   // not byref
        // special case for larger array. make sure structures
        // embedding a big array would be rejected
        if (ulCount > _UI16_MAX)
            ulCount = _UI16_MAX;
        pStructInfo->MemorySize = (USHORT)ulCount;
        pStructInfo->WireSize = (USHORT)ulCount;
    }

Error:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterUDT
//
//  Synopsis:   Register a user defined type in the type format string.
//
//  Arguments:  pParamInfo  - Supplies the user defined type.
//              pOffset     - Returns the type offset of the struct.
//              pStructInfo - HIWORD is alignment, LOWORD is size.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterUDT(
    IN  PARAMINFO * pParamInfo,
    OUT USHORT    * pOffset,
    OUT MemoryInfo     * pStructInfo)
{
    HRESULT     hr;
    TYPEATTR  * pTypeAttr;
    PARAMINFO   paramInfo;
    ITypeInfo * pTypeInfo = pParamInfo->pTypeInfo;

    *pOffset = 0;

    hr = pTypeInfo->lpVtbl->GetTypeAttr(pTypeInfo,
                                        &pTypeAttr);
    if(SUCCEEDED(hr))
    {
        pParamInfo->cbAlignment = pTypeAttr->cbAlignment -1;

        switch(pTypeAttr->typekind)
        {
        case TKIND_RECORD:
            hr = RegisterStruct(pParamInfo, pOffset, pStructInfo);
            NDR_ASSERT( pStructInfo->MemorySize != 0, "struct size can't be 0");
            break;

        case TKIND_ALIAS:
            hr = VarVtOfTypeDesc(pTypeInfo, &pTypeAttr->tdescAlias, &paramInfo);
            if(SUCCEEDED(hr))
            {
                hr = RegisterType(&paramInfo, pOffset, pStructInfo);
                NDR_ASSERT( pStructInfo->MemorySize != 0, "data size can't be 0");
            }
            if (FAILED(hr))
                break;
            if (0 == *pOffset)
            // this is an aliases to a simple type. We should just pass the vt type back
            {
                pParamInfo->vt = paramInfo.vt;
            }
            break;

        case TKIND_DISPATCH:
        case TKIND_INTERFACE:
            hr = VarVtOfIface(pTypeInfo, pTypeAttr, &paramInfo);
            if(SUCCEEDED(hr))
            {
                hr = RegisterType(&paramInfo, pOffset, pStructInfo);
            }
            break;

        case TKIND_ENUM:
            pParamInfo->vt = VT_I4;
            *pOffset = 0;
            UpdateStructInfo( pStructInfo, VT_I4, FALSE , pParamInfo->cbAlignment);
            break;

        case TKIND_MODULE:
        case TKIND_COCLASS:
        case TKIND_UNION:
        default:
            hr = DISP_E_BADVARTYPE;
            break;
        }
    }
    pTypeInfo->lpVtbl->ReleaseTypeAttr(pTypeInfo,pTypeAttr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterStruct
//
//  Synopsis:   Register an user defined struct in the type format string.
//
//  Arguments:  riid - Supplies the ITypeInfo for that struct.
//              pOffset - Returns the type offset of the struct.
//              pStructInfo: HIWORD is alignment, LOWORD is size.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterStruct(
    IN PARAMINFO * parainfo,
    OUT USHORT   * pOffset,
    OUT MemoryInfo    * pStructInfo)
{
    HRESULT hr = S_OK;
    TYPEATTR *pTypeAttr;
    VARDESC  **ppVarDesc;
    ITypeInfo* pInfo = parainfo->pTypeInfo;
    VARTYPE vt = parainfo->vt;
    FORMAT_CHARACTER fcStruct = FC_STRUCT;
    BYTE fcTemp;
    USHORT *poffsets;
    MemoryInfo *pFieldInfos;
    USHORT uPacklingLevel;
    int i = 0;

    hr = pInfo->lpVtbl->GetTypeAttr(pInfo,&pTypeAttr);
    if (FAILED(hr))
        return hr;

    *pOffset = 0;

    uPacklingLevel = parainfo->cbAlignment;
    poffsets = (USHORT *)alloca(pTypeAttr->cVars * sizeof(USHORT));
    memset(poffsets,0,pTypeAttr->cVars * sizeof(USHORT));
    pFieldInfos = (MemoryInfo *)alloca(pTypeAttr->cVars * sizeof(MemoryInfo));
    memset(pFieldInfos,0,pTypeAttr->cVars * sizeof(MemoryInfo));
    ppVarDesc = (VARDESC **)alloca(pTypeAttr->cVars * sizeof(VARDESC *));
    memset(ppVarDesc,0,pTypeAttr->cVars * sizeof(VARDESC *));


    for(i = 0; SUCCEEDED(hr) && i < pTypeAttr->cVars; i++)
    {
        hr = pInfo->lpVtbl->GetVarDesc(pInfo,i, &ppVarDesc[i]);
        if(SUCCEEDED(hr))
        {
            VARKIND varkind = ppVarDesc[i]->varkind;
            PARAMINFO iteminfo;
            iteminfo.cbAlignment = pTypeAttr->cbAlignment - 1;
            BOOL IsRef;  

            switch (varkind)
            {
                case VAR_PERINSTANCE:
                    iteminfo.wIDLFlags = parainfo->wIDLFlags;
                    iteminfo.vt = ppVarDesc[i]->elemdescVar.tdesc.vt;
                    IsRef = iteminfo.vt & VT_BYREF;

                    switch (iteminfo.vt  & ~VT_BYREF)
                    {
                    case VT_USERDEFINED:
                        ITypeInfo *pTempTI;
                        hr = pInfo->lpVtbl->GetRefTypeInfo(pInfo,ppVarDesc[i]->elemdescVar.tdesc.hreftype, &pTempTI);
                        if (FAILED(hr))
                            goto Error;
                        iteminfo.pTypeInfo = pTempTI;
                        hr = RegisterUDT(&iteminfo,&poffsets[i],&pFieldInfos[i]);
                        if (FAILED(hr))
                            goto Error;

                        if (0 == poffsets[i])
                        // the UDT in fact is a simple type (alias or TKIND_ENUM). pass the type back
                        // this is a hack. If the member is typedef->typedef<>...tkind_enum, it's effectively a 
                        // simple type, and we bring the real type up here to be used in Parse & PushStruct.
                        {
                            ppVarDesc[i]->elemdescVar.tdesc.vt = iteminfo.vt;
                            UpdateStructInfo( &pFieldInfos[i], iteminfo.vt,  IsRef, uPacklingLevel);
                        }
                        break;

                    // special case: the top level parameter case is treated differently
                    case VT_DECIMAL:
                        if ( IsRef )
                        {
                            poffsets[i] = BYREF_DECIMAL_TYPE_FS_OFFSET ;
                        }                            
                        else
                        {
                            poffsets[i] = DECIMAL_TYPE_FS_OFFSET;
                        }
                        UpdateStructInfo(&pFieldInfos[i], VT_DECIMAL, IsRef, uPacklingLevel);
                        break;
                     case VT_LPSTR:
                        if (IsRef)
                        {
                            poffsets[i] = BYREF_LPSTR_TYPE_FS_OFFSET ;
                        }
                        else
                        {
                            poffsets[i] = EMBEDDED_LPSTR_TYPE_FS_OFFSET ;
                        }
                        UpdateStructInfo(&pFieldInfos[i], VT_LPSTR, IsRef, uPacklingLevel);
                        break;
                     case VT_LPWSTR:
                        if ( IsRef )
                        {
                            poffsets[i] = BYREF_LPWSTR_TYPE_FS_OFFSET ;
                         }
                        else
                        {
                            poffsets[i] = EMBEDDED_LPWSTR_TYPE_FS_OFFSET ;
                        }
                        UpdateStructInfo(&pFieldInfos[i], VT_LPWSTR, IsRef, uPacklingLevel);
                        break;

                    // doesn't need special case
                    case VT_FILETIME:
                    //  all the following are user marshalls.

                     case VT_DISPATCH:
                     case VT_UNKNOWN:
                     case VT_INTERFACE:
                     case VT_STREAM:
                     case VT_STORAGE:
                     case VT_BSTR:
                     case VT_VARIANT:
                        hr = RegisterType(&iteminfo,&(poffsets[i]),&(pFieldInfos[i]));
                        if (FAILED(hr))
                            goto Error;
                        break;


                     case VT_PTR:
                     case VT_SAFEARRAY:     // 13129
                     {
                        PARAMINFO ptrInfo;
                        hr = VarVtOfTypeDesc(pInfo,&(ppVarDesc[i]->elemdescVar.tdesc),&ptrInfo);
                        if (SUCCEEDED(hr))
                            hr = RegisterType(&ptrInfo,&(poffsets[i]),&(pFieldInfos[i]));
                        if (FAILED(hr))
                            goto Error;
                        // these are really pointers.
                        UpdateStructInfo(&pFieldInfos[i], iteminfo.vt, IsRef, uPacklingLevel);
                     }
                        break;


                     case VT_CARRAY:
                        iteminfo.pArray = ppVarDesc[i]->elemdescVar.tdesc.lpadesc;
                        iteminfo.pTypeInfo = parainfo->pTypeInfo;
                        iteminfo.pTypeInfo->lpVtbl->AddRef(iteminfo.pTypeInfo);
                        iteminfo.vt = ppVarDesc[i]->elemdescVar.tdesc.vt;
                        hr = RegisterCArray(&iteminfo,&poffsets[i],&pFieldInfos[i]);
                        if (FAILED(hr))
                            goto Error;
                        break;

                    }

                    // this member is not a simple type.
                    // we could have some optimization here but for now we just 
                    // generate complex struct.
                    if (poffsets[i])
                    {
                        hr = GetByte(poffsets[i],&fcTemp);
                        if (FAILED(hr))
                            return hr;

                        switch (fcTemp)
                        {
                        case FC_PSTRUCT:
                        case FC_CSTRUCT:
                        case FC_CVSTRUCT:
                            hr = DISP_E_BADVARTYPE;
                            break;
                        case FC_STRUCT:
                        case FC_BOGUS_STRUCT:
                        case FC_USER_MARSHAL:
                        case FC_LGFARRAY:
                        case FC_SMFARRAY:
                        case FC_BOGUS_ARRAY:
                        case FC_IP:
                        case FC_UP:
                        case FC_OP:
                        case FC_RP:
                            fcStruct = FC_BOGUS_STRUCT;
                            break;
                        default:    
                            NDR_ASSERT(0, "invalid struct type");
                            fcStruct = FC_BOGUS_STRUCT;
                        break;
                        }
                    }
                break;

                default:    // all other types shouldn't happen .

                    hr = DISP_E_BADVARTYPE;
                break;
            }
        }
        else
            goto Error;
    }
    if (FAILED(hr))
        goto Error;

    hr = PushStruct(parainfo,fcStruct,ppVarDesc,poffsets,pFieldInfos,pTypeAttr->cVars,pOffset,pStructInfo);

Error:
    for (int j = 0; j < pTypeAttr->cVars ; j++)
        if (ppVarDesc[j])
            pInfo->lpVtbl->ReleaseVarDesc(pInfo,ppVarDesc[j]);

    pInfo->lpVtbl->ReleaseTypeAttr(pInfo,pTypeAttr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::PushStruct
//
//  Synopsis:   This should be part of RegisterStruct, seperate them just because
//              the function is too long.
//
//  Arguments:  parainfo - parameter information.
//              fcStruct - type of struct.
//              ppVarDesc - variable description, if applicable.
//              poffsets  - offset of embedded complex members.
//              pdwStructInfo - size/pad of embedded complex members.
//              uNumElement     - number of members in the struct.
//              pOffset - Returns the type offset of the struct.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::PushStruct(
    IN PARAMINFO *parainfo,
    IN FORMAT_CHARACTER fcStruct,
    IN VARDESC **ppVarDesc,
    IN USHORT *poffsets,
    IN MemoryInfo * pFieldInfos,
    IN USHORT uNumElements,
    OUT USHORT *pOffset,
    OUT MemoryInfo *pStructInfo)
{
    HRESULT hr = S_OK;
    USHORT  uStartoffset;
    USHORT uMemorySize = 0,maxMemoryAlignment=0;
    USHORT FieldMemoryAlignment = 0;
    USHORT structpad;
    int i;
    VARTYPE vt = parainfo->vt;
    boolean fHasPointer = FALSE;
    USHORT uPackingLevel = parainfo->cbAlignment;

    _uStructSize = 0;

    // sizing pass, find out the size of the struct and check if we need to convert struct into bogus struct.
    hr = ParseStructMembers(parainfo,&fcStruct,ppVarDesc,poffsets,pFieldInfos,uNumElements,pStructInfo);

    if (FAILED(hr))
        return hr;

    uStartoffset = _offset;   // the starting point of this struct.
    _uStructSize = 0;

    PushByte(fcStruct);
    PushByte((BYTE)pStructInfo->WireAlignment);
    PushShort(pStructInfo->MemorySize);

    switch (fcStruct)
    {
    case FC_STRUCT:
    break;

    case FC_CSTRUCT:
    case FC_PSTRUCT:
    case FC_CVSTRUCT:
        hr = E_NOTIMPL;
    break;

    case FC_BOGUS_STRUCT:
        PushShort(0);   // offset to array. E_NOTIMPLE;
        PushShort(0);   // offset to pointer layout.
    break;

    default:
    hr = DISP_E_BADVARTYPE;
    break;

    }
    if (FAILED(hr))
        return hr;

    for (i = 0; i < uNumElements; i++)
    {
        if (poffsets[i] > 0)
        {
            // The struct member is an embedded complex, the descsriptor of which
            // is already generated.
            NDR_ASSERT( pFieldInfos[i].MemorySize > 0, "MemoryInfo should have been initialized");
            USHORT uPrevSize;
            BYTE fcTemp;

            // we need to find the offset to know if we have pointers. 
            // we could do that through the typelib directly though.
            hr = GetByte(poffsets[i],&fcTemp);
            if (FAILED(hr))
                return hr;

            if ( pFieldInfos[i].MemoryAlignment > uPackingLevel )
                FieldMemoryAlignment = uPackingLevel;
            else
                FieldMemoryAlignment = pFieldInfos[i].MemoryAlignment;
            uMemorySize = pFieldInfos[i].MemorySize;

            if (fcTemp == FC_UP || fcTemp == FC_RP || fcTemp == FC_OP )
            {
                FieldMemoryAlignment = Alignment( PTR_MEM_ALIGN, uPackingLevel );
                PushByte(FC_POINTER);
                fHasPointer = TRUE;
                _uStructSize += PTR_MEM_SIZE;
                NDR_ASSERT( uMemorySize == PTR_MEM_SIZE, "invalid pointer size");
            }
            else
            {
                PushByte(FC_EMBEDDED_COMPLEX);
                // push the padding required the previous field and
                // following FC_EMBEDDED_COMPLEX
                uPrevSize = (SHORT )_uStructSize;
                LENGTH_ALIGN( _uStructSize, FieldMemoryAlignment);
                PushByte( (BYTE)( _uStructSize - uPrevSize ) );
                PushOffset(poffsets[i]);
                _uStructSize += uMemorySize;  // size of the struct
            }
        }
        else
        {
            hr = GenStructSimpleTypesFormatString(parainfo,ppVarDesc[i],&FieldMemoryAlignment);
            if (FAILED(hr))
                return hr;
        }
        if ( FieldMemoryAlignment > maxMemoryAlignment  )
            maxMemoryAlignment = FieldMemoryAlignment;

    }
    structpad = (USHORT)_uStructSize & maxMemoryAlignment;
    if (structpad )
    {
        structpad = maxMemoryAlignment - structpad;
        hr = PushByte((BYTE)FC_STRUCTPAD1 + structpad) ;
        if (FAILED(hr))
            return hr;
    }

    if (!((_offset - uStartoffset) & 1))
    {
        hr = PushByte(FC_PAD);
        if (FAILED(hr))
            return hr;
    }

    PushByte(FC_END);

    // one level of indirection if it's a pointer
    if (fHasPointer)
    {
        USHORT tempOffset, tempAddr;
        BYTE fcTemp,fcType;
        tempOffset = uStartoffset + 2*sizeof(BYTE) + 2*sizeof(SHORT);

        SetShort(tempOffset,_offset-tempOffset);
        for (i = 0 ; i < uNumElements; i++)
        {
            if (poffsets[i] > 0)
            {
                hr = GetByte(poffsets[i],&fcTemp);
                hr = GetByte(poffsets[i] + 1, &fcType);
                if (FAILED(hr))
                    return hr;
                if (fcTemp == FC_UP || fcTemp == FC_RP || fcTemp == FC_OP )
                {
                   // should really be FC_OP here!!!
                   // MIDL generate FC_OP for [out] and [in,out] param.
                   // We can always generate FC_OP here: the engine behave differently
                   // only on unmarshaling in client side, and force no buffer reuse on
                   // server side, but even we set the flag on [in] only parameter,
                   // unmarshall routine is not called on the client side so it doesn't matter.
                   PushByte(FC_UP);
                   PushByte(fcType);
                   if (FC_SIMPLE_POINTER == fcType)
                   {
                       GetByte(poffsets[i] + 2 * sizeof(BYTE), &fcTemp);
                       PushByte(fcTemp);
                       PushByte(FC_PAD);
                   }
                   else
                   {
                       GetOffset(poffsets[i] + 2*sizeof(BYTE) , &tempAddr);
                       PushOffset(tempAddr);
                   }
                }
            }
        }
    }
    if (vt & VT_BYREF)
    {
        *pOffset = _offset;
        PushByte(FC_UP);
        PushByte(0);
        PushOffset(uStartoffset);
    }
    else
        *pOffset = uStartoffset;

    if (_offset & 2)    // align the starting point of next struct to 4 byte boundary.
        PushShort(0);

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::ParseStructMembers
//
//  Synopsis:   basically sizing pass of the struct, check if we need to convert
//              struct into bogus struct when we can't memcpy the buffer.
//
//  Arguments:  parainfo - parameter information.
//              pfcStruct - type of struct.
//              ppVarDesc - variable description, if applicable.
//              poffsets  - offset of embedded complex members.
//              pdwStructInfo - size/pad of embedded complex members.
//              uNumElement     - number of members in the struct.
//              pStructInfo - return the struct info.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::ParseStructMembers(
    IN PARAMINFO *parainfo,
    IN OUT FORMAT_CHARACTER *pfcStruct,
    IN VARDESC **ppVarDesc,
    IN USHORT *poffsets,
    IN MemoryInfo *pFieldInfos,
    IN USHORT uNumElements,
    OUT MemoryInfo *pStructInfo)
{
    USHORT uStartoffset = 0;
    BOOL fChangeToBogus = FALSE;
    int i;
    USHORT FieldMemoryAlignment = 0, MaxWireAlignment = 0, MaxMemoryAlignment = 0;
    HRESULT hr = S_OK ;
    USHORT uPacklingLevel = parainfo->cbAlignment;

    memset( pStructInfo, 0, sizeof( MemoryInfo ) );

    for (i = 0; i < uNumElements; i++)
    {
        // this is simple type. Let's fill in the memory/size info.
        if ( pFieldInfos[i].MemorySize == 0 )
            {
            NDR_ASSERT( poffsets[i] == 0 , "invalid simple type format string offset");
            hr = GetMemoryInfoForSimpleType(ppVarDesc[i]->elemdescVar.tdesc.vt,
                                                      &pFieldInfos[i]);
            if (FAILED(hr))
                return hr;
            }

        NDR_ASSERT( pFieldInfos[i].MemorySize != 0, "invalid field information");
        if ( pFieldInfos[i].MemoryAlignment > uPacklingLevel )
            {
            // need to change to bogus struct if the struct is not naturally aligned.
            FieldMemoryAlignment = uPacklingLevel;
            fChangeToBogus = TRUE;
            }
        else
            FieldMemoryAlignment = pFieldInfos[i].MemoryAlignment;

        // wire alignment is put on the format string only.
        if ( pFieldInfos[i].WireAlignment > MaxWireAlignment )
            MaxWireAlignment = pFieldInfos[i].WireAlignment ;

        if ( FieldMemoryAlignment > MaxMemoryAlignment )
            MaxMemoryAlignment = FieldMemoryAlignment;

        LENGTH_ALIGN( _uStructSize, FieldMemoryAlignment );
            _uStructSize += pFieldInfos[i].MemorySize;  // size of the struct
    }

    if ((USHORT)_uStructSize & MaxMemoryAlignment )
    {
        // it's a bogus struct if we have trailing padding.
        fChangeToBogus = TRUE;
        *pfcStruct = FC_BOGUS_STRUCT;
    }

    LENGTH_ALIGN( _uStructSize, MaxMemoryAlignment );

    // we are returning the real size of struct up. In the type format generating code,
    // embedded pointer size is always PTR_MEM_SIZE and the sizing info returned from here
    // is ignored.
    pStructInfo->MemorySize = (USHORT)_uStructSize;
    pStructInfo->MemoryAlignment = MaxMemoryAlignment;
    pStructInfo->WireAlignment = MaxWireAlignment;
    NDR_ASSERT( _uStructSize != 0, "invalid struct size");

    if (_uStructSize > _UI16_MAX)
    {
        hr = DISP_E_BADVARTYPE;
    }

    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::GetMemoryInfoForSimpleType
//
//  Synopsis:   Fill in the memory and wire size information for simple types
//
//  Arguments:  vt - what's the simple type.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::GetMemoryInfoForSimpleType(VARTYPE vt,
        MemoryInfo *pSimpleTypeInfo)
{
    HRESULT hr = S_OK;
    VARTYPE vtnoref = vt & ~VT_BYREF;
    if ( vt > VT_VERSIONED_STREAM )
        {
        NDR_ASSERT( 0, "invalid vartype" );
        hr = DISP_E_BADVARTYPE;
        }

    *pSimpleTypeInfo = VarMemInfo[vtnoref];
    if ( pSimpleTypeInfo->WireSize == 0 )
        {
        NDR_ASSERT(0, "invalid vartype" );
        hr = DISP_E_BADVARTYPE;
        }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::RegisterSafeArray
//
//  Synopsis:   Register a safe array in the type format string.
//
//  Arguments:  riid - Supplies the IID of the interface.
//              pOffset - Returns the type offset of the safe array.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::RegisterSafeArray(
          IN PARAMINFO* pParainfo,
          OUT USHORT    *pOffset)
{
    HRESULT hr = S_OK;
    USHORT  offset;
    VARTYPE vt = pParainfo->vt;
    IID *piid = &(pParainfo->iid);

    switch(vt & ~(VT_ARRAY | VT_BYREF))
    {
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_DISPATCH:
    case VT_ERROR:
    case VT_BOOL:
    case VT_VARIANT:
    case VT_UNKNOWN:
    case VT_DECIMAL:
    case VT_I1:
    case VT_UI1:
    case VT_UI2:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_INT:
    case VT_UINT:
    case VT_USERDEFINED:    // 13129
    case VT_CARRAY:
        //This is actually an LPSAFEARRAY pSafeArray.
        if(vt & VT_BYREF)
        {
            *pOffset = BYREF_SAFEARRAY_TYPE_FS_OFFSET ;
        }
        else
        {
            *pOffset = SAFEARRAY_TYPE_FS_OFFSET ;
        }
        break;

    case VT_INTERFACE:
        offset = _offset;
        hr = PushByte(FC_USER_MARSHAL);
        if(FAILED(hr))
            return hr;

        hr = PushByte(USER_MARSHAL_UNIQUE | USER_MARSHAL_IID | 3);
        if(FAILED(hr))
            return hr;

        hr = PushShort(2);
        if(FAILED(hr))
            return hr;

        hr = PushShort(4);
        if(FAILED(hr))
            return hr;

        hr = PushShort(0);
        if(FAILED(hr))
            return hr;

        // yongqu: this offset doesn't really matter. In NdrpInitUserMarshalCB,
        // pReserve is set to offset+10, pointing to the iid directly. In safearrayunmarshal,
        // the iid is read from usermarshalinfo->pReserve. So this short value is never read
        hr = PushOffset(SAFEARRAY_TYPE_FS_OFFSET); //LPSAFEARRAY * type offset
        if(FAILED(hr))
            return hr;

        hr = PushIID(*piid);
        if(FAILED(hr))
            return hr;

        *pOffset = offset;
        break;

    default:
        hr = DISP_E_BADVARTYPE;
        break;
    }


    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::GenStructFormatString
//
//  Synopsis:   generate type format string for a simple type member of a struct.
//
//  Arguments:  parainfo - parameter information
//                              pVarDesc - variable description.
//              pOffset - Returns the type offset of the safe array.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::GenStructSimpleTypesFormatString(
        IN PARAMINFO *parainfo,
        IN VARDESC *pVarDesc,
        OUT USHORT *TypeMemoryAlignment)
{
    VARTYPE vtnoref = pVarDesc->elemdescVar.tdesc.vt & ~VT_BYREF;
    HRESULT hr = S_OK;
    NDR_ASSERT( vtnoref <= VT_VERSIONED_STREAM, "invalid vt");
    if ( vtnoref > VT_VERSIONED_STREAM )
        return DISP_E_BADVARTYPE;

    BYTE FcElement = VT_FC_MAP[vtnoref];
    *TypeMemoryAlignment = Alignment( VarMemInfo[vtnoref].MemoryAlignment, parainfo->cbAlignment );
    PushByte( FcElement);
    _uStructSize += VarMemInfo[vtnoref].MemorySize;

    NDR_ASSERT( VarMemInfo[vtnoref].WireSize != 0, "invalid simple vartype");
    if ( VarMemInfo[vtnoref].WireSize == 0 )

        hr = DISP_E_BADVARTYPE;

    return hr;

}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::AdjustTopLevelRef
//
//  Synopsis:   Adjust the top level multiple level pointer to
//              FC_RP FC_ALLOCED_ON_STACK|FC_POINTER_DEREF
//
//  Arguments:  dwReq - basic alignment requirement of the member.
//              dwMax - the alignment requirement of the struct.
//
//----------------------------------------------------------------------------
HRESULT CTypeGen::AdjustTopLevelRef(USHORT offset)
{
    HRESULT hr;
    hr = SetByte(offset,FC_RP);
    if (SUCCEEDED(hr))
        hr = SetByte(offset+1, FC_ALLOCED_ON_STACK|FC_POINTER_DEREF);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeGen::Alignment
//
//  Synopsis:   get the alignment info of a type and push FC_ALIGN when required.
//
//  Arguments:  dwReq - basic alignment requirement of the member.
//              dwMax - the alignment requirement of the struct.
//
//----------------------------------------------------------------------------
USHORT CTypeGen::Alignment(DWORD dwReq,DWORD dwMax)
{
    USHORT TypeAlignment = (USHORT)(dwReq > dwMax ? dwMax : dwReq);

    if (_uStructSize & TypeAlignment)
    {
        LENGTH_ALIGN( _uStructSize, TypeAlignment );
        switch (TypeAlignment)
        {
        case 1:
            PushByte(FC_ALIGNM2);
            break;
        case 3:
            PushByte(FC_ALIGNM4);
            break;
        case 7:
            PushByte(FC_ALIGNM8);
            break;
        }
    }
    return TypeAlignment;
}

HRESULT CTypeGen::GrowTypeFormat(
    USHORT cb)
{
    HRESULT hr = S_OK;

    //Check if we need to grow the type format string.
    if((_offset + cb) >= _cbTypeFormat)
    {
        void  *pTemp;
        USHORT cbTemp;

        cbTemp = _cbTypeFormat * 2;
        pTemp = I_RpcAllocate(cbTemp);
        if(pTemp != NULL)
        {
            //copy the memory
            memcpy(pTemp, _pTypeFormat, _cbTypeFormat);

            //free the old memory
            if(_pTypeFormat != __MIDL_TypeFormatString.Format)
            {
                I_RpcFree((void *) _pTypeFormat);
            }

            _pTypeFormat = (PFORMAT_STRING) pTemp;
            _cbTypeFormat = cbTemp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CTypeGen::PushByte(
    IN  byte b)
{
    HRESULT hr;

    hr = GrowTypeFormat(sizeof(b));
    if(SUCCEEDED(hr))
    {
        *((BYTE *) &_pTypeFormat[_offset]) = b;
        _offset += sizeof(b);
    }

    return hr;
}

HRESULT CTypeGen::PushShort(
    IN  USHORT s)
{
    HRESULT hr;

    hr = GrowTypeFormat(sizeof(s));
    if(SUCCEEDED(hr))
    {
        *((UNALIGNED short *) &_pTypeFormat[_offset]) = s;
        _offset += sizeof(s);
    }

    return hr;
}

HRESULT CTypeGen::PushLong(
    IN  ULONG s)
{
    HRESULT hr;

    hr = GrowTypeFormat(sizeof(s));
    if(SUCCEEDED(hr))
    {
        *((UNALIGNED long *) &_pTypeFormat[_offset]) = s;
        _offset += sizeof(s);
    }

    return hr;
}

HRESULT CTypeGen::PushOffset(
    IN  USHORT offset)
{
    HRESULT hr;

    hr = PushShort(offset - _offset);
    return hr;
}


HRESULT CTypeGen::PushIID(
    IN  IID iid)
{
    HRESULT hr;

    hr = GrowTypeFormat(sizeof(IID));
    if(SUCCEEDED(hr))
    {
        memcpy((void *)&_pTypeFormat[_offset], &iid, sizeof(IID));
        _offset += sizeof(IID);
    }

    return hr;
}

HRESULT CTypeGen::SetShort(
    IN  USHORT offset,
    IN  USHORT data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *((UNALIGNED short *) &_pTypeFormat[offset]) = data;
    return S_OK;
}

HRESULT CTypeGen::SetByte(
    IN  USHORT offset,
    IN  BYTE data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *((BYTE *) &_pTypeFormat[offset]) = data;
    return S_OK;
}

HRESULT CTypeGen::GetShort(
    IN  USHORT offset,
    OUT  USHORT* data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *data = *((UNALIGNED short*)&_pTypeFormat[offset]);
    return S_OK;
}

HRESULT CTypeGen::GetOffset(
    IN USHORT addr,
    OUT USHORT* poffset)
{
    USHORT delta;
    HRESULT hr;

    hr = GetShort(addr,&delta);
    if (FAILED(hr))
        return hr;
    *poffset = addr + (SHORT) delta;
//  hr = GetShort(addr + (SHORT)delta,poffset);
    return hr;
}


HRESULT CTypeGen::GetByte(
    IN  USHORT offset,
    OUT  BYTE* data)
{
    if (offset >=  _offset)
        return E_INVALIDARG;

    *data = *((BYTE *) &_pTypeFormat[offset]);
    return S_OK;
}


ULONG __RPC_USER
BSTR_UserSize(ULONG * pFlags, ULONG Offset, BSTR * pBstr)

{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[0].pfnBufferSize)(pFlags, Offset, pBstr);
}

BYTE * __RPC_USER
BSTR_UserMarshal (ULONG * pFlags, BYTE * pBuffer, BSTR * pBstr)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[0].pfnMarshall)(pFlags, pBuffer, pBstr);
}

BYTE * __RPC_USER
BSTR_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, BSTR * pBstr)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[0].pfnUnmarshall)(pFlags, pBuffer, pBstr);
}

void __RPC_USER
BSTR_UserFree(ULONG * pFlags, BSTR * pBstr)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    (UserMarshalRoutines[0].pfnFree)(pFlags, pBstr);
}

ULONG __RPC_USER
VARIANT_UserSize(ULONG * pFlags, ULONG Offset, VARIANT * pVariant)

{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[1].pfnBufferSize)(pFlags, Offset, pVariant);
}

BYTE * __RPC_USER
VARIANT_UserMarshal (ULONG * pFlags, BYTE * pBuffer, VARIANT * pVariant)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[1].pfnMarshall)(pFlags, pBuffer, pVariant);
}

BYTE * __RPC_USER
VARIANT_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, VARIANT * pVariant)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (UserMarshalRoutines[1].pfnUnmarshall)(pFlags, pBuffer, pVariant);
}

void __RPC_USER
VARIANT_UserFree(ULONG * pFlags, VARIANT * pVariant)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    (UserMarshalRoutines[1].pfnFree)(pFlags, pVariant);
}

ULONG __RPC_USER
LPSAFEARRAY_UserSize(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray)

{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (pfnLPSAFEARRAY_UserSize)(pFlags, Offset, ppSafeArray);
}

BYTE * __RPC_USER
LPSAFEARRAY_UserMarshal (ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (pfnLPSAFEARRAY_UserMarshal)(pFlags, pBuffer, ppSafeArray);
}

BYTE * __RPC_USER
LPSAFEARRAY_UserUnmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    return (pfnLPSAFEARRAY_UserUnmarshal)(pFlags, pBuffer, ppSafeArray);
}

void __RPC_USER
LPSAFEARRAY_UserFree(ULONG * pFlags, LPSAFEARRAY * ppSafeArray)
{
    HRESULT hr;

    hr = NdrLoadOleAutomationRoutines();

    if(FAILED(hr))
        RpcRaiseException(hr);

    (UserMarshalRoutines[2].pfnFree)(pFlags, ppSafeArray);
}


ULONG __RPC_USER
LPSAFEARRAY_Size(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray, const IID *piid)
{
    HINSTANCE h;
    void * pfnTemp;

    //Load oleaut32.dll
    if(0 == hOleAut32)
    {
        h = LoadLibraryA("OLEAUT32");

        if(h != 0)
        {
            hOleAut32 = h;
        }
        else
        {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_Size");
    if(pfnTemp != 0)
    {
        pfnLPSAFEARRAY_Size = (PFNSAFEARRAY_SIZE) pfnTemp;
    }
    else
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    return (pfnLPSAFEARRAY_Size)(pFlags, Offset, ppSafeArray, piid);
}

BYTE * __RPC_USER
LPSAFEARRAY_Marshal (ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray, const IID *piid)
{
    HINSTANCE h;
    void * pfnTemp;

    //Load oleaut32.dll
    if(0 == hOleAut32)
    {
        h = LoadLibraryA("OLEAUT32");

        if(h != 0)
        {
            hOleAut32 = h;
        }
        else
        {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_Marshal");
    if(pfnTemp != 0)
    {
        pfnLPSAFEARRAY_Marshal = (PFNSAFEARRAY_MARSHAL) pfnTemp;
    }
    else
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    return (pfnLPSAFEARRAY_Marshal)(pFlags, pBuffer, ppSafeArray, piid);
}

BYTE * __RPC_USER
LPSAFEARRAY_Unmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray, const IID *piid)
{
    HINSTANCE h;
    void * pfnTemp;

    //Load oleaut32.dll
    if(0 == hOleAut32)
    {
        h = LoadLibraryA("OLEAUT32");

        if(h != 0)
        {
            hOleAut32 = h;
        }
        else
        {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_Unmarshal");
    if(pfnTemp != 0)
    {
        pfnLPSAFEARRAY_Unmarshal = (PFNSAFEARRAY_UNMARSHAL) pfnTemp;
    }
    else
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }
    return (pfnLPSAFEARRAY_Unmarshal)(pFlags, pBuffer, ppSafeArray, piid);
}

PFNSAFEARRAY_SIZE      pfnLPSAFEARRAY_Size      = LPSAFEARRAY_Size;
PFNSAFEARRAY_MARSHAL   pfnLPSAFEARRAY_Marshal   = LPSAFEARRAY_Marshal;
PFNSAFEARRAY_UNMARSHAL pfnLPSAFEARRAY_Unmarshal = LPSAFEARRAY_Unmarshal;

ULONG __RPC_USER
SafeArraySize(ULONG * pFlags, ULONG Offset, LPSAFEARRAY * ppSafeArray)

{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;

    if(pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (pfnLPSAFEARRAY_Size)(pFlags, Offset, ppSafeArray, &iid);
    }
    else
    {
        return (pfnLPSAFEARRAY_UserSize)(pFlags, Offset, ppSafeArray);
    }
}

BYTE * __RPC_USER
SafeArrayMarshal (ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;

    if(pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (pfnLPSAFEARRAY_Marshal)(pFlags, pBuffer, ppSafeArray, &iid);
    }
    else
    {
        return (pfnLPSAFEARRAY_UserMarshal)(pFlags, pBuffer, ppSafeArray);
    }
}

BYTE * __RPC_USER
SafeArrayUnmarshal(ULONG * pFlags, BYTE * pBuffer, LPSAFEARRAY * ppSafeArray)
{
    USER_MARSHAL_CB *pUserMarshal = (USER_MARSHAL_CB *) pFlags;

    if(pUserMarshal->pReserve != 0)
    {
        IID iid;
        memcpy(&iid, pUserMarshal->pReserve, sizeof(IID));
        return (pfnLPSAFEARRAY_Unmarshal)(pFlags, pBuffer, ppSafeArray, &iid);
    }
    else
    {
        return (pfnLPSAFEARRAY_UserUnmarshal)(pFlags, pBuffer, ppSafeArray);
    }
}


USER_MARSHAL_SIZING_ROUTINE
pfnLPSAFEARRAY_UserSize = (USER_MARSHAL_SIZING_ROUTINE) LPSAFEARRAY_UserSize;

USER_MARSHAL_MARSHALLING_ROUTINE
pfnLPSAFEARRAY_UserMarshal = (USER_MARSHAL_MARSHALLING_ROUTINE) LPSAFEARRAY_UserMarshal;

USER_MARSHAL_UNMARSHALLING_ROUTINE
pfnLPSAFEARRAY_UserUnmarshal = (USER_MARSHAL_UNMARSHALLING_ROUTINE) LPSAFEARRAY_UserUnmarshal;

USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[3] =
{
    {
        (USER_MARSHAL_SIZING_ROUTINE) BSTR_UserSize,
        (USER_MARSHAL_MARSHALLING_ROUTINE) BSTR_UserMarshal,
        (USER_MARSHAL_UNMARSHALLING_ROUTINE) BSTR_UserUnmarshal,
        (USER_MARSHAL_FREEING_ROUTINE) BSTR_UserFree
    },
    {
        (USER_MARSHAL_SIZING_ROUTINE) VARIANT_UserSize,
        (USER_MARSHAL_MARSHALLING_ROUTINE) VARIANT_UserMarshal,
        (USER_MARSHAL_UNMARSHALLING_ROUTINE) VARIANT_UserUnmarshal,
        (USER_MARSHAL_FREEING_ROUTINE) VARIANT_UserFree
    },
    {
        (USER_MARSHAL_SIZING_ROUTINE) SafeArraySize,
        (USER_MARSHAL_MARSHALLING_ROUTINE) SafeArrayMarshal,
        (USER_MARSHAL_UNMARSHALLING_ROUTINE) SafeArrayUnmarshal,
        (USER_MARSHAL_FREEING_ROUTINE) LPSAFEARRAY_UserFree
    }
};

HRESULT NdrLoadOleAutomationRoutines()
{

    void * pfnTemp;

    //Load oleaut32.dll
    if(hOleAut32 == 0)
    {
        hOleAut32 = LoadLibraryA("OLEAUT32");

        if(0 == hOleAut32)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    pfnTemp = GetProcAddress(hOleAut32, "BSTR_UserSize");
    if(pfnTemp != 0)
        UserMarshalRoutines[0].pfnBufferSize = (USER_MARSHAL_SIZING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "BSTR_UserMarshal");
    if(pfnTemp != 0)
        UserMarshalRoutines[0].pfnMarshall = (USER_MARSHAL_MARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "BSTR_UserUnmarshal");
    if(pfnTemp != 0)
        UserMarshalRoutines[0].pfnUnmarshall = (USER_MARSHAL_UNMARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "BSTR_UserFree");
    if(pfnTemp != 0)
        UserMarshalRoutines[0].pfnFree = (USER_MARSHAL_FREEING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "VARIANT_UserSize");
    if(pfnTemp != 0)
        UserMarshalRoutines[1].pfnBufferSize = (USER_MARSHAL_SIZING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "VARIANT_UserMarshal");
    if(pfnTemp != 0)
        UserMarshalRoutines[1].pfnMarshall = (USER_MARSHAL_MARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "VARIANT_UserUnmarshal");
    if(pfnTemp != 0)
        UserMarshalRoutines[1].pfnUnmarshall = (USER_MARSHAL_UNMARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "VARIANT_UserFree");
    if(pfnTemp != 0)
        UserMarshalRoutines[1].pfnFree = (USER_MARSHAL_FREEING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_UserSize");
    if(pfnTemp != 0)
        pfnLPSAFEARRAY_UserSize = (USER_MARSHAL_SIZING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_UserMarshal");
    if(pfnTemp != 0)
        pfnLPSAFEARRAY_UserMarshal = (USER_MARSHAL_MARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_UserUnmarshal");
    if(pfnTemp != 0)
        pfnLPSAFEARRAY_UserUnmarshal = (USER_MARSHAL_UNMARSHALLING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());


    pfnTemp = GetProcAddress(hOleAut32, "LPSAFEARRAY_UserFree");
    if(pfnTemp != 0)
        UserMarshalRoutines[2].pfnFree = (USER_MARSHAL_FREEING_ROUTINE) pfnTemp;
    else
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\tiutil.cxx ===
// Copyright (c) 1993-2000 Microsoft Corporation

#include <windows.h>
#include <ole2.h>
#include <oleauto.h>
#include <typegen.h>
#include <tiutil.h>
#define ASSERT(x) 
#define UNREACHED 0

//---------------------------------------------------------------------
//                            Utilities
//---------------------------------------------------------------------
/***
*PUBLIC HRESULT GetPrimaryInterface
*Purpose:
*  Given a TypeInfo describing a Coclass, search for and return
*  type TypeInfo that describes that class' primary interface.
*
*Entry:
*  ptinfo = the TypeInfo of the base class.
*
*Exit:
*  return value = HRESULT
*
*  *ptinfoPrimary = the TypeInfo of the primary interface, NULL
*           if the class does not have a primary interface.
*
***********************************************************************/
HRESULT 
GetPrimaryInterface(ITypeInfo *ptinfo, ITypeInfo **pptinfoPri)
{
    BOOL fIsDual;
    TYPEKIND tkind;
    HRESULT hresult;
    HREFTYPE hreftype;
    int impltypeflags;
    TYPEATTR *ptattr;
    unsigned int iImplType, cImplTypes;
    ITypeInfo *ptinfoRef;

    ptinfoRef = NULL;

    IfFailGo(ptinfo->GetTypeAttr(&ptattr), Error);
    cImplTypes = ptattr->cImplTypes;
    tkind = ptattr->typekind;
    ptinfo->ReleaseTypeAttr(ptattr);

    if(tkind != TKIND_COCLASS)
      return E_INVALIDARG;

    // Look for the interface marked [default] and not [source]
    for(iImplType = 0; iImplType < cImplTypes; ++iImplType){
      IfFailGo(ptinfo->GetImplTypeFlags(iImplType, &impltypeflags), Error);
      if(IMPLTYPEFLAG_FDEFAULT  == (impltypeflags & (IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE)))
      {
    // Found It!
    IfFailGo(ptinfo->GetRefTypeOfImplType(iImplType, &hreftype), Error);
    IfFailGo(ptinfo->GetRefTypeInfo(hreftype, &ptinfoRef), Error);

    // If its dual, get the interface portion
        IfFailGo(ptinfoRef->GetTypeAttr(&ptattr), Error);
        fIsDual = (ptattr->wTypeFlags & TYPEFLAG_FDUAL)
           && (ptattr->typekind == TKIND_DISPATCH);
        ptinfoRef->ReleaseTypeAttr(ptattr);

    if (fIsDual) {
      IfFailGo(ptinfoRef->GetRefTypeOfImplType((UINT)-1, &hreftype), Error);
      IfFailGo(ptinfoRef->GetRefTypeInfo(hreftype, pptinfoPri), Error);
      ptinfoRef->Release();
    }
    else {
      *pptinfoPri = ptinfoRef;
    }

    return NOERROR;
      }
    }
    // NotFound
    *pptinfoPri = NULL;
    return NOERROR;

Error:
    if(ptinfoRef != NULL)
      ptinfoRef->Release();
    return hresult;
}

HRESULT 
VarVtOfIface(ITypeInfo FAR* ptinfo,
         TYPEATTR FAR* ptattr,
       PARAMINFO *pPinfo)
{
    HRESULT hresult;

    switch(ptattr->typekind){
    case TKIND_DISPATCH:
      if ((ptattr->wTypeFlags & TYPEFLAG_FDUAL) == 0) {
    // regular (non-dual) dispinterface is just VT_DISPATCH.
    pPinfo->vt = VT_DISPATCH;
    // don't have to set up *pguid, since not VT_INTERFACE
    break;
      }
      // The interface typeinfo version of a dual interface has the same
      // same guid as the dispinterface portion does, hence we can just use
      // the dispinterface guid here.
      /* FALLTHROUGH */

    case TKIND_INTERFACE:
      pPinfo->vt = VT_INTERFACE;
      pPinfo->iid = ptattr->guid;
      break;

    default:
      ASSERT(UNREACHED);
      hresult = DISP_E_BADVARTYPE;
      goto Error;
    }

    hresult = NOERROR;

Error:;
    return hresult;
}

HRESULT 
VarVtOfUDT(ITypeInfo FAR* ptinfo,
       TYPEDESC FAR* ptdesc,
       PARAMINFO *pPinfo)
{
    HRESULT hresult;
    TYPEATTR FAR* ptattrRef;
    ITypeInfo FAR* ptinfoRef;
    BOOLEAN fReleaseAttr = TRUE;

    ASSERT(ptdesc->vt == VT_USERDEFINED);

    ptinfoRef = NULL;
    ptattrRef = NULL;

    IfFailGo(ptinfo->GetRefTypeInfo(ptdesc->hreftype, &ptinfoRef), Error);
    IfFailGo(ptinfoRef->GetTypeAttr(&ptattrRef), Error);

    pPinfo->cbAlignment = ptattrRef->cbAlignment - 1;

    switch (ptattrRef->typekind) {
    case TKIND_ENUM:
      pPinfo->vt = VT_I4;
      hresult = NOERROR;
      break;

    case TKIND_ALIAS:
      hresult = VarVtOfTypeDesc(ptinfoRef,
                &ptattrRef->tdescAlias,
                pPinfo);
      if ((pPinfo->vt & (~VT_BYREF)) == VT_CARRAY)
      {
        if (pPinfo->pArray != NULL && pPinfo->pTypeAttr == NULL)    // immediate upper level
        {
            fReleaseAttr = FALSE;
            pPinfo->pTypeInfo->AddRef();
            pPinfo->pTypeAttr = ptattrRef;
        }
      }
      break;

    case TKIND_DISPATCH:
    case TKIND_INTERFACE:
      hresult = VarVtOfIface(ptinfoRef, ptattrRef, pPinfo);
      break;

    case TKIND_COCLASS:
    { TYPEATTR FAR* ptattrPri;
      ITypeInfo FAR* ptinfoPri;

      if((hresult = GetPrimaryInterface(ptinfoRef, &ptinfoPri)) == NOERROR){
    if((hresult = ptinfoPri->GetTypeAttr(&ptattrPri)) == NOERROR){
      hresult = VarVtOfIface(ptinfoPri, ptattrPri, pPinfo);
      ptinfoPri->ReleaseTypeAttr(ptattrPri);
    }
    ptinfoPri->Release();
      }
    }
      break;

    // this is a struct, handle indiviudal member later.
    case TKIND_RECORD:
        pPinfo->vt= VT_USERDEFINED;
        (*pPinfo).pTypeInfo = ptinfoRef;
        ptinfoRef->AddRef();
        
      break;

    default:
      IfFailGo(DISP_E_BADVARTYPE, Error);
      break;
    }

Error:;
    if(ptinfoRef != NULL){
      if(ptattrRef != NULL && fReleaseAttr)
    ptinfoRef->ReleaseTypeAttr(ptattrRef);
      ptinfoRef->Release();
    }
    return hresult;
}


/***
*PRIVATE HRESULT VarVtOfTypeDesc
*Purpose:
*  Convert the given typeinfo TYPEDESC into a VARTYPE that can be
*  represented in a VARIANT.  For some this is a 1:1 mapping, for
*  others we convert to a (possibly machine dependent, eg VT_INT->VT_I2)
*  base type, and others we cant represent in a VARIANT.
*  
*  Now we are supporting multiple levels of pointer indirection. To support
*  this, we created an internal VT_MULTIINDIRECTIONS. If vt in PARAMINFO is
*  VT_MULTIINDIRECTIONS, the real vt is on PARAMINFO::realvt, and VT_BYREF
*  must be true; additional levels of indirection is saved in PARAMINFO::
*  lLevelCount.
*
*Entry:
*  ptinfo = 
*  ptdesc = * to the typedesc to convert
*  pvt = 
*  pguid = 
*
*Exit:
*  return value = HRESULT
*
*  *pvt = a VARTYPE that may be stored in a VARIANT.
*  *pguid = a guid for a custom interface.
*
*
*  Following is a summary of how types are represented in typeinfo.
*  Note the difference between the apparent levels of indirection
*  between IDispatch* / DispFoo*, and DualFoo*.
*
*  I2		=> VT_I2
*  I2*		=> VT_PTR - VT_I2
*
*  IDispatch *	=> VT_DISPATCH
*  IDispatch **	=> VT_PTR - VT_DISPATCH
*  DispFoo *    => VT_DISPATCH
*  DispFoo **   => VT_PTR - VT_DISPATCH
*  DualFoo *	=> VT_PTR - VT_INTERFACE (DispIID)
*  DualFoo **	=> VT_PTR - VT_PTR - VT_INTERFACE (DispIID)
*  IFoo *	=> VT_PTR - VT_INTERFACE (IID)
*  IFoo **	=> VT_PTR - VT_PTR - VT_INTERFACE (IID)
*
***********************************************************************/
HRESULT 
VarVtOfTypeDesc(ITypeInfo FAR* ptinfo,
        TYPEDESC FAR* ptdesc,
       PARAMINFO *pPinfo)
{
    HRESULT hresult = NOERROR;

    switch (ptdesc->vt) {
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BSTR:
    case VT_DISPATCH:
    case VT_ERROR:
    case VT_BOOL:
    case VT_VARIANT:
    case VT_UNKNOWN:
    case VT_DECIMAL:
    case VT_I1:
    case VT_UI1:
    case VT_UI2:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_HRESULT:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_FILETIME:
    case VT_STREAM:
    case VT_STORAGE:
      pPinfo->vt = ptdesc->vt;
      break;

    case VT_INT:
      pPinfo->vt = VT_I4;
      break;

    case VT_UINT:
      pPinfo->vt = VT_UI4;
      break;
    
    case VT_USERDEFINED:
      hresult = VarVtOfUDT(ptinfo, ptdesc, pPinfo);
      break;

    case VT_PTR:
        switch (ptdesc->lptdesc->vt)
        {
        // VT_PTR + VT_DISPATCH: it's IDispatch**
        case VT_DISPATCH:
        case VT_UNKNOWN:
        case VT_STREAM:
        case VT_STORAGE:
            pPinfo->vt  = ptdesc->lptdesc->vt |VT_BYREF;
            hresult = NOERROR;
            break;

      // Special case: dispinterface** (represented by VT_PTR-VT_PTR-VT_USERDEFINED-TKIND_DISPATCH
        case VT_PTR:
            if ( VT_USERDEFINED == ptdesc->lptdesc->lptdesc->vt )
                {
                // we need to read forward in VT_PTR-VT_PTR-VT_UDT case for 
                // dispinterface **
                hresult = VarVtOfUDT(ptinfo, ptdesc->lptdesc->lptdesc,pPinfo);
                if (hresult == NOERROR)
                    {
                    if (pPinfo->vt == VT_INTERFACE)
                        {
                        pPinfo->vt = (VT_BYREF | VT_INTERFACE);
                        }
                    else if (pPinfo->vt == VT_DISPATCH)
                        {
                        pPinfo->vt = (VT_BYREF | VT_DISPATCH);
                        }
                    else if ( pPinfo->vt == VT_MULTIINDIRECTIONS )
                        {
                        // add an additional level if it's ** already
                        pPinfo->lLevelCount++;
                        }
                    else
                        {
                        // VT_PTR-VT_PTR-something_other_than_interface:
                        pPinfo->realvt = pPinfo->vt;
                        pPinfo->vt = VT_MULTIINDIRECTIONS;
                        if ( pPinfo->realvt & VT_BYREF )
                            pPinfo->lLevelCount = 2;
                        else
                            {
                            pPinfo->realvt = pPinfo->realvt | VT_BYREF;
                            pPinfo->lLevelCount = 1;
                            }
                        }
                    }                    
                break;
                }
         // fall through if not VT_PTR-VT_PTR-VT_USERDEFINED case
        default:
            hresult = VarVtOfTypeDesc(ptinfo, ptdesc->lptdesc, pPinfo);
            if(hresult == NOERROR)
                {
                if(pPinfo->vt & VT_BYREF)
                    {
                    pPinfo->realvt = pPinfo->vt;
                    pPinfo->vt = VT_MULTIINDIRECTIONS;
                    pPinfo->lLevelCount = 1;
                    }
                else if ( pPinfo->vt == VT_MULTIINDIRECTIONS )
                    {
                    pPinfo->lLevelCount++;
                    }
                else if ((pPinfo->vt != VT_INTERFACE) && (pPinfo->vt != VT_DISPATCH))
                    {
                    // need to get rid of one level of indirection for interface
                    pPinfo->vt |= VT_BYREF;
                    }
                break;
                }
        }

            
      
      break;

    case VT_SAFEARRAY:
      hresult = VarVtOfTypeDesc(ptinfo, ptdesc->lptdesc, pPinfo);
      if(hresult == NOERROR){
        if(pPinfo->vt & (VT_BYREF | VT_ARRAY)){
      // error if nested array or array of pointers
        hresult = DISP_E_BADVARTYPE;
        break;
        }
        pPinfo->vt |= VT_ARRAY;
      }
      break;

        // VT_CARRAY in fact is fix length array. 
    case VT_CARRAY: 
        pPinfo->vt = ptdesc->vt;
        (*pPinfo).pArray = ptdesc->lpadesc;
        (*pPinfo).pTypeInfo = ptinfo;
        ptinfo->AddRef();
        break;

    default:
      ASSERT(UNREACHED);
      hresult = DISP_E_BADVARTYPE;
      break;
    }

    return hresult;
}

//
// Simple wrapper for VarVtOfTypeDesc that only returns
// the vt, not an entire PARAMINFO structure.  Used
// by the callframe code in ole32.
//
EXTERN_C
HRESULT NdrpVarVtOfTypeDesc(IN ITypeInfo *pTypeInfo,
							IN TYPEDESC  *ptdesc,
							OUT VARTYPE  *vt)
{
	PARAMINFO pinfo;
	HRESULT hr;

	if (vt == NULL)
		return E_POINTER;

	*vt = VT_EMPTY;

	hr = VarVtOfTypeDesc(pTypeInfo, ptdesc, &pinfo);
	if (SUCCEEDED(hr))
		*vt = pinfo.vt;
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\udt.cxx ===
/*++

Microsoft Windows
Copyright (c) 1997 - 1999 Microsoft Corporation.  All rights reserved.

File:
    udt.cxx

Abstract:
    Marshalling support for user defined data types.

Author:
    ShannonC    21-Apr-1997

Environment:
    Windows NT and Windows 95.  We do not support DOS and Win16.

Revision History:

--*/
#include <ndrp.h>
#include <oaidl.h>
#include <typegen.h>
#include <interp2.h>

extern USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[3];


class CTypeFactory : public ITypeFactory, public IClassFactory
{
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN  REFIID riid,
        OUT void **ppv);

    ULONG   STDMETHODCALLTYPE AddRef();

    ULONG   STDMETHODCALLTYPE Release();

    HRESULT STDMETHODCALLTYPE CreateFromTypeInfo(
        IN  ITypeInfo *pTypeInfo,
        IN  REFIID riid,
        OUT IUnknown **ppv);

    HRESULT STDMETHODCALLTYPE CreateInstance(
        IN  IUnknown * pUnkOuter,
        IN  REFIID     riid,
        OUT void    ** ppv);

    HRESULT STDMETHODCALLTYPE LockServer(
	IN  BOOL fLock);

    CTypeFactory();

private:
    long _cRefs;
};

CLSID CLSID_TypeFactory = { /* b5866878-bd99-11d0-b04b-00c04fd91550 */
    0xb5866878,
    0xbd99,
    0x11d0,
    {0xb0, 0x4b, 0x00, 0xc0, 0x4f, 0xd9, 0x15, 0x50}
  };

class CTypeMarshal : public ITypeMarshal, public IMarshal
{
public:
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface(
        IN  REFIID riid,
        OUT void **ppvObject);

    ULONG   STDMETHODCALLTYPE AddRef();

    ULONG   STDMETHODCALLTYPE Release();

    // ITypeMarshal methods
    HRESULT STDMETHODCALLTYPE Size(
        IN  void *  pType,
        IN  DWORD   dwDestContext,
        IN  void  * pvDestContext,
        OUT ULONG * pSize);

    HRESULT STDMETHODCALLTYPE Marshal(
        IN  void *  pType,
        IN  DWORD   dwDestContext,
        IN  void  * pvDestContext,
        IN  ULONG   cbBufferLength,
        OUT BYTE  * pBuffer,
        OUT ULONG * pcbWritten);

    HRESULT STDMETHODCALLTYPE Unmarshal(
        IN  void   * pType,
        IN  DWORD    dwFlags,
        IN  ULONG    cbBufferLength,
        IN  BYTE   * pBuffer,
        OUT ULONG  * pcbRead);

    HRESULT STDMETHODCALLTYPE Free(
        IN void * pType);

    // IMarshal methods.
    HRESULT STDMETHODCALLTYPE GetUnmarshalClass
    (
        IN  REFIID riid,
        IN  void *pv,
        IN  DWORD dwDestContext,
        IN  void *pvDestContext,
        IN  DWORD mshlflags,
        OUT CLSID *pCid
    );

    HRESULT STDMETHODCALLTYPE GetMarshalSizeMax
    (
        IN  REFIID riid,
        IN  void *pv,
        IN  DWORD dwDestContext,
        IN  void *pvDestContext,
        IN  DWORD mshlflags,
        OUT DWORD *pSize
    );

    HRESULT STDMETHODCALLTYPE MarshalInterface
    (
        IN  IStream *pStm,
        IN  REFIID riid,
        IN  void *pv,
        IN  DWORD dwDestContext,
        IN  void *pvDestContext,
        IN  DWORD mshlflags
    );

    HRESULT STDMETHODCALLTYPE UnmarshalInterface
    (
        IN  IStream *pStm,
        IN  REFIID riid,
        OUT void **ppv
    );

    HRESULT STDMETHODCALLTYPE ReleaseMarshalData
    (
        IN  IStream *pStm
    );

    HRESULT STDMETHODCALLTYPE DisconnectObject
    (
        IN  DWORD dwReserved
    );

    CTypeMarshal(
        IN PFORMAT_STRING pFormatString,
        IN ULONG          length,
        IN ULONG          offset);

private:
    ~CTypeMarshal();

    long           _cRefs;
    ULONG          _offset;
    ULONG          _length;
    PFORMAT_STRING _pFormatString;
    MIDL_STUB_DESC _StubDesc;
};


//+---------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Gets an interface pointer to the specified class object.
//
//  Arguments:  rclsid - CLSID for the class object.
//              riid   - IID for the requested interface
//		[ppv]  - Returns the interface pointer to the class object.
//
//  Returns:   	S_OK
//              CLASS_E_CLASSNOTAVAILABLE
//              E_INVALIDARG
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//----------------------------------------------------------------------------
STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void ** ppv)
{
    HRESULT hr;
    RPC_STATUS rc;

    __try
    {
        *ppv = NULL;

        //Initialize the RPC heap.
        rc = NdrpPerformRpcInitialization();

        if (rc == RPC_S_OK)
        {
            if(rclsid == CLSID_TypeFactory)
            {
                CTypeFactory * pTypeFactory;
    
                pTypeFactory = new CTypeFactory;
                if(pTypeFactory != NULL)
                {
                    hr = pTypeFactory->QueryInterface(riid, ppv);
                    pTypeFactory->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = CLASS_E_CLASSNOTAVAILABLE;
            }
        }
        else
            hr = HRESULT_FROM_WIN32(rc);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::CTypeFactory
//
//  Synopsis:   Constructor for CTypeFactory
//
//----------------------------------------------------------------------------
CTypeFactory::CTypeFactory()
: _cRefs(1)
{
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.
//
//  Arguments:  riid - IID of the requested interface.
//		ppv  - Returns the interface pointer.
//
//  Returns:   	S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeFactory::QueryInterface(
    REFIID riid,
    void **ppv)
{
    HRESULT hr;

    __try
    {
        *ppv = NULL;

        if(IsEqualIID(riid, IID_IUnknown) ||
           IsEqualIID(riid, IID_ITypeFactory))
        {
            AddRef();
            *ppv = (ITypeFactory *) this;
            hr = S_OK;
        }
        else if(IsEqualIID(riid, IID_IClassFactory))
        {
            AddRef();
            *ppv = (IClassFactory *) this;
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//  Notes:      Use InterlockedIncrement to make it multi-thread safe.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CTypeFactory::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::Release
//
//  Synopsis:   Decrement the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//  Notes:      Use InterlockedDecrement to make it multi-thread safe.
//              We use a local variable so that we don't access
//              a data member after decrementing the reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CTypeFactory::Release(void)
{
    ULONG count = _cRefs - 1;

    if(0 == InterlockedDecrement(&_cRefs))
    {
	    delete this;
	    count = 0;
    }

    return count;
}

//+-------------------------------------------------------------------------
//
//  Member:   	CTypeFactory::LockServer
//
//  Synopsis:   Lock the server. Does nothing.
//
//  Arguments:  fLock
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CTypeFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CTypeFactory::CreateInstance
//
//  Synopsis:   Creates a CTypeMarshal.
//
//  Arguments:  [pUnkOuter] - The controlling unknown (for aggregation)
//		[iid]       - The requested interface ID.
//		[ppv]       - Returns the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_NOAGGREGATION
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CTypeFactory::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID     riid, 
    void **    ppv)
{
    HRESULT hr;
    IID     iid;

    __try
    {
        //Parameter validation.
        *ppv = NULL;
        iid = riid;

        if(NULL == pUnkOuter)
        {
            CTypeMarshal *pTypeMarshal = new CTypeMarshal(NULL, 0, 0);
            if(pTypeMarshal != NULL)
            {
                hr = pTypeMarshal->QueryInterface(iid, ppv);
                pTypeMarshal->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            //CTypeMarshal does not support aggregation.
            hr = CLASS_E_NOAGGREGATION;            
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeFactory::CreateFromTypeInfo
//
//  Synopsis:   Create a type marshaller from the typeinfo.
//
//  Arguments:  void
//
//  Returns:    S_OK
//              DISP_E_BADVARTYPE
//              E_INVALIDARG
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CTypeFactory::CreateFromTypeInfo(
    IN  ITypeInfo * pTypeInfo,
    IN  REFIID      riid,
    OUT IUnknown ** ppv)
{
    HRESULT        hr;
    CTypeMarshal * pTypeMarshal;
    PFORMAT_STRING pFormatString;
    USHORT         length;
    USHORT         offset;
    PARAMINFO      paramInfo;
    CTypeGen       *ptypeGen = new CTypeGen;
    MemoryInfo          StructInfo;

    if (NULL == ptypeGen)
        return E_OUTOFMEMORY;

    __try
    {
        *ppv = NULL;

        //Build a type format string from the typeinfo.

        paramInfo.vt = VT_USERDEFINED;
        paramInfo.pTypeInfo = pTypeInfo;
        pTypeInfo->AddRef();

        memset( &StructInfo, 0, sizeof( MemoryInfo )  );
        hr = ptypeGen->RegisterType(&paramInfo,
                                  &offset,
                                  &StructInfo);

        if (SUCCEEDED(hr) && (0 == offset))
        {
            ASSERT( !(paramInfo.vt & VT_BYREF));
            switch (paramInfo.vt)
            {
            case VT_I1:
            case VT_UI1:
                    offset = 734;
                break;

            case VT_I2:
            case VT_UI2:
            case VT_BOOL:
                    offset = 738;
                break;

            case VT_I4:
            case VT_UI4:
            case VT_INT:
            case VT_UINT:
            case VT_ERROR:
            case VT_HRESULT:
                    offset = 742;
                break;

            case VT_I8:
            case VT_UI8:
            case VT_CY:
                    offset = 310;
                break;

            case VT_R4:
                    offset = 746;
                break;

            case VT_R8:
            case VT_DATE:
                    offset = 750;
                break;  
            }
        }
        
        if(SUCCEEDED(hr))
        {
            hr = ptypeGen->GetTypeFormatString(&pFormatString, &length);
            if(SUCCEEDED(hr))
            {
                pTypeMarshal = new CTypeMarshal(pFormatString, length, offset);
                if(pTypeMarshal != NULL)
                {
                    hr = pTypeMarshal->QueryInterface(riid, (void **) ppv);
                    pTypeMarshal->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    ReleaseTypeFormatString(pFormatString);
                }
            }
        }
        delete ptypeGen;    // fix compile warning
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        delete ptypeGen;    // fix compile warning
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::CTypeMarshal
//
//  Synopsis:   Constructor for CTypeMarshal
//
//----------------------------------------------------------------------------
CTypeMarshal::CTypeMarshal(
    IN PFORMAT_STRING pFormatString,
    IN ULONG          length,
    IN ULONG          offset)
: _pFormatString(pFormatString), _length(length), _offset(offset), _cRefs(1)
{
    //Initialize the MIDL_STUB_DESC.
    MIDL_memset(&_StubDesc, 0, sizeof(_StubDesc));
    _StubDesc.pfnAllocate = NdrOleAllocate;
    _StubDesc.pfnFree = NdrOleFree;
    _StubDesc.pFormatTypes = pFormatString;
#if !defined(__RPC_WIN64__)
    _StubDesc.Version = 0x20000; /* Ndr library version */
    _StubDesc.MIDLVersion = MIDL_VERSION_3_0_44;
#else
    _StubDesc.Version = 0x50002; /* Ndr library version */
    _StubDesc.MIDLVersion = MIDL_VERSION_5_2_202;
#endif
    _StubDesc.aUserMarshalQuadruple = UserMarshalRoutines;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::~CTypeMarshal
//
//  Synopsis:   Destructor for CTypeMarshal
//
//----------------------------------------------------------------------------
CTypeMarshal::~CTypeMarshal()
{
    ReleaseTypeFormatString(_pFormatString);
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.
//
//  Arguments:  riid - IID of the requested interface.
//		ppv  - Returns the interface pointer.
//
//  Returns:   	S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::QueryInterface(
    REFIID riid,
    void **ppv)
{
    HRESULT hr;

    __try
    {
        *ppv = NULL;

        if(IsEqualIID(riid, IID_IUnknown) ||
           IsEqualIID(riid, IID_ITypeMarshal))
        {
            AddRef();
            *ppv = (ITypeMarshal *) this;
            hr = S_OK;
        }
        else if (IsEqualIID(riid, IID_IMarshal))
        {
            AddRef();
            *ppv = (IMarshal *) this;
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//  Notes:      Use InterlockedIncrement to make it multi-thread safe.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CTypeMarshal::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Release
//
//  Synopsis:   Decrement the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//  Notes:      Use InterlockedDecrement to make it multi-thread safe.
//              We use a local variable so that we don't access
//              a data member after decrementing the reference count.
//
//----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CTypeMarshal::Release(void)
{
    ULONG count = _cRefs - 1;

    if(0 == InterlockedDecrement(&_cRefs))
    {
	    delete this;
	    count = 0;
    }

    return count;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Size
//
//  Synopsis:   Computes the size of the marshalled data type.
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::Size(
    IN  void *  pType,
    IN  DWORD   dwDestContext,
    IN  void  * pvDestContext,
    OUT ULONG * pSize)
{
    HRESULT           hr = S_OK;
    MIDL_STUB_MESSAGE StubMsg;
    PFORMAT_STRING    pTypeFormat;

    __try
    {
        if(!_pFormatString)
            return E_UNEXPECTED;

        pTypeFormat = _pFormatString + _offset;

        MIDL_memset(&StubMsg, 0, sizeof(StubMsg));
        StubMsg.StubDesc = &_StubDesc;
        StubMsg.pfnFree = NdrOleFree;
        StubMsg.pfnAllocate = NdrOleAllocate;
        StubMsg.IsClient = 1;
        StubMsg.BufferLength = 1; //Reserve space for an alignment gap.
        StubMsg.dwDestContext = dwDestContext;
        StubMsg.pvDestContext = pvDestContext;

        (*pfnSizeRoutines[ROUTINE_INDEX(*pTypeFormat)])(
            &StubMsg,
            (unsigned char *)pType,
            pTypeFormat);

        *pSize = StubMsg.BufferLength - 1;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Marshal
//
//  Synopsis:   Marshals the user-defined type into a buffer.
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::Marshal(
    IN  void *  pType,
    IN  DWORD   dwDestContext,
    IN  void  * pvDestContext,
    IN  ULONG   cbBufferLength,
    OUT BYTE  * pBuffer,
    OUT ULONG * pcbWritten)
{
    HRESULT           hr = S_OK;    
    MIDL_STUB_MESSAGE StubMsg;
    RPC_MESSAGE       RpcMsg;
    PFORMAT_STRING    pTypeFormat;

    __try
    {
        if(!_pFormatString)
            return E_UNEXPECTED;

        pTypeFormat = _pFormatString + _offset;

        MIDL_memset(&StubMsg, 0, sizeof(StubMsg));
        StubMsg.StubDesc = &_StubDesc;
        StubMsg.pfnFree = NdrOleFree;
        StubMsg.pfnAllocate = NdrOleAllocate;
        StubMsg.IsClient = 1;
        StubMsg.dwDestContext = dwDestContext;
        StubMsg.pvDestContext = pvDestContext;
        StubMsg.Buffer = pBuffer;

        MIDL_memset(&RpcMsg, 0, sizeof(RpcMsg));
        RpcMsg.DataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;
        RpcMsg.Buffer = pBuffer;
        RpcMsg.BufferLength = cbBufferLength;
        StubMsg.RpcMsg = &RpcMsg;

        (*pfnMarshallRoutines[ROUTINE_INDEX(*pTypeFormat)])(
            &StubMsg,
            (unsigned char *)pType,
            pTypeFormat);

        *pcbWritten = (ULONG)(StubMsg.Buffer - pBuffer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Unmarshal
//
//  Synopsis:   Unmarshals a user-defined type from a buffer.
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::Unmarshal(
    OUT void   * pType,
    IN  DWORD    dwFlags,
    IN  ULONG    cbBufferLength,
    IN  BYTE   * pBuffer,
    OUT ULONG  * pcbRead)
{
    HRESULT           hr = S_OK;
    MIDL_STUB_MESSAGE StubMsg;
    RPC_MESSAGE       RpcMsg;
    PFORMAT_STRING    pTypeFormat;

    __try
    {
        if(pcbRead)
            *pcbRead = 0;

        if(!_pFormatString)
            return E_UNEXPECTED;

        pTypeFormat = _pFormatString + _offset;
        // HACK! OA might pass in 0xffffffff, which 
        // will break the attack checking in ndr engine.
        // what we do now is mask off the highest byte.
        // This will lead to a 64M limit buffer, but that
        // should be good enough for now.
        cbBufferLength &= 0xffffff;

        MIDL_memset(&StubMsg, 0, sizeof(StubMsg));
        StubMsg.StubDesc = &_StubDesc;
        StubMsg.pfnFree = NdrOleFree;
        StubMsg.pfnAllocate = NdrOleAllocate;
        StubMsg.IsClient = 1;
        StubMsg.dwDestContext = dwFlags & 0x0000FFFF;
        StubMsg.Buffer = pBuffer;
        StubMsg.BufferStart = pBuffer;
        StubMsg.BufferLength = cbBufferLength;
        StubMsg.BufferEnd = pBuffer + cbBufferLength;

        MIDL_memset(&RpcMsg, 0, sizeof(RpcMsg));
        RpcMsg.DataRepresentation = dwFlags >> 16;
        RpcMsg.Buffer = pBuffer;
        RpcMsg.BufferLength = cbBufferLength;
        StubMsg.RpcMsg = &RpcMsg;

        NdrClientZeroOut(&StubMsg,
                         pTypeFormat,
                         (uchar *) pType); 

        //Endianness
        if(RpcMsg.DataRepresentation != NDR_LOCAL_DATA_REPRESENTATION)
        {
            (*pfnConvertRoutines[ROUTINE_INDEX(*pTypeFormat)])(&StubMsg,
                                                               pTypeFormat,
                                                               FALSE);
            StubMsg.Buffer = pBuffer;
        }
        
        //Unmarshal
        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pTypeFormat)])(
            &StubMsg,
            (unsigned char **)&pType,
            pTypeFormat,
            FALSE);

        if(pcbRead)
            *pcbRead = (ULONG)(StubMsg.Buffer - pBuffer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::Free
//
//  Synopsis:   Frees a user-defined type.
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE
CTypeMarshal::Free(
    void * pType)
{
    HRESULT           hr = S_OK;
    MIDL_STUB_MESSAGE StubMsg;
    PFORMAT_STRING    pTypeFormat;

    __try
    {
        if(pType != NULL)
        {
            if(!_pFormatString)
                return E_UNEXPECTED;

            pTypeFormat = _pFormatString + _offset;

            MIDL_memset(&StubMsg, 0, sizeof(StubMsg));
            StubMsg.StubDesc = &_StubDesc;
            StubMsg.pfnFree = NdrOleFree;
            StubMsg.pfnAllocate = NdrOleAllocate;
            StubMsg.IsClient = 1;

            (*pfnFreeRoutines[ROUTINE_INDEX(*pTypeFormat)])(
                 &StubMsg,
                 (unsigned char *)pType,
                 pTypeFormat);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = HRESULT_FROM_WIN32(GetExceptionCode());
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::GetUnmarshalClass
//
//  Synopsis:   Get the class ID.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::GetUnmarshalClass(
    REFIID  riid,
    LPVOID  pv,
    DWORD   dwDestContext,
    LPVOID  pvDestContext,
    DWORD   mshlflags,
    CLSID * pClassID)
{
    HRESULT hr = S_OK;

    __try
    {
        *pClassID = CLSID_TypeFactory;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::GetMarshalSizeMax
//
//  Synopsis:   Get maximum size of marshalled moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::GetMarshalSizeMax(
    REFIID riid,
    LPVOID pv,
    DWORD  dwDestContext,
    LPVOID pvDestContext,
    DWORD  mshlflags,
    DWORD *pSize)
{
    HRESULT hr;

    __try
    {
        *pSize =  sizeof(_offset) + sizeof(_length) + _length;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::MarshalInterface
//
//  Synopsis:   Marshal moniker into a stream.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::MarshalInterface(
    IStream * pStream,
    REFIID    riid,
    void    * pv,
    DWORD     dwDestContext,
    LPVOID    pvDestContext,
    DWORD     mshlflags)
{
    HRESULT hr;
    ULONG cb;

    hr = pStream->Write(&_offset, sizeof(_offset), &cb);
    if(SUCCEEDED(hr))
    {
        hr = pStream->Write(&_length, sizeof(_length), &cb);
        if(SUCCEEDED(hr))
        {
            hr = pStream->Write(_pFormatString, _length, &cb);
        }
    }
   
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::UnmarshalInterface
//
//  Synopsis:   Unmarshal moniker from a stream.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::UnmarshalInterface(
    IStream * pStream,
    REFIID    riid,
    void   ** ppv)
{
    HRESULT hr;
    ULONG   cb;

    __try
    {
        //Validate parameters.
        *ppv = NULL;

        hr = pStream->Read(&_offset, sizeof(_offset), &cb);
        if(SUCCEEDED(hr) && 
           (sizeof(_offset) == cb))
        {
            hr = pStream->Read(&_length, sizeof(_length), &cb);
            if(SUCCEEDED(hr) && 
               (sizeof(_length) == cb))
            {
                _pFormatString = (PFORMAT_STRING) I_RpcAllocate(_length);
                if(_pFormatString != NULL)
                {
                    hr = pStream->Read((void *) _pFormatString, _length, &_length);
                    if(SUCCEEDED(hr))
                    {
                        hr = QueryInterface(riid, ppv);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::ReleaseMarshalData
//
//  Synopsis:   Release a marshalled class moniker.
//              Just seek to the end of the marshalled class moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::ReleaseMarshalData(
    IStream * pStream)
{
    HRESULT hr;
    ULONG   cb;    

    hr = pStream->Read(&_offset, sizeof(_offset), &cb);
    if(SUCCEEDED(hr) && 
       (sizeof(_offset) == cb))
    {
        hr = pStream->Read(&_length, sizeof(_length), &cb);
        if(SUCCEEDED(hr) && 
           (sizeof(_length) == cb))
        {
            LARGE_INTEGER liSize;
 
            liSize.LowPart = _length;
            liSize.HighPart = 0;
            hr = pStream->Seek(liSize, STREAM_SEEK_CUR, NULL);
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CTypeMarshal::DisconnectObject
//
//  Synopsis:   Disconnect the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CTypeMarshal::DisconnectObject(
    DWORD dwReserved)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\unmrshlp.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    unmrshlp.c

Abstract :

    This file contains the routines for unmarshalling an array's or a
    structure's embedded pointers.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"
#include "attack.h"
#include "pointerq.h"


PFORMAT_STRING
NdrpEmbeddedPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    uchar               fNewMemory )
/*++

Routine Description :

    Unmarshalls an array's or a structure's embedded pointers.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure or array whose embedded pointers
                  are being unmarshalled.
    pFormat     - Pointer layout format string description.
    fNewMemory  - TRUE if the array or structure was allocated during
                  unmarshalling, FALSE otherwise.

Return :

    Format string pointer after the pointer layout.

--*/
{
    uchar **        ppMemPtr;
    uchar **        ppBufPtr;
    uchar *         pBufferMark;
    ULONG_PTR       MaxCountSave;
    long            OffsetSave;

    MaxCountSave =  pStubMsg->MaxCount;
    OffsetSave = pStubMsg->Offset;
    pStubMsg->Memory = pMemory;

    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);
    
    // Save BufferMark in a local.
    pBufferMark = pStubMsg->BufferMark;

    // Increment past FC_PP and FC_PAD.
    pFormat += 2;

    for (;;)
        {
        if ( *pFormat == FC_END )
            {
            return pFormat;
            }

        // Check for FC_FIXED_REPEAT or FC_VARIABLE_REPEAT.
        if ( *pFormat != FC_NO_REPEAT )
            {
            pStubMsg->MaxCount = MaxCountSave;
            pStubMsg->Offset = OffsetSave;

            pStubMsg->BufferMark = pBufferMark;

            pFormat = NdrpEmbeddedRepeatPointerUnmarshall( pStubMsg,
                                                           pMemory,
                                                           pFormat,
                                                           fNewMemory );

            // Continue to the next pointer.
            continue;
            }

        // Compute the pointer to the current memory pointer to the data.
        ppMemPtr = (uchar **)( pMemory + *((signed short *)(pFormat + 2)) );

        // Compute the pointer to the pointer in the buffer.
        ppBufPtr = (uchar **)(pBufferMark + *((signed short *)(pFormat + 4)));

        // Increment to the pointer description.
        pFormat += 6;

        //
        // If the incomming encapsulating memory pointer was just allocated,
        // then explicitly null out the current pointer.
        //
        if ( fNewMemory )
            *ppMemPtr = 0;

        NdrpPointerUnmarshall( 
             pStubMsg,
             (uchar**)ppMemPtr, // Memory rep written here
             *ppMemPtr,
             (long *)ppBufPtr,  // Wire rep written here
             pFormat );

        // Increment to the next pointer description.
        pFormat += 4;
        }
}


PFORMAT_STRING
NdrpEmbeddedRepeatPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat,
    uchar               fNewMemory )
/*++

Routine Description :

    Unmarshalls an array's embedded pointers.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array whose embedded pointers are being
                  unmarshalled.
    pFormat     - Pointer layout format string description.
    fNewMemory  - TRUE if the array was allocated during unmarshalling,
                  FALSE otherwise.

Return :

    Format string pointer after the pointer layout.

--*/
{
    uchar **        ppMemPtr;
    uchar **        ppBufPtr;
    PFORMAT_STRING  pFormatSave;
    uchar *         pBufferMark;
    uchar *         pArrayElement;
    ulong           RepeatCount, RepeatIncrement, Pointers, PointersSave;

    CORRELATION_RESOURCE_SAVE;

    SAVE_CORRELATION_MEMORY();

    // Get the beginning of the contained structure in the buffer.
    pBufferMark = pStubMsg->BufferMark;

    // Get the repeat count.
    switch ( *pFormat )
        {
        case FC_FIXED_REPEAT :
            pFormat += 2;

            RepeatCount = *((ushort *)pFormat);

            break;

        case FC_VARIABLE_REPEAT :
            RepeatCount = (ulong)pStubMsg->MaxCount;

            //
            // Check if this variable repeat instance also has a variable
            // offset (this would be the case for a conformant varying array
            // of pointers, or structures which contain pointers).  If so then
            // increment the format string to point to the actual first array
            // element which is being marshalled.
            //
            if ( pFormat[1] == FC_VARIABLE_OFFSET )
                pMemory += *((ushort *)(pFormat + 2)) * pStubMsg->Offset;

            // else pFormat[1] == FC_FIXED_OFFSET - do nothing

            break;

        default :
            NDR_ASSERT(0,"NdrpEmbeddedRepeatPointerUnmarshall : bad format");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    // Increment format string to increment field.
    pFormat += 2;

    // Get the increment amount between successive pointers.
    RepeatIncrement = *((ushort * &)pFormat)++;

    // Load up pointer to first element of embedded array.
    pArrayElement = pBufferMark + *((ushort * &)pFormat)++;

    // Get number of pointers in each array element.
    PointersSave = Pointers = *((ushort * &)pFormat)++;

    pFormatSave = pFormat;

    //
    // Loop over the number of shipped array elements.
    //
    for ( ; RepeatCount--;
            pBufferMark += RepeatIncrement,
            pMemory += RepeatIncrement,
            pArrayElement += RepeatIncrement )
        {
        pFormat = pFormatSave;
        Pointers = PointersSave;

        // Set the correlation check context to be the beginning of each element
        // in the array. This is necessary since other functions will assume that
        // the context points to the top of the flat part of the containing structure.
        // If the containing structure is embedded in another structure, the offset
        // for correlation checks will be relative to the topmost structure.
        pStubMsg->pCorrMemory = pArrayElement;

        //
        // Loop over the number of pointer per array element (which can
        // be greater than one for an array of structures).
        //
        for ( ; Pointers--; )
            {
            // Pointer to the pointer in memory.
            ppMemPtr = (uchar **)(pMemory + *((signed short * &)pFormat)++);

            // Pointer to the pointer's id in the buffer.
            ppBufPtr = (uchar **)(pBufferMark + *((signed short * &)pFormat)++);

            //
            // If the incomming encapsulating memory pointer was just
            // allocated, then explicitly null out the current pointer.
            //
            if ( fNewMemory )
                *ppMemPtr = 0;

            NdrpPointerUnmarshall( 
                pStubMsg,
                (uchar**)ppMemPtr, // Memory rep written here
                *ppMemPtr,
                (long *)ppBufPtr,  // Wire rep written here
                pFormat );

            // Increment past the pointer description.
            pFormat += 4;
            }
        }

    RESET_CORRELATION_MEMORY();

    // Return the format string pointer past the array's pointer description.
    return pFormatSave + PointersSave * 8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\unmrshlp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

	unmrshlp.h

Abtract :

	Contains private definitions for unmrshl.c.

Author :

	David Kays  dkays   September 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _UNMRSHLP_
#define _UNMRSHLP_

void
NdrpPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,       // Where allocated pointer is written
    uchar *             pMemory,
    long  *             pBufferPointer, // Pointer to the wire rep.
    PFORMAT_STRING      pFormat );

void 
NdrpConformantArrayUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						fMustCopy ,
	uchar				              fMustAlloc 
	);

void 
NdrpConformantVaryingArrayUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						fMustCopy,
	uchar				              fMustAlloc 
	);

void 
NdrpComplexArrayUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						fMustCopy,
	uchar				              fMustAlloc 
	);

void 
NdrpConformantStringUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						fMustCopy ,
	uchar				              fMustAlloc 
	);

void 
NdrpUnionUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar **					ppMemory, 
	PFORMAT_STRING				pFormat,
	uchar 						SwitchType,
    PFORMAT_STRING              pNonEncUnion
	);

PFORMAT_STRING
NdrpEmbeddedPointerUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar						fNewMemory
	);

PFORMAT_STRING 
NdrpEmbeddedRepeatPointerUnmarshall( 
	PMIDL_STUB_MESSAGE			pStubMsg, 
	uchar *						pMemory, 
	PFORMAT_STRING				pFormat,
	uchar						fNewMemory
	);

#define FULL_POINTER_INSERT( pStubMsg, Pointer )	\
				{ \
			    NdrFullPointerInsertRefId( pStubMsg->FullPtrXlatTables, \
                                           pStubMsg->FullPtrRefId, \
                                           Pointer ); \
 \
                pStubMsg->FullPtrRefId = 0; \
				}

typedef uchar * (RPC_ENTRY * PUNMARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar **, 
					PFORMAT_STRING,
					uchar 
				);

typedef void  	(* PPRIVATE_UNMARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar **, 
					PFORMAT_STRING,
					uchar,
					uchar
				);

//
// Function table defined in unmrshl.c.
//
IMPORTSPEC
extern const PUNMARSHALL_ROUTINE * pfnUnmarshallRoutines;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\amd64\forward.asm ===
title   "Ndr Proxy Forwarding Functions"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   forward.asm
;
; Abstract:
;
;   This module implements the proxy forwarding functions.
;
; Author:
;
;   David N. Cutler 30-Dec-2000
;
; Environment:
;
;   Any mode.
;
;-

include ksamd64.inc

        subttl  "Delegation Forwarding Functions"
;++
;
; VOID
; NdrProxyForwardingFunction<nnn>(
;    IN IUnknown *This,
;    ...
;    )
;
; Routine Description:
;
;   This function forwards a call to the proxy for the base interface.
;
; Arguments:
;
;   This (rcx) - Supplies a pointer to the interface proxy.
;
; Return Value:
;
;   None.
;
;--

;
; Define macro to generate forwarder functions.
;

subclass_offset equ 32

DELEGATION_FORWARDER macro Method

        LEAF_ENTRY NdrProxyForwardingFunction&Method, _TEXT$00

        mov     rcx, subclass_offset[rcx] ; get subclass object address
        mov     r10, [rcx]              ; get vtable address
        jmp     qword ptr (&Method * 8)[r10] ; transfer to method

        LEAF_END NdrProxyForwardingFunction&Method, _TEXT$00

        endm

;
; Generate forwarder functions.
;

index = 3

        rept    (255 - 3 + 1)

        DELEGATION_FORWARDER %index

index = index + 1

        endm

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\amd64\stblsclt.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    stblsclt.c

Abstract:

    This file contains the routines for support of stubless clients in
    object interfaces.

Author :

    David Kays (dkays) February 1995.

--*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "hndl.h"
#include "interp2.h"
#include "ndrtypes.h"
#include "mulsyntx.h"

#include "ndrole.h"
#include "rpcproxy.h"

#pragma code_seg(".orpc")

CLIENT_CALL_RETURN
RPC_ENTRY
NdrClientCall2 (
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    ...
    );

CLIENT_CALL_RETURN
RPC_ENTRY
NdrDcomAsyncClientCall (
    PMIDL_STUB_DESC pStubDescriptor,
    PFORMAT_STRING pFormat,
    ...
    );

CLIENT_CALL_RETURN
RPC_ENTRY
NdrpClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    );

CLIENT_CALL_RETURN
RPC_ENTRY
NdrpDcomAsyncClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    );

extern "C"
{

long
ObjectStublessClient (
    void *ParamAddress,
    REGISTER_TYPE *FloatRegisters,
    long Method
    );

void ObjectStublessClient3(void);
void ObjectStublessClient4(void);
void ObjectStublessClient5(void);
void ObjectStublessClient6(void);
void ObjectStublessClient7(void);
void ObjectStublessClient8(void);
void ObjectStublessClient9(void);
void ObjectStublessClient10(void);
void ObjectStublessClient11(void);
void ObjectStublessClient12(void);
void ObjectStublessClient13(void);
void ObjectStublessClient14(void);
void ObjectStublessClient15(void);
void ObjectStublessClient16(void);
void ObjectStublessClient17(void);
void ObjectStublessClient18(void);
void ObjectStublessClient19(void);
void ObjectStublessClient20(void);
void ObjectStublessClient21(void);
void ObjectStublessClient22(void);
void ObjectStublessClient23(void);
void ObjectStublessClient24(void);
void ObjectStublessClient25(void);
void ObjectStublessClient26(void);
void ObjectStublessClient27(void);
void ObjectStublessClient28(void);
void ObjectStublessClient29(void);
void ObjectStublessClient30(void);
void ObjectStublessClient31(void);
void ObjectStublessClient32(void);
void ObjectStublessClient33(void);
void ObjectStublessClient34(void);
void ObjectStublessClient35(void);
void ObjectStublessClient36(void);
void ObjectStublessClient37(void);
void ObjectStublessClient38(void);
void ObjectStublessClient39(void);
void ObjectStublessClient40(void);
void ObjectStublessClient41(void);
void ObjectStublessClient42(void);
void ObjectStublessClient43(void);
void ObjectStublessClient44(void);
void ObjectStublessClient45(void);
void ObjectStublessClient46(void);
void ObjectStublessClient47(void);
void ObjectStublessClient48(void);
void ObjectStublessClient49(void);
void ObjectStublessClient50(void);
void ObjectStublessClient51(void);
void ObjectStublessClient52(void);
void ObjectStublessClient53(void);
void ObjectStublessClient54(void);
void ObjectStublessClient55(void);
void ObjectStublessClient56(void);
void ObjectStublessClient57(void);
void ObjectStublessClient58(void);
void ObjectStublessClient59(void);
void ObjectStublessClient60(void);
void ObjectStublessClient61(void);
void ObjectStublessClient62(void);
void ObjectStublessClient63(void);
void ObjectStublessClient64(void);
void ObjectStublessClient65(void);
void ObjectStublessClient66(void);
void ObjectStublessClient67(void);
void ObjectStublessClient68(void);
void ObjectStublessClient69(void);
void ObjectStublessClient70(void);
void ObjectStublessClient71(void);
void ObjectStublessClient72(void);
void ObjectStublessClient73(void);
void ObjectStublessClient74(void);
void ObjectStublessClient75(void);
void ObjectStublessClient76(void);
void ObjectStublessClient77(void);
void ObjectStublessClient78(void);
void ObjectStublessClient79(void);
void ObjectStublessClient80(void);
void ObjectStublessClient81(void);
void ObjectStublessClient82(void);
void ObjectStublessClient83(void);
void ObjectStublessClient84(void);
void ObjectStublessClient85(void);
void ObjectStublessClient86(void);
void ObjectStublessClient87(void);
void ObjectStublessClient88(void);
void ObjectStublessClient89(void);
void ObjectStublessClient90(void);
void ObjectStublessClient91(void);
void ObjectStublessClient92(void);
void ObjectStublessClient93(void);
void ObjectStublessClient94(void);
void ObjectStublessClient95(void);
void ObjectStublessClient96(void);
void ObjectStublessClient97(void);
void ObjectStublessClient98(void);
void ObjectStublessClient99(void);
void ObjectStublessClient100(void);
void ObjectStublessClient101(void);
void ObjectStublessClient102(void);
void ObjectStublessClient103(void);
void ObjectStublessClient104(void);
void ObjectStublessClient105(void);
void ObjectStublessClient106(void);
void ObjectStublessClient107(void);
void ObjectStublessClient108(void);
void ObjectStublessClient109(void);
void ObjectStublessClient110(void);
void ObjectStublessClient111(void);
void ObjectStublessClient112(void);
void ObjectStublessClient113(void);
void ObjectStublessClient114(void);
void ObjectStublessClient115(void);
void ObjectStublessClient116(void);
void ObjectStublessClient117(void);
void ObjectStublessClient118(void);
void ObjectStublessClient119(void);
void ObjectStublessClient120(void);
void ObjectStublessClient121(void);
void ObjectStublessClient122(void);
void ObjectStublessClient123(void);
void ObjectStublessClient124(void);
void ObjectStublessClient125(void);
void ObjectStublessClient126(void);
void ObjectStublessClient127(void);
void ObjectStublessClient128(void);
void ObjectStublessClient129(void);
void ObjectStublessClient130(void);
void ObjectStublessClient131(void);
void ObjectStublessClient132(void);
void ObjectStublessClient133(void);
void ObjectStublessClient134(void);
void ObjectStublessClient135(void);
void ObjectStublessClient136(void);
void ObjectStublessClient137(void);
void ObjectStublessClient138(void);
void ObjectStublessClient139(void);
void ObjectStublessClient140(void);
void ObjectStublessClient141(void);
void ObjectStublessClient142(void);
void ObjectStublessClient143(void);
void ObjectStublessClient144(void);
void ObjectStublessClient145(void);
void ObjectStublessClient146(void);
void ObjectStublessClient147(void);
void ObjectStublessClient148(void);
void ObjectStublessClient149(void);
void ObjectStublessClient150(void);
void ObjectStublessClient151(void);
void ObjectStublessClient152(void);
void ObjectStublessClient153(void);
void ObjectStublessClient154(void);
void ObjectStublessClient155(void);
void ObjectStublessClient156(void);
void ObjectStublessClient157(void);
void ObjectStublessClient158(void);
void ObjectStublessClient159(void);
void ObjectStublessClient160(void);
void ObjectStublessClient161(void);
void ObjectStublessClient162(void);
void ObjectStublessClient163(void);
void ObjectStublessClient164(void);
void ObjectStublessClient165(void);
void ObjectStublessClient166(void);
void ObjectStublessClient167(void);
void ObjectStublessClient168(void);
void ObjectStublessClient169(void);
void ObjectStublessClient170(void);
void ObjectStublessClient171(void);
void ObjectStublessClient172(void);
void ObjectStublessClient173(void);
void ObjectStublessClient174(void);
void ObjectStublessClient175(void);
void ObjectStublessClient176(void);
void ObjectStublessClient177(void);
void ObjectStublessClient178(void);
void ObjectStublessClient179(void);
void ObjectStublessClient180(void);
void ObjectStublessClient181(void);
void ObjectStublessClient182(void);
void ObjectStublessClient183(void);
void ObjectStublessClient184(void);
void ObjectStublessClient185(void);
void ObjectStublessClient186(void);
void ObjectStublessClient187(void);
void ObjectStublessClient188(void);
void ObjectStublessClient189(void);
void ObjectStublessClient190(void);
void ObjectStublessClient191(void);
void ObjectStublessClient192(void);
void ObjectStublessClient193(void);
void ObjectStublessClient194(void);
void ObjectStublessClient195(void);
void ObjectStublessClient196(void);
void ObjectStublessClient197(void);
void ObjectStublessClient198(void);
void ObjectStublessClient199(void);
void ObjectStublessClient200(void);
void ObjectStublessClient201(void);
void ObjectStublessClient202(void);
void ObjectStublessClient203(void);
void ObjectStublessClient204(void);
void ObjectStublessClient205(void);
void ObjectStublessClient206(void);
void ObjectStublessClient207(void);
void ObjectStublessClient208(void);
void ObjectStublessClient209(void);
void ObjectStublessClient210(void);
void ObjectStublessClient211(void);
void ObjectStublessClient212(void);
void ObjectStublessClient213(void);
void ObjectStublessClient214(void);
void ObjectStublessClient215(void);
void ObjectStublessClient216(void);
void ObjectStublessClient217(void);
void ObjectStublessClient218(void);
void ObjectStublessClient219(void);
void ObjectStublessClient220(void);
void ObjectStublessClient221(void);
void ObjectStublessClient222(void);
void ObjectStublessClient223(void);
void ObjectStublessClient224(void);
void ObjectStublessClient225(void);
void ObjectStublessClient226(void);
void ObjectStublessClient227(void);
void ObjectStublessClient228(void);
void ObjectStublessClient229(void);
void ObjectStublessClient230(void);
void ObjectStublessClient231(void);
void ObjectStublessClient232(void);
void ObjectStublessClient233(void);
void ObjectStublessClient234(void);
void ObjectStublessClient235(void);
void ObjectStublessClient236(void);
void ObjectStublessClient237(void);
void ObjectStublessClient238(void);
void ObjectStublessClient239(void);
void ObjectStublessClient240(void);
void ObjectStublessClient241(void);
void ObjectStublessClient242(void);
void ObjectStublessClient243(void);
void ObjectStublessClient244(void);
void ObjectStublessClient245(void);
void ObjectStublessClient246(void);
void ObjectStublessClient247(void);
void ObjectStublessClient248(void);
void ObjectStublessClient249(void);
void ObjectStublessClient250(void);
void ObjectStublessClient251(void);
void ObjectStublessClient252(void);
void ObjectStublessClient253(void);
void ObjectStublessClient254(void);
void ObjectStublessClient255(void);
void ObjectStublessClient256(void);
void ObjectStublessClient257(void);
void ObjectStublessClient258(void);
void ObjectStublessClient259(void);
void ObjectStublessClient260(void);
void ObjectStublessClient261(void);
void ObjectStublessClient262(void);
void ObjectStublessClient263(void);
void ObjectStublessClient264(void);
void ObjectStublessClient265(void);
void ObjectStublessClient266(void);
void ObjectStublessClient267(void);
void ObjectStublessClient268(void);
void ObjectStublessClient269(void);
void ObjectStublessClient270(void);
void ObjectStublessClient271(void);
void ObjectStublessClient272(void);
void ObjectStublessClient273(void);
void ObjectStublessClient274(void);
void ObjectStublessClient275(void);
void ObjectStublessClient276(void);
void ObjectStublessClient277(void);
void ObjectStublessClient278(void);
void ObjectStublessClient279(void);
void ObjectStublessClient280(void);
void ObjectStublessClient281(void);
void ObjectStublessClient282(void);
void ObjectStublessClient283(void);
void ObjectStublessClient284(void);
void ObjectStublessClient285(void);
void ObjectStublessClient286(void);
void ObjectStublessClient287(void);
void ObjectStublessClient288(void);
void ObjectStublessClient289(void);
void ObjectStublessClient290(void);
void ObjectStublessClient291(void);
void ObjectStublessClient292(void);
void ObjectStublessClient293(void);
void ObjectStublessClient294(void);
void ObjectStublessClient295(void);
void ObjectStublessClient296(void);
void ObjectStublessClient297(void);
void ObjectStublessClient298(void);
void ObjectStublessClient299(void);
void ObjectStublessClient300(void);
void ObjectStublessClient301(void);
void ObjectStublessClient302(void);
void ObjectStublessClient303(void);
void ObjectStublessClient304(void);
void ObjectStublessClient305(void);
void ObjectStublessClient306(void);
void ObjectStublessClient307(void);
void ObjectStublessClient308(void);
void ObjectStublessClient309(void);
void ObjectStublessClient310(void);
void ObjectStublessClient311(void);
void ObjectStublessClient312(void);
void ObjectStublessClient313(void);
void ObjectStublessClient314(void);
void ObjectStublessClient315(void);
void ObjectStublessClient316(void);
void ObjectStublessClient317(void);
void ObjectStublessClient318(void);
void ObjectStublessClient319(void);
void ObjectStublessClient320(void);
void ObjectStublessClient321(void);
void ObjectStublessClient322(void);
void ObjectStublessClient323(void);
void ObjectStublessClient324(void);
void ObjectStublessClient325(void);
void ObjectStublessClient326(void);
void ObjectStublessClient327(void);
void ObjectStublessClient328(void);
void ObjectStublessClient329(void);
void ObjectStublessClient330(void);
void ObjectStublessClient331(void);
void ObjectStublessClient332(void);
void ObjectStublessClient333(void);
void ObjectStublessClient334(void);
void ObjectStublessClient335(void);
void ObjectStublessClient336(void);
void ObjectStublessClient337(void);
void ObjectStublessClient338(void);
void ObjectStublessClient339(void);
void ObjectStublessClient340(void);
void ObjectStublessClient341(void);
void ObjectStublessClient342(void);
void ObjectStublessClient343(void);
void ObjectStublessClient344(void);
void ObjectStublessClient345(void);
void ObjectStublessClient346(void);
void ObjectStublessClient347(void);
void ObjectStublessClient348(void);
void ObjectStublessClient349(void);
void ObjectStublessClient350(void);
void ObjectStublessClient351(void);
void ObjectStublessClient352(void);
void ObjectStublessClient353(void);
void ObjectStublessClient354(void);
void ObjectStublessClient355(void);
void ObjectStublessClient356(void);
void ObjectStublessClient357(void);
void ObjectStublessClient358(void);
void ObjectStublessClient359(void);
void ObjectStublessClient360(void);
void ObjectStublessClient361(void);
void ObjectStublessClient362(void);
void ObjectStublessClient363(void);
void ObjectStublessClient364(void);
void ObjectStublessClient365(void);
void ObjectStublessClient366(void);
void ObjectStublessClient367(void);
void ObjectStublessClient368(void);
void ObjectStublessClient369(void);
void ObjectStublessClient370(void);
void ObjectStublessClient371(void);
void ObjectStublessClient372(void);
void ObjectStublessClient373(void);
void ObjectStublessClient374(void);
void ObjectStublessClient375(void);
void ObjectStublessClient376(void);
void ObjectStublessClient377(void);
void ObjectStublessClient378(void);
void ObjectStublessClient379(void);
void ObjectStublessClient380(void);
void ObjectStublessClient381(void);
void ObjectStublessClient382(void);
void ObjectStublessClient383(void);
void ObjectStublessClient384(void);
void ObjectStublessClient385(void);
void ObjectStublessClient386(void);
void ObjectStublessClient387(void);
void ObjectStublessClient388(void);
void ObjectStublessClient389(void);
void ObjectStublessClient390(void);
void ObjectStublessClient391(void);
void ObjectStublessClient392(void);
void ObjectStublessClient393(void);
void ObjectStublessClient394(void);
void ObjectStublessClient395(void);
void ObjectStublessClient396(void);
void ObjectStublessClient397(void);
void ObjectStublessClient398(void);
void ObjectStublessClient399(void);
void ObjectStublessClient400(void);
void ObjectStublessClient401(void);
void ObjectStublessClient402(void);
void ObjectStublessClient403(void);
void ObjectStublessClient404(void);
void ObjectStublessClient405(void);
void ObjectStublessClient406(void);
void ObjectStublessClient407(void);
void ObjectStublessClient408(void);
void ObjectStublessClient409(void);
void ObjectStublessClient410(void);
void ObjectStublessClient411(void);
void ObjectStublessClient412(void);
void ObjectStublessClient413(void);
void ObjectStublessClient414(void);
void ObjectStublessClient415(void);
void ObjectStublessClient416(void);
void ObjectStublessClient417(void);
void ObjectStublessClient418(void);
void ObjectStublessClient419(void);
void ObjectStublessClient420(void);
void ObjectStublessClient421(void);
void ObjectStublessClient422(void);
void ObjectStublessClient423(void);
void ObjectStublessClient424(void);
void ObjectStublessClient425(void);
void ObjectStublessClient426(void);
void ObjectStublessClient427(void);
void ObjectStublessClient428(void);
void ObjectStublessClient429(void);
void ObjectStublessClient430(void);
void ObjectStublessClient431(void);
void ObjectStublessClient432(void);
void ObjectStublessClient433(void);
void ObjectStublessClient434(void);
void ObjectStublessClient435(void);
void ObjectStublessClient436(void);
void ObjectStublessClient437(void);
void ObjectStublessClient438(void);
void ObjectStublessClient439(void);
void ObjectStublessClient440(void);
void ObjectStublessClient441(void);
void ObjectStublessClient442(void);
void ObjectStublessClient443(void);
void ObjectStublessClient444(void);
void ObjectStublessClient445(void);
void ObjectStublessClient446(void);
void ObjectStublessClient447(void);
void ObjectStublessClient448(void);
void ObjectStublessClient449(void);
void ObjectStublessClient450(void);
void ObjectStublessClient451(void);
void ObjectStublessClient452(void);
void ObjectStublessClient453(void);
void ObjectStublessClient454(void);
void ObjectStublessClient455(void);
void ObjectStublessClient456(void);
void ObjectStublessClient457(void);
void ObjectStublessClient458(void);
void ObjectStublessClient459(void);
void ObjectStublessClient460(void);
void ObjectStublessClient461(void);
void ObjectStublessClient462(void);
void ObjectStublessClient463(void);
void ObjectStublessClient464(void);
void ObjectStublessClient465(void);
void ObjectStublessClient466(void);
void ObjectStublessClient467(void);
void ObjectStublessClient468(void);
void ObjectStublessClient469(void);
void ObjectStublessClient470(void);
void ObjectStublessClient471(void);
void ObjectStublessClient472(void);
void ObjectStublessClient473(void);
void ObjectStublessClient474(void);
void ObjectStublessClient475(void);
void ObjectStublessClient476(void);
void ObjectStublessClient477(void);
void ObjectStublessClient478(void);
void ObjectStublessClient479(void);
void ObjectStublessClient480(void);
void ObjectStublessClient481(void);
void ObjectStublessClient482(void);
void ObjectStublessClient483(void);
void ObjectStublessClient484(void);
void ObjectStublessClient485(void);
void ObjectStublessClient486(void);
void ObjectStublessClient487(void);
void ObjectStublessClient488(void);
void ObjectStublessClient489(void);
void ObjectStublessClient490(void);
void ObjectStublessClient491(void);
void ObjectStublessClient492(void);
void ObjectStublessClient493(void);
void ObjectStublessClient494(void);
void ObjectStublessClient495(void);
void ObjectStublessClient496(void);
void ObjectStublessClient497(void);
void ObjectStublessClient498(void);
void ObjectStublessClient499(void);
void ObjectStublessClient500(void);
void ObjectStublessClient501(void);
void ObjectStublessClient502(void);
void ObjectStublessClient503(void);
void ObjectStublessClient504(void);
void ObjectStublessClient505(void);
void ObjectStublessClient506(void);
void ObjectStublessClient507(void);
void ObjectStublessClient508(void);
void ObjectStublessClient509(void);
void ObjectStublessClient510(void);
void ObjectStublessClient511(void);
void ObjectStublessClient512(void);
void ObjectStublessClient513(void);
void ObjectStublessClient514(void);
void ObjectStublessClient515(void);
void ObjectStublessClient516(void);
void ObjectStublessClient517(void);
void ObjectStublessClient518(void);
void ObjectStublessClient519(void);
void ObjectStublessClient520(void);
void ObjectStublessClient521(void);
void ObjectStublessClient522(void);
void ObjectStublessClient523(void);
void ObjectStublessClient524(void);
void ObjectStublessClient525(void);
void ObjectStublessClient526(void);
void ObjectStublessClient527(void);
void ObjectStublessClient528(void);
void ObjectStublessClient529(void);
void ObjectStublessClient530(void);
void ObjectStublessClient531(void);
void ObjectStublessClient532(void);
void ObjectStublessClient533(void);
void ObjectStublessClient534(void);
void ObjectStublessClient535(void);
void ObjectStublessClient536(void);
void ObjectStublessClient537(void);
void ObjectStublessClient538(void);
void ObjectStublessClient539(void);
void ObjectStublessClient540(void);
void ObjectStublessClient541(void);
void ObjectStublessClient542(void);
void ObjectStublessClient543(void);
void ObjectStublessClient544(void);
void ObjectStublessClient545(void);
void ObjectStublessClient546(void);
void ObjectStublessClient547(void);
void ObjectStublessClient548(void);
void ObjectStublessClient549(void);
void ObjectStublessClient550(void);
void ObjectStublessClient551(void);
void ObjectStublessClient552(void);
void ObjectStublessClient553(void);
void ObjectStublessClient554(void);
void ObjectStublessClient555(void);
void ObjectStublessClient556(void);
void ObjectStublessClient557(void);
void ObjectStublessClient558(void);
void ObjectStublessClient559(void);
void ObjectStublessClient560(void);
void ObjectStublessClient561(void);
void ObjectStublessClient562(void);
void ObjectStublessClient563(void);
void ObjectStublessClient564(void);
void ObjectStublessClient565(void);
void ObjectStublessClient566(void);
void ObjectStublessClient567(void);
void ObjectStublessClient568(void);
void ObjectStublessClient569(void);
void ObjectStublessClient570(void);
void ObjectStublessClient571(void);
void ObjectStublessClient572(void);
void ObjectStublessClient573(void);
void ObjectStublessClient574(void);
void ObjectStublessClient575(void);
void ObjectStublessClient576(void);
void ObjectStublessClient577(void);
void ObjectStublessClient578(void);
void ObjectStublessClient579(void);
void ObjectStublessClient580(void);
void ObjectStublessClient581(void);
void ObjectStublessClient582(void);
void ObjectStublessClient583(void);
void ObjectStublessClient584(void);
void ObjectStublessClient585(void);
void ObjectStublessClient586(void);
void ObjectStublessClient587(void);
void ObjectStublessClient588(void);
void ObjectStublessClient589(void);
void ObjectStublessClient590(void);
void ObjectStublessClient591(void);
void ObjectStublessClient592(void);
void ObjectStublessClient593(void);
void ObjectStublessClient594(void);
void ObjectStublessClient595(void);
void ObjectStublessClient596(void);
void ObjectStublessClient597(void);
void ObjectStublessClient598(void);
void ObjectStublessClient599(void);
void ObjectStublessClient600(void);
void ObjectStublessClient601(void);
void ObjectStublessClient602(void);
void ObjectStublessClient603(void);
void ObjectStublessClient604(void);
void ObjectStublessClient605(void);
void ObjectStublessClient606(void);
void ObjectStublessClient607(void);
void ObjectStublessClient608(void);
void ObjectStublessClient609(void);
void ObjectStublessClient610(void);
void ObjectStublessClient611(void);
void ObjectStublessClient612(void);
void ObjectStublessClient613(void);
void ObjectStublessClient614(void);
void ObjectStublessClient615(void);
void ObjectStublessClient616(void);
void ObjectStublessClient617(void);
void ObjectStublessClient618(void);
void ObjectStublessClient619(void);
void ObjectStublessClient620(void);
void ObjectStublessClient621(void);
void ObjectStublessClient622(void);
void ObjectStublessClient623(void);
void ObjectStublessClient624(void);
void ObjectStublessClient625(void);
void ObjectStublessClient626(void);
void ObjectStublessClient627(void);
void ObjectStublessClient628(void);
void ObjectStublessClient629(void);
void ObjectStublessClient630(void);
void ObjectStublessClient631(void);
void ObjectStublessClient632(void);
void ObjectStublessClient633(void);
void ObjectStublessClient634(void);
void ObjectStublessClient635(void);
void ObjectStublessClient636(void);
void ObjectStublessClient637(void);
void ObjectStublessClient638(void);
void ObjectStublessClient639(void);
void ObjectStublessClient640(void);
void ObjectStublessClient641(void);
void ObjectStublessClient642(void);
void ObjectStublessClient643(void);
void ObjectStublessClient644(void);
void ObjectStublessClient645(void);
void ObjectStublessClient646(void);
void ObjectStublessClient647(void);
void ObjectStublessClient648(void);
void ObjectStublessClient649(void);
void ObjectStublessClient650(void);
void ObjectStublessClient651(void);
void ObjectStublessClient652(void);
void ObjectStublessClient653(void);
void ObjectStublessClient654(void);
void ObjectStublessClient655(void);
void ObjectStublessClient656(void);
void ObjectStublessClient657(void);
void ObjectStublessClient658(void);
void ObjectStublessClient659(void);
void ObjectStublessClient660(void);
void ObjectStublessClient661(void);
void ObjectStublessClient662(void);
void ObjectStublessClient663(void);
void ObjectStublessClient664(void);
void ObjectStublessClient665(void);
void ObjectStublessClient666(void);
void ObjectStublessClient667(void);
void ObjectStublessClient668(void);
void ObjectStublessClient669(void);
void ObjectStublessClient670(void);
void ObjectStublessClient671(void);
void ObjectStublessClient672(void);
void ObjectStublessClient673(void);
void ObjectStublessClient674(void);
void ObjectStublessClient675(void);
void ObjectStublessClient676(void);
void ObjectStublessClient677(void);
void ObjectStublessClient678(void);
void ObjectStublessClient679(void);
void ObjectStublessClient680(void);
void ObjectStublessClient681(void);
void ObjectStublessClient682(void);
void ObjectStublessClient683(void);
void ObjectStublessClient684(void);
void ObjectStublessClient685(void);
void ObjectStublessClient686(void);
void ObjectStublessClient687(void);
void ObjectStublessClient688(void);
void ObjectStublessClient689(void);
void ObjectStublessClient690(void);
void ObjectStublessClient691(void);
void ObjectStublessClient692(void);
void ObjectStublessClient693(void);
void ObjectStublessClient694(void);
void ObjectStublessClient695(void);
void ObjectStublessClient696(void);
void ObjectStublessClient697(void);
void ObjectStublessClient698(void);
void ObjectStublessClient699(void);
void ObjectStublessClient700(void);
void ObjectStublessClient701(void);
void ObjectStublessClient702(void);
void ObjectStublessClient703(void);
void ObjectStublessClient704(void);
void ObjectStublessClient705(void);
void ObjectStublessClient706(void);
void ObjectStublessClient707(void);
void ObjectStublessClient708(void);
void ObjectStublessClient709(void);
void ObjectStublessClient710(void);
void ObjectStublessClient711(void);
void ObjectStublessClient712(void);
void ObjectStublessClient713(void);
void ObjectStublessClient714(void);
void ObjectStublessClient715(void);
void ObjectStublessClient716(void);
void ObjectStublessClient717(void);
void ObjectStublessClient718(void);
void ObjectStublessClient719(void);
void ObjectStublessClient720(void);
void ObjectStublessClient721(void);
void ObjectStublessClient722(void);
void ObjectStublessClient723(void);
void ObjectStublessClient724(void);
void ObjectStublessClient725(void);
void ObjectStublessClient726(void);
void ObjectStublessClient727(void);
void ObjectStublessClient728(void);
void ObjectStublessClient729(void);
void ObjectStublessClient730(void);
void ObjectStublessClient731(void);
void ObjectStublessClient732(void);
void ObjectStublessClient733(void);
void ObjectStublessClient734(void);
void ObjectStublessClient735(void);
void ObjectStublessClient736(void);
void ObjectStublessClient737(void);
void ObjectStublessClient738(void);
void ObjectStublessClient739(void);
void ObjectStublessClient740(void);
void ObjectStublessClient741(void);
void ObjectStublessClient742(void);
void ObjectStublessClient743(void);
void ObjectStublessClient744(void);
void ObjectStublessClient745(void);
void ObjectStublessClient746(void);
void ObjectStublessClient747(void);
void ObjectStublessClient748(void);
void ObjectStublessClient749(void);
void ObjectStublessClient750(void);
void ObjectStublessClient751(void);
void ObjectStublessClient752(void);
void ObjectStublessClient753(void);
void ObjectStublessClient754(void);
void ObjectStublessClient755(void);
void ObjectStublessClient756(void);
void ObjectStublessClient757(void);
void ObjectStublessClient758(void);
void ObjectStublessClient759(void);
void ObjectStublessClient760(void);
void ObjectStublessClient761(void);
void ObjectStublessClient762(void);
void ObjectStublessClient763(void);
void ObjectStublessClient764(void);
void ObjectStublessClient765(void);
void ObjectStublessClient766(void);
void ObjectStublessClient767(void);
void ObjectStublessClient768(void);
void ObjectStublessClient769(void);
void ObjectStublessClient770(void);
void ObjectStublessClient771(void);
void ObjectStublessClient772(void);
void ObjectStublessClient773(void);
void ObjectStublessClient774(void);
void ObjectStublessClient775(void);
void ObjectStublessClient776(void);
void ObjectStublessClient777(void);
void ObjectStublessClient778(void);
void ObjectStublessClient779(void);
void ObjectStublessClient780(void);
void ObjectStublessClient781(void);
void ObjectStublessClient782(void);
void ObjectStublessClient783(void);
void ObjectStublessClient784(void);
void ObjectStublessClient785(void);
void ObjectStublessClient786(void);
void ObjectStublessClient787(void);
void ObjectStublessClient788(void);
void ObjectStublessClient789(void);
void ObjectStublessClient790(void);
void ObjectStublessClient791(void);
void ObjectStublessClient792(void);
void ObjectStublessClient793(void);
void ObjectStublessClient794(void);
void ObjectStublessClient795(void);
void ObjectStublessClient796(void);
void ObjectStublessClient797(void);
void ObjectStublessClient798(void);
void ObjectStublessClient799(void);
void ObjectStublessClient800(void);
void ObjectStublessClient801(void);
void ObjectStublessClient802(void);
void ObjectStublessClient803(void);
void ObjectStublessClient804(void);
void ObjectStublessClient805(void);
void ObjectStublessClient806(void);
void ObjectStublessClient807(void);
void ObjectStublessClient808(void);
void ObjectStublessClient809(void);
void ObjectStublessClient810(void);
void ObjectStublessClient811(void);
void ObjectStublessClient812(void);
void ObjectStublessClient813(void);
void ObjectStublessClient814(void);
void ObjectStublessClient815(void);
void ObjectStublessClient816(void);
void ObjectStublessClient817(void);
void ObjectStublessClient818(void);
void ObjectStublessClient819(void);
void ObjectStublessClient820(void);
void ObjectStublessClient821(void);
void ObjectStublessClient822(void);
void ObjectStublessClient823(void);
void ObjectStublessClient824(void);
void ObjectStublessClient825(void);
void ObjectStublessClient826(void);
void ObjectStublessClient827(void);
void ObjectStublessClient828(void);
void ObjectStublessClient829(void);
void ObjectStublessClient830(void);
void ObjectStublessClient831(void);
void ObjectStublessClient832(void);
void ObjectStublessClient833(void);
void ObjectStublessClient834(void);
void ObjectStublessClient835(void);
void ObjectStublessClient836(void);
void ObjectStublessClient837(void);
void ObjectStublessClient838(void);
void ObjectStublessClient839(void);
void ObjectStublessClient840(void);
void ObjectStublessClient841(void);
void ObjectStublessClient842(void);
void ObjectStublessClient843(void);
void ObjectStublessClient844(void);
void ObjectStublessClient845(void);
void ObjectStublessClient846(void);
void ObjectStublessClient847(void);
void ObjectStublessClient848(void);
void ObjectStublessClient849(void);
void ObjectStublessClient850(void);
void ObjectStublessClient851(void);
void ObjectStublessClient852(void);
void ObjectStublessClient853(void);
void ObjectStublessClient854(void);
void ObjectStublessClient855(void);
void ObjectStublessClient856(void);
void ObjectStublessClient857(void);
void ObjectStublessClient858(void);
void ObjectStublessClient859(void);
void ObjectStublessClient860(void);
void ObjectStublessClient861(void);
void ObjectStublessClient862(void);
void ObjectStublessClient863(void);
void ObjectStublessClient864(void);
void ObjectStublessClient865(void);
void ObjectStublessClient866(void);
void ObjectStublessClient867(void);
void ObjectStublessClient868(void);
void ObjectStublessClient869(void);
void ObjectStublessClient870(void);
void ObjectStublessClient871(void);
void ObjectStublessClient872(void);
void ObjectStublessClient873(void);
void ObjectStublessClient874(void);
void ObjectStublessClient875(void);
void ObjectStublessClient876(void);
void ObjectStublessClient877(void);
void ObjectStublessClient878(void);
void ObjectStublessClient879(void);
void ObjectStublessClient880(void);
void ObjectStublessClient881(void);
void ObjectStublessClient882(void);
void ObjectStublessClient883(void);
void ObjectStublessClient884(void);
void ObjectStublessClient885(void);
void ObjectStublessClient886(void);
void ObjectStublessClient887(void);
void ObjectStublessClient888(void);
void ObjectStublessClient889(void);
void ObjectStublessClient890(void);
void ObjectStublessClient891(void);
void ObjectStublessClient892(void);
void ObjectStublessClient893(void);
void ObjectStublessClient894(void);
void ObjectStublessClient895(void);
void ObjectStublessClient896(void);
void ObjectStublessClient897(void);
void ObjectStublessClient898(void);
void ObjectStublessClient899(void);
void ObjectStublessClient900(void);
void ObjectStublessClient901(void);
void ObjectStublessClient902(void);
void ObjectStublessClient903(void);
void ObjectStublessClient904(void);
void ObjectStublessClient905(void);
void ObjectStublessClient906(void);
void ObjectStublessClient907(void);
void ObjectStublessClient908(void);
void ObjectStublessClient909(void);
void ObjectStublessClient910(void);
void ObjectStublessClient911(void);
void ObjectStublessClient912(void);
void ObjectStublessClient913(void);
void ObjectStublessClient914(void);
void ObjectStublessClient915(void);
void ObjectStublessClient916(void);
void ObjectStublessClient917(void);
void ObjectStublessClient918(void);
void ObjectStublessClient919(void);
void ObjectStublessClient920(void);
void ObjectStublessClient921(void);
void ObjectStublessClient922(void);
void ObjectStublessClient923(void);
void ObjectStublessClient924(void);
void ObjectStublessClient925(void);
void ObjectStublessClient926(void);
void ObjectStublessClient927(void);
void ObjectStublessClient928(void);
void ObjectStublessClient929(void);
void ObjectStublessClient930(void);
void ObjectStublessClient931(void);
void ObjectStublessClient932(void);
void ObjectStublessClient933(void);
void ObjectStublessClient934(void);
void ObjectStublessClient935(void);
void ObjectStublessClient936(void);
void ObjectStublessClient937(void);
void ObjectStublessClient938(void);
void ObjectStublessClient939(void);
void ObjectStublessClient940(void);
void ObjectStublessClient941(void);
void ObjectStublessClient942(void);
void ObjectStublessClient943(void);
void ObjectStublessClient944(void);
void ObjectStublessClient945(void);
void ObjectStublessClient946(void);
void ObjectStublessClient947(void);
void ObjectStublessClient948(void);
void ObjectStublessClient949(void);
void ObjectStublessClient950(void);
void ObjectStublessClient951(void);
void ObjectStublessClient952(void);
void ObjectStublessClient953(void);
void ObjectStublessClient954(void);
void ObjectStublessClient955(void);
void ObjectStublessClient956(void);
void ObjectStublessClient957(void);
void ObjectStublessClient958(void);
void ObjectStublessClient959(void);
void ObjectStublessClient960(void);
void ObjectStublessClient961(void);
void ObjectStublessClient962(void);
void ObjectStublessClient963(void);
void ObjectStublessClient964(void);
void ObjectStublessClient965(void);
void ObjectStublessClient966(void);
void ObjectStublessClient967(void);
void ObjectStublessClient968(void);
void ObjectStublessClient969(void);
void ObjectStublessClient970(void);
void ObjectStublessClient971(void);
void ObjectStublessClient972(void);
void ObjectStublessClient973(void);
void ObjectStublessClient974(void);
void ObjectStublessClient975(void);
void ObjectStublessClient976(void);
void ObjectStublessClient977(void);
void ObjectStublessClient978(void);
void ObjectStublessClient979(void);
void ObjectStublessClient980(void);
void ObjectStublessClient981(void);
void ObjectStublessClient982(void);
void ObjectStublessClient983(void);
void ObjectStublessClient984(void);
void ObjectStublessClient985(void);
void ObjectStublessClient986(void);
void ObjectStublessClient987(void);
void ObjectStublessClient988(void);
void ObjectStublessClient989(void);
void ObjectStublessClient990(void);
void ObjectStublessClient991(void);
void ObjectStublessClient992(void);
void ObjectStublessClient993(void);
void ObjectStublessClient994(void);
void ObjectStublessClient995(void);
void ObjectStublessClient996(void);
void ObjectStublessClient997(void);
void ObjectStublessClient998(void);
void ObjectStublessClient999(void);
void ObjectStublessClient1000(void);
void ObjectStublessClient1001(void);
void ObjectStublessClient1002(void);
void ObjectStublessClient1003(void);
void ObjectStublessClient1004(void);
void ObjectStublessClient1005(void);
void ObjectStublessClient1006(void);
void ObjectStublessClient1007(void);
void ObjectStublessClient1008(void);
void ObjectStublessClient1009(void);
void ObjectStublessClient1010(void);
void ObjectStublessClient1011(void);
void ObjectStublessClient1012(void);
void ObjectStublessClient1013(void);
void ObjectStublessClient1014(void);
void ObjectStublessClient1015(void);
void ObjectStublessClient1016(void);
void ObjectStublessClient1017(void);
void ObjectStublessClient1018(void);
void ObjectStublessClient1019(void);
void ObjectStublessClient1020(void);
void ObjectStublessClient1021(void);
void ObjectStublessClient1022(void);
void ObjectStublessClient1023(void);

extern void * const g_StublessClientVtbl[1024] =
    {
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy,
    ObjectStublessClient3,
    ObjectStublessClient4,
    ObjectStublessClient5,
    ObjectStublessClient6,
    ObjectStublessClient7,
    ObjectStublessClient8,
    ObjectStublessClient9,
    ObjectStublessClient10,
    ObjectStublessClient11,
    ObjectStublessClient12,
    ObjectStublessClient13,
    ObjectStublessClient14,
    ObjectStublessClient15,
    ObjectStublessClient16,
    ObjectStublessClient17,
    ObjectStublessClient18,
    ObjectStublessClient19,
    ObjectStublessClient20,
    ObjectStublessClient21,
    ObjectStublessClient22,
    ObjectStublessClient23,
    ObjectStublessClient24,
    ObjectStublessClient25,
    ObjectStublessClient26,
    ObjectStublessClient27,
    ObjectStublessClient28,
    ObjectStublessClient29,
    ObjectStublessClient30,
    ObjectStublessClient31,
    ObjectStublessClient32,
    ObjectStublessClient33,
    ObjectStublessClient34,
    ObjectStublessClient35,
    ObjectStublessClient36,
    ObjectStublessClient37,
    ObjectStublessClient38,
    ObjectStublessClient39,
    ObjectStublessClient40,
    ObjectStublessClient41,
    ObjectStublessClient42,
    ObjectStublessClient43,
    ObjectStublessClient44,
    ObjectStublessClient45,
    ObjectStublessClient46,
    ObjectStublessClient47,
    ObjectStublessClient48,
    ObjectStublessClient49,
    ObjectStublessClient50,
    ObjectStublessClient51,
    ObjectStublessClient52,
    ObjectStublessClient53,
    ObjectStublessClient54,
    ObjectStublessClient55,
    ObjectStublessClient56,
    ObjectStublessClient57,
    ObjectStublessClient58,
    ObjectStublessClient59,
    ObjectStublessClient60,
    ObjectStublessClient61,
    ObjectStublessClient62,
    ObjectStublessClient63,
    ObjectStublessClient64,
    ObjectStublessClient65,
    ObjectStublessClient66,
    ObjectStublessClient67,
    ObjectStublessClient68,
    ObjectStublessClient69,
    ObjectStublessClient70,
    ObjectStublessClient71,
    ObjectStublessClient72,
    ObjectStublessClient73,
    ObjectStublessClient74,
    ObjectStublessClient75,
    ObjectStublessClient76,
    ObjectStublessClient77,
    ObjectStublessClient78,
    ObjectStublessClient79,
    ObjectStublessClient80,
    ObjectStublessClient81,
    ObjectStublessClient82,
    ObjectStublessClient83,
    ObjectStublessClient84,
    ObjectStublessClient85,
    ObjectStublessClient86,
    ObjectStublessClient87,
    ObjectStublessClient88,
    ObjectStublessClient89,
    ObjectStublessClient90,
    ObjectStublessClient91,
    ObjectStublessClient92,
    ObjectStublessClient93,
    ObjectStublessClient94,
    ObjectStublessClient95,
    ObjectStublessClient96,
    ObjectStublessClient97,
    ObjectStublessClient98,
    ObjectStublessClient99,
    ObjectStublessClient100,
    ObjectStublessClient101,
    ObjectStublessClient102,
    ObjectStublessClient103,
    ObjectStublessClient104,
    ObjectStublessClient105,
    ObjectStublessClient106,
    ObjectStublessClient107,
    ObjectStublessClient108,
    ObjectStublessClient109,
    ObjectStublessClient110,
    ObjectStublessClient111,
    ObjectStublessClient112,
    ObjectStublessClient113,
    ObjectStublessClient114,
    ObjectStublessClient115,
    ObjectStublessClient116,
    ObjectStublessClient117,
    ObjectStublessClient118,
    ObjectStublessClient119,
    ObjectStublessClient120,
    ObjectStublessClient121,
    ObjectStublessClient122,
    ObjectStublessClient123,
    ObjectStublessClient124,
    ObjectStublessClient125,
    ObjectStublessClient126,
    ObjectStublessClient127,
    ObjectStublessClient128,
    ObjectStublessClient129,
    ObjectStublessClient130,
    ObjectStublessClient131,
    ObjectStublessClient132,
    ObjectStublessClient133,
    ObjectStublessClient134,
    ObjectStublessClient135,
    ObjectStublessClient136,
    ObjectStublessClient137,
    ObjectStublessClient138,
    ObjectStublessClient139,
    ObjectStublessClient140,
    ObjectStublessClient141,
    ObjectStublessClient142,
    ObjectStublessClient143,
    ObjectStublessClient144,
    ObjectStublessClient145,
    ObjectStublessClient146,
    ObjectStublessClient147,
    ObjectStublessClient148,
    ObjectStublessClient149,
    ObjectStublessClient150,
    ObjectStublessClient151,
    ObjectStublessClient152,
    ObjectStublessClient153,
    ObjectStublessClient154,
    ObjectStublessClient155,
    ObjectStublessClient156,
    ObjectStublessClient157,
    ObjectStublessClient158,
    ObjectStublessClient159,
    ObjectStublessClient160,
    ObjectStublessClient161,
    ObjectStublessClient162,
    ObjectStublessClient163,
    ObjectStublessClient164,
    ObjectStublessClient165,
    ObjectStublessClient166,
    ObjectStublessClient167,
    ObjectStublessClient168,
    ObjectStublessClient169,
    ObjectStublessClient170,
    ObjectStublessClient171,
    ObjectStublessClient172,
    ObjectStublessClient173,
    ObjectStublessClient174,
    ObjectStublessClient175,
    ObjectStublessClient176,
    ObjectStublessClient177,
    ObjectStublessClient178,
    ObjectStublessClient179,
    ObjectStublessClient180,
    ObjectStublessClient181,
    ObjectStublessClient182,
    ObjectStublessClient183,
    ObjectStublessClient184,
    ObjectStublessClient185,
    ObjectStublessClient186,
    ObjectStublessClient187,
    ObjectStublessClient188,
    ObjectStublessClient189,
    ObjectStublessClient190,
    ObjectStublessClient191,
    ObjectStublessClient192,
    ObjectStublessClient193,
    ObjectStublessClient194,
    ObjectStublessClient195,
    ObjectStublessClient196,
    ObjectStublessClient197,
    ObjectStublessClient198,
    ObjectStublessClient199,
    ObjectStublessClient200,
    ObjectStublessClient201,
    ObjectStublessClient202,
    ObjectStublessClient203,
    ObjectStublessClient204,
    ObjectStublessClient205,
    ObjectStublessClient206,
    ObjectStublessClient207,
    ObjectStublessClient208,
    ObjectStublessClient209,
    ObjectStublessClient210,
    ObjectStublessClient211,
    ObjectStublessClient212,
    ObjectStublessClient213,
    ObjectStublessClient214,
    ObjectStublessClient215,
    ObjectStublessClient216,
    ObjectStublessClient217,
    ObjectStublessClient218,
    ObjectStublessClient219,
    ObjectStublessClient220,
    ObjectStublessClient221,
    ObjectStublessClient222,
    ObjectStublessClient223,
    ObjectStublessClient224,
    ObjectStublessClient225,
    ObjectStublessClient226,
    ObjectStublessClient227,
    ObjectStublessClient228,
    ObjectStublessClient229,
    ObjectStublessClient230,
    ObjectStublessClient231,
    ObjectStublessClient232,
    ObjectStublessClient233,
    ObjectStublessClient234,
    ObjectStublessClient235,
    ObjectStublessClient236,
    ObjectStublessClient237,
    ObjectStublessClient238,
    ObjectStublessClient239,
    ObjectStublessClient240,
    ObjectStublessClient241,
    ObjectStublessClient242,
    ObjectStublessClient243,
    ObjectStublessClient244,
    ObjectStublessClient245,
    ObjectStublessClient246,
    ObjectStublessClient247,
    ObjectStublessClient248,
    ObjectStublessClient249,
    ObjectStublessClient250,
    ObjectStublessClient251,
    ObjectStublessClient252,
    ObjectStublessClient253,
    ObjectStublessClient254,
    ObjectStublessClient255,
    ObjectStublessClient256,
    ObjectStublessClient257,
    ObjectStublessClient258,
    ObjectStublessClient259,
    ObjectStublessClient260,
    ObjectStublessClient261,
    ObjectStublessClient262,
    ObjectStublessClient263,
    ObjectStublessClient264,
    ObjectStublessClient265,
    ObjectStublessClient266,
    ObjectStublessClient267,
    ObjectStublessClient268,
    ObjectStublessClient269,
    ObjectStublessClient270,
    ObjectStublessClient271,
    ObjectStublessClient272,
    ObjectStublessClient273,
    ObjectStublessClient274,
    ObjectStublessClient275,
    ObjectStublessClient276,
    ObjectStublessClient277,
    ObjectStublessClient278,
    ObjectStublessClient279,
    ObjectStublessClient280,
    ObjectStublessClient281,
    ObjectStublessClient282,
    ObjectStublessClient283,
    ObjectStublessClient284,
    ObjectStublessClient285,
    ObjectStublessClient286,
    ObjectStublessClient287,
    ObjectStublessClient288,
    ObjectStublessClient289,
    ObjectStublessClient290,
    ObjectStublessClient291,
    ObjectStublessClient292,
    ObjectStublessClient293,
    ObjectStublessClient294,
    ObjectStublessClient295,
    ObjectStublessClient296,
    ObjectStublessClient297,
    ObjectStublessClient298,
    ObjectStublessClient299,
    ObjectStublessClient300,
    ObjectStublessClient301,
    ObjectStublessClient302,
    ObjectStublessClient303,
    ObjectStublessClient304,
    ObjectStublessClient305,
    ObjectStublessClient306,
    ObjectStublessClient307,
    ObjectStublessClient308,
    ObjectStublessClient309,
    ObjectStublessClient310,
    ObjectStublessClient311,
    ObjectStublessClient312,
    ObjectStublessClient313,
    ObjectStublessClient314,
    ObjectStublessClient315,
    ObjectStublessClient316,
    ObjectStublessClient317,
    ObjectStublessClient318,
    ObjectStublessClient319,
    ObjectStublessClient320,
    ObjectStublessClient321,
    ObjectStublessClient322,
    ObjectStublessClient323,
    ObjectStublessClient324,
    ObjectStublessClient325,
    ObjectStublessClient326,
    ObjectStublessClient327,
    ObjectStublessClient328,
    ObjectStublessClient329,
    ObjectStublessClient330,
    ObjectStublessClient331,
    ObjectStublessClient332,
    ObjectStublessClient333,
    ObjectStublessClient334,
    ObjectStublessClient335,
    ObjectStublessClient336,
    ObjectStublessClient337,
    ObjectStublessClient338,
    ObjectStublessClient339,
    ObjectStublessClient340,
    ObjectStublessClient341,
    ObjectStublessClient342,
    ObjectStublessClient343,
    ObjectStublessClient344,
    ObjectStublessClient345,
    ObjectStublessClient346,
    ObjectStublessClient347,
    ObjectStublessClient348,
    ObjectStublessClient349,
    ObjectStublessClient350,
    ObjectStublessClient351,
    ObjectStublessClient352,
    ObjectStublessClient353,
    ObjectStublessClient354,
    ObjectStublessClient355,
    ObjectStublessClient356,
    ObjectStublessClient357,
    ObjectStublessClient358,
    ObjectStublessClient359,
    ObjectStublessClient360,
    ObjectStublessClient361,
    ObjectStublessClient362,
    ObjectStublessClient363,
    ObjectStublessClient364,
    ObjectStublessClient365,
    ObjectStublessClient366,
    ObjectStublessClient367,
    ObjectStublessClient368,
    ObjectStublessClient369,
    ObjectStublessClient370,
    ObjectStublessClient371,
    ObjectStublessClient372,
    ObjectStublessClient373,
    ObjectStublessClient374,
    ObjectStublessClient375,
    ObjectStublessClient376,
    ObjectStublessClient377,
    ObjectStublessClient378,
    ObjectStublessClient379,
    ObjectStublessClient380,
    ObjectStublessClient381,
    ObjectStublessClient382,
    ObjectStublessClient383,
    ObjectStublessClient384,
    ObjectStublessClient385,
    ObjectStublessClient386,
    ObjectStublessClient387,
    ObjectStublessClient388,
    ObjectStublessClient389,
    ObjectStublessClient390,
    ObjectStublessClient391,
    ObjectStublessClient392,
    ObjectStublessClient393,
    ObjectStublessClient394,
    ObjectStublessClient395,
    ObjectStublessClient396,
    ObjectStublessClient397,
    ObjectStublessClient398,
    ObjectStublessClient399,
    ObjectStublessClient400,
    ObjectStublessClient401,
    ObjectStublessClient402,
    ObjectStublessClient403,
    ObjectStublessClient404,
    ObjectStublessClient405,
    ObjectStublessClient406,
    ObjectStublessClient407,
    ObjectStublessClient408,
    ObjectStublessClient409,
    ObjectStublessClient410,
    ObjectStublessClient411,
    ObjectStublessClient412,
    ObjectStublessClient413,
    ObjectStublessClient414,
    ObjectStublessClient415,
    ObjectStublessClient416,
    ObjectStublessClient417,
    ObjectStublessClient418,
    ObjectStublessClient419,
    ObjectStublessClient420,
    ObjectStublessClient421,
    ObjectStublessClient422,
    ObjectStublessClient423,
    ObjectStublessClient424,
    ObjectStublessClient425,
    ObjectStublessClient426,
    ObjectStublessClient427,
    ObjectStublessClient428,
    ObjectStublessClient429,
    ObjectStublessClient430,
    ObjectStublessClient431,
    ObjectStublessClient432,
    ObjectStublessClient433,
    ObjectStublessClient434,
    ObjectStublessClient435,
    ObjectStublessClient436,
    ObjectStublessClient437,
    ObjectStublessClient438,
    ObjectStublessClient439,
    ObjectStublessClient440,
    ObjectStublessClient441,
    ObjectStublessClient442,
    ObjectStublessClient443,
    ObjectStublessClient444,
    ObjectStublessClient445,
    ObjectStublessClient446,
    ObjectStublessClient447,
    ObjectStublessClient448,
    ObjectStublessClient449,
    ObjectStublessClient450,
    ObjectStublessClient451,
    ObjectStublessClient452,
    ObjectStublessClient453,
    ObjectStublessClient454,
    ObjectStublessClient455,
    ObjectStublessClient456,
    ObjectStublessClient457,
    ObjectStublessClient458,
    ObjectStublessClient459,
    ObjectStublessClient460,
    ObjectStublessClient461,
    ObjectStublessClient462,
    ObjectStublessClient463,
    ObjectStublessClient464,
    ObjectStublessClient465,
    ObjectStublessClient466,
    ObjectStublessClient467,
    ObjectStublessClient468,
    ObjectStublessClient469,
    ObjectStublessClient470,
    ObjectStublessClient471,
    ObjectStublessClient472,
    ObjectStublessClient473,
    ObjectStublessClient474,
    ObjectStublessClient475,
    ObjectStublessClient476,
    ObjectStublessClient477,
    ObjectStublessClient478,
    ObjectStublessClient479,
    ObjectStublessClient480,
    ObjectStublessClient481,
    ObjectStublessClient482,
    ObjectStublessClient483,
    ObjectStublessClient484,
    ObjectStublessClient485,
    ObjectStublessClient486,
    ObjectStublessClient487,
    ObjectStublessClient488,
    ObjectStublessClient489,
    ObjectStublessClient490,
    ObjectStublessClient491,
    ObjectStublessClient492,
    ObjectStublessClient493,
    ObjectStublessClient494,
    ObjectStublessClient495,
    ObjectStublessClient496,
    ObjectStublessClient497,
    ObjectStublessClient498,
    ObjectStublessClient499,
    ObjectStublessClient500,
    ObjectStublessClient501,
    ObjectStublessClient502,
    ObjectStublessClient503,
    ObjectStublessClient504,
    ObjectStublessClient505,
    ObjectStublessClient506,
    ObjectStublessClient507,
    ObjectStublessClient508,
    ObjectStublessClient509,
    ObjectStublessClient510,
    ObjectStublessClient511,
    ObjectStublessClient512,
    ObjectStublessClient513,
    ObjectStublessClient514,
    ObjectStublessClient515,
    ObjectStublessClient516,
    ObjectStublessClient517,
    ObjectStublessClient518,
    ObjectStublessClient519,
    ObjectStublessClient520,
    ObjectStublessClient521,
    ObjectStublessClient522,
    ObjectStublessClient523,
    ObjectStublessClient524,
    ObjectStublessClient525,
    ObjectStublessClient526,
    ObjectStublessClient527,
    ObjectStublessClient528,
    ObjectStublessClient529,
    ObjectStublessClient530,
    ObjectStublessClient531,
    ObjectStublessClient532,
    ObjectStublessClient533,
    ObjectStublessClient534,
    ObjectStublessClient535,
    ObjectStublessClient536,
    ObjectStublessClient537,
    ObjectStublessClient538,
    ObjectStublessClient539,
    ObjectStublessClient540,
    ObjectStublessClient541,
    ObjectStublessClient542,
    ObjectStublessClient543,
    ObjectStublessClient544,
    ObjectStublessClient545,
    ObjectStublessClient546,
    ObjectStublessClient547,
    ObjectStublessClient548,
    ObjectStublessClient549,
    ObjectStublessClient550,
    ObjectStublessClient551,
    ObjectStublessClient552,
    ObjectStublessClient553,
    ObjectStublessClient554,
    ObjectStublessClient555,
    ObjectStublessClient556,
    ObjectStublessClient557,
    ObjectStublessClient558,
    ObjectStublessClient559,
    ObjectStublessClient560,
    ObjectStublessClient561,
    ObjectStublessClient562,
    ObjectStublessClient563,
    ObjectStublessClient564,
    ObjectStublessClient565,
    ObjectStublessClient566,
    ObjectStublessClient567,
    ObjectStublessClient568,
    ObjectStublessClient569,
    ObjectStublessClient570,
    ObjectStublessClient571,
    ObjectStublessClient572,
    ObjectStublessClient573,
    ObjectStublessClient574,
    ObjectStublessClient575,
    ObjectStublessClient576,
    ObjectStublessClient577,
    ObjectStublessClient578,
    ObjectStublessClient579,
    ObjectStublessClient580,
    ObjectStublessClient581,
    ObjectStublessClient582,
    ObjectStublessClient583,
    ObjectStublessClient584,
    ObjectStublessClient585,
    ObjectStublessClient586,
    ObjectStublessClient587,
    ObjectStublessClient588,
    ObjectStublessClient589,
    ObjectStublessClient590,
    ObjectStublessClient591,
    ObjectStublessClient592,
    ObjectStublessClient593,
    ObjectStublessClient594,
    ObjectStublessClient595,
    ObjectStublessClient596,
    ObjectStublessClient597,
    ObjectStublessClient598,
    ObjectStublessClient599,
    ObjectStublessClient600,
    ObjectStublessClient601,
    ObjectStublessClient602,
    ObjectStublessClient603,
    ObjectStublessClient604,
    ObjectStublessClient605,
    ObjectStublessClient606,
    ObjectStublessClient607,
    ObjectStublessClient608,
    ObjectStublessClient609,
    ObjectStublessClient610,
    ObjectStublessClient611,
    ObjectStublessClient612,
    ObjectStublessClient613,
    ObjectStublessClient614,
    ObjectStublessClient615,
    ObjectStublessClient616,
    ObjectStublessClient617,
    ObjectStublessClient618,
    ObjectStublessClient619,
    ObjectStublessClient620,
    ObjectStublessClient621,
    ObjectStublessClient622,
    ObjectStublessClient623,
    ObjectStublessClient624,
    ObjectStublessClient625,
    ObjectStublessClient626,
    ObjectStublessClient627,
    ObjectStublessClient628,
    ObjectStublessClient629,
    ObjectStublessClient630,
    ObjectStublessClient631,
    ObjectStublessClient632,
    ObjectStublessClient633,
    ObjectStublessClient634,
    ObjectStublessClient635,
    ObjectStublessClient636,
    ObjectStublessClient637,
    ObjectStublessClient638,
    ObjectStublessClient639,
    ObjectStublessClient640,
    ObjectStublessClient641,
    ObjectStublessClient642,
    ObjectStublessClient643,
    ObjectStublessClient644,
    ObjectStublessClient645,
    ObjectStublessClient646,
    ObjectStublessClient647,
    ObjectStublessClient648,
    ObjectStublessClient649,
    ObjectStublessClient650,
    ObjectStublessClient651,
    ObjectStublessClient652,
    ObjectStublessClient653,
    ObjectStublessClient654,
    ObjectStublessClient655,
    ObjectStublessClient656,
    ObjectStublessClient657,
    ObjectStublessClient658,
    ObjectStublessClient659,
    ObjectStublessClient660,
    ObjectStublessClient661,
    ObjectStublessClient662,
    ObjectStublessClient663,
    ObjectStublessClient664,
    ObjectStublessClient665,
    ObjectStublessClient666,
    ObjectStublessClient667,
    ObjectStublessClient668,
    ObjectStublessClient669,
    ObjectStublessClient670,
    ObjectStublessClient671,
    ObjectStublessClient672,
    ObjectStublessClient673,
    ObjectStublessClient674,
    ObjectStublessClient675,
    ObjectStublessClient676,
    ObjectStublessClient677,
    ObjectStublessClient678,
    ObjectStublessClient679,
    ObjectStublessClient680,
    ObjectStublessClient681,
    ObjectStublessClient682,
    ObjectStublessClient683,
    ObjectStublessClient684,
    ObjectStublessClient685,
    ObjectStublessClient686,
    ObjectStublessClient687,
    ObjectStublessClient688,
    ObjectStublessClient689,
    ObjectStublessClient690,
    ObjectStublessClient691,
    ObjectStublessClient692,
    ObjectStublessClient693,
    ObjectStublessClient694,
    ObjectStublessClient695,
    ObjectStublessClient696,
    ObjectStublessClient697,
    ObjectStublessClient698,
    ObjectStublessClient699,
    ObjectStublessClient700,
    ObjectStublessClient701,
    ObjectStublessClient702,
    ObjectStublessClient703,
    ObjectStublessClient704,
    ObjectStublessClient705,
    ObjectStublessClient706,
    ObjectStublessClient707,
    ObjectStublessClient708,
    ObjectStublessClient709,
    ObjectStublessClient710,
    ObjectStublessClient711,
    ObjectStublessClient712,
    ObjectStublessClient713,
    ObjectStublessClient714,
    ObjectStublessClient715,
    ObjectStublessClient716,
    ObjectStublessClient717,
    ObjectStublessClient718,
    ObjectStublessClient719,
    ObjectStublessClient720,
    ObjectStublessClient721,
    ObjectStublessClient722,
    ObjectStublessClient723,
    ObjectStublessClient724,
    ObjectStublessClient725,
    ObjectStublessClient726,
    ObjectStublessClient727,
    ObjectStublessClient728,
    ObjectStublessClient729,
    ObjectStublessClient730,
    ObjectStublessClient731,
    ObjectStublessClient732,
    ObjectStublessClient733,
    ObjectStublessClient734,
    ObjectStublessClient735,
    ObjectStublessClient736,
    ObjectStublessClient737,
    ObjectStublessClient738,
    ObjectStublessClient739,
    ObjectStublessClient740,
    ObjectStublessClient741,
    ObjectStublessClient742,
    ObjectStublessClient743,
    ObjectStublessClient744,
    ObjectStublessClient745,
    ObjectStublessClient746,
    ObjectStublessClient747,
    ObjectStublessClient748,
    ObjectStublessClient749,
    ObjectStublessClient750,
    ObjectStublessClient751,
    ObjectStublessClient752,
    ObjectStublessClient753,
    ObjectStublessClient754,
    ObjectStublessClient755,
    ObjectStublessClient756,
    ObjectStublessClient757,
    ObjectStublessClient758,
    ObjectStublessClient759,
    ObjectStublessClient760,
    ObjectStublessClient761,
    ObjectStublessClient762,
    ObjectStublessClient763,
    ObjectStublessClient764,
    ObjectStublessClient765,
    ObjectStublessClient766,
    ObjectStublessClient767,
    ObjectStublessClient768,
    ObjectStublessClient769,
    ObjectStublessClient770,
    ObjectStublessClient771,
    ObjectStublessClient772,
    ObjectStublessClient773,
    ObjectStublessClient774,
    ObjectStublessClient775,
    ObjectStublessClient776,
    ObjectStublessClient777,
    ObjectStublessClient778,
    ObjectStublessClient779,
    ObjectStublessClient780,
    ObjectStublessClient781,
    ObjectStublessClient782,
    ObjectStublessClient783,
    ObjectStublessClient784,
    ObjectStublessClient785,
    ObjectStublessClient786,
    ObjectStublessClient787,
    ObjectStublessClient788,
    ObjectStublessClient789,
    ObjectStublessClient790,
    ObjectStublessClient791,
    ObjectStublessClient792,
    ObjectStublessClient793,
    ObjectStublessClient794,
    ObjectStublessClient795,
    ObjectStublessClient796,
    ObjectStublessClient797,
    ObjectStublessClient798,
    ObjectStublessClient799,
    ObjectStublessClient800,
    ObjectStublessClient801,
    ObjectStublessClient802,
    ObjectStublessClient803,
    ObjectStublessClient804,
    ObjectStublessClient805,
    ObjectStublessClient806,
    ObjectStublessClient807,
    ObjectStublessClient808,
    ObjectStublessClient809,
    ObjectStublessClient810,
    ObjectStublessClient811,
    ObjectStublessClient812,
    ObjectStublessClient813,
    ObjectStublessClient814,
    ObjectStublessClient815,
    ObjectStublessClient816,
    ObjectStublessClient817,
    ObjectStublessClient818,
    ObjectStublessClient819,
    ObjectStublessClient820,
    ObjectStublessClient821,
    ObjectStublessClient822,
    ObjectStublessClient823,
    ObjectStublessClient824,
    ObjectStublessClient825,
    ObjectStublessClient826,
    ObjectStublessClient827,
    ObjectStublessClient828,
    ObjectStublessClient829,
    ObjectStublessClient830,
    ObjectStublessClient831,
    ObjectStublessClient832,
    ObjectStublessClient833,
    ObjectStublessClient834,
    ObjectStublessClient835,
    ObjectStublessClient836,
    ObjectStublessClient837,
    ObjectStublessClient838,
    ObjectStublessClient839,
    ObjectStublessClient840,
    ObjectStublessClient841,
    ObjectStublessClient842,
    ObjectStublessClient843,
    ObjectStublessClient844,
    ObjectStublessClient845,
    ObjectStublessClient846,
    ObjectStublessClient847,
    ObjectStublessClient848,
    ObjectStublessClient849,
    ObjectStublessClient850,
    ObjectStublessClient851,
    ObjectStublessClient852,
    ObjectStublessClient853,
    ObjectStublessClient854,
    ObjectStublessClient855,
    ObjectStublessClient856,
    ObjectStublessClient857,
    ObjectStublessClient858,
    ObjectStublessClient859,
    ObjectStublessClient860,
    ObjectStublessClient861,
    ObjectStublessClient862,
    ObjectStublessClient863,
    ObjectStublessClient864,
    ObjectStublessClient865,
    ObjectStublessClient866,
    ObjectStublessClient867,
    ObjectStublessClient868,
    ObjectStublessClient869,
    ObjectStublessClient870,
    ObjectStublessClient871,
    ObjectStublessClient872,
    ObjectStublessClient873,
    ObjectStublessClient874,
    ObjectStublessClient875,
    ObjectStublessClient876,
    ObjectStublessClient877,
    ObjectStublessClient878,
    ObjectStublessClient879,
    ObjectStublessClient880,
    ObjectStublessClient881,
    ObjectStublessClient882,
    ObjectStublessClient883,
    ObjectStublessClient884,
    ObjectStublessClient885,
    ObjectStublessClient886,
    ObjectStublessClient887,
    ObjectStublessClient888,
    ObjectStublessClient889,
    ObjectStublessClient890,
    ObjectStublessClient891,
    ObjectStublessClient892,
    ObjectStublessClient893,
    ObjectStublessClient894,
    ObjectStublessClient895,
    ObjectStublessClient896,
    ObjectStublessClient897,
    ObjectStublessClient898,
    ObjectStublessClient899,
    ObjectStublessClient900,
    ObjectStublessClient901,
    ObjectStublessClient902,
    ObjectStublessClient903,
    ObjectStublessClient904,
    ObjectStublessClient905,
    ObjectStublessClient906,
    ObjectStublessClient907,
    ObjectStublessClient908,
    ObjectStublessClient909,
    ObjectStublessClient910,
    ObjectStublessClient911,
    ObjectStublessClient912,
    ObjectStublessClient913,
    ObjectStublessClient914,
    ObjectStublessClient915,
    ObjectStublessClient916,
    ObjectStublessClient917,
    ObjectStublessClient918,
    ObjectStublessClient919,
    ObjectStublessClient920,
    ObjectStublessClient921,
    ObjectStublessClient922,
    ObjectStublessClient923,
    ObjectStublessClient924,
    ObjectStublessClient925,
    ObjectStublessClient926,
    ObjectStublessClient927,
    ObjectStublessClient928,
    ObjectStublessClient929,
    ObjectStublessClient930,
    ObjectStublessClient931,
    ObjectStublessClient932,
    ObjectStublessClient933,
    ObjectStublessClient934,
    ObjectStublessClient935,
    ObjectStublessClient936,
    ObjectStublessClient937,
    ObjectStublessClient938,
    ObjectStublessClient939,
    ObjectStublessClient940,
    ObjectStublessClient941,
    ObjectStublessClient942,
    ObjectStublessClient943,
    ObjectStublessClient944,
    ObjectStublessClient945,
    ObjectStublessClient946,
    ObjectStublessClient947,
    ObjectStublessClient948,
    ObjectStublessClient949,
    ObjectStublessClient950,
    ObjectStublessClient951,
    ObjectStublessClient952,
    ObjectStublessClient953,
    ObjectStublessClient954,
    ObjectStublessClient955,
    ObjectStublessClient956,
    ObjectStublessClient957,
    ObjectStublessClient958,
    ObjectStublessClient959,
    ObjectStublessClient960,
    ObjectStublessClient961,
    ObjectStublessClient962,
    ObjectStublessClient963,
    ObjectStublessClient964,
    ObjectStublessClient965,
    ObjectStublessClient966,
    ObjectStublessClient967,
    ObjectStublessClient968,
    ObjectStublessClient969,
    ObjectStublessClient970,
    ObjectStublessClient971,
    ObjectStublessClient972,
    ObjectStublessClient973,
    ObjectStublessClient974,
    ObjectStublessClient975,
    ObjectStublessClient976,
    ObjectStublessClient977,
    ObjectStublessClient978,
    ObjectStublessClient979,
    ObjectStublessClient980,
    ObjectStublessClient981,
    ObjectStublessClient982,
    ObjectStublessClient983,
    ObjectStublessClient984,
    ObjectStublessClient985,
    ObjectStublessClient986,
    ObjectStublessClient987,
    ObjectStublessClient988,
    ObjectStublessClient989,
    ObjectStublessClient990,
    ObjectStublessClient991,
    ObjectStublessClient992,
    ObjectStublessClient993,
    ObjectStublessClient994,
    ObjectStublessClient995,
    ObjectStublessClient996,
    ObjectStublessClient997,
    ObjectStublessClient998,
    ObjectStublessClient999,
    ObjectStublessClient1000,
    ObjectStublessClient1001,
    ObjectStublessClient1002,
    ObjectStublessClient1003,
    ObjectStublessClient1004,
    ObjectStublessClient1005,
    ObjectStublessClient1006,
    ObjectStublessClient1007,
    ObjectStublessClient1008,
    ObjectStublessClient1009,
    ObjectStublessClient1010,
    ObjectStublessClient1011,
    ObjectStublessClient1012,
    ObjectStublessClient1013,
    ObjectStublessClient1014,
    ObjectStublessClient1015,
    ObjectStublessClient1016,
    ObjectStublessClient1017,
    ObjectStublessClient1018,
    ObjectStublessClient1019,
    ObjectStublessClient1020,
    ObjectStublessClient1021,
    ObjectStublessClient1022,
    ObjectStublessClient1023
    };
}

void
MergeFpArguments (
    REGISTER_TYPE *ArgumentList,
    REGISTER_TYPE *FloatRegisters,
    ULONG FloatMask
    )

/*++

Routine Description:

    This function merges floating arguments into the specified argument list.

Arguments:

    ArgumentList - Supplies a pointer to the argument list.

    FloatingRegister - Supplies a pointer to possible floating register
        arguments.

    FloatMask - Supplies the floating value mask. Each pair of bits in the
        mask describe one argument.

Return Value:

    None.

--*/

{

    //
    // Merge floating values into argument list.
    //

    if ((FloatMask & 0x3)) {
        ArgumentList[0] = FloatRegisters[0];
    }

    if ((FloatMask & 0xe)) {
        ArgumentList[1] = FloatRegisters[1];
    }

    if ((FloatMask & 0x30)) {
        ArgumentList[2] = FloatRegisters[2];
    }

    if ((FloatMask & 0xe0)) {
        ArgumentList[3] = FloatRegisters[3];
    }
}

void ** StublessClientVtbl = (void **)g_StublessClientVtbl;

long
ObjectStublessClient(
    void *ParamAddress,
    REGISTER_TYPE *FloatRegisters,
    long Method
    )

/*++

Routine Description:

Arguments:

    ParamAddress - Supplies a pointer to the argument list.

    FloatRegisters - Supplies a pointer to the saved floating argument
        registers.

    Method - Supplies the method number.

Return Value:

--*/

{

    PMIDL_STUBLESS_PROXY_INFO ProxyInfo;
    CInterfaceProxyHeader *ProxyHeader;
    PFORMAT_STRING ProcFormat;
    unsigned short ProcFormatOffset;
    CLIENT_CALL_RETURN Return;
    void *This;

    This = *(void **)ParamAddress;
    ProxyHeader =
        (CInterfaceProxyHeader *)(*((char **)This) - sizeof(CInterfaceProxyHeader));

    ProxyInfo = (PMIDL_STUBLESS_PROXY_INFO)ProxyHeader->pStublessProxyInfo;
    if (ProxyInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES) {
        NDR_PROC_CONTEXT ProcContext;
        HRESULT          hr;

        Ndr64ClientInitializeContext(NdrpGetSyntaxType(ProxyInfo->pTransferSyntax),
                                     ProxyInfo,
                                     Method,
                                     &ProcContext,
                                     (uchar *)ParamAddress);

        if (ProcContext.FloatDoubleMask != 0) {
            MergeFpArguments((REGISTER_TYPE *)ParamAddress,
                             FloatRegisters,
                             ProcContext.FloatDoubleMask);
        }

        if (ProcContext.IsAsync) {
            if (Method & 0x1) {
                hr =  MulNdrpBeginDcomAsyncClientCall(ProxyInfo,
                                                      Method,
                                                      &ProcContext,
                                                      ParamAddress);

            } else {
                hr =  MulNdrpFinishDcomAsyncClientCall(ProxyInfo,
                                                       Method,
                                                       &ProcContext,
                                                       ParamAddress);
            }

            Return.Simple = hr;

        } else {
            Return = NdrpClientCall3(This,
                                     ProxyInfo,
                                     Method,
                                     NULL,
                                     &ProcContext,
                                     (uchar *)ParamAddress);
        }

        return (long)Return.Simple;
    }

    ProcFormatOffset = ProxyInfo->FormatStringOffset[Method];
    ProcFormat = &ProxyInfo->ProcFormatString[ProcFormatOffset];

    //
    // The first public MIDL with 64b support was released with NT5 betA2.
    // We will ignore any MIDL earlier than the MIDL released with NT5/2000 beta3.
    // Change MIDL_VERSION_5_2_202 to the MIDL version for beta3, now at 5.2.221.
    //

    if (ProxyInfo->pStubDesc->MIDLVersion < MIDL_VERSION_5_2_202) {
        RpcRaiseException(RPC_X_WRONG_STUB_VERSION);
    }

    //
    // Since MIDL 3.0.39 we have a proc flag that indicates
    // which interpeter to call. This is because the NDR version
    // may be bigger than 1.1 for other reasons.
    // MIDL version is 5.2.+ so the flag is guaranteed to be there.
    //

    if (ProcFormat[1]  &  Oi_OBJ_USE_V2_INTERPRETER) {
        if (((PNDR_DCOM_OI2_PROC_HEADER)ProcFormat)->Oi2Flags.HasExtensions) {
            PNDR_PROC_HEADER_EXTS64 pExts =
                (PNDR_PROC_HEADER_EXTS64)(ProcFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

            if (pExts->FloatArgMask != 0) {
                MergeFpArguments((REGISTER_TYPE *)ParamAddress,
                                 FloatRegisters,
                                 pExts->FloatArgMask);
            }
        }

        if (((PNDR_DCOM_OI2_PROC_HEADER)ProcFormat)->Oi2Flags.HasAsyncUuid) {
            Return = NdrpDcomAsyncClientCall(ProxyInfo->pStubDesc,
                                             ProcFormat,
                                             (PUCHAR)ParamAddress);

        } else {
            Return = NdrpClientCall2(ProxyInfo->pStubDesc,
                                     ProcFormat,
                                     (PUCHAR)ParamAddress);
        }

    } else {
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
    }

    return (long)Return.Simple;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\daytona\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation
#
# Build wxndr20.lib from rpcndr20.lib. We need to remove all objects that
# have functions that are thunked (ie, under EXPORT_RT in rpcrt4.src) and
# not emulated.
$(O)\wxndr20.lib: $(O)\rpcndr20.lib
    lib /remove:$(O)\rpcssm.obj /out:$@ $?
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\i386\forward.c ===
/*++

  Copyright  c  1994  Microsoft Corporation.  All rights reserved.

  Module Name:
     forward.c

  Abstract:
     This module implements the proxy forwarding functions.

  Author:
    ShannonC    26-Oct-94

  Environment:                     
   
     Any mode.
  Revision History:

--*/

#define STDMETHODCALLTYPE __stdcall
/*++

 VOID
 NdrProxyForwardingFunction<nnn>(...)

 Routine Description:

    This function forwards a call to the proxy for the base interface.

 Arguments:

    This [esp+4] - Points to an interface proxy.

 Return Value:

    None.

--*/

// Here is what a forwarder looks like
// we must:
//      change the "this" pointer in [esp+4] to point to the delegated object
//      fetch the correct entry from the vtable
//      call the function

#define SUBCLASS_OFFSET     16
#define VTABLE_ENTRY(n)     n*4

// Stop the C++ compiler from adding additional push instructions
// as well as generating the return sequence for the forwarder
// and so messing up our assembly stack when using -Od, etc.
// by using the _declspec().

#define DELEGATION_FORWARDER(method_num)        \
_declspec(naked) \
void STDMETHODCALLTYPE NdrProxyForwardingFunction##method_num() \
{ \
    /*Get this->pBaseProxy */ \
    __asm{mov   eax,  [esp + 4]} \
    __asm{mov   eax,  [eax + SUBCLASS_OFFSET]} \
    __asm{mov   [esp + 4], eax} \
    /*Get this->pBaseProxy->lpVtbl*/ \
    __asm{mov   eax,  [eax]} \
    /*Jump to interface member function*/ \
    __asm{mov   eax,  [eax + VTABLE_ENTRY(method_num)]} \
    __asm{jmp   eax} \
}

    DELEGATION_FORWARDER(3)

    DELEGATION_FORWARDER(4)

    DELEGATION_FORWARDER(5)

    DELEGATION_FORWARDER(6)

    DELEGATION_FORWARDER(7)
    
    DELEGATION_FORWARDER(8)
    
    DELEGATION_FORWARDER(9)
    
    DELEGATION_FORWARDER(10)
    
    DELEGATION_FORWARDER(11)
    
    DELEGATION_FORWARDER(12)
    
    DELEGATION_FORWARDER(13)
    
    DELEGATION_FORWARDER(14)
    
    DELEGATION_FORWARDER(15)
    
    DELEGATION_FORWARDER(16)
    
    DELEGATION_FORWARDER(17)
    
    DELEGATION_FORWARDER(18)
    
    DELEGATION_FORWARDER(19)
    
    DELEGATION_FORWARDER(20)
    
    DELEGATION_FORWARDER(21)
    
    DELEGATION_FORWARDER(22)
    
    DELEGATION_FORWARDER(23)
    
    DELEGATION_FORWARDER(24)
    
    DELEGATION_FORWARDER(25)
    
    DELEGATION_FORWARDER(26)
    
    DELEGATION_FORWARDER(27)
    
    DELEGATION_FORWARDER(28)
    
    DELEGATION_FORWARDER(29)
    
    DELEGATION_FORWARDER(30)
    
    DELEGATION_FORWARDER(31)
    
    DELEGATION_FORWARDER(32)
    
    DELEGATION_FORWARDER(33)
    
    DELEGATION_FORWARDER(34)
    
    DELEGATION_FORWARDER(35)
    
    DELEGATION_FORWARDER(36)
    
    DELEGATION_FORWARDER(37)
    
    DELEGATION_FORWARDER(38)
    
    DELEGATION_FORWARDER(39)
    
    DELEGATION_FORWARDER(40)
    
    DELEGATION_FORWARDER(41)
    
    DELEGATION_FORWARDER(42)
    
    DELEGATION_FORWARDER(43)
    
    DELEGATION_FORWARDER(44)
    
    DELEGATION_FORWARDER(45)
    
    DELEGATION_FORWARDER(46)
    
    DELEGATION_FORWARDER(47)
    
    DELEGATION_FORWARDER(48)
    
    DELEGATION_FORWARDER(49)
    
    DELEGATION_FORWARDER(50)
    
    DELEGATION_FORWARDER(51)
    
    DELEGATION_FORWARDER(52)
    
    DELEGATION_FORWARDER(53)
    
    DELEGATION_FORWARDER(54)
    
    DELEGATION_FORWARDER(55)
    
    DELEGATION_FORWARDER(56)
    
    DELEGATION_FORWARDER(57)
    
    DELEGATION_FORWARDER(58)
    
    DELEGATION_FORWARDER(59)
    
    DELEGATION_FORWARDER(60)
    
    DELEGATION_FORWARDER(61)
    
    DELEGATION_FORWARDER(62)
    
    DELEGATION_FORWARDER(63)
    
    DELEGATION_FORWARDER(64)
    
    DELEGATION_FORWARDER(65)
    
    DELEGATION_FORWARDER(66)
    
    DELEGATION_FORWARDER(67)
    
    DELEGATION_FORWARDER(68)
    
    DELEGATION_FORWARDER(69)
    
    DELEGATION_FORWARDER(70)
    
    DELEGATION_FORWARDER(71)
    
    DELEGATION_FORWARDER(72)
    
    DELEGATION_FORWARDER(73)
    
    DELEGATION_FORWARDER(74)
    
    DELEGATION_FORWARDER(75)
    
    DELEGATION_FORWARDER(76)
    
    DELEGATION_FORWARDER(77)
    
    DELEGATION_FORWARDER(78)
    
    DELEGATION_FORWARDER(79)
    
    DELEGATION_FORWARDER(80)
    
    DELEGATION_FORWARDER(81)
    
    DELEGATION_FORWARDER(82)
    
    DELEGATION_FORWARDER(83)
    
    DELEGATION_FORWARDER(84)
    
    DELEGATION_FORWARDER(85)
    
    DELEGATION_FORWARDER(86)
    
    DELEGATION_FORWARDER(87)
    
    DELEGATION_FORWARDER(88)
    
    DELEGATION_FORWARDER(89)
    
    DELEGATION_FORWARDER(90)
    
    DELEGATION_FORWARDER(91)
    
    DELEGATION_FORWARDER(92)
    
    DELEGATION_FORWARDER(93)
    
    DELEGATION_FORWARDER(94)
    
    DELEGATION_FORWARDER(95)
    
    DELEGATION_FORWARDER(96)
    
    DELEGATION_FORWARDER(97)
    
    DELEGATION_FORWARDER(98)
    
    DELEGATION_FORWARDER(99)
    
    DELEGATION_FORWARDER(100)
    
    DELEGATION_FORWARDER(101)
    
    DELEGATION_FORWARDER(102)
    
    DELEGATION_FORWARDER(103)
    
    DELEGATION_FORWARDER(104)
    
    DELEGATION_FORWARDER(105)
    
    DELEGATION_FORWARDER(106)
    
    DELEGATION_FORWARDER(107)
    
    DELEGATION_FORWARDER(108)
    
    DELEGATION_FORWARDER(109)
    
    DELEGATION_FORWARDER(110)
    
    DELEGATION_FORWARDER(111)
    
    DELEGATION_FORWARDER(112)
    
    DELEGATION_FORWARDER(113)
    
    DELEGATION_FORWARDER(114)
    
    DELEGATION_FORWARDER(115)
    
    DELEGATION_FORWARDER(116)
    
    DELEGATION_FORWARDER(117)
    
    DELEGATION_FORWARDER(118)
    
    DELEGATION_FORWARDER(119)
    
    DELEGATION_FORWARDER(120)
    
    DELEGATION_FORWARDER(121)
    
    DELEGATION_FORWARDER(122)
    
    DELEGATION_FORWARDER(123)
    
    DELEGATION_FORWARDER(124)
    
    DELEGATION_FORWARDER(125)
    
    DELEGATION_FORWARDER(126)
    
    DELEGATION_FORWARDER(127)
    

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\unmrshl.cxx ===
/**********************************************************************

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    unmrshl.cxx

Abstract :

    This file contains the unmarshalling routines called by MIDL generated
    stubs and the interpreter.

Author :

    David Kays  dkays   September 1993.

Revision History :

  **********************************************************************/

#include "ndrp.h"
#include "hndl.h"
#include "ndrole.h"
#include "attack.h"
#include "pointerq.h"

unsigned char * RPC_ENTRY
NdrUDTSimpleTypeUnmarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned char * *   ppMemory,
    PFORMAT_STRING      pFormat,
    unsigned char       fMustAlloc
    );


//
// Function table of unmarshalling routines.
//
extern const
PUNMARSHALL_ROUTINE UnmarshallRoutinesTable[] =
                    {
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,
                    NdrUDTSimpleTypeUnmarshall1,

                    NdrPointerUnmarshall,
                    NdrPointerUnmarshall,
                    NdrPointerUnmarshall,
                    NdrPointerUnmarshall,

                    NdrSimpleStructUnmarshall,
                    NdrSimpleStructUnmarshall,
                    NdrConformantStructUnmarshall,
                    NdrConformantStructUnmarshall,
                    NdrConformantVaryingStructUnmarshall,

                    NdrComplexStructUnmarshall,

                    NdrConformantArrayUnmarshall,
                    NdrConformantVaryingArrayUnmarshall,
                    NdrFixedArrayUnmarshall,
                    NdrFixedArrayUnmarshall,
                    NdrVaryingArrayUnmarshall,
                    NdrVaryingArrayUnmarshall,

                    NdrComplexArrayUnmarshall,

                    NdrConformantStringUnmarshall,
                    NdrConformantStringUnmarshall,
                    NdrConformantStringUnmarshall,
                    NdrConformantStringUnmarshall,

                    NdrNonConformantStringUnmarshall,
                    NdrNonConformantStringUnmarshall,
                    NdrNonConformantStringUnmarshall,
                    NdrNonConformantStringUnmarshall,

                    NdrEncapsulatedUnionUnmarshall,
                    NdrNonEncapsulatedUnionUnmarshall,

                    NdrByteCountPointerUnmarshall,

                    NdrXmitOrRepAsUnmarshall,  // transmit as
                    NdrXmitOrRepAsUnmarshall,  // represent as

                    NdrPointerUnmarshall,

                    NdrUnmarshallHandle,

                    // New Post NT 3.5 tokens serviced from here on.

                    0,   // FC_HARD_STRUCT     // NdrHardStructUnmarshall,

                    NdrXmitOrRepAsUnmarshall,  // transmit as ptr
                    NdrXmitOrRepAsUnmarshall,  // represent as ptr

                    NdrUserMarshalUnmarshall,

                    0,   // FC_PIPE
                    0,   // FC_BLK_HOLE

                    NdrRangeUnmarshall,
                
                    0,   // FC_INT3264
                    0,   // FC_UINT3264

                    0, // NdrCsArrayUnmarshall,
                    0, // NdrCsTagUnmarshall

                    };

extern const
PUNMARSHALL_ROUTINE * pfnUnmarshallRoutines = UnmarshallRoutinesTable;

RPCRTAPI
unsigned char * RPC_ENTRY
NdrTypeUnmarshall( PMIDL_STUB_MESSAGE pStubMsg,
                   uchar **           ppMemory,
                   PFORMAT_STRING     pFormat,
                   uchar              fMustAlloc )
{
    return 
    (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                       ppMemory,
                                                       pFormat,
                                                       fMustAlloc );
}

__inline unsigned char * RPC_ENTRY
NdrUDTSimpleTypeUnmarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               /* fSkipRefCheck */)
{
    NdrSimpleTypeUnmarshall(pStubMsg,*ppMemory,*pFormat);
    return NULL;
}

void 
NdrpInterfacePointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat );


void RPC_ENTRY
NdrSimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    uchar               FormatChar )
/*++

Routine Description :

    Unmarshalls a simple type.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Memory pointer to unmarshall into.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
    switch ( FormatChar )
        {
        case FC_CHAR :
        case FC_BYTE :
        case FC_SMALL :
        case FC_USMALL :
            *pMemory = *(pStubMsg->Buffer)++;
            break;

        case FC_ENUM16 :
            *((ulong *)pMemory) &= 0x0000ffff;

            // fall through...

        case FC_WCHAR :
        case FC_SHORT :
        case FC_USHORT :
            ALIGN(pStubMsg->Buffer,1);

            *((ushort *)pMemory) = *((ushort * &)pStubMsg->Buffer)++;
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
            ALIGN(pStubMsg->Buffer,3);
            // sign exted long to __int64
            *((__int64 *)pMemory) = *((long * &)pStubMsg->Buffer)++;
            break;

        case FC_UINT3264:
            ALIGN(pStubMsg->Buffer,3);

            *((unsigned __int64 *)pMemory) = *((ulong * &)pStubMsg->Buffer)++;
            break;
#endif

        case FC_LONG :
        case FC_ULONG :
        case FC_FLOAT :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);

            *((ulong *)pMemory) = *((ulong * &)pStubMsg->Buffer)++;
            break;

        case FC_HYPER :
        case FC_DOUBLE :
            ALIGN(pStubMsg->Buffer,7);

            //
            // Let's stay away from casts to doubles.
            //
            *((ulong *)pMemory) = *((ulong * &)pStubMsg->Buffer)++;
            *((ulong *)(pMemory + 4)) = *((ulong * &)pStubMsg->Buffer)++;
            break;

        case FC_IGNORE :
            break;

        default :
            NDR_ASSERT(0,"NdrSimpleTypeUnmarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}


unsigned char * RPC_ENTRY
NdrRangeUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++
    Unmarshals a range FC_RANGE descriptor.
--*/
{
     FORMAT_CHARACTER   FcType = (FORMAT_CHARACTER)(pFormat[1] & 0xf);
     NDR_DEF_FC_RANGE * pRange = (NDR_DEF_FC_RANGE *)pFormat;
     uchar *        pMemory;
     long               Value;
     unsigned long      Low, High;

     ALIGN( pStubMsg->Buffer, SIMPLE_TYPE_ALIGNMENT( FcType ) ); 
     CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + SIMPLE_TYPE_BUFSIZE(FcType )  );
     
    if ( fMustAlloc )
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, SIMPLE_TYPE_MEMSIZE(FcType) );
    else
        {
        if (REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            *ppMemory = pStubMsg->Buffer;
        else if ( ppMemory == NULL )
            {
            NDR_ASSERT(0, "invalid range memory\n");
            }
        }
     pMemory= *ppMemory;

     switch ( FcType )
     {
        case FC_CHAR :
        case FC_BYTE :
        case FC_USMALL :
            Value = *pMemory = *(pStubMsg->Buffer)++;
            break;

        case FC_SMALL :
            Value = *(small *)pMemory = *(small *)(pStubMsg->Buffer)++;
            break;

        case FC_ENUM16 :
            Value = *((ulong *)pMemory) &= 0x0000ffff;

            // fall through...

        case FC_WCHAR :
        case FC_USHORT :
            ALIGN(pStubMsg->Buffer,1);
            Value = *((ushort *)pMemory) = *((ushort * &)pStubMsg->Buffer)++;
            break;

        case FC_SHORT :
            ALIGN(pStubMsg->Buffer,1);
            Value = *((short *)pMemory) = *((short * &)pStubMsg->Buffer)++;
            break;

        case FC_ULONG :
        case FC_ENUM32 :
        case FC_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);
            Value = *((ulong *)pMemory) = *((ulong * &)pStubMsg->Buffer)++;
            break;

        case FC_LONG :
            ALIGN(pStubMsg->Buffer,3);
            Value = *((long *)pMemory) = *((long * &)pStubMsg->Buffer)++;
            break;

//        case FC_IGNORE :
//        case FC_FLOAT :
//        case FC_HYPER :
//        case FC_DOUBLE :
//        case FC_INT3264 :
//        case FC_UINT3264 :
        default :
            NDR_ASSERT(0,"NdrSimpleTypeUnmarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
     }

     Low  = *(unsigned long UNALIGNED *)(pFormat + 2);
     High = *(unsigned long UNALIGNED *)(pFormat + 6);

     if ( FcType == FC_ULONG )
         {
         if ( (ulong)Value < Low  ||  (ulong)Value > High )
             RpcRaiseException( RPC_X_INVALID_BOUND );
         }
     else
         if ( Value < (long)Low  ||  Value > (long)High )
             RpcRaiseException( RPC_X_INVALID_BOUND );

    return 0;
}


unsigned char * RPC_ENTRY
NdrPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               /*fSkipRefCheck*/ )
/*++

Routine Description :

    Unmarshalls a top level pointer to anything.  Pointers embedded in
    structures, arrays, or unions call NdrpPointerUnmarshall directly.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg        - Pointer to the stub message.
    ppMemory        - Double pointer to where to unmarshall the pointer.
    pFormat         - Pointer's format string description.
    fSkipRefCheck   - This is for cases like [in,out] unique to unique to ref 
                      pointer or unique to unique to structure with embedded
                      ref pointer. Client pass in NULL and server allocate some
                      memory back. The flag is set when fPointerAlloc is true
                      in NdrpPointerUnmarshall.
                      In fact, we probably should skip the check for all the
                      ref pointer from fPointerAlloc. So we add a new flag in
                      pStubMsg->uFlag

Return :

    None.

--*/
{
    //
    // If the pointer is not a ref pointer then get a pointer to it's
    // incomming value's location in the buffer.  If it's a ref then set
    // up some stack space to temporarily act as the buffer.
    //
    long * pBufferPointer;
    if ( *pFormat != FC_RP )
        {
        ALIGN( pStubMsg->Buffer, 3 );
        pBufferPointer = (long*)pStubMsg->Buffer;
        pStubMsg->Buffer += PTR_WIRE_SIZE;
        }
    else
        {
        //
        // If we're on the client unmarshalling a top level [out] ref pointer,
        // we have to make sure that it is non-null.
        //
        if ( pStubMsg->IsClient && 
             !IS_SKIP_REF_CHECK( pStubMsg->uFlags )  && 
             ! *ppMemory )
            RpcRaiseException( RPC_X_NULL_REF_POINTER );

        //
        // Do this so unmarshalling ref pointers works the same as
        // unmarshalling unique and ptr pointers.
        //
        pBufferPointer = NULL;
        }

    NdrpPointerUnmarshall( pStubMsg,
                           ppMemory,
                           *ppMemory,
                           pBufferPointer,
                           pFormat );
    return 0;
}

void
NdrpFreeOlePointer(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar             *pMemory,
    PFORMAT_STRING     pFormat )
{
    NDR_POINTER_QUEUE *pOldQueue;
    if ( pStubMsg->pPointerQueueState )
        {
        pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
        pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
        }

    RpcTryFinally
        {
        NdrPointerFree( pStubMsg,
                        pMemory,
                        pFormat );                    
        }
    RpcFinally
        {
        if (pStubMsg->pPointerQueueState)
            {
            pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
            }
        }
    RpcEndFinally

}

NDR_ALLOC_ALL_NODES_CONTEXT *
NdrpGetAllocateAllNodesContext(
    PMIDL_STUB_MESSAGE pStubMsg,
    PFORMAT_STRING     pFormat )
{
    uchar *pBuffer = pStubMsg->Buffer;

    // Clear memory size before calling mem size routine.
    pStubMsg->MemorySize = 0;

    //
    // Get the allocate all nodes memory size. Need to make sure
    // all the pointee as finished before continuing
    //
    {
        NDR_POINTER_QUEUE *pOldQueue;
        if ( pStubMsg->pPointerQueueState )
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormat)])
                ( pStubMsg,
                  pFormat );
            }
        RpcFinally
            {
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally

    }

    pStubMsg->Buffer = pBuffer;

    ulong AllocSize = pStubMsg->MemorySize;
    pStubMsg->MemorySize = 0;
    LENGTH_ALIGN( AllocSize, __alignof(NDR_ALLOC_ALL_NODES_CONTEXT) - 1);

    uchar *pAllocMemory = 
        (uchar*)NdrAllocate( pStubMsg, AllocSize + sizeof(NDR_ALLOC_ALL_NODES_CONTEXT) );

    NDR_ALLOC_ALL_NODES_CONTEXT *pAllocContext = 
        (NDR_ALLOC_ALL_NODES_CONTEXT*)(pAllocMemory + AllocSize);
    pAllocContext->AllocAllNodesMemory      = pAllocMemory;
    pAllocContext->AllocAllNodesMemoryBegin = pAllocMemory;
    pAllocContext->AllocAllNodesMemoryEnd   = (uchar*)pAllocContext;
    
    return pAllocContext;
}


__forceinline void
NdrpPointerUnmarshallInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,       // Where allocated pointer is written
    uchar *             pMemory,
    long  *             pBufferPointer, // Pointer to the wire rep.
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Private routine for unmarshalling a pointer to anything.  This is the
    entry point for pointers embedded in structures, arrays, and unions.

    Used for FC_RP, FC_UP, FC_FP, FC_OP.

Arguments :

    pStubMsg        - Pointer to the stub message.
    ppBufferPointer - Address of the location in the buffer which holds the
                      incomming pointer's value and will hold the final
                      unmarshalled pointer's value.
    pMemory         - Current memory pointer's value which we want to
                      unmarshall into.  If this value is valid the it will
                      be copied to *ppBufferPointer and this is where stuff
                      will get unmarshalled into.
    pFormat         - Pointer's format string description.

    pStubMsg->Buffer - set to the pointee.

Return :

    None.

--*/
{
    ulong       FullPtrRefId;
    uchar       fPointeeAlloc;
    int         fNewAllocAllNodes;
    int         fNewDontFreeContext;
    uchar       uFlagsSave;

    fNewAllocAllNodes = FALSE;
    fNewDontFreeContext = FALSE;

    // we need to have a check here for pointer embedded in a struct, 
    // or pointer to pointer case. 
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );
    //
    // Check the pointer type.
    //
    switch ( *pFormat )
        {
        case FC_RP :
            break;

        case FC_IP :
            // On the client side, release the [in,out] interface pointer.

            if ( IS_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags ) )
                {
                NdrInterfacePointerUnmarshall( pStubMsg,
                                               ppMemory,
                                               pFormat,
                                               true );
                return;
                }

            if ((pStubMsg->IsClient == TRUE) && (pMemory != 0))
                {
                ((IUnknown*)pMemory)->Release();
                *ppMemory = NULL ;
                }
            
            if ( !*pBufferPointer ) 
                {
                *ppMemory = NULL;
                return;
                }
                
            NdrpInterfacePointerUnmarshall( pStubMsg,
                                            ppMemory,
                                            pFormat );

            if ( pBufferPointer ) *pBufferPointer = UNMARSHAL_PTR_WIRE_REP(*ppMemory);

            return;

        case FC_OP :
            //
            // Burn some instructions for OLE unique pointer support.
            //
            if ( pStubMsg->IsClient )
                {
                //
                // It's ok if this is an [out] unique pointer.  It will get
                // zeroed before this routine is called and NdrPointerFree
                // will simply return. Need to finish all the pointees before
                // continueing.
                
                NdrpFreeOlePointer( 
                    pStubMsg,
                    pMemory,
                    pFormat);

                // Set the current memory pointer to 0 so that we'll alloc.
                pMemory = 0;
                }

            // Fall through.

        case FC_UP :
            //
            // Check for a null incomming pointer.  Routines which call this
            // routine insure that the memory pointer gets nulled.
            //
            if ( ! *pBufferPointer )
                {
                *ppMemory = NULL;
                return;
                }

            break;

        case FC_FP :
            //
            // We have to remember the incomming ref id because we overwrite
            // it during the QueryRefId call.
            //
            FullPtrRefId = *pBufferPointer;

            // we couldn't pass pBufferPointer to QueryRefId because it's 4bytes
            // on wire but 8bytes on 64bit. (and it'll have mix alignment issue)
            if ( 0 == FullPtrRefId )
                {
                *ppMemory = NULL;
                return;
                }
            //
            // Lookup the ref id.
            //
            if ( NdrFullPointerQueryRefId( pStubMsg->FullPtrXlatTables,
                                           FullPtrRefId,
                                           FULL_POINTER_UNMARSHALLED,
                                           (void**)ppMemory) )
                {
                // true means the RefId had been unmarshalled.
                *pBufferPointer = UNMARSHAL_PTR_WIRE_REP( *ppMemory );
                return;
                }

            //
            // If our query returned false then check if the returned pointer
            // is 0.  If so then we have to scribble away the ref id in the
            // stub message FullPtrRefId field so that we can insert the
            // pointer translation later, after we've allocated the pointer.
            // If the returned pointer was non-null then we leave the stub
            // message FullPtrRefId field alone so that we don't try to
            // re-insert the pointer to ref id translation later.
            //
            // We also copy the returned pointer value into pMemory.  This
            // will allow our allocation decision to be made correctly.
            //
            pMemory = *ppMemory;
            if ( !pMemory )
                {
                //
                // Put the unmarshalled ref id into the stub message to
                // be used later in a call to NdrFullPointerInsertRefId.
                //
                pStubMsg->FullPtrRefId = FullPtrRefId;
                }

            break;

        default :
            NDR_ASSERT(0,"NdrpPointerUnmarshall : bad pointer type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Make the initial "must allocate" decision.
    //
    // The fPointeeAlloc flag is set on the client side if the current memory
    // pointer is null, and on the server side it is set if the current memory
    // pointer has the allocate don't free attribute applied to it.
    //
    // On the client side we also set the pointer's value in the buffer equal
    // to the current memory pointer.
    //
    // On the server side we explicitly null out the pointer's value in the
    // buffer as long as it's not allocated on the stack, otherwise we set it
    // equal to the current memory pointer (stack allocated).
    //
    if ( pStubMsg->IsClient )
        {
        *ppMemory = pMemory;

        fPointeeAlloc = ! pMemory;
        }
    else
        {
        if ( ! ALLOCED_ON_STACK(pFormat[1]) )
            *ppMemory = 0;
        else
            *ppMemory = pMemory;

        //
        // If this is a don't free pointer or a parent pointer of this pointer
        // was a don't free pointer then we set the alloc flag.
        //
        if ( fPointeeAlloc = (DONT_FREE(pFormat[1]) 
                             || pStubMsg->ReuseBuffer 
                             || pStubMsg->fInDontFree) )
            {
            //
            // If we encounter a don't free pointer which is not nested inside
            // of another don't free pointer then set the local and stub message
            // flags.
            //
            if ( ! pStubMsg->fInDontFree )
                {
                fNewDontFreeContext = TRUE;
                pStubMsg->fInDontFree = TRUE;
                }
            }

        //
        // We also set the alloc flag for object interface pointers.
        //
        if ( *pFormat == FC_OP )
            fPointeeAlloc = TRUE;

        }

    //
    // Pointer to complex type.
    //
    if ( ! SIMPLE_POINTER(pFormat[1]) )
        {
        PFORMAT_STRING pFormatPointee;

        pFormatPointee = pFormat + 2;

        // Set the pointee format string.
        // Cast must be to a signed short since some offsets are negative.
        pFormatPointee += *((signed short *)pFormatPointee);

        //
        // Right now the server will always allocate for allocate all nodes
        // when told to.  Eventually we want to use the rpc buffer when
        // possible.
        //

        //
        // Check if this is an allocate all nodes pointer AND that we're
        // not already in an allocate all nodes context.
        //
        if ( ALLOCATE_ALL_NODES(pFormat[1]) && ! pStubMsg->pAllocAllNodesContext )
            {
            fNewAllocAllNodes = TRUE;

            pStubMsg->pAllocAllNodesContext =
                NdrpGetAllocateAllNodesContext(
                    pStubMsg,
                    pFormatPointee );

            *ppMemory = 0;

            fPointeeAlloc = TRUE;

            //
            // I think this is what we'll have to add to support an [in,out]
            // allocate all nodes full pointer ([in] only and [out] only
            // allocate all nodes full pointer shouldn't need any special
            // treatment).
            //
            // if ( *pFormat == FC_FP )
            //     {
            //     pStubMsg->FullPtrRefId = FullPtrRefId;
            //     }
            //
            }

        if ( POINTER_DEREF(pFormat[1]) )
            {
            //
            // Re-align the buffer.  This is to cover embedded pointer to
            // pointers.
            //
            ALIGN(pStubMsg->Buffer,0x3);

            //
            // We can't re-use the buffer for a pointer to a pointer
            // because we can't null out the pointee before we've unmarshalled
            // it.  We need the stubs to alloc pointers to pointers on the
            // stack.
            //
            if ( ! *ppMemory && ! pStubMsg->IsClient )
                fPointeeAlloc = TRUE;

            if ( fPointeeAlloc )
                {
                *ppMemory = (uchar*)NdrAllocate( pStubMsg, PTR_MEM_SIZE );
                *((void **)*ppMemory) = 0;
                }

            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );

            if ( pBufferPointer ) 
                *pBufferPointer = UNMARSHAL_PTR_WIRE_REP(*ppMemory);

            pBufferPointer = 0;
            ppMemory = (uchar**)*ppMemory;
            }

        //
        // Now call the proper unmarshalling routine.
        //
        uFlagsSave = pStubMsg->uFlags;
        RESET_CONF_FLAGS_TO_STANDALONE(pStubMsg->uFlags);
        if ( fPointeeAlloc )
            SET_SKIP_REF_CHECK( pStubMsg->uFlags );

        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatPointee)])
        ( pStubMsg,
          ppMemory,
          pFormatPointee,
          fPointeeAlloc );

        pStubMsg->uFlags = uFlagsSave;

        if ( *pFormatPointee == FC_USER_MARSHAL )
            {
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );
            }

        goto PointerUnmarshallEnd;
        }

    //
    // Else handle a pointer to a simple type, pointer, or string.
    //

    switch ( pFormat[2] )
        {
        case FC_C_CSTRING :
        case FC_C_BSTRING :
        case FC_C_WSTRING :
        case FC_C_SSTRING :
            NdrConformantStringUnmarshall( pStubMsg,
                                           ppMemory,
                                           &pFormat[2],
                                           fPointeeAlloc );
            goto PointerUnmarshallEnd;

        default :
            // Break to handle a simple type.
            break;
        }

    //
    // Handle pointers to simple types.
    //

    //
    // Align the buffer.
    //
    ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(pFormat[2]));

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + SIMPLE_TYPE_BUFSIZE(pFormat[2]) );
    
    //
    // We can't use the buffer for pointers to enum16 since these force
    // us to zero out the upper 16 bits of the memory pointer, and this
    // might overwrite data in the buffer that we still need!
    // Similar thing happens for int3264 values.
    //
    if ( pFormat[2] == FC_ENUM16
       #if defined(__RPC_WIN64__)
         ||  pFormat[2] == FC_INT3264  ||  pFormat[2] == FC_UINT3264
       #endif
       )
        {
        if ( ! pStubMsg->IsClient && ! *ppMemory )
            fPointeeAlloc = TRUE;
        }

    //
    // Check for allocation or buffer reuse.
    //
    if ( fPointeeAlloc )
        {
        *ppMemory = 
            (uchar*)NdrAllocate( pStubMsg,
                                 SIMPLE_TYPE_MEMSIZE(pFormat[2]) );
        }
    else
        {
        if ( ! pStubMsg->IsClient && ! *ppMemory )
            {
            // Set pointer into buffer.
            *ppMemory = pStubMsg->Buffer;
            }
        }

    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    //
    // We always get here for simple types.  What this means is that
    // when we reuse the buffer on the server side we end up copying the
    // data with source and destination memory pointer equal.  But this
    // way we can cover the enum and error_status_t cases without duplicating
    // a lot of code.
    //
    NdrSimpleTypeUnmarshall( pStubMsg,
                             *ppMemory,
                             pFormat[2] );

PointerUnmarshallEnd:

    if ( fNewDontFreeContext )
        pStubMsg->fInDontFree = FALSE;

    if ( pBufferPointer ) 
        *pBufferPointer = UNMARSHAL_PTR_WIRE_REP(*ppMemory);

    if ( fNewAllocAllNodes )
        pStubMsg->pAllocAllNodesContext = 0;
}



NDR_UNMRSHL_POINTER_QUEUE_ELEMENT::NDR_UNMRSHL_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar **           ppMemoryNew,      
    uchar *            pMemoryNew,
    long  *            pBufferPointerNew,
    PFORMAT_STRING     pFormatNew ) :

        ppMemory(ppMemoryNew),
        pMemory(pMemoryNew),
        pBufferPointer(pBufferPointerNew),
        pFormat(pFormatNew),
        Memory(pStubMsg->Memory),
        uFlags(pStubMsg->uFlags),
        fInDontFree( pStubMsg->fInDontFree ),
        pAllocAllNodesContext( pStubMsg->pAllocAllNodesContext ),
        pCorrMemory( pStubMsg->pCorrMemory )
{

}

void 
NDR_UNMRSHL_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar*> MemorySave( pStubMsg->Memory, Memory );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    NDR_ASSERT( !pStubMsg->PointerBufferMark, "PointerBufferMark is not 0\n");
    int fInDontFreeSave = pStubMsg->fInDontFree;
    pStubMsg->fInDontFree = fInDontFree;
    SAVE_CONTEXT<uchar*> pCorrMemorySave(pStubMsg->pCorrMemory, pCorrMemory );
    SAVE_CONTEXT<NDR_ALLOC_ALL_NODES_CONTEXT *> 
        AllNodesContextSave(pStubMsg->pAllocAllNodesContext, pAllocAllNodesContext); 
    
    NdrpPointerUnmarshallInternal( pStubMsg,
                                   ppMemory,
                                   pMemory,
                                   pBufferPointer,
                                   pFormat );

    pStubMsg->fInDontFree = fInDontFreeSave;
}

#if defined(DBG)
void 
NDR_UNMRSHL_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("ppMemory:                %p\n", ppMemory );
    DbgPrint("pBufferPointer:          %p\n", pBufferPointer );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("Memory:                  %p\n", Memory );
    DbgPrint("uFlags:                  %x\n", uFlags );
    DbgPrint("fInDontFree:             %u\n", fInDontFree );
    DbgPrint("pAllocAllNodesContext:   %p\n", pAllocAllNodesContext );
    DbgPrint("pCorrMemorySave:         %p\n", pCorrMemory );
}
#endif

void
NdrpEnquePointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,       // Where allocated pointer is written
    uchar *             pMemory,
    long  *             pBufferPointer, // Pointer to the wire rep.
    PFORMAT_STRING      pFormat )
{
    NDR32_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        NDR_UNMRSHL_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR_UNMRSHL_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                  ppMemory,
                                                  pMemory,
                                                  pBufferPointer,
                                                  pFormat );
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally
}

void
NdrpPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,       // Where allocated pointer is written
    uchar *             pMemory,
    long  *             pBufferPointer, // Pointer to the wire rep.
    PFORMAT_STRING      pFormat )
{
    if ( !NdrIsLowStack( pStubMsg ) )
        {
        NdrpPointerUnmarshallInternal( 
            pStubMsg,
            ppMemory,
            pMemory,
            pBufferPointer,
            pFormat );

        return;
        }

    NdrpEnquePointerUnmarshall(
        pStubMsg,
        ppMemory,
        pMemory,
        pBufferPointer,
        pFormat );
}


unsigned char * RPC_ENTRY
NdrSimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a simple structure.

    Used for FC_STRUCT and FC_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to the structure being unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - TRUE if the structure must be allocate, FALSE otherwise.

--*/
{
    uchar *     pBufferSave;
    uint        StructSize;

    CORRELATION_RESOURCE_SAVE;

    // Align the buffer.
    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Increment to the struct size field.
    pFormat += 2;

    // Get struct size and increment.
    StructSize = (ulong) *((ushort * &)pFormat)++;

    // Remember the current buffer position for the struct copy later.
    pBufferSave = pStubMsg->Buffer;

    // Set BufferMark to the beginning of the struct in the buffer.
    pStubMsg->BufferMark = pBufferSave;

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + StructSize );

    // Increment Buffer past struct data.
    pStubMsg->Buffer += StructSize;

    // Initialize the memory pointer if needed.
    if ( fMustAlloc )
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, StructSize );
    else
        // we'll get rid of pStubMsg->ReuseBuffer given it's basically !IsClient now
        // we might set the flag again through compiler flag later on.
        if ( REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            *ppMemory = pBufferSave;

    SET_CORRELATION_MEMORY( pBufferSave );

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    // Unmarshall embedded pointers before copying the struct.
    if ( *pFormat == FC_PP )
        {
        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustAlloc );
        }

    // Copy the struct if we're not using the rpc buffer.
    if ( *ppMemory != pBufferSave )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferSave,
                        StructSize );
        }

    RESET_CORRELATION_MEMORY();

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a conformant structure.

    Used for FC_CSTRUCT and FC_CPSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - TRUE if the structure must be allocate, FALSE otherwise.

Return :

    None.

--*/
{
    uchar *         pBufferStart;
    PFORMAT_STRING  pFormatArray;
    uint            StructSize;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    CORRELATION_RESOURCE_SAVE;

    // Unmarshall the conformance count into the stub message.
    // Only a bogus struct can embed a conf struct; if so, ->BufferMark is set.

    if ( fIsEmbeddedStruct )
        pStubMsg->MaxCount = *((ulong *)pStubMsg->BufferMark);
    else
        {
        // Align the buffer for unmarshalling the conformance count.
        ALIGN(pStubMsg->Buffer,3);
        pStubMsg->MaxCount = *((ulong * &)pStubMsg->Buffer)++;
        }

    // Re-align the buffer
    ALIGN(pStubMsg->Buffer, pFormat[1]);

    // Increment format string to structure size field.
    pFormat += 2;

    // Get flat struct size and increment format string.
    StructSize = (ulong) *((ushort * &)pFormat)++;

    // Get the conformant array's description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    CHECK_EOB_RAISE_IB( pStubMsg->Buffer + StructSize );

    if ( F_CORRELATION_CHECK )
        {
        SET_CORRELATION_MEMORY( pStubMsg->Buffer + StructSize);

        NdrpCheckCorrelation( pStubMsg,
                              pStubMsg->MaxCount,
                              pFormatArray,
                              NDR_CHECK_CONFORMANCE );
        RESET_CORRELATION_MEMORY();
        }

    // Add the size of the conformant array to the structure size.
    // check for possible mulitplication overflow attack here.
    StructSize += MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount, *((ushort *)(pFormatArray + 2) ) );

    // Check the size and the buffer limit.
    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormatArray[4] & 0x0f );
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, StructSize );

    //
    // Remember where we're going to copy from.
    //
    pBufferStart = pStubMsg->Buffer;

    // Set stub message Buffer field to the end of the structure in the buffer.
    pStubMsg->Buffer += StructSize;

    // Increment pFormat past the array description
    pFormat += 2;

    // Initialize the memory pointer if needed.
    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, StructSize );
        }
    else
        if ( REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            *ppMemory = pBufferStart;

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    SET_CORRELATION_MEMORY( pBufferStart );

    // Unmarshall embedded pointers before copying the struct.
    if ( *pFormat == FC_PP )
        {
        //
        // Set BufferMark to the beginning of the structure in the buffer.
        //
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustAlloc );
        }

    // Copy the struct if we're not using the rpc buffer.
    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        StructSize );
        }

    RESET_CORRELATION_MEMORY();

    // Set the reverse flag to signal that the array has been unmarshaled.
    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantVaryingStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a structure which contains a conformant varying array.

    Used for FC_CVSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatArray;
    uchar *         pBufferStruct;
    uchar *         pBufferArray;
    uint            StructSize, ArrayCopySize, ArrayOffset;
    ulong           AllocationSize;
    ulong           Elements;
    uchar           Alignment;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );

    CORRELATION_RESOURCE_SAVE;

    IGNORED(fMustAlloc);

    // Save structure's alignment.
    Alignment = pFormat[1];

    // Increment format string to struct size field.
    pFormat += 2;

    // Get non-conformant struct size and increment format string.
    StructSize = (ulong) *((ushort * &)pFormat)++;

    // Get conformant varying array's description.
    pFormatArray = pFormat + *((signed short *)pFormat);

    AllocationSize = 0;

    // Conformant array size
    // Only a bogus struct can embed a conf struct; if so, ->BufferMark is set.

    if ( fIsEmbeddedStruct )
        Elements = *((ulong *)pStubMsg->BufferMark);
    else
        {
        // Align the buffer for conformance count unmarshalling.
        ALIGN(pStubMsg->Buffer,3);
        Elements = *((ulong * &)pStubMsg->Buffer)++;
        }

    // Check the size.
    if ( *pFormatArray == FC_CVARRAY )
        CHECK_BOUND( Elements, pFormatArray[4] & 0x0f );
    else
        if ( pFormatArray[1] == FC_STRING_SIZED )
            CHECK_BOUND( Elements, pFormatArray[2] & 0x0f );

    CHECK_EOB_RAISE_IB( pStubMsg->Buffer + StructSize );

    if ( F_CORRELATION_CHECK )
        {
        SET_CORRELATION_MEMORY( pStubMsg->Buffer + StructSize);

        NdrpCheckCorrelation( pStubMsg,
                              Elements,
                              pFormatArray,
                              NDR_CHECK_CONFORMANCE );
        RESET_CORRELATION_MEMORY();
        }

    //
    // For a conformant varying struct we ignore all allocation flags.
    // Memory must always be allocated on both client and server stubs
    // if the current memory pointer is null.
    //
    if ( ! *ppMemory )
        {
        AllocationSize = StructSize;
        ULONG ElementSize;

        if ( *pFormatArray == FC_CVARRAY )
            {
            // check for possible mulitplication overflow attack here.
            AllocationSize += MultiplyWithOverflowCheck( Elements, *((ushort *)(pFormatArray + 2)) );
            }
        else // must be a conformant string
            {
            if ( *pFormatArray != FC_C_WSTRING )
                AllocationSize += Elements;
            else
                {
                AllocationSize += MultiplyWithOverflowCheck( Elements, 2 );
                }
            }
        // do the real allocation after correlation checks.
        }

    // Align for the struct
    ALIGN(pStubMsg->Buffer,Alignment);

    // Remember where the structure starts in the buffer.
    pBufferStruct = pStubMsg->Buffer;

    // Mark the start of the structure in the buffer.
    pStubMsg->BufferMark = pStubMsg->Buffer;

    // Increment past the non-conformant part of the structure.
    //
    pStubMsg->Buffer += StructSize;

    // Align again for variance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    //
    // Get offset and actual count.  Put the actual count into the MaxCount
    // field of the stub message, where it is used if the array has pointers.
    //
    pStubMsg->Offset = ArrayOffset = *((ulong * &)pStubMsg->Buffer)++;
    ArrayCopySize = *((ulong * &)pStubMsg->Buffer)++;
    pStubMsg->MaxCount = ArrayCopySize;

    // Check the offset and lentgth.

    if ( *pFormatArray == FC_CVARRAY )
        {
        PFORMAT_STRING  pFormatVar = pFormatArray + 8;
        CORRELATION_DESC_INCREMENT( pFormatVar );

        CHECK_BOUND( ArrayOffset,   FC_LONG );
        CHECK_BOUND( ArrayCopySize, *pFormatVar & 0x0f );

       if ( F_CORRELATION_CHECK )
           {
           SET_CORRELATION_MEMORY( pBufferStruct + StructSize );  // at the end of the fixed part

           NdrpCheckCorrelation( pStubMsg,
                              (ulong)pStubMsg->MaxCount,    // yes, this is variance from above
                              pFormatArray,
                              NDR_CHECK_VARIANCE );
           NdrpCheckCorrelation( pStubMsg,
                              pStubMsg->Offset,
                              pFormatArray,
                              NDR_CHECK_OFFSET );
           RESET_CORRELATION_MEMORY();
            }
        }
    else
        // has to be strings here. check for invalid offset
        {
        if ( ArrayOffset != 0 )
            RpcRaiseException( RPC_X_INVALID_BOUND );
        }

    if ( (Elements < (ArrayOffset + ArrayCopySize)) )
        RpcRaiseException( RPC_X_INVALID_BOUND );


    SET_CORRELATION_MEMORY( pBufferStruct );

    // Remember where the array starts in the buffer.
    pBufferArray = pStubMsg->Buffer;

    // we don't need to check overflow for length_is and first_is: 
    // if size_is doesn't overflow, and size_is > length_is+first_is, neither of them can overflow.
    if ( *pFormatArray == FC_CVARRAY )
        {
        // Skip to array element size field.
        pFormatArray += 2;

        //
        // Compute the real offset (in bytes) from the beginning of the
        // array for the copy and the real total number of bytes to copy.
        //
        ArrayOffset = MultiplyWithOverflowCheck( ArrayOffset, *((ushort *)pFormatArray) );
        ArrayCopySize = MultiplyWithOverflowCheck( ArrayCopySize, *((ushort *)pFormatArray) );
        }
    else
        {
        ulong CharSize = 1;
        // Conformant string.

        if ( *pFormatArray == FC_C_WSTRING )
            {
            // Double the offset and copy size for wide char string.
            ArrayOffset = MultiplyWithOverflowCheck( ArrayOffset, sizeof(wchar_t) );
            ArrayCopySize = MultiplyWithOverflowCheck( ArrayCopySize, sizeof(wchar_t) );
            CharSize = sizeof(wchar_t);
            }

        if ( ArrayCopySize )
            {
            uchar * p;

            // Check if the terminator is there.
            for ( p = pStubMsg->Buffer + ArrayCopySize - CharSize;  CharSize--;  )
                {
                if ( *p++ != 0 )
                    RpcRaiseException( RPC_X_INVALID_BOUND );
                }
            }
        else    // cannot be zero here.
            {
            RpcRaiseException( RPC_X_INVALID_BOUND );            
            }
            
        }

    // Set the stub message Buffer field to the end of the array/string.
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, ArrayCopySize );
    pStubMsg->Buffer += ArrayCopySize;

    // Increment format string past offset to array description field.
    pFormat += 2;

    // allocate the memory after correlation checks. Should help avoid allocation in
    // early correlation.
    if ( AllocationSize != 0 )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, (uint) AllocationSize );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );


    //
    // Unmarshall embedded pointers before copying the struct.
    //
    if ( *pFormat == FC_PP )
        {
        pStubMsg->BufferMark = pBufferStruct;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       (uchar) (AllocationSize != 0) );
        }

    RESET_CORRELATION_MEMORY();

    //
    // Copy the array.  Make sure the destination memory pointer is at
    // the proper offset from the beginning of the array in memory.
    //
    RpcpMemoryCopy( *ppMemory,
                    pBufferStruct,
                    StructSize );

    RpcpMemoryCopy( *ppMemory + StructSize + ArrayOffset,
                    pBufferArray,
                    ArrayCopySize );
    // Set the reverse flag to signal that the array has been unmarshaled.

    if ( fIsEmbeddedStruct )
        SET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}


#if 0
unsigned char * RPC_ENTRY
NdrHardStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a hard structure.

    Used for FC_HARD_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar *     pUnion;
    uchar *     pEnum;
    BOOL        fNewMemory;
    ushort      CopySize;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    pFormat += 2;

    if ( fNewMemory = (! *ppMemory || fMustAlloc) )
        {
        //
        // Allocate if forced to, or if we have a union.
        //
        if ( fMustAlloc || *((short *)&pFormat[12]) )
            *ppMemory = (uchar *) NdrAllocate( pStubMsg, *((ushort *)pFormat) );
        else // pStubMsg->ReuseBuffer assumed
            *ppMemory = pStubMsg->Buffer;
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    pFormat += 8;

    CopySize = *((ushort *)pFormat);

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CopySize );

    if ( *ppMemory != pStubMsg->Buffer )
        {
        RpcpMemoryCopy( *ppMemory,
                        pStubMsg->Buffer,
                        CopySize );
        }

    //
    // Zero out the upper two bytes of enums!
    //
    if ( *((short *)&pFormat[-2]) != (short) -1 )
        {
        pEnum = *ppMemory + *((ushort *)&pFormat[-2]);
        *((int *)(pEnum)) = *((int *)pEnum) & ((int)0x7fff) ;
        }

    pStubMsg->Buffer += *((ushort *)pFormat)++;

    //
    // See if we have a union.
    //
    if ( *((short *)&pFormat[2]) )
        {
        pUnion = *ppMemory + *((ushort *)pFormat);

        if ( fNewMemory )
            MIDL_memset( pUnion,
                         0,
                         *((ushort *)&pFormat[-10]) - *((ushort *)pFormat) );

        pFormat += 2;

        pFormat += *((short *)pFormat);

        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormat)])( pStubMsg,
                                                           &pUnion,
                                                           pFormat,
                                                           FALSE );
        }

    return 0;
}
#endif // 0


unsigned char * RPC_ENTRY
NdrComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a complex structure.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar *         pBuffer;
    uchar *         pBufferMark;
    uchar *         pMemory;
    PFORMAT_STRING  pFormatPointers;
    PFORMAT_STRING  pFormatArray;
    PFORMAT_STRING  pFormatComplex;
    PFORMAT_STRING  pFormatSave;
    uint            StructSize;
    long            Alignment;
    long            Align8Mod;
    uchar           fIsEmbeddedStruct = IS_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    BOOL            fOldIgnore;
    BOOL            fSetPointerBufferMark;
    BOOL            fEmbedConfStructContext;


    CORRELATION_RESOURCE_SAVE;

    IGNORED(fMustAlloc);

    pFormatSave = pFormat;

    StructSize = 0;

    // Get structure's buffer alignment.
    Alignment = pFormat[1];

    // Increment to the conformat array offset field.
    pFormat += 4;

    // Get conformant array description.
    if ( *((ushort *)pFormat) )
        pFormatArray = pFormat + *((signed short *)pFormat);
    else
        pFormatArray = 0;

    pFormat += 2;

    // Get pointer layout description.
    if ( *((ushort *)pFormat) )
        pFormatPointers = pFormat + *((ushort *)pFormat);
    else
        pFormatPointers = 0;

    pFormat += 2;

    //
    // If the stub message PointerBufferMark field is not currently set, then
    // set it to the end of the flat part of structure in the buffer.
    //
    // We do this to handle embedded pointers.
    //
    if ( fSetPointerBufferMark = ! pStubMsg->PointerBufferMark )
        {
        pBuffer = pStubMsg->Buffer;

        // Save field.
        fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // Clear MemorySize.
        pStubMsg->MemorySize = 0;

        //
        // Get a buffer pointer to where the struct's pointees will be
        // unmarshalled from and remember the flat struct size in case we
        // have to allocate.
        //

        // Note that this function will recursively do buffer overrun
        // checks, bound checks, and sanity checks on size, actual count,
        // and offset.  And further checks in this function or called functions
        // are redundant.

        StructSize = NdrComplexStructMemorySize( pStubMsg,
                                                 pFormatSave );

        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

        // This is where any pointees begin in the buffer.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;

        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

        pStubMsg->Buffer = pBuffer;
        }

    if ( fMustAlloc || ! *ppMemory )
        {
        //
        // We can only get here if pStubMsg->PointerBufferMark was 0 upon
        // entry to this proc.
        //
        NDR_ASSERT( StructSize ,"Complex struct size is 0" );

        *ppMemory = (uchar*)NdrAllocate( pStubMsg, StructSize );

        //
        // Zero out all of the allocated memory so that deeply nested pointers
        // getted properly zeroed out.
        //
        MIDL_memset( *ppMemory, 0, StructSize );
        }

    // Insert the full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    //
    // Now check if there is a conformant array and mark where the conformance
    // will be unmarshalled from.
    //
    fEmbedConfStructContext = fIsEmbeddedStruct;

    if ( pFormatArray && !fIsEmbeddedStruct )
        {
        ALIGN(pStubMsg->Buffer,3);

        pStubMsg->BufferMark = pStubMsg->Buffer;

        //
        // Increment the buffer pointer 4 bytes for every dimension in the
        // conformant array.
        //
        pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormatArray, FALSE ) * 4;

        if ( FixWireRepForDComVerGTE54( pStubMsg ) )
            fEmbedConfStructContext = TRUE;
        }

    // BufferMark may be set up by an outer bogus struct.
    pBufferMark = pStubMsg->BufferMark;

    // conformance count mark
    pStubMsg->BufferMark = pBufferMark;

    // Align the buffer on the struct's alignment.
    ALIGN(pStubMsg->Buffer,Alignment);

    // Get the beginning memory pointer.
    pMemory = *ppMemory;

    // Set it to the beginning of the struct.
    SET_CORRELATION_MEMORY( pMemory );

    //
    // This is used for support of structs with doubles passed on an
    // i386 stack.  The alignment of such struct's is no guaranteed to be on
    // an 8 byte boundary. Similarly, od 16 bit platforms for 4 byte align.
    //
    // A cast to long is what we need.
    Align8Mod = 0x7 & PtrToLong( pMemory );

    //
    // Unmarshall the structure member by member.
    //
    for ( ; ; pFormat++ )
        {
        switch ( *pFormat )
            {
            //
            // simple types
            //
            case FC_CHAR :
            case FC_BYTE :
            case FC_SMALL :
            case FC_WCHAR :
            case FC_SHORT :
            case FC_LONG :
#if defined(__RPC_WIN64__)
            case FC_INT3264 :
            case FC_UINT3264 :
#endif
            case FC_FLOAT :
            case FC_HYPER :
            case FC_DOUBLE :
            case FC_ENUM16 :
            case FC_ENUM32 :
                NdrSimpleTypeUnmarshall( pStubMsg,
                                         pMemory,
                                         *pFormat );

                pMemory += SIMPLE_TYPE_MEMSIZE(*pFormat);
                break;

            case FC_IGNORE :
                ALIGN(pStubMsg->Buffer,3);
                pStubMsg->Buffer += 4;
                pMemory += PTR_MEM_SIZE;
                break;

            case FC_POINTER :
                {
                uchar *         pMemorySave = NULL;
                ALIGN( pStubMsg->Buffer, 0x3 );
                long *pPointerId = (long*)pStubMsg->Buffer;
                pStubMsg->Buffer += PTR_WIRE_SIZE;

                // A sized pointer here would have an offset from the beginning of the struct.

                // for [in,out] struct containing "[size_is(num)] IFoo ** pfoo",
                // we need to setup the pStub->memory pointing to the beginning of the struct
                // such that we can get the conformance correctly during freeing pass, before
                // unmarshall the returning result to the same memory spot.
                if (FC_OP == *pFormatPointers )
                {
                    pMemorySave = pStubMsg->Memory;
                    pStubMsg->Memory = *ppMemory;
                }

                POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

                NdrpPointerUnmarshall( pStubMsg,
                                       (uchar **)pMemory, // Where the memory pointer will be written
                                       *((uchar **)pMemory),
                                       pPointerId,        // Where the pointer in the buffer is. 
                                       pFormatPointers );  

                if (FC_OP == *pFormatPointers )
                    pStubMsg->Memory = pMemorySave;

                // Increment past the memory for the pointer.
                pMemory          += PTR_MEM_SIZE;

                pFormatPointers += 4;
                break;
                }


            //
            // Embedded complex things.
            //
            case FC_EMBEDDED_COMPLEX :
                {
                // Note, we opened a new block, so this is a different set of
                // save variables than the one on the top.
                CORRELATION_RESOURCE_SAVE;

                // Add memory padding.
                pMemory += pFormat[1];

                pFormat += 2;

                // Get the type's description.
                pFormatComplex = pFormat + *((signed short UNALIGNED *)pFormat);

                if ( FC_IP == *pFormatComplex ) 
                    {

                    // Treat like an embedded pointer except set the
                    // mark for iid_is.

                    SET_CORRELATION_MEMORY( pMemory );
                    
                    ALIGN( pStubMsg->Buffer, 0x3 );
                    long *pPointerId = (long*)pStubMsg->Buffer;
                    pStubMsg->Buffer += PTR_WIRE_SIZE;

                    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

                    NdrpPointerUnmarshall( pStubMsg,
                                           (uchar **)pMemory, // Where the memory pointer will be written
                                           *((uchar **)pMemory),
                                           pPointerId,        // Where the pointer in the buffer is. 
                                           pFormatComplex );  

                    pMemory          += PTR_MEM_SIZE;
                    pFormat++;
                    RESET_CORRELATION_MEMORY();

                    break;
                    }

                // A sized thingy here is relative to its position.

                SET_CORRELATION_MEMORY( pMemory );

                // Needed for an embedded conf struct.
                //
                pStubMsg->BufferMark = pBufferMark;
                if ( fEmbedConfStructContext )
                    SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatComplex)])
                ( pStubMsg,
                  &pMemory,
                  pFormatComplex,
                  FALSE );

                pMemory = NdrpMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pFormatComplex );

                RESET_EMBED_CONF_STRUCT( pStubMsg->uFlags );

                RESET_CORRELATION_MEMORY();
                //
                // Increment the main format string one byte.  The loop
                // will increment it one more byte past the offset field.
                //
                pFormat++;
                }
                break;

            case FC_ALIGNM2 :
                ALIGN( pMemory, 0x1 );
                break;

            case FC_ALIGNM4 :
                ALIGN( pMemory, 0x3 );
                break;

            case FC_ALIGNM8 :
                //
                // We have to play some tricks for the i386 to handle the case
                // when an 8 byte aligned structure is passed by value.  The
                // alignment of the struct on the stack is not guaranteed to be
                // on an 8 byte boundary.
                //
                pMemory -= Align8Mod;
                ALIGN( pMemory, 0x7 );
                pMemory += Align8Mod;

                break;

            case FC_STRUCTPAD1 :
            case FC_STRUCTPAD2 :
            case FC_STRUCTPAD3 :
            case FC_STRUCTPAD4 :
            case FC_STRUCTPAD5 :
            case FC_STRUCTPAD6 :
            case FC_STRUCTPAD7 :
                //
                // Increment memory pointer by amount of padding.
                //
                pMemory += (*pFormat - FC_STRUCTPAD1) + 1;
                break;

            case FC_STRUCTPADN :
                // FC_STRUCTPADN 0 <unsigned short>
                pMemory += *(((unsigned short *)pFormat) + 1);
                pFormat += 3;
                break;

            case FC_PAD :
                break;

            //
            // Done with layout.
            //
            case FC_END :
                goto ComplexUnmarshallEnd;

            default :
                NDR_ASSERT(0,"NdrComplexStructUnmarshall : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return 0;
            }
        }

ComplexUnmarshallEnd:

    RESET_CORRELATION_MEMORY();

    //
    // Unmarshall conformant array if the struct has one.
    //
    if ( pFormatArray && !fIsEmbeddedStruct  &&
         ! IS_CONF_ARRAY_DONE( pStubMsg->uFlags ) )
        {
        PPRIVATE_UNMARSHALL_ROUTINE   pfnPUnmarshall;

        switch ( *pFormatArray )
            {
            case FC_CARRAY :
                pfnPUnmarshall = NdrpConformantArrayUnmarshall;
                break;

            case FC_CVARRAY :
                pfnPUnmarshall = NdrpConformantVaryingArrayUnmarshall;
                break;

            case FC_BOGUS_ARRAY :
                pfnPUnmarshall = NdrpComplexArrayUnmarshall;
                break;

            case FC_C_WSTRING :
                ALIGN( pMemory, 1 );
                // fall through

            // case FC_C_CSTRING :
            // case FC_C_BSTRING :
            // case FC_C_SSTRING :

            default :
                pfnPUnmarshall = NdrpConformantStringUnmarshall;
                break;
            }


        // Set it to the end of the non-conformant part of the struct.
        SET_CORRELATION_MEMORY( pMemory );

        //
        // Unmarshall the conformance count of the outer array dimension for
        // unidimensional arrays.
        //
        pStubMsg->MaxCount = *((ulong *)pBufferMark);

        //
        // Mark where conformace counts are in the buffer.
        //
        pStubMsg->BufferMark = pBufferMark;

        //
        // Unmarshall the array/string.  The final flag is the fMustCopy flag,
        // which must be set.
        //
        (*pfnPUnmarshall)( pStubMsg,
                           &pMemory,
                           pFormatArray,
                           TRUE,
                           FALSE );

        RESET_CORRELATION_MEMORY();
        }

    //
    // Now fix up the stub message Buffer field if we set the PointerBufferMark
    // field.
    //
    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    if ( fIsEmbeddedStruct )
        SET_EMBED_CONF_STRUCT( pStubMsg->uFlags );
    else
        RESET_CONF_ARRAY_DONE( pStubMsg->uFlags );

    return 0;
}



unsigned char * RPC_ENTRY
NdrNonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a non conformant string.

    Used for FC_CSTRING, FC_WSTRING, FC_SSTRING, and FC_BSTRING (NT Beta2
    compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Double pointer to the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    ulong       Offset, Count, AllocSize, CharSize;

    IGNORED(fMustAlloc);

    // Align the buffer.
    ALIGN(pStubMsg->Buffer,3);

    // Get the count.
    Offset = *((ulong * &)pStubMsg->Buffer)++;
    Count = *((ulong * &)pStubMsg->Buffer)++;

    // Get total number of elements.
    AllocSize = (ulong) *((ushort *)(pFormat + 2));

    CharSize = 1;

    if ( Offset != 0  ||  AllocSize < Count )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    // Adjust count for wide char strings and stringable structs.
    // Adjust alloc size for wide char strings and stringable structs.
    switch ( *pFormat )
        {
        case FC_WSTRING :
            CharSize = 2;
            Count *= 2;
            AllocSize = MultiplyWithOverflowCheck( AllocSize , 2 );
            break;
        case FC_SSTRING :
            CharSize = pFormat[1];
            Count *= pFormat[1];
            AllocSize = MultiplyWithOverflowCheck( AllocSize, pFormat[1] );
            break;
        case FC_CSTRING:
        case FC_BSTRING:
            break;
        default :
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            break;
        }
    
    if ( Count )
        {
        uchar * p;

        CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, Count );

        // Check if the terminator is there.
        for ( p = pStubMsg->Buffer + Count - CharSize; CharSize--;  )
            {
            if ( *p++ != 0 )
                RpcRaiseException( RPC_X_INVALID_BOUND );
            }
        }
    else
        {
        // any MS product will generate non-zero out;
        // what about interop? will they send zero in valid case?
        RpcRaiseException( RPC_X_INVALID_BOUND );
        }

    // Allocate memory if needed.
    if ( ! *ppMemory )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) AllocSize );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    RpcpMemoryCopy( *ppMemory,
                    pStubMsg->Buffer,
                    (uint) Count );

    // Update buffer pointer.
    pStubMsg->Buffer += Count;

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine description :

    Unmarshalls a top level conformant string.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustAlloc  - TRUE if the string must be allocated, FALSE otherwise.

Return :

    None.

--*/
{
    uchar   fMustCopy;
    ulong   MaxCount;

    if ( pStubMsg->pArrayInfo == 0 )
        {

        ulong   ActualCount, Offset;
        ulong   ElementSize;
        ulong   ConformanceType = FC_LONG;
        BOOL    fIsSized;

        // find string type
        if ( *pFormat != FC_C_SSTRING )
            {
            // Typical case: char and wchar strings

            ElementSize = (*pFormat == FC_C_WSTRING) ? 2
                                                     : 1;
            fIsSized = (pFormat[1] == FC_STRING_SIZED);
            if ( fIsSized )
                ConformanceType = (pFormat[2] & 0x0f);
            }
        else
            {
            ElementSize = pFormat[1];
            fIsSized = (pFormat[2] == FC_STRING_SIZED);
            if ( fIsSized )
                ConformanceType = (pFormat[4] & 0x0f);
            }

        // Align the buffer for conformance unmarshalling.
        ALIGN( pStubMsg->Buffer,3 );


        MaxCount = *((ulong * &)pStubMsg->Buffer)++;
        Offset   = ((ulong *)pStubMsg->Buffer)[0];
        ActualCount = ((ulong *)pStubMsg->Buffer)[1];

        CHECK_BOUND( MaxCount, ConformanceType );
        if ( (Offset != 0) ||
             (MaxCount < ActualCount) )
            RpcRaiseException( RPC_X_INVALID_BOUND );

        MultiplyWithOverflowCheck( MaxCount, ElementSize );

        CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, (ActualCount * ElementSize) + 8);

        // Defer the termination check till NdrpConformantStringUnmarshall.

        //
        // Initialize the memory pointer if needed.  If the string is sized
        // then we always malloc on the server side.
        //
        fMustAlloc = fMustAlloc || (!pStubMsg->IsClient && fIsSized);
        if ( fMustAlloc )
            {
            fMustCopy = TRUE;
            }
        else
            {
            if ( REUSE_BUFFER(pStubMsg) )
                *ppMemory = pStubMsg->Buffer + 8;
            fMustCopy = FALSE;

             // Insert full pointer to ref id translation if needed.
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );

            }
        }
    else
        {

        //
        // If this is part of a multidimensional array then we get the location
        // where the conformance is located from a special place.
        // When coming here, the StubMsg->Buffer is already behind conf sizes.
        //
        MaxCount = (pStubMsg->pArrayInfo->
                           BufferConformanceMark[pStubMsg->pArrayInfo->Dimension]);
        //
        // We must copy the string from the buffer to new memory.
        //
        fMustCopy = TRUE;

        // Since this case is called by NdrComplexArrayUnmarshall, the buffer will
        // have already been validated for buffer overruns and bound checks in
        // NdrComplexArrayMemorySize.
        // The offset and actual counts will also have been checked for sanity.
        }

    // Load up conformant size for next stage.
    pStubMsg->MaxCount = MaxCount;

    // Call the private unmarshalling routine to do the work.
    NdrpConformantStringUnmarshall( pStubMsg,
                                    ppMemory,
                                    pFormat,
                                    fMustCopy,
                                    fMustAlloc );

    return 0;
}


void
NdrpConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **             ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustCopy ,
    uchar	              fMustAlloc )
/*++

Routine description :

    Private routine for unmarshalling a conformant string.  This is the
    entry point for unmarshalling an embedded conformant strings.

    Used for FC_C_CSTRING, FC_C_WSTRING, FC_C_SSTRING, and FC_C_BSTRING
    (NT Beta2 compatability only).

    Note this functions is only called from NdrConformantStringUnmarshall
    and NdrComplexStructUnmarshall.  NdrComplexStructUnmarshall calls
    NdrComplexStructMemSize which validates everything except correlation.
    This allows many validation checks to be skipped.  If the call is through
    NdrConformantStringUnmarshall, most of the necessary checks are in
    NdrConformantStringUnmarshall.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to where the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustCopy   - TRUE if the string must be copied from the buffer to memory,
                  FALSE otherwise.

Return :

    None.

--*/
{
    ulong       Offset, Count, CharSize;
    BOOL        fIsSized;

    fIsSized = (*pFormat != FC_C_SSTRING)  ?  (pFormat[1] == FC_STRING_SIZED)
                                           :  (pFormat[2] == FC_STRING_SIZED);
    if ( fIsSized && F_CORRELATION_CHECK)
        {
        NdrpCheckCorrelation( pStubMsg,
                           (long)pStubMsg->MaxCount,
                           pFormat,
                           NDR_CHECK_CONFORMANCE );
        }

    // Align for variance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Unmarshall the string count.
    Offset = *((ulong * &)pStubMsg->Buffer)++;
    Count = *((ulong * &)pStubMsg->Buffer)++;

    // Adjust the count for a wide strings and stringable structs.
    // This is good enough for BSTRs as the mem pointer has already moved.

    switch ( *pFormat )
        {
        case FC_C_WSTRING :
            CharSize = 2;
            Count *= 2;
            break;
        case FC_C_SSTRING :
            CharSize = pFormat[1];
            Count *= pFormat[1];
            break;
        default :
            CharSize = 1;
            break;
        }

        // String must have a terminator since we computed the size
        // in marshaling with wcslen/strlen+charsize and the app has no
        // method to size a string without a terminator.
        
        if ( 0 == Count )
           {
           RpcRaiseException( RPC_X_INVALID_BOUND );
           }

    
    if ( Count )
        {
        uchar * p;
        ulong ElemSize = CharSize;

        // Check if the terminator is there.
        for ( p = pStubMsg->Buffer + Count - ElemSize;  ElemSize--;  )
            {
            if ( *p++ != 0 )
                RpcRaiseException( RPC_X_INVALID_BOUND );
            }
        }

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, pStubMsg->MaxCount * CharSize );

        // Insert full pointer to ref id translation if needed.
        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );
        }


    // Copy the string if needed.
    if ( pStubMsg->IsClient || fMustCopy )
        {
        RpcpMemoryCopy( *ppMemory,
                        pStubMsg->Buffer,
                        (uint) Count );
        }

    // Update buffer pointer.
    pStubMsg->Buffer += Count;
}


unsigned char * RPC_ENTRY
NdrFixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a fixed array of any number of dimensions.

    Used for FC_SMFARRAY and FC_LGFARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array to unmarshall.
    pFormat     - Array's format string description.
    fMustAlloc  - TRUE if the array must be allocated, FALSE otherwise.

Return :

    None.

--*/
{
    uchar *     pBufferStart;
    ulong       Size;

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Get the total array size.
    if ( *pFormat == FC_SMFARRAY )
        {
        pFormat += 2;
        Size = (ulong) *((ushort * &)pFormat)++;
        }
    else // *pFormat++ == FC_LGFARRAY
        {
        pFormat += 2;
        Size = *((ulong UNALIGNED * &)pFormat)++;
        }

    pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , Size );

    // Set stub message buffer pointer past array.
    pStubMsg->Buffer += Size;

    // Initialize the memory pointer if necessary.
    if ( fMustAlloc )
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) Size );
    else
        if (REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            *ppMemory = pBufferStart;

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    // Unmarshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        // Mark the beginning of the array in the buffer.
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustAlloc );
        }

    // Copy the array if we're not using the rpc buffer to hold it.
    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        (uint) Size );
        }

    return 0;
}


unsigned char * RPC_ENTRY
NdrConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level one dimensional conformant array.

    Used for FC_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to array to be unmarshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    ulong    CopySize;

    // Align the buffer for conformance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Unmarshall the conformance count.
    pStubMsg->MaxCount = *((ulong * &)pStubMsg->Buffer)++;

    CHECK_BOUND( (ulong)pStubMsg->MaxCount, pFormat[4] & 0x0f );
    CopySize = MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount , *((ushort *)(pFormat + 2)) );

    // Buffer size checking will be done in NdrpConformantArrayUnmarshall after alignment.
    // Initialize the memory pointer if necessary.
        if (!fMustAlloc && REUSE_BUFFER(pStubMsg) && ! *ppMemory )
            {
            *ppMemory = pStubMsg->Buffer;

            //
            // Align memory pointer on an 8 byte boundary if needed.
            // We can't align the buffer pointer because we haven't made
            // the check for size_is == 0 yet.
            //
            ALIGN(*ppMemory, pFormat[1]);

            // if we point outside of buffer, we need to move it into 
            // RPC buffer.
            if ( ( *ppMemory > pStubMsg->BufferEnd ) && 
                    ( pStubMsg->MaxCount == 0 ) &&
                    ( pFormat[1] == 7 ) &&
                    !pStubMsg->pRpcChannelBuffer )
                {
                *ppMemory = (uchar *)pStubMsg->RpcMsg->Buffer;
                }
            
            // Insert full pointer to ref id translation if needed.
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );    
            }


    NdrpConformantArrayUnmarshall( pStubMsg,
                                   ppMemory,
                                   pFormat,
                                   fMustAlloc,
                                   fMustAlloc);

    return 0;
}


void
NdrpConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **             ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustCopy,
    uchar               fMustAlloc )
/*++

Routine Description :

    Private routine for unmarshalling a one dimensional conformant array.
    This is the entry point for unmarshalling an embedded conformant array.

    Used for FC_CARRAY.

    Note this functions is only called from NdrConformantArrayUnmarshall
    and NdrComplexStructUnmarshall.  NdrComplexStructUnmarshall calls
    NdrComplexStructMemSize which validates everything except correlation.
    NdrConformantArrayUnmarshall also does buffer validation.
    This allows many validation checks to be skipped.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array being unmarshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    uchar *     pBufferStart;
    ulong       CopySize;

    // do correlation testing even if the array size is zero
    if (F_CORRELATION_CHECK )
        {
        NdrpCheckCorrelation( pStubMsg,
                           (long) pStubMsg->MaxCount,
                           pFormat,
                           NDR_CHECK_CONFORMANCE );
        }

    // Return if array size is 0 so that we don't align the buffer.
    if ( ! pStubMsg->MaxCount )
        {
        // allocate before return; shouldn't happen here.
        if ( fMustAlloc )
            {
            // Compute total array size in bytes.
            *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) 0 );
    
            // Insert full pointer to ref id translation if needed.
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );
            }
        return;
        }

    ALIGN(pStubMsg->Buffer,pFormat[1]);

    // Compute total array size in bytes.
    CopySize = MultiplyWithOverflowCheck( (ulong)pStubMsg->MaxCount , *((ushort *)(pFormat + 2)) );

    pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize);
    pStubMsg->Buffer += CopySize;

    // we need to copy the whole allocated size in conformance array
    if ( fMustAlloc )
        {
        // Compute total array size in bytes.
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) CopySize );

        // Insert full pointer to ref id translation if needed.
        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );
        }


    // Increment the format string pointer to possible pointer layout.
    pFormat += 8;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Unmarshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        // Mark the beginning of the array in the buffer.
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustCopy );
        }

    // Copy the array if we're not using the rpc message buffer for it.
    if ( pStubMsg->IsClient || fMustCopy )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        (uint) CopySize );
        }
}


unsigned char * RPC_ENTRY
NdrConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level one dimensional conformant varying array.

    Used for FC_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    ulong   ArrayElements = 0;

    // Align the buffer for conformance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Unmarshall the conformance size.
    ArrayElements = *((ulong * &)pStubMsg->Buffer)++;

        {
        ulong           Size;
        ulong           Offset, ActualCount;
        PFORMAT_STRING  pFormatVar;

        CHECK_BOUND( ArrayElements, pFormat[4] & 0x0f );

        Offset = *((ulong *)pStubMsg->Buffer);
        CHECK_BOUND( Offset, FC_LONG );

        ActualCount = *((ulong *)(pStubMsg->Buffer + 4));

        pFormatVar = pFormat + 8;
        CORRELATION_DESC_INCREMENT( pFormatVar );

        CHECK_BOUND( ActualCount, *pFormatVar & 0x0f );

        // we only need to check overflow for conformant size . we don't need
        // to check varying overflow after we check conformance overflow
        MultiplyWithOverflowCheck( ArrayElements,  *((ushort *)(pFormat + 2)) );

        Size = ActualCount * *((ushort *)(pFormat + 2));

        if ( ((long)Offset < 0) ||
             (ArrayElements < (Offset + ActualCount)) )
            RpcRaiseException( RPC_X_INVALID_BOUND );

        if ( (pStubMsg->Buffer + 8 + Size) > pStubMsg->BufferEnd )
            RpcRaiseException( RPC_X_INVALID_BOUND );
        }


    //
    // For a conformant varying array, we can't reuse the buffer
    // because it doesn't hold the total size of the array.  So
    // allocate if the current memory pointer is 0.
    //
    if ( ! *ppMemory )
        {
        fMustAlloc = TRUE;
        }
    else
        {
        fMustAlloc = FALSE;
         // Insert full pointer to ref id translation if needed.
         // do this only when not allocating memory. this will be done 
         // in p version if new memory is allocated.
        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );
        }


    pStubMsg->MaxCount = ArrayElements;

    NdrpConformantVaryingArrayUnmarshall( pStubMsg,
                                          ppMemory,
                                          pFormat,
                                          fMustAlloc,
                                          fMustAlloc);

    return 0;
}


void
NdrpConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **             ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustCopy,
    uchar               fMustAlloc )
/*++

Routine Description :

    Private routine for unmarshalling a one dimensional conformant varying
    array. This is the entry point for unmarshalling an embedded conformant
    varying array.

    Used for FC_CVARRAY.

    Note this functions is only called from NdrConformantVaryingArrayUnmarshall
    and NdrComplexStructUnmarshall.  NdrComplexStructUnmarshall calls
    NdrComplexStructMemSize which validates everything except correlation.
    NdrConformantVaryingArrayUnmarshall also does buffer validation.
    This allows many validation checks to be skipped.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array being unmarshalled.
    pFormat     - Array's format string description.
    fMustCopy   - Ignored.

Return :

    None.

--*/
{
    uchar *     pBufferStart;
    ulong       CopyOffset, CopySize;
    ushort      ElemSize;

    IGNORED(fMustCopy);

    // Align the buffer for conformance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    // Unmarshall offset and actual count.
    pStubMsg->Offset = *((ulong * &)pStubMsg->Buffer)++;
    pStubMsg->ActualCount = *((ulong * &)pStubMsg->Buffer)++;

    if (F_CORRELATION_CHECK )
        {
        NdrpCheckCorrelation( pStubMsg,
                           (long) pStubMsg->MaxCount,
                           pFormat,
                           NDR_CHECK_CONFORMANCE );
        NdrpCheckCorrelation( pStubMsg,
                           (long) pStubMsg->ActualCount,
                           pFormat,
                           NDR_CHECK_VARIANCE );
        NdrpCheckCorrelation( pStubMsg,
                           (long) pStubMsg->Offset,
                           pFormat,
                           NDR_CHECK_OFFSET );
        }


    ElemSize = *((ushort *)(pFormat + 2));

    //
    // Return if length is 0.
    //
    if ( ! pStubMsg->ActualCount )
        {
        // needs to allocate before return. 
        if ( fMustAlloc )
            {
            *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) pStubMsg->MaxCount * ElemSize );
            // Insert full pointer to ref id translation if needed.
            if ( pStubMsg->FullPtrRefId )
                FULL_POINTER_INSERT( pStubMsg, *ppMemory );
            }
        return;
        }

    
    CopyOffset = MultiplyWithOverflowCheck(pStubMsg->Offset , ElemSize );
    CopySize = MultiplyWithOverflowCheck( pStubMsg->ActualCount , ElemSize );

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    pBufferStart = pStubMsg->Buffer;

    // Increment buffer pointer past array.
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize );
    pStubMsg->Buffer += CopySize;

    // Increment format string to possible pointer description.
    pFormat += 12;
    CORRELATION_DESC_INCREMENT( pFormat );
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( fMustAlloc )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) pStubMsg->MaxCount * ElemSize );
        // Insert full pointer to ref id translation if needed.
        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );
        }


    // Unmarshall embedded pointers first.
    if ( *pFormat == FC_PP )
        {
        //
        // Set the MaxCount field equal to the variance count.
        // The pointer unmarshalling routine uses the MaxCount field
        // to determine the number of times an FC_VARIABLE_REPEAT
        // pointer is unmarshalled.  In the face of variance the
        // correct number of time is the actual count, not MaxCount.
        //
        pStubMsg->MaxCount = pStubMsg->ActualCount;

        //
        // Mark the location of the first transmitted array element in
        // the buffer.
        //
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fMustCopy );
        }

    // Always copy.  Buffer reuse is not possible.
    RpcpMemoryCopy( *ppMemory + CopyOffset,
                    pBufferStart,
                    (uint) CopySize );
}


unsigned char * RPC_ENTRY
NdrVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls top level or embedded a one dimensional varying array.

    Used for FC_SMVARRAY and FC_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

--*/
{
    uchar *     pBufferStart;
    ulong       TotalSize;
    ulong       Offset, Count;
    ulong       CopyOffset, CopySize;
    ushort      ElemSize;
    uchar       fNewMemory;
    long        Elements;

    // Align the buffer for variance unmarshalling.
    ALIGN(pStubMsg->Buffer,3);

    Offset = *((ulong * &)pStubMsg->Buffer)++;
    Count = *((ulong * &)pStubMsg->Buffer)++;

    if ( ! Count )
        return 0;

    // We fish out type from the (old part of the) variance descriptor.

    CHECK_BOUND( Offset, FC_LONG);
    CHECK_BOUND( Count,
                 pFormat[(*pFormat == FC_SMVARRAY) ? 8 : 12] & 0x0f );

    Elements =
        (*pFormat == FC_SMVARRAY) ?
        *((ushort *)(pFormat + 4)) : *((ulong UNALIGNED *)(pFormat + 6));

    if ( ((long)Offset < 0 ) ||
         (Elements < (long)(Count + Offset)) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    if (F_CORRELATION_CHECK )
        {
        NdrpCheckCorrelation( pStubMsg,
                              (long)Count,
                              pFormat,
                              NDR_CHECK_VARIANCE );
        NdrpCheckCorrelation( pStubMsg,
                              (long)Offset,
                              pFormat,
                              NDR_CHECK_OFFSET );
        }

    ALIGN(pStubMsg->Buffer, pFormat[1]);

    // Get array's total size and increment to element size field.
    if ( *pFormat == FC_SMVARRAY )
        {
        TotalSize = (ulong) *((ushort *)(pFormat + 2));

        pFormat += 6;
        }
    else
        {
        TotalSize = *((ulong UNALIGNED *)(pFormat + 2));

        pFormat += 10;
        }

    if ( fNewMemory = ! *ppMemory )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) TotalSize );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    ElemSize = *((ushort *)pFormat);

    CopyOffset = MultiplyWithOverflowCheck( Offset, ElemSize );
    CopySize = MultiplyWithOverflowCheck( Count, ElemSize );
    
    if ( (long) CopyOffset < 0 ||
        ( TotalSize < CopyOffset + CopySize ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );
    
    pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize );
    pStubMsg->Buffer += CopySize;

    // Increment format string to possible pointer description.
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );

    // Unmarshall embedded pointers.
    if ( *pFormat == FC_PP )
        {
        //
        // Set the MaxCount field equal to the variance count.
        // The pointer unmarshalling routine uses the MaxCount field
        // to determine the number of times an FC_VARIABLE_REPEAT
        // pointer is unmarshalled.  In the face of variance the
        // correct number of time is the actual count, not MaxCount.
        //
        pStubMsg->MaxCount = Count;

        //
        // Mark the location of the first transmitted array element in
        // the buffer
        //
        pStubMsg->BufferMark = pBufferStart;

        NdrpEmbeddedPointerUnmarshall( pStubMsg,
                                       *ppMemory,
                                       pFormat,
                                       fNewMemory );
        }

    RpcpMemoryCopy( *ppMemory + CopyOffset,
                    pBufferStart,
                    (uint) CopySize );

    return 0;
}


unsigned char * RPC_ENTRY
NdrComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level complex array.

    Used for FC_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar *     pBuffer;
    long        ArraySize;
    BOOL        fSetPointerBufferMark;

    ArraySize = 0;

    //
    // Setting this flag means that the array is not embedded inside of
    // another complex struct or array.
    //
    fSetPointerBufferMark = ! pStubMsg->PointerBufferMark;

    if ( fSetPointerBufferMark )
        {
        BOOL            fOldIgnore;
        PFORMAT_STRING  pFormatPP;

        pBuffer = pStubMsg->Buffer;

        fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        pStubMsg->MemorySize = 0;

        //
        // Get a buffer pointer to where the arrays's pointees will be
        // unmarshalled from and remember the array size in case we
        // have to allocate.
        //

        // Note this function will recursively check buffer overflows,
        // bounds, and trial sanity checks on array offsets, sizes,
        // and actual counts.  This make additional checks in this
        // function redundant.

        ArraySize = NdrComplexArrayMemorySize( pStubMsg,
                                               pFormat );

        // at least we are not out of bound in flat part. not really necessary
        // but good to have.
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );
        //
        // PointerBufferaMark is where the pointees begin in the buffer.
        // If this is an array of ref pointers then we don't want to set
        // this, all we wanted was the array size.
        //

        pFormatPP = pFormat + 12;
        CORRELATION_DESC_INCREMENT( pFormatPP );
        CORRELATION_DESC_INCREMENT( pFormatPP );

        if ( *pFormatPP != FC_RP )
            {
            pStubMsg->PointerBufferMark = pStubMsg->Buffer;
            }
        else
            fSetPointerBufferMark = FALSE;

        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;

        pStubMsg->Buffer = pBuffer;
        }

    if ( fMustAlloc || ! *ppMemory )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) ArraySize );

        //
        // Zero out the memory of the array if we allocated it, to insure
        // that all embedded pointers are zeroed out.  Blech.
        //
        MIDL_memset( *ppMemory, 0, (uint) ArraySize );
        }


    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    //
    // Check for a conformance description.
    //
    if ( ( *((long UNALIGNED *)(pFormat + 4)) != 0xffffffff ) &&
         ( pStubMsg->pArrayInfo == 0 ) )
        {
        //
        // The outer most array dimension sets the conformance marker.
        //

        ALIGN(pStubMsg->Buffer,0x3);

        // Mark where the conformance count(s) will be unmarshalled from.
        pStubMsg->BufferMark = pStubMsg->Buffer;

        // Increment past conformance count(s).
        pStubMsg->Buffer += NdrpArrayDimensions( pStubMsg, pFormat, FALSE ) * 4;

        }

    NdrpComplexArrayUnmarshall( pStubMsg,
                                ppMemory,
                                pFormat,
                                TRUE,
                                FALSE );

    if ( fSetPointerBufferMark )
        {
        //
        // This will set the buffer pointer to end of all of the array's
        // unmarshalled data in the buffer.
        //
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;

        pStubMsg->PointerBufferMark = 0;
        }

    return 0;
}


void
NdrpComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **             ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustCopy,
    uchar               fMustAlloc )
/*++

Routine Description :

    Private routine for unmarshalling a complex array.  This is the entry
    point for unmarshalling an embedded complex array.

    Used for FC_BOGUS_ARRAY.

    Note this functions is only called from NdrComplexArrayUnmarshall
    and NdrComplexStructUnmarshall.  NdrComplexStructUnmarshall calls
    NdrComplexStructMemSize which validates everything except correlation.
    MdrComplexArrayUnmarshall has a similar check.
    This allows many validation checks to be skipped.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustCopy   - Ignored.

Return :

    None.

--*/
{
    ARRAY_INFO      ArrayInfo;
    PARRAY_INFO             pArrayInfo;
    PUNMARSHALL_ROUTINE     pfnUnmarshall;
    PFORMAT_STRING          pFormatSave;
    ulong                   Elements;
    ulong                   Offset, Count;
    ulong                   MemoryElementSize;
    long                    Dimension;
    uchar                   Alignment;
    bool                    UseBrokenInterfacePointer = false;

    // this is called from ComplexStruct & ComplexArray, and in either case, we
    // cann't prevent allocation before correlation check. These are "can't solve"
    // scenarios.
    uchar *                pMemory = *ppMemory;

    //
    // Setup if we are the outer dimension.  All this is for multidimensional
    // array support.  If we didn't have to worry about Beta2 stub
    // compatability we could this much better.
    //
    if ( ! pStubMsg->pArrayInfo )
        {
        NdrpInitArrayInfo(pStubMsg, &ArrayInfo );
        }

    pFormatSave = pFormat;

    pArrayInfo = pStubMsg->pArrayInfo;

    Dimension = pArrayInfo->Dimension;

    Alignment = pFormat[1];

    pFormat += 2;

    // This is 0 if the array has conformance.
    Elements = *((ushort * &)pFormat)++;

    //
    // Check for conformance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        Elements = pArrayInfo->BufferConformanceMark[Dimension];
        if ( F_CORRELATION_CHECK )
            {
            NdrpCheckCorrelation( pStubMsg,
                               Elements,
                               pFormatSave,
                               NDR_CHECK_CONFORMANCE );
            }
        }

    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    //
    // Check for variance description.
    //
    if ( *((long UNALIGNED *)pFormat) != 0xffffffff )
        {
        if ( Dimension == 0 )
            {
            ulong   VarianceSize;

            ALIGN(pStubMsg->Buffer,0x3);

            // Mark where the variance counts are.
            pArrayInfo->BufferVarianceMark = (unsigned long *)pStubMsg->Buffer;

            // Handle multidimensional arrays.
            VarianceSize =  NdrpArrayDimensions( pStubMsg, pFormatSave, TRUE ) * 8;

            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, VarianceSize );
            pStubMsg->Buffer += VarianceSize;
            }

        Offset = pArrayInfo->BufferVarianceMark[Dimension * 2];
        Count = pArrayInfo->BufferVarianceMark[(Dimension * 2) + 1];
        if ( F_CORRELATION_CHECK )
            {
            NdrpCheckCorrelation( pStubMsg,
                               Offset,
                               pFormatSave,
                               NDR_CHECK_OFFSET );
            NdrpCheckCorrelation( pStubMsg,
                       Count,
                       pFormatSave,
                       NDR_CHECK_VARIANCE );
            }
        }
    else
        {
        Offset = 0;
        Count = Elements;
        }

    if ( (long)Offset < 0 ||
          ( Count+ Offset ) > Elements )
          RpcRaiseException( RPC_X_INVALID_BOUND );
    
    pFormat += 4;
    CORRELATION_DESC_INCREMENT( pFormat );

    if ( ! Count )
        goto ComplexArrayUnmarshallEnd;

    ALIGN(pStubMsg->Buffer,Alignment);

    switch ( *pFormat )
        {
        case FC_EMBEDDED_COMPLEX :
            pFormat += 2;
            pFormat += *((signed short *)pFormat);

            if ( *pFormat == FC_IP )
                goto HandleInterfacePointer;

            pfnUnmarshall = pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormat)];

            pArrayInfo->Dimension = Dimension + 1;
            pArrayInfo->MaxCountArray = pArrayInfo->BufferConformanceMark;

            MemoryElementSize = (ulong) ( NdrpMemoryIncrement( pStubMsg,
                                                               pMemory,
                                                               pFormat ) - pMemory );

            pArrayInfo->MaxCountArray = 0;
            break;

        // note : midl doesn't seems to generate FC_OP in here, so we don't want
        // to change it for now. but there is potential bug here that pStubMsg->Memory
        // is not set and NdrPointerFree might fail if FC_OP points to a conformance
        // struct/array.
        case FC_RP :
        case FC_UP :
        case FC_FP :
        case FC_OP :
            pfnUnmarshall = (PUNMARSHALL_ROUTINE) NdrpPointerUnmarshall;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_IP :
HandleInterfacePointer:
            
            UseBrokenInterfacePointer = !FixWireRepForDComVerGTE54( pStubMsg );
            // Probably this code is not used, as for arrays of IPs the compiler
            // (as of ver. 5.1.+) generates array of embedded complex.
            //
            pfnUnmarshall = (PUNMARSHALL_ROUTINE)NdrpPointerUnmarshall;

            // Need this in case we have a variant offset.
            MemoryElementSize = PTR_MEM_SIZE;
            break;

        case FC_ENUM16 :
            pfnUnmarshall = 0;
            MemoryElementSize = sizeof(int);
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
        case FC_UINT3264:
            pfnUnmarshall = 0;
            MemoryElementSize = sizeof(__int64);
            break;
#endif

        case FC_RANGE:
            pfnUnmarshall = NdrRangeUnmarshall;
            MemoryElementSize = SIMPLE_TYPE_MEMSIZE( pFormat[1] );
            break;
        default :
            NDR_ASSERT( IS_SIMPLE_TYPE(*pFormat),
                        "NdrpComplexArrayUnmarshall : bad format char" );

            Count = MultiplyWithOverflowCheck( Count, SIMPLE_TYPE_BUFSIZE(*pFormat) );

            pMemory += MultiplyWithOverflowCheck( Offset , SIMPLE_TYPE_MEMSIZE(*pFormat) );

            RpcpMemoryCopy( pMemory,
                            pStubMsg->Buffer,
                            (uint) Count );

            CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, Count );
            pStubMsg->Buffer += Count;

            goto ComplexArrayUnmarshallEnd;
        }

    //
    // If there is variance then increment the memory pointer to the first
    // element actually being marshalled.
    //
    if ( Offset )
        pMemory += MultiplyWithOverflowCheck( Offset , MemoryElementSize );

    //
    // Check for an array of enum16 or int3264.
    //
    if ( ! pfnUnmarshall )
        {
      #if defined(__RPC_WIN64__)
        if ( *pFormat != FC_ENUM16 )
            {
            // int3264

            if ( *pFormat == FC_INT3264 )
                {
                for ( ; Count--; )
                    *((INT64 * &)pMemory)++ = *((long * &)pStubMsg->Buffer)++;
                }
            else
                {
                for ( ; Count--; )
                    *((UINT64 * &)pMemory)++ = *((ulong * &)pStubMsg->Buffer)++;
                }
            }
        else
      #endif
            {
            for ( ; Count--; )
                {
                // Cast to ushort since we don't want to sign extend.
                *((int * &)pMemory)++ = (int) *((ushort * &)pStubMsg->Buffer)++;
                }
            }

        goto ComplexArrayUnmarshallEnd;
        } // !pfnUnmarshall

    //
    // Array of pointers.
    //
    if ( (pfnUnmarshall == (PUNMARSHALL_ROUTINE) NdrpPointerUnmarshall) )
        {

        // If the broken interface pointer is used,
        // the pointer will not show up in the flat part
        // but in the pointee.
        if ( UseBrokenInterfacePointer )
            {
            pStubMsg->pArrayInfo = 0;
            SET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );

            POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

            for ( ; Count--; )
                {
                
                NdrpPointerUnmarshall( 
                    pStubMsg,
                    (uchar **)pMemory,
                    *((uchar **)pMemory),
                    NULL,
                    pFormat );
                pMemory += PTR_MEM_SIZE;
                }

            RESET_BROKEN_INTERFACE_POINTER( pStubMsg->uFlags );
            }
        else
            {
            long *pBufferPtr;
            ulong DoPtrWireInc;

            if ( *pFormat != FC_RP )
                {
                pBufferPtr = (long*)pStubMsg->Buffer;
                ulong uSize =  MultiplyWithOverflowCheck( PTR_WIRE_SIZE , Count );
                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, uSize );
                pStubMsg->Buffer += uSize;
                DoPtrWireInc = 1;
                }
            else 
                {
                pBufferPtr = 0;
                DoPtrWireInc = 0;
                }

            pStubMsg->pArrayInfo = 0;

            POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

            for ( ; Count--; )
                {

                NdrpPointerUnmarshall( 
                    pStubMsg,
                    (uchar **)pMemory,
                    *((uchar **)pMemory),
                    pBufferPtr,
                    pFormat );

                pBufferPtr += DoPtrWireInc;
                pMemory += PTR_MEM_SIZE;
                }

            }

        goto ComplexArrayUnmarshallEnd;
        }

    //
    // Unmarshall the complex array elements.
    //

    if ( ! IS_ARRAY_OR_STRING(*pFormat) )
        pStubMsg->pArrayInfo = 0;

    for ( ; Count--; )
        {
        // Keep track of multidimensional array dimension.
        if ( IS_ARRAY_OR_STRING(*pFormat) )
            pArrayInfo->Dimension = Dimension + 1;

        (*pfnUnmarshall)( pStubMsg,
                          &pMemory,
                          pFormat,
                          FALSE );

        // Increment the memory pointer by the element size.
        pMemory += MemoryElementSize;
        }

ComplexArrayUnmarshallEnd:

    // pArrayInfo must be zero when not valid.
    pStubMsg->pArrayInfo = (Dimension == 0) ? 0 : pArrayInfo;
}


unsigned char * RPC_ENTRY
NdrEncapsulatedUnionUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls an encapsulated array.

    Used for FC_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the union should be unmarshalled.
    pFormat     - Union's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar *     pBuffer;
    uchar *     pUnion;
    uchar       SwitchType;

    IGNORED(fMustAlloc);

    NO_CORRELATION;

    //
    // Since we can never use the buffer to hold a union we simply have
    // to check the current memory pointer to see if memory must be allocated.
    //
    // The memory size of an encapsulated union is the union size plus
    // the memory needed for the switch_is member (including any padding
    // for alignment).
    //
    if ( ! *ppMemory )
        {
        uint   Size;

        Size = *((ushort *)(pFormat + 2)) + HIGH_NIBBLE(pFormat[1]);

        *ppMemory = (uchar*)NdrAllocate( pStubMsg, Size );

        //
        // We must zero out all of the new memory in case there are pointers
        // in any of the arms.
        //
        MIDL_memset( *ppMemory, 0, Size );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    SwitchType = LOW_NIBBLE(pFormat[1]);

    pBuffer = pStubMsg->Buffer;

    //
    // Unmarshall the switch_is field into memory.
    //
    NdrSimpleTypeUnmarshall( pStubMsg,
                             *ppMemory,
                             SwitchType );

    //
    // The above call incremented the buffer pointer.  Set it back to before
    // the switch is value in the buffer.
    //
    pStubMsg->Buffer = pBuffer;

    // Get a memory pointer to the union.
    pUnion = *ppMemory + HIGH_NIBBLE(pFormat[1]);

    NdrpUnionUnmarshall( pStubMsg,
                         &pUnion,
                         pFormat + 2,
                         SwitchType,
                         0 );   // Encapsulated union

    return 0;
}


unsigned char * RPC_ENTRY
NdrNonEncapsulatedUnionUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a non encapsulated array.

    Used for FC_NON_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the union should be unmarshalled.
    pFormat     - Union's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    uchar               SwitchType;
    PFORMAT_STRING      pFormatSave = pFormat;

    IGNORED(fMustAlloc);

    SwitchType = pFormat[1];

    //
    // Get the memory size and arm description part of the format string
    // description.
    //
    pFormat += 6;
    CORRELATION_DESC_INCREMENT( pFormat );
    pFormat += *((signed short *)pFormat);

    //
    // Since we can never use the buffer to hold a union we simply have
    // to check the current memory pointer to see if memory must be allocated.
    //
    if ( fMustAlloc || ! *ppMemory )
        {
        uint   Size;

        Size = *((ushort *)pFormat);

        *ppMemory = (uchar*)NdrAllocate( pStubMsg, Size );

        //
        // We must zero out all of the new memory in case there are pointers
        // in any of the arms.
        //
        MIDL_memset( *ppMemory, 0, Size );
        }

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    NdrpUnionUnmarshall( pStubMsg,
                         ppMemory,
                         pFormat,
                         SwitchType,
                         pFormatSave );

    return 0;
}


void
NdrpUnionUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               SwitchType,
    PFORMAT_STRING      pFormatNonEncUnion
    )
/*++

Routine description :

    Private routine for unmarshalling a union.  This routine is shared for
    both encapsulated and non-encapsulated unions and handles the actual
    unmarshalling of the proper union arm.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the union should be unmarshalled.
    pFormat     - Union's format string description.
    SwitchType  - Union's switch type.

Return :

    None.

--*/
{
    long        SwitchIs;
    long        Arms;
    uchar       Alignment;

    //
    // Unmarshall the switch is.  We have to do it inline here so that a
    // switch_is which is negative will be properly sign extended.
    //
    switch ( SwitchType )
        {
        case FC_SMALL :
        case FC_CHAR :
            SwitchIs = (long) *((char * &)pStubMsg->Buffer)++;
            break;
        case FC_USMALL :
            SwitchIs = (long) *((uchar * &)pStubMsg->Buffer)++;
            break;
        case FC_SHORT :
        case FC_ENUM16 :
            ALIGN(pStubMsg->Buffer,1);
            SwitchIs = (long) *((short * &)pStubMsg->Buffer)++;
            break;
        case FC_USHORT :
        case FC_WCHAR :
            ALIGN(pStubMsg->Buffer,1);
            SwitchIs = (long) *((ushort * &)pStubMsg->Buffer)++;
            break;
        case FC_LONG :
        case FC_ULONG :
        case FC_ENUM32 :
          // FC_INT3264 gets mapped to FC_LONG.
            ALIGN(pStubMsg->Buffer,3);
            SwitchIs = *((long * &)pStubMsg->Buffer)++;
            break;
        default :
            NDR_ASSERT(0,"NdrpUnionUnmarshall : Illegal union switch_type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    if ( pFormatNonEncUnion )
        {
        if ( F_CORRELATION_CHECK )
            {
            // Unions offset in the switch_is correlation descriptor is relative
            // to the union position itself, not to the beginning of the struct.
            // This is set properly at the complex struct level.

            NdrpCheckCorrelation( pStubMsg,
                                  SwitchIs,
                                  pFormatNonEncUnion,
                                  NDR_CHECK_CONFORMANCE );
            }
        }

    // Skip the memory size field.
    pFormat += 2;

    //
    // We're at the union_arms<2> field now, which contains both the
    // Microsoft union aligment value and the number of union arms.
    //

    //
    // Get the union alignment (0 if this is a DCE union).  Get your gun.
    //
    Alignment = (uchar) ( *((ushort *)pFormat) >> 12 );

    ALIGN(pStubMsg->Buffer,Alignment);

    //
    // Number of arms is the lower 12 bits.  Ok shoot me.
    //
    Arms = (long) ( *((ushort * &)pFormat)++ & 0x0fff);

    //
    // Search for union arm.
    //
    for ( ; Arms; Arms-- )
        {
        if ( *((long UNALIGNED * &)pFormat)++ == SwitchIs )
            {
            //
            // Found the right arm, break out.
            //
            break;
            }

        // Else increment format string.
        pFormat += 2;
        }

    //
    // Check if we took the default arm and no default arm is specified.
    //
    if ( ! Arms && (*((ushort *)pFormat) == (ushort) 0xffff) )
        {
        RpcRaiseException( RPC_S_INVALID_TAG );
        }

    //
    // Return if the arm is empty.
    //
    if ( ! *((ushort *)pFormat) )
        return;

    // check we aren't EOB after unmarshalling arm selector
    // not really necessary ( we shouldn't overwrite buffer in union) but we shouldn't
    // go further if it failes here.
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );    

    //
    // Get the arm's description.
    //
    // We need a real solution after beta for simple type arms.  This could
    // break if we have a format string larger than about 32K.
    //
    if ( IS_MAGIC_UNION_BYTE(pFormat) )
        {
        // we could read pass the end of buffer, but won't corrupt memory
        // here. We always allocate memory for union in the server side. 
        NdrSimpleTypeUnmarshall( pStubMsg,
                                 *ppMemory,
                                 pFormat[0] );
        return;
        }

    pFormat += *((signed short *)pFormat);

    //
    // Determine the double memory pointer that we pass to the arm's
    // unmarshalling routine.
    // If the union arm we take is a pointer, we have to dereference the
    // current memory pointer since we're passed the pointer to a pointer
    // to the union (regardless of whether the actual parameter was a by-value
    // union or a pointer to a union).
    //
    // We also have to do a bunch of other special stuff to handle unions
    // embedded inside of strutures.
    //
    if ( IS_POINTER_TYPE(*pFormat) )
        {
        ppMemory = (uchar **) *ppMemory;

       //
       // If we're embedded in a struct or array we have do some extra stuff.
       //
       if ( pStubMsg->PointerBufferMark )
            {
            
            ALIGN(pStubMsg->Buffer,3);
            long *pPointerId = (long*)pStubMsg->Buffer;
            pStubMsg->Buffer += PTR_WIRE_SIZE;

            POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

            NdrpPointerUnmarshall( pStubMsg,
                                   ppMemory,
                                   *((uchar **)ppMemory),
                                   pPointerId,
                                   pFormat );

            return;
            }
        }

    //
    // Union arm of a non-simple type.
    //
    (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormat)])
    ( pStubMsg,
      ppMemory,
      pFormat,
      FALSE );
}



unsigned char * RPC_ENTRY
NdrByteCountPointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a pointer with the byte count attribute applied to it.

    Used for FC_BYTE_COUNT_POINTER.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the byte count pointer should be
                  unmarshalled.
    pFormat     - Byte count pointer's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    PFORMAT_STRING  pFormatComplex;
    long            ByteCount;
    long            DataSize;

    ByteCount = (ulong) NdrpComputeConformance( pStubMsg,
                                                NULL,
                                                pFormat );

    pFormatComplex = pFormat + 6;
    CORRELATION_DESC_INCREMENT( pFormatComplex );
    pFormatComplex += *((signed short *)pFormatComplex);

    //
    // Determine incoming data size.
    //
    if ( pFormat[1] != FC_PAD )
        {
        DataSize = SIMPLE_TYPE_MEMSIZE(pFormat[1]);
        }
    else
        {
        uchar *     pBuffer;

        pBuffer = pStubMsg->Buffer;

        pStubMsg->MemorySize = 0;

        //
        // This will give us the allocate(all_nodes) size of the data.
        //
        DataSize = (*pfnMemSizeRoutines[ROUTINE_INDEX(*pFormatComplex)])
                   ( pStubMsg,
                     pFormatComplex );

        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

        pStubMsg->Buffer = pBuffer;
        }

    if ( DataSize > ByteCount )
        RpcRaiseException( RPC_X_BYTE_COUNT_TOO_SMALL );

    //
    // Now make things look like we're handling an allocate all nodes.
    //
    NDR_ALLOC_ALL_NODES_CONTEXT AllocContext;
    AllocContext.AllocAllNodesMemory = *ppMemory;
    AllocContext.AllocAllNodesMemoryBegin = *ppMemory;
    AllocContext.AllocAllNodesMemoryEnd = *ppMemory + ByteCount;
    pStubMsg->pAllocAllNodesContext = &AllocContext;

    //
    // Now unmarshall.
    //
    if ( pFormat[1] != FC_PAD )
        {
        ALIGN(pStubMsg->Buffer,SIMPLE_TYPE_ALIGNMENT(pFormat[1]));

        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + SIMPLE_TYPE_BUFSIZE(pFormat[1]) );
        
        NdrSimpleTypeUnmarshall( pStubMsg,
                                 *ppMemory,
                                 pFormat[1] );
        }
    else
        {
        (*pfnUnmarshallRoutines[ROUTINE_INDEX(*pFormatComplex)])
        ( pStubMsg,
          ppMemory,
          pFormatComplex,
          TRUE );
        }

    pStubMsg->pAllocAllNodesContext = 0;

    return 0;
}


unsigned char * RPC_ENTRY
NdrpXmitOrRepAsPtrUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a transmit as (or represent as) object given by pointers.
    (FC_TRANSMIT_AS_PTR or FC_REPRESENT_AS_PTR)

    See NdrXmitOrRepAsUnmarshall for more detals.

Arguments :

    pStubMsg    - a pointer to the stub message
    ppMemory    - pointer to the presented type where to put data
    pFormat     - format string description
    fMustAlloc  - allocate flag

Note.
    fMustAlloc is ignored as we always allocate outside of the buffer.

--*/
{
    unsigned char *          pTransmittedType;
    unsigned char  *         pPresentedType = *ppMemory;
    BOOL                     fMustFreeXmit = FALSE;
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;
    unsigned short           QIndex;
    unsigned long            PresentedTypeSize;
    uchar *                  PointerBufferMarkSave;
    void *                   XmitTypePtr = 0;
    void *                   pMemoryListSave;
    (void)                   fMustAlloc;

    // Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);
    PresentedTypeSize = *(unsigned short *)(pFormat + 4);

    if ( ! pPresentedType )
        {
        //Allocate a presented type object first.

        pPresentedType = (uchar*)NdrAllocate( pStubMsg, (uint) PresentedTypeSize );
        MIDL_memset( pPresentedType, 0, (uint) PresentedTypeSize );
        }

    // Allocate the transmitted object outside of the buffer
    // and unmarshall into it

    pFormat += 8;
    pFormat = pFormat + *(short *)pFormat;

    // Save the current state of the memory list so that the temporary
    // memory allocated for the transmitted type can be easily removed
    // from the list.   This assumes that the memory allocated here 
    // will not have any pointers to other blocks of memory.   This is true
    // as long as full pointers are not used.  The current compiler does 
    // not support full pointers, so this in not a problem.
   
    pMemoryListSave = pStubMsg->pMemoryList;

    pTransmittedType = NULL;  // asking the engine to allocate

    // only when ptr is ref: make it look like UP.

    if ( *pFormat == FC_RP )
        pTransmittedType = (uchar *)& XmitTypePtr;
    
    {
        uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        NDR_POINTER_QUEUE *pOldQueue = NULL;

        // Set the current queue to NULL so that all pointees will be
        // queued and unmarshalled together
        if ( pStubMsg->pPointerQueueState )
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            (*pfnUnmarshallRoutines[ ROUTINE_INDEX( *pFormat )])
                   ( pStubMsg,
                     & pTransmittedType,
                     pFormat,
                     TRUE );
            }
        RpcFinally
            {
            pStubMsg->PointerBufferMark = PointerBufferMarkSave;
            
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally

    }

    // Translate from the transmitted type into the presented type.

    pStubMsg->pTransmitType = (uchar *)& pTransmittedType;
    pStubMsg->pPresentedType = pPresentedType;

    pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );

    *ppMemory = pStubMsg->pPresentedType;

    // Free the transmitted object (it was allocated by the engine)
    // and its pointees. The call through the table frees the pointees
    // plus it frees the object itself as it is a pointer.

    // Remove the memory that will be freed from the allocated memory
    // list by restoring the memory list pointer.
    // If an exception occures during one of these free routines, we 
    // are in trouble anyway.
        
    pStubMsg->pMemoryList = pMemoryListSave;

    {
        uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        NDR_POINTER_QUEUE *pOldQueue = NULL;

        // Set the current queue to NULL so that all pointees will be
        // queued and freed together
        if ( pStubMsg->pPointerQueueState )
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            (*pfnFreeRoutines[ ROUTINE_INDEX( *pFormat )])( pStubMsg,
                                                            pTransmittedType,
                                                            pFormat );
            }
        RpcFinally
            {
            pStubMsg->PointerBufferMark = PointerBufferMarkSave;
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally

    }

    return 0;
}

unsigned char * RPC_ENTRY
NdrXmitOrRepAsUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a transmit as (or represent as)object.

    Means:  allocate the transmitted object,
            unmarshall transmitted object,
            translate the transmitted into presented
            free the transmitted.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - a pointer to the stub message
    ppMemory    - pointer to the presented type where to put data
    pFormat     - format string description
    fMustAlloc  - allocate flag

Note.
    fMustAlloc is ignored as we always allocate outside of the buffer.

--*/
{
    unsigned char *          pTransmittedType;
    unsigned char  *         pPresentedType = *ppMemory;
    __int64                  SimpleTypeValueBuffer[2];
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;
    unsigned short           QIndex;
    unsigned long            PresentedTypeSize;
    uchar *                  PointerBufferMarkSave;
    BOOL                     fXmitByPtr = *pFormat == FC_TRANSMIT_AS_PTR ||
                                          *pFormat == FC_REPRESENT_AS_PTR;
    (void)                   fMustAlloc;

    if ( fXmitByPtr )
        {
        NdrpXmitOrRepAsPtrUnmarshall( pStubMsg,
                                      ppMemory,
                                      pFormat,
                                      fMustAlloc );
        return 0;
        }

    // Fetch the QuintupleIndex.

    QIndex = *(unsigned short *)(pFormat + 2);
    PresentedTypeSize = *(unsigned short *)(pFormat + 4);

    if ( ! pPresentedType )
        {
        //Allocate a presented type object first.

        pPresentedType = (uchar*)NdrAllocate( pStubMsg, (uint) PresentedTypeSize );
        MIDL_memset( pPresentedType, 0, (uint) PresentedTypeSize );
        }

    // Allocate the transmitted object outside of the buffer
    // and unmarshall into it

    pFormat += 8;
    pFormat = pFormat + *(short *)pFormat;

    if ( IS_SIMPLE_TYPE( *pFormat ))
        {
        pTransmittedType = (unsigned char *)SimpleTypeValueBuffer;
        
        NdrSimpleTypeUnmarshall( pStubMsg,
                                 pTransmittedType,
                                *pFormat );
        
        // Translate from the transmitted type into the presented type.

        pStubMsg->pTransmitType = pTransmittedType;
        pStubMsg->pPresentedType = pPresentedType;

        pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );

        *ppMemory = pStubMsg->pPresentedType;
        }
    else
        {

        // Save the current state of the memory list so that the temporary
        // memory allocated for the transmitted type can be easily removed
        // from the list.   This assumes that the memory allocated here 
        // will not have any linkes to other blocks of memory.   This is true
        // as long as full pointers are not used.  Fortunatly, full pointers
        // do not work correctly in the current code.
   
        void *pMemoryListSave = pStubMsg->pMemoryList;        
    
        {
            uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
            pStubMsg->PointerBufferMark = 0;
            NDR_POINTER_QUEUE *pOldQueue = NULL;

            // Set the current queue to NULL so that all pointees will be
            // queued and unmarshalled together
            if ( pStubMsg->pPointerQueueState )
                {
                pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
                pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
                }

            pTransmittedType = NULL; //asking the engine to allocate

            RpcTryFinally
                {
                (*pfnUnmarshallRoutines[ ROUTINE_INDEX( *pFormat )])
                       ( pStubMsg,
                         & pTransmittedType,
                         pFormat,
                         TRUE );
                }
            RpcFinally
                {
                pStubMsg->PointerBufferMark = PointerBufferMarkSave;
                if ( pStubMsg->pPointerQueueState )
                    {
                    pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                    }
                }
            RpcEndFinally

        }

        // Translate from the transmitted type into the presented type.
    
        pStubMsg->pTransmitType = pTransmittedType;
        pStubMsg->pPresentedType = pPresentedType;
    
        pQuintuple[ QIndex ].pfnTranslateFromXmit( pStubMsg );
    
        *ppMemory = pStubMsg->pPresentedType;

        // Free the transmitted object (it was allocated by the engine)
        // and its pointees. The call through the table frees the pointees
        // only (plus it'd free the object itself if it were a pointer).
        // As the transmitted type is not a pointer here, we need to free it
        // explicitely later.

        // Remove the memory that will be freed from the allocated memory
        // list by restoring the memory list pointer.
        // If an exception occures during one of these free routines, we 
        // are in trouble anyway.
        
        pStubMsg->pMemoryList = pMemoryListSave;        

        {        
            uchar *PointerBufferMarkSave = pStubMsg->PointerBufferMark;
            pStubMsg->PointerBufferMark = 0;
            NDR_POINTER_QUEUE *pOldQueue = NULL;

            // Set the current queue to NULL so that all pointees will be
            // queued and freed together
            if ( pStubMsg->pPointerQueueState )
                {
                pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
                pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
                }

            RpcTryFinally
                {
                (*pfnFreeRoutines[ ROUTINE_INDEX( *pFormat )])( pStubMsg,
                                                                pTransmittedType,
                                                                pFormat );
                }
            RpcFinally
                {
                pStubMsg->PointerBufferMark = PointerBufferMarkSave;
                if ( pStubMsg->pPointerQueueState )
                    {
                    pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                    }
                }
            RpcEndFinally

        }

        // The buffer reusage check.

        if ( pTransmittedType < pStubMsg->BufferStart  ||
             pTransmittedType > pStubMsg->BufferEnd )
            (*pStubMsg->pfnFree)( pTransmittedType );

        }

    return 0;
}


void
NdrpUserMarshalUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Unmarshals a user_marshal object.
    The layout is described in marshalling.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the memory where the object should be unmarshalled to.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    unsigned char *pUserBuffer = pStubMsg->Buffer;
    unsigned char *pUserBufferSaved = pUserBuffer;
    USER_MARSHAL_CB UserMarshalCB;

    NdrpInitUserMarshalCB( pStubMsg,
                           pFormat,
                           USER_MARSHAL_CB_UNMARSHALL, 
                           & UserMarshalCB );

    unsigned short QIndex = *(unsigned short *)(pFormat + 2);
    const USER_MARSHAL_ROUTINE_QUADRUPLE *pQuadruple = 
        pStubMsg->StubDesc->aUserMarshalQuadruple;

    if ((pUserBufferSaved < (uchar *) pStubMsg->RpcMsg->Buffer) ||
        ((unsigned long) (pUserBufferSaved - (uchar *) pStubMsg->RpcMsg->Buffer) 
                                           > pStubMsg->RpcMsg->BufferLength)) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    pUserBuffer = pQuadruple[ QIndex ].pfnUnmarshall( (ulong*) &UserMarshalCB,
                                                      pUserBuffer,
                                                      pMemory );

    if ((pUserBufferSaved > pUserBuffer) || 
        ((unsigned long) (pUserBuffer - (uchar *) pStubMsg->RpcMsg->Buffer)
                                      > pStubMsg->RpcMsg->BufferLength )) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    pStubMsg->Buffer = pUserBuffer;

    return;
}

void 
NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    NdrpUserMarshalUnmarshall( pStubMsg,
                               pMemory,
                               pFormat );
}
#if defined(DBG)
void 
NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


unsigned char *
NdrUserMarshalUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )

{
    // Align for the object or a pointer to it.
    unsigned long PointerMarker = 0;
    ALIGN( pStubMsg->Buffer, LOW_NIBBLE(pFormat[1]) );

    // Take care of the pointer, if any.

    if ( (pFormat[1] & USER_MARSHAL_UNIQUE)  ||
         ((pFormat[1] & USER_MARSHAL_REF) && pStubMsg->PointerBufferMark) )
        {
        PointerMarker = *((unsigned long * &)pStubMsg->Buffer)++;
        }

    // We always call user's routine to unmarshall the user object.

    // However, the top level object is allocated by the engine.
    // Thus, the behavior is exactly the same as for represent_as(),
    // with regard to the top level presented type.

    if ( *ppMemory == NULL )
        {
        // Allocate a presented type object first.

        uint MemSize = *(ushort *)(pFormat + 4);

        *ppMemory = (uchar *) NdrAllocate( pStubMsg, MemSize );

        MIDL_memset( *ppMemory, 0, MemSize );
        }

    if ( pFormat[1] & USER_MARSHAL_POINTER )
       {

       if ((pFormat[1] & USER_MARSHAL_UNIQUE) && !PointerMarker )
           return 0;

       if ( !pStubMsg->pPointerQueueState ||
            !pStubMsg->pPointerQueueState->GetActiveQueue())
           {           
           POINTER_BUFFER_SWAP_CONTEXT NewContext(pStubMsg);
           NdrpUserMarshalUnmarshall( 
               pStubMsg,
               *ppMemory,
               pFormat );
           }
       else
           {
           NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT*pElement = 
              new(pStubMsg->pPointerQueueState) 
                  NDR_USR_MRSHL_UNMRSHL_POINTER_QUEUE_ELEMENT(*ppMemory,
                                                              pFormat );
           pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
           }

       return 0;
       }

    NdrpUserMarshalUnmarshall( 
        pStubMsg,
        *ppMemory,
        pFormat );

    return 0;
}


void 
NdrpInterfacePointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat )
/*++

Routine Description :

    Unmarshalls an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the interface pointer being unmarshalled.
    pFormat     - Interface pointer's format string description.

Return :

    None.

Notes : There are two data representation formats for a marshalled
        interface pointer. The NDR engine examines the format string
        to determine the appropriate data format.  The format string
        contains FC_IP followed by either FC_CONSTANT_IID or FC_PAD.

        Here is the data representation for the FC_CONSTANT_IID case.

            typedef struct
            {
                unsigned long size;
                [size_is(size)] byte data[];
            }MarshalledInterface;

        Here is the data representation for the FC_PAD case.  This format
        is used when [iid_is] is specified in the IDL file.

            typedef struct
            {
                uuid_t iid;
                unsigned long size;
                [size_is(size)] byte data[];
            }MarshalledInterfaceWithIid;

--*/
{
    HRESULT         hr;
    unsigned long   MaxCount, Size;
    IStream *       pStream;

    ALIGN(pStubMsg->Buffer,0x3);

    // Unmarshal the conformant size and the count field.
    MaxCount = *((unsigned long * &) pStubMsg->Buffer)++;
    Size     = *((unsigned long * &) pStubMsg->Buffer)++;

    //Check the array bounds
    if ( Size != MaxCount )
        RpcRaiseException( RPC_X_BAD_STUB_DATA );

    if( MaxCount > 0)
        {
        CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, MaxCount );

      if ( F_CORRELATION_CHECK )
            {
            IID     *piid, *piidValue;
            BOOL    fDoCheck = FALSE;

            // Get a pointer to the IID hidden in the interface pointer
            // representation in the buffer with Rick's IRpcHelper.
            //
            NdrpGetIIDFromBuffer( pStubMsg, & piidValue );

            //
            // Get an IID pointer to compare.
            //
            if ( pFormat[1] == FC_CONSTANT_IID )
                {
                //
                // The IID may not be aligned properly in the format string,
                // so we copy it to a local variable.
                //
                piid = (IID*) (pFormat + 2);
                fDoCheck = TRUE;
                }
            else
                {
                ULONG_PTR     MaxCountSave = pStubMsg->MaxCount;
                uchar *       pMemorySave  = pStubMsg->Memory;

                pStubMsg->MaxCount = 0;
                pStubMsg->Memory   = pStubMsg->pCorrMemory;
                piid = (IID *)
                              NdrpComputeIIDPointer( pStubMsg,
                                                     *ppMemory, // should not be used
                                                     pFormat );
                if (piid != 0)
                    {
                    PNDR_FCDEF_CORRELATION  pFormatCorr = (PNDR_FCDEF_CORRELATION)(pFormat+2);

                    if ( pFormatCorr->CorrFlags.Early )
                        fDoCheck = TRUE;
                    else
                        {
                        // save ptr as a value to check
                        NdrpAddCorrelationData( pStubMsg,
                                                pStubMsg->pCorrMemory,
                                                pFormat + 2,
                                                (LONG_PTR) piid,  // "value"
                                                NDR_CHECK_CONFORMANCE );
                        }
                    }
                    // else could not check for -Os etc.

                pStubMsg->MaxCount = MaxCountSave;
                pStubMsg->Memory   = pMemorySave;
                }

            if ( fDoCheck  &&
                 0 != memcmp( piidValue, piid, sizeof(IID) ) )
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }

        pStream = (*NdrpCreateStreamOnMemory)(pStubMsg->Buffer, MaxCount);
        if(pStream == 0)
            RpcRaiseException(RPC_S_OUT_OF_MEMORY);

        hr = (*pfnCoUnmarshalInterface)(pStream, IID_NULL, (void**)ppMemory);
        pStream->Release();
        pStream = 0;

        if(FAILED(hr))
            RpcRaiseException(hr);
        }

    //Advance the stub message pointer.

    pStubMsg->Buffer += MaxCount;
}

unsigned char * RPC_ENTRY
NdrInterfacePointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               /*fMustAlloc*/ )
{

    // This is only called for toplevel interface pointers
    // in Os mode stubs.
    IUnknown **     ppunk = (IUnknown **)ppMemory;
    
    // On the client side, release the [in,out] interface pointer.

    if ((pStubMsg->IsClient == TRUE) && (*ppunk != 0))
        (*ppunk)->Release();

    *ppunk = 0;

    //
    // We always have to pickup the pointer itself from the wire
    // as it behaves like a unique pointer.

    ALIGN(pStubMsg->Buffer,0x3);
    long PtrValue = *((long * &)pStubMsg->Buffer)++;

    // If the pointer is null, we are done.

    if ( 0 == PtrValue )
        return 0;

    NdrpInterfacePointerUnmarshall(
        pStubMsg,
        ppMemory,
        pFormat );

    return 0;
}


void RPC_ENTRY
NdrClientContextUnmarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_CCONTEXT *        pContextHandle,
    RPC_BINDING_HANDLE    BindHandle )
/*++

Routine Description :

    Unmarshalls a context handle on the client side.

Arguments :

    pStubMsg        - Pointer to stub message.
    pContextHandle  - Pointer to context handle to unmarshall.
    BindHandle      - The handle value used by the client for binding.

Return :

    None.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called NdrUnmarshallHandle
    // and can be found in hndl.c

    ALIGN(pStubMsg->Buffer,3);

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );    

    // All 20 bytes of the buffer are touched so a check is not needed here.

    NDRCContextUnmarshall( pContextHandle,
                           BindHandle,
                           pStubMsg->Buffer,
                           pStubMsg->RpcMsg->DataRepresentation );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

NDR_SCONTEXT RPC_ENTRY
NdrServerContextUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg )
/*++

Routine Description :

    Unmarshalls a context handle on the server side.

Arguments :

    pStubMsg    - Pointer to stub message.

Return :

    The unmarshalled context handle.

--*/
{
    // Note, this is a routine called directly from -Os stubs.
    // The routine called by interpreter is called NdrUnmarshallHandle
    // and can be found in hndl.c

    NDR_SCONTEXT    Context;

    ALIGN(pStubMsg->Buffer,3);

    // we might corrupt the memory during the byte swap 
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );    

    // All 20 bytes of the buffer are touched so a check is not needed here.

    Context = NDRSContextUnmarshall2(pStubMsg->RpcMsg->Handle,
                                     pStubMsg->Buffer,
                                     pStubMsg->RpcMsg->DataRepresentation,
                                     RPC_CONTEXT_HANDLE_DEFAULT_GUARD,
                                     RPC_CONTEXT_HANDLE_DEFAULT_FLAGS );

    if ( ! Context )
        RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

    return Context;
}

NDR_SCONTEXT  RPC_ENTRY
NdrContextHandleInitialize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*
    This routine is to initialize a context handle with a new NT5 flavor.
    It is used in conjunction with NdrContextHandleUnmarshal.
*/
{
    NDR_SCONTEXT    SContext;
    void *          pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD           Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pFormat[1] & NDR_STRICT_CONTEXT_HANDLE )
        {
        // The guard is defined as the interface ID.
        // If you change it, modify hndlsvr.cxx in the same way.

        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pFormat[1] & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pFormat[1] & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    SContext = NDRSContextUnmarshall2(
                    pStubMsg->RpcMsg->Handle,
                    (void *)0,  // buffer
                    pStubMsg->RpcMsg->DataRepresentation,
                    pGuard,
                    Flags );

    return SContext;
}

NDR_SCONTEXT RPC_ENTRY
NdrServerContextNewUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PFORMAT_STRING      pFormat )
/*
    This routine to unmarshal a context handle with a new NT5 flavor.
    For the old style handles, we call an optimized routine
    NdrServerContextUnmarshall below.
    Interpreter calls NdrUnmarshallHandle from hndl.c

      ppMemory - note, this is not a pointer to user's context handle but
                 a pointer to NDR_SCONTEXT pointer to the runtime internal object.
                 User's handle is a field of that object.
*/
{
    NDR_SCONTEXT    SContext;

    void *          pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD           Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;

    ALIGN( pStubMsg->Buffer, 0x3 );

    // we might corrupt the memory during the byte swap
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + CONTEXT_HANDLE_WIRE_SIZE );

    // Anti-attack defense for servers, NT5 beta3 feature.

    if ( pFormat[1] & NDR_CONTEXT_HANDLE_CANNOT_BE_NULL )
        {
        // Check the incoming context handle on the server.
        // Context handle wire layout: ulong with version (always 0), then a uuid.
        //
        if ( !pStubMsg->IsClient  &&  0 == memcmp( pStubMsg->Buffer + 4,
                                                   &GUID_NULL,
                                                   sizeof(GUID) ) )
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }

    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pFormat[1] & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pFormat[1] & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pFormat[1] & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    SContext = NDRSContextUnmarshall2(
                    pStubMsg->RpcMsg->Handle,
                    pStubMsg->Buffer,
                    pStubMsg->RpcMsg->DataRepresentation,
                    pGuard,
                    Flags );

    if ( ! SContext )
        RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

    return SContext;
}


#ifdef _CS_CHAR_
unsigned char * RPC_ENTRY
NdrCsTagUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a cs tag.

Arguments :

    pStubMsg    - Pointer to stub message.
    ppMemory    - Double pointer to where to unmarshall to
    pFormat     - The format string entry
    fMustAlloc  - TRUE if we can't reuse the buffer (not relevant in this case)

--*/
{
    NDR_CS_TAG_FORMAT *pTagFormat = (NDR_CS_TAG_FORMAT *) pFormat;

    ulong Codeset = NdrpGetSetCSTagUnmarshall(
                            pStubMsg, 
                            (NDR_CS_TAG_FORMAT *) pFormat);

    // If there is a tag routine, then this parameter is not on the stack

    if ( NDR_INVALID_TAG_ROUTINE_INDEX == pTagFormat->TagRoutineIndex )
        ** (ulong **) ppMemory = Codeset;

    pStubMsg->Buffer += sizeof(ulong);

    return 0;
}


unsigned char * RPC_ENTRY
NdrCsArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PFORMAT_STRING      pFormat,
    uchar               fMustAlloc )
/*++

Routine Description :

    Unmarshalls a international character (cs) array tag.

Arguments :

    pStubMsg    - Pointer to stub message.
    ppMemory    - Double pointer to where to unmarshall to
    pFormat     - The format string entry
    fMustAlloc  - TRUE if we can't reuse the buffer

--*/
{
    ulong                       LocalCodeset;
    error_status_t              status;
    uchar                      *ConvertedData;
    uchar                      *UnconvertedData;
    ulong                       ArraySize;
    ulong                       WireLength;
    uchar                      *OldBuffer;
    uchar                       fMustAllocOriginal;
    BOOL                        IsClient;

    NDR_CS_ARRAY_FORMAT            *pCSFormat;
    NDR_CS_SIZE_CONVERT_ROUTINES   *CSRoutines;
    CS_TYPE_LOCAL_SIZE_ROUTINE      LocalSizeRoutine;
    CS_TYPE_FROM_NETCS_ROUTINE      FromNetCSRoutine;
    IDL_CS_CONVERT                  ConversionType;

    pCSFormat = (NDR_CS_ARRAY_FORMAT *) pFormat;

    NDR_ASSERT( NULL != pStubMsg->pCSInfo, "cs stub info not set up");

    // Get all the info out of the FC_CS_ARRAY structure and bump pFormat
    // to point to the underlying data descriptor

    CSRoutines = pStubMsg->StubDesc->CsRoutineTables->pSizeConvertRoutines;
    LocalSizeRoutine = CSRoutines[ pCSFormat->CSRoutineIndex].pfnLocalSize;
    FromNetCSRoutine = CSRoutines[ pCSFormat->CSRoutineIndex].pfnFromNetCs;

    pFormat += pCSFormat->DescriptionOffset;

// REVIEW:  A lot of this code can be eleminted by calling memsize on the 
//          cs_char array instead of the underlying one.

    // Get the size of the data on the wire

    OldBuffer = pStubMsg->Buffer;

    WireLength = PtrToUlong( NdrpMemoryIncrement( pStubMsg, 0, pFormat ) );

    // Figure out whether we need to convert and how much we need to allocate
    // if we do

    LocalSizeRoutine(
            pStubMsg->RpcMsg->Handle,
            pStubMsg->pCSInfo->WireCodeset,
            WireLength,
            &ConversionType,
            &ArraySize,
            &status);

    if ( RPC_S_OK != status )
        RpcRaiseException( status );

    // If we need to convert we just want the unmarshalling routine to give us
    // back a pointer and not do any allocations.  We'll do the allocation 
    // later if need be.

    IsClient = pStubMsg->IsClient;

    if ( IDL_CS_NO_CONVERT != ConversionType )
        {
        fMustAllocOriginal = fMustAlloc;
        OldBuffer = *ppMemory;
        *ppMemory = NULL;
        fMustAlloc = FALSE;
        
        // Slimy hack to enable buffer reuse on the client side
        pStubMsg->IsClient = FALSE;
        }

    // Unmarshall the base array

    pfnUnmarshallRoutines[ ROUTINE_INDEX( *pFormat ) ] (
            pStubMsg,
            ppMemory,
            pFormat,
            fMustAlloc );

    pStubMsg->IsClient = IsClient;

    // If we don't need to convert, we're done

    if ( IDL_CS_NO_CONVERT == ConversionType )
        return 0;
   
    // Make sure we've got a buffer to convert into

    NDR_ASSERT( NULL != *ppMemory, "Invalid memory pointer" );

    UnconvertedData = *ppMemory;
    *ppMemory = OldBuffer;

    if ( fMustAllocOriginal || NULL == *ppMemory )
        {
        *ppMemory = (uchar *) NdrAllocate( 
                                    pStubMsg, 
                                    ArraySize * pCSFormat->UserTypeSize );
        }
    else if ( pStubMsg->IsClient )
        {
        // Make sure we don't overflow the client's buffer

        long ClientArraySize;
        long ClientArrayLength;
        long ClientWireSize;

        NdrpGetArraySizeLength(
                            pStubMsg,
                            *ppMemory,
                            pFormat,
                            pCSFormat->UserTypeSize,
                            &ClientArraySize,
                            &ClientArrayLength,
                            &ClientWireSize );

        ArraySize = min( ArraySize, (ulong)ClientArraySize );
        }

    // Reset the conformance variable to the new array size

    if ( NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ] & MARSHALL_CONFORMANCE )
        {
        uchar *pOldCorrMemory = pStubMsg->pCorrMemory;

        if ( !pStubMsg->pCorrMemory )
            pStubMsg->pCorrMemory = pStubMsg->StackTop;

        NdrpCheckCorrelation(
                pStubMsg,
                ArraySize,
                pFormat,
                NDR_CHECK_CONFORMANCE | NDR_RESET_VALUE );

        pStubMsg->pCorrMemory = pOldCorrMemory;
        }

    // Do the conversion

    FromNetCSRoutine(
            pStubMsg->RpcMsg->Handle,
            pStubMsg->pCSInfo->WireCodeset,
            UnconvertedData,
            WireLength,
            ArraySize,
            *ppMemory,
            &ArraySize,     // Actually it returns the length not the size
            &status);

    if ( RPC_S_OK != status )
        RpcRaiseException( status );

    // Reset the variance variable to the new array length

    if ( NdrpArrayMarshallFlags[ *pFormat - FC_CARRAY ] & MARSHALL_VARIANCE )
        {
        NdrpCheckCorrelation(
                pStubMsg,
                ArraySize,
                pFormat,
                NDR_CHECK_VARIANCE | NDR_RESET_VALUE );
        }

    return 0;
}
#endif // _CS_CHAR_


void
NdrPartialIgnoreServerUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    void **                             ppMemory 
    )
{
    ALIGN( pStubMsg->Buffer, 0x3 );
    *ppMemory = UlongToPtr( *(ulong*)pStubMsg->Buffer );
    pStubMsg->Buffer += PTR_WIRE_SIZE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\amd64\stubless.asm ===
title   "Stubless Support"
;++
;
; Copyright (C) 2000  Microsoft Corporation
;
; Module Name:
;
;   stubless.asm
;
; Abstract:
;
;   This module contains interpreter support routines for the AMD64 platform.
;
; Author:
;
;   David N. Cutler 30-Dec-2000
;
; Environment:
;
;   User mode.
;
;--

include ksamd64.inc

        extern  ObjectStublessClient:proc
        extern  __chkstk:proc

;
; Define object stubless client macro.
;

STUBLESS_CLIENT macro Method

        LEAF_ENTRY ObjectStublessClient&Method, _TEXT$00

        mov     r10d, Method            ; set method number
        jmp     ObjectStubless          ; finish in common code

        LEAF_END ObjectStublessClient&Method, _TEXT$00

        endm

;
; Generate stubless client thunks.
;

index = 3

        rept    (1023 - 3 + 1)

        STUBLESS_CLIENT %index

index = index + 1

        endm

        subttl  "Common Object Stubless Client Code"
;++
;
; long
; ObjectStubless (
;     ...
;     )
;
; Routine description:
;
;   This function is jumped to from the corresponding linkage stub and calls
;   the object stubless client routine to invoke the ultimate function.
;
; Arguments:
;
;   ...
;
; Implicit Arguments:
;
;   Method (r10d) - Supplies the method number from the thunk code.
;
; Return Value:
;
;   The value as returned by the target function.
;
;--

OsFrame struct
        P1Home    dq ?                  ; argument home addresses
        P2Home    dq ?                  ; 
        P3Home    dq ?                  ;
        P4Home    dq ?                  ; 
        SavedXmm0 dq ?                  ; saved floating argument registers
        SavedXmm1 dq ?                  ;
        SavedXmm2 dq ?                  ;
        SavedXmm3 dq ?                  ;
        Fill      dq ?                  ;
OsFrame ends

        NESTED_ENTRY ObjectStubless, _TEXT$00

        mov     8[rsp], rcx             ; save integer argument registers
        mov     16[rsp], rdx            ;
        mov     24[rsp], r8             ;
        mov     32[rsp], r9             ;

        alloc_stack sizeof OsFrame      ; allocate stack frame

        END_PROLOGUE

        movq    OsFrame.SavedXmm0[rsp], xmm0 ; save floating argument registers
        movq    OsFrame.SavedXmm1[rsp], xmm1 ;
        movq    OsFrame.SavedXmm2[rsp], xmm2 ;
        movq    OsFrame.SavedXmm3[rsp], xmm3;

        lea     rcx, sizeof OsFrame + 8[rsp] ; set integer arguments address
        lea     rdx, OsFrame.SavedXmm0[rsp]  ; set floating arguments address
        mov     r8d, r10d               ; set method number
        call    ObjectStublessClient    ;
        add     rsp, sizeof OsFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END ObjectStubless, _TEXT$00

        subttl  "Invoke Function with Parameter List"
;++
;
; REGISTER_TYPE
; Invoke (
;     MANAGER_FUNCTION Function,
;     REGISTER_TYPE *ArgumentList,
;     ULONG FloatArgMask,
;     ULONG Arguments
;     )
;
; Routine description:
;
;   This function builds an appropriate argument list and calls the specified
;   function.
;
; Arguments:
;
;   Function (rcx) - Supplies a pointer to the target function.
;
;   ArgumentList (rdx) - Supplies a pointer to the argument list.
;
;   FloatArgMask (r8d) - Supplies the floating argument register mask (not
;       used.
;
;   Arguments (r9d) - Supplies the number of arguments.
;
; Return Value:
;
;   The value as returned by the target function.
;
;--

        NESTED_ENTRY Invoke, _TEXT$00

        push_reg rdi                    ; save nonvolatile registers
        push_reg rsi                    ;
        push_reg rbp                    ;
        set_frame rbp, 0                ; set frame pointer

        END_PROLOGUE

        mov     eax, r9d                ; round to even argument count
        inc     eax                     ;
        and     al, 0feh                ;
        shl     eax, 3                  ; compute number of bytes
        call    __chkstk                ; check stack allocation
        sub     rsp, rax                ; allocate argument list
        mov     r10, rcx                ; save address of function
        mov     rsi, rdx                ; set source argument list address
        mov     rdi, rsp                ; set destination argument list address
        mov     ecx, r9d                ; set number of arguments
    rep movsq                           ; copy arguments to the stack

;
; N.B. All four argument registers are loaded regardless of the actual number
;      of arguments.
;

        mov     rcx, 0[rsp]             ; load first four argument registers
        movq    xmm0, 0[rsp]            ;
        mov     rdx, 8[rsp]             ;
        movq    xmm1, 8[rsp]            ;
        mov     r8, 16[rsp]             ;
        movq    xmm2, 16[rsp]           ;
        mov     r9, 24[rsp]             ;
        movq    xmm3, 24[rsp]           ;
        call    r10                     ; call target function
        mov     rsp, rbp                ; deallocate argument list
        pop     rbp                     ; restore nonvolatile register
        pop     rsi                     ;
        pop     rdi                     ;
        ret                             ;

        NESTED_END Invoke, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\ia64\forward.s ===
/*++

  Copyright  c  1994  Microsoft Corporation.  All rights reserved.

  Module Name:
     forward.s

  Abstract:
     This module implements the proxy forwarding functions.

  Author:
    ShannonC    26-Oct-94

  Environment:                     
   
     Any mode.
  Revision History:

--*/

#include "ksia64.h"
        .file   "forward.s"
/*++

 VOID
 NdrProxyForwardingFunction<nnn>(...)

 Routine Description:

    This function forwards a call to the proxy for the base interface.

 Arguments:

    This [a0] - Points to an interface proxy.

 Return Value:

    None.

--*/


// here is what a forwarder looks like
// we must:
//      change the "this" pointer in [esp+4] to point to the delegated object
//      fetch the correct entry from the vtable
//      call the function

#define SUBCLASS_OFFSET     32
#define VTABLE_ENTRY(n)     n*8

/*
    this is a macro for delegation methods. It first retrives BaseProxyBuffer
    from the proxy vtbl, then deference to get the base vtbl.  From the offset
    in vtbl, we get the pair of real .ObjectStublessClient##method_number
    and gp. bp & b6 is loaded up accordingly and the code is branched into
    ObjectStublessClient##method_number
*/
#define DELEGATION_FORWARDER(method_number)        \
        LEAF_ENTRY( NdrProxyForwardingFunction##method_number );        \
        add             r32 = SUBCLASS_OFFSET, r32;                     \
        ;;                                                              \
        LDPTR           (r32, r32);;                                     \
        LDPTR           (r2, r32);;                                     \
        add             r2 = VTABLE_ENTRY(method_number), r2;;          \
        LDPTR           (r2, r2 );;                                       \
        LDPTRINC        (r3, r2, 8);                                    \
        ;;                                                              \
        LDPTR           (gp, r2);                                       \
        mov             b6 = r3;                                        \
        br##.##sptk##.##clr     b6;                                     \
        LEAF_EXIT( NdrProxyForwardingFunction##method_number )

    DELEGATION_FORWARDER(3)

    DELEGATION_FORWARDER(4)

    DELEGATION_FORWARDER(5)

    DELEGATION_FORWARDER(6)

    DELEGATION_FORWARDER(7)
    
    DELEGATION_FORWARDER(8)
    
    DELEGATION_FORWARDER(9)
    
    DELEGATION_FORWARDER(10)
    
    DELEGATION_FORWARDER(11)
    
    DELEGATION_FORWARDER(12)
    
    DELEGATION_FORWARDER(13)
    
    DELEGATION_FORWARDER(14)
    
    DELEGATION_FORWARDER(15)
    
    DELEGATION_FORWARDER(16)
    
    DELEGATION_FORWARDER(17)
    
    DELEGATION_FORWARDER(18)
    
    DELEGATION_FORWARDER(19)
    
    DELEGATION_FORWARDER(20)
    
    DELEGATION_FORWARDER(21)
    
    DELEGATION_FORWARDER(22)
    
    DELEGATION_FORWARDER(23)
    
    DELEGATION_FORWARDER(24)
    
    DELEGATION_FORWARDER(25)
    
    DELEGATION_FORWARDER(26)
    
    DELEGATION_FORWARDER(27)
    
    DELEGATION_FORWARDER(28)
    
    DELEGATION_FORWARDER(29)
    
    DELEGATION_FORWARDER(30)
    
    DELEGATION_FORWARDER(31)
    
    DELEGATION_FORWARDER(32)
    
    DELEGATION_FORWARDER(33)
    
    DELEGATION_FORWARDER(34)
    
    DELEGATION_FORWARDER(35)
    
    DELEGATION_FORWARDER(36)
    
    DELEGATION_FORWARDER(37)
    
    DELEGATION_FORWARDER(38)
    
    DELEGATION_FORWARDER(39)
    
    DELEGATION_FORWARDER(40)
    
    DELEGATION_FORWARDER(41)
    
    DELEGATION_FORWARDER(42)
    
    DELEGATION_FORWARDER(43)
    
    DELEGATION_FORWARDER(44)
    
    DELEGATION_FORWARDER(45)
    
    DELEGATION_FORWARDER(46)
    
    DELEGATION_FORWARDER(47)
    
    DELEGATION_FORWARDER(48)
    
    DELEGATION_FORWARDER(49)
    
    DELEGATION_FORWARDER(50)
    
    DELEGATION_FORWARDER(51)
    
    DELEGATION_FORWARDER(52)
    
    DELEGATION_FORWARDER(53)
    
    DELEGATION_FORWARDER(54)
    
    DELEGATION_FORWARDER(55)
    
    DELEGATION_FORWARDER(56)
    
    DELEGATION_FORWARDER(57)
    
    DELEGATION_FORWARDER(58)
    
    DELEGATION_FORWARDER(59)
    
    DELEGATION_FORWARDER(60)
    
    DELEGATION_FORWARDER(61)
    
    DELEGATION_FORWARDER(62)
    
    DELEGATION_FORWARDER(63)
    
    DELEGATION_FORWARDER(64)
    
    DELEGATION_FORWARDER(65)
    
    DELEGATION_FORWARDER(66)
    
    DELEGATION_FORWARDER(67)
    
    DELEGATION_FORWARDER(68)
    
    DELEGATION_FORWARDER(69)
    
    DELEGATION_FORWARDER(70)
    
    DELEGATION_FORWARDER(71)
    
    DELEGATION_FORWARDER(72)
    
    DELEGATION_FORWARDER(73)
    
    DELEGATION_FORWARDER(74)
    
    DELEGATION_FORWARDER(75)
    
    DELEGATION_FORWARDER(76)
    
    DELEGATION_FORWARDER(77)
    
    DELEGATION_FORWARDER(78)
    
    DELEGATION_FORWARDER(79)
    
    DELEGATION_FORWARDER(80)
    
    DELEGATION_FORWARDER(81)
    
    DELEGATION_FORWARDER(82)
    
    DELEGATION_FORWARDER(83)
    
    DELEGATION_FORWARDER(84)
    
    DELEGATION_FORWARDER(85)
    
    DELEGATION_FORWARDER(86)
    
    DELEGATION_FORWARDER(87)
    
    DELEGATION_FORWARDER(88)
    
    DELEGATION_FORWARDER(89)
    
    DELEGATION_FORWARDER(90)
    
    DELEGATION_FORWARDER(91)
    
    DELEGATION_FORWARDER(92)
    
    DELEGATION_FORWARDER(93)
    
    DELEGATION_FORWARDER(94)
    
    DELEGATION_FORWARDER(95)
    
    DELEGATION_FORWARDER(96)
    
    DELEGATION_FORWARDER(97)
    
    DELEGATION_FORWARDER(98)
    
    DELEGATION_FORWARDER(99)
    
    DELEGATION_FORWARDER(100)
    
    DELEGATION_FORWARDER(101)
    
    DELEGATION_FORWARDER(102)
    
    DELEGATION_FORWARDER(103)
    
    DELEGATION_FORWARDER(104)
    
    DELEGATION_FORWARDER(105)
    
    DELEGATION_FORWARDER(106)
    
    DELEGATION_FORWARDER(107)
    
    DELEGATION_FORWARDER(108)
    
    DELEGATION_FORWARDER(109)
    
    DELEGATION_FORWARDER(110)
    
    DELEGATION_FORWARDER(111)
    
    DELEGATION_FORWARDER(112)
    
    DELEGATION_FORWARDER(113)
    
    DELEGATION_FORWARDER(114)
    
    DELEGATION_FORWARDER(115)
    
    DELEGATION_FORWARDER(116)
    
    DELEGATION_FORWARDER(117)
    
    DELEGATION_FORWARDER(118)
    
    DELEGATION_FORWARDER(119)
    
    DELEGATION_FORWARDER(120)
    
    DELEGATION_FORWARDER(121)
    
    DELEGATION_FORWARDER(122)
    
    DELEGATION_FORWARDER(123)
    
    DELEGATION_FORWARDER(124)
    
    DELEGATION_FORWARDER(125)
    
    DELEGATION_FORWARDER(126)
    
    DELEGATION_FORWARDER(127)
    
    DELEGATION_FORWARDER(128)
    
    DELEGATION_FORWARDER(129)
    
    DELEGATION_FORWARDER(130)
    
    DELEGATION_FORWARDER(131)
    
    DELEGATION_FORWARDER(132)
    
    DELEGATION_FORWARDER(133)
    
    DELEGATION_FORWARDER(134)
    
    DELEGATION_FORWARDER(135)
    
    DELEGATION_FORWARDER(136)
    
    DELEGATION_FORWARDER(137)
    
    DELEGATION_FORWARDER(138)
    
    DELEGATION_FORWARDER(139)
    
    DELEGATION_FORWARDER(140)
    
    DELEGATION_FORWARDER(141)
    
    DELEGATION_FORWARDER(142)
    
    DELEGATION_FORWARDER(143)
    
    DELEGATION_FORWARDER(144)
    
    DELEGATION_FORWARDER(145)
    
    DELEGATION_FORWARDER(146)
    
    DELEGATION_FORWARDER(147)
    
    DELEGATION_FORWARDER(148)
    
    DELEGATION_FORWARDER(149)
    
    DELEGATION_FORWARDER(150)
    
    DELEGATION_FORWARDER(151)
    
    DELEGATION_FORWARDER(152)
    
    DELEGATION_FORWARDER(153)
    
    DELEGATION_FORWARDER(154)
    
    DELEGATION_FORWARDER(155)
    
    DELEGATION_FORWARDER(156)
    
    DELEGATION_FORWARDER(157)
    
    DELEGATION_FORWARDER(158)
    
    DELEGATION_FORWARDER(159)
    
    DELEGATION_FORWARDER(160)
    
    DELEGATION_FORWARDER(161)
    
    DELEGATION_FORWARDER(162)
    
    DELEGATION_FORWARDER(163)
    
    DELEGATION_FORWARDER(164)
    
    DELEGATION_FORWARDER(165)
    
    DELEGATION_FORWARDER(166)
    
    DELEGATION_FORWARDER(167)
    
    DELEGATION_FORWARDER(168)
    
    DELEGATION_FORWARDER(169)
    
    DELEGATION_FORWARDER(170)
    
    DELEGATION_FORWARDER(171)
    
    DELEGATION_FORWARDER(172)
    
    DELEGATION_FORWARDER(173)
    
    DELEGATION_FORWARDER(174)
    
    DELEGATION_FORWARDER(175)
    
    DELEGATION_FORWARDER(176)
    
    DELEGATION_FORWARDER(177)
    
    DELEGATION_FORWARDER(178)
    
    DELEGATION_FORWARDER(179)
    
    DELEGATION_FORWARDER(180)
    
    DELEGATION_FORWARDER(181)
    
    DELEGATION_FORWARDER(182)
    
    DELEGATION_FORWARDER(183)
    
    DELEGATION_FORWARDER(184)
    
    DELEGATION_FORWARDER(185)
    
    DELEGATION_FORWARDER(186)
    
    DELEGATION_FORWARDER(187)
    
    DELEGATION_FORWARDER(188)
    
    DELEGATION_FORWARDER(189)
    
    DELEGATION_FORWARDER(190)
    
    DELEGATION_FORWARDER(191)
    
    DELEGATION_FORWARDER(192)
    
    DELEGATION_FORWARDER(193)
    
    DELEGATION_FORWARDER(194)
    
    DELEGATION_FORWARDER(195)
    
    DELEGATION_FORWARDER(196)
    
    DELEGATION_FORWARDER(197)
    
    DELEGATION_FORWARDER(198)
    
    DELEGATION_FORWARDER(199)
    
    DELEGATION_FORWARDER(200)
    
    DELEGATION_FORWARDER(201)
    
    DELEGATION_FORWARDER(202)
    
    DELEGATION_FORWARDER(203)
    
    DELEGATION_FORWARDER(204)
    
    DELEGATION_FORWARDER(205)
    
    DELEGATION_FORWARDER(206)
    
    DELEGATION_FORWARDER(207)
    
    DELEGATION_FORWARDER(208)
    
    DELEGATION_FORWARDER(209)
    
    DELEGATION_FORWARDER(210)
    
    DELEGATION_FORWARDER(211)
    
    DELEGATION_FORWARDER(212)
    
    DELEGATION_FORWARDER(213)
    
    DELEGATION_FORWARDER(214)
    
    DELEGATION_FORWARDER(215)
    
    DELEGATION_FORWARDER(216)
    
    DELEGATION_FORWARDER(217)
    
    DELEGATION_FORWARDER(218)
    
    DELEGATION_FORWARDER(219)
    
    DELEGATION_FORWARDER(220)
    
    DELEGATION_FORWARDER(221)
    
    DELEGATION_FORWARDER(222)
    
    DELEGATION_FORWARDER(223)
    
    DELEGATION_FORWARDER(224)
    
    DELEGATION_FORWARDER(225)
    
    DELEGATION_FORWARDER(226)
    
    DELEGATION_FORWARDER(227)
    
    DELEGATION_FORWARDER(228)
    
    DELEGATION_FORWARDER(229)
    
    DELEGATION_FORWARDER(230)
    
    DELEGATION_FORWARDER(231)
    
    DELEGATION_FORWARDER(232)
    
    DELEGATION_FORWARDER(233)
    
    DELEGATION_FORWARDER(234)
    
    DELEGATION_FORWARDER(235)
    
    DELEGATION_FORWARDER(236)
    
    DELEGATION_FORWARDER(237)
    
    DELEGATION_FORWARDER(238)
    
    DELEGATION_FORWARDER(239)
    
    DELEGATION_FORWARDER(240)
    
    DELEGATION_FORWARDER(241)
    
    DELEGATION_FORWARDER(242)
    
    DELEGATION_FORWARDER(243)
    
    DELEGATION_FORWARDER(244)
    
    DELEGATION_FORWARDER(245)
    
    DELEGATION_FORWARDER(246)
    
    DELEGATION_FORWARDER(247)
    
    DELEGATION_FORWARDER(248)
    
    DELEGATION_FORWARDER(249)
    
    DELEGATION_FORWARDER(250)
    
    DELEGATION_FORWARDER(251)
    
    DELEGATION_FORWARDER(252)
    
    DELEGATION_FORWARDER(253)
    
    DELEGATION_FORWARDER(254)
    
    DELEGATION_FORWARDER(255)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\ia64\stblsclt.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1995 Microsoft Corporation

Module Name :

    stblsclt.c

Abstract :

    This file contains the routines for support of stubless clients in
    object interfaces.

Author :

    David Kays    dkays    February 1995.

Revision History :

---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "hndl.h"
#include "interp2.h"
#include "ndrtypes.h"
#include "mulsyntx.h"

#include "ndrole.h"
#include "rpcproxy.h"

#pragma code_seg(".orpc")


typedef unsigned short  ushort;

EXTERN_C long
ObjectStublessClient(
    void *  ParamAddress,
    long    Method
    );

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall2(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    );

CLIENT_CALL_RETURN  RPC_ENTRY
NdrpDcomAsyncClientCall(
    PMIDL_STUB_DESC     pStubDescriptor,
    PFORMAT_STRING      pFormat,
    uchar *             StartofStack
    );

EXTERN_C void
SpillFPRegsForIA64(
    REGISTER_TYPE * pStack,
    ULONG           FloatArgMask
    );

extern "C"
{

void ObjectStublessClient3(void);
void ObjectStublessClient4(void);
void ObjectStublessClient5(void);
void ObjectStublessClient6(void);
void ObjectStublessClient7(void);

void ObjectStublessClient8(void);
void ObjectStublessClient9(void);
void ObjectStublessClient10(void);
void ObjectStublessClient11(void);
void ObjectStublessClient12(void);
void ObjectStublessClient13(void);
void ObjectStublessClient14(void);
void ObjectStublessClient15(void);
void ObjectStublessClient16(void);
void ObjectStublessClient17(void);
void ObjectStublessClient18(void);
void ObjectStublessClient19(void);
void ObjectStublessClient20(void);
void ObjectStublessClient21(void);
void ObjectStublessClient22(void);
void ObjectStublessClient23(void);
void ObjectStublessClient24(void);
void ObjectStublessClient25(void);
void ObjectStublessClient26(void);
void ObjectStublessClient27(void);
void ObjectStublessClient28(void);
void ObjectStublessClient29(void);
void ObjectStublessClient30(void);
void ObjectStublessClient31(void);
void ObjectStublessClient32(void);
void ObjectStublessClient33(void);
void ObjectStublessClient34(void);
void ObjectStublessClient35(void);
void ObjectStublessClient36(void);
void ObjectStublessClient37(void);
void ObjectStublessClient38(void);
void ObjectStublessClient39(void);
void ObjectStublessClient40(void);
void ObjectStublessClient41(void);
void ObjectStublessClient42(void);
void ObjectStublessClient43(void);
void ObjectStublessClient44(void);
void ObjectStublessClient45(void);
void ObjectStublessClient46(void);
void ObjectStublessClient47(void);
void ObjectStublessClient48(void);
void ObjectStublessClient49(void);
void ObjectStublessClient50(void);
void ObjectStublessClient51(void);
void ObjectStublessClient52(void);
void ObjectStublessClient53(void);
void ObjectStublessClient54(void);
void ObjectStublessClient55(void);
void ObjectStublessClient56(void);
void ObjectStublessClient57(void);
void ObjectStublessClient58(void);
void ObjectStublessClient59(void);
void ObjectStublessClient60(void);
void ObjectStublessClient61(void);
void ObjectStublessClient62(void);
void ObjectStublessClient63(void);
void ObjectStublessClient64(void);
void ObjectStublessClient65(void);
void ObjectStublessClient66(void);
void ObjectStublessClient67(void);
void ObjectStublessClient68(void);
void ObjectStublessClient69(void);
void ObjectStublessClient70(void);
void ObjectStublessClient71(void);
void ObjectStublessClient72(void);
void ObjectStublessClient73(void);
void ObjectStublessClient74(void);
void ObjectStublessClient75(void);
void ObjectStublessClient76(void);
void ObjectStublessClient77(void);
void ObjectStublessClient78(void);
void ObjectStublessClient79(void);
void ObjectStublessClient80(void);
void ObjectStublessClient81(void);
void ObjectStublessClient82(void);
void ObjectStublessClient83(void);
void ObjectStublessClient84(void);
void ObjectStublessClient85(void);
void ObjectStublessClient86(void);
void ObjectStublessClient87(void);
void ObjectStublessClient88(void);
void ObjectStublessClient89(void);
void ObjectStublessClient90(void);
void ObjectStublessClient91(void);
void ObjectStublessClient92(void);
void ObjectStublessClient93(void);
void ObjectStublessClient94(void);
void ObjectStublessClient95(void);
void ObjectStublessClient96(void);
void ObjectStublessClient97(void);
void ObjectStublessClient98(void);
void ObjectStublessClient99(void);
void ObjectStublessClient100(void);
void ObjectStublessClient101(void);
void ObjectStublessClient102(void);
void ObjectStublessClient103(void);
void ObjectStublessClient104(void);
void ObjectStublessClient105(void);
void ObjectStublessClient106(void);
void ObjectStublessClient107(void);
void ObjectStublessClient108(void);
void ObjectStublessClient109(void);
void ObjectStublessClient110(void);
void ObjectStublessClient111(void);
void ObjectStublessClient112(void);
void ObjectStublessClient113(void);
void ObjectStublessClient114(void);
void ObjectStublessClient115(void);
void ObjectStublessClient116(void);
void ObjectStublessClient117(void);
void ObjectStublessClient118(void);
void ObjectStublessClient119(void);
void ObjectStublessClient120(void);
void ObjectStublessClient121(void);
void ObjectStublessClient122(void);
void ObjectStublessClient123(void);
void ObjectStublessClient124(void);
void ObjectStublessClient125(void);
void ObjectStublessClient126(void);
void ObjectStublessClient127(void);
void ObjectStublessClient128(void);
void ObjectStublessClient129(void);
void ObjectStublessClient130(void);
void ObjectStublessClient131(void);
void ObjectStublessClient132(void);
void ObjectStublessClient133(void);
void ObjectStublessClient134(void);
void ObjectStublessClient135(void);
void ObjectStublessClient136(void);
void ObjectStublessClient137(void);
void ObjectStublessClient138(void);
void ObjectStublessClient139(void);
void ObjectStublessClient140(void);
void ObjectStublessClient141(void);
void ObjectStublessClient142(void);
void ObjectStublessClient143(void);
void ObjectStublessClient144(void);
void ObjectStublessClient145(void);
void ObjectStublessClient146(void);
void ObjectStublessClient147(void);
void ObjectStublessClient148(void);
void ObjectStublessClient149(void);
void ObjectStublessClient150(void);
void ObjectStublessClient151(void);
void ObjectStublessClient152(void);
void ObjectStublessClient153(void);
void ObjectStublessClient154(void);
void ObjectStublessClient155(void);
void ObjectStublessClient156(void);
void ObjectStublessClient157(void);
void ObjectStublessClient158(void);
void ObjectStublessClient159(void);
void ObjectStublessClient160(void);
void ObjectStublessClient161(void);
void ObjectStublessClient162(void);
void ObjectStublessClient163(void);
void ObjectStublessClient164(void);
void ObjectStublessClient165(void);
void ObjectStublessClient166(void);
void ObjectStublessClient167(void);
void ObjectStublessClient168(void);
void ObjectStublessClient169(void);
void ObjectStublessClient170(void);
void ObjectStublessClient171(void);
void ObjectStublessClient172(void);
void ObjectStublessClient173(void);
void ObjectStublessClient174(void);
void ObjectStublessClient175(void);
void ObjectStublessClient176(void);
void ObjectStublessClient177(void);
void ObjectStublessClient178(void);
void ObjectStublessClient179(void);
void ObjectStublessClient180(void);
void ObjectStublessClient181(void);
void ObjectStublessClient182(void);
void ObjectStublessClient183(void);
void ObjectStublessClient184(void);
void ObjectStublessClient185(void);
void ObjectStublessClient186(void);
void ObjectStublessClient187(void);
void ObjectStublessClient188(void);
void ObjectStublessClient189(void);
void ObjectStublessClient190(void);
void ObjectStublessClient191(void);
void ObjectStublessClient192(void);
void ObjectStublessClient193(void);
void ObjectStublessClient194(void);
void ObjectStublessClient195(void);
void ObjectStublessClient196(void);
void ObjectStublessClient197(void);
void ObjectStublessClient198(void);
void ObjectStublessClient199(void);
void ObjectStublessClient200(void);
void ObjectStublessClient201(void);
void ObjectStublessClient202(void);
void ObjectStublessClient203(void);
void ObjectStublessClient204(void);
void ObjectStublessClient205(void);
void ObjectStublessClient206(void);
void ObjectStublessClient207(void);
void ObjectStublessClient208(void);
void ObjectStublessClient209(void);
void ObjectStublessClient210(void);
void ObjectStublessClient211(void);
void ObjectStublessClient212(void);
void ObjectStublessClient213(void);
void ObjectStublessClient214(void);
void ObjectStublessClient215(void);
void ObjectStublessClient216(void);
void ObjectStublessClient217(void);
void ObjectStublessClient218(void);
void ObjectStublessClient219(void);
void ObjectStublessClient220(void);
void ObjectStublessClient221(void);
void ObjectStublessClient222(void);
void ObjectStublessClient223(void);
void ObjectStublessClient224(void);
void ObjectStublessClient225(void);
void ObjectStublessClient226(void);
void ObjectStublessClient227(void);
void ObjectStublessClient228(void);
void ObjectStublessClient229(void);
void ObjectStublessClient230(void);
void ObjectStublessClient231(void);
void ObjectStublessClient232(void);
void ObjectStublessClient233(void);
void ObjectStublessClient234(void);
void ObjectStublessClient235(void);
void ObjectStublessClient236(void);
void ObjectStublessClient237(void);
void ObjectStublessClient238(void);
void ObjectStublessClient239(void);
void ObjectStublessClient240(void);
void ObjectStublessClient241(void);
void ObjectStublessClient242(void);
void ObjectStublessClient243(void);
void ObjectStublessClient244(void);
void ObjectStublessClient245(void);
void ObjectStublessClient246(void);
void ObjectStublessClient247(void);
void ObjectStublessClient248(void);
void ObjectStublessClient249(void);
void ObjectStublessClient250(void);
void ObjectStublessClient251(void);
void ObjectStublessClient252(void);
void ObjectStublessClient253(void);
void ObjectStublessClient254(void);
void ObjectStublessClient255(void);
void ObjectStublessClient256(void);
void ObjectStublessClient257(void);
void ObjectStublessClient258(void);
void ObjectStublessClient259(void);
void ObjectStublessClient260(void);
void ObjectStublessClient261(void);
void ObjectStublessClient262(void);
void ObjectStublessClient263(void);
void ObjectStublessClient264(void);
void ObjectStublessClient265(void);
void ObjectStublessClient266(void);
void ObjectStublessClient267(void);
void ObjectStublessClient268(void);
void ObjectStublessClient269(void);
void ObjectStublessClient270(void);
void ObjectStublessClient271(void);
void ObjectStublessClient272(void);
void ObjectStublessClient273(void);
void ObjectStublessClient274(void);
void ObjectStublessClient275(void);
void ObjectStublessClient276(void);
void ObjectStublessClient277(void);
void ObjectStublessClient278(void);
void ObjectStublessClient279(void);
void ObjectStublessClient280(void);
void ObjectStublessClient281(void);
void ObjectStublessClient282(void);
void ObjectStublessClient283(void);
void ObjectStublessClient284(void);
void ObjectStublessClient285(void);
void ObjectStublessClient286(void);
void ObjectStublessClient287(void);
void ObjectStublessClient288(void);
void ObjectStublessClient289(void);
void ObjectStublessClient290(void);
void ObjectStublessClient291(void);
void ObjectStublessClient292(void);
void ObjectStublessClient293(void);
void ObjectStublessClient294(void);
void ObjectStublessClient295(void);
void ObjectStublessClient296(void);
void ObjectStublessClient297(void);
void ObjectStublessClient298(void);
void ObjectStublessClient299(void);
void ObjectStublessClient300(void);
void ObjectStublessClient301(void);
void ObjectStublessClient302(void);
void ObjectStublessClient303(void);
void ObjectStublessClient304(void);
void ObjectStublessClient305(void);
void ObjectStublessClient306(void);
void ObjectStublessClient307(void);
void ObjectStublessClient308(void);
void ObjectStublessClient309(void);
void ObjectStublessClient310(void);
void ObjectStublessClient311(void);
void ObjectStublessClient312(void);
void ObjectStublessClient313(void);
void ObjectStublessClient314(void);
void ObjectStublessClient315(void);
void ObjectStublessClient316(void);
void ObjectStublessClient317(void);
void ObjectStublessClient318(void);
void ObjectStublessClient319(void);
void ObjectStublessClient320(void);
void ObjectStublessClient321(void);
void ObjectStublessClient322(void);
void ObjectStublessClient323(void);
void ObjectStublessClient324(void);
void ObjectStublessClient325(void);
void ObjectStublessClient326(void);
void ObjectStublessClient327(void);
void ObjectStublessClient328(void);
void ObjectStublessClient329(void);
void ObjectStublessClient330(void);
void ObjectStublessClient331(void);
void ObjectStublessClient332(void);
void ObjectStublessClient333(void);
void ObjectStublessClient334(void);
void ObjectStublessClient335(void);
void ObjectStublessClient336(void);
void ObjectStublessClient337(void);
void ObjectStublessClient338(void);
void ObjectStublessClient339(void);
void ObjectStublessClient340(void);
void ObjectStublessClient341(void);
void ObjectStublessClient342(void);
void ObjectStublessClient343(void);
void ObjectStublessClient344(void);
void ObjectStublessClient345(void);
void ObjectStublessClient346(void);
void ObjectStublessClient347(void);
void ObjectStublessClient348(void);
void ObjectStublessClient349(void);
void ObjectStublessClient350(void);
void ObjectStublessClient351(void);
void ObjectStublessClient352(void);
void ObjectStublessClient353(void);
void ObjectStublessClient354(void);
void ObjectStublessClient355(void);
void ObjectStublessClient356(void);
void ObjectStublessClient357(void);
void ObjectStublessClient358(void);
void ObjectStublessClient359(void);
void ObjectStublessClient360(void);
void ObjectStublessClient361(void);
void ObjectStublessClient362(void);
void ObjectStublessClient363(void);
void ObjectStublessClient364(void);
void ObjectStublessClient365(void);
void ObjectStublessClient366(void);
void ObjectStublessClient367(void);
void ObjectStublessClient368(void);
void ObjectStublessClient369(void);
void ObjectStublessClient370(void);
void ObjectStublessClient371(void);
void ObjectStublessClient372(void);
void ObjectStublessClient373(void);
void ObjectStublessClient374(void);
void ObjectStublessClient375(void);
void ObjectStublessClient376(void);
void ObjectStublessClient377(void);
void ObjectStublessClient378(void);
void ObjectStublessClient379(void);
void ObjectStublessClient380(void);
void ObjectStublessClient381(void);
void ObjectStublessClient382(void);
void ObjectStublessClient383(void);
void ObjectStublessClient384(void);
void ObjectStublessClient385(void);
void ObjectStublessClient386(void);
void ObjectStublessClient387(void);
void ObjectStublessClient388(void);
void ObjectStublessClient389(void);
void ObjectStublessClient390(void);
void ObjectStublessClient391(void);
void ObjectStublessClient392(void);
void ObjectStublessClient393(void);
void ObjectStublessClient394(void);
void ObjectStublessClient395(void);
void ObjectStublessClient396(void);
void ObjectStublessClient397(void);
void ObjectStublessClient398(void);
void ObjectStublessClient399(void);
void ObjectStublessClient400(void);
void ObjectStublessClient401(void);
void ObjectStublessClient402(void);
void ObjectStublessClient403(void);
void ObjectStublessClient404(void);
void ObjectStublessClient405(void);
void ObjectStublessClient406(void);
void ObjectStublessClient407(void);
void ObjectStublessClient408(void);
void ObjectStublessClient409(void);
void ObjectStublessClient410(void);
void ObjectStublessClient411(void);
void ObjectStublessClient412(void);
void ObjectStublessClient413(void);
void ObjectStublessClient414(void);
void ObjectStublessClient415(void);
void ObjectStublessClient416(void);
void ObjectStublessClient417(void);
void ObjectStublessClient418(void);
void ObjectStublessClient419(void);
void ObjectStublessClient420(void);
void ObjectStublessClient421(void);
void ObjectStublessClient422(void);
void ObjectStublessClient423(void);
void ObjectStublessClient424(void);
void ObjectStublessClient425(void);
void ObjectStublessClient426(void);
void ObjectStublessClient427(void);
void ObjectStublessClient428(void);
void ObjectStublessClient429(void);
void ObjectStublessClient430(void);
void ObjectStublessClient431(void);
void ObjectStublessClient432(void);
void ObjectStublessClient433(void);
void ObjectStublessClient434(void);
void ObjectStublessClient435(void);
void ObjectStublessClient436(void);
void ObjectStublessClient437(void);
void ObjectStublessClient438(void);
void ObjectStublessClient439(void);
void ObjectStublessClient440(void);
void ObjectStublessClient441(void);
void ObjectStublessClient442(void);
void ObjectStublessClient443(void);
void ObjectStublessClient444(void);
void ObjectStublessClient445(void);
void ObjectStublessClient446(void);
void ObjectStublessClient447(void);
void ObjectStublessClient448(void);
void ObjectStublessClient449(void);
void ObjectStublessClient450(void);
void ObjectStublessClient451(void);
void ObjectStublessClient452(void);
void ObjectStublessClient453(void);
void ObjectStublessClient454(void);
void ObjectStublessClient455(void);
void ObjectStublessClient456(void);
void ObjectStublessClient457(void);
void ObjectStublessClient458(void);
void ObjectStublessClient459(void);
void ObjectStublessClient460(void);
void ObjectStublessClient461(void);
void ObjectStublessClient462(void);
void ObjectStublessClient463(void);
void ObjectStublessClient464(void);
void ObjectStublessClient465(void);
void ObjectStublessClient466(void);
void ObjectStublessClient467(void);
void ObjectStublessClient468(void);
void ObjectStublessClient469(void);
void ObjectStublessClient470(void);
void ObjectStublessClient471(void);
void ObjectStublessClient472(void);
void ObjectStublessClient473(void);
void ObjectStublessClient474(void);
void ObjectStublessClient475(void);
void ObjectStublessClient476(void);
void ObjectStublessClient477(void);
void ObjectStublessClient478(void);
void ObjectStublessClient479(void);
void ObjectStublessClient480(void);
void ObjectStublessClient481(void);
void ObjectStublessClient482(void);
void ObjectStublessClient483(void);
void ObjectStublessClient484(void);
void ObjectStublessClient485(void);
void ObjectStublessClient486(void);
void ObjectStublessClient487(void);
void ObjectStublessClient488(void);
void ObjectStublessClient489(void);
void ObjectStublessClient490(void);
void ObjectStublessClient491(void);
void ObjectStublessClient492(void);
void ObjectStublessClient493(void);
void ObjectStublessClient494(void);
void ObjectStublessClient495(void);
void ObjectStublessClient496(void);
void ObjectStublessClient497(void);
void ObjectStublessClient498(void);
void ObjectStublessClient499(void);
void ObjectStublessClient500(void);
void ObjectStublessClient501(void);
void ObjectStublessClient502(void);
void ObjectStublessClient503(void);
void ObjectStublessClient504(void);
void ObjectStublessClient505(void);
void ObjectStublessClient506(void);
void ObjectStublessClient507(void);
void ObjectStublessClient508(void);
void ObjectStublessClient509(void);
void ObjectStublessClient510(void);
void ObjectStublessClient511(void);
void ObjectStublessClient512(void);
void ObjectStublessClient513(void);
void ObjectStublessClient514(void);
void ObjectStublessClient515(void);
void ObjectStublessClient516(void);
void ObjectStublessClient517(void);
void ObjectStublessClient518(void);
void ObjectStublessClient519(void);
void ObjectStublessClient520(void);
void ObjectStublessClient521(void);
void ObjectStublessClient522(void);
void ObjectStublessClient523(void);
void ObjectStublessClient524(void);
void ObjectStublessClient525(void);
void ObjectStublessClient526(void);
void ObjectStublessClient527(void);
void ObjectStublessClient528(void);
void ObjectStublessClient529(void);
void ObjectStublessClient530(void);
void ObjectStublessClient531(void);
void ObjectStublessClient532(void);
void ObjectStublessClient533(void);
void ObjectStublessClient534(void);
void ObjectStublessClient535(void);
void ObjectStublessClient536(void);
void ObjectStublessClient537(void);
void ObjectStublessClient538(void);
void ObjectStublessClient539(void);
void ObjectStublessClient540(void);
void ObjectStublessClient541(void);
void ObjectStublessClient542(void);
void ObjectStublessClient543(void);
void ObjectStublessClient544(void);
void ObjectStublessClient545(void);
void ObjectStublessClient546(void);
void ObjectStublessClient547(void);
void ObjectStublessClient548(void);
void ObjectStublessClient549(void);
void ObjectStublessClient550(void);
void ObjectStublessClient551(void);
void ObjectStublessClient552(void);
void ObjectStublessClient553(void);
void ObjectStublessClient554(void);
void ObjectStublessClient555(void);
void ObjectStublessClient556(void);
void ObjectStublessClient557(void);
void ObjectStublessClient558(void);
void ObjectStublessClient559(void);
void ObjectStublessClient560(void);
void ObjectStublessClient561(void);
void ObjectStublessClient562(void);
void ObjectStublessClient563(void);
void ObjectStublessClient564(void);
void ObjectStublessClient565(void);
void ObjectStublessClient566(void);
void ObjectStublessClient567(void);
void ObjectStublessClient568(void);
void ObjectStublessClient569(void);
void ObjectStublessClient570(void);
void ObjectStublessClient571(void);
void ObjectStublessClient572(void);
void ObjectStublessClient573(void);
void ObjectStublessClient574(void);
void ObjectStublessClient575(void);
void ObjectStublessClient576(void);
void ObjectStublessClient577(void);
void ObjectStublessClient578(void);
void ObjectStublessClient579(void);
void ObjectStublessClient580(void);
void ObjectStublessClient581(void);
void ObjectStublessClient582(void);
void ObjectStublessClient583(void);
void ObjectStublessClient584(void);
void ObjectStublessClient585(void);
void ObjectStublessClient586(void);
void ObjectStublessClient587(void);
void ObjectStublessClient588(void);
void ObjectStublessClient589(void);
void ObjectStublessClient590(void);
void ObjectStublessClient591(void);
void ObjectStublessClient592(void);
void ObjectStublessClient593(void);
void ObjectStublessClient594(void);
void ObjectStublessClient595(void);
void ObjectStublessClient596(void);
void ObjectStublessClient597(void);
void ObjectStublessClient598(void);
void ObjectStublessClient599(void);
void ObjectStublessClient600(void);
void ObjectStublessClient601(void);
void ObjectStublessClient602(void);
void ObjectStublessClient603(void);
void ObjectStublessClient604(void);
void ObjectStublessClient605(void);
void ObjectStublessClient606(void);
void ObjectStublessClient607(void);
void ObjectStublessClient608(void);
void ObjectStublessClient609(void);
void ObjectStublessClient610(void);
void ObjectStublessClient611(void);
void ObjectStublessClient612(void);
void ObjectStublessClient613(void);
void ObjectStublessClient614(void);
void ObjectStublessClient615(void);
void ObjectStublessClient616(void);
void ObjectStublessClient617(void);
void ObjectStublessClient618(void);
void ObjectStublessClient619(void);
void ObjectStublessClient620(void);
void ObjectStublessClient621(void);
void ObjectStublessClient622(void);
void ObjectStublessClient623(void);
void ObjectStublessClient624(void);
void ObjectStublessClient625(void);
void ObjectStublessClient626(void);
void ObjectStublessClient627(void);
void ObjectStublessClient628(void);
void ObjectStublessClient629(void);
void ObjectStublessClient630(void);
void ObjectStublessClient631(void);
void ObjectStublessClient632(void);
void ObjectStublessClient633(void);
void ObjectStublessClient634(void);
void ObjectStublessClient635(void);
void ObjectStublessClient636(void);
void ObjectStublessClient637(void);
void ObjectStublessClient638(void);
void ObjectStublessClient639(void);
void ObjectStublessClient640(void);
void ObjectStublessClient641(void);
void ObjectStublessClient642(void);
void ObjectStublessClient643(void);
void ObjectStublessClient644(void);
void ObjectStublessClient645(void);
void ObjectStublessClient646(void);
void ObjectStublessClient647(void);
void ObjectStublessClient648(void);
void ObjectStublessClient649(void);
void ObjectStublessClient650(void);
void ObjectStublessClient651(void);
void ObjectStublessClient652(void);
void ObjectStublessClient653(void);
void ObjectStublessClient654(void);
void ObjectStublessClient655(void);
void ObjectStublessClient656(void);
void ObjectStublessClient657(void);
void ObjectStublessClient658(void);
void ObjectStublessClient659(void);
void ObjectStublessClient660(void);
void ObjectStublessClient661(void);
void ObjectStublessClient662(void);
void ObjectStublessClient663(void);
void ObjectStublessClient664(void);
void ObjectStublessClient665(void);
void ObjectStublessClient666(void);
void ObjectStublessClient667(void);
void ObjectStublessClient668(void);
void ObjectStublessClient669(void);
void ObjectStublessClient670(void);
void ObjectStublessClient671(void);
void ObjectStublessClient672(void);
void ObjectStublessClient673(void);
void ObjectStublessClient674(void);
void ObjectStublessClient675(void);
void ObjectStublessClient676(void);
void ObjectStublessClient677(void);
void ObjectStublessClient678(void);
void ObjectStublessClient679(void);
void ObjectStublessClient680(void);
void ObjectStublessClient681(void);
void ObjectStublessClient682(void);
void ObjectStublessClient683(void);
void ObjectStublessClient684(void);
void ObjectStublessClient685(void);
void ObjectStublessClient686(void);
void ObjectStublessClient687(void);
void ObjectStublessClient688(void);
void ObjectStublessClient689(void);
void ObjectStublessClient690(void);
void ObjectStublessClient691(void);
void ObjectStublessClient692(void);
void ObjectStublessClient693(void);
void ObjectStublessClient694(void);
void ObjectStublessClient695(void);
void ObjectStublessClient696(void);
void ObjectStublessClient697(void);
void ObjectStublessClient698(void);
void ObjectStublessClient699(void);
void ObjectStublessClient700(void);
void ObjectStublessClient701(void);
void ObjectStublessClient702(void);
void ObjectStublessClient703(void);
void ObjectStublessClient704(void);
void ObjectStublessClient705(void);
void ObjectStublessClient706(void);
void ObjectStublessClient707(void);
void ObjectStublessClient708(void);
void ObjectStublessClient709(void);
void ObjectStublessClient710(void);
void ObjectStublessClient711(void);
void ObjectStublessClient712(void);
void ObjectStublessClient713(void);
void ObjectStublessClient714(void);
void ObjectStublessClient715(void);
void ObjectStublessClient716(void);
void ObjectStublessClient717(void);
void ObjectStublessClient718(void);
void ObjectStublessClient719(void);
void ObjectStublessClient720(void);
void ObjectStublessClient721(void);
void ObjectStublessClient722(void);
void ObjectStublessClient723(void);
void ObjectStublessClient724(void);
void ObjectStublessClient725(void);
void ObjectStublessClient726(void);
void ObjectStublessClient727(void);
void ObjectStublessClient728(void);
void ObjectStublessClient729(void);
void ObjectStublessClient730(void);
void ObjectStublessClient731(void);
void ObjectStublessClient732(void);
void ObjectStublessClient733(void);
void ObjectStublessClient734(void);
void ObjectStublessClient735(void);
void ObjectStublessClient736(void);
void ObjectStublessClient737(void);
void ObjectStublessClient738(void);
void ObjectStublessClient739(void);
void ObjectStublessClient740(void);
void ObjectStublessClient741(void);
void ObjectStublessClient742(void);
void ObjectStublessClient743(void);
void ObjectStublessClient744(void);
void ObjectStublessClient745(void);
void ObjectStublessClient746(void);
void ObjectStublessClient747(void);
void ObjectStublessClient748(void);
void ObjectStublessClient749(void);
void ObjectStublessClient750(void);
void ObjectStublessClient751(void);
void ObjectStublessClient752(void);
void ObjectStublessClient753(void);
void ObjectStublessClient754(void);
void ObjectStublessClient755(void);
void ObjectStublessClient756(void);
void ObjectStublessClient757(void);
void ObjectStublessClient758(void);
void ObjectStublessClient759(void);
void ObjectStublessClient760(void);
void ObjectStublessClient761(void);
void ObjectStublessClient762(void);
void ObjectStublessClient763(void);
void ObjectStublessClient764(void);
void ObjectStublessClient765(void);
void ObjectStublessClient766(void);
void ObjectStublessClient767(void);
void ObjectStublessClient768(void);
void ObjectStublessClient769(void);
void ObjectStublessClient770(void);
void ObjectStublessClient771(void);
void ObjectStublessClient772(void);
void ObjectStublessClient773(void);
void ObjectStublessClient774(void);
void ObjectStublessClient775(void);
void ObjectStublessClient776(void);
void ObjectStublessClient777(void);
void ObjectStublessClient778(void);
void ObjectStublessClient779(void);
void ObjectStublessClient780(void);
void ObjectStublessClient781(void);
void ObjectStublessClient782(void);
void ObjectStublessClient783(void);
void ObjectStublessClient784(void);
void ObjectStublessClient785(void);
void ObjectStublessClient786(void);
void ObjectStublessClient787(void);
void ObjectStublessClient788(void);
void ObjectStublessClient789(void);
void ObjectStublessClient790(void);
void ObjectStublessClient791(void);
void ObjectStublessClient792(void);
void ObjectStublessClient793(void);
void ObjectStublessClient794(void);
void ObjectStublessClient795(void);
void ObjectStublessClient796(void);
void ObjectStublessClient797(void);
void ObjectStublessClient798(void);
void ObjectStublessClient799(void);
void ObjectStublessClient800(void);
void ObjectStublessClient801(void);
void ObjectStublessClient802(void);
void ObjectStublessClient803(void);
void ObjectStublessClient804(void);
void ObjectStublessClient805(void);
void ObjectStublessClient806(void);
void ObjectStublessClient807(void);
void ObjectStublessClient808(void);
void ObjectStublessClient809(void);
void ObjectStublessClient810(void);
void ObjectStublessClient811(void);
void ObjectStublessClient812(void);
void ObjectStublessClient813(void);
void ObjectStublessClient814(void);
void ObjectStublessClient815(void);
void ObjectStublessClient816(void);
void ObjectStublessClient817(void);
void ObjectStublessClient818(void);
void ObjectStublessClient819(void);
void ObjectStublessClient820(void);
void ObjectStublessClient821(void);
void ObjectStublessClient822(void);
void ObjectStublessClient823(void);
void ObjectStublessClient824(void);
void ObjectStublessClient825(void);
void ObjectStublessClient826(void);
void ObjectStublessClient827(void);
void ObjectStublessClient828(void);
void ObjectStublessClient829(void);
void ObjectStublessClient830(void);
void ObjectStublessClient831(void);
void ObjectStublessClient832(void);
void ObjectStublessClient833(void);
void ObjectStublessClient834(void);
void ObjectStublessClient835(void);
void ObjectStublessClient836(void);
void ObjectStublessClient837(void);
void ObjectStublessClient838(void);
void ObjectStublessClient839(void);
void ObjectStublessClient840(void);
void ObjectStublessClient841(void);
void ObjectStublessClient842(void);
void ObjectStublessClient843(void);
void ObjectStublessClient844(void);
void ObjectStublessClient845(void);
void ObjectStublessClient846(void);
void ObjectStublessClient847(void);
void ObjectStublessClient848(void);
void ObjectStublessClient849(void);
void ObjectStublessClient850(void);
void ObjectStublessClient851(void);
void ObjectStublessClient852(void);
void ObjectStublessClient853(void);
void ObjectStublessClient854(void);
void ObjectStublessClient855(void);
void ObjectStublessClient856(void);
void ObjectStublessClient857(void);
void ObjectStublessClient858(void);
void ObjectStublessClient859(void);
void ObjectStublessClient860(void);
void ObjectStublessClient861(void);
void ObjectStublessClient862(void);
void ObjectStublessClient863(void);
void ObjectStublessClient864(void);
void ObjectStublessClient865(void);
void ObjectStublessClient866(void);
void ObjectStublessClient867(void);
void ObjectStublessClient868(void);
void ObjectStublessClient869(void);
void ObjectStublessClient870(void);
void ObjectStublessClient871(void);
void ObjectStublessClient872(void);
void ObjectStublessClient873(void);
void ObjectStublessClient874(void);
void ObjectStublessClient875(void);
void ObjectStublessClient876(void);
void ObjectStublessClient877(void);
void ObjectStublessClient878(void);
void ObjectStublessClient879(void);
void ObjectStublessClient880(void);
void ObjectStublessClient881(void);
void ObjectStublessClient882(void);
void ObjectStublessClient883(void);
void ObjectStublessClient884(void);
void ObjectStublessClient885(void);
void ObjectStublessClient886(void);
void ObjectStublessClient887(void);
void ObjectStublessClient888(void);
void ObjectStublessClient889(void);
void ObjectStublessClient890(void);
void ObjectStublessClient891(void);
void ObjectStublessClient892(void);
void ObjectStublessClient893(void);
void ObjectStublessClient894(void);
void ObjectStublessClient895(void);
void ObjectStublessClient896(void);
void ObjectStublessClient897(void);
void ObjectStublessClient898(void);
void ObjectStublessClient899(void);
void ObjectStublessClient900(void);
void ObjectStublessClient901(void);
void ObjectStublessClient902(void);
void ObjectStublessClient903(void);
void ObjectStublessClient904(void);
void ObjectStublessClient905(void);
void ObjectStublessClient906(void);
void ObjectStublessClient907(void);
void ObjectStublessClient908(void);
void ObjectStublessClient909(void);
void ObjectStublessClient910(void);
void ObjectStublessClient911(void);
void ObjectStublessClient912(void);
void ObjectStublessClient913(void);
void ObjectStublessClient914(void);
void ObjectStublessClient915(void);
void ObjectStublessClient916(void);
void ObjectStublessClient917(void);
void ObjectStublessClient918(void);
void ObjectStublessClient919(void);
void ObjectStublessClient920(void);
void ObjectStublessClient921(void);
void ObjectStublessClient922(void);
void ObjectStublessClient923(void);
void ObjectStublessClient924(void);
void ObjectStublessClient925(void);
void ObjectStublessClient926(void);
void ObjectStublessClient927(void);
void ObjectStublessClient928(void);
void ObjectStublessClient929(void);
void ObjectStublessClient930(void);
void ObjectStublessClient931(void);
void ObjectStublessClient932(void);
void ObjectStublessClient933(void);
void ObjectStublessClient934(void);
void ObjectStublessClient935(void);
void ObjectStublessClient936(void);
void ObjectStublessClient937(void);
void ObjectStublessClient938(void);
void ObjectStublessClient939(void);
void ObjectStublessClient940(void);
void ObjectStublessClient941(void);
void ObjectStublessClient942(void);
void ObjectStublessClient943(void);
void ObjectStublessClient944(void);
void ObjectStublessClient945(void);
void ObjectStublessClient946(void);
void ObjectStublessClient947(void);
void ObjectStublessClient948(void);
void ObjectStublessClient949(void);
void ObjectStublessClient950(void);
void ObjectStublessClient951(void);
void ObjectStublessClient952(void);
void ObjectStublessClient953(void);
void ObjectStublessClient954(void);
void ObjectStublessClient955(void);
void ObjectStublessClient956(void);
void ObjectStublessClient957(void);
void ObjectStublessClient958(void);
void ObjectStublessClient959(void);
void ObjectStublessClient960(void);
void ObjectStublessClient961(void);
void ObjectStublessClient962(void);
void ObjectStublessClient963(void);
void ObjectStublessClient964(void);
void ObjectStublessClient965(void);
void ObjectStublessClient966(void);
void ObjectStublessClient967(void);
void ObjectStublessClient968(void);
void ObjectStublessClient969(void);
void ObjectStublessClient970(void);
void ObjectStublessClient971(void);
void ObjectStublessClient972(void);
void ObjectStublessClient973(void);
void ObjectStublessClient974(void);
void ObjectStublessClient975(void);
void ObjectStublessClient976(void);
void ObjectStublessClient977(void);
void ObjectStublessClient978(void);
void ObjectStublessClient979(void);
void ObjectStublessClient980(void);
void ObjectStublessClient981(void);
void ObjectStublessClient982(void);
void ObjectStublessClient983(void);
void ObjectStublessClient984(void);
void ObjectStublessClient985(void);
void ObjectStublessClient986(void);
void ObjectStublessClient987(void);
void ObjectStublessClient988(void);
void ObjectStublessClient989(void);
void ObjectStublessClient990(void);
void ObjectStublessClient991(void);
void ObjectStublessClient992(void);
void ObjectStublessClient993(void);
void ObjectStublessClient994(void);
void ObjectStublessClient995(void);
void ObjectStublessClient996(void);
void ObjectStublessClient997(void);
void ObjectStublessClient998(void);
void ObjectStublessClient999(void);
void ObjectStublessClient1000(void);
void ObjectStublessClient1001(void);
void ObjectStublessClient1002(void);
void ObjectStublessClient1003(void);
void ObjectStublessClient1004(void);
void ObjectStublessClient1005(void);
void ObjectStublessClient1006(void);
void ObjectStublessClient1007(void);
void ObjectStublessClient1008(void);
void ObjectStublessClient1009(void);
void ObjectStublessClient1010(void);
void ObjectStublessClient1011(void);
void ObjectStublessClient1012(void);
void ObjectStublessClient1013(void);
void ObjectStublessClient1014(void);
void ObjectStublessClient1015(void);
void ObjectStublessClient1016(void);
void ObjectStublessClient1017(void);
void ObjectStublessClient1018(void);
void ObjectStublessClient1019(void);
void ObjectStublessClient1020(void);
void ObjectStublessClient1021(void);
void ObjectStublessClient1022(void);
void ObjectStublessClient1023(void);

extern void * const g_StublessClientVtbl[1024] =
    {
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy,
    ObjectStublessClient3,
    ObjectStublessClient4,
    ObjectStublessClient5,
    ObjectStublessClient6,
    ObjectStublessClient7,
    ObjectStublessClient8,
    ObjectStublessClient9,
    ObjectStublessClient10,
    ObjectStublessClient11,
    ObjectStublessClient12,
    ObjectStublessClient13,
    ObjectStublessClient14,
    ObjectStublessClient15,
    ObjectStublessClient16,
    ObjectStublessClient17,
    ObjectStublessClient18,
    ObjectStublessClient19,
    ObjectStublessClient20,
    ObjectStublessClient21,
    ObjectStublessClient22,
    ObjectStublessClient23,
    ObjectStublessClient24,
    ObjectStublessClient25,
    ObjectStublessClient26,
    ObjectStublessClient27,
    ObjectStublessClient28,
    ObjectStublessClient29,
    ObjectStublessClient30,
    ObjectStublessClient31,
    ObjectStublessClient32,
    ObjectStublessClient33,
    ObjectStublessClient34,
    ObjectStublessClient35,
    ObjectStublessClient36,
    ObjectStublessClient37,
    ObjectStublessClient38,
    ObjectStublessClient39,
    ObjectStublessClient40,
    ObjectStublessClient41,
    ObjectStublessClient42,
    ObjectStublessClient43,
    ObjectStublessClient44,
    ObjectStublessClient45,
    ObjectStublessClient46,
    ObjectStublessClient47,
    ObjectStublessClient48,
    ObjectStublessClient49,
    ObjectStublessClient50,
    ObjectStublessClient51,
    ObjectStublessClient52,
    ObjectStublessClient53,
    ObjectStublessClient54,
    ObjectStublessClient55,
    ObjectStublessClient56,
    ObjectStublessClient57,
    ObjectStublessClient58,
    ObjectStublessClient59,
    ObjectStublessClient60,
    ObjectStublessClient61,
    ObjectStublessClient62,
    ObjectStublessClient63,
    ObjectStublessClient64,
    ObjectStublessClient65,
    ObjectStublessClient66,
    ObjectStublessClient67,
    ObjectStublessClient68,
    ObjectStublessClient69,
    ObjectStublessClient70,
    ObjectStublessClient71,
    ObjectStublessClient72,
    ObjectStublessClient73,
    ObjectStublessClient74,
    ObjectStublessClient75,
    ObjectStublessClient76,
    ObjectStublessClient77,
    ObjectStublessClient78,
    ObjectStublessClient79,
    ObjectStublessClient80,
    ObjectStublessClient81,
    ObjectStublessClient82,
    ObjectStublessClient83,
    ObjectStublessClient84,
    ObjectStublessClient85,
    ObjectStublessClient86,
    ObjectStublessClient87,
    ObjectStublessClient88,
    ObjectStublessClient89,
    ObjectStublessClient90,
    ObjectStublessClient91,
    ObjectStublessClient92,
    ObjectStublessClient93,
    ObjectStublessClient94,
    ObjectStublessClient95,
    ObjectStublessClient96,
    ObjectStublessClient97,
    ObjectStublessClient98,
    ObjectStublessClient99,
    ObjectStublessClient100,
    ObjectStublessClient101,
    ObjectStublessClient102,
    ObjectStublessClient103,
    ObjectStublessClient104,
    ObjectStublessClient105,
    ObjectStublessClient106,
    ObjectStublessClient107,
    ObjectStublessClient108,
    ObjectStublessClient109,
    ObjectStublessClient110,
    ObjectStublessClient111,
    ObjectStublessClient112,
    ObjectStublessClient113,
    ObjectStublessClient114,
    ObjectStublessClient115,
    ObjectStublessClient116,
    ObjectStublessClient117,
    ObjectStublessClient118,
    ObjectStublessClient119,
    ObjectStublessClient120,
    ObjectStublessClient121,
    ObjectStublessClient122,
    ObjectStublessClient123,
    ObjectStublessClient124,
    ObjectStublessClient125,
    ObjectStublessClient126,
    ObjectStublessClient127,
    ObjectStublessClient128,
    ObjectStublessClient129,
    ObjectStublessClient130,
    ObjectStublessClient131,
    ObjectStublessClient132,
    ObjectStublessClient133,
    ObjectStublessClient134,
    ObjectStublessClient135,
    ObjectStublessClient136,
    ObjectStublessClient137,
    ObjectStublessClient138,
    ObjectStublessClient139,
    ObjectStublessClient140,
    ObjectStublessClient141,
    ObjectStublessClient142,
    ObjectStublessClient143,
    ObjectStublessClient144,
    ObjectStublessClient145,
    ObjectStublessClient146,
    ObjectStublessClient147,
    ObjectStublessClient148,
    ObjectStublessClient149,
    ObjectStublessClient150,
    ObjectStublessClient151,
    ObjectStublessClient152,
    ObjectStublessClient153,
    ObjectStublessClient154,
    ObjectStublessClient155,
    ObjectStublessClient156,
    ObjectStublessClient157,
    ObjectStublessClient158,
    ObjectStublessClient159,
    ObjectStublessClient160,
    ObjectStublessClient161,
    ObjectStublessClient162,
    ObjectStublessClient163,
    ObjectStublessClient164,
    ObjectStublessClient165,
    ObjectStublessClient166,
    ObjectStublessClient167,
    ObjectStublessClient168,
    ObjectStublessClient169,
    ObjectStublessClient170,
    ObjectStublessClient171,
    ObjectStublessClient172,
    ObjectStublessClient173,
    ObjectStublessClient174,
    ObjectStublessClient175,
    ObjectStublessClient176,
    ObjectStublessClient177,
    ObjectStublessClient178,
    ObjectStublessClient179,
    ObjectStublessClient180,
    ObjectStublessClient181,
    ObjectStublessClient182,
    ObjectStublessClient183,
    ObjectStublessClient184,
    ObjectStublessClient185,
    ObjectStublessClient186,
    ObjectStublessClient187,
    ObjectStublessClient188,
    ObjectStublessClient189,
    ObjectStublessClient190,
    ObjectStublessClient191,
    ObjectStublessClient192,
    ObjectStublessClient193,
    ObjectStublessClient194,
    ObjectStublessClient195,
    ObjectStublessClient196,
    ObjectStublessClient197,
    ObjectStublessClient198,
    ObjectStublessClient199,
    ObjectStublessClient200,
    ObjectStublessClient201,
    ObjectStublessClient202,
    ObjectStublessClient203,
    ObjectStublessClient204,
    ObjectStublessClient205,
    ObjectStublessClient206,
    ObjectStublessClient207,
    ObjectStublessClient208,
    ObjectStublessClient209,
    ObjectStublessClient210,
    ObjectStublessClient211,
    ObjectStublessClient212,
    ObjectStublessClient213,
    ObjectStublessClient214,
    ObjectStublessClient215,
    ObjectStublessClient216,
    ObjectStublessClient217,
    ObjectStublessClient218,
    ObjectStublessClient219,
    ObjectStublessClient220,
    ObjectStublessClient221,
    ObjectStublessClient222,
    ObjectStublessClient223,
    ObjectStublessClient224,
    ObjectStublessClient225,
    ObjectStublessClient226,
    ObjectStublessClient227,
    ObjectStublessClient228,
    ObjectStublessClient229,
    ObjectStublessClient230,
    ObjectStublessClient231,
    ObjectStublessClient232,
    ObjectStublessClient233,
    ObjectStublessClient234,
    ObjectStublessClient235,
    ObjectStublessClient236,
    ObjectStublessClient237,
    ObjectStublessClient238,
    ObjectStublessClient239,
    ObjectStublessClient240,
    ObjectStublessClient241,
    ObjectStublessClient242,
    ObjectStublessClient243,
    ObjectStublessClient244,
    ObjectStublessClient245,
    ObjectStublessClient246,
    ObjectStublessClient247,
    ObjectStublessClient248,
    ObjectStublessClient249,
    ObjectStublessClient250,
    ObjectStublessClient251,
    ObjectStublessClient252,
    ObjectStublessClient253,
    ObjectStublessClient254,
    ObjectStublessClient255,
    ObjectStublessClient256,
    ObjectStublessClient257,
    ObjectStublessClient258,
    ObjectStublessClient259,
    ObjectStublessClient260,
    ObjectStublessClient261,
    ObjectStublessClient262,
    ObjectStublessClient263,
    ObjectStublessClient264,
    ObjectStublessClient265,
    ObjectStublessClient266,
    ObjectStublessClient267,
    ObjectStublessClient268,
    ObjectStublessClient269,
    ObjectStublessClient270,
    ObjectStublessClient271,
    ObjectStublessClient272,
    ObjectStublessClient273,
    ObjectStublessClient274,
    ObjectStublessClient275,
    ObjectStublessClient276,
    ObjectStublessClient277,
    ObjectStublessClient278,
    ObjectStublessClient279,
    ObjectStublessClient280,
    ObjectStublessClient281,
    ObjectStublessClient282,
    ObjectStublessClient283,
    ObjectStublessClient284,
    ObjectStublessClient285,
    ObjectStublessClient286,
    ObjectStublessClient287,
    ObjectStublessClient288,
    ObjectStublessClient289,
    ObjectStublessClient290,
    ObjectStublessClient291,
    ObjectStublessClient292,
    ObjectStublessClient293,
    ObjectStublessClient294,
    ObjectStublessClient295,
    ObjectStublessClient296,
    ObjectStublessClient297,
    ObjectStublessClient298,
    ObjectStublessClient299,
    ObjectStublessClient300,
    ObjectStublessClient301,
    ObjectStublessClient302,
    ObjectStublessClient303,
    ObjectStublessClient304,
    ObjectStublessClient305,
    ObjectStublessClient306,
    ObjectStublessClient307,
    ObjectStublessClient308,
    ObjectStublessClient309,
    ObjectStublessClient310,
    ObjectStublessClient311,
    ObjectStublessClient312,
    ObjectStublessClient313,
    ObjectStublessClient314,
    ObjectStublessClient315,
    ObjectStublessClient316,
    ObjectStublessClient317,
    ObjectStublessClient318,
    ObjectStublessClient319,
    ObjectStublessClient320,
    ObjectStublessClient321,
    ObjectStublessClient322,
    ObjectStublessClient323,
    ObjectStublessClient324,
    ObjectStublessClient325,
    ObjectStublessClient326,
    ObjectStublessClient327,
    ObjectStublessClient328,
    ObjectStublessClient329,
    ObjectStublessClient330,
    ObjectStublessClient331,
    ObjectStublessClient332,
    ObjectStublessClient333,
    ObjectStublessClient334,
    ObjectStublessClient335,
    ObjectStublessClient336,
    ObjectStublessClient337,
    ObjectStublessClient338,
    ObjectStublessClient339,
    ObjectStublessClient340,
    ObjectStublessClient341,
    ObjectStublessClient342,
    ObjectStublessClient343,
    ObjectStublessClient344,
    ObjectStublessClient345,
    ObjectStublessClient346,
    ObjectStublessClient347,
    ObjectStublessClient348,
    ObjectStublessClient349,
    ObjectStublessClient350,
    ObjectStublessClient351,
    ObjectStublessClient352,
    ObjectStublessClient353,
    ObjectStublessClient354,
    ObjectStublessClient355,
    ObjectStublessClient356,
    ObjectStublessClient357,
    ObjectStublessClient358,
    ObjectStublessClient359,
    ObjectStublessClient360,
    ObjectStublessClient361,
    ObjectStublessClient362,
    ObjectStublessClient363,
    ObjectStublessClient364,
    ObjectStublessClient365,
    ObjectStublessClient366,
    ObjectStublessClient367,
    ObjectStublessClient368,
    ObjectStublessClient369,
    ObjectStublessClient370,
    ObjectStublessClient371,
    ObjectStublessClient372,
    ObjectStublessClient373,
    ObjectStublessClient374,
    ObjectStublessClient375,
    ObjectStublessClient376,
    ObjectStublessClient377,
    ObjectStublessClient378,
    ObjectStublessClient379,
    ObjectStublessClient380,
    ObjectStublessClient381,
    ObjectStublessClient382,
    ObjectStublessClient383,
    ObjectStublessClient384,
    ObjectStublessClient385,
    ObjectStublessClient386,
    ObjectStublessClient387,
    ObjectStublessClient388,
    ObjectStublessClient389,
    ObjectStublessClient390,
    ObjectStublessClient391,
    ObjectStublessClient392,
    ObjectStublessClient393,
    ObjectStublessClient394,
    ObjectStublessClient395,
    ObjectStublessClient396,
    ObjectStublessClient397,
    ObjectStublessClient398,
    ObjectStublessClient399,
    ObjectStublessClient400,
    ObjectStublessClient401,
    ObjectStublessClient402,
    ObjectStublessClient403,
    ObjectStublessClient404,
    ObjectStublessClient405,
    ObjectStublessClient406,
    ObjectStublessClient407,
    ObjectStublessClient408,
    ObjectStublessClient409,
    ObjectStublessClient410,
    ObjectStublessClient411,
    ObjectStublessClient412,
    ObjectStublessClient413,
    ObjectStublessClient414,
    ObjectStublessClient415,
    ObjectStublessClient416,
    ObjectStublessClient417,
    ObjectStublessClient418,
    ObjectStublessClient419,
    ObjectStublessClient420,
    ObjectStublessClient421,
    ObjectStublessClient422,
    ObjectStublessClient423,
    ObjectStublessClient424,
    ObjectStublessClient425,
    ObjectStublessClient426,
    ObjectStublessClient427,
    ObjectStublessClient428,
    ObjectStublessClient429,
    ObjectStublessClient430,
    ObjectStublessClient431,
    ObjectStublessClient432,
    ObjectStublessClient433,
    ObjectStublessClient434,
    ObjectStublessClient435,
    ObjectStublessClient436,
    ObjectStublessClient437,
    ObjectStublessClient438,
    ObjectStublessClient439,
    ObjectStublessClient440,
    ObjectStublessClient441,
    ObjectStublessClient442,
    ObjectStublessClient443,
    ObjectStublessClient444,
    ObjectStublessClient445,
    ObjectStublessClient446,
    ObjectStublessClient447,
    ObjectStublessClient448,
    ObjectStublessClient449,
    ObjectStublessClient450,
    ObjectStublessClient451,
    ObjectStublessClient452,
    ObjectStublessClient453,
    ObjectStublessClient454,
    ObjectStublessClient455,
    ObjectStublessClient456,
    ObjectStublessClient457,
    ObjectStublessClient458,
    ObjectStublessClient459,
    ObjectStublessClient460,
    ObjectStublessClient461,
    ObjectStublessClient462,
    ObjectStublessClient463,
    ObjectStublessClient464,
    ObjectStublessClient465,
    ObjectStublessClient466,
    ObjectStublessClient467,
    ObjectStublessClient468,
    ObjectStublessClient469,
    ObjectStublessClient470,
    ObjectStublessClient471,
    ObjectStublessClient472,
    ObjectStublessClient473,
    ObjectStublessClient474,
    ObjectStublessClient475,
    ObjectStublessClient476,
    ObjectStublessClient477,
    ObjectStublessClient478,
    ObjectStublessClient479,
    ObjectStublessClient480,
    ObjectStublessClient481,
    ObjectStublessClient482,
    ObjectStublessClient483,
    ObjectStublessClient484,
    ObjectStublessClient485,
    ObjectStublessClient486,
    ObjectStublessClient487,
    ObjectStublessClient488,
    ObjectStublessClient489,
    ObjectStublessClient490,
    ObjectStublessClient491,
    ObjectStublessClient492,
    ObjectStublessClient493,
    ObjectStublessClient494,
    ObjectStublessClient495,
    ObjectStublessClient496,
    ObjectStublessClient497,
    ObjectStublessClient498,
    ObjectStublessClient499,
    ObjectStublessClient500,
    ObjectStublessClient501,
    ObjectStublessClient502,
    ObjectStublessClient503,
    ObjectStublessClient504,
    ObjectStublessClient505,
    ObjectStublessClient506,
    ObjectStublessClient507,
    ObjectStublessClient508,
    ObjectStublessClient509,
    ObjectStublessClient510,
    ObjectStublessClient511,
    ObjectStublessClient512,
    ObjectStublessClient513,
    ObjectStublessClient514,
    ObjectStublessClient515,
    ObjectStublessClient516,
    ObjectStublessClient517,
    ObjectStublessClient518,
    ObjectStublessClient519,
    ObjectStublessClient520,
    ObjectStublessClient521,
    ObjectStublessClient522,
    ObjectStublessClient523,
    ObjectStublessClient524,
    ObjectStublessClient525,
    ObjectStublessClient526,
    ObjectStublessClient527,
    ObjectStublessClient528,
    ObjectStublessClient529,
    ObjectStublessClient530,
    ObjectStublessClient531,
    ObjectStublessClient532,
    ObjectStublessClient533,
    ObjectStublessClient534,
    ObjectStublessClient535,
    ObjectStublessClient536,
    ObjectStublessClient537,
    ObjectStublessClient538,
    ObjectStublessClient539,
    ObjectStublessClient540,
    ObjectStublessClient541,
    ObjectStublessClient542,
    ObjectStublessClient543,
    ObjectStublessClient544,
    ObjectStublessClient545,
    ObjectStublessClient546,
    ObjectStublessClient547,
    ObjectStublessClient548,
    ObjectStublessClient549,
    ObjectStublessClient550,
    ObjectStublessClient551,
    ObjectStublessClient552,
    ObjectStublessClient553,
    ObjectStublessClient554,
    ObjectStublessClient555,
    ObjectStublessClient556,
    ObjectStublessClient557,
    ObjectStublessClient558,
    ObjectStublessClient559,
    ObjectStublessClient560,
    ObjectStublessClient561,
    ObjectStublessClient562,
    ObjectStublessClient563,
    ObjectStublessClient564,
    ObjectStublessClient565,
    ObjectStublessClient566,
    ObjectStublessClient567,
    ObjectStublessClient568,
    ObjectStublessClient569,
    ObjectStublessClient570,
    ObjectStublessClient571,
    ObjectStublessClient572,
    ObjectStublessClient573,
    ObjectStublessClient574,
    ObjectStublessClient575,
    ObjectStublessClient576,
    ObjectStublessClient577,
    ObjectStublessClient578,
    ObjectStublessClient579,
    ObjectStublessClient580,
    ObjectStublessClient581,
    ObjectStublessClient582,
    ObjectStublessClient583,
    ObjectStublessClient584,
    ObjectStublessClient585,
    ObjectStublessClient586,
    ObjectStublessClient587,
    ObjectStublessClient588,
    ObjectStublessClient589,
    ObjectStublessClient590,
    ObjectStublessClient591,
    ObjectStublessClient592,
    ObjectStublessClient593,
    ObjectStublessClient594,
    ObjectStublessClient595,
    ObjectStublessClient596,
    ObjectStublessClient597,
    ObjectStublessClient598,
    ObjectStublessClient599,
    ObjectStublessClient600,
    ObjectStublessClient601,
    ObjectStublessClient602,
    ObjectStublessClient603,
    ObjectStublessClient604,
    ObjectStublessClient605,
    ObjectStublessClient606,
    ObjectStublessClient607,
    ObjectStublessClient608,
    ObjectStublessClient609,
    ObjectStublessClient610,
    ObjectStublessClient611,
    ObjectStublessClient612,
    ObjectStublessClient613,
    ObjectStublessClient614,
    ObjectStublessClient615,
    ObjectStublessClient616,
    ObjectStublessClient617,
    ObjectStublessClient618,
    ObjectStublessClient619,
    ObjectStublessClient620,
    ObjectStublessClient621,
    ObjectStublessClient622,
    ObjectStublessClient623,
    ObjectStublessClient624,
    ObjectStublessClient625,
    ObjectStublessClient626,
    ObjectStublessClient627,
    ObjectStublessClient628,
    ObjectStublessClient629,
    ObjectStublessClient630,
    ObjectStublessClient631,
    ObjectStublessClient632,
    ObjectStublessClient633,
    ObjectStublessClient634,
    ObjectStublessClient635,
    ObjectStublessClient636,
    ObjectStublessClient637,
    ObjectStublessClient638,
    ObjectStublessClient639,
    ObjectStublessClient640,
    ObjectStublessClient641,
    ObjectStublessClient642,
    ObjectStublessClient643,
    ObjectStublessClient644,
    ObjectStublessClient645,
    ObjectStublessClient646,
    ObjectStublessClient647,
    ObjectStublessClient648,
    ObjectStublessClient649,
    ObjectStublessClient650,
    ObjectStublessClient651,
    ObjectStublessClient652,
    ObjectStublessClient653,
    ObjectStublessClient654,
    ObjectStublessClient655,
    ObjectStublessClient656,
    ObjectStublessClient657,
    ObjectStublessClient658,
    ObjectStublessClient659,
    ObjectStublessClient660,
    ObjectStublessClient661,
    ObjectStublessClient662,
    ObjectStublessClient663,
    ObjectStublessClient664,
    ObjectStublessClient665,
    ObjectStublessClient666,
    ObjectStublessClient667,
    ObjectStublessClient668,
    ObjectStublessClient669,
    ObjectStublessClient670,
    ObjectStublessClient671,
    ObjectStublessClient672,
    ObjectStublessClient673,
    ObjectStublessClient674,
    ObjectStublessClient675,
    ObjectStublessClient676,
    ObjectStublessClient677,
    ObjectStublessClient678,
    ObjectStublessClient679,
    ObjectStublessClient680,
    ObjectStublessClient681,
    ObjectStublessClient682,
    ObjectStublessClient683,
    ObjectStublessClient684,
    ObjectStublessClient685,
    ObjectStublessClient686,
    ObjectStublessClient687,
    ObjectStublessClient688,
    ObjectStublessClient689,
    ObjectStublessClient690,
    ObjectStublessClient691,
    ObjectStublessClient692,
    ObjectStublessClient693,
    ObjectStublessClient694,
    ObjectStublessClient695,
    ObjectStublessClient696,
    ObjectStublessClient697,
    ObjectStublessClient698,
    ObjectStublessClient699,
    ObjectStublessClient700,
    ObjectStublessClient701,
    ObjectStublessClient702,
    ObjectStublessClient703,
    ObjectStublessClient704,
    ObjectStublessClient705,
    ObjectStublessClient706,
    ObjectStublessClient707,
    ObjectStublessClient708,
    ObjectStublessClient709,
    ObjectStublessClient710,
    ObjectStublessClient711,
    ObjectStublessClient712,
    ObjectStublessClient713,
    ObjectStublessClient714,
    ObjectStublessClient715,
    ObjectStublessClient716,
    ObjectStublessClient717,
    ObjectStublessClient718,
    ObjectStublessClient719,
    ObjectStublessClient720,
    ObjectStublessClient721,
    ObjectStublessClient722,
    ObjectStublessClient723,
    ObjectStublessClient724,
    ObjectStublessClient725,
    ObjectStublessClient726,
    ObjectStublessClient727,
    ObjectStublessClient728,
    ObjectStublessClient729,
    ObjectStublessClient730,
    ObjectStublessClient731,
    ObjectStublessClient732,
    ObjectStublessClient733,
    ObjectStublessClient734,
    ObjectStublessClient735,
    ObjectStublessClient736,
    ObjectStublessClient737,
    ObjectStublessClient738,
    ObjectStublessClient739,
    ObjectStublessClient740,
    ObjectStublessClient741,
    ObjectStublessClient742,
    ObjectStublessClient743,
    ObjectStublessClient744,
    ObjectStublessClient745,
    ObjectStublessClient746,
    ObjectStublessClient747,
    ObjectStublessClient748,
    ObjectStublessClient749,
    ObjectStublessClient750,
    ObjectStublessClient751,
    ObjectStublessClient752,
    ObjectStublessClient753,
    ObjectStublessClient754,
    ObjectStublessClient755,
    ObjectStublessClient756,
    ObjectStublessClient757,
    ObjectStublessClient758,
    ObjectStublessClient759,
    ObjectStublessClient760,
    ObjectStublessClient761,
    ObjectStublessClient762,
    ObjectStublessClient763,
    ObjectStublessClient764,
    ObjectStublessClient765,
    ObjectStublessClient766,
    ObjectStublessClient767,
    ObjectStublessClient768,
    ObjectStublessClient769,
    ObjectStublessClient770,
    ObjectStublessClient771,
    ObjectStublessClient772,
    ObjectStublessClient773,
    ObjectStublessClient774,
    ObjectStublessClient775,
    ObjectStublessClient776,
    ObjectStublessClient777,
    ObjectStublessClient778,
    ObjectStublessClient779,
    ObjectStublessClient780,
    ObjectStublessClient781,
    ObjectStublessClient782,
    ObjectStublessClient783,
    ObjectStublessClient784,
    ObjectStublessClient785,
    ObjectStublessClient786,
    ObjectStublessClient787,
    ObjectStublessClient788,
    ObjectStublessClient789,
    ObjectStublessClient790,
    ObjectStublessClient791,
    ObjectStublessClient792,
    ObjectStublessClient793,
    ObjectStublessClient794,
    ObjectStublessClient795,
    ObjectStublessClient796,
    ObjectStublessClient797,
    ObjectStublessClient798,
    ObjectStublessClient799,
    ObjectStublessClient800,
    ObjectStublessClient801,
    ObjectStublessClient802,
    ObjectStublessClient803,
    ObjectStublessClient804,
    ObjectStublessClient805,
    ObjectStublessClient806,
    ObjectStublessClient807,
    ObjectStublessClient808,
    ObjectStublessClient809,
    ObjectStublessClient810,
    ObjectStublessClient811,
    ObjectStublessClient812,
    ObjectStublessClient813,
    ObjectStublessClient814,
    ObjectStublessClient815,
    ObjectStublessClient816,
    ObjectStublessClient817,
    ObjectStublessClient818,
    ObjectStublessClient819,
    ObjectStublessClient820,
    ObjectStublessClient821,
    ObjectStublessClient822,
    ObjectStublessClient823,
    ObjectStublessClient824,
    ObjectStublessClient825,
    ObjectStublessClient826,
    ObjectStublessClient827,
    ObjectStublessClient828,
    ObjectStublessClient829,
    ObjectStublessClient830,
    ObjectStublessClient831,
    ObjectStublessClient832,
    ObjectStublessClient833,
    ObjectStublessClient834,
    ObjectStublessClient835,
    ObjectStublessClient836,
    ObjectStublessClient837,
    ObjectStublessClient838,
    ObjectStublessClient839,
    ObjectStublessClient840,
    ObjectStublessClient841,
    ObjectStublessClient842,
    ObjectStublessClient843,
    ObjectStublessClient844,
    ObjectStublessClient845,
    ObjectStublessClient846,
    ObjectStublessClient847,
    ObjectStublessClient848,
    ObjectStublessClient849,
    ObjectStublessClient850,
    ObjectStublessClient851,
    ObjectStublessClient852,
    ObjectStublessClient853,
    ObjectStublessClient854,
    ObjectStublessClient855,
    ObjectStublessClient856,
    ObjectStublessClient857,
    ObjectStublessClient858,
    ObjectStublessClient859,
    ObjectStublessClient860,
    ObjectStublessClient861,
    ObjectStublessClient862,
    ObjectStublessClient863,
    ObjectStublessClient864,
    ObjectStublessClient865,
    ObjectStublessClient866,
    ObjectStublessClient867,
    ObjectStublessClient868,
    ObjectStublessClient869,
    ObjectStublessClient870,
    ObjectStublessClient871,
    ObjectStublessClient872,
    ObjectStublessClient873,
    ObjectStublessClient874,
    ObjectStublessClient875,
    ObjectStublessClient876,
    ObjectStublessClient877,
    ObjectStublessClient878,
    ObjectStublessClient879,
    ObjectStublessClient880,
    ObjectStublessClient881,
    ObjectStublessClient882,
    ObjectStublessClient883,
    ObjectStublessClient884,
    ObjectStublessClient885,
    ObjectStublessClient886,
    ObjectStublessClient887,
    ObjectStublessClient888,
    ObjectStublessClient889,
    ObjectStublessClient890,
    ObjectStublessClient891,
    ObjectStublessClient892,
    ObjectStublessClient893,
    ObjectStublessClient894,
    ObjectStublessClient895,
    ObjectStublessClient896,
    ObjectStublessClient897,
    ObjectStublessClient898,
    ObjectStublessClient899,
    ObjectStublessClient900,
    ObjectStublessClient901,
    ObjectStublessClient902,
    ObjectStublessClient903,
    ObjectStublessClient904,
    ObjectStublessClient905,
    ObjectStublessClient906,
    ObjectStublessClient907,
    ObjectStublessClient908,
    ObjectStublessClient909,
    ObjectStublessClient910,
    ObjectStublessClient911,
    ObjectStublessClient912,
    ObjectStublessClient913,
    ObjectStublessClient914,
    ObjectStublessClient915,
    ObjectStublessClient916,
    ObjectStublessClient917,
    ObjectStublessClient918,
    ObjectStublessClient919,
    ObjectStublessClient920,
    ObjectStublessClient921,
    ObjectStublessClient922,
    ObjectStublessClient923,
    ObjectStublessClient924,
    ObjectStublessClient925,
    ObjectStublessClient926,
    ObjectStublessClient927,
    ObjectStublessClient928,
    ObjectStublessClient929,
    ObjectStublessClient930,
    ObjectStublessClient931,
    ObjectStublessClient932,
    ObjectStublessClient933,
    ObjectStublessClient934,
    ObjectStublessClient935,
    ObjectStublessClient936,
    ObjectStublessClient937,
    ObjectStublessClient938,
    ObjectStublessClient939,
    ObjectStublessClient940,
    ObjectStublessClient941,
    ObjectStublessClient942,
    ObjectStublessClient943,
    ObjectStublessClient944,
    ObjectStublessClient945,
    ObjectStublessClient946,
    ObjectStublessClient947,
    ObjectStublessClient948,
    ObjectStublessClient949,
    ObjectStublessClient950,
    ObjectStublessClient951,
    ObjectStublessClient952,
    ObjectStublessClient953,
    ObjectStublessClient954,
    ObjectStublessClient955,
    ObjectStublessClient956,
    ObjectStublessClient957,
    ObjectStublessClient958,
    ObjectStublessClient959,
    ObjectStublessClient960,
    ObjectStublessClient961,
    ObjectStublessClient962,
    ObjectStublessClient963,
    ObjectStublessClient964,
    ObjectStublessClient965,
    ObjectStublessClient966,
    ObjectStublessClient967,
    ObjectStublessClient968,
    ObjectStublessClient969,
    ObjectStublessClient970,
    ObjectStublessClient971,
    ObjectStublessClient972,
    ObjectStublessClient973,
    ObjectStublessClient974,
    ObjectStublessClient975,
    ObjectStublessClient976,
    ObjectStublessClient977,
    ObjectStublessClient978,
    ObjectStublessClient979,
    ObjectStublessClient980,
    ObjectStublessClient981,
    ObjectStublessClient982,
    ObjectStublessClient983,
    ObjectStublessClient984,
    ObjectStublessClient985,
    ObjectStublessClient986,
    ObjectStublessClient987,
    ObjectStublessClient988,
    ObjectStublessClient989,
    ObjectStublessClient990,
    ObjectStublessClient991,
    ObjectStublessClient992,
    ObjectStublessClient993,
    ObjectStublessClient994,
    ObjectStublessClient995,
    ObjectStublessClient996,
    ObjectStublessClient997,
    ObjectStublessClient998,
    ObjectStublessClient999,
    ObjectStublessClient1000,
    ObjectStublessClient1001,
    ObjectStublessClient1002,
    ObjectStublessClient1003,
    ObjectStublessClient1004,
    ObjectStublessClient1005,
    ObjectStublessClient1006,
    ObjectStublessClient1007,
    ObjectStublessClient1008,
    ObjectStublessClient1009,
    ObjectStublessClient1010,
    ObjectStublessClient1011,
    ObjectStublessClient1012,
    ObjectStublessClient1013,
    ObjectStublessClient1014,
    ObjectStublessClient1015,
    ObjectStublessClient1016,
    ObjectStublessClient1017,
    ObjectStublessClient1018,
    ObjectStublessClient1019,
    ObjectStublessClient1020,
    ObjectStublessClient1021,
    ObjectStublessClient1022,
    ObjectStublessClient1023
    };

}

void ** StublessClientVtbl = (void **)g_StublessClientVtbl;
long
ObjectStublessClient(
    void *  ParamAddress,
    long    Method
    )
{
    PMIDL_STUBLESS_PROXY_INFO   ProxyInfo;
    CInterfaceProxyHeader *     ProxyHeader;
    PFORMAT_STRING              ProcFormat;
    unsigned short              ProcFormatOffset;
    CLIENT_CALL_RETURN          Return;
    void *                      This;

    This = *((void **)ParamAddress);

    ProxyHeader = (CInterfaceProxyHeader *)
                  (*((char **)This) - sizeof(CInterfaceProxyHeader));
    ProxyInfo = (PMIDL_STUBLESS_PROXY_INFO) ProxyHeader->pStublessProxyInfo;

    if ( ProxyInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )
    {
        NDR_PROC_CONTEXT ProcContext;
        HRESULT          hr;

        Ndr64ClientInitializeContext(
                               NdrpGetSyntaxType( ProxyInfo->pTransferSyntax),
                               ProxyInfo,
                               Method,
                               &ProcContext,
                               (uchar*)ParamAddress );

        if ( ProcContext.FloatDoubleMask != 0 )
            SpillFPRegsForIA64( (REGISTER_TYPE*)ParamAddress, ProcContext.FloatDoubleMask );


        if ( ProcContext.IsAsync )
            {
            if ( Method & 0x1 )
                hr =  MulNdrpBeginDcomAsyncClientCall( ProxyInfo,
                                               Method,
                                               &ProcContext,
                                               ParamAddress );
            else
                hr =  MulNdrpFinishDcomAsyncClientCall(ProxyInfo,
                                               Method,
                                               &ProcContext,
                                               ParamAddress );
            Return.Simple = hr;
            }
        else
            Return = NdrpClientCall3(This,
                                     ProxyInfo,
                                     Method,
                                     NULL,
                                     &ProcContext,
                                     (uchar*)ParamAddress);

        return (long) Return.Simple;
    }

    ProcFormatOffset = ProxyInfo->FormatStringOffset[Method];
    ProcFormat = &ProxyInfo->ProcFormatString[ProcFormatOffset];

    // The first public MIDL with 64b support was released with NT5 betA2.
    // We will ignore any MIDL earlier than the MIDL released with NT5/2000 beta3.
    // Change MIDL_VERSION_5_2_202 to the MIDL version for beta3, now at 5.2.221.

    if ( ProxyInfo->pStubDesc->MIDLVersion < MIDL_VERSION_5_2_202 )
        {
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    // Since MIDL 3.0.39 we have a proc flag that indicates
    // which interpeter to call. This is because the NDR version
    // may be bigger than 1.1 for other reasons.
    // MIDL version is 5.2.+ so the flag is guaraneed to be there.

    if ( ProcFormat[1]  &  Oi_OBJ_USE_V2_INTERPRETER )
        {
            {
            ULONG   FloatArgMask = 0;

            if ( ((PNDR_DCOM_OI2_PROC_HEADER) ProcFormat)->Oi2Flags.HasExtensions )
                {
                PNDR_PROC_HEADER_EXTS64 pExts = (PNDR_PROC_HEADER_EXTS64)
                                    (ProcFormat + sizeof(NDR_DCOM_OI2_PROC_HEADER));

                FloatArgMask = pExts->FloatArgMask;
                }

            if ( FloatArgMask != 0 )
                SpillFPRegsForIA64( (REGISTER_TYPE*)ParamAddress, FloatArgMask );
            }

        if ( ((PNDR_DCOM_OI2_PROC_HEADER) ProcFormat)->Oi2Flags.HasAsyncUuid )
            {
            Return = NdrpDcomAsyncClientCall( ProxyInfo->pStubDesc,
                                             ProcFormat,
                                             (uchar*)ParamAddress );
            }
        else
            {
            Return = NdrpClientCall2( ProxyInfo->pStubDesc,
                                     ProcFormat,
                                     (uchar*)ParamAddress );
            }
        }
    else
        {
        // No support for old interpreter on 64b platform.
        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    return (long) Return.Simple;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\ia64\stubless.s ===
// Copyright (c) 1993-1999 Microsoft Corporation

        .file       "stubless.s"

#include "ksia64.h"

        .global ObjectStublessClient
        .type   ObjectStublessClient, @function

//++
//
//  Function:   REGISTER_TYPE __stdcall Invoke(MANAGER_FUNCTION pFunction, 
//                                             REGISTER_TYPE   *pArgumentList,
//                                             ULONG            FloatMask,
//                                             ULONG            cArguments);
//
//  Synopsis:   Given a function pointer and an argument list, Invoke builds 
//              a stack frame and calls the function.
//
//  Arguments:  pFunction - Pointer to the function to be called.
//
//              pArgumentList - Pointer to the buffer containing the 
//                              function parameters.
//
//              FloatMask - A mask that indicates argument slots passed as float/double registers
//                          Each nibble indicates if the argument slot contains a float
//                          Float       : D8 F8 D7 F7 D6 F6 D5 F5 D4 F4 D3 F3 D2 F2 D1 F1
//                          bit position: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
//                          16 bits represents 8 slots
//                          If both the D and F bits are set then the argument slot contains
//                          *two* floating point args.
//
//              cArguments - The size of the argument list in REGISTER_TYPEs.
//
//
//  Notes:     In the __stdcall calling convention, the callee must pop
//             the parameters.
//
//--
        NESTED_ENTRY(Invoke)
        NESTED_SETUP(4,4,8,0)

        NumParam        = a3
        FloatMask       = a2
        ParamStartAddr  = a1
        CallFuncAddr    = a0

        savedSP         = loc2
        savedLC         = loc3

        paramSz         = t10
        funcAddr        = t11
        paramAddr       = t12
                
        startP          = t13
        endP            = t14

        ARGPTR          (a0)
        ARGPTR          (a1)

        .vframe savedSP
        mov             savedSP = sp                    // save sp
		mov             savedLC = ar.lc                 // preserve loop count
        shl             paramSz = NumParam, 3           // num * szof(register)
        ;;

        PROLOGUE_END

        mov             paramAddr = ParamStartAddr      // param address
        add             startP = ParamStartAddr,paramSz // to copy bottom to top
        ;;

//
//  Check if the parameter list is > 64 bytes. If so then jump to the default
//  label. This will copy parameters > 64 bytes to the stack.
//
//  If the paramter list is < 64 bytes then calculate the number of registers required
//  and dispatch to the correct load label.
//
        
        add             startP = -8, startP             // compute start address
                                                        // = pAddr + pSz - 8
        cmp4.ge         pt0, pt1 = 64, paramSz          // if paramSz > 64 bytes
(pt1)   br.cond.spnt    default                         // yes

        movl            t0 = label0                     // no. mem copy not needed 
        shl             t1 = NumParam, 4;;
        sub             t0 = t0, t1;;                   // get correct bundle addr    
        mov             bt0 = t0                        // to jump to
        br.cond.sptk    bt0        

default:                                                // copy in-memory args

        tbit.nz         pt2, pt3 = NumParam, 0          // is NumParam even?
        add             endP = 64, paramAddr            // last address
        add             t0 = -64, paramSz
        ;;

(pt2)   add             t0 = -8, t0
(pt3)   add             t0 = -16, t0
(pt2)   mov             t2 = savedSP
(pt3)   add             t2 = 8, savedSP
        ;;

        sub             sp = sp, t0                     // allocate stack frame

//
//      Load arguments > 64 bytes on to the stack
//
NextParam:
        ld8             t3 = [startP], -8            
        ;;
        st8             [t2] = t3, -8
        cmp.lt          pt0, pt1 = startP, endP         // while current >= end
(pt1)   br.cond.sptk    NextParam   
        ;;

//
//      Load the appropriate number of registers
//

label8:
        ld8             out7 = [startP], -8
        nop.i           0
        nop.i           0;;
label7:
        ld8             out6 = [startP], -8
        nop.i           0
        nop.i           0;;

label6:
        ld8             out5 = [startP], -8
        nop.i           0
        nop.i           0;;

label5:
        ld8             out4 = [startP], -8
        nop.i           0
        nop.i           0;;

label4:
        ld8             out3 = [startP], -8
        nop.i           0
        nop.i           0;;

label3:
        ld8             out2 = [startP], -8
        nop.i           0
        nop.i           0;;

label2:
        ld8             out1 = [startP], -8
        nop.i           0
        nop.i           0;;

label1:
        ld8             out0 = [startP]
        nop.i           0
        nop.i           0;;

label0:
//
// If there are any floating point registers load them here      
//
        cmp.eq          pt1 = 0,FloatMask           // Check for Zero FP Arguments
(pt1)   br.cond.sptk    NoFloat                     // If eql zero we are All done

//
//  Loop through the floating mask looking for slots containing fp values
//  Algorithm:
//     The position of float arguments is unknown so iterate sequentially
//     through the FloatMask. Each time a float is found rotate the registers
//     using a counted loop. 
//
//  lc  - Loop count. Initialize to the maximum number of arguments   
//  t15 - Contains the floatmask. Shifted each iteration of the loop
//  t14 - bits<1:0> contain the current float descriptor
//  t12 - Contains the current parameter (i.e., slot) address
//  f32 - Rotated float register
//  pt1 - True if FloatMask equals zero
//  pt2 - True if current descriptor equals zero
//  pr16 - True if current descriptor contains a float. Rotate (pr17,pr18,etc) each iteration of the loop
//  pt3  - True if current descriptor contains float value
//  pt4  - True if current descriptor contanis double value
//
//        
        mov         t15    = FloatMask;;            // Make a copy 
        popcnt      t4     = t15;;                  // Count the number of floating point regs needed
        mov         t12    = paramAddr
        mov         ar.lc  = t4;;                   // The maximum loop count

GetNextFloatDescriptor:
        extr.u      t14 = t15, 0, 2                 // Extract the current descriptor (D or F)
        shr         t15 = t15,2;;                   // Shift to get next descriptor
        cmp.eq      pt1 = 0,t15                     // See if the mask is zero ( 0 = all done)
        cmp.eq      pt2 = 0,t14                     // If the current descriptor is zero get the next descriptor
        cmp.eq      pt3 = 1,t14                     // Check for float 
        cmp.eq      pt4 = 2,t14                     // Check for double
        cmp.ne      pt5 = 3,t14;;                   // Check for dual floats

(pt3)   ldfs        f32 = [t12];;                   // Load float
(pt4)   ldfd        f32 = [t12];;                   // Load double
(pt5)   br.cond.sptk    SkipDualFloat

        br.ctop.sptk    DualFloatRegBump;;          // Force an extra register rotate if dual floats
DualFloatRegBump:
        ldfps       f33,f32 = [t12];;               // Load two floats
    
SkipDualFloat:
        add         t12 = 8,t12;;                   // Increment argument slot address
(pt1)   br.cond.sptk    MoveFloat                   // If the mask is zero exit loop
(pt2)   br.cond.sptk    GetNextFloatDescriptor      // A zero descriptor pays a branch penality
                                                    // but it does not rotate the registers                 
        br.ctop.sptk    GetNextFloatDescriptor      // Counted loop no penalty for branch rotate f32&pr16 
        ;;
//
// At this point the fp values are in f32-f39. Predicate registers pr16-pr23 
// are set for each float found. Copy the float values to f8-f15
//
MoveFloat:

        cmp.eq      pt1 = 1, t4;;           // look at the number of floats and move accordingly.
(pt1)   br.cond.sptk    MoveOne
        cmp.eq      pt2 = 2, t4;;
(pt2)   br.cond.sptk    MoveTwo
        cmp.eq      pt3 = 3, t4;;
(pt3)   br.cond.sptk    MoveThree
        cmp.eq      pt4 = 4, t4;;
(pt4)   br.cond.sptk    MoveFour
        cmp.eq      pt5 = 5, t4;;
(pt5)   br.cond.sptk    MoveFive
        cmp.eq      pt6 = 6, t4;;
(pt6)   br.cond.sptk    MoveSix
        cmp.eq      pt7 = 7, t4;;
(pt7)   br.cond.sptk    MoveSeven
        cmp.eq      pt8 = 8, t4;;
(pt8)   br.cond.sptk    MoveEight

        br.cond.sptk DoneMoveFloat;;        // we should never get here, but just in case, exit.

MoveOne:
        mov         f8 = f32
        br.cond.sptk DoneMoveFloat;;

MoveTwo:
        mov         f8 = f33
        mov         f9 = f32
        br.cond.sptk DoneMoveFloat;;

MoveThree:
        mov         f8 = f34
        mov         f9 = f33
        mov         f10 = f32
        br.cond.sptk DoneMoveFloat;;

MoveFour:
        mov         f8 = f35
        mov         f9 = f34
        mov         f10 = f33
        mov         f11 = f32
        br.cond.sptk DoneMoveFloat;;

MoveFive:
        mov         f8 = f36
        mov         f9 = f35
        mov         f10 = f34
        mov         f11 = f33
        mov         f12 = f32
        br.cond.sptk DoneMoveFloat;;

MoveSix:
        mov         f8 = f37
        mov         f9 = f36
        mov         f10 = f35
        mov         f11 = f34
        mov         f12 = f33
        mov         f13 = f32
        br.cond.sptk DoneMoveFloat;;

MoveSeven:
        mov         f8 = f38
        mov         f9 = f37
        mov         f10 = f36
        mov         f11 = f35
        mov         f12 = f34
        mov         f13 = f33
        mov         f14 = f32
        br.cond.sptk DoneMoveFloat;;

MoveEight:
        mov         f8 = f39
        mov         f9 = f38
        mov         f10 = f37
        mov         f11 = f36
        mov         f12 = f35
        mov         f13 = f34
        mov         f14 = f33
        mov         f15 = f32


DoneMoveFloat:
        rum         1 << PSR_MFH
        

NoFloat:

        add        sp = -STACK_SCRATCH_AREA, sp             // space for scratch area

        ld8        funcAddr = [CallFuncAddr],PlGlobalPointer-PlEntryPoint
        ;;
        ld8        gp = [CallFuncAddr] 
        mov        bt1 = funcAddr                           // call the function
        br.call.sptk brp = bt1
        ;;

        mov        ar.lc = savedLC             // restore loop count register
        .restore
        mov        sp = savedSP

        NESTED_RETURN
     
        NESTED_EXIT(Invoke)

//
// Define ObjectStublessClientBig routine macro.
// This macro can be used for any number of arguments
//

#define StublessClientProc(Method)                                      \
                                                                        \
        .##global       ObjectStublessClient##Method;                   \
        NESTED_ENTRY(ObjectStublessClient##Method);                     \
        NESTED_SETUP(8, 3, 2, 0);                                       \
/*                                                                      \
 *      Assume we have more than 8 arguments, starting from nineth      \
 *      argument is located STACK_SCRATCH_AREA(sp'),                    \
 *      STACK_SCRATCH_AREA+8(sp') and so on ... sp' is sp at point of   \
 *      call                                                            \
 *                                                                      \
 *      We have to push those 8 arguments into contiguous stack         \
 *      starting at STACK_SCRATCH_AREA(sp). A local frame size of 64    \
 *      bytes is allocated for the 8 arguments, 8 bytes each.           \
 */                                                                     \
        .##fframe 64;                                                   \
        add     sp = -64, sp;                                           \
        ;;                                                              \
                                                                        \
        .##save  ar##.##unat, loc2;                                     \
        mov     loc2 = ar##.##unat;                                     \
        add     r2 = 64+STACK_SCRATCH_AREA-8, sp;                       \
        add     r3 = STACK_SCRATCH_AREA, sp;                            \
        ;;                                                              \
                                                                        \
        .##mem##.##offset 0,0;                                          \
        st8.spill     [r2] = a7, -8;                                    \
        .##mem##.##offset 8,0;                                          \
        st8.spill     [r3] = a0, 8;                                     \
        PROLOGUE_END                                                    \
        ;;                                                              \
                                                                        \
        .##mem##.##offset 0,0;                                          \
        st8.spill     [r2] = a6, -8;                                    \
        .##mem##.##offset 8,0;                                          \
        st8.spill     [r3] = a1, 8;                                     \
        ;;                                                              \
                                                                        \
        .##mem##.##offset 0,0;                                          \
        st8.spill     [r2] = a5, -8;                                    \
        .##mem##.##offset 8,0;                                          \
        st8.spill     [r3] = a2, 8;                                     \
        ;;                                                              \
                                                                        \
        .##mem##.##offset 0,0;                                          \
        st8.spill     [r2] = a4;                                        \
        .##mem##.##offset 8,0;                                          \
        st8.spill     [r3] = a3;                                        \
        ;;                                                              \
                                                                        \
        mov     ar##.##unat = loc2;                                     \
        add     out0 = STACK_SCRATCH_AREA, sp;                          \
        mov     out1 = ##Method;                                        \
                                                                        \
        br##.##call##.##sptk    brp = ObjectStublessClient;             \
        ;;                                                              \
                                                                        \
        .##restore;                                                     \
        add     sp = 64, sp;                                            \
        NESTED_RETURN;                                                  \
        NESTED_EXIT(ObjectStublessClient##Method)       

//++
//
//  Function:   void __stdcall SpillFPRegsForIA64(
//                                 REGISTER_TYPE* pStack, 
//                                 ULONG          FloatMask
//                                 );
//
//  Synopsis:   Given a pointer to the virtual stack and floating-point mask,
//              SpillFPRegsForIA64 copies the contents of the floating-point 
//              registers to the appropriate slots in pStack.
//
//  Arguments:  pStack - Pointer to the virtual stack in memory.
//
//              FloatMask - A mask that indicates argument slots passed as float/double registers
//                          Each nibble indicates if the argument slot contains a float
//                          Float       : D8 F8 D7 F7 D6 F6 D5 F5 D4 F4 D3 F3 D2 F2 D1 F1
//                          bit position: 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
//                          16 bits represents 8 slots
//                          If both the D and F bits are set then the argument slot contains
//                          *two* floating point args.
//
//  Notes:     In the __stdcall calling convention, the callee must pop
//             the parameters.
//
//--
        NESTED_ENTRY(SpillFPRegsForIA64)
        NESTED_SETUP(4,4,8,0)

        savedSP         = loc2                  // savedSP aliased to loc2
        savedLC         = loc3
        pStack          = a0                    // pStack  aliased to first param passed in
        FloatMask       = a1                    // FloatMask  aliased to second param passed in

        mov             savedSP = sp            // save sp
        mov             savedLC = ar.lc         // save lc

        PROLOGUE_END

        ARGPTR          (a0)                    // sign-extend pStack for WIN32

        //----------------------------------------------------------------
        // start of main algorithm
        //----------------------------------------------------------------
        mov             t0 = FloatMask;;        // FloatMask copied to t0
        mov             t1 = pStack             // pStack copied to t1

        popcnt          t4 = t0;;               // count number of bits in FloatMask; i.e. how many
                                                // active slots

        cmp.eq          pt0 = 8, t4             // look at the number of parameters and branch accordingly.
(pt0)   br.cond.sptk    ReverseFP8;;            
        cmp.eq          pt0 = 7, t4             // the fp args are ordered by their arguement order; i.e.
(pt0)   br.cond.sptk    ReverseFP7;;            // fp32 contains the first fp arg, fp32 contains the next
        cmp.eq          pt0 = 6, t4             // fp arg...etc. 
(pt0)   br.cond.sptk    ReverseFP6;;              
        cmp.eq          pt0 = 5, t4             // rotating registers rotate downward. because of this we
(pt0)   br.cond.sptk    ReverseFP5;;            // reverse the order of the fp regs fp8 - fp15 to 
        cmp.eq          pt0 = 4, t4             // fp47 - fp40. (see ReverseFP8 to ReverseFP1)
(pt0)   br.cond.sptk    ReverseFP4;;
        cmp.eq          pt0 = 3, t4             
(pt0)   br.cond.sptk    ReverseFP3;;
        cmp.eq          pt0 = 2, t4
(pt0)   br.cond.sptk    ReverseFP2;;
        cmp.eq          pt0 = 1, t4
(pt0)   br.cond.sptk    ReverseFP1;;


ReverseFP8:                                     // reverse fp reg order
        mov             f40 = f15
ReverseFP7:
        mov             f41 = f14
ReverseFP6:
        mov             f42 = f13
ReverseFP5:
        mov             f43 = f12
ReverseFP4:
        mov             f44 = f11
ReverseFP3:
        mov             f45 = f10
ReverseFP2:
        mov             f46 = f9
ReverseFP1:
        mov             f47 = f8
     

StartSpill:
        mov             ar.lc  = t4             // the maximum loop count is total fp slots used


ProcessNextSlot:
        extr.u          t10 = t0, 0, 2          // extract the two FP slot nibbles into t10
        shr.u           t0  = t0, 2;;           // shift FloatMask, since we've extracted the slot

        cmp.eq          pt0 = 0, t0             // check if FloatMask is zero; if so, we are done.
        cmp.eq          pt1 = 0, t10            // check if slot is 0; i.e. not a float or double
        cmp.eq          pt2 = 1, t10            // check first nibble of extracted slot is float
        cmp.eq          pt3 = 2, t10            // check second nibble of extracted slot is double
        cmp.ne          pt4 = 3, t10;;          // check for dual floats

(pt2)   stfs            [t1] = f47;;            // store float at pStack
(pt3)   stfd            [t1] = f47;;            // store double at pStack
(pt4)   br.cond.sptk    SkipDualFloat2;;

        stfs            [t1] = f47, 4;;         // store dual floats
        stfs            [t1] = f46, -4;;
        br.ctop.sptk    SkipDualFloat2;;        // Force an extra register rotate if dual floats

SkipDualFloat2:        
        add             t1 = 8, t1              // increment address to point to the next slot

(pt0)   br.cond.sptk    Done                    // FloatMask is zero, so we are done
(pt1)   br.cond.sptk    ProcessNextSlot         // a zero slot pays a branch penality; but it does not 
                                                // rotate the fp & pr registers
        br.ctop.sptk    ProcessNextSlot;;       // counted loop no penalty for branch rotate f32&pr16 
        ;;


        //----------------------------------------------------------------
        // done, restore sp and exit
        //----------------------------------------------------------------
Done:
		mov             ar.lc = savedLC         // restore loop count register
        .restore
        mov             sp = savedSP            // restore sp

        NESTED_RETURN
     
        NESTED_EXIT(SpillFPRegsForIA64)


StublessClientProc( 3 )
StublessClientProc( 4 )
StublessClientProc( 5 )
StublessClientProc( 6 )
StublessClientProc( 7 )
StublessClientProc( 8 )
StublessClientProc( 9 )
StublessClientProc( 10 )
StublessClientProc( 11 )
StublessClientProc( 12 )
StublessClientProc( 13 )
StublessClientProc( 14 )
StublessClientProc( 15 )
StublessClientProc( 16 )
StublessClientProc( 17 )
StublessClientProc( 18 )
StublessClientProc( 19 )
StublessClientProc( 20 )
StublessClientProc( 21 )
StublessClientProc( 22 )
StublessClientProc( 23 )
StublessClientProc( 24 )
StublessClientProc( 25 )
StublessClientProc( 26 )
StublessClientProc( 27 )
StublessClientProc( 28 )
StublessClientProc( 29 )
StublessClientProc( 30 )
StublessClientProc( 31 )
StublessClientProc( 32 )
StublessClientProc( 33 )
StublessClientProc( 34 )
StublessClientProc( 35 )
StublessClientProc( 36 )
StublessClientProc( 37 )
StublessClientProc( 38 )
StublessClientProc( 39 )
StublessClientProc( 40 )
StublessClientProc( 41 )
StublessClientProc( 42 )
StublessClientProc( 43 )
StublessClientProc( 44 )
StublessClientProc( 45 )
StublessClientProc( 46 )
StublessClientProc( 47 )
StublessClientProc( 48 )
StublessClientProc( 49 )
StublessClientProc( 50 )
StublessClientProc( 51 )
StublessClientProc( 52 )
StublessClientProc( 53 )
StublessClientProc( 54 )
StublessClientProc( 55 )
StublessClientProc( 56 )
StublessClientProc( 57 )
StublessClientProc( 58 )
StublessClientProc( 59 )
StublessClientProc( 60 )
StublessClientProc( 61 )
StublessClientProc( 62 )
StublessClientProc( 63 )
StublessClientProc( 64 )
StublessClientProc( 65 )
StublessClientProc( 66 )
StublessClientProc( 67 )
StublessClientProc( 68 )
StublessClientProc( 69 )
StublessClientProc( 70 )
StublessClientProc( 71 )
StublessClientProc( 72 )
StublessClientProc( 73 )
StublessClientProc( 74 )
StublessClientProc( 75 )
StublessClientProc( 76 )
StublessClientProc( 77 )
StublessClientProc( 78 )
StublessClientProc( 79 )
StublessClientProc( 80 )
StublessClientProc( 81 )
StublessClientProc( 82 )
StublessClientProc( 83 )
StublessClientProc( 84 )
StublessClientProc( 85 )
StublessClientProc( 86 )
StublessClientProc( 87 )
StublessClientProc( 88 )
StublessClientProc( 89 )
StublessClientProc( 90 )
StublessClientProc( 91 )
StublessClientProc( 92 )
StublessClientProc( 93 )
StublessClientProc( 94 )
StublessClientProc( 95 )
StublessClientProc( 96 )
StublessClientProc( 97 )
StublessClientProc( 98 )
StublessClientProc( 99 )
StublessClientProc( 100 )
StublessClientProc( 101 )
StublessClientProc( 102 )
StublessClientProc( 103 )
StublessClientProc( 104 )
StublessClientProc( 105 )
StublessClientProc( 106 )
StublessClientProc( 107 )
StublessClientProc( 108 )
StublessClientProc( 109 )
StublessClientProc( 110 )
StublessClientProc( 111 )
StublessClientProc( 112 )
StublessClientProc( 113 )
StublessClientProc( 114 )
StublessClientProc( 115 )
StublessClientProc( 116 )
StublessClientProc( 117 )
StublessClientProc( 118 )
StublessClientProc( 119 )
StublessClientProc( 120 )
StublessClientProc( 121 )
StublessClientProc( 122 )
StublessClientProc( 123 )
StublessClientProc( 124 )
StublessClientProc( 125 )
StublessClientProc( 126 )
StublessClientProc( 127 )
StublessClientProc( 128 )
StublessClientProc( 129 )
StublessClientProc( 130 )
StublessClientProc( 131 )
StublessClientProc( 132 )
StublessClientProc( 133 )
StublessClientProc( 134 )
StublessClientProc( 135 )
StublessClientProc( 136 )
StublessClientProc( 137 )
StublessClientProc( 138 )
StublessClientProc( 139 )
StublessClientProc( 140 )
StublessClientProc( 141 )
StublessClientProc( 142 )
StublessClientProc( 143 )
StublessClientProc( 144 )
StublessClientProc( 145 )
StublessClientProc( 146 )
StublessClientProc( 147 )
StublessClientProc( 148 )
StublessClientProc( 149 )
StublessClientProc( 150 )
StublessClientProc( 151 )
StublessClientProc( 152 )
StublessClientProc( 153 )
StublessClientProc( 154 )
StublessClientProc( 155 )
StublessClientProc( 156 )
StublessClientProc( 157 )
StublessClientProc( 158 )
StublessClientProc( 159 )
StublessClientProc( 160 )
StublessClientProc( 161 )
StublessClientProc( 162 )
StublessClientProc( 163 )
StublessClientProc( 164 )
StublessClientProc( 165 )
StublessClientProc( 166 )
StublessClientProc( 167 )
StublessClientProc( 168 )
StublessClientProc( 169 )
StublessClientProc( 170 )
StublessClientProc( 171 )
StublessClientProc( 172 )
StublessClientProc( 173 )
StublessClientProc( 174 )
StublessClientProc( 175 )
StublessClientProc( 176 )
StublessClientProc( 177 )
StublessClientProc( 178 )
StublessClientProc( 179 )
StublessClientProc( 180 )
StublessClientProc( 181 )
StublessClientProc( 182 )
StublessClientProc( 183 )
StublessClientProc( 184 )
StublessClientProc( 185 )
StublessClientProc( 186 )
StublessClientProc( 187 )
StublessClientProc( 188 )
StublessClientProc( 189 )
StublessClientProc( 190 )
StublessClientProc( 191 )
StublessClientProc( 192 )
StublessClientProc( 193 )
StublessClientProc( 194 )
StublessClientProc( 195 )
StublessClientProc( 196 )
StublessClientProc( 197 )
StublessClientProc( 198 )
StublessClientProc( 199 )
StublessClientProc( 200 )
StublessClientProc( 201 )
StublessClientProc( 202 )
StublessClientProc( 203 )
StublessClientProc( 204 )
StublessClientProc( 205 )
StublessClientProc( 206 )
StublessClientProc( 207 )
StublessClientProc( 208 )
StublessClientProc( 209 )
StublessClientProc( 210 )
StublessClientProc( 211 )
StublessClientProc( 212 )
StublessClientProc( 213 )
StublessClientProc( 214 )
StublessClientProc( 215 )
StublessClientProc( 216 )
StublessClientProc( 217 )
StublessClientProc( 218 )
StublessClientProc( 219 )
StublessClientProc( 220 )
StublessClientProc( 221 )
StublessClientProc( 222 )
StublessClientProc( 223 )
StublessClientProc( 224 )
StublessClientProc( 225 )
StublessClientProc( 226 )
StublessClientProc( 227 )
StublessClientProc( 228 )
StublessClientProc( 229 )
StublessClientProc( 230 )
StublessClientProc( 231 )
StublessClientProc( 232 )
StublessClientProc( 233 )
StublessClientProc( 234 )
StublessClientProc( 235 )
StublessClientProc( 236 )
StublessClientProc( 237 )
StublessClientProc( 238 )
StublessClientProc( 239 )
StublessClientProc( 240 )
StublessClientProc( 241 )
StublessClientProc( 242 )
StublessClientProc( 243 )
StublessClientProc( 244 )
StublessClientProc( 245 )
StublessClientProc( 246 )
StublessClientProc( 247 )
StublessClientProc( 248 )
StublessClientProc( 249 )
StublessClientProc( 250 )
StublessClientProc( 251 )
StublessClientProc( 252 )
StublessClientProc( 253 )
StublessClientProc( 254 )
StublessClientProc( 255 )
StublessClientProc( 256 )
StublessClientProc( 257 )
StublessClientProc( 258 )
StublessClientProc( 259 )
StublessClientProc( 260 )
StublessClientProc( 261 )
StublessClientProc( 262 )
StublessClientProc( 263 )
StublessClientProc( 264 )
StublessClientProc( 265 )
StublessClientProc( 266 )
StublessClientProc( 267 )
StublessClientProc( 268 )
StublessClientProc( 269 )
StublessClientProc( 270 )
StublessClientProc( 271 )
StublessClientProc( 272 )
StublessClientProc( 273 )
StublessClientProc( 274 )
StublessClientProc( 275 )
StublessClientProc( 276 )
StublessClientProc( 277 )
StublessClientProc( 278 )
StublessClientProc( 279 )
StublessClientProc( 280 )
StublessClientProc( 281 )
StublessClientProc( 282 )
StublessClientProc( 283 )
StublessClientProc( 284 )
StublessClientProc( 285 )
StublessClientProc( 286 )
StublessClientProc( 287 )
StublessClientProc( 288 )
StublessClientProc( 289 )
StublessClientProc( 290 )
StublessClientProc( 291 )
StublessClientProc( 292 )
StublessClientProc( 293 )
StublessClientProc( 294 )
StublessClientProc( 295 )
StublessClientProc( 296 )
StublessClientProc( 297 )
StublessClientProc( 298 )
StublessClientProc( 299 )
StublessClientProc( 300 )
StublessClientProc( 301 )
StublessClientProc( 302 )
StublessClientProc( 303 )
StublessClientProc( 304 )
StublessClientProc( 305 )
StublessClientProc( 306 )
StublessClientProc( 307 )
StublessClientProc( 308 )
StublessClientProc( 309 )
StublessClientProc( 310 )
StublessClientProc( 311 )
StublessClientProc( 312 )
StublessClientProc( 313 )
StublessClientProc( 314 )
StublessClientProc( 315 )
StublessClientProc( 316 )
StublessClientProc( 317 )
StublessClientProc( 318 )
StublessClientProc( 319 )
StublessClientProc( 320 )
StublessClientProc( 321 )
StublessClientProc( 322 )
StublessClientProc( 323 )
StublessClientProc( 324 )
StublessClientProc( 325 )
StublessClientProc( 326 )
StublessClientProc( 327 )
StublessClientProc( 328 )
StublessClientProc( 329 )
StublessClientProc( 330 )
StublessClientProc( 331 )
StublessClientProc( 332 )
StublessClientProc( 333 )
StublessClientProc( 334 )
StublessClientProc( 335 )
StublessClientProc( 336 )
StublessClientProc( 337 )
StublessClientProc( 338 )
StublessClientProc( 339 )
StublessClientProc( 340 )
StublessClientProc( 341 )
StublessClientProc( 342 )
StublessClientProc( 343 )
StublessClientProc( 344 )
StublessClientProc( 345 )
StublessClientProc( 346 )
StublessClientProc( 347 )
StublessClientProc( 348 )
StublessClientProc( 349 )
StublessClientProc( 350 )
StublessClientProc( 351 )
StublessClientProc( 352 )
StublessClientProc( 353 )
StublessClientProc( 354 )
StublessClientProc( 355 )
StublessClientProc( 356 )
StublessClientProc( 357 )
StublessClientProc( 358 )
StublessClientProc( 359 )
StublessClientProc( 360 )
StublessClientProc( 361 )
StublessClientProc( 362 )
StublessClientProc( 363 )
StublessClientProc( 364 )
StublessClientProc( 365 )
StublessClientProc( 366 )
StublessClientProc( 367 )
StublessClientProc( 368 )
StublessClientProc( 369 )
StublessClientProc( 370 )
StublessClientProc( 371 )
StublessClientProc( 372 )
StublessClientProc( 373 )
StublessClientProc( 374 )
StublessClientProc( 375 )
StublessClientProc( 376 )
StublessClientProc( 377 )
StublessClientProc( 378 )
StublessClientProc( 379 )
StublessClientProc( 380 )
StublessClientProc( 381 )
StublessClientProc( 382 )
StublessClientProc( 383 )
StublessClientProc( 384 )
StublessClientProc( 385 )
StublessClientProc( 386 )
StublessClientProc( 387 )
StublessClientProc( 388 )
StublessClientProc( 389 )
StublessClientProc( 390 )
StublessClientProc( 391 )
StublessClientProc( 392 )
StublessClientProc( 393 )
StublessClientProc( 394 )
StublessClientProc( 395 )
StublessClientProc( 396 )
StublessClientProc( 397 )
StublessClientProc( 398 )
StublessClientProc( 399 )
StublessClientProc( 400 )
StublessClientProc( 401 )
StublessClientProc( 402 )
StublessClientProc( 403 )
StublessClientProc( 404 )
StublessClientProc( 405 )
StublessClientProc( 406 )
StublessClientProc( 407 )
StublessClientProc( 408 )
StublessClientProc( 409 )
StublessClientProc( 410 )
StublessClientProc( 411 )
StublessClientProc( 412 )
StublessClientProc( 413 )
StublessClientProc( 414 )
StublessClientProc( 415 )
StublessClientProc( 416 )
StublessClientProc( 417 )
StublessClientProc( 418 )
StublessClientProc( 419 )
StublessClientProc( 420 )
StublessClientProc( 421 )
StublessClientProc( 422 )
StublessClientProc( 423 )
StublessClientProc( 424 )
StublessClientProc( 425 )
StublessClientProc( 426 )
StublessClientProc( 427 )
StublessClientProc( 428 )
StublessClientProc( 429 )
StublessClientProc( 430 )
StublessClientProc( 431 )
StublessClientProc( 432 )
StublessClientProc( 433 )
StublessClientProc( 434 )
StublessClientProc( 435 )
StublessClientProc( 436 )
StublessClientProc( 437 )
StublessClientProc( 438 )
StublessClientProc( 439 )
StublessClientProc( 440 )
StublessClientProc( 441 )
StublessClientProc( 442 )
StublessClientProc( 443 )
StublessClientProc( 444 )
StublessClientProc( 445 )
StublessClientProc( 446 )
StublessClientProc( 447 )
StublessClientProc( 448 )
StublessClientProc( 449 )
StublessClientProc( 450 )
StublessClientProc( 451 )
StublessClientProc( 452 )
StublessClientProc( 453 )
StublessClientProc( 454 )
StublessClientProc( 455 )
StublessClientProc( 456 )
StublessClientProc( 457 )
StublessClientProc( 458 )
StublessClientProc( 459 )
StublessClientProc( 460 )
StublessClientProc( 461 )
StublessClientProc( 462 )
StublessClientProc( 463 )
StublessClientProc( 464 )
StublessClientProc( 465 )
StublessClientProc( 466 )
StublessClientProc( 467 )
StublessClientProc( 468 )
StublessClientProc( 469 )
StublessClientProc( 470 )
StublessClientProc( 471 )
StublessClientProc( 472 )
StublessClientProc( 473 )
StublessClientProc( 474 )
StublessClientProc( 475 )
StublessClientProc( 476 )
StublessClientProc( 477 )
StublessClientProc( 478 )
StublessClientProc( 479 )
StublessClientProc( 480 )
StublessClientProc( 481 )
StublessClientProc( 482 )
StublessClientProc( 483 )
StublessClientProc( 484 )
StublessClientProc( 485 )
StublessClientProc( 486 )
StublessClientProc( 487 )
StublessClientProc( 488 )
StublessClientProc( 489 )
StublessClientProc( 490 )
StublessClientProc( 491 )
StublessClientProc( 492 )
StublessClientProc( 493 )
StublessClientProc( 494 )
StublessClientProc( 495 )
StublessClientProc( 496 )
StublessClientProc( 497 )
StublessClientProc( 498 )
StublessClientProc( 499 )
StublessClientProc( 500 )
StublessClientProc( 501 )
StublessClientProc( 502 )
StublessClientProc( 503 )
StublessClientProc( 504 )
StublessClientProc( 505 )
StublessClientProc( 506 )
StublessClientProc( 507 )
StublessClientProc( 508 )
StublessClientProc( 509 )
StublessClientProc( 510 )
StublessClientProc( 511 )
StublessClientProc( 512 )
StublessClientProc( 513 )
StublessClientProc( 514 )
StublessClientProc( 515 )
StublessClientProc( 516 )
StublessClientProc( 517 )
StublessClientProc( 518 )
StublessClientProc( 519 )
StublessClientProc( 520 )
StublessClientProc( 521 )
StublessClientProc( 522 )
StublessClientProc( 523 )
StublessClientProc( 524 )
StublessClientProc( 525 )
StublessClientProc( 526 )
StublessClientProc( 527 )
StublessClientProc( 528 )
StublessClientProc( 529 )
StublessClientProc( 530 )
StublessClientProc( 531 )
StublessClientProc( 532 )
StublessClientProc( 533 )
StublessClientProc( 534 )
StublessClientProc( 535 )
StublessClientProc( 536 )
StublessClientProc( 537 )
StublessClientProc( 538 )
StublessClientProc( 539 )
StublessClientProc( 540 )
StublessClientProc( 541 )
StublessClientProc( 542 )
StublessClientProc( 543 )
StublessClientProc( 544 )
StublessClientProc( 545 )
StublessClientProc( 546 )
StublessClientProc( 547 )
StublessClientProc( 548 )
StublessClientProc( 549 )
StublessClientProc( 550 )
StublessClientProc( 551 )
StublessClientProc( 552 )
StublessClientProc( 553 )
StublessClientProc( 554 )
StublessClientProc( 555 )
StublessClientProc( 556 )
StublessClientProc( 557 )
StublessClientProc( 558 )
StublessClientProc( 559 )
StublessClientProc( 560 )
StublessClientProc( 561 )
StublessClientProc( 562 )
StublessClientProc( 563 )
StublessClientProc( 564 )
StublessClientProc( 565 )
StublessClientProc( 566 )
StublessClientProc( 567 )
StublessClientProc( 568 )
StublessClientProc( 569 )
StublessClientProc( 570 )
StublessClientProc( 571 )
StublessClientProc( 572 )
StublessClientProc( 573 )
StublessClientProc( 574 )
StublessClientProc( 575 )
StublessClientProc( 576 )
StublessClientProc( 577 )
StublessClientProc( 578 )
StublessClientProc( 579 )
StublessClientProc( 580 )
StublessClientProc( 581 )
StublessClientProc( 582 )
StublessClientProc( 583 )
StublessClientProc( 584 )
StublessClientProc( 585 )
StublessClientProc( 586 )
StublessClientProc( 587 )
StublessClientProc( 588 )
StublessClientProc( 589 )
StublessClientProc( 590 )
StublessClientProc( 591 )
StublessClientProc( 592 )
StublessClientProc( 593 )
StublessClientProc( 594 )
StublessClientProc( 595 )
StublessClientProc( 596 )
StublessClientProc( 597 )
StublessClientProc( 598 )
StublessClientProc( 599 )
StublessClientProc( 600 )
StublessClientProc( 601 )
StublessClientProc( 602 )
StublessClientProc( 603 )
StublessClientProc( 604 )
StublessClientProc( 605 )
StublessClientProc( 606 )
StublessClientProc( 607 )
StublessClientProc( 608 )
StublessClientProc( 609 )
StublessClientProc( 610 )
StublessClientProc( 611 )
StublessClientProc( 612 )
StublessClientProc( 613 )
StublessClientProc( 614 )
StublessClientProc( 615 )
StublessClientProc( 616 )
StublessClientProc( 617 )
StublessClientProc( 618 )
StublessClientProc( 619 )
StublessClientProc( 620 )
StublessClientProc( 621 )
StublessClientProc( 622 )
StublessClientProc( 623 )
StublessClientProc( 624 )
StublessClientProc( 625 )
StublessClientProc( 626 )
StublessClientProc( 627 )
StublessClientProc( 628 )
StublessClientProc( 629 )
StublessClientProc( 630 )
StublessClientProc( 631 )
StublessClientProc( 632 )
StublessClientProc( 633 )
StublessClientProc( 634 )
StublessClientProc( 635 )
StublessClientProc( 636 )
StublessClientProc( 637 )
StublessClientProc( 638 )
StublessClientProc( 639 )
StublessClientProc( 640 )
StublessClientProc( 641 )
StublessClientProc( 642 )
StublessClientProc( 643 )
StublessClientProc( 644 )
StublessClientProc( 645 )
StublessClientProc( 646 )
StublessClientProc( 647 )
StublessClientProc( 648 )
StublessClientProc( 649 )
StublessClientProc( 650 )
StublessClientProc( 651 )
StublessClientProc( 652 )
StublessClientProc( 653 )
StublessClientProc( 654 )
StublessClientProc( 655 )
StublessClientProc( 656 )
StublessClientProc( 657 )
StublessClientProc( 658 )
StublessClientProc( 659 )
StublessClientProc( 660 )
StublessClientProc( 661 )
StublessClientProc( 662 )
StublessClientProc( 663 )
StublessClientProc( 664 )
StublessClientProc( 665 )
StublessClientProc( 666 )
StublessClientProc( 667 )
StublessClientProc( 668 )
StublessClientProc( 669 )
StublessClientProc( 670 )
StublessClientProc( 671 )
StublessClientProc( 672 )
StublessClientProc( 673 )
StublessClientProc( 674 )
StublessClientProc( 675 )
StublessClientProc( 676 )
StublessClientProc( 677 )
StublessClientProc( 678 )
StublessClientProc( 679 )
StublessClientProc( 680 )
StublessClientProc( 681 )
StublessClientProc( 682 )
StublessClientProc( 683 )
StublessClientProc( 684 )
StublessClientProc( 685 )
StublessClientProc( 686 )
StublessClientProc( 687 )
StublessClientProc( 688 )
StublessClientProc( 689 )
StublessClientProc( 690 )
StublessClientProc( 691 )
StublessClientProc( 692 )
StublessClientProc( 693 )
StublessClientProc( 694 )
StublessClientProc( 695 )
StublessClientProc( 696 )
StublessClientProc( 697 )
StublessClientProc( 698 )
StublessClientProc( 699 )
StublessClientProc( 700 )
StublessClientProc( 701 )
StublessClientProc( 702 )
StublessClientProc( 703 )
StublessClientProc( 704 )
StublessClientProc( 705 )
StublessClientProc( 706 )
StublessClientProc( 707 )
StublessClientProc( 708 )
StublessClientProc( 709 )
StublessClientProc( 710 )
StublessClientProc( 711 )
StublessClientProc( 712 )
StublessClientProc( 713 )
StublessClientProc( 714 )
StublessClientProc( 715 )
StublessClientProc( 716 )
StublessClientProc( 717 )
StublessClientProc( 718 )
StublessClientProc( 719 )
StublessClientProc( 720 )
StublessClientProc( 721 )
StublessClientProc( 722 )
StublessClientProc( 723 )
StublessClientProc( 724 )
StublessClientProc( 725 )
StublessClientProc( 726 )
StublessClientProc( 727 )
StublessClientProc( 728 )
StublessClientProc( 729 )
StublessClientProc( 730 )
StublessClientProc( 731 )
StublessClientProc( 732 )
StublessClientProc( 733 )
StublessClientProc( 734 )
StublessClientProc( 735 )
StublessClientProc( 736 )
StublessClientProc( 737 )
StublessClientProc( 738 )
StublessClientProc( 739 )
StublessClientProc( 740 )
StublessClientProc( 741 )
StublessClientProc( 742 )
StublessClientProc( 743 )
StublessClientProc( 744 )
StublessClientProc( 745 )
StublessClientProc( 746 )
StublessClientProc( 747 )
StublessClientProc( 748 )
StublessClientProc( 749 )
StublessClientProc( 750 )
StublessClientProc( 751 )
StublessClientProc( 752 )
StublessClientProc( 753 )
StublessClientProc( 754 )
StublessClientProc( 755 )
StublessClientProc( 756 )
StublessClientProc( 757 )
StublessClientProc( 758 )
StublessClientProc( 759 )
StublessClientProc( 760 )
StublessClientProc( 761 )
StublessClientProc( 762 )
StublessClientProc( 763 )
StublessClientProc( 764 )
StublessClientProc( 765 )
StublessClientProc( 766 )
StublessClientProc( 767 )
StublessClientProc( 768 )
StublessClientProc( 769 )
StublessClientProc( 770 )
StublessClientProc( 771 )
StublessClientProc( 772 )
StublessClientProc( 773 )
StublessClientProc( 774 )
StublessClientProc( 775 )
StublessClientProc( 776 )
StublessClientProc( 777 )
StublessClientProc( 778 )
StublessClientProc( 779 )
StublessClientProc( 780 )
StublessClientProc( 781 )
StublessClientProc( 782 )
StublessClientProc( 783 )
StublessClientProc( 784 )
StublessClientProc( 785 )
StublessClientProc( 786 )
StublessClientProc( 787 )
StublessClientProc( 788 )
StublessClientProc( 789 )
StublessClientProc( 790 )
StublessClientProc( 791 )
StublessClientProc( 792 )
StublessClientProc( 793 )
StublessClientProc( 794 )
StublessClientProc( 795 )
StublessClientProc( 796 )
StublessClientProc( 797 )
StublessClientProc( 798 )
StublessClientProc( 799 )
StublessClientProc( 800 )
StublessClientProc( 801 )
StublessClientProc( 802 )
StublessClientProc( 803 )
StublessClientProc( 804 )
StublessClientProc( 805 )
StublessClientProc( 806 )
StublessClientProc( 807 )
StublessClientProc( 808 )
StublessClientProc( 809 )
StublessClientProc( 810 )
StublessClientProc( 811 )
StublessClientProc( 812 )
StublessClientProc( 813 )
StublessClientProc( 814 )
StublessClientProc( 815 )
StublessClientProc( 816 )
StublessClientProc( 817 )
StublessClientProc( 818 )
StublessClientProc( 819 )
StublessClientProc( 820 )
StublessClientProc( 821 )
StublessClientProc( 822 )
StublessClientProc( 823 )
StublessClientProc( 824 )
StublessClientProc( 825 )
StublessClientProc( 826 )
StublessClientProc( 827 )
StublessClientProc( 828 )
StublessClientProc( 829 )
StublessClientProc( 830 )
StublessClientProc( 831 )
StublessClientProc( 832 )
StublessClientProc( 833 )
StublessClientProc( 834 )
StublessClientProc( 835 )
StublessClientProc( 836 )
StublessClientProc( 837 )
StublessClientProc( 838 )
StublessClientProc( 839 )
StublessClientProc( 840 )
StublessClientProc( 841 )
StublessClientProc( 842 )
StublessClientProc( 843 )
StublessClientProc( 844 )
StublessClientProc( 845 )
StublessClientProc( 846 )
StublessClientProc( 847 )
StublessClientProc( 848 )
StublessClientProc( 849 )
StublessClientProc( 850 )
StublessClientProc( 851 )
StublessClientProc( 852 )
StublessClientProc( 853 )
StublessClientProc( 854 )
StublessClientProc( 855 )
StublessClientProc( 856 )
StublessClientProc( 857 )
StublessClientProc( 858 )
StublessClientProc( 859 )
StublessClientProc( 860 )
StublessClientProc( 861 )
StublessClientProc( 862 )
StublessClientProc( 863 )
StublessClientProc( 864 )
StublessClientProc( 865 )
StublessClientProc( 866 )
StublessClientProc( 867 )
StublessClientProc( 868 )
StublessClientProc( 869 )
StublessClientProc( 870 )
StublessClientProc( 871 )
StublessClientProc( 872 )
StublessClientProc( 873 )
StublessClientProc( 874 )
StublessClientProc( 875 )
StublessClientProc( 876 )
StublessClientProc( 877 )
StublessClientProc( 878 )
StublessClientProc( 879 )
StublessClientProc( 880 )
StublessClientProc( 881 )
StublessClientProc( 882 )
StublessClientProc( 883 )
StublessClientProc( 884 )
StublessClientProc( 885 )
StublessClientProc( 886 )
StublessClientProc( 887 )
StublessClientProc( 888 )
StublessClientProc( 889 )
StublessClientProc( 890 )
StublessClientProc( 891 )
StublessClientProc( 892 )
StublessClientProc( 893 )
StublessClientProc( 894 )
StublessClientProc( 895 )
StublessClientProc( 896 )
StublessClientProc( 897 )
StublessClientProc( 898 )
StublessClientProc( 899 )
StublessClientProc( 900 )
StublessClientProc( 901 )
StublessClientProc( 902 )
StublessClientProc( 903 )
StublessClientProc( 904 )
StublessClientProc( 905 )
StublessClientProc( 906 )
StublessClientProc( 907 )
StublessClientProc( 908 )
StublessClientProc( 909 )
StublessClientProc( 910 )
StublessClientProc( 911 )
StublessClientProc( 912 )
StublessClientProc( 913 )
StublessClientProc( 914 )
StublessClientProc( 915 )
StublessClientProc( 916 )
StublessClientProc( 917 )
StublessClientProc( 918 )
StublessClientProc( 919 )
StublessClientProc( 920 )
StublessClientProc( 921 )
StublessClientProc( 922 )
StublessClientProc( 923 )
StublessClientProc( 924 )
StublessClientProc( 925 )
StublessClientProc( 926 )
StublessClientProc( 927 )
StublessClientProc( 928 )
StublessClientProc( 929 )
StublessClientProc( 930 )
StublessClientProc( 931 )
StublessClientProc( 932 )
StublessClientProc( 933 )
StublessClientProc( 934 )
StublessClientProc( 935 )
StublessClientProc( 936 )
StublessClientProc( 937 )
StublessClientProc( 938 )
StublessClientProc( 939 )
StublessClientProc( 940 )
StublessClientProc( 941 )
StublessClientProc( 942 )
StublessClientProc( 943 )
StublessClientProc( 944 )
StublessClientProc( 945 )
StublessClientProc( 946 )
StublessClientProc( 947 )
StublessClientProc( 948 )
StublessClientProc( 949 )
StublessClientProc( 950 )
StublessClientProc( 951 )
StublessClientProc( 952 )
StublessClientProc( 953 )
StublessClientProc( 954 )
StublessClientProc( 955 )
StublessClientProc( 956 )
StublessClientProc( 957 )
StublessClientProc( 958 )
StublessClientProc( 959 )
StublessClientProc( 960 )
StublessClientProc( 961 )
StublessClientProc( 962 )
StublessClientProc( 963 )
StublessClientProc( 964 )
StublessClientProc( 965 )
StublessClientProc( 966 )
StublessClientProc( 967 )
StublessClientProc( 968 )
StublessClientProc( 969 )
StublessClientProc( 970 )
StublessClientProc( 971 )
StublessClientProc( 972 )
StublessClientProc( 973 )
StublessClientProc( 974 )
StublessClientProc( 975 )
StublessClientProc( 976 )
StublessClientProc( 977 )
StublessClientProc( 978 )
StublessClientProc( 979 )
StublessClientProc( 980 )
StublessClientProc( 981 )
StublessClientProc( 982 )
StublessClientProc( 983 )
StublessClientProc( 984 )
StublessClientProc( 985 )
StublessClientProc( 986 )
StublessClientProc( 987 )
StublessClientProc( 988 )
StublessClientProc( 989 )
StublessClientProc( 990 )
StublessClientProc( 991 )
StublessClientProc( 992 )
StublessClientProc( 993 )
StublessClientProc( 994 )
StublessClientProc( 995 )
StublessClientProc( 996 )
StublessClientProc( 997 )
StublessClientProc( 998 )
StublessClientProc( 999 )
StublessClientProc( 1000 )
StublessClientProc( 1001 )
StublessClientProc( 1002 )
StublessClientProc( 1003 )
StublessClientProc( 1004 )
StublessClientProc( 1005 )
StublessClientProc( 1006 )
StublessClientProc( 1007 )
StublessClientProc( 1008 )
StublessClientProc( 1009 )
StublessClientProc( 1010 )
StublessClientProc( 1011 )
StublessClientProc( 1012 )
StublessClientProc( 1013 )
StublessClientProc( 1014 )
StublessClientProc( 1015 )
StublessClientProc( 1016 )
StublessClientProc( 1017 )
StublessClientProc( 1018 )
StublessClientProc( 1019 )
StublessClientProc( 1020 )
StublessClientProc( 1021 )
StublessClientProc( 1022 )
StublessClientProc( 1023 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\asyncu.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 2000 Microsoft Corporation

Module Name :

    asyncu.c

Abstract :

    This file contains the ndr async uuid implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Oct 1997

Revision History :

---------------------------------------------------------------------*/

#include "precomp.hxx"

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include "ndrole.h"
#include "rpcproxy.h"
#include "interp2.h"
#include "asyncu64.h"
#include "expr.h"
#include "ndrtypes.h"
#include "ndr64types.h"
#include <stddef.h>

#include <stdarg.h>

#pragma code_seg(".ndr64")

void
Ndr64pCloneInOnlyCorrArgs(
                       NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg,
                       PFORMAT_STRING           pFormatType
                       );

HRESULT
Ndr64pCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             );


CLIENT_CALL_RETURN RPC_VAR_ENTRY
Ndr64DcomAsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    ulong                       nProcNum,
    void                       *pReturnValue,
    ...
    )
{
    NDR_PROC_CONTEXT ProcContext;
    RPC_STATUS status;
    CLIENT_CALL_RETURN      Ret;
    va_list                 ArgList;
    unsigned char  *        StartofStack;

    INIT_ARG( ArgList, pReturnValue);
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *) GET_STACK_START(ArgList);

    Ndr64ClientInitializeContext( NdrpGetSyntaxType( pProxyInfo->pTransferSyntax),
                                   pProxyInfo,
                                   nProcNum,
                                  &ProcContext,
                                   StartofStack );

    NDR_ASSERT( ProcContext.IsAsync, "invalid async proc" );
    if ( nProcNum & 0x1 )
        status =  MulNdrpBeginDcomAsyncClientCall( pProxyInfo,
                                       nProcNum,
                                       &ProcContext,
                                       StartofStack );
    else
        status =  MulNdrpFinishDcomAsyncClientCall(pProxyInfo,
                                       nProcNum,
                                       &ProcContext,
                                       StartofStack );

    Ret.Simple = status;
   
    return Ret;

}



VOID
Ndr64pAsyncDCOMFreeParams(
                       PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg )
{
/*++

Routine Description:
    Frees the parameters for both the begin and finish calls.

Arguments:
    pAsyncMsg - Supplies a pointer to the async message.

Return Value:
    None.

--*/
   NDR64_PARAM_FLAGS   *   pParamFlags;

   if ( pAsyncMsg->BeginStack )
      {

      if ( pAsyncMsg->FinishStack )
         {

         // Clear out the IN OUT parameters on the begin stack
         // so that they are not freed twice.
         int n;
         REGISTER_TYPE       *pBeginStack      = (REGISTER_TYPE *)pAsyncMsg->BeginStack;
         NDR64_PARAM_FORMAT  *BeginParams       = (NDR64_PARAM_FORMAT*)pAsyncMsg->BeginParams;
         int                 BeginNumberParams = pAsyncMsg->nBeginParams ;

         for( n = 0; n < BeginNumberParams; n++ ) 
            {
            pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( BeginParams[n].Attributes );

            if ( pParamFlags->IsIn  &&
                 pParamFlags->IsOut )
               {

               pBeginStack[ BeginParams[ n ].StackOffset / sizeof(REGISTER_TYPE) ] = 0;
               
               }
                  
            }
         }

      pAsyncMsg->StubMsg.StackTop = pAsyncMsg->BeginStack;
      Ndr64pFreeParams( & (pAsyncMsg->StubMsg),
                       pAsyncMsg->nBeginParams,
                      ( NDR64_PARAM_FORMAT * ) pAsyncMsg->BeginParams,
                      pAsyncMsg->BeginStack );
      }

   if ( pAsyncMsg->FinishStack )
      {
      pAsyncMsg->StubMsg.StackTop = pAsyncMsg->FinishStack;
      Ndr64pFreeParams( & (pAsyncMsg->StubMsg),
                      pAsyncMsg->nFinishParams,
                      ( NDR64_PARAM_FORMAT * ) pAsyncMsg->FinishParams,
                      pAsyncMsg->FinishStack );
      }

}


HRESULT
MulNdrpBeginDcomAsyncClientCall(
                            MIDL_STUBLESS_PROXY_INFO    *     pProxyInfo,
                            ulong                             nProcNum,
                            NDR_PROC_CONTEXT *                pContext, 
                            void *                            StartofStack )
/*
    Notes: OLE Refcounting.
    The model for async_uuid() is that async proxies or stubs
    are created with RefCount==1 and should never ever be
    addrefed by the engine.
    What the engine does is only the AsyncMsg clean up when done.

    The decision to destroy the AsyncPB or AsyncSB object is
    up to the client side PM or channel's SM for the server side.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   uchar *                     pArg;
   void *                      pThis = *(void **)StartofStack;
   void *                      Params;
   long                        NumberParams;
   long                        n;

   RPC_STATUS                  Status;
   CStdAsyncProxyBuffer    *   pAsyncPB;
   const IID *                 piid;
   HRESULT                     hr = S_OK;
   BOOL                        fSendCalled = FALSE;

   pAsyncPB = (CStdAsyncProxyBuffer*)
              ((uchar*)pThis - offsetof(CStdProxyBuffer, pProxyVtbl));

   piid = NdrGetProxyIID( pThis );


   Status = MulNdrpSetupBeginClientCall( pAsyncPB,
                                      StartofStack,
                                      pContext,
                                      *piid );
   if ( !SUCCEEDED(Status) )
      return Status;

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE *)pAsyncPB->CallState.pAsyncMsg;

   // We need to switch to our copy of the stack everywhere, including pStubMsg.

   StartofStack = pAsyncMsg->ProcContext.StartofStack;

   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pStubMsg->pContext = &pAsyncMsg->ProcContext;
   pContext = &pAsyncMsg->ProcContext;
   

   NumberParams = pContext->NumberParams;

   // This is OLE only code path - use a single TryExcept.
   // After catching it just map it to OLE exception.

   RpcTryExcept
   {
      ulong  RpcFlags;
      PFORMAT_STRING              pFormat;

      pContext->RpcFlags |= RPC_BUFFER_ASYNC;
      Ndr64pClientSetupTransferSyntax(pThis, 
                           pRpcMsg,
                           pStubMsg,
                           pProxyInfo,
                           pContext,
                           nProcNum );

      pStubMsg->pAsyncMsg = (struct _NDR_ASYNC_MESSAGE *) pAsyncMsg;

   //
   // Parameter descriptions are nicely spit out by MIDL.
   //
      Params = (NDR64_PARAM_FORMAT *) ( pContext->Params );

      pFormat      = NdrpGetProcString( pContext->pSyntaxInfo,
                                        pContext->CurrentSyntaxType,
                                        nProcNum );

      pStubMsg->pContext       = pContext;

      pAsyncMsg->nBeginParams = NumberParams;
      pAsyncMsg->BeginParams  = (void *)Params;
      pAsyncMsg->pThis        = pThis;
      pAsyncMsg->SyntaxType   = pContext->CurrentSyntaxType;

      ( * pContext->pfnInit)(pStubMsg, 
                             NULL );        // return value
                             


      ( * pContext->pfnSizing) ( pStubMsg,
                                   TRUE );    // isclient
      //
      // Do the GetBuffer.
      //

      pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

      NdrProxyGetBuffer( pThis, pStubMsg );

      NDR_ASSERT( pStubMsg->fBufferValid, "Invalid buffer" );

      pAsyncMsg->StubPhase = STUB_MARSHAL;

      //
      // ----------------------------------------------------------
      // Marshall Pass.
      // ----------------------------------------------------------
      //

      ( * pContext->pfnMarshal ) ( pStubMsg,
                                TRUE ); // IsObject

      //
      // Make the RPC call.
      //

      pAsyncMsg->StubPhase = NDR_ASYNC_CALL_PHASE;

      fSendCalled = NdrpDcomAsyncClientSend( pStubMsg,
                                             pAsyncPB->punkOuter );  // PM's entry
      if ( fSendCalled )
         hr = S_OK;
   }
   RpcExcept( 1 )
   {
      RPC_STATUS ExceptionCode = RpcExceptionCode();

      pAsyncPB->CallState.Flags.BeginError = 1;

      // Actually dismantle the call.
      // This is a request call and there is nothing left at the runtime.

      pAsyncMsg->StubPhase = NDR_ASYNC_ERROR_PHASE;
      pAsyncMsg->ErrorCode = ExceptionCode;

      hr = NdrHrFromWin32Error(ExceptionCode);
      pAsyncPB->CallState.Hr = hr;

      // Async call in request phase: don't touch [out] params.
   }
   RpcEndExcept

   // "Finally"
   // Dont touch anything, the client has to call the Finish method anyway.

   pAsyncPB->CallState.Flags.BeginDone = 1;
   if ( SUCCEEDED(hr) )
      {
      if ( pContext->CurrentSyntaxType == XFER_SYNTAX_DCE )
          NdrpCloneInOnlyCorrArgs( pAsyncMsg,
                                   pContext->pSyntaxInfo->TypeString );
      else
          Ndr64pCloneInOnlyCorrArgs( pAsyncMsg,
                                     pContext->pSyntaxInfo->TypeString );
      // Channel will prompt signal
      }
   else
      if (!fSendCalled )
      NdrpAsyncProxySignal( pAsyncPB );

   // No need to release, our refcount should be 1 at this point.

   return hr;
}


void
Ndr64pCloneInOnlyCorrArgs(
                       NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg,
                       PFORMAT_STRING             pFormatTypes
                       )
/*
    Walk the client stack looking for an in only argument flagged to clone.
    For each one, replace the arg with a clone that we control.
    Assumption is, we do it before returning to the user from the Begin call
    and also we clone walking the copy of the app's stack not the app stack.

    The stack modified in this way will be the one to access for the weird
    crossreferenced correlated args.

    This issue doesn't happen on the server, as we keep the Begin stack around
    when the Finish call is processed.

*/
{
   unsigned char        *  pBeginStack  = pAsyncMsg->BeginStack;
   NDR64_PARAM_FORMAT   *  Params       = ( NDR64_PARAM_FORMAT *)pAsyncMsg->BeginParams;
   NDR64_PARAM_FLAGS    *  pParamFlags;
   
   int                 NumberParams = pAsyncMsg->nBeginParams;
   unsigned char  *    pArg;
   int                 n;

   for ( n = 0; n < NumberParams; n++ )
      {
      pParamFlags = ( NDR64_PARAM_FLAGS * ) & Params[n].Attributes ;
      
      if ( pParamFlags->SaveForAsyncFinish )
         {
         // Note that the arguments that need cloning come from top level size_is,
         // length_is etc, switch_is and iid_is attributes.
         // Hence, the only types of interest are uuid clones and integral types
         // different from hyper.
         // On top of it, we deal with stack-slot chunks of memory, so we don't
         // have to care about mac issues.

         pArg = pBeginStack + Params[n].StackOffset;

         if ( pParamFlags->IsBasetype )
            {
            if ( pParamFlags->IsSimpleRef )
               {
               void * pPointee = AsyncAlloca( pAsyncMsg, 8 );
               NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

               // The assignment needs to follow the type.
               RpcpMemoryCopy( pPointee, *(void **)pArg, 
                               NDR64_SIMPLE_TYPE_MEMSIZE( type ) );  
               *(void**)pArg = pPointee;
               }
            // else the stack slot has the simple value already.
            }
         else
            {
            // If it's not a base type, then it cannot be by value.
            // It has to be a pointer to a simple type or to an iid.

            PFORMAT_STRING  pParamFormat;
            const NDR64_POINTER_FORMAT *pPointerFormat ;
            PFORMAT_STRING pPointeeFormat; 

            pParamFormat = (PFORMAT_STRING)Params[n].Type;

            pPointerFormat = (const NDR64_POINTER_FORMAT*)pParamFormat;
            pPointeeFormat = (PFORMAT_STRING)pPointerFormat->Pointee;
            if ( NDR64_IS_BASIC_POINTER(*pParamFormat) )  // not FC64_IP
               {
               if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
                  {
                  // Covers things like a unique pointer to a size
                  // Essentially the same as for the simple ref above.

                  void * pPointee = AsyncAlloca( pAsyncMsg, 8 );
                  NDR64_FORMAT_CHAR type = *pPointeeFormat;

                  // The assignment needs to follow the type.
                  RpcpMemoryCopy( pPointee, *(void **)pArg, 
                                  NDR64_SIMPLE_TYPE_MEMSIZE( type ) );
                  *(void**)pArg = pPointee;
                  }
               else
                  {
                  // has to be the riid case.
                  // REFIID* comes out as FC64_?P -> FC64_?P -> FC64_STRUCT


                  if ( NDR64_IS_BASIC_POINTER(*pPointeeFormat)  &&
                       ! NDR64_SIMPLE_POINTER( pPointerFormat->Flags) )
                     {

                     if ( *pPointeeFormat == FC64_STRUCT )
                        {
                        // one alloc for REFIID and IID itself.
                        IID** ppIID = (IID**)AsyncAlloca( pAsyncMsg,
                                                          sizeof(IID *) + sizeof(IID));
                        IID* pIID = (IID *)(ppIID + 1);


                        *ppIID = pIID; //set pointer
                        RpcpMemoryCopy( pIID, **(IID ***)pArg, sizeof(IID));
                        *(IID ***)pArg = ppIID;
                        }
                     else
                        RpcRaiseException( RPC_S_INTERNAL_ERROR );
                     }
                  else
                     RpcRaiseException( RPC_S_INTERNAL_ERROR );
                  }
               }
            else
               {
               // has to be the riid case.
               // REFIID comes out as FC64_STRUCT

               if ( *pParamFormat == FC64_STRUCT )
                  {
                  IID *pIID = (IID*)AsyncAlloca( pAsyncMsg, sizeof(IID) );

                  RpcpMemoryCopy( pIID, *(IID **)pArg, sizeof(IID));
                  *(IID **)pArg = pIID;
                  }
               else
                  RpcRaiseException( RPC_S_INTERNAL_ERROR );
               }

            }

         }
      }
}


HRESULT
MulNdrpFinishDcomAsyncClientCall(
                            MIDL_STUBLESS_PROXY_INFO    *     pProxyInfo,
                            ulong                             nProcNum,
                            NDR_PROC_CONTEXT *                pContext ,
                            void *                            StartofStack )
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;


   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   uchar *                     pArg;
   void *                      pThis = *(void **)StartofStack;
   CLIENT_CALL_RETURN          ReturnValue;

   NDR64_PARAM_FORMAT      *   Params;
   long                        NumberParams;
   long                        n;
   NDR_ASYNC_CALL_FLAGS        CallFlags;

   CStdAsyncProxyBuffer    *   pAsyncPB;
   const IID *                 piid;
   HRESULT                     hr = S_OK;
   NDR64_PARAM_FLAGS *         pParamFlags;
   
   ReturnValue.Simple = 0;

                                              
   pAsyncPB = (CStdAsyncProxyBuffer*)
              ((uchar*)pThis - offsetof(CStdProxyBuffer, pProxyVtbl));

   piid = NdrGetProxyIID( pThis );
                                 
   hr = MulNdrpSetupFinishClientCall( pAsyncPB,
                                   StartofStack,
                                   *piid,
                                   nProcNum,
                                   pContext );
   if ( !SUCCEEDED(hr) )
      return hr;

   // Note that we cant call to Ndr64ProxyInitialize again.

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)pAsyncPB->CallState.pAsyncMsg;

   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;

   // begin method negotiate to a different syntax than default
   if ( pContext->CurrentSyntaxType != pAsyncMsg->SyntaxType )
        {        
        PFORMAT_STRING pFormat;
        pContext->CurrentSyntaxType = pAsyncMsg->SyntaxType;
        pContext->pSyntaxInfo = pAsyncMsg->ProcContext.pSyntaxInfo;
        pFormat = NdrpGetProcString( pContext->pSyntaxInfo,
                                     pContext->CurrentSyntaxType,
                                     nProcNum );

        MulNdrpInitializeContextFromProc(  pContext->CurrentSyntaxType, 
                                           pFormat, 
                                           pContext, 
                                           (uchar *)StartofStack );        
        }
   
   
   // we can directly call to ndr20 finish routine because there is extra setup cost.
   if ( pContext->CurrentSyntaxType == XFER_SYNTAX_DCE )
       return NdrpFinishDcomAsyncClientCall( pProxyInfo->pStubDesc, 
                                              pContext->pProcFormat,
                                              (uchar*)StartofStack );

   memcpy ( & pAsyncMsg->ProcContext, pContext, offsetof( NDR_PROC_CONTEXT, AllocateContext ) );
  
   NumberParams = pContext->NumberParams;

   CallFlags = pAsyncMsg->Flags;

   // Initialize the stack top in the stub msg to be
   // this stack, the stack for the finish call parameters.
   pAsyncMsg->nFinishParams = NumberParams;
   pAsyncMsg->FinishParams = pContext->Params;
   Params = (NDR64_PARAM_FORMAT *) pContext->Params;
   pStubMsg->StackTop = (uchar*)StartofStack;
   pStubMsg->pContext = &pAsyncMsg->ProcContext;

   // OLE only code path - single RpcTryExcept.
   //
   RpcTryExcept
   {
      BOOL fRaiseExcFlag = FALSE;

      if ( CallFlags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // We need to zero out the [out] parameters and to check
      // the ref pointers.

      for ( n = 0; n < NumberParams; n++ )
         {
         pParamFlags = ( NDR64_PARAM_FLAGS * ) & Params[n].Attributes ;
         
         pArg = (uchar *)StartofStack + Params[n].StackOffset;

         if ( pParamFlags->IsSimpleRef )
            {
            // We cannot raise the exception here,
            // as some out args may not be zeroed out yet.

            if ( ! *((uchar **)pArg) )
               {
               fRaiseExcFlag = TRUE;
               continue;
               }
            }

         // We do the basetype check to cover the
         // [out] simple ref to basetype case.
         //
         if ( pParamFlags->IsPartialIgnore ||
              ( ! pParamFlags->IsIn &&
                ! pParamFlags->IsReturn ))
            {
            if ( pParamFlags->IsBasetype )
               {
               // [out] only arg can only be ref, we checked that above.

               NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

               MIDL_memset( *(uchar **)pArg, 
                            0, 
                            (size_t)NDR64_SIMPLE_TYPE_MEMSIZE( type ));
               }
            else
               {
               Ndr64ClientZeroOut(
                               pStubMsg,
                               Params[n].Type,
                               *(uchar **)pArg );
               }
            }
         }

      if ( fRaiseExcFlag )
         RpcRaiseException( RPC_X_NULL_REF_POINTER );


      NdrDcomAsyncReceive( pStubMsg );

      Ndr64pClientUnMarshal( pStubMsg,
                        &ReturnValue );
      

      // Pass the HR from the Finish call, if there was any, to the client.
      if ( pArg == (uchar *) &ReturnValue )
         hr = (HRESULT) ReturnValue.Simple;
   }
   RpcExcept( 1 )
   {
      RPC_STATUS ExceptionCode = RpcExceptionCode();

      //
      // In OLE, since they don't know about error_status_t and wanted to
      // reinvent the wheel, check to see if we need to map the exception.
      // In either case, set the return value and then try to free the
      // [out] params, if required.
      //
      hr = NdrHrFromWin32Error(ExceptionCode);

      //
      // Set the Buffer endpoints so the Ndr64Free routines work.
      //

      Ndr64pDcomClientExceptionHandling ( pStubMsg,
                                          nProcNum,
                                          hr,
                                          &ReturnValue );
                                                    
   }
   RpcEndExcept

   // Finish
   // Cleanup everything. However, don't free pAsyncPB itself.

   NdrpAsyncProxyMsgDestructor( pAsyncPB );

   //  Never addref or release async proxy object, this is app's/PM's job.

   return hr;
}


HRESULT RPC_ENTRY
Ndr64DcomAsyncStubCall(
                    struct IRpcStubBuffer *     pThis,
                    struct IRpcChannelBuffer *  pChannel,
                    PRPC_MESSAGE                pRpcMsg,
                    ulong *                     pdwStubPhase
                    )
/*++

Routine Description :

    Server Interpreter entry point for DCOM async procs.
    This is the Begin entry for channel (regular dispatch entry from stub.c).
    The Finish happen when the channel calls stub's Synchronize::Signal method
    on the stub object. The call then comes to NdrpAsyncStubSignal later below.

Arguments :

    pThis           - Object proc's 'this' pointer.
    pChannel        - Object proc's Channel Buffer.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

Notes :
    The engine never calls a signal on behalf of the user, regardless what kind of
    errors happen during begin (cannot setup begin, cannot unmarshal, app dies in invoke).
    In each of these cases, the engine simply returns an error code to the channel.

    The only time the engine would call FreeBuffer on the server is if the engine died
    between a successful GetBuffer and the final Send.

Notes on OLE Refcounting.
    The model for async_uuid() is that async proxies or stubs are created
    with RefCount==1 and should never ever be addrefed by the engine.
    What the engine does is only the AsyncMsg clean up when done.

    The decision to destroy the AsyncPB or AsyncSB object is
    up to the client side PM or channel's SM for the server side.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   PMIDL_SERVER_INFO           pServerInfo;
   PMIDL_STUB_DESC             pStubDesc;
   const SERVER_ROUTINE  *     DispatchTable;
   unsigned long               ProcNum;

   ushort                      FormatOffset;
   PFORMAT_STRING              pFormat;

   PMIDL_STUB_MESSAGE          pStubMsg;

   uchar *                     pArgBuffer;
   uchar *                     pArg;
   uchar **                    ppArg;

   NDR64_PARAM_FORMAT  *       Params;

   BOOL                        fBadStubDataException = FALSE;
   BOOL                        fManagerCodeInvoked = FALSE;
   unsigned long               n, i;

   CStdAsyncStubBuffer *       pAsyncSB;

   HRESULT                     hr;

   const IID *                 piid = 0;
   BOOL                        fErrorInInvoke = FALSE;
   BOOL                        fRecoverableErrorInInvoke = FALSE;

   IUnknown *                  pSrvObj;
   CInterfaceStubVtbl *        pStubVTable;
   NDR_PROC_CONTEXT            ProcContext, *pContext;
   NDR64_PROC_FORMAT    *      pProcFormat;
   NDR64_PROC_FLAGS    *       pNdr64Flags;
   NDR64_PARAM_FLAGS   *       pParamFlags;
   SYNTAX_TYPE                 SyntaxType;
   RPC_STATUS                  ExceptionCode = 0;
   MIDL_SYNTAX_INFO *          pSyntaxInfo = NULL;
   

   NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
               "marshaling buffer misaligned at server" );

   // The channel dispatches to the engine with the sync proc num.
   // We need only async proc num at the engine level.
   ProcNum = pRpcMsg->ProcNum;
   ProcNum = 2 * ProcNum - 3;  // Begin method #

   pSrvObj = (IUnknown *)((CStdStubBuffer *)pThis)->pvServerObject;
   DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

   pStubVTable = (CInterfaceStubVtbl *)
                 (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

   piid        = pStubVTable->header.piid;
   pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

    SyntaxType = NdrpGetSyntaxType( pRpcMsg->TransferSyntax );

    if ( SyntaxType == XFER_SYNTAX_DCE )
        return NdrDcomAsyncStubCall( pThis, pChannel, pRpcMsg, pdwStubPhase );
  
   pStubDesc    = pServerInfo->pStubDesc;
   pAsyncSB = (CStdAsyncStubBuffer *)
              ((uchar *)pThis - offsetof(CStdAsyncStubBuffer,lpVtbl));

   for ( i = 0; i < (ulong)pServerInfo->nCount; i++ )
       {
       if ( SyntaxType == NdrpGetSyntaxType( &pServerInfo->pSyntaxInfo[i].TransferSyntax ) )
           {
           pSyntaxInfo = &pServerInfo->pSyntaxInfo[i];
           break;
           }
       }

   if ( NULL == pSyntaxInfo )
        return HRESULT_FROM_WIN32( RPC_S_UNSUPPORTED_TRANS_SYN );

   NdrServerSetupNDR64TransferSyntax( ProcNum, pSyntaxInfo, &ProcContext);

   pProcFormat = ProcContext.Ndr64Header;
   pNdr64Flags = (NDR64_PROC_FLAGS *)&pProcFormat->Flags;
        
   hr = NdrpValidateAsyncStubCall( pAsyncSB );
   if ( ! SUCCEEDED(hr) )
      return hr;
      
   hr = Ndr64pSetupBeginStubCall( pAsyncSB, &ProcContext, *piid );
   if ( FAILED(hr) )
      return hr;

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)pAsyncSB->CallState.pAsyncMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;


   // Both rpc runtime and channel require that we use a copy of the rpc message.

   RpcpMemoryCopy( & pAsyncMsg->RpcMsg, pRpcMsg, sizeof(RPC_MESSAGE) );
   pRpcMsg = & pAsyncMsg->RpcMsg;

   pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

   pStubMsg->RpcMsg = pRpcMsg;
   pContext = &pAsyncMsg->ProcContext;

   // The arg buffer is zeroed out already.
   pArgBuffer = pAsyncMsg->ProcContext.StartofStack;

   //
   // Get new interpreter info.
   //
   Params = (NDR64_PARAM_FORMAT *) pContext->Params;

   pAsyncMsg->nBeginParams     = pContext->NumberParams;
   pAsyncMsg->BeginParams      = pContext->Params;
   pAsyncMsg->pThis            = pThis;
   pAsyncMsg->SyntaxType       = pContext->CurrentSyntaxType;

   //
   // Wrap the unmarshalling and the invoke call in the try block of
   // a try-finally. Put the free phase in the associated finally block.
   //
   // We abstract the level of indirection here.

   RpcTryFinally
   {
      // OLE: put pThis in first dword of stack.
      //
      ((void **)pArgBuffer)[0] = ((CStdStubBuffer *)pThis)->pvServerObject;

      // Initialize the Stub message.
      //
      NdrStubInitialize( pRpcMsg,
                         pStubMsg,
                         pStubDesc,
                         pChannel );

      pStubMsg->pAsyncMsg     = (struct _NDR_ASYNC_MESSAGE *) pAsyncMsg;
      pStubMsg->pContext       = pContext;

      pAsyncMsg->BeginParams  = Params;
      pAsyncMsg->pdwStubPhase = pdwStubPhase;    // the phase is STUB_UNMARSHAL

      // Raise exceptions after initializing the stub.

      if ( pNdr64Flags->UsesFullPtrPackage )
         pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );
      else
         pStubMsg->FullPtrXlatTables = 0;

      //
      // Set StackTop AFTER the initialize call, since it zeros the field
      // out.
      //
      pStubMsg->StackTop  = pArgBuffer;

      // StubPhase set up by invoke is STUB_UNMARSHAL

      RpcTryExcept
      {
         NDR_ASSERT( pContext->StartofStack == pArgBuffer, "startofstack is not set" );

         Ndr64pServerUnMarshal ( pStubMsg  );  



      // Last ditch checks.

      if ( pRpcMsg->BufferLength  <
           (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
         {
         RpcRaiseException( RPC_X_BAD_STUB_DATA );
         }

      }
      RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
      {
         // Filter set in rpcndr.h to catch one of the following
         //     STATUS_ACCESS_VIOLATION
         //     STATUS_DATATYPE_MISALIGNMENT
         //     RPC_X_BAD_STUB_DATA

         ExceptionCode = RpcExceptionCode();
         fBadStubDataException = TRUE;

         if ( RPC_BAD_STUB_DATA_EXCEPTION_FILTER ) 
            ExceptionCode = RPC_X_BAD_STUB_DATA;
            
         pAsyncMsg->Flags.ErrorPending = 1;
         pAsyncMsg->Flags.BadStubData = 1;
         pAsyncMsg->ErrorCode = ExceptionCode;

         pAsyncSB->CallState.Flags.BeginError = 1;
         pAsyncSB->CallState.Hr = NdrHrFromWin32Error( ExceptionCode);
         NdrpFreeMemoryList( pStubMsg );

         RpcRaiseException( ExceptionCode );

      }
      RpcEndExcept

      //
      // Do [out] initialization before the invoke.
      //
      for ( n = 0; n < pContext->NumberParams; n++ )
         {
         pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
         
         if ( pParamFlags->IsIn     ||
              pParamFlags->IsReturn )
            continue;

         // This is a Begin call, there cannot be any [out] only args.

         RpcRaiseException( RPC_S_INTERNAL_ERROR );
         }


      //
      // OLE interfaces use pdwStubPhase in the exception filter.
      // See CStdStubBuffer_Invoke in stub.c.
      //
      *pdwStubPhase = STUB_CALL_SERVER;

      // We need to catch exception in the manager code separately
      // as the model implies that there will be no other call from
      // the server app to clean up.

      pAsyncSB->CallState.Flags.BeginDone = 1;

      RpcTryExcept
      {
         //
         // Check for a thunk.  Compiler does all the setup for us.
         //
         if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ ProcNum ] )
            {
            fManagerCodeInvoked = TRUE;
            pServerInfo->ThunkTable[ ProcNum ]( pStubMsg );
            }
         else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       ReturnValue;

            pFunc  = (MANAGER_FUNCTION) DispatchTable[ ProcNum ];
            ArgNum = (long)pProcFormat->StackSize  / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && pNdr64Flags->HasReturn )
               ArgNum--;

            // Being here means that we can expect results. Note that the user
            // can call RpcCompleteCall from inside of the manager code.

            fManagerCodeInvoked = TRUE;
            ReturnValue = Invoke( pFunc,
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_WIN64)
                                  pProcFormat->FloatDoubleMask,
#endif
                                  ArgNum);

            if ( pNdr64Flags->HasReturn )
               {
               // Pass the app's HR from Begin call to the channel.
               (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                            NULL,   // reserved
                                            (HRESULT) ReturnValue);
               }

            // We are discarding the return value as it is not the real one.
            }
      }
      RpcExcept( 1 )
      {
         fErrorInInvoke = TRUE;

         pAsyncMsg->Flags.ErrorPending = 1;
         pAsyncMsg->ErrorCode = RpcExceptionCode();

         pAsyncSB->CallState.Flags.BeginError = 1;
         pAsyncSB->CallState.Hr = NdrHrFromWin32Error( RpcExceptionCode());
      }
      RpcEndExcept

      //  Done with invoking Begin
   }
   RpcFinally
   {
      if ( !fManagerCodeInvoked )
         {
         // Failed without invoking Begin - return an error. Remember the error.

         if ( fBadStubDataException )
            pAsyncMsg->ErrorCode = RPC_X_BAD_STUB_DATA;

         pAsyncSB->CallState.Flags.BeginDone = 1;
         hr = pAsyncSB->CallState.Hr;
         }
      else // fManagerCodeInvoked
         {
         hr = S_OK;

         if ( fErrorInInvoke )
            hr = pAsyncSB->CallState.Hr;
         }
   }
   RpcEndFinally

   return hr;
}




void
Ndr64pCloneInOutStubArgs(
                      NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg )
/*
    Walk the second stack looking for an in-out argument.
    For each one, find the corresponding in-out atgument from the first stack
    and clone it to the second stack.

    Note, we need to do it only on the server side where we preserver the first
    stack, the dispatch buffer and all the arguments from the first stack. 

    On the client, this is the app's task to supply meaningful in-out arguments
    for the second stack.
*/
{
   REGISTER_TYPE *   pBeginStack  = (REGISTER_TYPE *)pAsyncMsg->BeginStack;
   REGISTER_TYPE *   pFinishStack = (REGISTER_TYPE *)pAsyncMsg->FinishStack;

   NDR64_PARAM_FORMAT * BeginParams       =  ( NDR64_PARAM_FORMAT *) pAsyncMsg->BeginParams;
   int                  BeginNumberParams =  pAsyncMsg->nBeginParams;
   NDR64_PARAM_FLAGS  * pParamFlags, * pBeginParamFlags;

   NDR64_PARAM_FORMAT * FinishParams       = ( NDR64_PARAM_FORMAT *) pAsyncMsg->FinishParams;
   int                  FinishNumberParams =  pAsyncMsg->nFinishParams;

   int FirstIO = 0;
   int n;

   for ( n = 0; n < FinishNumberParams; n++ )
      {
      pParamFlags = ( NDR64_PARAM_FLAGS *) & FinishParams[n].Attributes;
      // Find in-out arg that needs cloning.

      if ( pParamFlags->IsIn  &&
           pParamFlags->IsOut )
         {
         // Find the first IO on the first stack

         while ( FirstIO < BeginNumberParams )
            {
            pBeginParamFlags = ( NDR64_PARAM_FLAGS *) & BeginParams[FirstIO].Attributes;
            if ( pBeginParamFlags->IsIn  &&
                 pBeginParamFlags->IsOut )
               {
               break;
               }

            FirstIO++;
            }

         if ( BeginNumberParams <= FirstIO )
            RpcRaiseException( RPC_S_INTERNAL_ERROR );

         // Clone it to the second stack

         pFinishStack[ FinishParams[n].StackOffset / sizeof(REGISTER_TYPE) ] =
         pBeginStack[ BeginParams[ FirstIO ].StackOffset / sizeof(REGISTER_TYPE) ];
         FirstIO++;
         }
      }
}


HRESULT
Ndr64pCompleteDcomAsyncStubCall(
                             CStdAsyncStubBuffer *   pAsyncSB
                             )
/*++

Routine Description :

    Complete an async call on the server side.

Arguments :

    AsyncHandle  - raw or object handle (if pointer) as appropriate,
    pAsyncMsg    - pointer to async msg structure,
    pReturnValue - from the user to pass back to caller.

Return :

    Status of S_OK.

--*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;

   PMIDL_SERVER_INFO           pServerInfo;
   const SERVER_ROUTINE  *     DispatchTable;  // should be the same
   unsigned long               ProcNum;        // should be 1+

   RPC_MESSAGE *               pRpcMsg;
   MIDL_STUB_MESSAGE *         pStubMsg;

   NDR64_PARAM_FORMAT *        Params;         // Finish params
   uchar *                     pArgBuffer;     // new stack
   
   // MZ, BUG BUG, Fix after ship
   // ulong *                     pdwStubPhase;
 
   uchar *                     pArg;

   long                        NumberParams;
   long                        n;
   NDR64_PROC_FORMAT   *       pProcHeader;

   IUnknown *                  pSrvObj;
   CInterfaceStubVtbl *        pStubVTable;
   void *                      pThis;

   HRESULT                     hr;
   const IID *                 piid;           // should be the same

   BOOL                        fManagerCodeInvoked = FALSE;
   BOOL                        fErrorInInvoke = FALSE;
   RPC_STATUS                  ExceptionCode = 0;
   boolean                     fParamsFreed = FALSE;
   NDR64_PARAM_FLAGS *         pParamFlags;
   NDR64_PROC_FLAGS    *       pNdr64Flags;
   NDR_PROC_CONTEXT *          pContext = NULL;
   
   // We validated both the stub and the async context in the signal call.

   // We validated the pAsyncSB in the Signal call.
   // Do additional checks.

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)pAsyncSB->CallState.pAsyncMsg;
   pThis     = pAsyncMsg->pThis;

   // See if channel calls on the right stub
   if ( & pAsyncSB->lpVtbl != pThis)
      return E_INVALIDARG;


   pRpcMsg   = & pAsyncMsg->RpcMsg;
   pStubMsg  = & pAsyncMsg->StubMsg;
   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext ;
   // We have preserved the sync proc num that the channel used.
   // We need only async proc num at the engine level.
   //

   ProcNum = pRpcMsg->ProcNum;
   ProcNum = 2 * ProcNum - 3 + 1;  // Finish method #

   pSrvObj = (IUnknown *)((CStdStubBuffer *)pThis)->pvServerObject;
   DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

   pStubVTable = (CInterfaceStubVtbl *)
                 (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

   piid        = pStubVTable->header.piid;
   pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

   // The proc header has a fixed layout now.

   pProcHeader = 
       (PNDR64_PROC_FORMAT)NdrpGetProcString( pAsyncMsg->ProcContext.pSyntaxInfo,
                                              XFER_SYNTAX_NDR64,
                                              ProcNum );
   pNdr64Flags = ( NDR64_PROC_FLAGS * )&pProcHeader->Flags;

   // Validate and setup for finish.

   hr = NdrpSetupFinishStubCall( pAsyncSB,
                                 (ushort )pProcHeader->StackSize,
                                 *piid );
   if ( hr )
      return hr;

   // The arg buffer is zeroed out already. Note, this is the second stack.

   pArgBuffer = pAsyncMsg->ProcContext.StartofStack;
   pStubMsg->StackTop = pArgBuffer;
   
   // MZ, BUG BUG, fix after ship
   // pdwStubPhase = pAsyncMsg->pdwStubPhase;
   
   //
   // Get new interpreter info.
   //
   NumberParams = pProcHeader->NumberOfParams;

   Params = (NDR64_PARAM_FORMAT *)(((PFORMAT_STRING)( pProcHeader + 1 )) + pProcHeader->ExtensionSize );


   pAsyncMsg->nFinishParams = pContext->NumberParams = NumberParams;
   pAsyncMsg->FinishParams = pContext->Params = Params;

   // Wrap the unmarshalling, mgr call and marshalling in the try block of
   // a try-finally. Put the free phase in the associated finally block.
   //
   RpcTryFinally
   {
      if ( pAsyncMsg->Flags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // Initialize the args of the new stack.

      // OLE: put pThis in first dword of stack.
      //
      ((void **)pArgBuffer)[0] = ((CStdStubBuffer *)pThis)->pvServerObject;

      //
      // Do [out] initialization before invoking Finish
      //

      Ndr64pCloneInOutStubArgs( pAsyncMsg );
      Ndr64pServerOutInit( pStubMsg );


      //
      // OLE interfaces use pdwStubPhase in the exception filter.
      // See CStdStubBuffer_Invoke in stub.c.
      //

      // MZ, BUG BUG, fix after ship
      // *pdwStubPhase = STUB_CALL_SERVER;

      // We need to catch exception in the manager code separately
      // as the model implies that there will be no other call from
      // the server app to clean up.

      RpcTryExcept
      {
         //
         // Check for a thunk.  Compiler does all the setup for us.
         //
         if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            fManagerCodeInvoked = TRUE;
            pServerInfo->ThunkTable[ProcNum]( pStubMsg );
            }
         else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE       ReturnValue;

            pFunc  = (MANAGER_FUNCTION) DispatchTable[ProcNum];
            ArgNum = (long)pProcHeader->StackSize / sizeof(REGISTER_TYPE);

            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && pNdr64Flags->HasReturn )
               ArgNum--;

            fManagerCodeInvoked = TRUE;
            ReturnValue = Invoke( pFunc,
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_WIN64)
                                  pProcHeader->FloatDoubleMask,
#endif
                                  ArgNum);

            // This is the return value that should be marshaled back.
            if ( pNdr64Flags->HasReturn )
               {
               ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = ReturnValue;
               // Pass the app's HR to the channel.
               (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                            NULL,   // reserved
                                            (HRESULT) ReturnValue);
               }
            }
      }
      RpcExcept( 1 )
      {
         pAsyncMsg->Flags.ErrorPending = 1;

         pAsyncMsg->ErrorCode = RpcExceptionCode();
         fErrorInInvoke = TRUE;
      }
      RpcEndExcept

      //  Done with invoking Finish

      if ( pAsyncMsg->Flags.ErrorPending )
         RpcRaiseException( pAsyncMsg->ErrorCode );

      // MZ, BUG BUG, fix after ship
      // *pdwStubPhase = STUB_MARSHAL;

      //
      // Buffer size pass.
      //
      pStubMsg->BufferLength = pProcHeader->ConstantServerBufferSize;

      if ( pNdr64Flags->ServerMustSize )
         {
         Ndr64pSizing( pStubMsg,
                       FALSE );  //server
         }

      // Get buffer.

      NdrStubGetBuffer( (IRpcStubBuffer *)pAsyncMsg->pThis,
                        pStubMsg->pRpcChannelBuffer,
                        pStubMsg );

      // Marshalling pass.
      Ndr64pServerMarshal ( pStubMsg );

      if ( pRpcMsg->BufferLength <
           (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
         {
         NDR_ASSERT( 0, "Ndr64StubCall2 marshal: buffer overflow!" );
         RpcRaiseException( RPC_X_BAD_STUB_DATA );
         }

      pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

      // We don't drop to the runtime like for synchronous calls,
      // we send the last buffer explicitly.

      fParamsFreed = TRUE;
      // see comment on async.cxx on why we call this twice.

      Ndr64pAsyncDCOMFreeParams( pAsyncMsg );

      NdrpDcomAsyncSend( pStubMsg,
                         0 );  // server doesn't pass pSynchronize back to channel.
   }
   RpcFinally
   {
      // Don't free parameters if we died because of bad stub data in unmarshaling.

      if ( ! pAsyncMsg->Flags.BadStubData && !fParamsFreed)
         {

         Ndr64pAsyncDCOMFreeParams( pAsyncMsg );

         }

      if ( pAsyncMsg->Flags.ErrorPending )
         hr = NdrHrFromWin32Error( pAsyncMsg->ErrorCode );
      else
         hr = S_OK;

      // If we are here, error or not, it means that we can (and need to) dispose of
      // the async context information

      NdrpAsyncStubMsgDestructor( pAsyncSB );

      // The engine never addrefs or releases the call object.
   }
   RpcEndFinally

   return hr;
}

HRESULT
Ndr64pSetupBeginStubCall(
                      CStdAsyncStubBuffer *   pAsyncSB,
                      NDR_PROC_CONTEXT *      pContext,
                      REFIID                  riid )
/*
    This method creates and initializes async msg.

*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;
   HRESULT                     hr = S_OK;


   if ( pAsyncSB->CallState.pAsyncMsg != 0  ||
        pAsyncSB->CallState.Flags.BeginStarted )
      hr = E_FAIL;
   else
      {
      pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)
                  I_RpcBCacheAllocate( sizeof( NDR_DCOM_ASYNC_MESSAGE) +
                                       pContext->StackSize + NDR_ASYNC_GUARD_SIZE );
      if ( ! pAsyncMsg )
         hr = E_OUTOFMEMORY;
      }

   if ( ! SUCCEEDED(hr) )
      {
      // The stub never signals.

      pAsyncSB->CallState.Flags.BeginError = 1;
      pAsyncSB->CallState.Hr = hr;
      return hr;
      }

   // Initialize the async message properly

   MIDL_memset( pAsyncMsg, 0x0, sizeof( NDR_DCOM_ASYNC_MESSAGE) );

   pAsyncMsg->Signature = NDR_DCOM_ASYNC_SIGNATURE;
   pAsyncMsg->Version   = NDR_DCOM_ASYNC_VERSION;
   pAsyncMsg->SyntaxType = XFER_SYNTAX_NDR64;

   memcpy( &pAsyncMsg->ProcContext, pContext, offsetof( NDR_PROC_CONTEXT, AllocateContext ) );
   NdrpAllocaInit( &pAsyncMsg->ProcContext.AllocateContext );

   
   pAsyncMsg->ProcContext.StartofStack = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStack   = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStackSize = pContext->StackSize;
   pAsyncMsg->StubPhase    = STUB_UNMARSHAL;
   pAsyncMsg->StubMsg.pContext  = &pAsyncMsg->ProcContext;

   // Server: zero out stack for allocs.
   MIDL_memset( & pAsyncMsg->AppStack, 0x0, pContext->StackSize );

   MIDL_memset( ((char *)& pAsyncMsg->AppStack) + pContext->StackSize,
                0x71,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncSB->CallState.pAsyncMsg = pAsyncMsg;
   pAsyncSB->CallState.Flags.BeginStarted = 1;
   pAsyncMsg->pAsyncSB = pAsyncSB;

   return S_OK;
}

HRESULT
MulNdrpSetupFinishClientCall(
                         CStdAsyncProxyBuffer *  pAsyncPB,
                         void *                  StartofStack,
                         REFIID                  riid,
                         unsigned long           FinishProcNum,
                         NDR_PROC_CONTEXT    *   pContext )
/*
    This method creates and initializes async msg.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE  pAsyncMsg;
   HRESULT                  hr = S_OK;

   hr = NdrpValidateAsyncProxyCall( pAsyncPB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( !pAsyncPB->CallState.Flags.BeginStarted  ||
        !pAsyncPB->CallState.Flags.BeginDone     ||
        pAsyncPB->CallState.Flags.FinishStarted )
      return E_FAIL;

   pAsyncMsg = 
       (NDR_DCOM_ASYNC_MESSAGE*)pAsyncPB->CallState.pAsyncMsg;

      
   hr = NdrpValidateDcomAsyncMsg( pAsyncMsg );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( (FinishProcNum + 3)/2  != (pAsyncMsg->RpcMsg.ProcNum & 0x7fff) )
      return E_FAIL;

   // return S_FALSE in SYNTAX_DCE: we'll call into 
   // NdrpDcomFinishClientCall
   if ( pAsyncMsg->SyntaxType == XFER_SYNTAX_DCE )
      return S_OK;
      
   pAsyncMsg->ProcContext.StartofStack = (uchar *) StartofStack;
   pAsyncMsg->FinishStack  = (uchar *) StartofStack;
   pAsyncMsg->FinishStackSize = pContext->StackSize;
   pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

   // Dont allocate or copy the new stack anywhere.

   pAsyncPB->CallState.Flags.FinishStarted = 1;

   return S_OK;
}

HRESULT
MulNdrpSetupBeginClientCall(
                        CStdAsyncProxyBuffer *  pAsyncPB,
                        void *                  StartofStack,
                        NDR_PROC_CONTEXT *      pContext,
                        REFIID                  riid )
/*
    This method creates and initializes async msg.
*/
{
   PNDR_DCOM_ASYNC_MESSAGE     pAsyncMsg;
   HRESULT                     hr = S_OK;

   hr = NdrpValidateAsyncProxyCall( pAsyncPB );
   if ( ! SUCCEEDED(hr) )
      return hr;

   if ( pAsyncPB->CallState.pAsyncMsg != 0  ||
        pAsyncPB->CallState.Flags.BeginStarted )
      return E_FAIL;

   // Do this first to simplify error conditions.

   pAsyncMsg = (NDR_DCOM_ASYNC_MESSAGE*)
               I_RpcBCacheAllocate( sizeof(NDR_DCOM_ASYNC_MESSAGE) +
                                    pContext->StackSize + NDR_ASYNC_GUARD_SIZE );
   if ( ! pAsyncMsg )
      {
      NdrpAsyncProxySignal( pAsyncPB );
      return E_OUTOFMEMORY;
      }

   // Initialize the async message properly

   MIDL_memset( pAsyncMsg, 0x0, sizeof( NDR_DCOM_ASYNC_MESSAGE) );

   pAsyncMsg->Signature = NDR_DCOM_ASYNC_SIGNATURE;
   pAsyncMsg->Version   = NDR_DCOM_ASYNC_VERSION;

   pAsyncMsg->ProcContext.StartofStack = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStack   = (uchar *) & pAsyncMsg->AppStack;
   pAsyncMsg->BeginStackSize = pContext->StackSize;
   pAsyncMsg->StubPhase    = NDR_ASYNC_PREP_PHASE;

   RpcpMemoryCopy( & pAsyncMsg->ProcContext, pContext, offsetof( NDR_PROC_CONTEXT, AllocateContext ) );
   NdrpAllocaInit( &pAsyncMsg->ProcContext.AllocateContext );

   // Client: copy stack from the app's request call.
   RpcpMemoryCopy( & pAsyncMsg->AppStack, StartofStack, pContext->StackSize );

   MIDL_memset( ((char *)& pAsyncMsg->AppStack) + pContext->StackSize,
                0x71,
                NDR_ASYNC_GUARD_SIZE );

   pAsyncMsg->pAsyncPB = pAsyncPB;
   pAsyncMsg->StubMsg.pContext = &pAsyncMsg->ProcContext;
   pAsyncPB->CallState.Flags.BeginStarted = 1;
   pAsyncPB->CallState.pAsyncMsg          = pAsyncMsg;

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\i386\stubless.asm ===
;+---------------------------------------------------------------------------
;
;  Microsoft Windows
;  Copyright (C) Microsoft Corporation, 1996.
;
;  File:       stubless.asm
;
;  Contents:   This module contains interpreter support routines for
;              Intel platforms.
;
;  Functions:  Invoke - Calls a function from an interpreter.
;              ObjectStublessClient3 - ObjectStublessClient511
;
;  History:    07-Nov-94 DKays     Created
;              24-Apr-96 ShannonC  Added Invoke and support for 
;                                  512 stubless client methods.
;
;----------------------------------------------------------------------------

.386p

EXTRN   _ObjectStublessClient@8:NEAR

_TEXT   SEGMENT DWORD PUBLIC 'CODE'


;+---------------------------------------------------------------------------
;
;  Function:   REGISTER_TYPE __stdcall Invoke(MANAGER_FUNCTION pFunction, 
;                                             REGISTER_TYPE   *pArgumentList,
;                                             ULONG            cArguments);
;
;  Synopsis:   Given a function pointer and an argument list, Invoke builds 
;              a stack frame and calls the function.
;
;  Arguments:  pFunction - Pointer to the function to be called.
;
;              pArgumentList - Pointer to the buffer containing the 
;                              function parameters.
;
;              cArguments - The size of the argument list in REGISTER_TYPEs.
;
;  Notes:     In the __stdcall calling convention, the callee must pop
;             the parameters.
;
;----------------------------------------------------------------------------
_Invoke@12 PROC PUBLIC

push ebp;          Save ebp
mov  ebp, esp;     Set ebp so the debugger can display the stack trace.

;Here is our stack layout.
;[ebp+0]  = saved ebp
;[ebp+4]  = return address
;[ebp+8]  = pFunction
;[ebp+12] = pArgumentList
;[ebp+16] = cArguments

push edi;          Save edi
push esi;          Save esi
pushf;	           Save the direction flag - pushes 2 bytes
pushf;		   To keep stack aligned at 4 push 2 more bytes 

mov eax, [ebp+16]; Load number of parameters
shl eax, 2;        Calculate size of parameters
sub esp, eax;      Grow the stack

;Copy parameters from bottom to top.
mov esi, [ebp+12]; Load pointer to parameters
mov ecx, [ebp+16]; Load number of parameters
sub eax, 4;
mov edi, esp
add esi, eax;      Get pointer to last source parameter
add edi, eax;      Get pointer last destination parameter

std;               Set direction flag
rep movsd;         Copy the parameters

mov eax, [ebp-12]; Get the direction flag (2+2 bytes)
push eax;	   Push it in order to restore it
popf;              Restore the direction flag
popf;		   Do it again as we pushed 4 bytes when saving the flag

;call the server
mov eax, [ebp+8];  Load pointer to function.
call eax

mov edi, [ebp-4];  Restore edi
mov esi, [ebp-8];  Restore esi
mov esp, ebp;      Restore stack pointer
pop ebp;           Restore ebp
ret 12 ;           Pop parameters       

_Invoke@12 ENDP 


;
; Define ObjectStublessClient routine macro.
;
StublessClientProc macro    Method

    _ObjectStublessClient&Method&@0 PROC PUBLIC
        
        ;
        ; NOTE :
        ; Don't use edi, esi, or ebx unless you add code to save them on 
        ; the stack!
        ;
    
        mov     ecx, Method
        jmp     _ObjectStubless@0

    _ObjectStublessClient&Method&@0 ENDP 

endm


;On entry, ecx contains method number.
_ObjectStubless@0 PROC PUBLIC
        
        ;
        ; NOTE :
        ; Don't use edi, esi, or ebx unless you add code to save them on 
        ; the stack!
        ;
    
        ;
        ; Do this so the debugger can figure out the stack trace correctly.
        ; Will make debugging much easier.
        ;
        push    ebp
        mov     ebp, esp

        ; Push the method number.
        push    ecx

        ; Push the stack address of the parameters.
        mov     eax, ebp
        add     eax, 8
        push    eax

        call    _ObjectStublessClient@8

        ;
        ; After the call :
        ;   Real return for the proxy is in eax.
        ;   Parameter stack size is put in ecx by ObjectStublessClient for us.
        ;
        ; At this pointer eax (return), ecx (ParamSize), and edi, esi, ebx
        ; (non-volatile registers) can not be written!!!
        ;

        ; Don't forget to pop ebp.
        pop     ebp

        ; Pop our return address.
        pop     edx

        ; Pop params explicitly.
        add     esp, ecx

        ; This will return us from whichever StublessClient routine was called.
        jmp     edx

    _ObjectStubless@0 ENDP 

StublessClientProc  3
StublessClientProc  4
StublessClientProc  5
StublessClientProc  6
StublessClientProc  7
StublessClientProc  8
StublessClientProc  9
StublessClientProc  10
StublessClientProc  11
StublessClientProc  12
StublessClientProc  13
StublessClientProc  14
StublessClientProc  15
StublessClientProc  16
StublessClientProc  17
StublessClientProc  18
StublessClientProc  19
StublessClientProc  20
StublessClientProc  21
StublessClientProc  22
StublessClientProc  23
StublessClientProc  24
StublessClientProc  25
StublessClientProc  26
StublessClientProc  27
StublessClientProc  28
StublessClientProc  29
StublessClientProc  30
StublessClientProc  31
StublessClientProc  32
StublessClientProc  33
StublessClientProc  34
StublessClientProc  35
StublessClientProc  36
StublessClientProc  37
StublessClientProc  38
StublessClientProc  39
StublessClientProc  40
StublessClientProc  41
StublessClientProc  42
StublessClientProc  43
StublessClientProc  44
StublessClientProc  45
StublessClientProc  46
StublessClientProc  47
StublessClientProc  48
StublessClientProc  49
StublessClientProc  50
StublessClientProc  51
StublessClientProc  52
StublessClientProc  53
StublessClientProc  54
StublessClientProc  55
StublessClientProc  56
StublessClientProc  57
StublessClientProc  58
StublessClientProc  59
StublessClientProc  60
StublessClientProc  61
StublessClientProc  62
StublessClientProc  63
StublessClientProc  64
StublessClientProc  65
StublessClientProc  66
StublessClientProc  67
StublessClientProc  68
StublessClientProc  69
StublessClientProc  70
StublessClientProc  71
StublessClientProc  72
StublessClientProc  73
StublessClientProc  74
StublessClientProc  75
StublessClientProc  76
StublessClientProc  77
StublessClientProc  78
StublessClientProc  79
StublessClientProc  80
StublessClientProc  81
StublessClientProc  82
StublessClientProc  83
StublessClientProc  84
StublessClientProc  85
StublessClientProc  86
StublessClientProc  87
StublessClientProc  88
StublessClientProc  89
StublessClientProc  90
StublessClientProc  91
StublessClientProc  92
StublessClientProc  93
StublessClientProc  94
StublessClientProc  95
StublessClientProc  96
StublessClientProc  97
StublessClientProc  98
StublessClientProc  99
StublessClientProc  100
StublessClientProc  101
StublessClientProc  102
StublessClientProc  103
StublessClientProc  104
StublessClientProc  105
StublessClientProc  106
StublessClientProc  107
StublessClientProc  108
StublessClientProc  109
StublessClientProc  110
StublessClientProc  111
StublessClientProc  112
StublessClientProc  113
StublessClientProc  114
StublessClientProc  115
StublessClientProc  116
StublessClientProc  117
StublessClientProc  118
StublessClientProc  119
StublessClientProc  120
StublessClientProc  121
StublessClientProc  122
StublessClientProc  123
StublessClientProc  124
StublessClientProc  125
StublessClientProc  126
StublessClientProc  127

_TEXT   ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr20\i386\stblsclt.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name :

    stblsclt.c

Abstract :

    This file contains the routines for support of stubless clients in
    object interfaces.

Note:
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IMPORTANT!
    THIS FILE IS PLATFORM SPECIFIC AND DUPLICATE AMONG ALL PLATFORMS. CHANING
        ONE FILE MEANS CHANGE ALL OF THEM!!!

Author :

    David Kays    dkays    February 1995.

Revision History :
    Yong Qu       YongQu    Oct. 1998 change to platform specific and allow unlimited
                                vtbl & delegation vtbl

---------------------------------------------------------------------*/

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <stdarg.h>
#include "ndrp.h"
#include "hndl.h"
#include "interp2.h"
#include "ndrtypes.h"

#include "ndrole.h"
#include "mulsyntx.h"
#include "rpcproxy.h"

#pragma code_seg(".orpc")


typedef unsigned short  ushort;

#define NUMBER_OF_BLOCKS_PER_ALLOC 4

// for dynamically generated vtbl
#define NUMBER_OF_METHODS_PER_BLOCK 56
#define NUMBER_OF_FORWARDING_METHODS_PER_BLOCK 48
// pointed to array of masm macro. don't need to generate the buffer everytime.
#define CB_METHOD 4
// vtbl jmp talble
const BYTE CASM_GENERATESTUBLESS[] =
{
0x33, 0xC9,                 // xor eax,eax
0x8A, 0xC8,                 // move al,cl
0x81, 0xC1, 00,00,04,00,    // method id
0xFF, 0x25, 00,00,00,00     // long jmp to ObjectStubless@0
};

const BYTE CASM_GENERATEFORWARD[] = 
{
0x8b, 0x4c, 0x24, 0x04,     // mov ecx, [esp+4]
0x8b, 0x49, 0x10,           // mov ecx, [ecx+a]
0x89, 0x4c, 0x24, 0x4,      // mov [esp+4], ecx
0x8b, 0x09,                 // mov ecx, [ecx]
0x66, 0x98,                 // cbw
0x98,                       // cwde
5, 00, 10, 00, 00,          // add eax, 0x1000
0xc1, 0xe0, 0x02,           // shl eax, 0x2
0x8b, 0x04, 0x01,           // mov eax, [eax+ecx]
0xff, 0xe0                  // jmp eax
};


typedef struct tagStublessProcBuffer 
{
    BYTE pMethodsa[NUMBER_OF_METHODS_PER_BLOCK/2][CB_METHOD];
    struct tagStublessProcBuffer* pNext;
    BYTE pAsm[sizeof(CASM_GENERATESTUBLESS)];
    BYTE pMethodsb[NUMBER_OF_METHODS_PER_BLOCK/2][CB_METHOD];
} StublessProcBuffer, *PStublessProcBuffer;

static StublessProcBuffer * g_pStublessProcBuffer = NULL;

typedef struct tagForwardProcBuffer 
{
    BYTE pMethodsa[NUMBER_OF_FORWARDING_METHODS_PER_BLOCK/2][CB_METHOD];
    struct tagForwardProcBuffer* pNext;
    BYTE pAsm[sizeof(CASM_GENERATEFORWARD)];
    BYTE pMethodsb[NUMBER_OF_FORWARDING_METHODS_PER_BLOCK/2][CB_METHOD];
} ForwardProcBuffer, *PForwardProcBuffer;

static ForwardProcBuffer * g_pForwardProcBuffer = NULL;
extern void ** ProxyForwardVtbl;

EXTERN_C void ObjectStubless(void);
void ReleaseTemplateForwardVtbl(void ** pVtbl);
void ReleaseTemplateVtbl(void ** pVtbl);

static DWORD g_ObjectStubless = (DWORD)ObjectStubless;
extern ULONG g_dwVtblSize,g_dwForwardVtblSize;

extern "C"
{

long
ObjectStublessClient(
    void *  ParamAddress,
    long    Method
    );

void ObjectStublessClient3(void);
void ObjectStublessClient4(void);
void ObjectStublessClient5(void);
void ObjectStublessClient6(void);
void ObjectStublessClient7(void);

void ObjectStublessClient8(void);
void ObjectStublessClient9(void);
void ObjectStublessClient10(void);
void ObjectStublessClient11(void);
void ObjectStublessClient12(void);
void ObjectStublessClient13(void);
void ObjectStublessClient14(void);
void ObjectStublessClient15(void);
void ObjectStublessClient16(void);
void ObjectStublessClient17(void);
void ObjectStublessClient18(void);
void ObjectStublessClient19(void);
void ObjectStublessClient20(void);
void ObjectStublessClient21(void);
void ObjectStublessClient22(void);
void ObjectStublessClient23(void);
void ObjectStublessClient24(void);
void ObjectStublessClient25(void);
void ObjectStublessClient26(void);
void ObjectStublessClient27(void);
void ObjectStublessClient28(void);
void ObjectStublessClient29(void);
void ObjectStublessClient30(void);
void ObjectStublessClient31(void);
void ObjectStublessClient32(void);
void ObjectStublessClient33(void);
void ObjectStublessClient34(void);
void ObjectStublessClient35(void);
void ObjectStublessClient36(void);
void ObjectStublessClient37(void);
void ObjectStublessClient38(void);
void ObjectStublessClient39(void);
void ObjectStublessClient40(void);
void ObjectStublessClient41(void);
void ObjectStublessClient42(void);
void ObjectStublessClient43(void);
void ObjectStublessClient44(void);
void ObjectStublessClient45(void);
void ObjectStublessClient46(void);
void ObjectStublessClient47(void);
void ObjectStublessClient48(void);
void ObjectStublessClient49(void);
void ObjectStublessClient50(void);
void ObjectStublessClient51(void);
void ObjectStublessClient52(void);
void ObjectStublessClient53(void);
void ObjectStublessClient54(void);
void ObjectStublessClient55(void);
void ObjectStublessClient56(void);
void ObjectStublessClient57(void);
void ObjectStublessClient58(void);
void ObjectStublessClient59(void);
void ObjectStublessClient60(void);
void ObjectStublessClient61(void);
void ObjectStublessClient62(void);
void ObjectStublessClient63(void);
void ObjectStublessClient64(void);
void ObjectStublessClient65(void);
void ObjectStublessClient66(void);
void ObjectStublessClient67(void);
void ObjectStublessClient68(void);
void ObjectStublessClient69(void);
void ObjectStublessClient70(void);
void ObjectStublessClient71(void);
void ObjectStublessClient72(void);
void ObjectStublessClient73(void);
void ObjectStublessClient74(void);
void ObjectStublessClient75(void);
void ObjectStublessClient76(void);
void ObjectStublessClient77(void);
void ObjectStublessClient78(void);
void ObjectStublessClient79(void);
void ObjectStublessClient80(void);
void ObjectStublessClient81(void);
void ObjectStublessClient82(void);
void ObjectStublessClient83(void);
void ObjectStublessClient84(void);
void ObjectStublessClient85(void);
void ObjectStublessClient86(void);
void ObjectStublessClient87(void);
void ObjectStublessClient88(void);
void ObjectStublessClient89(void);
void ObjectStublessClient90(void);
void ObjectStublessClient91(void);
void ObjectStublessClient92(void);
void ObjectStublessClient93(void);
void ObjectStublessClient94(void);
void ObjectStublessClient95(void);
void ObjectStublessClient96(void);
void ObjectStublessClient97(void);
void ObjectStublessClient98(void);
void ObjectStublessClient99(void);
void ObjectStublessClient100(void);
void ObjectStublessClient101(void);
void ObjectStublessClient102(void);
void ObjectStublessClient103(void);
void ObjectStublessClient104(void);
void ObjectStublessClient105(void);
void ObjectStublessClient106(void);
void ObjectStublessClient107(void);
void ObjectStublessClient108(void);
void ObjectStublessClient109(void);
void ObjectStublessClient110(void);
void ObjectStublessClient111(void);
void ObjectStublessClient112(void);
void ObjectStublessClient113(void);
void ObjectStublessClient114(void);
void ObjectStublessClient115(void);
void ObjectStublessClient116(void);
void ObjectStublessClient117(void);
void ObjectStublessClient118(void);
void ObjectStublessClient119(void);
void ObjectStublessClient120(void);
void ObjectStublessClient121(void);
void ObjectStublessClient122(void);
void ObjectStublessClient123(void);
void ObjectStublessClient124(void);
void ObjectStublessClient125(void);
void ObjectStublessClient126(void);
void ObjectStublessClient127(void);

extern void * const g_StublessClientVtbl[128] =
    {
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy,
    ObjectStublessClient3,
    ObjectStublessClient4,
    ObjectStublessClient5,
    ObjectStublessClient6,
    ObjectStublessClient7,
    ObjectStublessClient8,
    ObjectStublessClient9,
    ObjectStublessClient10,
    ObjectStublessClient11,
    ObjectStublessClient12,
    ObjectStublessClient13,
    ObjectStublessClient14,
    ObjectStublessClient15,
    ObjectStublessClient16,
    ObjectStublessClient17,
    ObjectStublessClient18,
    ObjectStublessClient19,
    ObjectStublessClient20,
    ObjectStublessClient21,
    ObjectStublessClient22,
    ObjectStublessClient23,
    ObjectStublessClient24,
    ObjectStublessClient25,
    ObjectStublessClient26,
    ObjectStublessClient27,
    ObjectStublessClient28,
    ObjectStublessClient29,
    ObjectStublessClient30,
    ObjectStublessClient31,
    ObjectStublessClient32,
    ObjectStublessClient33,
    ObjectStublessClient34,
    ObjectStublessClient35,
    ObjectStublessClient36,
    ObjectStublessClient37,
    ObjectStublessClient38,
    ObjectStublessClient39,
    ObjectStublessClient40,
    ObjectStublessClient41,
    ObjectStublessClient42,
    ObjectStublessClient43,
    ObjectStublessClient44,
    ObjectStublessClient45,
    ObjectStublessClient46,
    ObjectStublessClient47,
    ObjectStublessClient48,
    ObjectStublessClient49,
    ObjectStublessClient50,
    ObjectStublessClient51,
    ObjectStublessClient52,
    ObjectStublessClient53,
    ObjectStublessClient54,
    ObjectStublessClient55,
    ObjectStublessClient56,
    ObjectStublessClient57,
    ObjectStublessClient58,
    ObjectStublessClient59,
    ObjectStublessClient60,
    ObjectStublessClient61,
    ObjectStublessClient62,
    ObjectStublessClient63,
    ObjectStublessClient64,
    ObjectStublessClient65,
    ObjectStublessClient66,
    ObjectStublessClient67,
    ObjectStublessClient68,
    ObjectStublessClient69,
    ObjectStublessClient70,
    ObjectStublessClient71,
    ObjectStublessClient72,
    ObjectStublessClient73,
    ObjectStublessClient74,
    ObjectStublessClient75,
    ObjectStublessClient76,
    ObjectStublessClient77,
    ObjectStublessClient78,
    ObjectStublessClient79,
    ObjectStublessClient80,
    ObjectStublessClient81,
    ObjectStublessClient82,
    ObjectStublessClient83,
    ObjectStublessClient84,
    ObjectStublessClient85,
    ObjectStublessClient86,
    ObjectStublessClient87,
    ObjectStublessClient88,
    ObjectStublessClient89,
    ObjectStublessClient90,
    ObjectStublessClient91,
    ObjectStublessClient92,
    ObjectStublessClient93,
    ObjectStublessClient94,
    ObjectStublessClient95,
    ObjectStublessClient96,
    ObjectStublessClient97,
    ObjectStublessClient98,
    ObjectStublessClient99,
    ObjectStublessClient100,
    ObjectStublessClient101,
    ObjectStublessClient102,
    ObjectStublessClient103,
    ObjectStublessClient104,
    ObjectStublessClient105,
    ObjectStublessClient106,
    ObjectStublessClient107,
    ObjectStublessClient108,
    ObjectStublessClient109,
    ObjectStublessClient110,
    ObjectStublessClient111,
    ObjectStublessClient112,
    ObjectStublessClient113,
    ObjectStublessClient114,
    ObjectStublessClient115,
    ObjectStublessClient116,
    ObjectStublessClient117,
    ObjectStublessClient118,
    ObjectStublessClient119,
    ObjectStublessClient120,
    ObjectStublessClient121,
    ObjectStublessClient122,
    ObjectStublessClient123,
    ObjectStublessClient124,
    ObjectStublessClient125,
    ObjectStublessClient126,
    ObjectStublessClient127
};

}

void ** StublessClientVtbl = (void **)g_StublessClientVtbl;

long
ObjectStublessClient(
    void *  ParamAddress,
    long    Method
    )
{
    PMIDL_STUBLESS_PROXY_INFO   ProxyInfo;
    CInterfaceProxyHeader *     ProxyHeader;
    PFORMAT_STRING              ProcFormat;
    unsigned short              ProcFormatOffset;
    CLIENT_CALL_RETURN          Return;
    long                        ParamSize;
    void *                      This;

        
    This = *((void **)ParamAddress);

    ProxyHeader = (CInterfaceProxyHeader *)
                  (*((char **)This) - sizeof(CInterfaceProxyHeader));
    ProxyInfo = (PMIDL_STUBLESS_PROXY_INFO) ProxyHeader->pStublessProxyInfo;

#if defined(BUILD_NDR64)
    
    if ( ProxyInfo->pStubDesc->mFlags & RPCFLG_HAS_MULTI_SYNTAXES  )
    {

        NDR_PROC_CONTEXT ProcContext;
        HRESULT  hr;
        
        Ndr64ClientInitializeContext(  
                               NdrpGetSyntaxType( ProxyInfo->pTransferSyntax),
                               ProxyInfo,
                               Method,
                               &ProcContext,
                               (uchar*)ParamAddress );

        if ( ProcContext.IsAsync )
            {
            if ( Method & 0x1 )
                hr =  MulNdrpBeginDcomAsyncClientCall( ProxyInfo,
                                                   Method,
                                                   &ProcContext,
                                                   ParamAddress );
            else
                hr =  MulNdrpFinishDcomAsyncClientCall(ProxyInfo,
                                                   Method,
                                                   &ProcContext,
                                                   ParamAddress );
                Return.Simple = hr;
            }
        else
            Return = NdrpClientCall3(This, 
                                     ProxyInfo,
                                     Method,
                                     NULL,      // return value
                                     &ProcContext,
                                     (uchar*)ParamAddress);
                               
        ParamSize = ProcContext.StackSize;        
        goto Finish;
    }

#endif
    
    ProcFormatOffset = ProxyInfo->FormatStringOffset[Method];
    ProcFormat = &ProxyInfo->ProcFormatString[ProcFormatOffset];

    ParamSize = (long)
        ( (ProcFormat[1] & Oi_HAS_RPCFLAGS) ?
          *((ushort *)&ProcFormat[8]) : *((ushort *)&ProcFormat[4]) );
          
    if ( MIDL_VERSION_3_0_39 <= ProxyInfo->pStubDesc->MIDLVersion )
        {
        // Since MIDL 3.0.39 we have a proc flag that indicates
        // which interpeter to call. This is because the NDR version
        // may be bigger than 1.1 for other reasons.

        if ( ProcFormat[1]  &  Oi_OBJ_USE_V2_INTERPRETER )
            {

            if ( MIDL_VERSION_5_0_136 <= ProxyInfo->pStubDesc->MIDLVersion
                 &&
                 ((PNDR_DCOM_OI2_PROC_HEADER) ProcFormat)->Oi2Flags.HasAsyncUuid )
                {
                Return = NdrDcomAsyncClientCall( ProxyInfo->pStubDesc,
                                                 ProcFormat,
                                                 ParamAddress );
                }
            else
                {
                Return = NdrClientCall2( ProxyInfo->pStubDesc,
                                         ProcFormat,
                                         ParamAddress );
                }
            }
        else
            {
              Return = NdrClientCall( ProxyInfo->pStubDesc,
                                    ProcFormat,
                                    ParamAddress );
            }

        }
    else
        {
        // Prior to that, the NDR version (on per file basis)
        // was the only indication of -Oi2.

        if ( ProxyInfo->pStubDesc->Version <= NDR_VERSION_1_1 )
            {
            Return = NdrClientCall( ProxyInfo->pStubDesc,
                                    ProcFormat,
                                    ParamAddress );
              Return.Simple = E_FAIL;
            }
        else
            {
            Return = NdrClientCall2( ProxyInfo->pStubDesc,
                                    ProcFormat,
                                    ParamAddress );
            }
        }

#if defined(BUILD_NDR64)
Finish:
#endif
    //
    // Return the size of the parameter stack minus 4 bytes for the HRESULT
    // return in ecx.  The ObjectStublessClient* routines need this to pop
    // the stack the correct number of bytes.  We don't have to worry about
    // this on RISC platforms since the caller pops any argument stack space
    // needed .
    //
    _asm { mov  ecx, ParamSize }
    _asm { sub  ecx, 4 }

    return (long) Return.Simple;
}



//+---------------------------------------------------------------------------
//
//  Function:   CreateStublessProcBuffer
//
//  Synopsis:   Create a StublessClientProcBuffer for vtbl to point to. starting from g_dwVtblSize,
//              till the larger of numMethods and maximum vtbls created in the block
//
//  Arguments:  USHORT numMethods   // number of methods in this interface
//              StublessProcBuffer **pTail // the last pNext in the allocated block
//
//  Note:       in x86, we are using short move & short jmps such that each method entry is 4 bytes.
//                  this  force we to have two method table in each block
//              in alpha, each entry has to be 8 bytes (2 instructions) so we can just have one
//                  method table in a block.
//  
//  Returns:
//    pointer to ProcBuffer if succeeded;
//    NULL if failed. GetLastError() to retrieve error.
//
//----------------------------------------------------------------------------
HRESULT CreateStublessProcBuffer(IN ULONG numMethods, 
                                 OUT void *** lpTempVtbl)
{
    // pointer to the last "pNext" pointer in vtbl link list: only increase, never release.
    static StublessProcBuffer** pVtblTail = NULL;
    ULONG i,j,k,iBlock = 0;
    ULONG nMethodsToAlloc = numMethods - g_dwVtblSize;
    StublessProcBuffer InitBuffer, *pStart = NULL, **pTail = NULL, *pBuf = NULL;
    DWORD* lpdwTemp, dwStartMethod = g_dwVtblSize ;
    LPBYTE  lpByte;
    BYTE lDist;
    ULONG dwNewLength;
    void ** TempVtbl = NULL;
    HRESULT hr;

    //  get number of blocks need to be allocated
    iBlock = nMethodsToAlloc / (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_METHODS_PER_BLOCK);
    
    if (nMethodsToAlloc % (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_METHODS_PER_BLOCK) != 0)    
        iBlock++;

    // size of new vtbl tempplate.
    dwNewLength = g_dwVtblSize + iBlock * (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_METHODS_PER_BLOCK);
    
    TempVtbl = (void **)I_RpcAllocate(dwNewLength * sizeof(void *) + sizeof(LONG));
    if (NULL == TempVtbl)
        return E_OUTOFMEMORY;
        
    *(LONG*)TempVtbl = 1;    // ref count
    TempVtbl = (void **)((LPBYTE)TempVtbl + sizeof(LONG));
    memcpy(TempVtbl,StublessClientVtbl,g_dwVtblSize*sizeof(void *));

    // the template other StublessProcBuffers copy from.
    if (NULL == g_pStublessProcBuffer)
    {
        BYTE nRelativeID = 0;
        memset(&InitBuffer,0,sizeof(StublessProcBuffer));
        memcpy(InitBuffer.pAsm,CASM_GENERATESTUBLESS,sizeof(CASM_GENERATESTUBLESS));
        *((DWORD *)&InitBuffer.pAsm[12]) = (DWORD)&g_ObjectStubless;

        lpByte = (LPBYTE)InitBuffer.pMethodsa;
        lDist = CB_METHOD * NUMBER_OF_METHODS_PER_BLOCK / 2;

        for (i = 0; i < NUMBER_OF_METHODS_PER_BLOCK / 2; i++)
        {
            *lpByte++ = 0xB0;   // _asm mov al
            *lpByte++ = nRelativeID++;
            *lpByte++ = 0xEB;   // _asm jmp 
            *lpByte++ = lDist;
            lDist -=CB_METHOD;          // goes further and further
        }

        lpByte = (LPBYTE)InitBuffer.pMethodsb;
        lDist = sizeof(CASM_GENERATESTUBLESS) + CB_METHOD;
        lDist = -lDist;
        for (i = 0; i < NUMBER_OF_METHODS_PER_BLOCK /2 ; i++)
        {
            *lpByte++ = 0xB0;   // _asm mov al
            *lpByte++ = nRelativeID++;
            *lpByte++ = 0xEB;   // _asm jmp 
            *lpByte++ = lDist;
            lDist -=CB_METHOD;          // goes further and further
        }
    }
    else
        memcpy(&InitBuffer,g_pStublessProcBuffer,sizeof(StublessProcBuffer));

    for (i = 0; i < iBlock; i++)
    {
        // we need to create a buffer 
        pBuf = (StublessProcBuffer *)I_RpcAllocate(NUMBER_OF_BLOCKS_PER_ALLOC * sizeof(StublessProcBuffer) );
        if (NULL == pBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }            

        // remember the starting block of all the block in the call.
        if (NULL == pStart)
            pStart = pBuf; 

        if (pTail)
            *pTail = pBuf;   // link up the link list.
            
        for (j = 0; j < NUMBER_OF_BLOCKS_PER_ALLOC; j++)
        {
            memcpy(&pBuf[j],&InitBuffer,sizeof(StublessProcBuffer));
            if (j < NUMBER_OF_BLOCKS_PER_ALLOC -1 )
                pBuf[j].pNext = &pBuf[j+1];
            else
            {
                pTail = &(pBuf[NUMBER_OF_BLOCKS_PER_ALLOC-1].pNext);
                *pTail = NULL;
            }
                

            // adjust the starting methodid in this block
            lpdwTemp = (DWORD *)& (pBuf[j].pAsm[6]);
            *lpdwTemp = dwStartMethod;

            for (k = 0; k < NUMBER_OF_METHODS_PER_BLOCK / 2; k++)
                TempVtbl[dwStartMethod++] = (void *)pBuf[j].pMethodsa[k];

            for (k = 0; k < NUMBER_OF_METHODS_PER_BLOCK / 2; k++)
                TempVtbl[dwStartMethod++] = (void *)pBuf[j].pMethodsb[k];
            
        }
    }

    if (NULL == g_pStublessProcBuffer)
        g_pStublessProcBuffer = pStart;
    else
        *pVtblTail = pStart;
        
    *lpTempVtbl = TempVtbl;
    pVtblTail = pTail;
    g_dwVtblSize = dwNewLength;
    return S_OK;

Cleanup:
    while (pStart)
    {    
        pTail = &pStart[NUMBER_OF_BLOCKS_PER_ALLOC-1].pNext;
        I_RpcFree(pStart);
        pStart = *pTail;
    }
    if (TempVtbl)
        I_RpcFree(TempVtbl);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateForwardProcBuffer
//
//  Synopsis:   Create a StublessClientProcBuffer for vtbl to point to. starting from g_dwVtblSize,
//              till the larger of numMethods and maximum vtbls created in the block
//
//  Arguments:  USHORT numMethods   // number of methods in this interface
//              StublessProcBuffer **pTail // the last pNext in the allocated block
//
//  Note:       in x86, we are using short move & short jmps such that each method entry is 4 bytes.
//                  this  force we to have two method table in each block
//              in alpha, each entry has to be 8 bytes (2 instructions) so we can just have one
//                  method table in a block.
//  
//  Returns:
//    pointer to ProcBuffer if succeeded;
//    NULL if failed. GetLastError() to retrieve error.
//
//----------------------------------------------------------------------------
HRESULT  CreateForwardProcBuffer(ULONG numMethods, void ***lpTempVtbl)
{
    // pointer to the last "pNext" pointer in vtbl link list: only increase, never release.
    static ForwardProcBuffer** pVtblTail = NULL;
    ULONG i,j,k,iBlock = 0;
    ULONG nMethodsToAlloc = numMethods - g_dwForwardVtblSize;
    ForwardProcBuffer InitBuffer, *pStart = NULL, **pTail = NULL, *pBuf = NULL;
    DWORD* lpdwTemp, dwStartMethod = g_dwForwardVtblSize ;
    LPBYTE  lpByte;
    BYTE lDist;
    ULONG dwNewLength;
    void ** TempVtbl;
    HRESULT hr;

    //  get number of blocks need to be allocated
    iBlock = nMethodsToAlloc / (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_FORWARDING_METHODS_PER_BLOCK);
    
    if (nMethodsToAlloc % (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_FORWARDING_METHODS_PER_BLOCK) != 0)    
        iBlock++;

    // size of new vtbl tempplate.
    dwNewLength = g_dwForwardVtblSize + iBlock * (NUMBER_OF_BLOCKS_PER_ALLOC * NUMBER_OF_FORWARDING_METHODS_PER_BLOCK);
    
    TempVtbl = (void **)I_RpcAllocate(dwNewLength * sizeof(void *) + sizeof(LONG));
    if (NULL == TempVtbl)
        return E_OUTOFMEMORY;
        
    *(LONG*)TempVtbl = 1;    // ref count
    TempVtbl = (void **)((LPBYTE)TempVtbl + sizeof(LONG));
    memcpy(TempVtbl,ProxyForwardVtbl,g_dwForwardVtblSize*sizeof(void *));

    // the template other StublessProcBuffers copy from.
    if (NULL == g_pForwardProcBuffer)
    {
        BYTE nRelativeID = 0;
        memset(&InitBuffer,0,sizeof(ForwardProcBuffer));
        memcpy(&InitBuffer.pAsm,CASM_GENERATEFORWARD,sizeof(CASM_GENERATEFORWARD));

        lpByte = (LPBYTE)InitBuffer.pMethodsa;
        lDist = CB_METHOD * NUMBER_OF_FORWARDING_METHODS_PER_BLOCK / 2;

        for (i = 0; i < NUMBER_OF_FORWARDING_METHODS_PER_BLOCK / 2; i++)
        {
            *lpByte++ = 0xB0;   // _asm mov al
            *lpByte++ = nRelativeID++;
            *lpByte++ = 0xEB;   // _asm jmp 
            *lpByte++ = lDist;
            lDist -=CB_METHOD;          // goes further and further
        }

        lpByte = (LPBYTE)InitBuffer.pMethodsb;
        lDist = sizeof(CASM_GENERATEFORWARD) + CB_METHOD;
        lDist = -lDist;
        for (i = 0; i < NUMBER_OF_FORWARDING_METHODS_PER_BLOCK /2 ; i++)
        {
            *lpByte++ = 0xB0;   // _asm mov al
            *lpByte++ = nRelativeID++;
            *lpByte++ = 0xEB;   // _asm jmp 
            *lpByte++ = lDist;
            lDist -=CB_METHOD;          // goes further and further
        }
    }
    else
        memcpy(&InitBuffer,g_pForwardProcBuffer,sizeof(ForwardProcBuffer));

    for (i = 0; i < iBlock; i++)
    {
        // we need to create a buffer 
        pBuf = (ForwardProcBuffer *)I_RpcAllocate(NUMBER_OF_BLOCKS_PER_ALLOC * sizeof(ForwardProcBuffer) );
        if (NULL == pBuf)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }            

        // remember the starting block of all the block in the call.
        if (NULL == pStart)
            pStart = pBuf; 

        if (pTail)
            *pTail = pBuf;   // link up the link list.
            
        for (j = 0; j < NUMBER_OF_BLOCKS_PER_ALLOC; j++)
        {
            memcpy(&pBuf[j],&InitBuffer,sizeof(ForwardProcBuffer));
            if (j < NUMBER_OF_BLOCKS_PER_ALLOC -1 )
                pBuf[j].pNext = &pBuf[j+1];
            else
            {
                pTail = &(pBuf[NUMBER_OF_BLOCKS_PER_ALLOC-1].pNext);
                *pTail = NULL;
            }
                

            // adjust the starting methodid in this block
            lpdwTemp = (DWORD *)& (pBuf[j].pAsm[17]);
            *lpdwTemp = dwStartMethod;

            for (k = 0; k < NUMBER_OF_FORWARDING_METHODS_PER_BLOCK / 2; k++)
                TempVtbl[dwStartMethod++] = (void *)pBuf[j].pMethodsa[k];

            for (k = 0; k < NUMBER_OF_FORWARDING_METHODS_PER_BLOCK / 2; k++)
                TempVtbl[dwStartMethod++] = (void *)pBuf[j].pMethodsb[k];
            
        }
    }

    if (NULL == g_pForwardProcBuffer)
        g_pForwardProcBuffer = pStart;
    else
        *pVtblTail = pStart;
        
    *lpTempVtbl = TempVtbl;
    pVtblTail = pTail;
    g_dwForwardVtblSize = dwNewLength;
    return S_OK;

Cleanup:
    while (pStart)
    {    
        pTail = &pStart[NUMBER_OF_BLOCKS_PER_ALLOC-1].pNext;
        I_RpcFree(pStart);
        pStart = *pTail;
    }
    if (TempVtbl)
        I_RpcFree(TempVtbl);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\asyncu64.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name :

    asyncu.h

Abstract :

    This file contains the ndr async uuid implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Oct 1997

Revision History :

---------------------------------------------------------------------*/

#ifndef  __ASYNCU64_H__
#define  __ASYNCU64_H__
#include "asyncu.h"


RPC_STATUS
NdrpFinishDcomAsyncClientCall(
                             PMIDL_STUB_DESC     pStubDescriptor,
                             PFORMAT_STRING      pFormat,
                             unsigned char  *    StartofStack
                             );

HRESULT
MulNdrpSetupBeginClientCall( 
    CStdAsyncProxyBuffer *  pAsyncPB,
    void *                  StartofStack,
    NDR_PROC_CONTEXT *      pContext,
    REFIID                  riid );

HRESULT
MulNdrpSetupFinishClientCall( 
    CStdAsyncProxyBuffer *  pAsyncPB,
    void *                  StartofStack,
    REFIID                  riid,
    unsigned long           AsyncProcNum,
    NDR_PROC_CONTEXT    *   pContext);

HRESULT
Ndr64pSetupBeginStubCall( 
    CStdAsyncStubBuffer *   pAsyncSB,
    NDR_PROC_CONTEXT *      pContext,
    REFIID                  riid );

HRESULT
Ndr64pSetupFinishStubCall( 
    CStdAsyncStubBuffer *   pAsyncSB,
    unsigned long           StackSize,
    REFIID                  riid );

HRESULT
Ndr64pBeginDcomAsyncStubCall(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase );

ULONG STDMETHODCALLTYPE
Ndr64pAsyncProxyAddRef( 
    CStdAsyncProxyBuffer *  pAsyncPB );

ULONG STDMETHODCALLTYPE
Ndr64pAsyncProxyRelease( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
Ndr64pAsyncProxyLock( 
    CStdAsyncProxyBuffer *  pAsyncPB );

void
Ndr64pAsyncProxyUnlock( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
Ndr64pAsyncProxyCleanup( 
    CStdAsyncProxyBuffer *  pAsyncPB );

HRESULT
Ndr64pSetupBeginServerCall( 
    CStdAsyncStubBuffer *   pAsyncPB,
    void *                  StartofStack,
    unsigned short          StackSize,
    REFIID                  riid );


void
Ndr64pCloneInOutArgs( 
    NDR_DCOM_ASYNC_MESSAGE * pAsyncMsg, 
    PPARAM_DESCRIPTION       FinishParams,
    int                      FinishParamCount ); 

void
Ndr64pFreeDcomAsyncMsg( 
    PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg );


HRESULT
Ndr64pAsyncStubSignal(
    CStdAsyncStubBuffer *  pAsyncSB );


HRESULT
Ndr64pAsyncStubAddRef( 
    CStdAsyncStubBuffer *  pAsyncSB );

ULONG STDMETHODCALLTYPE
Ndr64pAsyncStubRelease( 
    CStdAsyncStubBuffer *  pAsyncSB );

HRESULT
Ndr64pAsyncStubLock( 
    CStdAsyncStubBuffer *  pAsyncSB );

void
Ndr64pAsyncStubUnlock( 
    CStdAsyncStubBuffer *  pAsyncSB );

HRESULT
Ndr64pAsyncStubCleanup( 
    CStdAsyncStubBuffer *  pAsyncSB );


BOOL
Ndr64pDcomAsyncSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    ISynchronize *      pSynchronize );

BOOL
Ndr64pDcomAsyncClientSend(
    PMIDL_STUB_MESSAGE  pStubMsg,
    IUnknown *          punkOuter );

void
Ndr64DcomAsyncReceive(
    PMIDL_STUB_MESSAGE  pStubMsg );


#define NdrHrFromWin32Error( exc )  NdrStubErrorHandler( exc )

#endif  // __ASYNCU64_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\async.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name :

    async.c

Abstract :

    This file contains the ndr async implementation.

Author :

    Ryszard K. Kott     (ryszardk)    Nov 1996

Revision History :

---------------------------------------------------------------------*/

#include "precomp.hxx"

#define USE_STUBLESS_PROXY

#define CINTERFACE

#include "ndrole.h"
#include "rpcproxy.h"
#include "interp2.h"
#include "asyndr64.h"
#include <stdarg.h>

#pragma code_seg(".ndr64")

#ifdef _PPC_
#error PPC code has been removed
#endif


void RPC_ENTRY
Ndr64AsyncServerWorker(
    PRPC_MESSAGE            pRpcMsg,
    ulong                   Index );


CLIENT_CALL_RETURN  RPC_VAR_ENTRY
Ndr64AsyncClientCall(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    ulong                       nProcNum,
    void                       *pReturnValue,
    ...
    )
/*
    This entry is used for raw rpc only.
    No support for OLE [async] attribute anymore.
*/
{
    va_list             ArgList;
    unsigned char  *    StartofStack;
    CLIENT_CALL_RETURN  Ret;
    //
    // Get address of argument to this function following pFormat. This
    // is the address of the address of the first argument of the function
    // calling this function.
    // Then get the address of the stack where the parameters are.
    //

    RPC_ASYNC_HANDLE            AsyncHandle;
    PNDR_ASYNC_MESSAGE          pAsyncMsg;

    RPC_MESSAGE *               pRpcMsg;
    MIDL_STUB_MESSAGE *         pStubMsg;
    ulong                       ProcNum;

    uchar *                     pArg;
    ushort                      StackSize;
    PPARAM_DESCRIPTION          Params;
    long                        n;

    RPC_STATUS                  Status;
    NDR_PROC_CONTEXT            * pContext;
    PMIDL_STUB_DESC             pStubDesc;
    

    Ret.Simple = NULL;
    
    if ( NULL == pReturnValue )
        pReturnValue = &Ret;

    INIT_ARG( ArgList, pReturnValue );
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *) GET_STACK_START(ArgList);


    RPC_ASYNC_HANDLE * pHandleArg;

    // async message needs to be allocated on heap to be passed between calls.
    pAsyncMsg = (NDR_ASYNC_MESSAGE*) I_RpcBCacheAllocate( sizeof( NDR_ASYNC_MESSAGE) );
    if ( ! pAsyncMsg )
        Status = RPC_S_OUT_OF_MEMORY;
    else
        {

        memset( pAsyncMsg, 0, sizeof( NDR_ASYNC_MESSAGE ) );
        Ndr64ClientInitializeContext( NdrpGetSyntaxType( pProxyInfo->pTransferSyntax),
                                      pProxyInfo,
                                      nProcNum,
                                      &pAsyncMsg->ProcContext,
                                      StartofStack );

        Status = NdrpInitializeAsyncMsg( StartofStack,
                                         pAsyncMsg );
        }

    // We need to cleanup and return if something wrong in the async message
    if ( Status )
        {
        MIDL_STUB_MESSAGE StubMsgTemp;
        NDR_PROC_CONTEXT ProcContext;
        Ndr64ClientInitializeContext( NdrpGetSyntaxType( pProxyInfo->pTransferSyntax),
                                      pProxyInfo,
                                      nProcNum,
                                      &ProcContext,
                                      StartofStack );
        
        StubMsgTemp.StubDesc = pProxyInfo->pStubDesc;
        StubMsgTemp.StackTop = StartofStack;
        StubMsgTemp.pContext = &ProcContext;
        (ProcContext.pfnExceptionHandling)(&StubMsgTemp,
                                             nProcNum,
                                             ( RPC_STATUS )Ret.Simple,
                                             &Ret );
        return Ret;                                    
        }

    pContext = & pAsyncMsg->ProcContext;

    // proc context 
    // We need to switch to our copy of the stack everywhere, including pStubMsg.

    StartofStack = pAsyncMsg->ProcContext.StartofStack;

    // We abstract the level of indirection here.
    AsyncHandle = pAsyncMsg->AsyncHandle;

    pRpcMsg   = & pAsyncMsg->RpcMsg;
    pStubMsg  = & pAsyncMsg->StubMsg;


    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        // Use a nested try-except pair to support [comm_status][fault_status].
        //
        RpcTryExcept
            {
            BOOL fRaiseExcFlag;

            pContext->RpcFlags |= RPC_BUFFER_ASYNC;

            Ndr64pClientSetupTransferSyntax( NULL, // pThis
                           pRpcMsg,
                           pStubMsg,
                           pProxyInfo,
                           pContext,
                           nProcNum );

            
            pStubMsg->pAsyncMsg = pAsyncMsg;
            pStubMsg->pContext       = pContext;

            (* pAsyncMsg->ProcContext.pfnInit) ( pStubMsg,
                                                 pReturnValue );

            ( * pAsyncMsg->ProcContext.pfnSizing) ( pStubMsg,
                                         TRUE );    // isclient
                                                          

            //
            // Do the GetBuffer.
            //

            pRpcMsg->RpcFlags |= RPC_BUFFER_ASYNC;

            Ndr64GetBuffer( pStubMsg,
                              pStubMsg->BufferLength );

            NDR_ASSERT( pStubMsg->fBufferValid, "Invalid buffer" );

            // Let runtime associate async handle with the call.

            NdrpRegisterAsyncHandle( pStubMsg, AsyncHandle );

            pAsyncMsg->StubPhase = NDR_ASYNC_SET_PHASE;

            //
            // ----------------------------------------------------------
            // Marshall Pass.
            // ----------------------------------------------------------
            //

            (* pAsyncMsg->ProcContext.pfnMarshal) (pStubMsg,
                    FALSE );    

            //
            // Make the RPC call.
            //

            pAsyncMsg->StubPhase = NDR_ASYNC_CALL_PHASE;

            NdrAsyncSend( pStubMsg,
                           pContext->HasPipe && pContext->pPipeDesc->InPipes );

            pAsyncMsg->Flags.ValidCallPending = 1;
            }
        RpcExcept( pAsyncMsg->ProcContext.ExceptionFlag )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            // Actually dismantle the call.
            // This is a request call and there is nothing left at the runtime.

            pAsyncMsg->StubPhase = NDR_ASYNC_ERROR_PHASE;

            (* pAsyncMsg->ProcContext.pfnExceptionHandling) ( pStubMsg,
                                             nProcNum,
                                             ExceptionCode,
                                             &Ret );
            }
        RpcEndExcept
        }
    RpcFinally
        {
        if ( pAsyncMsg->Flags.ValidCallPending )
            {
            if ( pContext->HasPipe )
                {
                NdrMarkNextActivePipe( pContext->pPipeDesc );
                pContext->pPipeDesc->Flags.NoBufferCallPending = 1;
                }
            }
        else
            {
            // Cleanup everything but the user's handle.

            NdrpFreeAsyncMsg( pAsyncMsg );

            AsyncHandle->StubInfo = 0;
            }

        InterlockedDecrement( & AsyncHandle->Lock );
        }
    RpcEndFinally

    return Ret;
}


RPC_STATUS
Ndr64pCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    )
{
    RPC_MESSAGE *               pRpcMsg   = & pAsyncMsg->RpcMsg;
    MIDL_STUB_MESSAGE *         pStubMsg  = & pAsyncMsg->StubMsg;
    NDR_PROC_CONTEXT    *       pContext  = & pAsyncMsg->ProcContext;

    PMIDL_STUB_DESC             pStubDescriptor  = pStubMsg->StubDesc;

    CLIENT_CALL_RETURN          RetVal           ;

    uchar *                     pArg;

    long                        n;
    NDR_ASYNC_CALL_FLAGS        CallFlags = pAsyncMsg->Flags;

    RetVal.Simple = 0;
    
    RpcTryFinally
        {
        // Use a nested try-except pair to support [comm_status][fault_status].
        //
        RpcTryExcept
            {
            if ( ! CallFlags.ValidCallPending )
                RpcRaiseException( RPC_S_INVALID_ASYNC_HANDLE );

            CallFlags.ValidCallPending = 0;

            // Non-pipe case or after pipe args case.

            if ( pContext->HasPipe )
                {
                RPC_STATUS rc = RpcAsyncGetCallStatus( AsyncHandle );
                
                if ( rc == RPC_S_OK  || rc == RPC_S_ASYNC_CALL_PENDING )
                    NdrIsAppDoneWithPipes( pContext->pPipeDesc );
                else
                    RpcRaiseException( rc );
                }

            NdrLastAsyncReceive( pStubMsg );

            //
            // ----------------------------------------------------------
            // Unmarshall Pass.
            // ----------------------------------------------------------
            //
            (*pAsyncMsg->ProcContext.pfnUnMarshal)( pStubMsg,
                                  (CLIENT_CALL_RETURN *) pReturnValue );
            



            }
        RpcExcept( pAsyncMsg->ProcContext.ExceptionFlag )
            {
            RPC_STATUS ExceptionCode = RpcExceptionCode();

            CallFlags.ValidCallPending = ExceptionCode == RPC_S_ASYNC_CALL_PENDING;

            (* pAsyncMsg->ProcContext.pfnExceptionHandling) ( pStubMsg,
                                             pRpcMsg->ProcNum,
                                             ExceptionCode,
                                             &RetVal );
            }
        RpcEndExcept

        }
    RpcFinally
        {
        // There is only one way a valid call may be pending at this stage:
        // that is the receive call returned with RPC_S_CALL_PENDING.

        if ( ! CallFlags.ValidCallPending )
            {
            // Cleanup everything. However, don't free user's handle.

            NdrpFreeAsyncMsg( pAsyncMsg );

            AsyncHandle->StubInfo = 0;
            }

        InterlockedDecrement( & AsyncHandle->Lock );
        }
    RpcEndFinally

    return (RPC_STATUS)RetVal.Simple;
}

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCall64(
    PRPC_MESSAGE    pRpcMsg )
{
    // When compiled with -protocol ndr64, 
    // NDR64 is the 1st (and only one) in MIDL_SYNTAX_INFO array.
    Ndr64AsyncServerWorker(
                     pRpcMsg,
                     0 );   // Index 0
}

RPCRTAPI
void
RPC_ENTRY
Ndr64AsyncServerCallAll(
    PRPC_MESSAGE    pRpcMsg )
{   
    // When compiles with -protocol all, 
    // NDR64 is the 2nd in MIDL_SYNTAX_INFO array
    Ndr64AsyncServerWorker(
                     pRpcMsg,
                     1 );  // Index 1
}                     


void RPC_ENTRY
Ndr64AsyncServerWorker(
    PRPC_MESSAGE            pRpcMsg,
    ulong                   SyntaxIndex )
/*++
Routine Description :

    The server side entry point for regular asynchronous RPC procs.

Arguments :

    pRpcMsg         - The RPC message.

Return :

    None.
--*/
{
    ulong dwStubPhase = STUB_UNMARSHAL;
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    const SERVER_ROUTINE  * DispatchTable;
    MIDL_SYNTAX_INFO *      pSyntaxInfo;
    RPC_ASYNC_HANDLE        AsyncHandle = 0;
    PNDR_ASYNC_MESSAGE      pAsyncMsg;

    ushort                  ProcNum;
    
    PMIDL_STUB_MESSAGE      pStubMsg;

    uchar *                 pArgBuffer;
    uchar *                 pArg;
    uchar **                ppArg;

    NDR64_PROC_FORMAT *     pHeader;
    NDR64_PARAM_FORMAT  *   Params;
    long                    NumberParams;
    NDR64_PROC_FLAGS *      pNdr64Flags;


    ushort                  ClientBufferSize;
    BOOL                    HasExplicitHandle;
    long                    n;

    // This context is just for setting up the call. embedded one in asyncmsg is the
    // one to be used during the life of this async call.
    NDR_PROC_CONTEXT        *pContext;
    RPC_STATUS              Status = RPC_S_OK;
    NDR64_PARAM_FLAGS   *       pParamFlags;
    NDR64_BIND_AND_NOTIFY_EXTENSION * pHeaderExts = NULL;

    pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
    pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
    DispatchTable = pServerInfo->DispatchTable;

    pSyntaxInfo = &pServerInfo->pSyntaxInfo[SyntaxIndex];
    NDR_ASSERT( XFER_SYNTAX_NDR64 == NdrpGetSyntaxType(&pSyntaxInfo->TransferSyntax),
                " invalid transfer syntax" );

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    // The handle table is part of the async handle.

    ProcNum = (ushort) pRpcMsg->ProcNum;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    AsyncHandle = 0;
    pAsyncMsg = (NDR_ASYNC_MESSAGE*) I_RpcBCacheAllocate( sizeof( NDR_ASYNC_MESSAGE) );
    if ( ! pAsyncMsg )
        Status = RPC_S_OUT_OF_MEMORY;
    else
        {
        memset( pAsyncMsg, 0, sizeof( NDR_ASYNC_MESSAGE ) );
        
        NdrServerSetupNDR64TransferSyntax(
                                         ProcNum,
                                         pSyntaxInfo,
                                         &pAsyncMsg->ProcContext );
                                     
        Status = NdrpInitializeAsyncMsg( 0,                 // StartofStack, server
                                         pAsyncMsg
                                        );
        }
        
    if ( Status )
        RpcRaiseException( Status );

    pContext = &pAsyncMsg->ProcContext;
    
    PFORMAT_STRING pFormat = pContext->pProcFormat;
    
    pAsyncMsg->StubPhase = STUB_UNMARSHAL;

    pStubMsg = & pAsyncMsg->StubMsg; 
 
    // same in ndr20
    pStubMsg->RpcMsg = pRpcMsg;

    // The arg buffer is zeroed out already.
    pArgBuffer = pContext->StartofStack;

    pHeader = (NDR64_PROC_FORMAT *) pFormat;
    pNdr64Flags = (NDR64_PROC_FLAGS *) &pHeader->Flags;
    HasExplicitHandle = !NDR64MAPHANDLETYPE( NDR64GETHANDLETYPE ( pNdr64Flags ) );

    if ( pNdr64Flags->HasOtherExtensions )
        pHeaderExts = (NDR64_BIND_AND_NOTIFY_EXTENSION *) (pFormat + sizeof( NDR64_PROC_FORMAT ) );


    if ( HasExplicitHandle )
    {
        NDR_ASSERT( pHeaderExts, "NULL extension header" );
        //
        // For a handle_t parameter we must pass the handle field of
        // the RPC message to the server manager.
        //
        if ( pHeaderExts->Binding.HandleType == FC64_BIND_PRIMITIVE )
        {
            pArg = pArgBuffer + pHeaderExts->Binding.StackOffset;

            if ( NDR64_IS_HANDLE_PTR( pHeaderExts->Binding.Flags ) )
                pArg = *((uchar **)pArg);

            *((handle_t *)pArg) = pRpcMsg->Handle;
        }

    }

    //
    // Get new interpreter info.
    //
    NumberParams = pHeader->NumberOfParams;

    Params = (NDR64_PARAM_FORMAT *)( (uchar *) pFormat + sizeof( NDR64_PROC_FORMAT ) + pHeader->ExtensionSize );


    //
    // Wrap the unmarshalling and the invoke call in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    BOOL        fManagerCodeInvoked = FALSE;
    BOOL        fErrorInInvoke = FALSE;
    RPC_STATUS  ExceptionCode = 0;

    // We abstract the level of indirection here.

    AsyncHandle = pAsyncMsg->AsyncHandle;

    RpcTryFinally
    {
        RpcTryExcept
        {
        // Put the async handle on stack.

        ((void **)pArgBuffer)[0] = AsyncHandle;  

        //
        // Initialize the Stub message.
        // Note that for pipes we read non-pipe data synchronously,
        // and so the init routine doesn't need to know about async.
        //
        if ( ! pNdr64Flags->UsesPipes )
           {
            Ndr64ServerInitialize( pRpcMsg,
                                    pStubMsg,
                                    pServerInfo->pStubDesc );
           }
        else
            Ndr64ServerInitializePartial( pRpcMsg,
                                        pStubMsg,
                                        pServerInfo->pStubDesc,
                                        pHeader->ConstantClientBufferSize );

        // We need to set up this flag because the runtime does not know whether
        //   it dispatched a sync or async call to us. same as ndr20

        pRpcMsg->RpcFlags         |= RPC_BUFFER_ASYNC;
        pStubMsg->pAsyncMsg       = pAsyncMsg;
        pStubMsg->RpcMsg = pRpcMsg;
        pStubMsg->pContext       = &pAsyncMsg->ProcContext;

         //
        // Set up for context handle management.
        //
        pStubMsg->SavedContextHandles = & pAsyncMsg->CtxtHndl[0];
        
       // Raise exceptions after initializing the stub.

        if ( pNdr64Flags->UsesFullPtrPackage  )
            pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

        //
        // Set StackTop AFTER the initialize call, since it zeros the field
        // out.
        //
        pStubMsg->pCorrMemory = pStubMsg->StackTop; 

        if ( pNdr64Flags->UsesPipes )
            NdrpPipesInitialize64( pStubMsg,
                                   &pContext->AllocateContext,
                                   (PFORMAT_STRING) Params,
                                   (char*)pArgBuffer,
                                   NumberParams );

        //
        // We must make this check AFTER the call to ServerInitialize,
        // since that routine puts the stub descriptor alloc/dealloc routines
        // into the stub message.
        //
        if ( pNdr64Flags->UsesRpcSmPackage )
            NdrRpcSsEnableAllocate( pStubMsg );

        // Let runtime associate async handle with the call.

        NdrpRegisterAsyncHandle( pStubMsg, AsyncHandle );

        pAsyncMsg->StubPhase = NDR_ASYNC_SET_PHASE;
            
            // --------------------------------
            // Unmarshall all of our parameters.
            // --------------------------------

        NDR_ASSERT( pContext->StartofStack == pArgBuffer, "startofstack is not set" );
        Ndr64pServerUnMarshal( pStubMsg  );


        if ( pRpcMsg->BufferLength  <
             (uint)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer) )
            {
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }                                               

            }
        RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
            {
            ExceptionCode = RpcExceptionCode();

            if( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
                {
                ExceptionCode = RPC_X_BAD_STUB_DATA;
                }

            pAsyncMsg->Flags.BadStubData = 1;
            pAsyncMsg->ErrorCode = ExceptionCode;
            NdrpFreeMemoryList( pStubMsg );
            RpcRaiseException( ExceptionCode );
            }
        RpcEndExcept

        // Two separate blocks because the filters are different.
        // We need to catch exception in the manager code separately
        // as the model implies that there will be no other call from
        // the server app to clean up.

        RpcTryExcept
            {
            //
            // Do [out] initialization before the invoke.
            //
            Ndr64pServerOutInit( pStubMsg );


            //
            // Unblock the first pipe; this needs to be after unmarshalling
            // because the buffer may need to be changed to the secondary one.
            // In the out only pipes case this happens immediately.
            //
            if ( pNdr64Flags->UsesPipes )
                NdrMarkNextActivePipe( pContext->pPipeDesc );

            pAsyncMsg->StubPhase = STUB_CALL_SERVER;

            //
            // Check for a thunk.  Compiler does all the setup for us.
            //
            if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
                {
                pAsyncMsg->Flags.ValidCallPending = 1;
                InterlockedDecrement( & AsyncHandle->Lock );

                fManagerCodeInvoked = TRUE;
                fErrorInInvoke = TRUE;
                pServerInfo->ThunkTable[ProcNum]( pStubMsg );
                }
            else
                {
                //
                // Note that this ArgNum is not the number of arguments declared
                // in the function we called, but really the number of
                // REGISTER_TYPEs occupied by the arguments to a function.
                //
                long                ArgNum;
                MANAGER_FUNCTION    pFunc;
                REGISTER_TYPE       returnValue;

                if ( pRpcMsg->ManagerEpv )
                    pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
                else
                    pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

                ArgNum = (long) pContext->StackSize / sizeof(REGISTER_TYPE);

                //
                // The StackSize includes the size of the return. If we want
                // just the number of REGISTER_TYPES, then ArgNum must be reduced
                // by 1 when there is a return value AND the current ArgNum count
                // is greater than 0.
                //
                if ( ArgNum &&  pNdr64Flags->HasReturn )
                    ArgNum--;

                // Being here means that we can expect results. Note that the user
                // can call RpcCompleteCall from inside of the manager code.

                pAsyncMsg->Flags.ValidCallPending = 1;

                // Unlock the handle - the app is allowed to call RpCAsyncComplete
                //  or RpcAsyncAbort from the manager code.

                InterlockedDecrement( & AsyncHandle->Lock );

                fManagerCodeInvoked = TRUE;
                fErrorInInvoke = TRUE;

                returnValue = Invoke( pFunc,
                                      (REGISTER_TYPE *)pArgBuffer,
#if defined(_WIN64)
                                      pHeader->FloatDoubleMask,
#endif
                                      ArgNum);

                // We are discarding the return value as it is not the real one.
                // The real return value is passed in the complete call.
                }

            fErrorInInvoke = FALSE;
            }
        RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
            {
            ExceptionCode = RpcExceptionCode();

            if ( ExceptionCode == 0 )
                ExceptionCode = ERROR_INVALID_PARAMETER;

            // We may not have the async message around anymore.

            RpcRaiseException( ExceptionCode );
            }
        RpcEndExcept

        }
    RpcFinally
        {
        if ( fManagerCodeInvoked  &&  !fErrorInInvoke )
            {
            // Success. Just skip everything if the manager code was invoked
            // and returned successfully.
            // Note that manager code could have called Complete or Abort by now
            // and so the async handle may not be valid anymore.
            }
        else
            {
            // See if we can clean up;

            Status = RPC_S_OK;
            if ( fErrorInInvoke )
                {
                // After an exception in invoking, let's see if we can get a hold
                // of the handle. If so, we will be able to clean up.
                // If not, there may be a leak there that we can do nothing about.
                // The rule is: after an exception the app cannot call Abort or
                // Complete. So, we need to force complete if we can.

                Status = NdrValidateBothAndLockAsyncHandle( AsyncHandle );
                }

            if ( Status == RPC_S_OK )
                {
                // Something went wrong but we are able to do the cleanup.

                // Cleanup parameters and async message/handle.
                // propagate the exception.
                Ndr64pCleanupServerContextHandles( pStubMsg, 
                                           NumberParams,
                                           Params,
                                           pArgBuffer,
                                           TRUE );     // fail before/during manager routine

                if (!pAsyncMsg->Flags.BadStubData)
                   {
                   Ndr64pFreeParams( pStubMsg,
                                   NumberParams,
                                   Params,
                                   pArgBuffer );
                   }

                NdrpFreeAsyncHandleAndMessage( AsyncHandle );
                }

            // else manager code invoked and we could not recover.
            // Exception will be raised by the EndFinally below.
            }

        }
    RpcEndFinally
}


RPC_STATUS
Ndr64pCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    PNDR_ASYNC_MESSAGE          pAsyncMsg,
    void *                      pReturnValue
    )
/*++

Routine Description :

    Complete an async call on the server side.  If an exception occurs, the
    asynchronous rpc call is aborted with the exception code and the server side
    caller is returned S_OK.

Arguments :

    AsyncHandle  - validated asynchronous handle,
    pAsyncMsg    - pointer to async msg structure,
    pReturnValue - pointer to the return value to be passed to the client.

Return :

    Status of S_OK.

--*/
{
    MIDL_STUB_MESSAGE *     pStubMsg       = & pAsyncMsg->StubMsg;
    RPC_MESSAGE *           pRpcMsg        = pStubMsg->RpcMsg;

    NDR64_PARAM_FORMAT  *   Params ;
    uchar *                 pArgBuffer     = pAsyncMsg->ProcContext.StartofStack;
    ushort                  StackSize      = (ushort)pAsyncMsg->ProcContext.StackSize;

    uchar *                 pArg;
    long                    NumberParams ;
    long                    n;
    boolean                 fParamsFreed   = FALSE;
    NDR64_PROC_FORMAT     * pHeader = pAsyncMsg->ProcContext.Ndr64Header;
    NDR64_PROC_FLAGS *      pNdr64Flags      = ( NDR64_PROC_FLAGS * )&pHeader->Flags;
    
    
    NumberParams    = pAsyncMsg->ProcContext.NumberParams;
    Params          = ( NDR64_PARAM_FORMAT * ) pAsyncMsg->ProcContext.Params;
    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-except. Put the call to abort in the except clause.
    //
    RpcTryExcept
    {
        // At this point, this is a valid RPC call since the asynchronous handle
        // is owned by NDR on the server side and NDR passes the handle
        // to the server during the invoke call.  During invoke
        // the parameters have already been unmarshalled.

        pAsyncMsg->StubPhase = STUB_MARSHAL;
    
        if( pNdr64Flags->HasReturn )
            {
            // Put user's return value on the stack as usual.
            // See the invoke for comments on folding return into the arg satck.

            long  ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);

            if ( ArgNum )
                ArgNum--;

            if ( ! pReturnValue )
                RpcRaiseException( RPC_S_INVALID_ARG );

            if ( Params[NumberParams-1].Attributes.IsBasetype )
                memcpy( &((REGISTER_TYPE *)pArgBuffer)[ArgNum], 
                    pReturnValue, 
                    (size_t)NDR64_SIMPLE_TYPE_MEMSIZE( *(PFORMAT_STRING) Params[NumberParams-1].Type ) );
            else
                ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = *(REGISTER_TYPE*)pReturnValue;
            }

        //
        // Buffer size pass.
        //
        ushort  ConstantBufferSize = (ushort)pHeader->ConstantServerBufferSize;

        if ( pNdr64Flags->UsesPipes )
            {
            NdrIsAppDoneWithPipes( pStubMsg->pContext->pPipeDesc );
            pStubMsg->BufferLength += ConstantBufferSize;
            }
        else
            pStubMsg->BufferLength = ConstantBufferSize;

        if ( pNdr64Flags->ServerMustSize )
            {
            NDR_ASSERT( pAsyncMsg->ProcContext.StartofStack == pArgBuffer, 
                        "startofstack is not set" );
            
            Ndr64pSizing( pStubMsg,
                          FALSE );
                          
            }

        // Get buffer.

        if ( pNdr64Flags->UsesPipes && pStubMsg->pContext->pPipeDesc->OutPipes )
            {
            NdrGetPartialBuffer( pStubMsg );
            pStubMsg->RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
            }
        else
            {
            Ndr64GetBuffer( pStubMsg,
                          pStubMsg->BufferLength );
            }

                       
        //
        // Marshall pass.
        //

        Ndr64pServerMarshal( pStubMsg );

        pRpcMsg->BufferLength = (ulong)(pStubMsg->Buffer - (uchar *)pRpcMsg->Buffer);

        // We don't drop to the runtime like for synchronous calls,
        // we send the last buffer explicitly.

        // set the freed flag.
        fParamsFreed = TRUE;
        /*
            we have to do release twice here:
                After the last piece of data is sent via NdrAsyncSend, dispatch buffer
            will be freed by runtime. We'll have problem calling ndr free routines to
            free unique pointers (where both pointer and pointee are in the buffer). So
            we call ndr free routines BEFORE the send, because it won't free anything
            inside dispatch buffer, and runtime send only cares about dispatch buffer.
                We still have to call ndr free routines in RpcFinally for exception cleanup. we
            check the flag to avoid calling free twice.
        */
        Ndr64pFreeParams( pStubMsg,
                        NumberParams,
                        Params,
                        pArgBuffer );

        NdrAsyncSend( pStubMsg,
                      FALSE );    // the last call is always non-partial
        }
    RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
        {
        // If we died during the marshaling phase, see if context handles are fine.

        // Abort the call which will result in the exception being propagated to
        // the client.

        Ndr64pAsyncAbortCall( AsyncHandle,
                            pAsyncMsg,
                            RpcExceptionCode(),
                            !fParamsFreed ); // Do not free if second attempt.
        return S_OK;
        }
    RpcEndExcept

    NdrpFreeAsyncHandleAndMessage( AsyncHandle );
    return S_OK;
}


RPC_STATUS
Ndr64pAsyncAbortCall (
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    )
/*++
Routine Description:

    Aborts the asynchronous RPC call indicated by AsyncHandle on the server and
    frees memory allocated for the parameters, message, and handle.

Arguments:
    AsyncHandle   - supplies the async handle for the call
    AsyncMessage  - supplies the async message for the call
    ExceptionCode - supplies the exception code to send to the client.
    bFreeParams   - TRUE if the parameters should be freed.

Return Value:
    NONE.

--*/
{

    RPC_STATUS Status = RPC_S_OK;

    // If the async call is aborted, see if context handles are fine.
    // We are dying after manager routine is called
        Ndr64pCleanupServerContextHandles( &pAsyncMsg->StubMsg, 
                                           pAsyncMsg->ProcContext.NumberParams,
                                           (NDR64_PARAM_FORMAT *) pAsyncMsg->ProcContext.Params,
                                           pAsyncMsg->ProcContext.StartofStack,
                                           FALSE );     // no exception in manager routine


    if (bFreeParams)
        {
        Ndr64pFreeParams( & pAsyncMsg->StubMsg,
                        pAsyncMsg->ProcContext.NumberParams,  //Number of parameters
                        (NDR64_PARAM_FORMAT *) pAsyncMsg->ProcContext.Params,
                        pAsyncMsg->ProcContext.StartofStack );
        }

    if ( ! pAsyncMsg->Flags.RuntimeCleanedUp )
        Status = I_RpcAsyncAbortCall( AsyncHandle, ExceptionCode);

    NdrpFreeAsyncHandleAndMessage( AsyncHandle );

    return Status;
}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\asyndr64.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 - 2000 Microsoft Corporation

Module Name :

    asyncndr.h

Abstract :

    This file contains the ndr async related definitions.

Author :

    Ryszard K. Kott     (ryszardk)    Nov 1996

Revision History :

---------------------------------------------------------------------*/

#ifndef  __ASYNCNDR64_H__
#define  __ASYNCNDR64_H__

#include "asyncndr.h"
#define RPC_ASYNC_CURRENT_VERSION     RPC_ASYNC_VERSION_1_0


RPC_STATUS
Ndr64pCompleteAsyncCall (
    IN PRPC_ASYNC_STATE     AsyncHandle,
    IN PNDR_ASYNC_MESSAGE   pAsyncMsg,
    IN void *               pReply
    );

RPC_STATUS
Ndr64pCompleteAsyncClientCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
Ndr64pCompleteAsyncServerCall(
    RPC_ASYNC_HANDLE            AsyncHandle,
    IN PNDR_ASYNC_MESSAGE       pAsyncMsg,
    void *                      pReturnValue
    );

RPC_STATUS
Ndr64pAsyncAbortCall(
    PRPC_ASYNC_STATE   AsyncHandle,
    PNDR_ASYNC_MESSAGE pAsyncMsg,
    unsigned long      ExceptionCode,
    BOOL               bFreeParams
    );
 

#endif  // __ASYNCNDR64_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\auxilary.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    auxilary.cxx

Abstract :

    This file contains auxilary routines used for initialization of the
    RPC and stub messages and the offline batching of common code sequences
    needed by the stubs.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/
#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"
#include "asyncndr.h"
#include "auxilary.h"


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Static data for NS library operations
  ---------------------------------------------------------------------*/

#pragma code_seg(".ndr64")

void
MakeSureWeHaveNonPipeArgs(
    PMIDL_STUB_MESSAGE  pStubMsg,
    unsigned long       BufferSize );

void
EnsureNSLoaded();

void
Ndr64ClientInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUBLESS_PROXY_INFO           pProxyInfo,
    unsigned int                        ProcNum )
/*++

Routine Description :

    This routine is called by client side stubs to initialize the RPC message
    and stub message, and to get the RPC buffer.

Arguments :

    pRpcMsg          - pointer to RPC message structure
    pStubMsg         - pointer to stub message structure
    pStubDescriptor  - pointer to stub descriptor structure
    ProcNum          - remote procedure number

--*/
{
    //
    // Initialize RPC message fields.
    //
    // The leftmost bit of the procnum field is supposed to be set to 1 inr
    // order for the runtime to know if it is talking to the older stubs or
    // not.
    //

    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext ;
    memset ( pRpcMsg, 0, sizeof( RPC_MESSAGE ) );
    pRpcMsg->RpcInterfaceInformation = pProxyInfo->pStubDesc->
                                        RpcInterfaceInformation;

    // default transfer syntax 
    if ( pProxyInfo->pTransferSyntax )
        pRpcMsg->TransferSyntax = pProxyInfo->pTransferSyntax;
    else
        pRpcMsg->TransferSyntax = (PRPC_SYNTAX_IDENTIFIER)&NDR_TRANSFER_SYNTAX;
        
//#if !defined(__RPC_WIN64__)
    pRpcMsg->ProcNum = ProcNum | RPC_FLAGS_VALID_BIT;
//#endif    

    //
    // Initialize the Stub messsage fields.
    //

    memset( pStubMsg, 0, sizeof(MIDL_STUB_MESSAGE) );

    pStubMsg->RpcMsg = pRpcMsg;

    pStubMsg->StubDesc = pProxyInfo->pStubDesc;

    pStubMsg->pfnAllocate = pProxyInfo->pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pProxyInfo->pStubDesc->pfnFree;

    pStubMsg->dwDestContext = MSHCTX_DIFFERENTMACHINE;
    pStubMsg->pContext = pContext;
    pStubMsg->StackTop = pContext->StartofStack;

    pStubMsg->IsClient = TRUE;
    
    NdrSetupLowStackMark( pStubMsg );

    if ( pProxyInfo->pStubDesc->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pProxyInfo->pStubDesc->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.

    if ( pProxyInfo->pStubDesc->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ClientInitialize : Bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    // This is where we would need to deal with initializing StubMsg fields 
    // added after NT 5.1 release, if we added them.
}

inline void 
Ndr64ServerInitializeCommon(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor )
/*++

Routine Description :

    This routine is called by the server stubs before unmarshalling.
    It initializes the stub message fields.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure

Note :

    This is a core server-side initializer, called by everybody,
    pipes or not.

--*/
{
    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext ;   

    memset( pStubMsg, 0, sizeof( MIDL_STUB_MESSAGE ) );
    
    pStubMsg->dwDestContext = MSHCTX_DIFFERENTMACHINE;

    //
    // Set BufferStart and BufferEnd before unmarshalling.
    // Ndr64PointerFree uses these values to detect pointers into the
    // rpc message buffer.
    //
    pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
    pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;

    pStubMsg->pfnAllocate = pStubDescriptor->pfnAllocate;
    pStubMsg->pfnFree     = pStubDescriptor->pfnFree;
    pStubMsg->ReuseBuffer = FALSE;

    pStubMsg->StubDesc = pStubDescriptor;

    pStubMsg->RpcMsg = pRpcMsg;
    pStubMsg->Buffer = (uchar*)pRpcMsg->Buffer;
    pStubMsg->pContext = pContext;
    pStubMsg->StackTop = pContext->StartofStack;
    
    NdrSetupLowStackMark( pStubMsg );

    if ( pStubDescriptor->pMallocFreeStruct )
        {
        MALLOC_FREE_STRUCT *pMFS = pStubDescriptor->pMallocFreeStruct;

        NdrpSetRpcSsDefaults(pMFS->pfnAllocate, pMFS->pfnFree);
        }

    // This exception should be raised after initializing StubMsg.
    NdrRpcSetNDRSlot( pStubMsg );

    if ( pStubDescriptor->Version > NDR_VERSION )
        {
        NDR_ASSERT( 0, "ServerInitialize : bad version number" );

        RpcRaiseException( RPC_X_WRONG_STUB_VERSION );
        }

    // This is where we would need to deal with initializing StubMsg fields 
    // added after NT 5.1 release, if we added them.
}

void 
Ndr64ServerInitializePartial(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor,
    unsigned long           RequestedBufferSize )
/*++

Routine Description :

    This routine is called by the server stubs for pipes.
    It is almost identical to Ndr64ServerInitializeNew, except that
    it calls Ndr64pServerInitialize.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure
    pBuffer         - pointer to the beginning of the RPC message buffer

--*/
{
    Ndr64ServerInitializeCommon( pRpcMsg,
                                 pStubMsg,
                                 pStubDescriptor );

    // Last but not least...

    MakeSureWeHaveNonPipeArgs( pStubMsg, RequestedBufferSize );

}


unsigned char *
Ndr64ServerInitialize(
    PRPC_MESSAGE            pRpcMsg,
    PMIDL_STUB_MESSAGE      pStubMsg,
    PMIDL_STUB_DESC         pStubDescriptor
    )
/*++

Routine Description :

    This routine is called by the server stubs before unmarshalling.
    It initializes the stub message fields.

Aruguments :

    pStubMsg        - pointer to the stub message structure
    pStubDescriptor - pointer to the stub descriptor structure

Note.
    Ndr64ServerInitializeNew is almost identical to Ndr64ServerInitializePartial.
    Ndr64ServerInitializeNew is generated for non-pipes and is backward comp.
    Ndr64ServerInitializePartial is generated for routines with pipes args.

--*/
{
    Ndr64ServerInitializeCommon( pRpcMsg,
                                 pStubMsg,
                                 pStubDescriptor );

    if ( !(pRpcMsg->RpcFlags & RPC_BUFFER_COMPLETE ) )
        {
        // A non-pipe call with an incomplete buffer.
        // This can happen only for non-pipe calls in an interface that
        // has some pipe calls. 

        RPC_STATUS Status;

        pRpcMsg->RpcFlags = RPC_BUFFER_EXTRA;

        // The size argument is ignored, we will get everything.

        Status = I_RpcReceive( pRpcMsg, 0 );

        if ( Status != RPC_S_OK )
            {
            // This is the same behavior (and comment) as in MakeSure..
            //    routine above for non-pipe data case in a pipe call.
            // For this particular error case, i.e. a call to Receive to get 
            // all (non-pipe) data failing, we don't want to restore the 
            // original dispatch buffer into the rpc message.
            // In case of an error the buffer coming back here would be 0.
            //
            RpcRaiseException( Status );
            }

        NDR_ASSERT( 0 == pRpcMsg->BufferLength ||
                    NULL != pRpcMsg->Buffer,
                    "Rpc runtime returned an invalid buffer.");

        // In case this is a new buffer

        pStubMsg->Buffer      = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferStart = (uchar*)pRpcMsg->Buffer;
        pStubMsg->BufferEnd   = pStubMsg->BufferStart + pRpcMsg->BufferLength;
        }

    return 0;
}


unsigned char *
Ndr64GetBuffer(
    PMIDL_STUB_MESSAGE      pStubMsg,
    unsigned long           BufferLength )
/*++

Routine Description :

    Performs an RpcGetBuffer.

Arguments :

    pStubMsg        - Pointer to stub message structure.
    BufferLength    - Length of requested rpc message buffer.
    Handle          - Bound handle.

--*/
{
    RPC_STATUS    Status;

    LENGTH_ALIGN( BufferLength, 3 );
    pStubMsg->RpcMsg->BufferLength = BufferLength;

    Status = I_RpcGetBuffer( pStubMsg->RpcMsg );

    if ( Status )
        {
        // For raw rpc, if async, don't call abort later.

        if ( pStubMsg->pAsyncMsg )
            pStubMsg->pAsyncMsg->Flags.RuntimeCleanedUp = 1;

        RpcRaiseException( Status );
        }

    NDR_ASSERT( 0 == BufferLength ||
                NULL != pStubMsg->RpcMsg->Buffer,
                "Rpc runtime returned an invalid buffer.");

    NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}


unsigned char *
Ndr64NsGetBuffer( PMIDL_STUB_MESSAGE    pStubMsg,
                unsigned long         BufferLength )
/*++
Routine Description :

    Performs an RpcNsGetBuffer.
    Will load the RpcNs4 DLL if not already loaded

Arguments :

    pStubMsg        - Pointer to stub message structure.
    BufferLength    - Length of requested rpc message buffer.
    Handle          - Bound handle

--*/
{
    RPC_STATUS    Status;

    EnsureNSLoaded();

    LENGTH_ALIGN( BufferLength, 3 );
    pStubMsg->RpcMsg->BufferLength = BufferLength;

    Status = (*pRpcNsGetBuffer)( pStubMsg->RpcMsg );

    if ( Status )
        RpcRaiseException( Status );

    NDR_ASSERT( ! ((ULONG_PTR)pStubMsg->RpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned" );

    pStubMsg->Buffer = (uchar *) pStubMsg->RpcMsg->Buffer;
    pStubMsg->fBufferValid = TRUE;

    return pStubMsg->Buffer;
}

void
Ndr64pInitUserMarshalCB(
    MIDL_STUB_MESSAGE *pStubMsg,
    NDR64_USER_MARSHAL_FORMAT *    pUserFormat,
    USER_MARSHAL_CB_TYPE CBType,
    USER_MARSHAL_CB   *pUserMarshalCB
    )
/*++

Routine Description :

    Initialize a user marshall callback structure.
    
Arguments :

    pStubMsg         - Supplies the stub message for the call.
    pFormat          - Supplies the format string for the type(FC64_USER_MARSHAL). 
    CBType           - Supplies the callback type.   
    pUserMarshalCB   - Pointer to the callback to be initialized.

Return :

    None.

--*/
{

    pUserMarshalCB->Flags    = USER_CALL_CTXT_MASK( pStubMsg->dwDestContext );
    if ( USER_MARSHAL_CB_UNMARSHALL == CBType )
        {
        pUserMarshalCB->Flags |=
            (((pStubMsg->RpcMsg->DataRepresentation & (ulong)0x0000FFFF)) << 16 );  
        }
    if ( pStubMsg->pAsyncMsg )
        pUserMarshalCB->Flags |= USER_CALL_IS_ASYNC;
    if ( pStubMsg->fHasNewCorrDesc )
        pUserMarshalCB->Flags |= USER_CALL_NEW_CORRELATION_DESC;
    
    pUserMarshalCB->pStubMsg = pStubMsg;
    pUserMarshalCB->pReserve = ( pUserFormat->Flags & USER_MARSHAL_IID)  ? 
                                        (PFORMAT_STRING)pUserFormat + sizeof( NDR64_USER_MARSHAL_FORMAT )
                                        : 0;
    pUserMarshalCB->Signature = USER_MARSHAL_CB_SIGNATURE;
    pUserMarshalCB->CBType = CBType;

    pUserMarshalCB->pFormat = ( PFORMAT_STRING )pUserFormat;
    pUserMarshalCB->pTypeFormat = (PFORMAT_STRING)pUserFormat->TransmittedType;

}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\cltcall.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 - 2000 Microsoft Corporation

Module Name :

    cltcall.c

Abstract :

    This file contains the single call Ndr64 routine for the client side.

Author :

    David Kays    dkays    October 1993.

Revision History :

    brucemc     11/15/93    Added struct by value support, corrected
                            varargs use.
    brucemc     12/20/93    Binding handle support
    ryszardk    3/12/94     handle optimization and fixes

---------------------------------------------------------------------*/
#include "precomp.hxx"

#define CINTERFACE
#define USE_STUBLESS_PROXY

#include <stdarg.h>
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"

#include "ndrole.h"
#include "rpcproxy.h"

#pragma code_seg(".ndr64")

#define NDR_MAX_RESEND_COUNT    5

#define WIN32RPC
#include "rpcerrp.h"


void
Ndr64ClearOutParameters(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    uchar *             pArg
    )
/*++

Routine Description :

    Free and clear an [out] parameter in case of exceptions for object
    interfaces.

Arguments :

    pStubMsg    - pointer to stub message structure
    pFormat     - The format string offset
    pArg        - The [out] pointer to clear.

Return :

    NA

Notes:

--*/
{
    const NDR64_POINTER_FORMAT *pPointerFormat = 
        (const NDR64_POINTER_FORMAT*)pFormat;
    PFORMAT_STRING pPointee = (PFORMAT_STRING)pPointerFormat->Pointee;

    if( pStubMsg->dwStubPhase != PROXY_UNMARSHAL)
        return;

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    NDR64_UINT32 Size = 0;
    uchar *pArgSaved = pArg;

    //
    // Look for a non-Interface pointer.
    //
    if ( NDR64_IS_BASIC_POINTER(*(PFORMAT_STRING)pFormat) )
        {
        // Pointer to a basetype.
        if ( NDR64_SIMPLE_POINTER(pPointerFormat->Flags) )
            {
            //
            // It seems wierd to zero an [out] pointer to a basetypes, but this
            // is what we did in NT 3.5x and I wouldn't be surprised if
            // something broke if we changed this behavior.
            //
            Size = NDR64_SIMPLE_TYPE_MEMSIZE( *pPointee );
            goto DoZero;
            }

        // Pointer to a pointer.
        if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
            {
            Size = PTR_MEM_SIZE;
            pArg = *((uchar **)pArg);
            }

        // context handle is not allowed in DCOM interface so I don't think
        // we need the check here (for both DCE & NDR64). we can get 
        // rid of this code in Longhorn. yongqu
        if ( *(PFORMAT_STRING)pFormat == FC64_BIND_CONTEXT )
            {
            *((NDR_CCONTEXT *)pArg) = (NDR_CCONTEXT) 0;
            return;
            }

        pFormat = pPointee;
        }

    // We have a pointer to complex type.
    Ndr64ToplevelTypeFree( pStubMsg,
                           pArg,
                           pFormat );

    if ( ! Size )
        {
        Size = Ndr64pMemorySize( pStubMsg,
                                 pFormat,
                                 FALSE );
        }

DoZero:

    MIDL_memset( pArgSaved, 0, (size_t)Size );
}


__forceinline void 
Ndr64pGetBuffer( void * pThis, 
                 MIDL_STUB_MESSAGE * pStubMsg,
                 NDR_PROC_CONTEXT *  pContext )
{
    if ( pThis )
        NdrProxyGetBuffer( pThis,
                           pStubMsg );
    else
        {
        if ( pContext->HandleType != FC64_AUTO_HANDLE )
            {
            Ndr64GetBuffer( pStubMsg,
                          pStubMsg->BufferLength );
            }
        else
            Ndr64NsGetBuffer( pStubMsg,
                          pStubMsg->BufferLength );

        // We only need to save the stubmsg in sync interfaces. 
        // In the client side, runtime tls would be available AFTER call
        // to runtime, it might be after I_RpcNegotiateTransferSyntax or 
        // GetBuffer, and we are sure the slot is available now.
        }

    NdrRpcSetNDRSlot( pStubMsg );
}

__forceinline void 
Ndr64pSendReceive( void * pThis,
                   MIDL_STUB_MESSAGE * pStubMsg,
                   NDR_PROC_CONTEXT  * pContext )
{
    if ( pContext->HasPipe )
        NdrPipeSendReceive( pStubMsg, pContext->pPipeDesc );
    else
        {
        if ( pThis )
            NdrProxySendReceive( pThis, pStubMsg );
        else
            if ( pContext->HandleType != FC64_AUTO_HANDLE )
                NdrSendReceive( pStubMsg, pStubMsg->Buffer );
            else
                NdrNsSendReceive( pStubMsg,
                                  pStubMsg->Buffer,
                                  (RPC_BINDING_HANDLE*) pStubMsg->StubDesc
                                    ->IMPLICIT_HANDLE_INFO.pAutoHandle );
        }
}


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrClientCall3(
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    ulong                       nProcNum,
    void                       *pReturnValue,
    ...
    )
/*
    This routine is called from the object stubless proxy dispatcher.
*/
{
    va_list                     ArgList;
    RPC_STATUS                  res = RPC_S_OK;
    NDR_PROC_CONTEXT            ProcContext;

    INIT_ARG( ArgList, pReturnValue );
    GET_FIRST_IN_ARG(ArgList);
    uchar * StartofStack = (uchar *)GET_STACK_START(ArgList);

    Ndr64ClientInitializeContext( NdrpGetSyntaxType( pProxyInfo->pTransferSyntax),
                                  pProxyInfo,
                                  nProcNum,
                                 &ProcContext,
                                  StartofStack );


    // call_as routines in ORPC interface come through here also.
    return NdrpClientCall3(  ProcContext.IsObject ? *(void **)StartofStack : NULL, 
                            pProxyInfo, 
                            nProcNum, 
                            pReturnValue,
                            &ProcContext,
                            StartofStack );
}

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall3(
    void *                      pThis,
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    ulong                       nProcNum,
    void                       *pReturnValue,
    NDR_PROC_CONTEXT        *   pContext,
    uchar *                     StartofStack
    )
{

    RPC_MESSAGE                 RpcMsg;
    MIDL_STUB_MESSAGE           StubMsg;
    PMIDL_STUB_MESSAGE          pStubMsg = &StubMsg;
    CLIENT_CALL_RETURN          ReturnValue;

    ReturnValue.Pointer = 0;

    if ( NULL == pReturnValue )
        pReturnValue = &ReturnValue;

    //
    // Wrap everything in a try-finally pair. The finally clause does the
    // required freeing of resources (RpcBuffer and Full ptr package).
    //
    RpcTryFinally
        {
        //
        // Use a nested try-except pair to support OLE. In OLE case, test the
        // exception and map it if required, then set the return value. In
        // nonOLE case, just reraise the exception.
        //
        RpcTryExcept
            {

            // client initialization and syntax negotiation.
            Ndr64pClientSetupTransferSyntax(pThis, 
                           &RpcMsg,
                           pStubMsg,
                           pProxyInfo,
                           pContext,
                           nProcNum );

            ( * pContext->pfnInit) ( pStubMsg, 
                                pReturnValue );

            ( * pContext->pfnSizing) ( pStubMsg,
                                       TRUE );    // isclient
            
            //
            // Do the GetBuffer.
            //

            Ndr64pGetBuffer( pThis, &StubMsg, pContext );
            

            NDR_ASSERT( StubMsg.fBufferValid, "Invalid buffer" );

            (* pContext->pfnMarshal) (&StubMsg,
                                     ( pThis != NULL ) );   // isobject


            //
            // Make the RPC call.
            //


            Ndr64pSendReceive( pThis, &StubMsg, pContext ) ;

            ( * pContext->pfnUnMarshal )( &StubMsg,
                                 pContext->HasComplexReturn
                                        ? &pReturnValue
                                        : pReturnValue );
                                
            }       
        RpcExcept( EXCEPTION_FLAG )
            {

            RPC_STATUS ExceptionCode = RpcExceptionCode();
            NDR_ASSERT( pContext->NeedsResend == FALSE, "resend flag should be false here" );

            // fail after some retries.
            if ( ExceptionCode == RPC_P_TRANSFER_SYNTAX_CHANGED && 
                 ( pContext->ResendCount < NDR_MAX_RESEND_COUNT ) &&
                 ( pProxyInfo->nCount > 1 ) ) 
                {
                // we'll retry only if: 
                // . runtime returns changed syntax error code
                // . client support multiple transfer syntax
                // . we retried less than the max retried number
                pContext->ResendCount ++;
                pContext->NeedsResend = TRUE;
                }
            else
                (pContext->pfnExceptionHandling) ( pStubMsg,
                                             nProcNum,
                                             ExceptionCode,
                                             &ReturnValue );
            }
        RpcEndExcept
        }
    RpcFinally
        {

        (pContext->pfnClientFinally )(  pStubMsg,
                                        pThis );

        // recurse back if resend is needed. we are very much making a new call again because runtime doesn't
        // know which tranfer syntax the new server supports when the previous negotiated transfer syntax failes.
        if ( pContext->NeedsResend )
            NdrpClientCall3( pThis, pProxyInfo, nProcNum, pReturnValue, pContext, StartofStack );
        }
    RpcEndFinally

    return ReturnValue;
}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\expr.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    expr.cxx

Abstract :

    This file contains the ndr expression evaluation and correlation
    check routines.

Author :

    Yong Qu     (yongqu)    Jan 2000
    Mike Zoran  (mzoran)    Jan 2000

Revision History :

---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"
#include "asyncu.h"
       
extern "C" {
extern const GUID CLSID_RpcHelper;
}

typedef void ( * PFNNDR64CHECKCORRELATION )(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  );

static const PFNNDR64CHECKCORRELATION pfnCorrCheck[] = 
{
    Ndr64pLateCheckCorrelation,
    Ndr64pEarlyCheckCorrelation,
    Ndr64pNoCheckCorrelation,
    Ndr64pNoCheckCorrelation
};

EXPR_VALUE 
Ndr64pExprGetVar( PMIDL_STUB_MESSAGE pStubMsg,
                  PNDR64_FORMAT pFormat,
                  PNDR64_FORMAT * pNext )
{
    NDR64_EXPR_VAR * pExpr = (NDR64_EXPR_VAR *)pFormat;

    NDR_ASSERT( pExpr->ExprType == FC_EXPR_VAR, "must be a variable!");
    
    uchar *pCount = pStubMsg->pCorrMemory + (long)pExpr->Offset;

    EXPR_VALUE Value = 
        Ndr64pSimpleTypeToExprValue( pExpr->VarType,
                                       pCount ); 

    *pNext = 
        (PNDR64_FORMAT)((PFORMAT_STRING)pFormat + sizeof( NDR64_EXPR_VAR ));
    
    return Value;
}

EXPR_VALUE EvaluateExpr( PMIDL_STUB_MESSAGE pStubMsg, 
                         PNDR64_FORMAT pFormat,
                         PNDR64_FORMAT * pNext );



EXPR_VALUE 
Ndr64CalculateExpr( PMIDL_STUB_MESSAGE pStubMsg,
                    NDR64_EXPR_OPERATOR * pExpr,
                    PNDR64_FORMAT *pNext )
{
    EXPR_VALUE   Value, LeftValue, RightValue ;
    PNDR64_FORMAT pTempNext;
    BOOL    fRational;

    switch ( pExpr->Operator )
        {
        case OP_UNARY_PLUS:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext );
            Value = +Value;
            break;

        case OP_UNARY_MINUS:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = -Value;
            break;

        case OP_UNARY_NOT:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = !Value;
            break;
            
        case OP_UNARY_COMPLEMENT:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = ~Value;
            break;
            
        case OP_UNARY_CAST:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = Ndr64pCastExprValueToExprValue( pExpr->CastType, Value );
            break;

        case OP_UNARY_AND:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = ~Value;
            break;

        case OP_UNARY_SIZEOF:
            NDR_ASSERT(0 , "Ndr64CalculateExpr : OP_UNARY_SIZEOF is invalid\n");
            return 0;
            break;

        case OP_UNARY_INDIRECTION:
            Value = Ndr64pExprGetVar( pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext );
            Value = Ndr64pSimpleTypeToExprValue( pExpr->CastType,
                                                 (uchar*)Value );             
            break;
            
        case OP_PRE_INCR:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = ++Value;
            break;
            
        case OP_PRE_DECR:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = --Value;
            break;
            
        case OP_POST_INCR:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = Value++;
            break;
            
        case OP_POST_DECR:
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            Value = Value--;
            break;
            

        case OP_PLUS:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue + RightValue;
            break;
            
        case OP_MINUS:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue - RightValue;
            break;
            
        case OP_STAR:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue * RightValue;
            break;           
        
        case OP_SLASH:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = (EXPR_VALUE) (LeftValue / RightValue);
            break;
            
        case OP_MOD:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue % RightValue;
            break;
                  
        case OP_LEFT_SHIFT:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue << RightValue;
            break;
            
        case OP_RIGHT_SHIFT:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue >> RightValue;
            break;
            
        case OP_LESS:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue < RightValue;
            break;
            
        
        case OP_LESS_EQUAL:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue <= RightValue;
            break;
            
        case OP_GREATER_EQUAL:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue >= RightValue;
            break;
            
        case OP_GREATER:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue > RightValue;
            break;
            
        case OP_EQUAL:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue == RightValue;
            break;
            
        case OP_NOT_EQUAL:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue != RightValue;
            break;
            

        case OP_AND:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue & RightValue;
            break;
            
        case OP_OR:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue | RightValue;
            break;
            
        case OP_XOR:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue ^ RightValue;
            break;
            
        case OP_LOGICAL_AND:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue && RightValue;
            break;
            
        case OP_LOGICAL_OR:
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = LeftValue || RightValue;
            break;
            
 
        case OP_QM:   
            LeftValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), &pTempNext  );
            RightValue = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , &pTempNext  );
            fRational = ( BOOL ) EvaluateExpr(pStubMsg, (PFORMAT_STRING )pTempNext , pNext  );
            Value = fRational ? LeftValue : RightValue;
            break;
            
        case OP_ASYNCSPLIT:
            {
            PNDR_DCOM_ASYNC_MESSAGE pAsyncMsg =  
                (PNDR_DCOM_ASYNC_MESSAGE) pStubMsg->pAsyncMsg;
            CORRELATION_CONTEXT CorrCtxt( pStubMsg, pAsyncMsg->BeginStack );
            Value = EvaluateExpr(pStubMsg, (PFORMAT_STRING )pExpr + sizeof( NDR64_EXPR_OPERATOR ), pNext  );
            break;
            }

        case OP_CORR_POINTER:
            pStubMsg->pCorrMemory = pStubMsg->Memory;
            break;

        case OP_CORR_TOP_LEVEL:
            pStubMsg->pCorrMemory = pStubMsg->StackTop;
            break;

        default:
            NDR_ASSERT(0 ,
                   "Ndr64CalculateExpr : invalid operator");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            break;
            
        }

    return Value;
}

EXPR_VALUE
EvaluateExpr( PMIDL_STUB_MESSAGE pStubMsg, 
              PNDR64_FORMAT pFormat,
              PNDR64_FORMAT  * pNext )
{
    EXPR_VALUE Value;
    
    switch ( *(PFORMAT_STRING)pFormat )
        {
        case FC_EXPR_NOOP:
            {
            PFORMAT_STRING pContinueFormat =
                ((PFORMAT_STRING)pFormat) + (( NDR64_EXPR_NOOP *)pFormat )->Size;
            Value = EvaluateExpr( pStubMsg, (PNDR64_FORMAT)pContinueFormat, pNext );
            break;
            }
            
        case FC_EXPR_CONST32:
            {
            NDR64_EXPR_CONST32 *pExpr = ( NDR64_EXPR_CONST32 *) pFormat;
            Value = (EXPR_VALUE) pExpr->ConstValue;
            *pNext = (PNDR64_FORMAT)(pExpr + 1);
            break;
            }
        case FC_EXPR_CONST64:
            {
            NDR64_EXPR_CONST64 *pExpr;
            pExpr = ( NDR64_EXPR_CONST64 * )pFormat;
            Value = (EXPR_VALUE) pExpr->ConstValue;
            *pNext = (PNDR64_FORMAT)(pExpr + 1);
            break;
            }
        case FC_EXPR_VAR:
            {
            NDR64_EXPR_VAR * pExpr = ( NDR64_EXPR_VAR * )pFormat;
            Value = Ndr64pExprGetVar( pStubMsg, pFormat, pNext );     // indirection. 
            break;
            }
        case FC_EXPR_OPER:
            {
            Value = Ndr64CalculateExpr( pStubMsg, ( NDR64_EXPR_OPERATOR * )pFormat, pNext );
            break;
            }
        default:
            NDR_ASSERT(0 ,
                   "Ndr64pComputeConformance : no expr eval routines");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            break;
        }
    return Value;
}


EXPR_VALUE   
Ndr64EvaluateExpr(
    PMIDL_STUB_MESSAGE  pStubMsg,
//    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType )
{   
    PNDR64_FORMAT pNext;
    EXPR_VALUE Value;
    
    NDR_ASSERT( pStubMsg->pCorrMemory, "Ndr64EvaluateExpr: pCorrMemory not initialized." );

    // we don't need to care about correlation flag in evaluation
    PFORMAT_STRING pActualFormat =
        ((PFORMAT_STRING)pFormat) + sizeof( NDR64_UINT32 );

    Value = EvaluateExpr( pStubMsg, (PNDR64_FORMAT)pActualFormat, &pNext );

    switch ( ExpressionType )
        {
        case EXPR_MAXCOUNT:
            pStubMsg->MaxCount = (ULONG_PTR)Value;
            break;
        case EXPR_ACTUALCOUNT:
            pStubMsg->ActualCount = ( unsigned long )Value;
            break;
        case EXPR_OFFSET:
            pStubMsg->Offset = ( unsigned long )Value;
            break;
        }

    return Value;
}

void
Ndr64pAddCorrelationData( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    EXPR_VALUE          Value,
    NDR64_EXPRESSION_TYPE                 CheckKind 
    )
/* 
    Adds a check data to the correlation data base for a later evaluation.
*/  
{
    PNDR64_CORRELATION_INFO  pCorrInfo = (PNDR64_CORRELATION_INFO)pStubMsg->pCorrInfo;

    if ( !pCorrInfo || NDR64_SLOTS_PER_CORRELATION_INFO == pCorrInfo->SlotsUsed )
        {
        NDR_PROC_CONTEXT *pProcContext = (NDR_PROC_CONTEXT*)pStubMsg->pContext;

        PNDR64_CORRELATION_INFO pCorrInfoNew = (PNDR64_CORRELATION_INFO)
            NdrpAlloca(&pProcContext->AllocateContext, sizeof(NDR64_CORRELATION_INFO));

        pCorrInfoNew->pNext     = pCorrInfo;
        pCorrInfoNew->SlotsUsed = 0;
        pCorrInfo = pCorrInfoNew;
        pStubMsg->pCorrInfo = (PNDR_CORRELATION_INFO)pCorrInfo;
        }

    NDR64_UINT32 CurrentSlot = pCorrInfo->SlotsUsed;

    pCorrInfo->Data[ CurrentSlot ].pMemoryObject = pMemory; 
    pCorrInfo->Data[ CurrentSlot ].Value         = Value; 
    pCorrInfo->Data[ CurrentSlot ].pCorrDesc     = pFormat; 
    pCorrInfo->Data[ CurrentSlot ].CheckKind     = CheckKind;

    pCorrInfo->SlotsUsed++;
}

RPCRTAPI
void
RPC_ENTRY
Ndr64CorrelationPass( 
    PMIDL_STUB_MESSAGE  pStubMsg
    )
/* 
    Walks the data base to check all the correlated values that could not be checked 
    on fly.
*/  
{
    
    if ( !pStubMsg->pCorrInfo )
        {
        return;
        }

    for( PNDR64_CORRELATION_INFO  pCorrInfo = (PNDR64_CORRELATION_INFO)pStubMsg->pCorrInfo;
         NULL != pCorrInfo;
         pCorrInfo = pCorrInfo->pNext )
        {

        for(NDR64_UINT32 SlotNumber = 0; SlotNumber < pCorrInfo->SlotsUsed; SlotNumber++)
            {

            CORRELATION_CONTEXT CorrCtxt( pStubMsg, pCorrInfo->Data[ SlotNumber ].pMemoryObject );
            
            // we must check now.
            Ndr64pEarlyCheckCorrelation( pStubMsg,
                                     pCorrInfo->Data[ SlotNumber ].Value,
                                     pCorrInfo->Data[ SlotNumber ].pCorrDesc,
                                     (NDR64_EXPRESSION_TYPE)pCorrInfo->Data[ SlotNumber ].CheckKind );
            }

        }
    
}

// no-check flag is set.
void Ndr64pNoCheckCorrelation( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE  ExpressionType  )
{
    return;
}

void Ndr64pEarlyCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  )
{
    EXPR_VALUE  ExprValue ;
    EXPR_VALUE  DestValue = Value;
    BOOL        fCheckOk; 
    
    ExprValue = Ndr64EvaluateExpr( pStubMsg, pFormat, ExpressionType );
    fCheckOk = ( DestValue == ExprValue );

    if ( !fCheckOk && ( ExpressionType == EXPR_IID ) )
        {
        IID * piidValue = (IID *)ExprValue;
        IID * piidArg   = (IID *)DestValue;
        
        fCheckOk = !memcmp( piidValue, piidArg, sizeof( IID )) ;
        }

    if ( !fCheckOk )
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        
    return;
}

void Ndr64pLateCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  )
{
    Ndr64pAddCorrelationData( pStubMsg, pStubMsg->pCorrMemory, pFormat, Value, ExpressionType );
    return;
}

void 
Ndr64pCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  )
{
    NDR64_UINT32 Flags;

    Flags = * (NDR64_UINT32 *)pFormat;
    ASSERT(  Flags <= ( FC_NDR64_EARLY_CORRELATION | FC_NDR64_NOCHECK_CORRELATION ) );

    pfnCorrCheck[Flags]( pStubMsg, Value, pFormat, ExpressionType );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\global.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993 Microsoft Corporation

Module Name :

    global.cxx

Abtract :

    Contains some global variable declarations for the NDR library.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

#include "precomp.hxx"

extern "C"
{

#define NDR64_BEGIN_TABLE  \
extern const unsigned char Ndr64SimpleTypeBufferSize[] = \
{                                                          

#define NDR64_TABLE_END    \
};                         

#define NDR64_ZERO_ENTRY   0
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,0
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,0

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,0                      

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,buffersize   
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64SimpleTypeBufferSize)/sizeof(char) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY

#define NDR64_BEGIN_TABLE  \
extern const unsigned char Ndr64SimpleTypeMemorySize[] = \
{                                                  

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,memorysize
   
#include "tokntbl.h"
   
C_ASSERT( sizeof(Ndr64SimpleTypeMemorySize)/sizeof(char) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY

#define NDR64_BEGIN_TABLE  \
extern const unsigned long Ndr64TypeFlags[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
    ,typeflags
    
#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
    ,_SIMPLE_TYPE_
    
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64TypeFlags)/sizeof(unsigned long) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_END
#undef NDR64_ZERO_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY
#undef NDR64_UNUSED_TABLE_ENTRY_NOSYM
#undef NDR64_TABLE_ENTRY
#undef NDR64_SIMPLE_TYPE_TABLE_ENTRY

#define NDR64_BEGIN_TABLE
#define NDR64_TABLE_END
#define NDR64_ZERO_ENTRY
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) C_ASSERT( (number) == (tokenname) ); 
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number )
#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
    C_ASSERT( (number) == (tokenname) );
#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
    C_ASSERT( (number) == (tokenname) );        \
    C_ASSERT( (buffersize) == (memorysize) );
                                              
#include "tokntbl.h"

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\free.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993  - 1999 Microsoft Corporation

Module Name :

    free.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the 
    interpreter for freeing unmarshalled data on the server. 

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"

__forceinline void
Ndr64FreeTypeMemory( 
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory )
{

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {
        (*pStubMsg->pfnFree)(pMemory);
        return;
        }
    
    NDR_PFNFREE_POINTER_QUEUE_ELEMENT*pElement = 
        new(pStubMsg->pPointerQueueState) 
            NDR_PFNFREE_POINTER_QUEUE_ELEMENT(pStubMsg->pfnFree,
                                              pMemory );
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
}

NDR64_FREE_POINTER_QUEUE_ELEMENT::NDR64_FREE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :
        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        uFlags(pStubMsg->uFlags),
        pCorrMemory(pStubMsg->pCorrMemory)
{

}

void 
NDR64_FREE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );
    CORRELATION_CONTEXT CorrContext( pStubMsg, pCorrMemory );
    
    Ndr64ToplevelTypeFree( pStubMsg,
                           pMemory,
                           pFormat );
}

#if defined(DBG)
void 
NDR64_FREE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_FREE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("uFlags:                  %x\n", uFlags );
    DbgPrint("pCorrMemory:             %p\n", pCorrMemory );
}
#endif

void
Ndr64EnquePointeeFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {

        NDR64_FREE_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR64_FREE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                 (uchar*)pMemory,
                                                 (PFORMAT_STRING)pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

__forceinline void
Ndr64PointeeFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    if ( !NdrIsLowStack( pStubMsg ) )
        {
        Ndr64ToplevelTypeFree( pStubMsg,
                               pMemory,
                               pFormat );
        return;
        }

    Ndr64EnquePointeeFree( 
        pStubMsg,
        pMemory,
        pFormat );

}

void
Ndr64pNoopFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    return;
}



__forceinline void 
Ndr64PointerFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a top level or embedded pointer to anything.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;
    uchar *         pMemoryPointee = pMemory;

    if ( ! pMemory )
        return;

    if ( *(PFORMAT_STRING)pFormat == FC64_IP )
        {
        ((IUnknown *)pMemory)->Release();
        return;
        }

    if ( *(PFORMAT_STRING)pFormat == FC64_FP )
        {
        //
        // Check if we've already freed this full pointer.
        //
        if ( ! NdrFullPointerFree( pStubMsg->FullPtrXlatTables,
                                   pMemory ) )
            return;
        }

    if ( 0 == pPointerFormat->Flags )
        goto FreeEmbeddedPointers;  

    //
    // Check if this pointer and any possible embedded pointers should not
    // be freed.
    //
    if ( NDR64_DONT_FREE( pPointerFormat->Flags) )
        return;

    // 
    // Just go free a pointer to a simple type.
    //
    if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) ) 
        goto FreeTopPointer;

    // 
    // Check if this is an allocate all nodes pointer.  
    // IDL symantics say that we only free the top most allocate all nodes
    // pointer on the server even in the [out] only case.  So jump to the 
    // check for the pointer free at the end of the routine.  
    //  
    if ( NDR64_ALLOCATE_ALL_NODES( pPointerFormat->Flags ) )
        goto FreeTopPointer;

    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        pMemoryPointee = *((uchar **)pMemory);

FreeEmbeddedPointers:


    Ndr64PointeeFree( pStubMsg,
                      pMemoryPointee,
                      pPointerFormat->Pointee );

FreeTopPointer:

    //
    // Now free the pointer.  Pointer guaranteed to be non-null here.
    //
    // We only free the pointer if it lies outside of the message buffer
    // that the server stub received from the RPC runtime. Otherwise we
    // used the RPC buffer to hold the pointer's data and should not free it.
    //
    if ( (pMemory < pStubMsg->BufferStart) || (pMemory > pStubMsg->BufferEnd) )
        {
        //
        // Also check to make sure that the pointer was not allocated on the
        // server stub's stack (this may happen for ref pointers).
        //
        // full pointer can't be allocated on stack
        if ( ! NDR64_ALLOCED_ON_STACK( pPointerFormat->Flags ) || 
             *(PFORMAT_STRING)pFormat == FC64_FP )
            {
            Ndr64FreeTypeMemory( pStubMsg, pMemory );
            }
        }
}


__forceinline void
Ndr64TopLevelPointerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a top level or embedded pointer to anything.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    Ndr64PointerFree( pStubMsg,
                      pMemory,
                      pFormat );

}

__forceinline void
Ndr64EmbeddedPointerFree(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )

{
    Ndr64PointerFree( pStubMsg,
                      *(uchar**)pMemory,
                      pFormat );
}


void 
Ndr64pRangeFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++
--*/
{
    return;
}


void 
Ndr64SimpleStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a simple structure's embedded pointers which were allocated during 
    a remote call.  

    Used for FC64_STRUCT and FC64_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;

    if ( !pMemory || !pStructFormat->Flags.HasPointerInfo ) 
        return;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pStructFormat + 1,
                             0,
                             pMemory );
}


void 
Ndr64ConformantStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a conformant structure's embedded pointers which were allocated 
    during a remote call.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.
    
--*/
{
    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =  
        (NDR64_CONF_ARRAY_HEADER_FORMAT *) pStructFormat->ArrayDescription;

    if ( !pMemory || !pStructFormat->Flags.HasPointerInfo )
        return;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    NDR64_UINT32 MaxCount = (NDR64_UINT32)
    Ndr64EvaluateExpr( pStubMsg,
                       pArrayFormat->ConfDescriptor,
                       EXPR_MAXCOUNT );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pStructFormat + 1,
                             MaxCount,
                             pMemory );
}


void 
Ndr64ComplexStructFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a complex structure's embedded pointers which were allocated during 
    a remote call.  

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING)(pStructFormat->PointerLayout );

    PFORMAT_STRING  pFormatArray = NULL;

    PFORMAT_STRING  pMemberLayout = ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                      *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                    (PFORMAT_STRING)( pConfStructFormat + 1) :
                                    (PFORMAT_STRING)( pStructFormat + 1);
    
    if ( !pMemory )
        return;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
    
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;
        }

    for ( ; ; )
        {
        switch ( *pMemberLayout )
            {

            case FC64_STRUCT:
                {
                const NDR64_SIMPLE_REGION_FORMAT *pRegion = 
                    (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;
                
                pMemory          += pRegion->RegionSize;

                pMemberLayout    += sizeof( *pRegion );
                break;
                }
            
            case FC64_STRUCTPADN :
                {
                const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
                pMemory       += pMemPad->MemPad;
                pMemberLayout += sizeof(*pMemPad);
                break;
                }

            case FC64_POINTER :
                Ndr64EmbeddedPointerFree( pStubMsg,
                                          pMemory,
                                          pFormatPointers );

                pMemory += PTR_MEM_SIZE;

                pFormatPointers += sizeof(NDR64_POINTER_FORMAT);                
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                
                break;

            case FC64_EMBEDDED_COMPLEX :
                
                {

                const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                    (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                Ndr64EmbeddedTypeFree( pStubMsg,
                                       pMemory,
                                       pEmbeddedFormat->Type );

                pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                                 pMemory,
                                                 pEmbeddedFormat->Type,
                                                 FALSE );

                pMemberLayout += sizeof( *pEmbeddedFormat );

                break;
                }

            case FC64_BUFFER_ALIGN:
                {
                const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign = 
                    (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                pMemberLayout += sizeof( *pBufAlign );
                break;
                }

             case FC64_CHAR :
             case FC64_WCHAR :
             case FC64_INT8:
             case FC64_UINT8:
             case FC64_INT16:
             case FC64_UINT16:
             case FC64_INT32:
             case FC64_UINT32:
             case FC64_INT64:
             case FC64_UINT64:
             case FC64_FLOAT32 :
             case FC64_FLOAT64 :
             case FC64_ERROR_STATUS_T:
                pMemory       += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);
                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;
                        
            case FC64_IGNORE :
                pMemory             += PTR_MEM_SIZE;
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;
            
            case FC64_END :
                goto ComplexFreeEnd;

            default :
                NDR_ASSERT(0,"Ndr64ComplexStructFree : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            } // switch
        } // for

ComplexFreeEnd :

    if ( pFormatArray )
        {

        Ndr64EmbeddedTypeFree( pStubMsg,
                               pMemory,
                               pFormatArray );
        }
}


void 
Ndr64FixedArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a fixed array's embedded pointers which were allocated during 
    a remote call.  

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;
    
    if ( ! pMemory || !pArrayFormat->Flags.HasPointerInfo ) 
        return;
    
    Ndr64pPointerLayoutFree( pStubMsg,
                             pArrayFormat + 1,
                             0,
                             pMemory );

}


void 
Ndr64ConformantArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a one dimensional conformant array's embedded pointers which were 
    allocated during a remote call.  Called for both top level and embedded
    conformant arrays.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;
    
    if ( ! pMemory || !pArrayFormat->Flags.HasPointerInfo ) 
        return;

    NDR64_UINT32 MaxCount = (NDR64_UINT32)
    Ndr64EvaluateExpr( pStubMsg,
                       pArrayFormat->ConfDescriptor,
                       EXPR_MAXCOUNT );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pArrayFormat + 1,
                             MaxCount,
                             pMemory );
        
}


void 
Ndr64ConformantVaryingArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a one dimensional conformant varying array's embedded pointers which 
    were allocated during a remote call.  Called for both top level and 
    embedded conformant varying arrays.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    if ( ! pMemory || !pArrayFormat->Flags.HasPointerInfo) 
        return;
    
    NDR64_UINT32 ActualCount = (NDR64_UINT32)
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->VarDescriptor,
                           EXPR_ACTUALCOUNT );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pArrayFormat + 1,
                             ActualCount,
                             pMemory );
}


void 
Ndr64VaryingArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a varying array's embedded pointers which were allocated 
    during a remote call.  Called for both top level and embedded varying
    arrays.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;
    
    if ( ! pMemory || !pArrayFormat->Flags.HasPointerInfo) 
        return;

    NDR64_UINT32 ActualCount = (NDR64_UINT32)
    Ndr64EvaluateExpr( pStubMsg,
                       pArrayFormat->VarDescriptor,
                       EXPR_ACTUALCOUNT );

    Ndr64pPointerLayoutFree( pStubMsg,
                             pArrayFormat + 1,
                             ActualCount,
                             pMemory );

}


void 
Ndr64ComplexArrayFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees a complex array's embedded pointers which were allocated 
    during a remote call.  Called for both top level and embedded complex
    arrays.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;
        
    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );
    
    PFORMAT_STRING      pElementFormat  = (PFORMAT_STRING)pArrayFormat->Element;

    //
    // We have to check this in case we get an exception before actually 
    // unmarshalling the array.
    // 
    if ( ! pMemory ) 
        return;
    
    NDR64_WIRE_COUNT_TYPE    Elements = pArrayFormat->NumberElements; 
    NDR64_WIRE_COUNT_TYPE    Count    = Elements;
    NDR64_WIRE_COUNT_TYPE    Offset   = 0;

    if ( !IsFixed )
        {
        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
             (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        //
        // Check for conformance description.
        //
        if ( pConfVarFormat->ConfDescription )
            {
            Elements = (NDR64_UINT32)Ndr64EvaluateExpr( pStubMsg,
                                                        pConfVarFormat->ConfDescription,
                                                        EXPR_MAXCOUNT );
            Offset = 0;
            Count = Elements;

            }

        //
        // Check for variance description.
        //
        if ( pConfVarFormat->VarDescription )
            {
            Count = (NDR64_UINT32)
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->VarDescription,
                                   EXPR_ACTUALCOUNT );

            Offset = (NDR64_UINT32)
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->OffsetDescription,
                                   EXPR_OFFSET );

            }
        
        }

    NDR64_UINT32    ElementMemorySize = 
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          FALSE );

    pMemory += Ndr64pConvertTo2GB((NDR64_UINT64)Offset * 
                                  (NDR64_UINT64)ElementMemorySize);

    Ndr64pConvertTo2GB( (NDR64_UINT64)Elements *
                        (NDR64_UINT64)ElementMemorySize );
    Ndr64pConvertTo2GB( (NDR64_UINT64)Count *
                        (NDR64_UINT64)ElementMemorySize );

    for ( ; Count--; )
        {

        Ndr64EmbeddedTypeFree( pStubMsg,
                               pMemory,
                               pElementFormat );

        pMemory += ElementMemorySize;
        }

}


void 
Ndr64UnionFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees an encapsulated union's embedded pointers which were allocated 
    during a remote call.  

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;

    EXPR_VALUE          SwitchIs;
    NDR64_FORMAT_CHAR   SwitchType;
    uchar *pArmMemory;
    
    if ( !pMemory )
        return;
    
    switch(*(PFORMAT_STRING)pFormat)
        {
        case FC64_NON_ENCAPSULATED_UNION:
            {
            const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
                (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;

            SwitchType      = pNonEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);

            SwitchIs   = Ndr64EvaluateExpr( pStubMsg,
                                            pNonEncapUnionFormat->Switch,
                                            EXPR_SWITCHIS );
            
            pArmMemory = pMemory;
            break;
            }
        case FC64_ENCAPSULATED_UNION:
            {
            const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
                (const NDR64_ENCAPSULATED_UNION*)pFormat;

            SwitchType      = pEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);
                
            SwitchIs        = Ndr64pSimpleTypeToExprValue( SwitchType,
                                                           pMemory );
            pArmMemory      = pMemory + pEncapUnionFormat->MemoryOffset;
            break;
            }
        default:
            NDR_ASSERT("Bad union format\n", 0);
            return;
        }

    PNDR64_FORMAT pArmFormat = 
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector, 
                            SwitchIs );
    
    if ( !pArmFormat )
        return;

    Ndr64EmbeddedTypeFree( pStubMsg,
                           pArmMemory,
                           pArmFormat );
}


void 
Ndr64XmitOrRepAsFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees the transmit-as object (actually the presented type instance)
    and steps over the object.

    There is an exceptional situation where the spec forbids stub to free
    the instance. This happens when there is an [in] only parameter with
    a [transmit_as()] on a component of the parameter, and the presented
    typedef is composed of one or more pointers.
    We have a flag in the stub msg that is set when this happens.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    const NDR64_TRANSMIT_AS_FORMAT *pTransFormat =
        ( const NDR64_TRANSMIT_AS_FORMAT *) pFormat;
    
    if ( !pMemory )
        return;

    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );

    unsigned short QIndex = pTransFormat->RoutineIndex;
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;

    // Free the presented type instance unless forbidden explicitely.

    if ( ! pStubMsg->fDontCallFreeInst )
        {
        pStubMsg->pPresentedType = pMemory;
        pQuintuple[ QIndex ].pfnFreeInst( pStubMsg );
        }
}


void 
Ndr64UserMarshalFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Frees the usr_marshal object and steps over the object.
    See mrshl.c for the description of the layouts.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to be freed.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    NDR64_USER_MARSHAL_FORMAT  *      pUserFormat = 
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    NDR_ASSERT( pUserFormat->FormatCode == FC64_USER_MARSHAL, "invalid format string for user marshal" );

    unsigned short QIndex = pUserFormat->RoutineIndex;
    const USER_MARSHAL_ROUTINE_QUADRUPLE * pQuadruple = 
        (const USER_MARSHAL_ROUTINE_QUADRUPLE *)( (  NDR_PROC_CONTEXT *)pStubMsg->pContext )->pSyntaxInfo->aUserMarshalQuadruple;

    // Call the user to free his stuff.
    USER_MARSHAL_CB        UserMarshalCB;
    Ndr64pInitUserMarshalCB( pStubMsg,
                           pUserFormat,
                           USER_MARSHAL_CB_FREE,
                           & UserMarshalCB);

    // The user shouldn't ever free the top level object as we free it.
    // He should free only pointees of his top level object.

    pQuadruple[ QIndex ].pfnFree( (ulong*) &UserMarshalCB, pMemory );

    // Ndr64pMemoryIncrement steps over the memory object.
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_FREE_ROUTINE extern const Ndr64FreeRoutinesTable[] = \
{                                                          

#define NDR64_TABLE_END    \
};                         

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,free                     

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,Ndr64pNoopFree         
   

#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64FreeRoutinesTable)/sizeof(PNDR64_FREE_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_BEGIN_TABLE \
PNDR64_FREE_ROUTINE extern const Ndr64EmbeddedFreeRoutinesTable[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,embeddedfree
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64EmbeddedFreeRoutinesTable) / sizeof(PNDR64_FREE_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\expr.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    expr.h

Abstract :

    This file contains code for ndr correlations.

Author :

    Ryszard K. Kott     (ryszardk)    Sep 1997

Revision History :

---------------------------------------------------------------------*/

#include "ndrp.h"

#if !defined(__EXPR_H__)
#define  __EXPR_H__

class CORRELATION_CONTEXT
{
    PMIDL_STUB_MESSAGE const pStubMsg;
    uchar * const pCorrMemorySave;
public:
    CORRELATION_CONTEXT(PMIDL_STUB_MESSAGE pCurStubMsg,
                        uchar *pNewContext ) :
        pStubMsg( pCurStubMsg ),
        pCorrMemorySave( pCurStubMsg->pCorrMemory )
    {
    pCurStubMsg->pCorrMemory = pNewContext;
    }
    ~CORRELATION_CONTEXT()
    {
        pStubMsg->pCorrMemory = pCorrMemorySave;
    }
};

typedef  __int64 EXPR_VALUE;

EXPR_VALUE
Ndr64EvaluateExpr(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType );


typedef struct _NDR64_CORRELATION_INFO_DATA
    {
    unsigned char *                 pMemoryObject;
    PNDR64_FORMAT                   pCorrDesc;
    EXPR_VALUE                      Value;
    long                            CheckKind;
    } NDR64_CORRELATION_INFO_DATA;

#define NDR64_SLOTS_PER_CORRELATION_INFO 5

typedef struct _NDR64_CORRELATION_INFO
    {
    struct _NDR64_CORRELATION_INFO  *pNext;
    NDR64_UINT32                    SlotsUsed;
    NDR64_CORRELATION_INFO_DATA     Data[NDR64_SLOTS_PER_CORRELATION_INFO];
    } NDR64_CORRELATION_INFO, *PNDR64_CORRELATION_INFO;


void 
Ndr64pCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE                 CheckKind );

void
Ndr64pAddCorrelationData( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    EXPR_VALUE          Value,
    NDR64_EXPRESSION_TYPE                 CheckKind );

void Ndr64pNoCheckCorrelation( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE  ExpressionType  );

void Ndr64pEarlyCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  );

void Ndr64pLateCheckCorrelation(
    PMIDL_STUB_MESSAGE  pStubMsg,
    EXPR_VALUE          Value,
    PNDR64_FORMAT       pFormat,
    NDR64_EXPRESSION_TYPE            ExpressionType  );

void
Ndr64CorrelationPass(
    PMIDL_STUB_MESSAGE                  pStubMsg
    );

#endif // __EXPR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\bufsize.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 - 2000 Microsoft Corporation

Module Name :

    bufsize.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the 
    interpreter for computing the buffer size needed for a parameter.  

Author :

    David Kays  dkays   September 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"

void 
Ndr64UDTSimpleTypeSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Get the size a top level or embedded simple type.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.

Return :

    None.

--*/
{
    LENGTH_ALIGN( pStubMsg->BufferLength,
                  NDR64_SIMPLE_TYPE_BUFALIGN(*(PFORMAT_STRING)pFormat) );

    pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(*(PFORMAT_STRING)pFormat);

    pMemory += NDR64_SIMPLE_TYPE_MEMSIZE(*(PFORMAT_STRING)pFormat);
}


void 
Ndr64pInterfacePointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for an interface pointer.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - The interface pointer being sized.
    pFormat     - Interface pointer's format string description.

Return :

    None.

    // wire representation of a marshalled interface pointer
    typedef struct tagMInterfacePointer
    {
        ULONG           ulCntData;          // size of data
        [size_is(ulCntData)] BYTE abData[]; // data (OBJREF)
    } MInterfacePointer;

--*/
{

    const NDR64_CONSTANT_IID_FORMAT *pConstInterfaceFormat =
        (NDR64_CONSTANT_IID_FORMAT*)pFormat;
    const NDR64_IID_FORMAT *pInterfaceFormat =
        (NDR64_IID_FORMAT*)pFormat;

    //
    // Get an IID pointer.
    //
    IID *piid;
    if ( ((NDR64_IID_FLAGS*)&pInterfaceFormat->Flags)->ConstantIID )
        {
        piid = (IID*)&pConstInterfaceFormat->Guid;
        }
    else
        {
        piid = (IID *) Ndr64EvaluateExpr( pStubMsg,
                                          pInterfaceFormat->IIDDescriptor,
                                          EXPR_IID );
        if(piid == 0)
            {
            RpcRaiseException( RPC_S_INVALID_ARG );
            }
        }

    // Allocate space for the length and array bounds.

    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );
    pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE);
    pStubMsg->BufferLength += sizeof(ulong);

    unsigned long size;
    HRESULT hr = (*pfnCoGetMarshalSizeMax)(&size, *piid, (IUnknown *)pMemory, 
                                           pStubMsg->dwDestContext, pStubMsg->pvDestContext, 0);
    if(FAILED(hr))
        {
        RpcRaiseException(hr);
        }

    pStubMsg->BufferLength += size;

}


__forceinline void 
Ndr64pPointerBufferSizeInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Private routine for sizing a pointee.  This is the entry
    point for pointers embedded in structures, arrays, or unions.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data being sized.
    pFormat     - Pointer's format string description.
    
    pStubMsg->BufferLength - ready for the pointee.

Return :

    None.

--*/
{   const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;
    PFORMAT_STRING pPointeeFormat = (PFORMAT_STRING)pPointerFormat->Pointee;

    if ( ! pMemory )
        return;

    switch( pPointerFormat->FormatCode )
        {
        case FC64_IP:
            Ndr64pInterfacePointerBufferSize( pStubMsg,
                                              pMemory,
                                              pPointeeFormat
                                              );
            return;
        
        case FC64_FP:
            //
            // Check if we have already sized this full pointer.
            //
            if ( Ndr64pFullPointerQueryPointer( pStubMsg,
                                                pMemory,
                                                FULL_POINTER_BUF_SIZED,
                                                0 ) )
                return;

            break;

        default:
            break;
        }

    if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
        {
        // Pointer to simple type.
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_SIMPLE_TYPE_BUFALIGN(*pPointeeFormat));
        pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(*pPointeeFormat);       
        return;
        }

    //
    // Pointer to complex type.
    //
    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        pMemory = *((uchar **)pMemory);

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    Ndr64TopLevelTypeSize( pStubMsg,
                           pMemory,
                           pPointeeFormat );
}
   
NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT::NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :

        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        uFlags(pStubMsg->uFlags),
        pCorrMemory(pStubMsg->pCorrMemory)
{

}

void 
NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{
    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags, uFlags );
    CORRELATION_CONTEXT CorrCtxt(pStubMsg, pCorrMemory); 

    Ndr64pPointerBufferSizeInternal( pStubMsg,
                                     pMemory,
                                     pFormat);
}                          

#if defined(DBG)
void 
NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("uFlags:                  %x\n", uFlags );
    DbgPrint("pCorrMemory:             %p\n", pCorrMemory );
}
#endif

void
Ndr64pEnquePointerBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT *pElement = 
            new(PointerContext.GetActiveState()) 
                NDR64_BUFSIZE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                    pMemory,
                                                    (PFORMAT_STRING)pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void 
Ndr64pPointerBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    
    if (!NdrIsLowStack(pStubMsg))
        {
        Ndr64pPointerBufferSizeInternal( 
            pStubMsg,
            pMemory,
            pFormat );
        return;
        }

    Ndr64pEnquePointerBufferSize( 
        pStubMsg,
        pMemory,
        pFormat );
}


__forceinline void 
Ndr64TopLevelPointerBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    if ( *(PFORMAT_STRING)pFormat != FC64_RP )
        {
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );

        pStubMsg->BufferLength += sizeof(NDR64_PTR_WIRE_TYPE);
        }

    Ndr64pPointerBufferSize( pStubMsg,
                             pMemory,
                             pFormat );
}

__forceinline void 
Ndr64EmbeddedPointerBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{

    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );
    pStubMsg->BufferLength += sizeof(NDR64_PTR_WIRE_TYPE);

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );
    Ndr64pPointerBufferSize( pStubMsg,
                             *(uchar**)pMemory,
                             pFormat );
}


void 
Ndr64pRangeBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a simple type with range on it.
    Used for FC64_RANGE.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_RANGE_FORMAT * pRangeFormat =
        (const NDR64_RANGE_FORMAT*)pFormat;

    LENGTH_ALIGN( pStubMsg->BufferLength, NDR64_SIMPLE_TYPE_BUFALIGN(pRangeFormat->RangeType) );
    pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(pRangeFormat->RangeType);
}


void 
Ndr64SimpleStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a simple structure.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;

    LENGTH_ALIGN( pStubMsg->BufferLength, pStructFormat->Alignment );

    pStubMsg->BufferLength += pStructFormat->MemorySize;  
    
    if ( pStructFormat->Flags.HasPointerInfo ) 
        {

        CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pStructFormat + 1,
                                       0,
                                       pMemory );

        }
}


void 
Ndr64ConformantStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a conformant structure.

    Used for FC64_CSTRUCT and FC64_CPSTRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =  
        (NDR64_CONF_ARRAY_HEADER_FORMAT *)pStructFormat->ArrayDescription;
    
    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align and add size for conformance count.
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);

        pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    
    // Align 
    LENGTH_ALIGN(pStubMsg->BufferLength, pStructFormat->Alignment );

    NDR64_WIRE_COUNT_TYPE MaxCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->ConfDescriptor, 
                           EXPR_MAXCOUNT );

    pStubMsg->BufferLength += pStructFormat->MemorySize + 
                              Ndr64pConvertTo2GB(MaxCount * 
                                                 (NDR64_UINT64)pArrayFormat->ElementSize );

    if ( pStructFormat->Flags.HasPointerInfo )  
        {

        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pStructFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       pMemory );
        }
}


void 
Ndr64ComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a complex structure.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being sized.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    bool  fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                  !pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {

        pStubMsg->IgnoreEmbeddedPointers = TRUE;
        ulong BufferLengthSave = pStubMsg->BufferLength;
        
        Ndr64ComplexStructBufferSize( 
            pStubMsg,
            pMemory,
            pFormat );

        // complex struct may not have a zero length
        NDR_ASSERT( pStubMsg->BufferLength, "Flat part of struct had a zero length!" );

        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        pStubMsg->PointerBufferMark = (uchar*) ULongToPtr(pStubMsg->BufferLength);
        pStubMsg->BufferLength = BufferLengthSave;
        
        }

    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING) pStructFormat->PointerLayout;
    PFORMAT_STRING  pFormatArray = NULL;

    PFORMAT_STRING  pMemberLayout =  ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                       *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                     (PFORMAT_STRING)( pConfStructFormat + 1) :
                                     (PFORMAT_STRING)( pStructFormat + 1);

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    // Get conformant array description.
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;

        // accounted for by the outermost embedding complex struct 
        if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
            {
            //
            // Align and add size of conformance count(s).
            //
            LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );
        
            pStubMsg->BufferLength += pConfStructFormat->Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE);

            NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );
            }
        }
     else
        pFormatArray = 0;

     LENGTH_ALIGN(pStubMsg->BufferLength, pStructFormat->Alignment);
        
     //
     // Shallow size the structure member by member.
     //
     for ( ; ; ) 
         {
         switch ( *pMemberLayout ) 
             {
             
             case FC64_STRUCT:
             {
             const NDR64_SIMPLE_REGION_FORMAT *pRegion = 
                 (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;
             
             LENGTH_ALIGN(pStubMsg->BufferLength, pRegion->Alignment );  
             pStubMsg->BufferLength += pRegion->RegionSize;

             pMemory          += pRegion->RegionSize;

             pMemberLayout    += sizeof( *pRegion );
             break;
             }

             case FC64_STRUCTPADN :
             {
             const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
             pMemory        += pMemPad->MemPad;
             pMemberLayout  += sizeof(*pMemPad);
             break;
             }

             case FC64_POINTER :
             {
             
             Ndr64EmbeddedPointerBufferSize( 
                 pStubMsg,
                 pMemory,
                 pFormatPointers );

             pMemory                += PTR_MEM_SIZE;     
             
             pFormatPointers += sizeof(NDR64_POINTER_FORMAT);
             pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);             
             break;
             }

             //
             // Embedded complex types.
             //
             case FC64_EMBEDDED_COMPLEX :
                 {
                 const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                 (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                 PFORMAT_STRING pTypeFormat = (PFORMAT_STRING)pEmbeddedFormat->Type;
                 
                 Ndr64EmbeddedTypeSize( pStubMsg,
                                        pMemory,
                                        pTypeFormat );

                 pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                                  pMemory,
                                                  pTypeFormat,
                                                  FALSE );

                 pMemberLayout += sizeof( *pEmbeddedFormat );
                 break;
                 }

             case FC64_BUFFER_ALIGN:
                 { 
                 const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign = 
                     (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                 LENGTH_ALIGN(pStubMsg->BufferLength, pBufAlign->Alignment);                 
                 pMemberLayout += sizeof( *pBufAlign );
                 break;
                 }

             //
             // simple types
             //
             case FC64_CHAR :
             case FC64_WCHAR :
             case FC64_INT8:
             case FC64_UINT8:
             case FC64_INT16:
             case FC64_UINT16:
             case FC64_INT32:
             case FC64_UINT32:
             case FC64_INT64:
             case FC64_UINT64:
             case FC64_FLOAT32 :
             case FC64_FLOAT64 :
             case FC64_ERROR_STATUS_T:
                 LENGTH_ALIGN( pStubMsg->BufferLength,
                               NDR64_SIMPLE_TYPE_BUFALIGN(*pMemberLayout) );
                 pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(*pMemberLayout);
                 pMemory += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);
                 
                 pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                 break;

             case FC64_IGNORE :
                 LENGTH_ALIGN( pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );
                 pStubMsg->BufferLength += sizeof(NDR64_PTR_WIRE_TYPE);
                 pMemory += PTR_MEM_SIZE;
                 pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                 break;

             //
             // Done with layout.
             //
             case FC64_END :
                 goto ComplexStructBufferSizeEnd;

             default :
                 NDR_ASSERT(0,"Ndr64ComplexStructBufferSize : bad format char");
                 RpcRaiseException( RPC_S_INTERNAL_ERROR );
                 return;
             } // switch 
         } // for

ComplexStructBufferSizeEnd:
     //
     // Size any conformant array.
     //

     if ( pFormatArray )
         {
         Ndr64EmbeddedTypeSize( pStubMsg,
                                pMemory,
                                pFormatArray );          
         }
    else 
        {
        // If the structure doesn't have a conformant array, align it again
        LENGTH_ALIGN( pStubMsg->BufferLength, pStructFormat->Alignment );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
        pStubMsg->PointerBufferMark = NULL;
        }
}


void 
Ndr64FixedArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a fixed array of any number of 
    dimensions.

    Used for FC64_SMFARRAY and FC64_LGFARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;

    LENGTH_ALIGN(pStubMsg->BufferLength, pArrayFormat->Alignment );
    pStubMsg->BufferLength += pArrayFormat->TotalSize;

    if ( pArrayFormat->Flags.HasPointerInfo ) 
        {

        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pArrayFormat + 1,
                                       0,
                                       pMemory );
        }
}


void 
Ndr64ConformantArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level one dimensional conformant 
    array.

    Used for FC64_CARRAY.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{

    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;

    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);
    
        pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE);

        }

    NDR64_WIRE_COUNT_TYPE ConformanceCount = 
        Ndr64EvaluateExpr( pStubMsg, 
                           pArrayFormat->ConfDescriptor, 
                           EXPR_MAXCOUNT );
    
    NDR64_UINT32 BufferSize = Ndr64pConvertTo2GB( (NDR64_UINT64)pArrayFormat->ElementSize * 
                                                  ConformanceCount );

    LENGTH_ALIGN(pStubMsg->BufferLength,pArrayFormat->Alignment);

    pStubMsg->BufferLength += BufferSize;

    if ( pArrayFormat->Flags.HasPointerInfo ) 
        {

        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ConformanceCount,
                                       pMemory );
        }

}


void 
Ndr64ConformantVaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level one dimensional conformant
    varying array.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{

    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );
    
        pStubMsg->BufferLength += sizeof( NDR64_WIRE_COUNT_TYPE );
        }

    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );

    pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_WIRE_COUNT_TYPE ActualCount = 
        Ndr64EvaluateExpr( pStubMsg, 
                           pArrayFormat->VarDescriptor, 
                           EXPR_ACTUALCOUNT );

    NDR64_UINT32 CopySize = Ndr64pConvertTo2GB( ActualCount * 
                                                (NDR64_UINT64)pArrayFormat->ElementSize );

    LENGTH_ALIGN(pStubMsg->BufferLength, pArrayFormat->Alignment );


    pStubMsg->BufferLength += CopySize;

    if ( pArrayFormat->Flags.HasPointerInfo ) 
        {

        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       pMemory );
        }
}


void 
Ndr64VaryingArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level or embedded one 
    dimensional varying array.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

Arguments : 

    pMemory     - pointer to the parameter to size
    pFormat     - pointer to the format string description of the parameter

--*/
{
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;
    
    //
    // Align and add size for offset and actual count.
    //
    LENGTH_ALIGN( pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);

    pStubMsg->BufferLength += (sizeof(NDR64_WIRE_COUNT_TYPE) * 2);

    NDR64_WIRE_COUNT_TYPE ActualCount =
        Ndr64EvaluateExpr( pStubMsg, 
                           pArrayFormat->VarDescriptor, 
                           EXPR_ACTUALCOUNT );

    // Check if the bounds are valid

    NDR64_UINT32 BufferSize = Ndr64pConvertTo2GB( ActualCount * 
                                                  (NDR64_UINT64)pArrayFormat->ElementSize );

    if ( BufferSize > pArrayFormat->TotalSize  )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    LENGTH_ALIGN(pStubMsg->BufferLength, pArrayFormat->Alignment );

    pStubMsg->BufferLength += BufferSize;

    if ( pArrayFormat->Flags.HasPointerInfo ) 
        {
        
        Ndr64pPointerLayoutBufferSize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       pMemory );
        
        }
}


void 
Ndr64ComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a top level complex array.

    Used for FC64_BOGUS_STRUCT.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.
    
--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
          (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;

    bool fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                 (! pStubMsg->PointerBufferMark );

    if ( fSetPointerBufferMark )
        {
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        Ndr64ComplexArrayBufferSize( 
            pStubMsg,
            pMemory,
            pFormat );

        // In NDR64 the flat part of a array may not have a zero length.
        NDR_ASSERT( pStubMsg->BufferLength, "Flat part of array had a zero length!" );

        pStubMsg->PointerBufferMark = (uchar*)ULongToPtr(pStubMsg->BufferLength);        
        pStubMsg->IgnoreEmbeddedPointers = FALSE;
        pStubMsg->BufferLength = BufferLengthSave;

        }

    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

    PFORMAT_STRING pElementFormat = (PFORMAT_STRING) pArrayFormat->Element;

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    
    NDR64_WIRE_COUNT_TYPE Elements = pArrayFormat->NumberElements;
    NDR64_WIRE_COUNT_TYPE Count = Elements;
    NDR64_WIRE_COUNT_TYPE Offset   = 0;
    
    if ( !IsFixed )
        {

        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat =
              (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        if ( pConfVarFormat->ConfDescription )
            {
            Elements = Ndr64EvaluateExpr( pStubMsg,
                                          pConfVarFormat->ConfDescription,
                                          EXPR_MAXCOUNT );
            Count  =  Elements;
            Offset =  0;

            if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
                {

                LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);

                pStubMsg->BufferLength += pArrayFormat->NumberDims * 
                                          sizeof(NDR64_WIRE_COUNT_TYPE);

                NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );

                }

            }

        if ( pConfVarFormat->VarDescription )
            {

            Count = 
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->VarDescription,
                                   EXPR_ACTUALCOUNT );

            Offset = 
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->OffsetDescription,
                                   EXPR_OFFSET);

            if ( ! NDR64_IS_VAR_MARK_VALID( pStubMsg->uFlags ) )
                {

                NDR64_UINT32 Dimensions;

                LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );

                Dimensions = ( pArrayFormat->Flags.IsArrayofStrings ) ? ( pArrayFormat->NumberDims - 1 ) :
                                                                        ( pArrayFormat->NumberDims );
                pStubMsg->BufferLength += Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

                if ( NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                    NDR64_SET_VAR_MARK_VALID( pStubMsg->uFlags );

                }
            else if ( !NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                NDR64_RESET_VAR_MARK_VALID( pStubMsg->uFlags );
               
            }
        }

    NDR64_UINT32 ElementMemorySize = 
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          FALSE );

    pMemory += Ndr64pConvertTo2GB(Offset * 
                                  (NDR64_UINT64)ElementMemorySize);

    Ndr64pConvertTo2GB( Elements *
                        (NDR64_UINT64)ElementMemorySize );
    Ndr64pConvertTo2GB( Count *
                        (NDR64_UINT64)ElementMemorySize );

    if ( (Offset + Count) > Elements )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    LENGTH_ALIGN( pStubMsg->BufferLength, pArrayFormat->Alignment );    

    for ( ; Count--; )
        {
        Ndr64EmbeddedTypeSize( pStubMsg,
                               pMemory,
                               pElementFormat );
        pMemory += ElementMemorySize;
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->BufferLength = PtrToUlong(pStubMsg->PointerBufferMark);
        pStubMsg->PointerBufferMark = NULL;
        }
}


void 
Ndr64NonConformantStringBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a non conformant string.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_NON_CONFORMANT_STRING_FORMAT * pStringFormat = 
        (NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_UINT32 CopySize = 
        Ndr64pCommonStringSize(pStubMsg,
                               pMemory,
                               &pStringFormat->Header);
    
    if ( CopySize > pStringFormat->TotalSize )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );

    pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;    

    pStubMsg->BufferLength += CopySize;

}


void 
Ndr64ConformantStringBufferSize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Routine for computing the buffer size needed for a conformant 
    string.  

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being sized.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_CONFORMANT_STRING_FORMAT * pStringFormat =
        (NDR64_CONFORMANT_STRING_FORMAT*) pFormat;
    const NDR64_SIZED_CONFORMANT_STRING_FORMAT * pSizedStringFormat =
        (NDR64_SIZED_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_UINT32 CopySize = 
        Ndr64pCommonStringSize(pStubMsg,
                               pMemory,
                                &pStringFormat->Header);    

    if ( pStringFormat->Header.Flags.IsSized )
        {
        
        Ndr64EvaluateExpr( pStubMsg,
                           pSizedStringFormat->SizeDescription,
                           EXPR_MAXCOUNT );

        if ( pStubMsg->ActualCount >  pStubMsg->MaxCount )
            RpcRaiseException(RPC_X_INVALID_BOUND);
        
        }

    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
       {
       LENGTH_ALIGN( pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN );
       pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE);
       }

    // Align and add size for variance.
    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_WIRE_COUNT_ALIGN);
    pStubMsg->BufferLength += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;
    pStubMsg->BufferLength += CopySize;

}



void 
Ndr64UnionBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the buffer size needed for an encapsulated union.

    Used for FC64_ENCAPSULATED_UNION.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being sized.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;

    EXPR_VALUE          SwitchIs;
    NDR64_FORMAT_CHAR   SwitchType;

    uchar *pArmMemory;
    switch(*(PFORMAT_STRING)pFormat)
        {
        case FC64_NON_ENCAPSULATED_UNION:
            {
            const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
                (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;

            LENGTH_ALIGN(pStubMsg->BufferLength, pNonEncapUnionFormat->Alignment);
            SwitchType      = pNonEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);

            SwitchIs   = Ndr64EvaluateExpr( pStubMsg,
                                            pNonEncapUnionFormat->Switch,
                                            EXPR_SWITCHIS );

            pArmMemory      = pMemory;
            break;
            }
        case FC64_ENCAPSULATED_UNION:
            {
            const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
                (const NDR64_ENCAPSULATED_UNION*)pFormat;

            LENGTH_ALIGN(pStubMsg->BufferLength, pEncapUnionFormat->Alignment);
            SwitchType      = pEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);
                
            SwitchIs        = Ndr64pSimpleTypeToExprValue(SwitchType,
                                                          pMemory);

            pArmMemory      = pMemory + pEncapUnionFormat->MemoryOffset;
            break;
            }
        default:
            NDR_ASSERT("Bad union format\n", 0);
            return;
        }

    //
    // Size the switch_is.
    //
    LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_SIMPLE_TYPE_BUFALIGN(SwitchType));
    
    pStubMsg->BufferLength += NDR64_SIMPLE_TYPE_BUFSIZE(SwitchType);

    LENGTH_ALIGN( pStubMsg->BufferLength, pArmSelector->Alignment);

    PNDR64_FORMAT pArmFormat = 
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector,
                            SwitchIs );

    if ( ! pArmFormat )
        return;

    Ndr64EmbeddedTypeSize( pStubMsg,
                           pArmMemory,
                           pArmFormat );

}


void 
Ndr64XmitOrRepAsBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    bool                IsEmbedded ) 
/*++

Routine Description :

    Computes the buffer size needed for a transmit as or represent as object.

    See mrshl.c for the description of the FC layout.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the transmit/represent as object being sized.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    NDR64_TRANSMIT_AS_FORMAT    *pTransFormat = ( NDR64_TRANSMIT_AS_FORMAT *) pFormat;
    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );

    unsigned short QIndex = pTransFormat->RoutineIndex;

    NDR64_UINT32 XmitTypeSize = pTransFormat->TransmittedTypeBufferSize;

    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = pStubMsg->StubDesc->aXmitQuintuple;

    if ( XmitTypeSize )
        {
        LENGTH_ALIGN( pStubMsg->BufferLength, pTransFormat->TransmittedTypeWireAlignment );
        pStubMsg->BufferLength += XmitTypeSize;
        }
    else
        {
        // We have to create an object to size it.

        // First translate the presented type into the transmitted type.
        // This includes an allocation of a transmitted type object.
    
        pStubMsg->pPresentedType = pMemory;
        pStubMsg->pTransmitType = NULL;
        pQuintuple[ QIndex ].pfnTranslateToXmit( pStubMsg );
    
        // bufsize the transmitted type.

        unsigned char *  pTransmittedType = pStubMsg->pTransmitType;

        // In NDR64, Xmit/Rep cannot be a pointer or contain a pointer.
        // So we don't need to worry about the pointer queue here.

        if ( IsEmbedded )
            {
            Ndr64EmbeddedTypeSize( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
            }
        else
            {
            Ndr64TopLevelTypeSize( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
            }

        pStubMsg->pTransmitType = pTransmittedType;
    
        // Free the temporary transmitted object (it was alloc'ed by the user).
    
        pQuintuple[ QIndex ].pfnFreeXmit( pStubMsg );
        }
}

void 
Ndr64TopLevelXmitOrRepAsBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsBufferSize( pStubMsg,
                                pMemory,
                                pFormat,
                                false );
}

void
Ndr64EmbeddedXmitOrRepAsBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    Ndr64XmitOrRepAsBufferSize( pStubMsg,
                                pMemory,
                                pFormat,
                                true );
}

void
Ndr64UserMarshallBufferSizeInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_USER_MARSHAL_FORMAT  *pUserFormat = ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    // We are here to size a flat object or a pointee object.
    // Optimization: if we know the wire size, don't call the user to size it.

    if ( pUserFormat->TransmittedTypeBufferSize != 0 )
        {
        pStubMsg->BufferLength += pUserFormat->TransmittedTypeBufferSize;
        }
    else
        {
        // Unknown wire size: Call the user to size his stuff.
        USER_MARSHAL_CB UserMarshalCB;
        Ndr64pInitUserMarshalCB( pStubMsg,
                               pUserFormat,
                               USER_MARSHAL_CB_BUFFER_SIZE,
                               & UserMarshalCB);

        unsigned long UserOffset = pStubMsg->BufferLength;

        unsigned short QIndex = pUserFormat->RoutineIndex;
        const USER_MARSHAL_ROUTINE_QUADRUPLE * pQuadruple = 
            (const USER_MARSHAL_ROUTINE_QUADRUPLE *)( (  NDR_PROC_CONTEXT *)pStubMsg->pContext )->pSyntaxInfo->aUserMarshalQuadruple;

        UserOffset = pQuadruple[ QIndex ].pfnBufferSize( (ulong*) &UserMarshalCB,
                                                         UserOffset,
                                                         pMemory );
        pStubMsg->BufferLength = UserOffset;
        }
}

void
NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    Ndr64UserMarshallBufferSizeInternal( pStubMsg,
                                         pMemory,
                                         pFormat );
}

#if defined(DBG)
void 
NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


void
Ndr64UserMarshallPointeeBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    
    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {

        POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );
        Ndr64UserMarshallBufferSizeInternal( pStubMsg,
                                             pMemory,
                                             pFormat );
        return;
        }
    
    NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT*pElement = 
       new(pStubMsg->pPointerQueueState) 
           NDR64_USR_MRSHL_BUFSIZE_POINTER_QUEUE_ELEMENT(pMemory,
                                                       (PFORMAT_STRING)pFormat );
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );
}


void
Ndr64UserMarshalBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    bool                bIsEmbedded ) 
/*++

Routine Description :

    Computes the buffer size needed for a usr_marshall object.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the usr_marshall object to buffer size.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{

    NDR64_USER_MARSHAL_FORMAT  *pUserFormat = ( NDR64_USER_MARSHAL_FORMAT *) pFormat;
    NDR_ASSERT( pUserFormat->FormatCode == FC64_USER_MARSHAL, "invalid format string for user marshal" );

    // Align for the flat object or a pointer to the user object.
    LENGTH_ALIGN( pStubMsg->BufferLength, pUserFormat->TransmittedTypeWireAlignment );

    if ( pUserFormat->Flags & USER_MARSHAL_POINTER )
        {
        
        if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE) ||
            ( ( pUserFormat->Flags & USER_MARSHAL_REF) && bIsEmbedded ) )
           {
           LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );
           pStubMsg->BufferLength += sizeof( NDR64_PTR_WIRE_TYPE );
           }
           
        
        Ndr64UserMarshallPointeeBufferSize( pStubMsg,
                                            pMemory,
                                            pFormat );
        return;
        }

    Ndr64UserMarshallBufferSizeInternal( pStubMsg,
                                         pMemory,
                                         pFormat );
        
}

void
Ndr64TopLevelUserMarshalBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64UserMarshalBufferSize(
        pStubMsg,
        pMemory,
        pFormat,
        false );
}

void
Ndr64EmbeddedUserMarshallBufferSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    Ndr64UserMarshalBufferSize(
        pStubMsg,
        pMemory,
        pFormat,
        true );
}


void 
Ndr64ContextHandleSize(
    PMIDL_STUB_MESSAGE     pStubMsg,
    uchar *                pMemory,
    PNDR64_FORMAT          pFormat )
/*++

Routine Description :

    Computes the buffer size needed for a context handle.

Arguments : 

    pStubMsg    - Pointer to the stub message.
    pMemory     - Ignored.
    pFormat     - Ignored.

Return :

    None.

--*/
{
    LENGTH_ALIGN(pStubMsg->BufferLength,0x3);
    pStubMsg->BufferLength += CONTEXT_HANDLE_WIRE_SIZE;
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_SIZE_ROUTINE extern const Ndr64SizeRoutinesTable[] = \
{                                                          

#define NDR64_TABLE_END    \
};                        

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,buffersize                    

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize,  memorysize ) \
   ,Ndr64UDTSimpleTypeSize
           
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64SizeRoutinesTable)/sizeof(PNDR64_SIZE_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_BEGIN_TABLE \
PNDR64_SIZE_ROUTINE extern const Ndr64EmbeddedSizeRoutinesTable[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,embeddedbuffersize
   
#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64EmbeddedSizeRoutinesTable) / sizeof(PNDR64_SIZE_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\hndl.h ===
/************************************************************************

Copyright (c) 1993 Microsoft Corporation

Module Name :

    hndl.h

Abstract :

    To hold prototypes of support routines for interpreting handles in 
    support of Format Strings.

Author :

    Bruce McQuistan (brucemc)

Revision History :

  ***********************************************************************/

#ifndef __HNDL_H__
#define __HNDL_H__

//
// The following is to be used in as masks for flags passed in these
// routines.
//
#define     MARSHALL_MASK           0x2
#define     IMPLICIT_MASK           0x4
#define     BINDING_MASK            0x8

//
// Next, a macro for getting the current call handle. On dos,win16, it'll
// never be called.
//
#if  defined(__RPC_MAC__)
#define GET_CURRENT_CALL_HANDLE()	NULL
#else
#define GET_CURRENT_CALL_HANDLE()   I_RpcGetCurrentCallHandle()
#endif

//
// Some typedefs to keep the front end of the C compiler happy and possibly to
// improve code generation.
//
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGCHAR)(uchar);
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGSHORT)(ushort);
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGLONG)(ulong);

typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGCHAR)(uchar, handle_t);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGSHORT)(ushort, handle_t);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGLONG)(ulong, handle_t);

#if defined(__RPC_WIN64__)
typedef void *  (__RPC_API * GENERIC_BIND_FUNC_ARGINT64)(uint64);
typedef void    (__RPC_API * GENERIC_UNBIND_FUNC_ARGINT64)(uint64, handle_t);
#endif

handle_t
GenericHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

void
GenericHandleUnbind(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

handle_t
ExplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    handle_t *              pSavedGenericHandle
    );

handle_t
ImplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar                   HandleType,
    handle_t *              pSavedGenericHandle
    );

handle_t
Ndr64GenericHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

void
Ndr64GenericHandleUnbind(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    uint                    Flags,
    handle_t *              pSavedGenericHandle
    );

handle_t
Ndr64ExplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar *                 ArgPtr,
    PFORMAT_STRING          FmtString,
    handle_t *              pSavedGenericHandle
    );

handle_t
Ndr64ImplicitBindHandleMgr(
    PMIDL_STUB_DESC         pStubDesc,
    uchar                   HandleType,
    handle_t *              pSavedGenericHandle
    );


void
Ndr64MarshallHandle(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar *                 pArg,
    PNDR64_FORMAT           FmtString
    );

void
Ndr64UnmarshallHandle(
    PMIDL_STUB_MESSAGE      pStubMsg,
    uchar **                ppArg,
    PNDR64_FORMAT           FmtString,
	bool				    fIgnored
    );

void
Ndr64SaveContextHandle (
    PMIDL_STUB_MESSAGE      pStubMsg,
    NDR_SCONTEXT            CtxtHandle,
    uchar **                ppArg,
    PFORMAT_STRING          pFormat
    );

void
Ndr64ContextHandleQueueFree(
    PMIDL_STUB_MESSAGE      pStubMsg,
    void *                  FixedArray
    );

#endif __HNDL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\hndl.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
Copyright (c) 1993  - 1999 Microsoft Corporation

Module Name :

    hndl.c

Abstract :

    To hold support routines for interpreting handles
    in support of Format Strings.

Author :
    
    Bruce McQuistan (brucemc)

Revision History :

    ryszardk    3/12/94     handle optimization and fixes

  ---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "interp.h"

extern const IID GUID_NULL;

handle_t
Ndr64GenericHandleMgr(
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    )
/*++

Description :

    Provides a filter for generic binding handle management issues.
    Deals with implicit or explicit generic binding handles calling
    user functions as appropriate.

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - pointer to handle.
    pFormat   - pointer to Format string such that *pFormat is a
                handle descriptor.
    Flag      - flag indicating either binding or unbinding.

Returns :     

    Valid binding handle.

*/
{
    uchar                                GHandleSize;
    handle_t                             ReturnHandle = 0;
    BOOL                                 fBinding;
    GENERIC_BINDING_ROUTINE              pBindFunc = 0;
    GENERIC_UNBIND_ROUTINE               pUnBindFunc = 0;
    const GENERIC_BINDING_ROUTINE_PAIR * Table;
    NDR64_BIND_GENERIC  *                pExplicitFormat;
    BOOL                                 fIsPtr = FALSE;

    Table = pStubDesc->aGenericBindingRoutinePairs;

    fBinding = (Flags & BINDING_MASK);

    if ( Flags & IMPLICIT_MASK )
        {
        //
        // Implicit generic: All the info is taken from the implicit generic
        // handle info structure accessed via stub descriptor.
        //
        PGENERIC_BINDING_INFO pGenHandleInfo;

        pGenHandleInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

        GHandleSize = (uchar) pGenHandleInfo->Size;

        if ( fBinding )
            pBindFunc = pGenHandleInfo->pfnBind;
        else
            pUnBindFunc = pGenHandleInfo->pfnUnbind;
        }
    else
        {
        //
        // Explicit generic: Get index into array of function ptrs and
        // the gen handle size the format string.
        //
        NDR64_UINT8 TableIndex;
        pExplicitFormat = ( NDR64_BIND_GENERIC * )pFormat;
        NDR_ASSERT ( pExplicitFormat->HandleType == FC64_BIND_GENERIC, "invalid format char" );
        TableIndex = pExplicitFormat->RoutineIndex;
        
        GHandleSize = pExplicitFormat->Size;

        if ( fBinding )
            pBindFunc = Table[TableIndex].pfnBind;
        else
            pUnBindFunc = Table[TableIndex].pfnUnbind;

        if ( NDR64_IS_HANDLE_PTR(( ( NDR64_BIND_GENERIC * )pFormat )->Flags ) )
            fIsPtr = TRUE;
        }

    //
    // Call users routine on correctly dereferenced pointer.
    //
    switch (GHandleSize)
        {
        case 1:
            {
            uchar HandlePtr = (uchar)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (uchar *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGCHAR)pBindFunc)(
                        (uchar)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGCHAR)pUnBindFunc)(
                    (uchar)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

        case 2:
            {
            ushort HandlePtr = (ushort)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ushort *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGSHORT)pBindFunc)(
                        (ushort)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGSHORT)pUnBindFunc)(
                    (ushort)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

        case 4:
            {
            ulong HandlePtr = (ulong)(ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ulong *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGLONG)pBindFunc)(
                        (ulong)(ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGLONG)pUnBindFunc)(
                    (ulong)(ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }

#if defined(__RPC_WIN64__)
        case 8:
            {
            ULONG_PTR HandlePtr = (ULONG_PTR)ArgPtr;
            if ( fIsPtr )
                HandlePtr = * (ULONG_PTR *)ArgPtr;
        
            if ( fBinding )
                ReturnHandle = 
                    (handle_t)(ULONG_PTR)
                    (*(GENERIC_BIND_FUNC_ARGINT64)pBindFunc)(
                        (ULONG_PTR)HandlePtr );
            else
                (*(GENERIC_UNBIND_FUNC_ARGINT64)pUnBindFunc)(
                    (ULONG_PTR)HandlePtr,
                    *pGenericHandle );
            break;
            }
#endif

        default:
            NDR_ASSERT(0,"GenericHandleMgr : Handle size too big");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    if ( fBinding )
        {
        *pGenericHandle = ReturnHandle;
        if ( ReturnHandle == NULL )
            RpcRaiseException( RPC_S_INVALID_BINDING );
        }
    else
        *pGenericHandle = NULL;

    return ReturnHandle;
}


void
Ndr64GenericHandleUnbind(
    PMIDL_STUB_DESC     pStubDesc,
    uchar *             ArgPtr,
    PFORMAT_STRING      pFormat,
    uint                Flags,
    handle_t *          pGenericHandle
    )
/*++

Description :

    Unbinds a generic handle: checks if it is implicit or explicit,
    gets the handle and calls GenericHandleMgr.

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - pointer to beginning of the stack.
    pFormat   - pointer to Format string such that *pFormat is a
                  handle descriptor.
    Flag      - flag indicating implicit vs. explicit.

 --*/
{
    if ( Flags & IMPLICIT_MASK )
        {
        PGENERIC_BINDING_INFO BindInfo;

        BindInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

        NDR_ASSERT( BindInfo != 0, "GenericHandleUnbind : null bind info" );

        ArgPtr = (uchar *) BindInfo->pObj;
        }
    else
        {
        ArgPtr += ( ( NDR64_BIND_GENERIC * )pFormat )->StackOffset;

        ArgPtr = *(uchar **)ArgPtr;

//        if ( NDR64_IS_HANDLE_PTR(( ( NDR64_BIND_GENERIC * )pFormat )->Flags ) )
//            ArgPtr = *(uchar * UNALIGNED *)ArgPtr;
        }

    (void) Ndr64GenericHandleMgr( pStubDesc,
                             ArgPtr,
                             pFormat,
                             Flags,
                             pGenericHandle );
}


handle_t
Ndr64ImplicitBindHandleMgr(
    PMIDL_STUB_DESC pStubDesc,
    uchar           HandleType,
    handle_t *      pSavedGenericHandle
    )
/*++

Description :

    Provides a filter for implicit handle management issues. Deals
    with binding handles (generic, primitive or auto), extracting
    a valid handle from pStubDesc.

Arguments :

    pStubDesc  - pointer to current StubDescriptor.
    HandleType - handle format code.

Return :     
    
    Valid handle.

--*/
{
    handle_t                ReturnHandle;
    PGENERIC_BINDING_INFO   pBindInfo;

    switch ( HandleType )
        {
        case FC64_BIND_PRIMITIVE :
            ReturnHandle = *(pStubDesc->IMPLICIT_HANDLE_INFO.pPrimitiveHandle);
            break;

        case FC64_BIND_GENERIC :
            pBindInfo = pStubDesc->IMPLICIT_HANDLE_INFO.pGenericBindingInfo;

            NDR_ASSERT( pBindInfo != 0, 
                        "ImplicitBindHandleMgr : no generic bind info" );

            ReturnHandle = Ndr64GenericHandleMgr( pStubDesc,
                                             (uchar *)pBindInfo->pObj,
                                             &HandleType,
                                             BINDING_MASK | IMPLICIT_MASK,
                                             pSavedGenericHandle );
            break;

        case FC64_AUTO_HANDLE :
            ReturnHandle = *(pStubDesc->IMPLICIT_HANDLE_INFO.pAutoHandle);
            break;

        case FC64_CALLBACK_HANDLE :
            ReturnHandle = GET_CURRENT_CALL_HANDLE();
            break;

        default :
            NDR_ASSERT(0, "ImplicitBindHandleMgr : bad handle type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return ReturnHandle;
}


handle_t
Ndr64ExplicitBindHandleMgr(
    PMIDL_STUB_DESC pStubDesc,
    uchar *         ArgPtr,
    PFORMAT_STRING  pFormat,
    handle_t *      pSavedGenericHandle
    )
/*

Description :

    Provides a filter for explicit binding handle management issues.
    Deals with binding handles (primitive, generic or context), calling
    either no routine, NDR routines or user functions as appropriate.

    To be called in the following cases:
    1) if handle is explicit.
        a) before calling I_RpcGetBuffer (to bind).
        b) after unmarshalling (to unbind).

Arguments :

    pStubDesc - pointer to current StubDescriptor.
    ArgPtr    - Pointer to start of stack
    pFormat   - pointer to Format string such that *pFormat is a
                  handle descriptor.

Return :     

    Valid binding handle.

*/
{
    handle_t    ReturnHandle;
    NDR64_BIND_CONTEXT * pExplicitFormat;

    //
    // We need to manage Explicit and Implicit handles.
    // Implicit handles are managed with info accessed via the StubMessage.
    // Explicit handles have their information stored in the format string.
    // We manage explicit handles for binding here.
    //

    pExplicitFormat = ( NDR64_BIND_CONTEXT * )pFormat;
    //
    // Get location in stack of handle referent.
    //
    ArgPtr += pExplicitFormat->StackOffset;

    ArgPtr = *(uchar **)ArgPtr;


    //
    // At this point ArgPtr is an address of the handle.
    //
    switch ( pExplicitFormat->HandleType )
        {
        case FC64_BIND_PRIMITIVE :
            if ( NDR64_IS_HANDLE_PTR( pExplicitFormat->Flags) )
                ArgPtr = *(uchar **)ArgPtr;
            ReturnHandle = (handle_t)(ULONG_PTR)ArgPtr;
            break;

        case FC64_BIND_GENERIC :
            ReturnHandle = Ndr64GenericHandleMgr( pStubDesc,
                                             ArgPtr,
                                             pFormat,
                                             BINDING_MASK,
                                             pSavedGenericHandle );
            break;
    
        case FC64_BIND_CONTEXT :
            if ( NDR64_IS_HANDLE_PTR( pExplicitFormat->Flags) )
                ArgPtr = *(uchar **)ArgPtr;
        
            if ( (!(ArgPtr)) && (!NDR64_IS_HANDLE_OUT(pExplicitFormat->Flags)) )
                 RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

            ReturnHandle = 0;    // covers NULL case below.

            if ( ArgPtr && ! 
                 (ReturnHandle = NDRCContextBinding((NDR_CCONTEXT)ArgPtr)) )
                 RpcRaiseException( RPC_X_SS_CONTEXT_MISMATCH );

            break;

        default :
            NDR_ASSERT( 0, "ExplictBindHandleMgr : bad handle type" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return ReturnHandle;
}


void
Ndr64MarshallHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pArg,
    PNDR64_FORMAT       pFormat
    )
/*++

Routine description :

    Marshalls a context handle.

Arguments :
    
    pStubMsg    - Pointer to stub message.
    pArg        - Context handle to marshall (NDR_CCONTEXT or NDR_SCONTEXT).
    pFormat     - Context handle's format string description.

Return :

    Buffer pointer after marshalling the context handle.

--*/
{
    long    Index;
    NDR64_CONTEXT_HANDLE_FORMAT * pExplicitFormat;

    pExplicitFormat = ( NDR64_CONTEXT_HANDLE_FORMAT * ) pFormat;
    NDR_ASSERT( pExplicitFormat->FormatCode == FC64_BIND_CONTEXT, 
                "Ndr64MarshallHandle : Expected a context handle" );


    if ( pStubMsg->IsClient )
        {
        NDR_CCONTEXT Context;

        ALIGN( pStubMsg->Buffer, 0x3 );

        //
        // Get the context handle.
        //
        Context = NDR64_IS_HANDLE_PTR( pExplicitFormat->ContextFlags ) ? 
                        *((NDR_CCONTEXT *)pArg) : (NDR_CCONTEXT)pArg;

        //
        // An [in] only context handle must be non-zero.
        //
        if ( ! Context && ! NDR64_IS_HANDLE_OUT( pExplicitFormat->ContextFlags ) )
            RpcRaiseException( RPC_X_SS_IN_NULL_CONTEXT );

        NDRCContextMarshall( Context, (void *) pStubMsg->Buffer );

        pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

        }
    else    
        {
 
        Index = pExplicitFormat->Ordinal;

        if ( NDR64_IS_HANDLE_RETURN( pExplicitFormat->ContextFlags ) )
            {
            NDR_SCONTEXT    SContext;

            //
            // Initialize the context handle.
            //
            SContext = Ndr64ContextHandleInitialize ( pStubMsg,
                                                      (PFORMAT_STRING)pFormat );

            //
            // Put the user context that was returned into the context
            // handle.
            //
            *((uchar **)NDRSContextValue(SContext)) = pArg;

            pStubMsg->SavedContextHandles[Index] = SContext;
            }

        // add a marker to indicate runtime is marshalling the context handle, 
        NDR_SCONTEXT pContext = pStubMsg->SavedContextHandles[Index];
        pStubMsg->SavedContextHandles[Index] = (NDR_SCONTEXT) CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER;

        Ndr64ServerContextNewMarshall( pStubMsg,
                                     pContext,
                                     pStubMsg->StubDesc->apfnNdrRundownRoutines[pExplicitFormat->RundownRoutineIndex],
                                     (PFORMAT_STRING)pFormat );

        // after marshalling is finised, the hContext becomes invalid and 
        // We need to zero out the saved context to avoid referencing garbage.
        pStubMsg->SavedContextHandles[Index] = (NDR_SCONTEXT)CONTEXT_HANDLE_AFTER_MARSHAL_MARKER;
        }
}

void
Ndr64UnmarshallHandle(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppArg,
    PNDR64_FORMAT       pFormat,
    bool 		        /*fIgnored*/
    )
/*++

Routine description :

    Unmarshall a context handle.

Arguments :
    
    pStubMsg    - Pointer to stub message.
    ppArg       - Pointer to the context handle on the client/server stack.
                  On the client this is a NDR_CCONTEXT *.  On the server
                  side this is a NDR_SCONTEXT (regardless of direction).
    pFormat     - Context handle's format string description.
    fIgnored    - Ignored, but needed to match necessary routine prototype.

Return :

    Buffer pointer after unmarshalling the context handle.

--*/
{
    NDR64_CONTEXT_HANDLE_FORMAT *   pExplicitFormat;

    pExplicitFormat = (NDR64_CONTEXT_HANDLE_FORMAT * )pFormat;
    NDR_ASSERT( pExplicitFormat->FormatCode == FC64_BIND_CONTEXT, 
                "Ndr64UnmarshallHHandle : Expected a context handle" );

    if ( pStubMsg->IsClient )
        {

        ALIGN( pStubMsg->Buffer, 0x3 );

        //
        // Check if we have a pointer to a context handle
        // (the pointer can't be null).
        //
        if ( NDR64_IS_HANDLE_PTR( pExplicitFormat->ContextFlags ) )
            {
            ppArg = (uchar **) *ppArg;
            }

        //
        // Zero an [out] only context handle before unmarshalling.
        //
        if ( ! NDR64_IS_HANDLE_IN( pExplicitFormat->ContextFlags ) )
            *ppArg = 0;

        //
        // We must use the original binding handle in this call.   
        //
        NDRCContextUnmarshall( (NDR_CCONTEXT *)ppArg,
                               pStubMsg->SavedHandle,
                               (void *)pStubMsg->Buffer,
                               pStubMsg->RpcMsg->DataRepresentation );

        pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;

        }
    else
        {
        NDR_SCONTEXT SContext = 
            Ndr64ServerContextNewUnmarshall( pStubMsg,
                                             (PFORMAT_STRING)pFormat );

        Ndr64SaveContextHandle( pStubMsg, 
                              SContext, 
                              ppArg, 
                              (PFORMAT_STRING)pFormat );
        }
}


void 
Ndr64SaveContextHandle (
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        CtxtHandle,
    uchar **            ppArg,
    PFORMAT_STRING      pFormat )
/*++

Routine Description : 

    Saves a context handle's current value and then extracts the user's
    context value.

Arguments :

    pStubMsg    - The stub message.
    CtxtHandle  - The context handle.
    ppArg       - Pointer to where user's context value should go.

Return : 

    None.

*/
{
    long    Index;

    // no NT3.5 stub in ndr64.
    Index = ( ( NDR64_CONTEXT_HANDLE_FORMAT * ) pFormat)->Ordinal;

    pStubMsg->SavedContextHandles[Index] = CtxtHandle;

    // On 32b alphas, a handle pointer needs to be properly sign extended
    // to a 64b virtual stack value, as this will become the register value.
    // So, we cast to the REGISTER_TYPE to get the sign extension

    if ( ! NDR64_IS_HANDLE_PTR(( ( NDR64_CONTEXT_HANDLE_FORMAT * ) pFormat)->ContextFlags) )
        *((REGISTER_TYPE*)ppArg) = (REGISTER_TYPE) *(NDRSContextValue(CtxtHandle));
    else
        *((REGISTER_TYPE*)ppArg) = (REGISTER_TYPE) NDRSContextValue(CtxtHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\makefile.inc ===
# Copyright (c) 1993-1999 Microsoft Corporation
#
# Build wxndr20.lib from rpcndr20.lib. We need to remove all objects that
# have functions that are thunked (ie, under EXPORT_RT in rpcrt4.src) and 
# not emulated.
$(BASEDIR)\public\sdk\lib\i386\wxndr64.lib: $(BASEDIR)\public\sdk\lib\i386\rpcndr64.lib
     lib /remove:obj\i386\rpcssm.obj /out:$(BASEDIR)\public\sdk\lib\i386\wxndr64.lib $(BASEDIR)\public\sdk\lib\i386\rpcndr64.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\mrshl.cxx ===
/************************************************************************

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    mrshl.c

Abstract :

    This file contains the marshalling routines called by MIDL generated
    stubs and the interpreter.

Author :

    David Kays  dkays   September 1993.

Revision History :

  ***********************************************************************/

#include "precomp.hxx"

#include "..\..\ndr20\ndrole.h"

// make this extern as this will be call from ClientMarshal & ServerMarshal also.
extern const PSIMPLETYPE_MARSHAL_ROUTINE Ndr64SimpleTypeMarshallRoutinesTable[] =
                    {
                    NdrpSimpleTypeInvalidMarshall,
                        
                    NdrpSimpleTypeCharMarshall,
                    NdrpSimpleTypeCharMarshall,
                    
                    NdrpSimpleTypeShortMarshall,
                    NdrpSimpleTypeShortMarshall,
                    
                    NdrpSimpleTypeLongMarshall,
                    NdrpSimpleTypeLongMarshall,
                    
                    NdrpSimpleTypeHyperMarshall,                    
                    NdrpSimpleTypeHyperMarshall,    // FC64_UINT64
                    
                    NdrpSimpleTypeInvalidMarshall,                    
                    NdrpSimpleTypeInvalidMarshall,     // FC64_INT128
                    
                    NdrpSimpleTypeLongMarshall,         // FC64_FLOAT32
                    NdrpSimpleTypeHyperMarshall,
                    
                    NdrpSimpleTypeInvalidMarshall,                       
                    NdrpSimpleTypeInvalidMarshall,                    
                    NdrpSimpleTypeInvalidMarshall,      // 0xF
                    
                    NdrpSimpleTypeCharMarshall,         // FC64_CHAR
                    
                    NdrpSimpleTypeShortMarshall,        // FC64_WCHAR
                    NdrpSimpleTypeIgnoreMarshall,

                    NdrpSimpleTypeLongMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall,
                    NdrpSimpleTypeInvalidMarshall   // make it 32 entries.
                    };
    


void 
Ndr64SimpleTypeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    uchar               FormatChar )
/*++

Routine Description :

    Marshalls a simple type.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the data to be marshalled.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
/*
    switch ( FormatChar )
        {
        case FC64_CHAR :
        case FC64_UINT8:
        case FC64_INT8:
            *(pStubMsg->Buffer)++ = *pMemory;
            break;
        case FC64_WCHAR :
        case FC64_UINT16:
        case FC64_INT16:
            ALIGN(pStubMsg->Buffer,1);

            *((NDR64_UINT16 *)pStubMsg->Buffer) = *((NDR64_UINT16 *)pMemory);
            pStubMsg->Buffer += sizeof(NDR64_UINT16);
            break;

        case FC64_UINT32:
        case FC64_INT32:
        case FC64_ERROR_STATUS_T:
        case FC64_FLOAT32:
            ALIGN(pStubMsg->Buffer,3);

            *((NDR64_UINT32 *)pStubMsg->Buffer)  = *((NDR64_UINT32 *)pMemory);
            pStubMsg->Buffer += sizeof(NDR64_UINT32);
            break;

        case FC64_UINT64:
        case FC64_INT64:
        case FC64_FLOAT64:
            ALIGN(pStubMsg->Buffer,7);
            *((NDR64_UINT64 *)pStubMsg->Buffer)   = *((NDR64_UINT64 *)pMemory);
            pStubMsg->Buffer += sizeof(NDR64_UINT64);
            break;

        case FC64_IGNORE:
            break;

        default :
            NDR_ASSERT(0,"Ndr64SimpleTypeMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
*/
        
    NDR_ASSERT( FormatChar <= FC64_ERROR_STATUS_T, "bad format char");
    Ndr64SimpleTypeMarshallRoutinesTable[FormatChar](pStubMsg, pMemory );
}

void
Ndr64UDTSimpleTypeMarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       FormatString )
{
    Ndr64SimpleTypeMarshall(pStubMsg,pMemory,*(PFORMAT_STRING)FormatString);
}


void 
Ndr64pRangeMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++
--*/
{
    const NDR64_RANGE_FORMAT * pRangeFormat =
        (const NDR64_RANGE_FORMAT*)pFormat;

    Ndr64SimpleTypeMarshall( pStubMsg, pMemory, pRangeFormat->RangeType );
}


void 
Ndr64pInterfacePointerMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the interface pointer being marshalled.
    pFormat     - Interface pointer's format string description.

Return :

    None.

Notes : There is now one representation of a marshalled interface pointer.

    // wire representation of a marshalled interface pointer
    typedef struct tagMInterfacePointer
    {
        ULONG           ulCntData;          // size of data
        [size_is(ulCntData)] BYTE abData[]; // data (OBJREF)
    } MInterfacePointer;

--*/
{

    const NDR64_CONSTANT_IID_FORMAT *pConstInterfaceFormat =
        (NDR64_CONSTANT_IID_FORMAT*)pFormat;
    const NDR64_IID_FORMAT *pInterfaceFormat =
        (NDR64_IID_FORMAT*)pFormat;

    //
    // Get an IID pointer.
    //
    IID *piid;
    if ( ((NDR64_IID_FLAGS*)&pInterfaceFormat->Flags)->ConstantIID )
        {
        piid = (IID*)&pConstInterfaceFormat->Guid;
        
        }
    else
        {

        piid = (IID *) Ndr64EvaluateExpr( pStubMsg,
                                          pInterfaceFormat->IIDDescriptor,
                                          EXPR_IID );
        if(piid == 0)
            {
            RpcRaiseException( RPC_S_INVALID_ARG );
            return;
            }

        }

    // Leave space in the buffer for the conformant size.

    ZeroOutGapAndAlign( pStubMsg, NDR64_WIRE_COUNT_ALIGN );
    NDR64_WIRE_COUNT_TYPE * pMaxCount = (NDR64_WIRE_COUNT_TYPE *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
    ulong *pulCntData = (ulong *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(ulong);

    //Calculate the maximum size of the stream.

    ulong position = (ulong)( pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer);
    ulong cbMax = pStubMsg->RpcMsg->BufferLength - position;

    //Create a stream on memory.

    IStream *pStream = NdrpCreateStreamOnMemory(pStubMsg->Buffer, cbMax);
    if(pStream == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        return;
        }

    RpcTryFinally
        {
        
        HRESULT hr = (*pfnCoMarshalInterface)(pStream, *piid, (IUnknown *)pMemory, 
                                              pStubMsg->dwDestContext, pStubMsg->pvDestContext, 0);
        if(FAILED(hr))
            {
            RpcRaiseException(hr);
            return;
            }
        
        ULARGE_INTEGER libPosition;
        LARGE_INTEGER libMove;
        libMove.QuadPart = 0;
        pStream->Seek(libMove, STREAM_SEEK_CUR, &libPosition);

        //Update the array bounds.
        *pMaxCount = libPosition.QuadPart;

        //Advance the stub message buffer pointer.
        pStubMsg->Buffer += (*pulCntData = Ndr64pConvertTo2GB(libPosition.QuadPart));

        }
    RpcFinally
        {
        pStream->Release(); 
        }
    RpcEndFinally
}


__forceinline void
Ndr64pPointerMarshallInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )

/*++

Routine Description :

    Private routine for marshalling a pointer and its pointee.  This is the
    entry point for pointers embedded in structures, arrays, and unions.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pBufferMark - Pointer to the pointer in the wire buffer.
    pMemory     - Pointer to the data to be marshalled.
    pFormat     - Pointer format string description.

    pStubMsg->Buffer - the place for the pointee.

Return :

    None.

--*/

{
    
    const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;

    //
    // Check the pointer type.
    //
    switch ( pPointerFormat->FormatCode )
        {

        case FC64_RP :
            if ( pBufferMark )
                {
                // Put the pointer in the buffer.
                *((NDR64_PTR_WIRE_TYPE*)pBufferMark) = PTR_WIRE_REP(pMemory);
                }

            if ( !pMemory )
                {
                RpcRaiseException( RPC_X_NULL_REF_POINTER );
                }
            break;

        case FC64_UP :
        case FC64_OP :
            // Put the pointer in the buffer.
            *((NDR64_PTR_WIRE_TYPE*)pBufferMark) = PTR_WIRE_REP(pMemory);

            if ( ! pMemory )
                {
                return;
                }

            break;

        case FC64_IP :
            // Put the pointer in the buffer
            *((NDR64_PTR_WIRE_TYPE*)pBufferMark) = PTR_WIRE_REP(pMemory);

            if ( ! pMemory )
                {
                return;
                }

            Ndr64pInterfacePointerMarshall (pStubMsg,
                                            pMemory,
                                            pPointerFormat->Pointee
                                            );
            return;

        case FC64_FP :
            //
            // Marshall the pointer's ref id and see if we've already
            // marshalled the pointer's data.
            //
            
            {
            ulong RefId;
 
            BOOL Result = 
                Ndr64pFullPointerQueryPointer( pStubMsg,
                                               pMemory,
                                               FULL_POINTER_MARSHALLED,
                                               &RefId );
            
            *(NDR64_PTR_WIRE_TYPE*)pBufferMark = Ndr64pRefIdToWirePtr( RefId );
            if ( Result )
                return;
            
            }
            break;

        default :
            NDR_ASSERT(0,"Ndr64pPointerMarshall : bad pointer type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
        {
        Ndr64SimpleTypeMarshall( pStubMsg,
                                 pMemory,
                                 *(PFORMAT_STRING)pPointerFormat->Pointee );
        return;
        }

    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        pMemory = *((uchar **)pMemory);

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags ); 
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);
    
    Ndr64TopLevelTypeMarshall(
        pStubMsg,
        pMemory,
        pPointerFormat->Pointee );

}

NDR64_MRSHL_POINTER_QUEUE_ELEMENT::NDR64_MRSHL_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg, 
    NDR64_PTR_WIRE_TYPE * pBufferMarkNew,
    uchar * const pMemoryNew,
    const PFORMAT_STRING pFormatNew) :

        pBufferMark(pBufferMarkNew),
        pMemory(pMemoryNew),
        pFormat(pFormatNew),
        uFlags(pStubMsg->uFlags),
        pCorrMemory(pStubMsg->pCorrMemory)
{

}

void 
NDR64_MRSHL_POINTER_QUEUE_ELEMENT::Dispatch(
    MIDL_STUB_MESSAGE *pStubMsg) 
{

    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags, uFlags ); 
    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pCorrMemory ); 
    
    Ndr64pPointerMarshallInternal( pStubMsg,
                                   pBufferMark,
                                   pMemory,
                                   (PNDR64_FORMAT)pFormat );
}

#if defined(DBG)
void 
NDR64_MRSHL_POINTER_QUEUE_ELEMENT::Print() 
{
    DbgPrint("NDR_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pBufferMark:             %p\n", pBufferMark );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pCorrMemory:             %p\n", pCorrMemory );
    DbgPrint("uFlags:                  %x\n", uFlags );
}
#endif

void
Ndr64pEnquePointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        NDR64_MRSHL_POINTER_QUEUE_ELEMENT*pElement = 
            new(PointerContext.GetActiveState()) 
                NDR64_MRSHL_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                 pBufferMark,
                                                 pMemory,
                                                 (PFORMAT_STRING)pFormat);
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void
Ndr64pPointerMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags);
    
    if ( !NdrIsLowStack(pStubMsg) )
        {
        Ndr64pPointerMarshallInternal( pStubMsg,
                                       pBufferMark,
                                       pMemory,
                                       pFormat );
        return;
        }

    Ndr64pEnquePointerMarshall(
        pStubMsg,
        pBufferMark,
        pMemory,
        pFormat );
}

__forceinline void
Ndr64TopLevelPointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_PTR_WIRE_TYPE *pBufferMark = NULL;

    // Non embedded ref pointers do not have a wire representation
    if ( *(PFORMAT_STRING)pFormat != FC64_RP )
        {
        ZeroOutGapAndAlign( pStubMsg, NDR64_PTR_WIRE_ALIGN );
        pBufferMark        = (NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer;
        pStubMsg->Buffer   += sizeof(NDR64_PTR_WIRE_TYPE);
        }

    Ndr64pPointerMarshall( pStubMsg,
                           pBufferMark,
                           pMemory,
                           pFormat );
}

__forceinline void
Ndr64EmbeddedPointerMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    ZeroOutGapAndAlign( pStubMsg, NDR64_PTR_WIRE_ALIGN );
    NDR64_PTR_WIRE_TYPE* pBufferMark = (NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer;
    pStubMsg->Buffer   += sizeof(NDR64_PTR_WIRE_TYPE);

    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

    Ndr64pPointerMarshall( pStubMsg,
                           pBufferMark,
                           *(uchar**)pMemory,
                           pFormat );

}


void 
Ndr64SimpleStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a simple structure.

    Used for FC64_STRUCT and FC64_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_UINT32 StructSize = pStructFormat->MemorySize;

    ZeroOutGapAndAlign(pStubMsg, pStructFormat->Alignment);

    uchar *pBufferSave = pStubMsg->Buffer;

        RpcpMarshalMemoryCopy( pBufferSave,
                    pMemory,
                    pStructFormat->MemorySize );

    pStubMsg->Buffer += pStructFormat->MemorySize;

    // Marshall embedded pointers.
    if ( pStructFormat->Flags.HasPointerInfo )
        {
        CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory); 

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pStructFormat + 1,
                                     0,
                                     pMemory,
                                     pBufferSave );
        
        }

}


void 
Ndr64ConformantStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a conformant structure.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure to be marshalled.
    pFormat     - Structure's format string description.

Return :

    None.       

Note

--*/
{

    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =  
        (NDR64_CONF_ARRAY_HEADER_FORMAT *) pStructFormat->ArrayDescription;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
    
    NDR64_WIRE_COUNT_TYPE MaxCount = 
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->ConfDescriptor,
                           EXPR_MAXCOUNT );

    if ( NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        *(NDR64_WIRE_COUNT_TYPE *)pStubMsg->ConformanceMark = MaxCount;
    else
        {
        ZeroOutGapAndAlign( pStubMsg, NDR64_WIRE_COUNT_ALIGN );

        *((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer) = MaxCount;
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }


    ZeroOutGapAndAlign(pStubMsg, pStructFormat->Alignment);
    uchar *pBufferStart = pStubMsg->Buffer;

    NDR64_UINT32 StructSize = Ndr64pConvertTo2GB( (NDR64_UINT64)pStructFormat->MemorySize +
                                                  ( MaxCount * (NDR64_UINT64)pArrayFormat->ElementSize ) );

    RpcpMarshalMemoryCopy( pBufferStart,
                    pMemory,
                    StructSize );

    pStubMsg->Buffer += StructSize;

    if ( pStructFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pStructFormat + 1,
                                     (NDR64_UINT32)MaxCount,
                                     pMemory,
                                     pBufferStart );
        }
}


void 
Ndr64ComplexStructMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a complex structure.

    Used for FC64_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the structure being marshalled.
    pFormat     - Structure's format string description.
    
Return :

    None.
    
Notes :

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    uchar *         pBufferSave = pStubMsg->Buffer;

    bool fSetPointerBufferMark = ! pStubMsg->PointerBufferMark;
    // Compute where the pointees should be unmarshalled to.
    if ( fSetPointerBufferMark )
        {
        BOOL fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        //
        // Set BufferLength equal to the current buffer pointer, and then
        // when we return from NdrComplexStructBufferSize it will pointer to
        // the location in the buffer where the pointees should be marshalled.
        //     pStubMsg->BufferLength = pBufferSave;
        // Instead of pointer, we now calculate pointer increment explicitly.

        // Set the pointer alignment as a base.
        // We use pBufferSave as the sizing routine accounts for the conf sizes.
        //
        ulong BufferLenOffset = 0xf & PtrToUlong( pBufferSave );
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->BufferLength = BufferLenOffset;

        Ndr64ComplexStructBufferSize( 
            pStubMsg,
            pMemory,
            pFormat );

        // Pointer increment including alignments.
        BufferLenOffset = pStubMsg->BufferLength - BufferLenOffset;

        // Set the location in the buffer where pointees will be marshalled.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer + BufferLenOffset;
        pStubMsg->BufferLength = BufferLengthSave;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        }

    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING)pStructFormat->PointerLayout;
    PFORMAT_STRING  pFormatArray = NULL;
    
    BOOL            fIsFullBogus  = ( *(PFORMAT_STRING)pFormat == FC64_BOGUS_STRUCT ||
                                      *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT );

    PFORMAT_STRING  pMemberLayout =  ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                       *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                     (PFORMAT_STRING)( pConfStructFormat + 1) :
                                     (PFORMAT_STRING)( pStructFormat + 1);

    SAVE_CONTEXT<uchar*> ConformanceMarkSave(pStubMsg->ConformanceMark);
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );

    // Get conformant array description.
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;

        if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
            {
            // Align for conformance marshalling.
            ZeroOutGapAndAlign(pStubMsg, NDR64_WIRE_COUNT_ALIGN);

            // Remember where the conformance count(s) will be marshalled.
            pStubMsg->ConformanceMark = pStubMsg->Buffer;

            // Increment the buffer pointer for every array dimension.
            pStubMsg->Buffer += pConfStructFormat->Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE);

            NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );
            }
        }
    else
        pFormatArray = 0;

    // Align buffer on struct's alignment.
    ZeroOutGapAndAlign(pStubMsg, pStructFormat->Alignment);

    //
    // Marshall the structure member by member.
    //
    for ( ; ; )
        {
        switch ( *pMemberLayout )
            {

            case FC64_STRUCT:
                {
                const NDR64_SIMPLE_REGION_FORMAT *pRegion = 
                    (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;
                
                ZeroOutGapAndAlign( pStubMsg, pRegion->Alignment );
                
                RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                                pMemory,
                                pRegion->RegionSize );

                pStubMsg->Buffer += pRegion->RegionSize;
                pMemory          += pRegion->RegionSize;

                pMemberLayout    += sizeof( *pRegion );
                break;
                }

            case FC64_STRUCTPADN :
                {
                const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
                pMemory         += pMemPad->MemPad;
                pMemberLayout   += sizeof(*pMemPad);
                break;
                }

            case FC64_POINTER :
                {

                NDR_ASSERT(pFormatPointers, "Ndr64ComplexStructMarshall: pointer field but no pointer layout");

                Ndr64EmbeddedPointerMarshall( 
                    pStubMsg,
                    pMemory,
                    pFormatPointers );

                pMemory += PTR_MEM_SIZE;

                pFormatPointers     += sizeof(NDR64_POINTER_FORMAT);
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT); 

                break;
                }

            case FC64_EMBEDDED_COMPLEX :

                {
                const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                    (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                Ndr64EmbeddedTypeMarshall( pStubMsg,
                                           pMemory,
                                           pEmbeddedFormat->Type );

                pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pEmbeddedFormat->Type,
                                               FALSE );

                pMemberLayout += sizeof(*pEmbeddedFormat);
                break;                
                }

            case FC64_BUFFER_ALIGN:
                 { 
                 const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign = 
                     (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                 ZeroOutGapAndAlign(pStubMsg, pBufAlign->Alignment);                 
                 pMemberLayout += sizeof( *pBufAlign );
                 break;
                 }
            
            case FC64_CHAR :
            case FC64_WCHAR :
            case FC64_INT8:
            case FC64_UINT8:
            case FC64_INT16:
            case FC64_UINT16:
            case FC64_INT32:
            case FC64_UINT32:
            case FC64_INT64:
            case FC64_UINT64:
            case FC64_FLOAT32 :
            case FC64_FLOAT64 :
            case FC64_ERROR_STATUS_T:
                Ndr64SimpleTypeMarshall( pStubMsg,
                                       pMemory,
                                       *pMemberLayout );

                pMemory       += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);
                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;

            case FC64_IGNORE :
                ZeroOutGapAndAlign(pStubMsg, NDR64_PTR_WIRE_ALIGN );
                pMemory          += PTR_MEM_SIZE;
                *(NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer = 0;
                pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
                pMemberLayout    += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);                
                break;

            case FC64_END :
                goto ComplexMarshallEnd;

            default :
                NDR_ASSERT(0,"Ndr64ComplexStructMarshall : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            } // switch
        } // for

ComplexMarshallEnd:

    //
    // Marshall conformant array if we have one.
    if ( pFormatArray )
        {

        Ndr64EmbeddedTypeMarshall( pStubMsg,
                                   pMemory,
                                   pFormatArray );

        }
    else 
        {
        // If the structure doesn't have a conformant array, align it again
        ZeroOutGapAndAlign( pStubMsg, pStructFormat->Alignment );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        }
}


void 
Ndr64NonConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a non conformant string.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{
    const NDR64_NON_CONFORMANT_STRING_FORMAT * pStringFormat = 
        (NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_UINT32 CopySize = 
        Ndr64pCommonStringSize( pStubMsg,
                                pMemory,
                                &pStringFormat->Header );    

    if ( CopySize >  pStringFormat->TotalSize )
        RpcRaiseException(RPC_X_INVALID_BOUND);

    ZeroOutGapAndAlign( pStubMsg, NDR64_WIRE_COUNT_ALIGN );
    ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[0] = pStubMsg->Offset;
    ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[1] = pStubMsg->ActualCount;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    // Copy the string.
    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    pStubMsg->Buffer += CopySize;

}


void 
Ndr64ConformantStringMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine description :

    Marshalls a conformant string.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the string to be marshalled.
    pFormat     - String's format string description.

Return :

    None.

--*/
{

    const NDR64_CONFORMANT_STRING_FORMAT * pStringFormat =
        (const NDR64_CONFORMANT_STRING_FORMAT*) pFormat;
    const NDR64_SIZED_CONFORMANT_STRING_FORMAT * pSizedStringFormat =
        (const NDR64_SIZED_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE    *pMaxCountMark;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
       {
       ZeroOutGapAndAlign( pStubMsg, NDR64_WIRE_COUNT_ALIGN );
       pMaxCountMark = (NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer;
       pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
       }
    else 
       {
       pMaxCountMark = (NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
       }    
    
    NDR64_UINT32 CopySize = 
        Ndr64pCommonStringSize( pStubMsg,
                                pMemory,
                                &pStringFormat->Header );    
    
    //
    // If the string is sized then compute the max count, otherwise the
    // max count is equal to the actual count.
    //
    NDR64_WIRE_COUNT_TYPE MaxCount = pStubMsg->ActualCount;    
    if ( pStringFormat->Header.Flags.IsSized )
        {
        MaxCount = 
            Ndr64EvaluateExpr( pStubMsg,
                               pSizedStringFormat->SizeDescription,
                               EXPR_MAXCOUNT );

        if ( pStubMsg->ActualCount >  MaxCount )
            RpcRaiseException(RPC_X_INVALID_BOUND);
        
        }

    
    // Marshall the max count.
    *pMaxCountMark  = MaxCount;

    ZeroOutGapAndAlign( pStubMsg, NDR64_WIRE_COUNT_ALIGN);
    ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[0] = pStubMsg->Offset;
    ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[1] = pStubMsg->ActualCount;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update the Buffer pointer.
    pStubMsg->Buffer += CopySize;

}


void 
Ndr64FixedArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a fixed array of any number of dimensions.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array to be marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{

    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;

    // Align the buffer.
    ZeroOutGapAndAlign( pStubMsg, pArrayFormat->Alignment );
    uchar *pBufferStart = pStubMsg->Buffer;                                                
    
    // Copy the array.
        RpcpMarshalMemoryCopy( pBufferStart,
                    pMemory,
                    pArrayFormat->TotalSize );

    // Increment stub message buffer pointer.
    pStubMsg->Buffer += pArrayFormat->TotalSize;

    // Marshall embedded pointers.
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pArrayFormat + 1,
                                     0,
                                     pMemory,
                                     pBufferStart );
        }

}


void 
Ndr64ConformantArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a top level one dimensional conformant array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;
    
    uchar *pConformanceMark;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        
        // Align the buffer for conformance marshalling.
        ZeroOutGapAndAlign(pStubMsg,NDR64_WIRE_COUNT_ALIGN);
        pConformanceMark = pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else 
        {
        pConformanceMark = pStubMsg->ConformanceMark;
        }

    NDR64_WIRE_COUNT_TYPE MaxCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->ConfDescriptor,
                           EXPR_MAXCOUNT );

    *(NDR64_WIRE_COUNT_TYPE*)pConformanceMark = MaxCount;


    // Compute the total array size in bytes.
    NDR64_UINT32 CopySize = 
        Ndr64pConvertTo2GB(MaxCount * (NDR64_UINT64)pArrayFormat->ElementSize);


    ZeroOutGapAndAlign( pStubMsg, pArrayFormat->Alignment );

    // doesn't need further processing here. 
    if ( CopySize == 0 )
        return;
    
    RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update buffer pointer.
    uchar *pBufferStart =  pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;

    // Marshall embedded pointers.
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pArrayFormat + 1,
                                     (NDR64_UINT32)MaxCount,
                                     pMemory,
                                     pBufferStart );
        
        }
}


void 
Ndr64ConformantVaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a top level one dimensional conformant varying array.

    Used for FC64_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;
    
    uchar *pConformanceMark;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ZeroOutGapAndAlign( pStubMsg, NDR64_WIRE_COUNT_ALIGN);
        pConformanceMark = pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        pConformanceMark = pStubMsg->ConformanceMark;
        }

    NDR64_WIRE_COUNT_TYPE MaxCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->ConfDescriptor,
                           EXPR_MAXCOUNT );

    NDR64_WIRE_COUNT_TYPE ActualCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->VarDescriptor,
                           EXPR_ACTUALCOUNT );
    
    if ( ActualCount > MaxCount )
        RpcRaiseException( RPC_X_INVALID_BOUND );
    
    *(NDR64_WIRE_COUNT_TYPE*)pConformanceMark = MaxCount;

    // Align the buffer for variance marshalling.
    ZeroOutGapAndAlign(pStubMsg, NDR64_WIRE_COUNT_ALIGN);

    // Marshall variance.
    ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0] = 0;
    ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1] = ActualCount;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 CopySize = 
        Ndr64pConvertTo2GB( ActualCount * 
                           (NDR64_UINT64)pArrayFormat->ElementSize );
    
    ZeroOutGapAndAlign( pStubMsg, pArrayFormat->Alignment );

    if ( CopySize == 0 )
        return;

    // Copy the array.
        RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );
    
    uchar *pBufferStart = pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;

    // Marshall embedded pointers.
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pArrayFormat + 1,
                                     (NDR64_UINT32)ActualCount,
                                     pMemory,
                                     pBufferStart );
        }

}


void 
Ndr64VaryingArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a top level or embedded one dimensional varying array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    // Compute the variance offset and count.
    NDR64_WIRE_COUNT_TYPE ActualCount =
        Ndr64EvaluateExpr( pStubMsg,
                           pArrayFormat->VarDescriptor,
                           EXPR_ACTUALCOUNT );
    
    NDR64_UINT32 CopySize = 
        Ndr64pConvertTo2GB( ActualCount * (NDR64_UINT64)pArrayFormat->ElementSize );

    // Align the buffer for variance marshalling.
    ZeroOutGapAndAlign(pStubMsg, NDR64_WIRE_COUNT_ALIGN );

    // Marshall variance.
    ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0] = 0;
    ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1] = ActualCount;
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    ZeroOutGapAndAlign(pStubMsg, pArrayFormat->Alignment);
 
    if ( CopySize == 0 )
        return;
    
    // Copy the array.
        RpcpMarshalMemoryCopy( pStubMsg->Buffer,
                    pMemory,
                    CopySize );

    // Update buffer pointer.
    uchar *pBufferStart =  pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;

    // Marshall embedded pointers.
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMarshall( pStubMsg,
                                     pArrayFormat + 1,
                                     (NDR64_UINT32)ActualCount,
                                     pMemory,
                                     pBufferStart );
        }

}


void 
Ndr64ComplexArrayMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls a top level complex array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the array being marshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;

    bool fSetPointerBufferMark = ! pStubMsg->PointerBufferMark;

    if ( fSetPointerBufferMark )
        {
        BOOL fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;

        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        ulong BufferLenOffset = 0xf & PtrToUlong( pStubMsg->Buffer );
        ulong BufferLengthSave = pStubMsg->BufferLength;
        pStubMsg->BufferLength = BufferLenOffset;

        Ndr64ComplexArrayBufferSize( pStubMsg,
                                     pMemory,
                                     pFormat );

        // Pointer increment including alignments.
        BufferLenOffset = pStubMsg->BufferLength - BufferLenOffset;

        //
        // This is the buffer pointer to the position where embedded pointers
        // will be marshalled.
        //
        pStubMsg->PointerBufferMark = pStubMsg->Buffer + BufferLenOffset;
        pStubMsg->BufferLength = BufferLengthSave;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        }

    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

    PFORMAT_STRING      pElementFormat   = (PFORMAT_STRING)pArrayFormat->Element;

    NDR64_WIRE_COUNT_TYPE Elements = pArrayFormat->NumberElements;
    NDR64_WIRE_COUNT_TYPE Count = Elements;
    NDR64_WIRE_COUNT_TYPE Offset   = 0;

    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
    SAVE_CONTEXT<uchar*> VarianceMarkSave( pStubMsg->VarianceMark );
    SAVE_CONTEXT<uchar>  uFlagsSave( pStubMsg->uFlags );

    if ( !IsFixed )
        {
        
        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
             (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        if (  pConfVarFormat->ConfDescription != 0 )
            {

            if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
                {
                //
                // Outer most dimension sets the conformance marker.
                //

                // Align the buffer for conformance marshalling.
                ZeroOutGapAndAlign(pStubMsg, NDR64_WIRE_COUNT_ALIGN);

                // Mark where the conformance count(s) will be marshalled.
                pStubMsg->ConformanceMark = pStubMsg->Buffer;

                // Increment past where the conformance will go.
                pStubMsg->Buffer += pArrayFormat->NumberDims * sizeof(NDR64_WIRE_COUNT_TYPE);

                NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );
                }

            Elements = Ndr64EvaluateExpr( pStubMsg,
                                          pConfVarFormat->ConfDescription,
                                          EXPR_MAXCOUNT );

            *(NDR64_WIRE_COUNT_TYPE*) pStubMsg->ConformanceMark = Elements;
            pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);

            Offset = 0;
            Count  = Elements;
            }

        //
        // Check for variance description.
        //
        if ( pConfVarFormat->VarDescription != 0 )
            {
            if ( ! NDR64_IS_VAR_MARK_VALID( pStubMsg->uFlags ) )
                {

                NDR64_UINT32 Dimensions;
                //
                // Set the variance marker.
                //

                ZeroOutGapAndAlign(pStubMsg, NDR64_WIRE_COUNT_ALIGN );

                Dimensions = ( pArrayFormat->Flags.IsArrayofStrings ) ? ( pArrayFormat->NumberDims - 1) :
                                                                        ( pArrayFormat->NumberDims );

                // Increment past where the variance will go.
                pStubMsg->VarianceMark  =  pStubMsg->Buffer;
                pStubMsg->Buffer        += Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

                if ( NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                    NDR64_SET_VAR_MARK_VALID( pStubMsg->uFlags );

                }

            else if ( !NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                NDR64_RESET_VAR_MARK_VALID( pStubMsg->uFlags );
                
            Count =
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->VarDescription,
                                   EXPR_ACTUALCOUNT );

            Offset =
                Ndr64EvaluateExpr( pStubMsg,
                                   pConfVarFormat->OffsetDescription,
                                   EXPR_OFFSET );

            if ( Count + Offset > Elements )
                RpcRaiseException( RPC_X_INVALID_BOUND );

            ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[0]  =   Offset;
            ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[1]  =   Count;
            pStubMsg->VarianceMark += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

            }

        }


    NDR64_UINT32 ElementMemorySize =
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          FALSE );

    pMemory += Ndr64pConvertTo2GB( Offset * 
                                  (NDR64_UINT64)ElementMemorySize);

    Ndr64pConvertTo2GB( Elements *
                        (NDR64_UINT64)ElementMemorySize );
    Ndr64pConvertTo2GB( Count *
                        (NDR64_UINT64)ElementMemorySize );

    ZeroOutGapAndAlign(pStubMsg, pArrayFormat->Alignment);

    for ( ; Count--; )
        {
        Ndr64EmbeddedTypeMarshall( pStubMsg,
                                       pMemory,
                                       pElementFormat );
        pMemory += ElementMemorySize;
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        }
}


void 
Ndr64UnionMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Marshalls an encapsulated union.

    Used for FC64_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the union being marshalled.
    pFormat     - Union's format string description.

Return :

    None.

--*/
{   
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;

    EXPR_VALUE          SwitchIs;
    NDR64_FORMAT_CHAR   SwitchType;

    uchar *pArmMemory;
    switch(*(PFORMAT_STRING)pFormat)
        {
        case FC64_NON_ENCAPSULATED_UNION:
            {
            const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
                (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;

            ZeroOutGapAndAlign(pStubMsg, pNonEncapUnionFormat->Alignment);
            SwitchType      = pNonEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);
                        
            SwitchIs   = Ndr64EvaluateExpr( pStubMsg,
                                            pNonEncapUnionFormat->Switch,
                                            EXPR_SWITCHIS );

            pArmMemory = pMemory;
            break;
            }
        case FC64_ENCAPSULATED_UNION:
            {
            const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
                (const NDR64_ENCAPSULATED_UNION*)pFormat;

            ZeroOutGapAndAlign(pStubMsg, pEncapUnionFormat->Alignment);
            SwitchType      = pEncapUnionFormat->SwitchType;
            pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);

            SwitchIs        = Ndr64pSimpleTypeToExprValue(SwitchType,
                                                          pMemory);

            pArmMemory      = pMemory + pEncapUnionFormat->MemoryOffset;
            break;
            }
        default:
            NDR_ASSERT(0, "Bad union format\n");
        }

    Ndr64SimpleTypeMarshall( pStubMsg,
                           (uchar *)&SwitchIs,
                           SwitchType );

    ZeroOutGapAndAlign(pStubMsg, pArmSelector->Alignment);
    
    PNDR64_FORMAT pArmFormat = 
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector,
                            SwitchIs );

    if ( !pArmFormat )
        return;

    Ndr64EmbeddedTypeMarshall( pStubMsg,
                               pArmMemory,
                               pArmFormat );
}


void 
Ndr64XmitOrRepAsMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    bool                bIsEmbedded )
/*++

Routine Description :

    Marshalls a transmit as or represent as argument:
        - translate the presented object into a transmitted object
        - marshall the transmitted object
        - free the transmitted object

    Format string layout:
        check out ndr64types.h

Arguments :

    pStubMsg    - a pointer to the stub message
    pMemory     - presented type translated into transmitted type
                  and than to be marshalled
    pFormat     - format string description

--*/
{

    // Skip the token itself and Oi flag. Fetch the QuintupleIndex.

    NDR64_TRANSMIT_AS_FORMAT    *  pTransFormat = 
        ( NDR64_TRANSMIT_AS_FORMAT *) pFormat;

    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );
    
    unsigned short QIndex = pTransFormat->RoutineIndex;

    // First translate the presented type into the transmitted type.
    // This includes an allocation of a transmitted type object.

    pStubMsg->pPresentedType = pMemory;
    pStubMsg->pTransmitType = NULL;
    const XMIT_ROUTINE_QUINTUPLE * pQuintuple = 
        pStubMsg->StubDesc->aXmitQuintuple;
    pQuintuple[ QIndex ].pfnTranslateToXmit( pStubMsg );

    unsigned char * pTransmittedType = pStubMsg->pTransmitType;
   
    // In NDR64, Xmit/Rep cannot be a pointer or contain a pointer.
    // So we don't need to worry about the pointer queue here.

    if ( bIsEmbedded )
        {
        Ndr64EmbeddedTypeMarshall( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
        }
    else 
        {
        Ndr64TopLevelTypeMarshall( pStubMsg,
                                   pTransmittedType,
                                   pTransFormat->TransmittedType );
        }

    pStubMsg->pTransmitType = pTransmittedType;

    // Free the temporary transmitted object (it was allocated by the user).

    pQuintuple[ QIndex ].pfnFreeXmit( pStubMsg );

}

void 
Ndr64TopLevelXmitOrRepAsMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsMarshall( pStubMsg,
                              pMemory,
                              pFormat,
                              false );
}

void 
Ndr64EmbeddedXmitOrRepAsMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsMarshall( pStubMsg,
                              pMemory,
                              pFormat,
                              true );
}

void
Ndr64UserMarshallMarshallInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    NDR64_PTR_WIRE_TYPE *pWirePtr )
{

    NDR64_USER_MARSHAL_FORMAT  * pUserFormat = 
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    unsigned char * pUserBuffer = pStubMsg->Buffer;
    unsigned char * pUserBufferSaved = pUserBuffer;

    // We always call user's routine to marshall.
    USER_MARSHAL_CB UserMarshalCB;
    Ndr64pInitUserMarshalCB( pStubMsg,
                           pUserFormat,
                           USER_MARSHAL_CB_MARSHALL,  
                           & UserMarshalCB );

    unsigned short QIndex = pUserFormat->RoutineIndex;
    const USER_MARSHAL_ROUTINE_QUADRUPLE * pQuadruple = 
        (const USER_MARSHAL_ROUTINE_QUADRUPLE *)( ( NDR_PROC_CONTEXT *)pStubMsg->pContext )->pSyntaxInfo->aUserMarshalQuadruple;   

    if ((pUserBufferSaved < (uchar *) pStubMsg->RpcMsg->Buffer) ||
        ((unsigned long) (pUserBufferSaved - (uchar *) pStubMsg->RpcMsg->Buffer) 
                                           > pStubMsg->RpcMsg->BufferLength)) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        } 

    pUserBuffer = pQuadruple[ QIndex ].pfnMarshall( (ulong*) &UserMarshalCB,
                                                    pUserBuffer,
                                                    pMemory );

    if ((pUserBufferSaved > pUserBuffer) || 
        ((unsigned long) (pUserBuffer - (uchar *) pStubMsg->RpcMsg->Buffer)
                                      > pStubMsg->RpcMsg->BufferLength )) 
        {
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        }

    if ( pUserBuffer == pUserBufferSaved )
        {
        // This is valid only if the wire type was a unique type.

        if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE) )
            {
            *pWirePtr = 0;
            return;
            }
        else
            RpcRaiseException( RPC_X_NULL_REF_POINTER );
        }

    pStubMsg->Buffer = pUserBuffer;
    
}

void 
NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{
    Ndr64UserMarshallMarshallInternal( pStubMsg,
                                       pMemory,
                                       pFormat,
                                       pWireMarkerPtr );
}

#if defined(DBG)
void 
NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pWireMarkerPtr:          %p\n", pWireMarkerPtr );
}
#endif


void
Ndr64UserMarshallPointeeMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    NDR64_PTR_WIRE_TYPE *pWirePtr )
{

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {

        POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

        Ndr64UserMarshallMarshallInternal( 
            pStubMsg,
            pMemory,
            pFormat,
            pWirePtr );
        return;
        }

    NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT*pElement = 
       new(pStubMsg->pPointerQueueState) 
           NDR64_USR_MRSHL_MRSHL_POINTER_QUEUE_ELEMENT(pMemory,
                                                       (PFORMAT_STRING)pFormat,
                                                       pWirePtr);
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );

}


void
Ndr64UserMarshalMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    bool                bIsEmbedded )
/*++

Routine Description :

    Marshals a usr_marshall object.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Pointer to the usr_marshall object to marshall.
    pFormat     - Object's format string description.

Return :

    None.

--*/
{
    

    NDR64_USER_MARSHAL_FORMAT  * pUserFormat = 
        ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    NDR_ASSERT( pUserFormat->FormatCode == FC64_USER_MARSHAL, "invalid format string for user marshal" );

    ZeroOutGapAndAlign( pStubMsg, pUserFormat->TransmittedTypeWireAlignment );

    if ( pUserFormat->Flags & USER_MARSHAL_POINTER )
        {
        
        NDR64_PTR_WIRE_TYPE *pWireMarkerPtr = NULL;
        if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE )  ||
             (( pUserFormat->Flags & USER_MARSHAL_REF ) && bIsEmbedded) )
            {
            pWireMarkerPtr = (NDR64_PTR_WIRE_TYPE *) pStubMsg->Buffer;
            *((NDR64_PTR_WIRE_TYPE *)pStubMsg->Buffer) = NDR64_USER_MARSHAL_MARKER;
            pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);

            }
        
        Ndr64UserMarshallPointeeMarshall( pStubMsg,
                                          pMemory,
                                          pFormat,
                                          pWireMarkerPtr );
        return;

        }


    Ndr64UserMarshallMarshallInternal(
        pStubMsg,
        pMemory,
        pFormat,
        NULL );

}

void
Ndr64TopLevelUserMarshalMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{
    Ndr64UserMarshalMarshall( pStubMsg,
                              pMemory,
                              pFormat,
                              false );
}

void
Ndr64EmbeddedUserMarshalMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    Ndr64UserMarshalMarshall( pStubMsg,
                              pMemory,
                              pFormat,
                              true );
}



void 
Ndr64ServerContextNewMarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR_SCONTEXT        ContextHandle,
    NDR_RUNDOWN         RundownRoutine,
    PFORMAT_STRING      pFormat )
/*
    This is a non-optimized NDR engine entry for context handle marshaling.
    In particular it is able to handle all the new NT5 context handle flavors.
    The optimized routine follows below.
    
      ContextHandle - note, this is not the user's handle but a
                      NDR_SCONTEXT pointer from the stub local stack. 
                      User's handle is a field in that object.
                
    Note that intepreter calls Ndr64MarshallHandle. However, we can't use it 
    as it assumes a helper array of saved context handles that we don't need.
   
*/
{   
    void *  pGuard = RPC_CONTEXT_HANDLE_DEFAULT_GUARD;
    DWORD   Flags  = RPC_CONTEXT_HANDLE_DEFAULT_FLAGS;
    NDR64_CONTEXT_HANDLE_FORMAT * pContextFormat;

    pContextFormat = ( NDR64_CONTEXT_HANDLE_FORMAT * )pFormat;
    NDR_ASSERT( pContextFormat->FormatCode == FC64_BIND_CONTEXT, "invalid format char " );
    // NT5 beta2 features: strict context handle, serialize and noserialize.

    if ( pContextFormat->ContextFlags & NDR_STRICT_CONTEXT_HANDLE )
        {
        pGuard = pStubMsg->StubDesc->RpcInterfaceInformation;
        pGuard = & ((PRPC_SERVER_INTERFACE)pGuard)->InterfaceId;
        }
    if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_NOSERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_DONT_SERIALIZE;
        }
    else if ( pContextFormat->ContextFlags & NDR_CONTEXT_HANDLE_SERIALIZE )
        {
        Flags = RPC_CONTEXT_HANDLE_SERIALIZE;
        }

    ALIGN( pStubMsg->Buffer, 0x3 );

    NDRSContextMarshall2( 
        pStubMsg->RpcMsg->Handle,
        ContextHandle,
        pStubMsg->Buffer,
        RundownRoutine,
        pGuard,
        Flags );

    pStubMsg->Buffer += CONTEXT_HANDLE_WIRE_SIZE;
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_MARSHALL_ROUTINE extern const Ndr64MarshallRoutinesTable[] = \
{                                                     

#define NDR64_TABLE_END    \
};                       

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
    ,marshall                      

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, typebuffersize, memorysize) \
   ,Ndr64UDTSimpleTypeMarshall1 

#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64MarshallRoutinesTable)/sizeof(PNDR64_MARSHALL_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
    ,embeddedmarshall
    
#define NDR64_BEGIN_TABLE \
PNDR64_MARSHALL_ROUTINE extern const Ndr64EmbeddedMarshallRoutinesTable[] = \
{

#include "tokntbl.h"

C_ASSERT( sizeof(Ndr64EmbeddedMarshallRoutinesTable) / sizeof(PNDR64_MARSHALL_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\memsize.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 - 1999 Microsoft Corporation

Module Name :

    memsize.c

Abstract :

    This file contains the routines called by MIDL 2.0 stubs and the
    intepreter for computing the memory size needed to hold a parameter being
    unmarshalled.

Author :

    David Kays  dkays   November 1993.

Revision History :

Note:
    Simple types are not checked for buffer over-run since we are
    only reading from the buffer and not writing from it.  So if
    a buffer overun actually occures, no real damage is done.

  ---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\..\ndr20\ndrole.h"


void
Ndr64UDTSimpleTypeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT      pFormat )

/*++
--*/
{
    ALIGN(pStubMsg->Buffer, NDR64_SIMPLE_TYPE_MEMALIGN(*(PFORMAT_STRING)pFormat));

    pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE(*(PFORMAT_STRING)pFormat);

    LENGTH_ALIGN( pStubMsg->MemorySize,
                  NDR64_SIMPLE_TYPE_MEMALIGN(*(PFORMAT_STRING)pFormat) );

    pStubMsg->MemorySize += NDR64_SIMPLE_TYPE_MEMSIZE(*(PFORMAT_STRING)pFormat);
}



void
Ndr64pRangeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++
--*/
{
   const NDR64_RANGE_FORMAT * pRangeFormat =
        (const NDR64_RANGE_FORMAT*)pFormat;

   Ndr64UDTSimpleTypeMemorySize( pStubMsg,
                                 (PFORMAT_STRING)&pRangeFormat->RangeType );
}


void
Ndr64pInterfacePointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size needed for an interface pointer.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The current memory size.

    // wire representation of a marshalled interface pointer
    typedef struct tagMInterfacePointer
    {
        ULONG           ulCntData;          // size of data
        [size_is(ulCntData)] BYTE abData[]; // data (OBJREF)
    } MInterfacePointer;

--*/
{

    ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    // Unmarshal the conformant size and the count field.
    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, (sizeof(NDR64_WIRE_COUNT_TYPE)+sizeof(ulong)) );
    NDR64_UINT32 MaxCount = Ndr64pConvertTo2GB( *(NDR64_WIRE_COUNT_TYPE *) pStubMsg->Buffer );
    pStubMsg->Buffer      += sizeof(NDR64_WIRE_COUNT_TYPE);
    ulong ulCntData       = *(ulong *) pStubMsg->Buffer;
    pStubMsg->Buffer      += sizeof(ulong);

    if ( MaxCount != ulCntData )
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        return;
        }

    RpcTryFinally
        {

        CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, MaxCount );

        if( (MaxCount > 0) && NDR64_IS_WALKIP(pStubMsg->uFlags) )
        {

            IStream *pStream = (*NdrpCreateStreamOnMemory)(pStubMsg->Buffer, MaxCount);
            if(pStream == 0)
                RpcRaiseException(RPC_S_OUT_OF_MEMORY);

            HRESULT hr = (*pfnCoReleaseMarshalData)(pStream);
            pStream->Release();

            if(FAILED(hr))
                RpcRaiseException(hr);
        }

        }
    RpcFinally
        {

        pStubMsg->Buffer += MaxCount;

        }
    RpcEndFinally
}


__forceinline void
Ndr64pPointerMemorySizeInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Private routine for computing the memory size required for a pointer to
    anything.  This is the entry point for pointers embedded in structures
    arrays, or unions.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg    - Pointer to stub message.
    pBufferMark - Location in the buffer where a unique or full pointer's id is.
                  Unused for ref pointers.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;

    PFORMAT_STRING pPointeeFormat = (PFORMAT_STRING)pPointerFormat->Pointee;

    switch ( pPointerFormat->FormatCode )
        {
        case FC64_RP :
            break;

        case FC64_UP :
        case FC64_OP :
            if ( ! *pBufferMark )
                return;
            break;

        case FC64_IP :
            if ( ! *pBufferMark )
                return;


            Ndr64pInterfacePointerMemorySize(pStubMsg,
                                             pPointeeFormat );
            return;

        case FC64_FP :
            //
            // Check if we've already mem sized this full pointer.
            //
            if ( Ndr64pFullPointerQueryRefId( pStubMsg,
                                              Ndr64pWirePtrToRefId(*pBufferMark),
                                              FULL_POINTER_MEM_SIZED,
                                              0 ) )
                return;

            break;

        default :
            NDR_ASSERT(0,"Ndr64pPointerMemorySize : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // We align all memory pointers on at least a void * boundary.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, PTR_MEM_ALIGN );

    if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
        {
        ALIGN(pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( *pPointeeFormat ));
        pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( *pPointeeFormat );

        LENGTH_ALIGN( pStubMsg->MemorySize,
                      NDR64_SIMPLE_TYPE_MEMALIGN( *pPointeeFormat ) );
        pStubMsg->MemorySize += NDR64_SIMPLE_TYPE_MEMSIZE( *pPointeeFormat );

        return;
        }

    // Pointer to complex type.

    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        pStubMsg->MemorySize += PTR_MEM_SIZE;

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    Ndr64TopLevelTypeMemorySize( pStubMsg,
                                 pPointeeFormat );

    return;
}


void NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT::Dispatch(PMIDL_STUB_MESSAGE pStubMsg)
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );

    Ndr64pPointerMemorySizeInternal( pStubMsg,
                                     pBufferMark,
                                     pFormat );

}

#if defined(DBG)
void NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT:\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("uFlags:                  %u\n", uFlags );
    DbgPrint("pBufferMark:             %p\n", pBufferMark );
}
#endif

void
Ndr64pEnquePointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    PNDR64_FORMAT       pFormat )
{

    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        if ( !PointerContext.ShouldEnque() )
            {
            Ndr64pPointerMemorySizeInternal( pStubMsg,
                                             pBufferMark,
                                             pFormat );

            }
        else
            {
            NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT*pElement =
                new(PointerContext.GetActiveState())
                    NDR64_MEMSIZE_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                        (PFORMAT_STRING)pFormat,
                                                        pBufferMark );
            PointerContext.Enque( pElement );
            }
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void
Ndr64pPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    PNDR64_FORMAT       pFormat )
{
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);

    if ( !NdrIsLowStack(pStubMsg) )
        {
        Ndr64pPointerMemorySizeInternal(
            pStubMsg,
            pBufferMark,
            pFormat );
        return;
        }


    Ndr64pEnquePointerMemorySize(
        pStubMsg,
        pBufferMark,
        pFormat );

}


__forceinline void
Ndr64TopLevelPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    NDR64_PTR_WIRE_TYPE * pBufferMark = NULL;

    //
    // If this is not a ref pointer then mark where the pointer's id is in
    // the buffer and increment the stub message buffer pointer.
    //
    if ( *(PFORMAT_STRING)pFormat != FC64_RP )
        {
        ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );

        pBufferMark = (NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer;

        pStubMsg->Buffer += sizeof( NDR64_PTR_WIRE_TYPE );
        }
     pStubMsg->MemorySize += PTR_MEM_SIZE;

     Ndr64pPointerMemorySize( pStubMsg,
                             pBufferMark,
                             pFormat );

}


__forceinline void
Ndr64EmbeddedPointerMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{

    ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
    NDR64_PTR_WIRE_TYPE * pBufferMark = (NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof( NDR64_PTR_WIRE_TYPE );
    pStubMsg->MemorySize += PTR_MEM_SIZE;

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );

    Ndr64pPointerMemorySize( pStubMsg,
                             pBufferMark,
                             pFormat );

}


void
Ndr64SimpleStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size required for a simple structure.

    Used for FC64_STRUCT and FC64_PSTRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Structure's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;

    ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );

    uchar *pBufferSave = pStubMsg->Buffer;

    LENGTH_ALIGN( pStubMsg->MemorySize, pStructFormat->Alignment );

    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + pStructFormat->MemorySize );
    pStubMsg->Buffer += pStructFormat->MemorySize;
    pStubMsg->MemorySize += pStructFormat->MemorySize;

    if ( pStructFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pStructFormat + 1,
                                       0,
                                       pBufferSave );
        }
}


void
Ndr64ConformantStructMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size required for a conformant structure.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE MaxCount;

    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT *) pStructFormat->ArrayDescription;

    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align for the conformance count.
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
        MaxCount = *((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    NDR64_UINT32 StructSize =  pStructFormat->MemorySize + Ndr64pMultiplyUpTo2GB( 
                                                    MaxCount , pArrayFormat->ElementSize ) ;

    // Realign for struct
    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);

    uchar *pBufferSave = pStubMsg->Buffer;

    LENGTH_ALIGN( pStubMsg->MemorySize, pStructFormat->Alignment );

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, StructSize );
    pStubMsg->Buffer        += StructSize;
    pStubMsg->MemorySize    += StructSize;

    if ( pStructFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pStructFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       pBufferSave );

        }
}


void
Ndr64ComplexStructMemorySize(
    PMIDL_STUB_MESSAGE    pStubMsg,
    PNDR64_FORMAT         pFormat )
/*++

Routine Description :

    Computes the memory size required for a complex structure.

    Used for FC64_BOGUS_STRUCT.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

Notes:
    This routine can calculate the memory size with or without pointees.
    When calculating size with pointees at the top level, the routine calls
    itself recursively to find out where pointees would be and then remember
    the context using pStubMsg->MemorySize and pStubMsg->PointerBufferMark.

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    bool fSetPointerBufferMark = !pStubMsg->IgnoreEmbeddedPointers &&
                                 !pStubMsg->PointerBufferMark;

    if ( fSetPointerBufferMark )
        {
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // This gets clobbered.
        uchar * BufferSave = pStubMsg->Buffer;
        ulong MemorySizeSave = pStubMsg->MemorySize;

        //
        // Get a buffer pointer to where the struct's pointees are.
        //
        Ndr64ComplexStructMemorySize(
            pStubMsg,
            pFormat );


        // Mark where the pointees begin.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->PointerLength     = pStubMsg->MemorySize;

        pStubMsg->IgnoreEmbeddedPointers = FALSE;

        pStubMsg->MemorySize = MemorySizeSave;
        pStubMsg->Buffer = BufferSave;
        }

    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING)pStructFormat->PointerLayout;
    PFORMAT_STRING  pFormatArray = NULL;

    PFORMAT_STRING  pMemberLayout = ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                      *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                    (PFORMAT_STRING)( pConfStructFormat + 1) :
                                    (PFORMAT_STRING)( pStructFormat + 1);

    SAVE_CONTEXT<uchar>  uFlagsSave( pStubMsg->uFlags );
    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );

    // Get conformant array description.
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;

        if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
            {

            NDR64_WIRE_COUNT_TYPE ConformanceSize;

            ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

            // conformance count marker
            pStubMsg->ConformanceMark = pStubMsg->Buffer;

            // Handle multidimensional arrays.
            ConformanceSize = pConfStructFormat->Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE);

            CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + ConformanceSize );
            pStubMsg->Buffer += ConformanceSize;

            NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );
            }
        }
    else
        {
        pFormatArray = 0;
        }

    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);

    for ( ; ; )
        {
        switch ( *pMemberLayout )
            {

            case FC64_STRUCT:
                {
                const NDR64_SIMPLE_REGION_FORMAT *pRegion =
                    (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;

                ALIGN( pStubMsg->Buffer, pRegion->Alignment );

                CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + pRegion->RegionSize );
                pStubMsg->Buffer        += pRegion->RegionSize;
                pStubMsg->MemorySize    += pRegion->RegionSize;

                pMemberLayout           += sizeof( *pRegion );
                break;
                }

            case FC64_STRUCTPADN :
                {
                const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
                pStubMsg->MemorySize    += pMemPad->MemPad;
                pMemberLayout           += sizeof(*pMemPad);
                break;
                }

            case FC64_POINTER :

                Ndr64EmbeddedPointerMemorySize(
                    pStubMsg,
                    pFormatPointers );

                pFormatPointers += sizeof(NDR64_POINTER_FORMAT);
                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);

                break;

            case FC64_EMBEDDED_COMPLEX :
                {
                const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                    (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                             pEmbeddedFormat->Type );

                pMemberLayout += sizeof(*pEmbeddedFormat);

                break;

                }

            case FC64_BUFFER_ALIGN:
                {
                const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign =
                    (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                ALIGN( pStubMsg->Buffer, pBufAlign->Alignment );
                pMemberLayout += sizeof( *pBufAlign );
                break;
                }

             case FC64_CHAR :
             case FC64_WCHAR :
             case FC64_INT8:
             case FC64_UINT8:
             case FC64_INT16:
             case FC64_UINT16:
             case FC64_INT32:
             case FC64_UINT32:
             case FC64_INT64:
             case FC64_UINT64:
             case FC64_FLOAT32 :
             case FC64_FLOAT64 :
             case FC64_ERROR_STATUS_T:
                ALIGN(pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN(*pMemberLayout));

                pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( *pMemberLayout );
                pStubMsg->MemorySize += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);

                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;

            case FC64_IGNORE:
                ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
                pStubMsg->Buffer     += sizeof(NDR64_PTR_WIRE_TYPE) ;
                pStubMsg->MemorySize += PTR_MEM_SIZE;

                pMemberLayout += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);
                break;

            case FC64_END :
                goto ComplexMemorySizeEnd;

            default :
                NDR_ASSERT(0,"Ndr64ComplexStructMemorySize : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            }
        }

ComplexMemorySizeEnd :

    if ( pFormatArray )
        {
        Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                     pFormatArray );
        }
    else
        {
        // If the structure doesn't have a conformant array, align it again
        ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer            = pStubMsg->PointerBufferMark;
        pStubMsg->MemorySize        = pStubMsg->PointerLength;
        pStubMsg->PointerBufferMark = 0;
        pStubMsg->PointerLength     = 0;
        }
}


void
Ndr64FixedArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a fixed array of any number of dimensions.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment );
    LENGTH_ALIGN( pStubMsg->MemorySize, pArrayFormat->Alignment );

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , pArrayFormat->TotalSize );
    uchar *pBufferStart = pStubMsg->Buffer;

    pStubMsg->Buffer        += pArrayFormat->TotalSize;
    pStubMsg->MemorySize    += pArrayFormat->TotalSize;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pArrayFormat + 1,
                                       0,
                                       pBufferStart );
        }
}


void
Ndr64ConformantArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a top level one dimensional conformant array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{


    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
        MaxCount = *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    NDR64_UINT32 Size = Ndr64pMultiplyUpTo2GB( MaxCount ,
                               pArrayFormat->ElementSize );

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment );
    LENGTH_ALIGN( pStubMsg->MemorySize, pArrayFormat->Alignment );

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, Size );
    uchar *pBufferStart     =  pStubMsg->Buffer;
    pStubMsg->Buffer        += Size;
    pStubMsg->MemorySize    += Size;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       pBufferStart );

        }
}


void
Ndr64ConformantVaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a one dimensional top level conformant
    varying array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align the buffer for conformance unmarshalling.
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

        MaxCount = *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    //
    // Get the offset and actual count in case needed for pointer sizing.
    //
    ALIGN(pStubMsg->Buffer,NDR64_WIRE_COUNT_ALIGN);

    NDR64_WIRE_COUNT_TYPE Offset      = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 MemorySize  = Ndr64pMultiplyUpTo2GB(MaxCount ,
                                     pArrayFormat->ElementSize );
    NDR64_UINT32 BufferSize  = Ndr64pMultiplyUpTo2GB(ActualCount ,
                                     pArrayFormat->ElementSize );

    if ( (Offset != 0) ||
         (MaxCount < ActualCount) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    //
    // Do the memory size increment now in case the actual count is 0.
    //
    LENGTH_ALIGN( pStubMsg->MemorySize, pArrayFormat->Alignment );
    pStubMsg->MemorySize += MemorySize;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, BufferSize );
    uchar *pBufferStart =  pStubMsg->Buffer;
    pStubMsg->Buffer    += BufferSize;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       pBufferStart );

        }
}


void
Ndr64VaryingArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a top level or embedded varying array.

    Used for FC64_SMVARRAY and FC64_LGVARRAY.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    //
    // Get the offset and actual count.
    //

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    NDR64_WIRE_COUNT_TYPE Offset = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 BufferSize =
        Ndr64pMultiplyUpTo2GB( ActualCount ,
                            pArrayFormat->ElementSize );

    if ( ( Offset != 0 ) ||
         ( BufferSize > pArrayFormat->TotalSize ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    LENGTH_ALIGN( pStubMsg->MemorySize, pArrayFormat->Alignment );

    pStubMsg->MemorySize += pArrayFormat->TotalSize;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, BufferSize );
    uchar *pBufferStart     =  pStubMsg->Buffer;
    pStubMsg->Buffer        += BufferSize;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutMemorySize( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       pBufferStart );

        }
}


void
Ndr64ComplexArrayMemorySize(
                           PMIDL_STUB_MESSAGE  pStubMsg,
                           PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a top level complex array.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
    (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;

    bool fSetPointerBufferMark = ! pStubMsg->IgnoreEmbeddedPointers &&
                                 ! pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {
        pStubMsg->IgnoreEmbeddedPointers = TRUE;

        // Save this since it gets clobbered.
        ulong MemorySizeSave = pStubMsg->MemorySize;
        uchar* pBufferSave = pStubMsg->Buffer;

        //
        // Get a buffer pointer to where the array's pointees are.
        //
        Ndr64ComplexArrayMemorySize(
            pStubMsg,
            pFormat );


        // This is where the array pointees start.
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->PointerLength     = pStubMsg->MemorySize;
        pStubMsg->IgnoreEmbeddedPointers = FALSE;

        pStubMsg->MemorySize = MemorySizeSave;
        pStubMsg->Buffer = pBufferSave;
        }

    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

    PFORMAT_STRING      pElementFormat = (PFORMAT_STRING)pArrayFormat->Element;

    SAVE_CONTEXT<uchar>  uFlagsSave( pStubMsg->uFlags );
    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
    SAVE_CONTEXT<uchar*> VarianceMarkSave( pStubMsg->VarianceMark );

    NDR64_WIRE_COUNT_TYPE Elements = pArrayFormat->NumberElements;
    NDR64_WIRE_COUNT_TYPE Count = Elements;
    NDR64_WIRE_COUNT_TYPE Offset = 0;

    if ( !IsFixed )
        {

        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
        (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        if ( pConfVarFormat->ConfDescription )
            {

            if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
                {
                //
                // The outer most array dimension sets the conformance marker.
                //

                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

                pStubMsg->ConformanceMark = pStubMsg->Buffer;

                // Increment past conformance count(s).
                pStubMsg->Buffer += pArrayFormat->NumberDims * sizeof(NDR64_WIRE_COUNT_TYPE);

                CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

                NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );

                }

            Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
            pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
            Offset   = 0;
            Count    = Elements;

            }

        if ( pConfVarFormat->VarDescription )
            {

            if ( ! NDR64_IS_VAR_MARK_VALID( pStubMsg->uFlags ) )
                {

                NDR64_UINT32 Dimensions;

                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

                // Mark where the variance counts are.
                pStubMsg->VarianceMark = pStubMsg->Buffer;

                Dimensions = pArrayFormat->Flags.IsArrayofStrings ?
                             (pArrayFormat->NumberDims - 1) :
                             (pArrayFormat->NumberDims);

                pStubMsg->Buffer += Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

                CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );

                if ( NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                    NDR64_SET_VAR_MARK_VALID( pStubMsg->uFlags );
                }
            else if ( !NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                NDR64_RESET_VAR_MARK_VALID( pStubMsg->uFlags );

            Offset  = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[0];
            Count   = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[1];
            pStubMsg->VarianceMark += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

            if ( Elements < (Offset + Count) )
                RpcRaiseException( RPC_X_INVALID_BOUND );
            }

        }


    NDR64_UINT32        ElementMemorySize =
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          TRUE );

    pStubMsg->MemorySize+= Ndr64pMultiplyUpTo2GB(Offset ,
                                              ElementMemorySize);

    Ndr64pMultiplyUpTo2GB( Elements ,  ElementMemorySize );
    Ndr64pMultiplyUpTo2GB( Count ,  ElementMemorySize );

    NDR64_WIRE_COUNT_TYPE LeftOverGap = Elements - Count - Offset;

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    for ( ; Count--; )
        {
        Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                     pElementFormat );
        }

    pStubMsg->MemorySize += Ndr64pMultiplyUpTo2GB(LeftOverGap , 
                                               ElementMemorySize );
    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer            = pStubMsg->PointerBufferMark;
        pStubMsg->MemorySize        = pStubMsg->PointerLength;
        pStubMsg->PointerBufferMark = 0;
        pStubMsg->PointerLength     = 0;
        }
}


void
Ndr64NonConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a non conformant string.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_NON_CONFORMANT_STRING_FORMAT * pStringFormat =
        (NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;

    ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    NDR64_WIRE_COUNT_TYPE Offset      = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 BufferSize =
        Ndr64pMultiplyUpTo2GB( ActualCount ,
                           pStringFormat->Header.ElementSize );

    if ( pStringFormat->Header.FormatCode == FC64_WCHAR_STRING )
        {
        // Align memory just in case.
        LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, BufferSize );
    pStubMsg->Buffer        += BufferSize;
    pStubMsg->MemorySize    += pStringFormat->TotalSize;

}


void
Ndr64ConformantStringMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of a top level conformant string.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{

    const NDR64_CONFORMANT_STRING_FORMAT * const pStringFormat =
        (NDR64_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE    MaxCount;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
        MaxCount =  *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount =  *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
    NDR64_WIRE_COUNT_TYPE Offset      = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 TransmittedSize =
        Ndr64pMultiplyUpTo2GB( ActualCount ,
                            pStringFormat->Header.ElementSize );
    NDR64_UINT32 MemorySize      =
        Ndr64pMultiplyUpTo2GB( MaxCount ,
                            pStringFormat->Header.ElementSize );

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, TransmittedSize );

    if ( pStringFormat->Header.FormatCode == FC64_CONF_WCHAR_STRING )
        {
        // Align memory just in case.
        LENGTH_ALIGN( pStubMsg->MemorySize, 0x1 );
        }


    pStubMsg->Buffer        += TransmittedSize;
    pStubMsg->MemorySize    += MemorySize;
}


void
Ndr64UnionMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Computes the memory size of an encapsulated union.

    Used for FC64_ENCAPSULATED_UNION.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size.

--*/
{
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;

    NDR64_FORMAT_CHAR   SwitchType;
    NDR64_UINT32        MemorySize;

    switch(*(PFORMAT_STRING)pFormat)
    {
    case FC64_NON_ENCAPSULATED_UNION:
        {
        const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
            (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;

        ALIGN(pStubMsg->Buffer, pNonEncapUnionFormat->Alignment);
        SwitchType      = pNonEncapUnionFormat->SwitchType;
        pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);
        MemorySize      = pNonEncapUnionFormat->MemorySize;

        break;
        }
    case FC64_ENCAPSULATED_UNION:
        {
        const NDR64_ENCAPSULATED_UNION* pEncapUnionFormat =
            (const NDR64_ENCAPSULATED_UNION*)pFormat;


        ALIGN(pStubMsg->Buffer, pEncapUnionFormat->Alignment);
        SwitchType      = pEncapUnionFormat->SwitchType;
        pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pEncapUnionFormat + 1);
        MemorySize      = pEncapUnionFormat->MemorySize;
        break;
        }

    default:
        NDR_ASSERT("Bad union format\n", 0);
        return;
        }

    EXPR_VALUE SwitchIs =
        Ndr64pSimpleTypeToExprValue( SwitchType,
                                     pStubMsg->Buffer );

    pStubMsg->MemorySize += MemorySize;

    pStubMsg->Buffer     += NDR64_SIMPLE_TYPE_BUFSIZE(SwitchType);

    ALIGN(pStubMsg->Buffer, pArmSelector->Alignment);

    PNDR64_FORMAT pArmFormat =
        Ndr64pFindUnionArm( pStubMsg,
                            pArmSelector,
                            SwitchIs );

    if ( ! pArmFormat )
        return;

    Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                 pArmFormat );

}


void
Ndr64XmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    bool bIsEmbedded )
/*++

Routine Description :

    Computes the memory size required for the presented type of a
    transmit as or represent as.

    See mrshl.c for the description of the FC layout.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The computed memory size of the presented type object.

--*/
{
    NDR64_TRANSMIT_AS_FORMAT *pTransFormat = ( NDR64_TRANSMIT_AS_FORMAT *) pFormat;
    NDR_ASSERT( pTransFormat->FormatCode == FC64_TRANSMIT_AS || pTransFormat->FormatCode , "invalid format string for user marshal" );

    pStubMsg->MemorySize += pTransFormat->PresentedTypeMemorySize;

    // In NDR64, Xmit/Rep cannot be a pointer or contain a pointer.
    // So we don't need to worry about the pointer queue here.

    if ( bIsEmbedded )
        {
        Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                     pTransFormat->TransmittedType );
        }
    else
        {
        Ndr64TopLevelTypeMemorySize( pStubMsg,
                                     pTransFormat->TransmittedType );
        }
}

void
Ndr64TopLevelXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsMemorySize( pStubMsg,
                                pFormat,
                                false );
}

void
Ndr64EmbeddedXmitOrRepAsMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    Ndr64XmitOrRepAsMemorySize( pStubMsg,
                                pFormat,
                                true );
}


void
NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT::Dispatch(MIDL_STUB_MESSAGE *pStubMsg)
{

    Ndr64TopLevelTypeMemorySize( pStubMsg,
                                 pFormat );

}

#if defined(DBG)
void
NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT\n");
    DbgPrint("pFormat:                 %p\n", pFormat );
}
#endif


void
Ndr64UserMarshallPointeeMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    if ( !pStubMsg->pPointerQueueState ||
         !pStubMsg->pPointerQueueState->GetActiveQueue() )
        {

        POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );

        Ndr64TopLevelTypeMemorySize(
            pStubMsg,
            pFormat );
        return;
        }

    NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT*pElement =
       new(pStubMsg->pPointerQueueState)
           NDR64_USR_MRSHL_MEMSIZE_POINTER_QUEUE_ELEMENT((PFORMAT_STRING)pFormat );
    pStubMsg->pPointerQueueState->GetActiveQueue()->Enque( pElement );

}


void
Ndr64UserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    bool                bIsEmbedded )
/*++

Routine Description :

    Computes the memory size required for a usr_marshal type.
    See mrshl.c for the description of the layouts.

Arguments :

    pStubMsg    - Pointer to stub message.
    pFormat     - Pointer's format string description.

Return :

    The memory size of the usr_marshall object.

--*/
{
    NDR64_USER_MARSHAL_FORMAT  *pUserFormat = ( NDR64_USER_MARSHAL_FORMAT *) pFormat;

    pStubMsg->MemorySize += pUserFormat->UserTypeMemorySize;

    ALIGN( pStubMsg->Buffer, pUserFormat->TransmittedTypeWireAlignment );

    if ( pUserFormat->Flags & USER_MARSHAL_POINTER )
        {

        if ( ( pUserFormat->Flags & USER_MARSHAL_UNIQUE )  ||
             (( pUserFormat->Flags & USER_MARSHAL_REF ) && bIsEmbedded) )
            {
            // it's embedded: unique or ref.
            pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
            }

        Ndr64UserMarshallPointeeMemorySize( pStubMsg,
                                            pUserFormat->TransmittedType );

        return;

        }

    if ( bIsEmbedded )
        {
        Ndr64EmbeddedTypeMemorySize( pStubMsg,
                                     pUserFormat->TransmittedType );
        }
    else
        {
        Ndr64TopLevelTypeMemorySize( pStubMsg,
                                     pUserFormat->TransmittedType );
        }

    return;
}

void
Ndr64TopLevelUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    Ndr64UserMarshalMemorySize( pStubMsg,
                                pFormat,
                                false );
}

void
Ndr64EmbeddedUserMarshalMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat )
{
    Ndr64UserMarshalMemorySize( pStubMsg,
                                pFormat,
                                true );
}

// define the jump table
#define NDR64_BEGIN_TABLE  \
PNDR64_MEM_SIZE_ROUTINE extern const Ndr64MemSizeRoutinesTable[] = \
{

#define NDR64_TABLE_END    \
};

#define NDR64_ZERO_ENTRY   NULL
#define NDR64_UNUSED_TABLE_ENTRY( number, tokenname ) ,NULL
#define NDR64_UNUSED_TABLE_ENTRY_NOSYM( number ) ,NULL

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,memsize

#define NDR64_SIMPLE_TYPE_TABLE_ENTRY( number, tokenname, buffersize, memorysize) \
   ,Ndr64UDTSimpleTypeMemorySize

#include "tokntbl.h"


C_ASSERT( sizeof(Ndr64MemSizeRoutinesTable)/sizeof(PNDR64_MEM_SIZE_ROUTINE) == 256 );

#undef NDR64_BEGIN_TABLE
#undef NDR64_TABLE_ENTRY

#define NDR64_BEGIN_TABLE  \
PNDR64_MEM_SIZE_ROUTINE extern const Ndr64EmbeddedMemSizeRoutinesTable[] = \
{

#define NDR64_TABLE_ENTRY( number, tokenname, marshall, embeddedmarshall, unmarshall, embeddedunmarshall, buffersize, embeddedbuffersize, memsize, embeddedmemsize, free, embeddedfree, typeflags ) \
   ,embeddedmemsize

#include "tokntbl.h"


C_ASSERT( sizeof(Ndr64EmbeddedMemSizeRoutinesTable)/sizeof(PNDR64_MEM_SIZE_ROUTINE) == 256 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\ndrp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright <c> 1993-2000 Microsoft Corporation

Module Name :

    ndrp.h

Abtract :

    Contains private definitions for Ndr64 files in this directory.  This
    file is included by all source files in this directory.

Author :

    David Kays  dkays   October 1993

Revision History :

--------------------------------------------------------------------*/

#ifndef _NDRP_
#define _NDRP_

#include <sysinc.h>

#include "rpc.h"
#include "rpcndr.h"

// Get new token definitions for 64b.
#define RPC_NDR_64
#include "ndrtypes.h"
#include "ndr64types.h"

#include "..\ndr20\ndrpall.h"

// Jump table defines

//
// Marshal jump tables
//
typedef void (* PNDR64_MARSHALL_ROUTINE)( 
					PMIDL_STUB_MESSAGE, 
					uchar *, 
					PNDR64_FORMAT
				);

extern PNDR64_MARSHALL_ROUTINE const Ndr64MarshallRoutinesTable[];
extern PNDR64_MARSHALL_ROUTINE const Ndr64EmbeddedMarshallRoutinesTable[];
extern PSIMPLETYPE_MARSHAL_ROUTINE const Ndr64SimpleTypeMarshallRoutinesTable[] ;

inline void
Ndr64TopLevelTypeMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64MarshallRoutinesTable[*(PFORMAT_STRING)pFormat] )
                                ( pStubMsg,
                                  pMemory,
                                  pFormat );
}

inline void
Ndr64EmbeddedTypeMarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT     pFormat )
{
    (*Ndr64EmbeddedMarshallRoutinesTable[*(PFORMAT_STRING)pFormat] )
                                        ( pStubMsg,
                                          pMemory,
                                          pFormat );
}

//
// Buffer size jump tables
//

typedef  void   (* PNDR64_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
						uchar *				pMemory,
                        PNDR64_FORMAT		pFormat
                    );

extern PNDR64_SIZE_ROUTINE const  Ndr64SizeRoutinesTable[];
extern PNDR64_SIZE_ROUTINE const  Ndr64EmbeddedSizeRoutinesTable[];


inline void
Ndr64TopLevelTypeSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64SizeRoutinesTable[*(PFORMAT_STRING)pFormat])( pStubMsg,
                                         pMemory,
                                         pFormat );
}

inline void
Ndr64EmbeddedTypeSize(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64EmbeddedSizeRoutinesTable[*(PFORMAT_STRING)pFormat])( pStubMsg,
                                                 pMemory,
                                                 pFormat );
}

void 
Ndr64ComplexStructBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat );

void 
Ndr64ComplexArrayBufferSize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat );

//
// Memsize jump tables
//

typedef     void	(* PNDR64_MEM_SIZE_ROUTINE)(
                        PMIDL_STUB_MESSAGE	pStubMsg,
                        PNDR64_FORMAT 		pFormat
                    );

extern PNDR64_MEM_SIZE_ROUTINE   const Ndr64MemSizeRoutinesTable[];
extern PNDR64_MEM_SIZE_ROUTINE   const Ndr64EmbeddedMemSizeRoutinesTable[];

inline void
Ndr64TopLevelTypeMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64MemSizeRoutinesTable[*(PFORMAT_STRING)pFormat] )
                                ( pStubMsg,
                                  pFormat );
}

inline void
Ndr64EmbeddedTypeMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64EmbeddedMemSizeRoutinesTable[*(PFORMAT_STRING)pFormat] )
                                        ( pStubMsg,
                                          pFormat );
}

void 
Ndr64ComplexStructMemorySize(
    PMIDL_STUB_MESSAGE    pStubMsg,
    PNDR64_FORMAT         pFormat );

void 
Ndr64ComplexArrayMemorySize(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat );
//
// Unmarshal
//

typedef void (* PNDR64_UNMARSHALL_ROUTINE)( 
                    PMIDL_STUB_MESSAGE, 
					uchar **, 
					PNDR64_FORMAT,
					bool 
				);

extern PNDR64_UNMARSHALL_ROUTINE const Ndr64UnmarshallRoutinesTable[];
extern PNDR64_UNMARSHALL_ROUTINE const Ndr64EmbeddedUnmarshallRoutinesTable[];

inline void
Ndr64EmbeddedTypeUnmarshall( 
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar **           ppMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64EmbeddedUnmarshallRoutinesTable[*(PFORMAT_STRING)pFormat])
        (pStubMsg,
         ppMemory,
         pFormat,
         false );
}

inline void 
Ndr64TopLevelTypeUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar **           ppMemory,
    PNDR64_FORMAT      pFormat,
    bool               fMustAlloc )
{

    (*Ndr64UnmarshallRoutinesTable[*(PFORMAT_STRING)pFormat])
        (pStubMsg,
         ppMemory,
         pFormat,
         fMustAlloc );


}

//
// Free routines
//

typedef     void    (* PNDR64_FREE_ROUTINE)( 
						PMIDL_STUB_MESSAGE, 
					 	uchar *, 
						PNDR64_FORMAT
					);

extern PNDR64_FREE_ROUTINE const Ndr64FreeRoutinesTable[];
extern PNDR64_FREE_ROUTINE const Ndr64EmbeddedFreeRoutinesTable[];  

inline void 
Ndr64EmbeddedTypeFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    (*Ndr64EmbeddedFreeRoutinesTable[*(PFORMAT_STRING)pFormat])
            ( pStubMsg,
              pMemory,
              pFormat );
}

inline void 
Ndr64ToplevelTypeFree(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{

    (*Ndr64FreeRoutinesTable[*(PFORMAT_STRING)pFormat])
            ( pStubMsg,
              pMemory,
              pFormat );

}

#include "..\..\ndr20\fullptr.h"
#include "pipendr.h"

#include "mulsyntx.h"
#include "pointer.h"

#include "expr.h"

uchar *
Ndr64pMemoryIncrement(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    BOOL                fUseBufferConformance
    );

inline
NDR64_UINT32
Ndr64pMemorySize(
    PMIDL_STUB_MESSAGE pStubMsg,
    PNDR64_FORMAT      pFormat,
    BOOL fUseBufferConformance )
{
    return
        PtrToUlong(Ndr64pMemoryIncrement( pStubMsg,
                                          NULL,
                                          pFormat,
                                          fUseBufferConformance ) );
}

BOOL
Ndr64pIsStructStringTerminator(
    NDR64_UINT8*    pMemory,
    NDR64_UINT32    ElementSize
    );

NDR64_UINT32
Ndr64pStructStringLen(       
    NDR64_UINT8*    pMemory,
    NDR64_UINT32    ElementSize
    );

NDR64_UINT32 
Ndr64pCommonStringSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    uchar *                             pMemory,
    const NDR64_STRING_HEADER_FORMAT    *pStringFormat
    );

inline NDR64_UINT32
Ndr64pConvertTo2GB(
    NDR64_UINT64        Data64
    )
{
    if ( Data64 > 0x7FFFFFFF )
        {
        RpcRaiseException( RPC_X_INVALID_BOUND );
        return 0;
        }
    return (NDR64_UINT32) Data64;
}

__forceinline NDR64_UINT32
Ndr64pMultiplyUpTo2GB( NDR64_UINT64 Op1, NDR64_UINT32 Op2 )
{
    if ( Op1 > 0x7fffffff )
        {
        RpcRaiseException ( RPC_X_INVALID_BOUND);
        return 0;
        }
    NDR64_UINT64 Res = Op1 * Op2;
    if ( Res > 0x7fffffff )
        {
        RpcRaiseException ( RPC_X_INVALID_BOUND);
        return 0;
        }
    return (NDR64_UINT32) Res;        
}

void
Ndr64pInitUserMarshalCB(
    MIDL_STUB_MESSAGE *pStubMsg,
    NDR64_USER_MARSHAL_FORMAT *     pUserFormat,
    USER_MARSHAL_CB_TYPE CBType,
    USER_MARSHAL_CB   *pUserMarshalCB
    );

CLIENT_CALL_RETURN RPC_ENTRY
NdrpClientCall3(
    void *                      pThis,
    MIDL_STUBLESS_PROXY_INFO   *pProxyInfo,
    unsigned long               nProcNum,
    void                       *pReturnValue,
    NDR_PROC_CONTEXT        *   pContext,
    unsigned char *             StartofStack
    );

PNDR64_FORMAT
Ndr64pFindUnionArm(
    PMIDL_STUB_MESSAGE pStubMsg,
    const NDR64_UNION_ARM_SELECTOR* pArmSelector,
    EXPR_VALUE Value
    );

EXPR_VALUE
Ndr64pSimpleTypeToExprValue(
    NDR64_FORMAT_CHAR FormatChar,
    uchar *pSimple);

EXPR_VALUE
Ndr64pCastExprValueToExprValue(
    NDR64_FORMAT_CHAR FormatChar,
    EXPR_VALUE Value);

// Context Handle Functions

NDR_SCONTEXT
RPC_ENTRY
Ndr64ContextHandleInitialize(
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PFORMAT_STRING      pFormat
    );

void
RPC_ENTRY
Ndr64ServerContextNewMarshall(
    PMIDL_STUB_MESSAGE    pStubMsg,
    NDR_SCONTEXT          ContextHandle,
    NDR_RUNDOWN           RundownRoutine,
    PFORMAT_STRING        pFormat
    );

NDR_SCONTEXT
RPC_ENTRY
Ndr64ServerContextNewUnmarshall(
    IN  PMIDL_STUB_MESSAGE  pStubMsg,
    IN  PFORMAT_STRING      pFormat
    );

void
Ndr64pCleanupServerContextHandles(
    MIDL_STUB_MESSAGE * pStubMsg,
    long                NumberParams,
    NDR64_PARAM_FORMAT* Params,
    uchar *             pArgBuffer,
    BOOL                fManagerRoutineException 
    );


// Free

void
RPC_ENTRY
Ndr64PointerFree(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PNDR64_FORMAT                       pFormat
    );

// Mrshl
void
RPC_ENTRY
Ndr64SimpleTypeMarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

// Unmarshall

void
RPC_ENTRY
Ndr64SimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    unsigned char                       FormatChar
    );

// Initialization                           

void
Ndr64ClientInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUBLESS_PROXY_INFO           pProxyInfo,
    unsigned int                        ProcNum
    );

unsigned char *
Ndr64ServerInitialize(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor
    );

void
Ndr64ServerInitializePartial(
    PRPC_MESSAGE                        pRpcMsg,
    PMIDL_STUB_MESSAGE                  pStubMsg,
    PMIDL_STUB_DESC                     pStubDescriptor,
    unsigned long                       RequestedBufferSize
    );

// Get Buffer variations

unsigned char *
Ndr64GetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength );

unsigned char *
Ndr64NsGetBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength );

unsigned char *
Ndr64GetPipeBuffer(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned long                       BufferLength );

void
Ndr64ClearOutParameters(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PNDR64_FORMAT           pFormat,
    uchar *                 ArgAddr
    );

extern void __fastcall NdrpSimpleTypeCharMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory);
    
extern void __fastcall NdrpSimpleTypeShortMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory);

    
extern void __fastcall NdrpSimpleTypeLongMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory);

extern void __fastcall NdrpSimpleTypeHyperMarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory);

extern void __fastcall NdrpSimpleTypeIgnoreMarshall (
    PMIDL_STUB_MESSAGE ,
    uchar * );

extern void __fastcall NdrpSimpleTypeInvalidMarshall (
    PMIDL_STUB_MESSAGE ,
    uchar *     );


// These end of buffer checks can be performed on a receiving side only.
// The necessary setup is there for memorysize, unmarshal and convert walks.
// This also includes pickling walk.
// Don't use this on the sending side.

// Checks if the pointer is past the end of the buffer.  Do not check for wraparound.

#define CHECK_EOB_RAISE_BSD( p )                                      \
    {                                                                 \
       if( (char *)(p) > (char*)pStubMsg->BufferEnd )                 \
           {                                                          \
           RpcRaiseException( RPC_X_BAD_STUB_DATA );                  \
           }                                                          \
    }

#define CHECK_EOB_RAISE_IB( p )                                       \
    {                                                                 \
        if( (char *)(p) > (char*)pStubMsg->BufferEnd )                \
            {                                                         \
            RpcRaiseException( RPC_X_INVALID_BOUND );                 \
            }                                                         \
    }

// Checks if p + incsize is past the end of the bufffer.
// 

#define CHECK_EOB_WITH_WRAP_RAISE_BSD( p, incsize )                          \
    {                                                                        \
        char *NewBuffer = ((char *)(p)) + (SIZE_T)(incsize);                 \
        if( (NewBuffer > (char*)(pStubMsg->BufferEnd)) || (NewBuffer < (char*)(p)) )  \
             {                                                               \
             RpcRaiseException( RPC_X_BAD_STUB_DATA );                       \
             }                                                               \
    }

#define CHECK_EOB_WITH_WRAP_RAISE_IB( p, incsize )                           \
    {                                                                        \
        char *NewBuffer = ((char *)(p)) + (SIZE_T)(incsize);                 \
        if(  (NewBuffer > (char*)(pStubMsg->BufferEnd)) || (NewBuffer < (char*)(p)) ) \
             {                                                               \
             RpcRaiseException( RPC_X_INVALID_BOUND );                       \
             }                                                               \
    }

// This would be appropriate on the sending side for marshaling.

#define CHECK_SEND_EOB_RAISE_BSD( p )  \
        if ( (char*)(pStubMsg->RpcMsg->Buffer + pStubMsg->RpcMsg->BufferLength) < (char*)( p ) ) \
            RpcRaiseException( RPC_X_BAD_STUB_DATA )


//
// Defined in global.c
//
extern const unsigned char Ndr64SimpleTypeBufferSize[];
extern const unsigned char Ndr64SimpleTypeMemorySize[];
extern const unsigned long Ndr64TypeFlags[];

// This definition is adjusted for a native platform.
// The wire size is fixed for DCE NDR regardless of platform.

#define PTR_MEM_SIZE                    sizeof(void *)
#define PTR_MEM_ALIGN                   (sizeof(void *)-1)

#define PTR_WIRE_REP(p)  (p?(NDR64_PTR_WIRE_TYPE)(UNIQUE_POINTER_MARK):0)

#define CONTEXT_HANDLE_WIRE_SIZE        20

#define IGNORED(Param)

//
// Proc info flags macros.
//
#define IS_OLE_INTERFACE(Flags)         ((Flags) & Oi_OBJECT_PROC)

#define HAS_RPCFLAGS(Flags)             ((Flags) & Oi_HAS_RPCFLAGS)

#define DONT_HANDLE_EXCEPTION(Flags)    \
                    ((Flags) & Oi_IGNORE_OBJECT_EXCEPTION_HANDLING)


//
// Routine index macro.
//
#define NDR64_ROUTINE_INDEX(FC)       ( (FC) )

//
// Simple type alignment and size lookup macros.
//
#define NDR64_SIMPLE_TYPE_BUFALIGN(FormatChar)    (Ndr64SimpleTypeBufferSize[FormatChar]-1)

#define NDR64_SIMPLE_TYPE_MEMALIGN(FormatChar)    (Ndr64SimpleTypeMemorySize[FormatChar]-1)

#define NDR64_SIMPLE_TYPE_BUFSIZE(FormatChar)     (Ndr64SimpleTypeBufferSize[FormatChar])

#define NDR64_SIMPLE_TYPE_MEMSIZE(FormatChar)     (Ndr64SimpleTypeMemorySize[FormatChar])

#if defined(__RPC_WIN32__)
#define NDR64_USER_MARSHAL_MARKER (0x72657355);
#else
#define NDR64_USER_MARSHAL_MARKER (0x7265735572657355);
#endif

#if defined(__RPC_WIN32__)
#define NDR64_CONTEXT_HANDLE_MARSHAL_MARKER (0xbaadbeef);
#else
#define NDR64_CONTEXT_HANDLE_MARSHAL_MARKER (0xbaadbeefbaadbeef);
#endif

//
// Format character attribute bits used in global Ndr64TypesFlags defined in
// global.c.
//
#define     _SIMPLE_TYPE_       0x0001L
#define     _POINTER_           0x0002L
#define     _STRUCT_            0x0004L
#define     _ARRAY_             0x0008L
#define     _STRING_            0x0010L
#define     _UNION_             0x0020L
#define     _XMIT_AS_           0x0040L

#define     _BY_VALUE_          0x0080L

#define     _HANDLE_            0x0100L

#define     _BASIC_POINTER_     0x0200L

//
// Format character query macros.
//
#define NDR64_IS_SIMPLE_TYPE(FC)     (Ndr64TypeFlags[(FC)] & _SIMPLE_TYPE_)

#define NDR64_IS_POINTER_TYPE(FC)    (Ndr64TypeFlags[(FC)] & _POINTER_)

#define NDR64_IS_BASIC_POINTER(FC)   (Ndr64TypeFlags[(FC)] & _BASIC_POINTER_)

#define NDR64_IS_ARRAY(FC)           (Ndr64TypeFlags[(FC)] & _ARRAY_)

#define NDR64_IS_STRUCT(FC)          (Ndr64TypeFlags[(FC)] & _STRUCT_)

#define NDR64_IS_UNION(FC)           (Ndr64TypeFlags[(FC)] & _UNION_)

#define NDR64_IS_STRING(FC)          (Ndr64TypeFlags[(FC)] & _STRING_)

#define NDR64_IS_ARRAY_OR_STRING(FC) (Ndr64TypeFlags[(FC)] & (_STRING_ | _ARRAY_))

#define NDR64_IS_XMIT_AS(FC)         (Ndr64TypeFlags[(FC)] & _XMIT_AS_)

#define NDR64_IS_BY_VALUE(FC)        (Ndr64TypeFlags[(FC)] & _BY_VALUE_)

#define NDR64_IS_HANDLE(FC)          (Ndr64TypeFlags[(FC)] & _HANDLE_)

//
// Pointer attribute extraction and querying macros.
//
#define NDR64_ALLOCATE_ALL_NODES( FC )    ((FC) & FC_ALLOCATE_ALL_NODES)

#define NDR64_DONT_FREE( FC )             ((FC) & FC_DONT_FREE)

#define NDR64_ALLOCED_ON_STACK( FC )      ((FC) & FC_ALLOCED_ON_STACK)

#define NDR64_SIMPLE_POINTER( FC )        ((FC) & FC_SIMPLE_POINTER)

#define NDR64_POINTER_DEREF( FC )         ((FC) & FC_POINTER_DEREF)

//
// Handle query macros.
//
#define NDR64_IS_HANDLE_PTR( FC )         ((FC) & HANDLE_PARAM_IS_VIA_PTR)

#define NDR64_IS_HANDLE_IN( FC )          ((FC) & HANDLE_PARAM_IS_IN)

#define NDR64_IS_HANDLE_OUT( FC )         ((FC) & HANDLE_PARAM_IS_OUT)

#define NDR64_IS_HANDLE_RETURN( FC )      ((FC) & HANDLE_PARAM_IS_RETURN)


#define NDR64_NEW_EMBEDDED_ALLOCATION_FLAG     ( ( unsigned char ) 0x01 )
#define NDR64_CONF_MARK_VALID_FLAG             ( ( unsigned char ) 0x02 )
#define NDR64_VAR_MARK_VALID_FLAG              ( ( unsigned char ) 0x04 )
#define NDR64_WALKIP_FLAG                      ( ( unsigned char ) 0x08 )
#define NDR64_SKIP_REF_CHECK_FLAG              ( ( unsigned char ) 0x40 )

#define NDR64_IS_CONF_MARK_VALID( f )                 ( ( f ) &  NDR64_CONF_MARK_VALID_FLAG )
#define NDR64_SET_CONF_MARK_VALID( f )                ( ( f ) |= NDR64_CONF_MARK_VALID_FLAG )
#define NDR64_RESET_CONF_MARK_VALID( f )              ( ( f ) &= ~NDR64_CONF_MARK_VALID_FLAG )

#define NDR64_IS_VAR_MARK_VALID( f )                  ( ( f ) &  NDR64_VAR_MARK_VALID_FLAG )
#define NDR64_SET_VAR_MARK_VALID( f )                 ( ( f ) |= NDR64_VAR_MARK_VALID_FLAG )
#define NDR64_RESET_VAR_MARK_VALID( f )               ( ( f ) &= ~NDR64_VAR_MARK_VALID_FLAG )

#define NDR64_IS_NEW_EMBEDDED_ALLOCATION( f )         ( ( f ) & NDR64_NEW_EMBEDDED_ALLOCATION_FLAG )
#define NDR64_SET_NEW_EMBEDDED_ALLOCATION( f )        ( ( f ) |= NDR64_NEW_EMBEDDED_ALLOCATION_FLAG )
#define NDR64_RESET_IS_NEW_EMBEDDED_ALLOCATION( f )   ( ( f ) &= ~NDR64_NEW_EMBEDDED_ALLOCATION_FLAG )

#define NDR64_IS_WALKIP( f )        ( ( f ) & NDR64_WALKIP_FLAG )
#define NDR64_SET_WALKIP( f )       ( ( f ) |= NDR64_WALKIP_FLAG ) 
#define NDR64_RESET_WALKIP( f )     ( ( f ) &= ~NDR64_WALKIP_FLAG )

#define NDR64_IS_SKIP_REF_CHECK( f ) ( ( f ) & NDR64_SKIP_REF_CHECK_FLAG )
#define NDR64_SET_SKIP_REF_CHECK( f ) ( ( f ) |= NDR64_SKIP_REF_CHECK_FLAG )
#define NDR64_RESET_SKIP_REF_CHECK( f ) ( ( f ) &= ~NDR64_SKIP_REF_CHECK_FLAG )



#define NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE( f )      \
    ( ( f ) &= ~ ( NDR64_NEW_EMBEDDED_ALLOCATION_FLAG |    \
                   NDR64_CONF_MARK_VALID_FLAG |            \
                   NDR64_VAR_MARK_VALID_FLAG  ) )  


#define EXCEPTION_FLAG   ( pContext->ExceptionFlag )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\mulsyntx.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    mulsyntx.c

Abstract :

    This file contains multiple transfer syntaxes negotiation related code

Author :

    Yong Qu    yongqu    September 1999. 

Revision History :


  ---------------------------------------------------------------------*/


#include "precomp.hxx"

#define CINTERFACE
#include "ndrole.h"
#include "rpcproxy.h"

#include "expr.h"
#include "auxilary.h"
#include "..\..\ndr20\pipendr.h"

extern const uchar Ndr64HandleTypeMap[] = 
{
    0,
    FC64_BIND_GENERIC,
    FC64_BIND_PRIMITIVE,
    FC64_AUTO_HANDLE,
    FC64_CALLBACK_HANDLE
} ;

extern const SYNTAX_DISPATCH_TABLE SyncDceClient =
{
    NdrpClientInit,
    NdrpSizing,
    NdrpClientMarshal,
    NdrpClientUnMarshal,
    NdrpClientExceptionHandling,
    NdrpClientFinally
};

extern const SYNTAX_DISPATCH_TABLE AsyncDceClient =
{
    NdrpClientInit,
    NdrpSizing,
    NdrpClientMarshal,
    NdrpClientUnMarshal,
    NdrpAsyncClientExceptionHandling,
    NdrpClientFinally
};

extern const SYNTAX_DISPATCH_TABLE SyncDcomDceClient =
{
    NdrpClientInit,
    NdrpSizing,
    NdrpClientMarshal,
    NdrpClientUnMarshal,
    NdrpDcomClientExceptionHandling,
    NdrpClientFinally
};

extern const SYNTAX_DISPATCH_TABLE SyncNdr64Client =
{
    Ndr64pClientInit,
    Ndr64pSizing,
    Ndr64pClientMarshal,
    Ndr64pClientUnMarshal,
    Ndr64pClientExceptionHandling,
    Ndr64pClientFinally
};

extern const SYNTAX_DISPATCH_TABLE SyncDcomNdr64Client =
{
    Ndr64pClientInit,
    Ndr64pSizing,
    Ndr64pClientMarshal,
    Ndr64pClientUnMarshal,
    Ndr64pDcomClientExceptionHandling,
    Ndr64pClientFinally
};


const RPC_SYNTAX_IDENTIFIER NDR_TRANSFER_SYNTAX = {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};
const RPC_SYNTAX_IDENTIFIER NDR64_TRANSFER_SYNTAX = {{0x71710533,0xbeba,0x4937,{0x83, 0x19, 0xb5, 0xdb, 0xef, 0x9c, 0xcc, 0x36}},{1,0}};
const RPC_SYNTAX_IDENTIFIER FAKE_NDR64_TRANSFER_SYNTAX = { { 0xb4537da9,0x3d03,0x4f6b,{0xb5, 0x94, 0x52, 0xb2, 0x87, 0x4e, 0xe9, 0xd0} }, {1,0} };

CStdProxyBuffer * RPC_ENTRY
NdrGetProxyBuffer(
    void *pThis);

void
EnsureNSLoaded();

#pragma code_seg(".ndr64")

__inline
const IID * RPC_ENTRY
NdrGetSyncProxyIID(
    IN  void *pThis)
/*++

Routine Description:
    The NDRGetSyncProxyIID function returns a pointer to IID.

Arguments:
    pThis - Supplies a pointer to the async interface proxy.

Return Value:
    This function returns a pointer to the corresponding sync IID.

--*/
{
    CStdAsyncProxyBuffer * pAsyncPB = ( CStdAsyncProxyBuffer *) NdrGetProxyBuffer( pThis );

    return pAsyncPB->pSyncIID;
}

 

void RPC_ENTRY
Ndr64SetupClientContextVtbl ( NDR_PROC_CONTEXT * pContext )
{
     if ( pContext->CurrentSyntaxType == XFER_SYNTAX_DCE )
         {
         if ( pContext->IsObject )
             memcpy( & (pContext->pfnInit), &SyncDcomDceClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
         else
             {
             if ( pContext->IsAsync )
                 memcpy( & (pContext->pfnInit), &AsyncDceClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
             else
                 memcpy( & (pContext->pfnInit), &SyncDceClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
             }
         }
     else
         {
         if ( pContext->IsObject )
             memcpy( & (pContext->pfnInit), &SyncDcomNdr64Client, sizeof( SYNTAX_DISPATCH_TABLE ) );
         else
             memcpy( & (pContext->pfnInit), &SyncNdr64Client, sizeof( SYNTAX_DISPATCH_TABLE ) );
         }
}

/*++

Routine Description :
    This routine initialize the server side NDR_PROC_CONTEXT when using
    NDR64. 

Arguments :


Return :
    None. 
    
--*/
void 
NdrServerSetupNDR64TransferSyntax(
    ulong                   ProcNum,
    MIDL_SYNTAX_INFO  *     pSyntaxInfo,
    NDR_PROC_CONTEXT  *     pContext)
{

    PFORMAT_STRING      pFormat;
    SYNTAX_TYPE         SyntaxType = XFER_SYNTAX_NDR64;

    NDR_ASSERT( SyntaxType == NdrpGetSyntaxType( &pSyntaxInfo->TransferSyntax ) ,
                "invalid transfer sytnax" );

    pFormat = NdrpGetProcString( pSyntaxInfo,
                                 SyntaxType,
                                 ProcNum );

    MulNdrpInitializeContextFromProc( 
                                 SyntaxType,
                                 pFormat,
                                 pContext,
                                 NULL );    // StartofStack. Don't have it yet.

    pContext->pSyntaxInfo = pSyntaxInfo;

}

/*++

Routine Description :

    Setup the client side transfer syntax information from MIDL_PROXY_INFO
    This is the first thing the engine do from the public entries, so if 
    somethings goes wrong here, we don't have enough information about the 
    procedure and we can't recover from the error. We have to raise exception
    back to the application. 
    

Arguments :


Return :

    RPC_S_OK    if 

--*/
void RPC_ENTRY 
Ndr64ClientInitializeContext( 
    SYNTAX_TYPE                         SyntaxType, 
    const MIDL_STUBLESS_PROXY_INFO *    pProxyInfo,
    ulong                               nProcNum,
    NDR_PROC_CONTEXT *                  pContext,
    uchar *                             StartofStack )
{                          
    PFORMAT_STRING                      pFormat;
    RPC_STATUS                          res = RPC_S_OK;
    MIDL_SYNTAX_INFO *                  pSyntaxInfo = NULL;
    ulong                               i;

    pContext->StartofStack = StartofStack;

    for ( i = 0; i < pProxyInfo->nCount; i ++ )
        if ( SyntaxType == NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) )
            {
            pSyntaxInfo = & pProxyInfo->pSyntaxInfo[i];
            break;
            }

    // We can't do much if we are reading invalid format string
    if ( NULL == pSyntaxInfo )
        RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );
    else
        {
        pFormat = NdrpGetProcString( pSyntaxInfo, SyntaxType, nProcNum );

        MulNdrpInitializeContextFromProc( SyntaxType, pFormat, pContext, StartofStack );
        pContext->pSyntaxInfo = pSyntaxInfo;
        }

}

// Fill in RPC_CLIENT_INTERFACE in rpcmessage if the proxy only support one transfer syntax.
__inline 
HRESULT NdrpDcomSetupSimpleClientInterface( 
                                        MIDL_STUB_MESSAGE * pStubMsg,
                                        RPC_CLIENT_INTERFACE * pClientIf,
                                        const IID * riid,
                                        MIDL_STUBLESS_PROXY_INFO * pProxyInfo )
{                                        
    memset(pClientIf, 0, sizeof( RPC_CLIENT_INTERFACE ) );
    pClientIf->Length = sizeof( RPC_CLIENT_INTERFACE );
    pClientIf->InterfaceId.SyntaxGUID = *riid;
    memcpy(&pClientIf->TransferSyntax, 
                pProxyInfo->pTransferSyntax, 
                sizeof(RPC_SYNTAX_IDENTIFIER) );
    pClientIf->InterpreterInfo = pProxyInfo;
    pStubMsg->RpcMsg->RpcInterfaceInformation = pClientIf;
    return S_OK;
}


RPC_STATUS RPC_ENTRY
Ndr64pClientSetupTransferSyntax( void * pThis,
                           RPC_MESSAGE  *                   pRpcMsg,
                           MIDL_STUB_MESSAGE  *             pStubMsg,
                           MIDL_STUBLESS_PROXY_INFO *       pProxyInfo,
                           NDR_PROC_CONTEXT *               pContext,
                           ulong                            nProcNum )
{                                   
    const MIDL_STUB_DESC *              pStubDesc = pProxyInfo->pStubDesc;  
    RPC_STATUS                          res = S_OK;

    // setup vtbl first so we can recover from error
    Ndr64SetupClientContextVtbl( pContext );
    
    pStubMsg->pContext       = pContext;
    pStubMsg->StackTop       = pContext->StartofStack;
    if ( pThis )
        {
        ulong SyncProcNum;

        // In DCOM async interface, the proc number in rpcmessage is the sync method id
        // instead of async methodid, so we need to setup the proxy differently.
        if ( pContext->IsAsync )
            SyncProcNum = (nProcNum + 3 ) / 2;
        else
            SyncProcNum = nProcNum;
           
        Ndr64ProxyInitialize( pThis,
                            pRpcMsg,
                            pStubMsg,
                            pProxyInfo,
                            SyncProcNum ); 
        }
    else
        {
        handle_t Handle;
        PFNEXPLICITBINDHANDLEMGR            pfnExpBindMgr = NULL; 
        PFNIMPLICITBINDHANDLEMGR            pfnImpBindMgr = NULL; 

        if ( pContext->CurrentSyntaxType == XFER_SYNTAX_NDR64 )
            {
            pfnExpBindMgr = &Ndr64ExplicitBindHandleMgr;
            pfnImpBindMgr = &Ndr64ImplicitBindHandleMgr;
            }
        else
            {                                   
            pfnExpBindMgr = &ExplicitBindHandleMgr;
            pfnImpBindMgr = &ImplicitBindHandleMgr;
            }
            
        Ndr64ClientInitialize( pRpcMsg,
                               pStubMsg,
                               pProxyInfo,
                               (uint) nProcNum );

        if ( pContext->HandleType )
            {
            //
            // We have an implicit handle.
            //
            Handle = (*pfnImpBindMgr)( pStubDesc,
                                       pContext->HandleType,
                                       &(pContext->SavedGenericHandle) );
            }
        else
            {
            PFORMAT_STRING      pFormat;
            if ( pContext->CurrentSyntaxType == XFER_SYNTAX_DCE )
                pFormat = (PFORMAT_STRING) pContext->pHandleFormatSave;
            else
                pFormat = (uchar *) pContext->Ndr64Header+ sizeof(NDR64_PROC_FORMAT);
                
            Handle = (*pfnExpBindMgr)( pStubDesc,
                                       pContext->StartofStack,
                                       pFormat,
                                       &(pContext->SavedGenericHandle ) );
            }

            pStubMsg->RpcMsg->Handle = pStubMsg->SavedHandle = Handle;

        }

        pStubMsg->RpcMsg->RpcFlags = pContext->RpcFlags;


        // The client only negotiates when the stub support more than one 
        // transfer syntax. 
        if ( pProxyInfo->nCount > 1 )
            {
            res = Ndr64ClientNegotiateTransferSyntax( pThis,
                                                      pStubMsg,
                                                      pProxyInfo,
                                                      pContext );

            if ( RPC_S_OK == res )
                {
                PFORMAT_STRING   pFormat;
                SYNTAX_TYPE      SyntaxType;
                ulong            i = 0;

                SyntaxType = NdrpGetSyntaxType( pStubMsg->RpcMsg->TransferSyntax );
                if ( SyntaxType != pContext->CurrentSyntaxType )
                    {
                    for (i = 0; i < pProxyInfo->nCount; i++)
                        {
                        if ( SyntaxType == NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) )
                            {
                            pContext->pSyntaxInfo = &( pProxyInfo->pSyntaxInfo[i] );
                            break;
                            }
                        }

                    NDR_ASSERT( i < pProxyInfo->nCount, "can't find the right syntax" );

                    // Reread the format string if we select a different transfer syntax
                    pFormat = NdrpGetProcString( pContext->pSyntaxInfo,
                                             SyntaxType,
                                             nProcNum );
            
                    MulNdrpInitializeContextFromProc( SyntaxType , 
                                                      pFormat, 
                                                      pContext, 
                                                      pContext->StartofStack,
                                                      TRUE );   // reset
                    Ndr64SetupClientContextVtbl( pContext );           
                    }
                }
            }
        else
            {
            pContext->pSyntaxInfo = pProxyInfo->pSyntaxInfo;

            // we need to fake the RPC_CLIENT_INTERFACE if client only support NDR64
            if ( pThis )
                {
                const IID * riid;
                RPC_CLIENT_INTERFACE * pClientIf;

                pClientIf = (RPC_CLIENT_INTERFACE *)NdrpAlloca( &pContext->AllocateContext, sizeof( RPC_CLIENT_INTERFACE ) );
                
                if ( pContext->IsAsync )
                    {
                    riid = NdrGetSyncProxyIID( pThis );
                    }
                else
                    riid = NdrGetProxyIID(pThis);
                    
                NdrpDcomSetupSimpleClientInterface( pStubMsg,
                                                    pClientIf,
                                                    riid,
                                                    pProxyInfo );
                }
            
            }
    return res;
    
}


HRESULT NdrpDcomNegotiateSyntax( void * pThis,
                                 MIDL_STUB_MESSAGE *pStubMsg,
                                 MIDL_STUBLESS_PROXY_INFO * pProxyInfo,
                                 NDR_PROC_CONTEXT         * pContext
                                 )
{
    IRpcSyntaxNegotiate * pNegotiate = NULL;
    IRpcChannelBuffer * pChannel = pStubMsg->pRpcChannelBuffer;
    HRESULT hr = E_FAIL ; 
    ulong nPrefer;
    const IID * riid;

    RPC_CLIENT_INTERFACE * pclientIf;

    pclientIf = ( RPC_CLIENT_INTERFACE * ) NdrpAlloca( &pContext->AllocateContext, sizeof( RPC_CLIENT_INTERFACE ) );

    if ( pContext->IsAsync )
        {
        riid = NdrGetSyncProxyIID( pThis );
        }
    else
        riid = NdrGetProxyIID(pThis);
        
    hr = pChannel->lpVtbl->QueryInterface( pChannel, IID_IRpcSyntaxNegotiate, (void **)&pNegotiate );

    if ( SUCCEEDED( hr ) )
        {
        // create RPC_CLIENT_INTERFACE here.
        memset(pclientIf, 0, sizeof( RPC_CLIENT_INTERFACE ) );
        pclientIf->Length = sizeof( RPC_CLIENT_INTERFACE ) ;
        pclientIf->InterfaceId.SyntaxGUID = *riid;
        memcpy(&pclientIf->TransferSyntax, 
                pProxyInfo->pTransferSyntax, 
                sizeof(RPC_SYNTAX_IDENTIFIER) );
        pclientIf->InterpreterInfo = pProxyInfo;
        pclientIf->Flags |= RPCFLG_HAS_MULTI_SYNTAXES;

        pStubMsg->RpcMsg->RpcInterfaceInformation = pclientIf;

        hr = pNegotiate->lpVtbl->NegotiateSyntax( pNegotiate, (RPCOLEMESSAGE *)pStubMsg->RpcMsg );

        // OLE will return S_FALSE in local server case, where OLE doesn't involve RPC runtime
        // to send package, such that I_RpcNegotiateSyntax can't be called. 
        if ( hr == S_FALSE )
            {
            NdrpGetPreferredSyntax( (ulong )pProxyInfo->nCount, pProxyInfo->pSyntaxInfo, &nPrefer );
            pStubMsg->RpcMsg->TransferSyntax = &pProxyInfo->pSyntaxInfo[nPrefer].TransferSyntax;
            hr = S_OK;
            }

        pNegotiate->lpVtbl->Release( pNegotiate );
        }
    else
        {
        // old style proxy
        hr  = NdrpDcomSetupSimpleClientInterface( pStubMsg, pclientIf, riid, pProxyInfo );
        }

    return hr;
}



RPC_STATUS RPC_ENTRY
Ndr64ClientNegotiateTransferSyntax(
    void *                       pThis,
    MIDL_STUB_MESSAGE           *pStubMsg,
    MIDL_STUBLESS_PROXY_INFO    *pProxyInfo,
    NDR_PROC_CONTEXT            *pContext  )
{
    RPC_STATUS status =         RPC_S_UNSUPPORTED_TRANS_SYN ;
    RPC_MESSAGE                 *pRpcMsg = pStubMsg->RpcMsg;
    const MIDL_STUB_DESC  *     pStubDesc = pProxyInfo->pStubDesc;
    ulong                        i;
    ushort                      FormatOffset;
    ushort  *                   pFormat; 
    uchar                       HandleType;
    HRESULT                     hr;
    SYNTAX_TYPE                 SyntaxType;

    if ( pThis )
        {
        hr = NdrpDcomNegotiateSyntax( pThis, pStubMsg, pProxyInfo, pContext );
        if ( FAILED( hr ) )
            RpcRaiseException( hr );

        status = RPC_S_OK;
        }
    else
        {
        if ( pContext->UseLocator )
            {
            // call into locator's negotiation code 
            EnsureNSLoaded();
            status = (*pRpcNsNegotiateTransferSyntax)( pStubMsg->RpcMsg );           
            }
        else
            {
            status = I_RpcNegotiateTransferSyntax( pStubMsg->RpcMsg );
            }
        if ( status != RPC_S_OK )
            RpcRaiseException( status );
        }


    return status;
}

void RPC_ENTRY
Ndr64pSizing( MIDL_STUB_MESSAGE *   pStubMsg,
            BOOL                    IsClient )
{
    long n;   
    uchar *                     pArg;
    NDR64_PARAM_FLAGS   *   pParamFlags;
    NDR_PROC_CONTEXT  *     pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    NDR64_PARAM_FORMAT  *   Params = 
         (NDR64_PARAM_FORMAT*)pContext->Params;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pContext->StartofStack );
    
    for (ulong n = 0; n < pContext->NumberParams; n++ )
        {
        pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( IsClient && pParamFlags->IsPartialIgnore )
            {

            LENGTH_ALIGN(pStubMsg->BufferLength, NDR64_PTR_WIRE_ALIGN );
            pStubMsg->BufferLength += sizeof(NDR64_PTR_WIRE_TYPE);
            continue;
            }

        if (  !NDR64SAMEDIRECTION(IsClient, pParamFlags) ||
             ! ( pParamFlags->MustSize ) )
            continue;

        //
        // Note : Basetypes will always be factored into the
        // constant buffer size emitted by in the format strings.
        //

        pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar **)pArg);

        Ndr64TopLevelTypeSize( pStubMsg,
                               pArg,
                               Params[n].Type );

        }
}    


void
Ndr64ClientZeroOut(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    uchar *             pArg
    )
{
    const NDR64_POINTER_FORMAT *pPointerFormat = 
        (const NDR64_POINTER_FORMAT*)pFormat;

    //
    // In an object proc, we must zero all [out] unique and interface
    // pointers which occur as the referent of a ref pointer or embedded in a
    // structure or union.
    //

    // Let's not die on a null ref pointer.

    if ( !pArg )
        return;

    //
    // The only top level [out] type allowed is a ref pointer or an array.
    //
    if ( *(PFORMAT_STRING)pFormat == FC64_RP )
        {
        pFormat = pPointerFormat->Pointee;
        // Double pointer.
        if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
            {
            *((void **)pArg) = 0;
            return;
            }

        // we need to zero out basetype because it might be conformant/
        // varying descriptor.
        if ( NDR64_SIMPLE_POINTER( pPointerFormat->Flags ) )
            {
            MIDL_memset( pArg, 0, 
                         (uint) NDR64_SIMPLE_TYPE_MEMSIZE( *(PFORMAT_STRING)pFormat ) );
            return;
            }

        }

    NDR64_UINT32 Size = Ndr64pMemorySize( pStubMsg,
                                          pFormat, 
                                          FALSE );

    MIDL_memset( pArg, 0, (size_t)Size );
}



void RPC_ENTRY
Ndr64pClientInit( MIDL_STUB_MESSAGE * pStubMsg,
                           void *              pReturnValue )
{
    NDR_PROC_CONTEXT    *       pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    NDR64_PROC_FORMAT   *       pHeader = pContext->Ndr64Header;
    BOOL                        fRaiseExcFlag = FALSE;    
    ulong                       n;
    uchar *                     pArg;
    NDR64_PARAM_FORMAT  *       Params;
    NDR64_PROC_FLAGS  *         pNdr64Flags;   
    NDR64_PARAM_FLAGS   *       pParamFlags;


    pNdr64Flags = (NDR64_PROC_FLAGS  * )&(pHeader->Flags) ;

    Params = ( NDR64_PARAM_FORMAT *) pContext->Params;
    

    if ( pNdr64Flags->UsesFullPtrPackage )
        pStubMsg->FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_CLIENT );
    else
        pStubMsg->FullPtrXlatTables = 0;


    if ( pNdr64Flags->UsesRpcSmPackage )
        NdrRpcSmSetClientToOsf( pStubMsg );

    if ( pNdr64Flags->UsesPipes )
        NdrpPipesInitialize64( pStubMsg,
                               &pContext->AllocateContext,
                               (PFORMAT_STRING) Params,
                               (char *)pContext->StartofStack,
                               pContext->NumberParams  );

    pStubMsg->StackTop = pContext->StartofStack;

    pStubMsg->pCorrMemory = pStubMsg->StackTop;

    // get initial size here: we might not need to get into sizing code.
    pStubMsg->BufferLength = pHeader->ConstantClientBufferSize;

    for ( n = 0; n < pContext->NumberParams; n++ )
        {
        pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( pParamFlags->IsReturn )
            pArg = (uchar *) &pReturnValue;
        else
            pArg = pContext->StartofStack + Params[n].StackOffset;

        if ( pParamFlags->IsSimpleRef && !pParamFlags->IsReturn )
            {
            // We cannot raise the exception here,
            // as some out args may not be zeroed out yet.
            
            if ( ! *((uchar **)pArg) )
                {
                fRaiseExcFlag = TRUE;
                continue;
                }
            
            }

        // if top level point is ref pointer and the stack is NULL, we'll catch this
        // before the call goes to server. 
        if ( pParamFlags->IsOut && !pParamFlags->IsBasetype )
            {
            if ( *(PFORMAT_STRING) Params[n].Type == FC64_RP &&  !*((uchar **)pArg) )
                {
                fRaiseExcFlag = TRUE;
                continue;
                }            
            }
        
        if ( ( pNdr64Flags->IsObject  &&
               ! pContext->IsAsync &&
               ( pParamFlags->IsPartialIgnore ||
                   ( ! pParamFlags->IsIn &&
                     ! pParamFlags->IsReturn &&
                     ! pParamFlags->IsPipe ) ) ) ||
             ( pNdr64Flags->HasComplexReturn &&
                        pParamFlags->IsReturn ) )
         {
        if ( pParamFlags->IsBasetype )
            {
            // [out] only arg can only be ref, we checked that above.

            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING) Params[n].Type;
            
            MIDL_memset( *(uchar **)pArg, 
                         0, 
                         (size_t)NDR64_SIMPLE_TYPE_MEMSIZE( type ));
            }
        else
            { 
            Ndr64ClientZeroOut(
                    pStubMsg,
                    Params[n].Type,
                    *(uchar **)pArg );
            }
         }
    }

    if ( fRaiseExcFlag )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );
    
    if ( !pNdr64Flags->ClientMustSize )
        pContext->pfnSizing = (PFNSIZING)NdrpNoopSizing;
}

void RPC_ENTRY
Ndr64pDcomClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                             ProcNum,
                      RPC_STATUS                        ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  )
{
    ulong                   NumberParams ;
    NDR64_PARAM_FORMAT  *   Params ;
    ulong                   n;
    uchar               *   pArg;
    NDR64_PARAM_FLAGS   *   pParamFlags;
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

    pReturnValue->Simple = NdrProxyErrorHandler(ExceptionCode);

    if( pStubMsg->dwStubPhase != PROXY_UNMARSHAL)
        return ;

    NumberParams = pContext->NumberParams;
    Params = ( NDR64_PARAM_FORMAT * ) pContext->Params;
    //
    // Set the Buffer endpoints so the Ndr64Free routines work.
    //
    pStubMsg->BufferStart = 0;
    pStubMsg->BufferEnd   = 0;

    for ( n = 0; n < NumberParams; n++ )
        {
        pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        //
        // Skip everything but [out] only parameters.  We make
        // the basetype check to cover [out] simple ref pointers
        // to basetypes.
        //
        
        if ( !pParamFlags->IsPartialIgnore )
            {
            if ( pParamFlags->IsIn ||
                 pParamFlags->IsReturn ||
                 pParamFlags->IsBasetype ||
                 pParamFlags->IsPipe )
                continue;            
            }

        pArg = pContext->StartofStack + Params[n].StackOffset;

        Ndr64ClearOutParameters( pStubMsg,
                               Params[n].Type,
                               *((uchar **)pArg) );
        }

    return ;
}


void RPC_ENTRY
Ndr64pClientExceptionHandling(  MIDL_STUB_MESSAGE  *    pStubMsg,
                      ulong                             ProcNum,
                      RPC_STATUS                        ExceptionCode,
                      CLIENT_CALL_RETURN  *   pReturnValue  )
{
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

        if ( ( (NDR64_PROC_FLAGS *) & pContext->Ndr64Header->Flags)->HandlesExceptions )
            {
            NdrClientMapCommFault( pStubMsg,
                                   ProcNum,
                                   ExceptionCode,
                                   (ULONG_PTR*)&pReturnValue->Simple );
            }
        else
            {
            RpcRaiseException(ExceptionCode);
            }

    return;
}


void RPC_ENTRY 
Ndr64pClientMarshal( MIDL_STUB_MESSAGE *    pStubMsg,
             BOOL                   IsObject )
{
    NDR_PROC_CONTEXT *      pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;

//    if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
//        RpcRaiseException( RPC_X_INVALID_BUFFER );

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pContext->StartofStack ); 
    
    NDR64_PARAM_FORMAT  *Params = (NDR64_PARAM_FORMAT *) pContext->Params;

    for ( ulong n = 0; n < pContext->NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = 
            ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );

        uchar *pArg = pContext->StartofStack + Params[n].StackOffset;
        
        if ( pParamFlags->IsPartialIgnore )
            {
            ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
            *((NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer) = (*pArg) ? (NDR64_PTR_WIRE_TYPE)1 :
                                                                  (NDR64_PTR_WIRE_TYPE)0;
			pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
            continue;

            }

        if ( !pParamFlags->IsIn || 
             pParamFlags->IsPipe )
            continue;        

        if ( pParamFlags->IsBasetype )
            {

            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;
            
            //
            // Check for pointer to basetype.
            //
            if ( pParamFlags->IsSimpleRef )
                pArg = *((uchar **)pArg);
            else
                {

#if defined(_IA64_)    || defined(_AMD64_)
                 if ( !IsObject && type == FC64_FLOAT32 )
                    {
                    // Due to the fact that NdrClientCall2 is called with the
                    // parameters in ... arguments, floats get promoted to doubles.
                    // This is not true for DCOM since an assembly langauge wrapper
                    // is used that saves the floats as floats.
                    //
                    // We do not handle this case properly. 
                    *((float *) pArg) = (float) *((double *)pArg);     

                    }
#endif     

                }

            Ndr64SimpleTypeMarshallRoutinesTable[type](pStubMsg, pArg );
            continue;
            }

        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar **)pArg);

        Ndr64TopLevelTypeMarshall( pStubMsg,
                                   pArg,
                                   Params[n].Type );

        }     
        if ( pStubMsg->RpcMsg->BufferLength <
                 (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
            {
            NDR_ASSERT( 0, "Ndr64pClientmarshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }        
}



void RPC_ENTRY 
Ndr64pServerMarshal( MIDL_STUB_MESSAGE *    pStubMsg )
{
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;

//    if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
//        RpcRaiseException( RPC_X_INVALID_BUFFER );

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pContext->StartofStack );
    NDR64_PARAM_FORMAT  *Params = (NDR64_PARAM_FORMAT *) pContext->Params;

    for ( ulong n = 0; n < pContext->NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );

        uchar *pArg = pContext->StartofStack + Params[n].StackOffset;
        
        if (!pParamFlags->IsOut || 
             pParamFlags->IsPipe )
            continue;        

        if ( pParamFlags->IsBasetype )
            {
            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

            //
            // Check for pointer to basetype.
            //
            if ( pParamFlags->IsSimpleRef )
                pArg = *((uchar **)pArg);

            Ndr64SimpleTypeMarshallRoutinesTable[type](pStubMsg, pArg );

            continue;
            }   

        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar **)pArg);

        Ndr64TopLevelTypeMarshall( pStubMsg,
                                   pArg,
                                   Params[n].Type);

        }     
    if ( pStubMsg->RpcMsg->BufferLength <
             (uint)(pStubMsg->Buffer - (uchar *)pStubMsg->RpcMsg->Buffer) )
        {
        NDR_ASSERT( 0, "Ndr64pCompleteAsyncServerCall marshal: buffer overflow!" );
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        }
        
}

void RPC_ENTRY 
Ndr64pClientUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg,
                void *                  pReturnValue )
{
    uchar *                     pArg;
    NDR_PROC_CONTEXT *          pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;

    NDR64_PARAM_FORMAT  *Params = (NDR64_PARAM_FORMAT *)pContext->Params;

//    if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
//        RpcRaiseException( RPC_X_INVALID_BUFFER );

    CORRELATION_CONTEXT( pStubMsg, pContext->StartofStack );
   
    //
    // ----------------------------------------------------------
    // Unmarshall Pass.
    // ----------------------------------------------------------
    //

    for ( ulong n = 0; n < pContext->NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( pParamFlags->IsPipe )
            continue;

        if ( !pParamFlags->IsOut )
            {
            if ( !pParamFlags->IsIn && !pParamFlags->IsReturn )
                {
                // If a param is not [in], [out], or a return value,
                // then it is a "hidden" client-side only status
                // paramater.  It will get set below if an exception
                // happens.  If everything is ok we need to zero it
                // out here.

                NDR_ASSERT( pParamFlags->IsSimpleRef
                                && pParamFlags->IsBasetype
                                && FC64_ERROR_STATUS_T == 
                                          *(PFORMAT_STRING)Params[n].Type,
                            "Apparently not a hidden status param" );

                pArg = pContext->StartofStack + Params[n].StackOffset;

                ** (error_status_t **) pArg = RPC_S_OK;
                }

            continue;
            }

        if ( pParamFlags->IsReturn )
            {
            if ( ! pReturnValue )
                RpcRaiseException( RPC_S_INVALID_ARG );

            pArg = (uchar *) pReturnValue;
            }
        else
            pArg = pContext->StartofStack + Params[n].StackOffset;

        //
        // This is for returned basetypes and for pointers to
        // basetypes.
        //
        if ( pParamFlags->IsBasetype )
            {
            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

            //
            // Check for a pointer to a basetype.
            //
            if ( pParamFlags->IsSimpleRef )
                pArg = *((uchar **)pArg);

            ALIGN( pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( type ) );

            RpcpMemoryCopy(
                pArg,
                pStubMsg->Buffer,
                NDR64_SIMPLE_TYPE_BUFSIZE( type ) );

            pStubMsg->Buffer +=
                NDR64_SIMPLE_TYPE_BUFSIZE( type );

            continue;
            }


        uchar **ppArg = pParamFlags->IsByValue ? &pArg : (uchar **)pArg;

        //
        // Transmit/Represent as can be passed as [out] only, thus
        // the IsByValue check.
        //
        Ndr64TopLevelTypeUnmarshall( pStubMsg,
                                     ppArg,
                                     Params[n].Type,
                                     false );
        }

    if ( pStubMsg->pCorrInfo )
        Ndr64CorrelationPass( pStubMsg );

    return ;
   
}


void  RPC_ENTRY
Ndr64pClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                     void *  pThis )
{
    NDR_PROC_CONTEXT * pContext = (NDR_PROC_CONTEXT *)pStubMsg->pContext;
    PMIDL_STUB_DESC   pStubDesc = pStubMsg->StubDesc;
    NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

    //
    // Free the RPC buffer.
    //
    if ( pThis )
        {
        NdrProxyFreeBuffer( pThis, pStubMsg );
        }
    else
        {
        NdrFreeBuffer( pStubMsg );

        //
        // Unbind if generic handle used.  We do this last so that if the
        // the user's unbind routine faults, then all of our internal stuff
        // will already have been freed.
        //
        if ( pContext->SavedGenericHandle )
            Ndr64GenericHandleUnbind( pStubDesc,
                             pContext->StartofStack,
                             (uchar *)pContext->Ndr64Header+ sizeof(NDR64_PROC_FORMAT),
                             (pContext->HandleType) ? IMPLICIT_MASK : 0,
                             &pContext->SavedGenericHandle );
        }

    NdrpAllocaDestroy( & pContext->AllocateContext );
}
              

void 
Ndr64pServerOutInit( PMIDL_STUB_MESSAGE pStubMsg )
{
    NDR_PROC_CONTEXT * pContext = ( NDR_PROC_CONTEXT *) pStubMsg->pContext;
    NDR64_PARAM_FLAGS   *       pParamFlags;
    NDR64_PARAM_FORMAT* Params =   (NDR64_PARAM_FORMAT*)pContext->Params;
    NDR64_PROC_FLAGS *      pNdr64Flags = (NDR64_PROC_FLAGS *)&pContext->Ndr64Header->Flags;
    uchar *                 pArg;    
    
    for ( ulong n = 0; n < pContext->NumberParams; n++ )
        {
        pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( !pParamFlags->IsPartialIgnore )
            {
            
            if (  pParamFlags->IsIn     ||
                  (pParamFlags->IsReturn && !pNdr64Flags->HasComplexReturn) ||
                  pParamFlags->IsPipe )
                continue;

            pArg = pContext->StartofStack + Params[n].StackOffset;


            }
        else 
            {

            pArg = pContext->StartofStack + Params[n].StackOffset;

            if ( !*(void**)pArg )
                continue;
            }

        //
        // Check if we can initialize this parameter using some of our
        // stack.
        //
        if ( pParamFlags->UseCache  )
            {
            *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext, 64 ); 
             
            MIDL_memset( *((void **)pArg),
                         0,
                         64 );
            continue;
            }
        else if ( pParamFlags->IsBasetype )
            {
            *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext,8);
            MIDL_memset( *((void **)pArg), 0, 8 );
            continue;
            };

        Ndr64OutInit( pStubMsg,
                    Params[n].Type,
                    (uchar **)pArg );
        }

}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\misc.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993 Microsoft Corporation

Module Name :

    misc.c

Abstract :

    Contains miscelaneous helper routines.

Author :

    David Kays  dkays   December 1993.

Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"

uchar *
Ndr64pMemoryIncrement( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat,
    BOOL                fUseBufferConformance
    )
/*++

Routine Description :

    Returns a memory pointer incremeted past a complex data type.  This routine
    is also overloaded to compute the size of a complex data type by passing
    a 0 memory pointer.

Arguments :

    pStubMsg                - Pointer to the stub message.
    pMemory                 - Pointer to the complex type, or 0 if a size is being computed.
    pFormat                 - Format string description.
    fUseBufferConformance   - Use conformance from buffer(During unmarshalling).

Return :

    A memory pointer incremented past the complex type.  If a 0 memory pointer
    was passed in then the returned value is the size of the complex type.

--*/
{
    long    Elements;
    long    ElementSize;

    switch ( *(PFORMAT_STRING)pFormat )
        {
         //
         // simple types
         //
         case FC64_CHAR :
         case FC64_WCHAR :
         case FC64_INT8:
         case FC64_UINT8:
         case FC64_INT16:
         case FC64_UINT16:
         case FC64_INT32:
         case FC64_UINT32:
         case FC64_INT64:
         case FC64_UINT64:
         case FC64_FLOAT32 :
         case FC64_FLOAT64 :
         case FC64_ERROR_STATUS_T:
         case FC64_IGNORE :
             pMemory +=  NDR64_SIMPLE_TYPE_MEMSIZE(*(PFORMAT_STRING)pFormat);
             break;

        //
        // Structs
        //
        case FC64_STRUCT :
        case FC64_PSTRUCT :
            pMemory += ((const NDR64_STRUCTURE_HEADER_FORMAT*)pFormat)->MemorySize;
            break;

        case FC64_CONF_STRUCT :
        case FC64_CONF_PSTRUCT :
            {
            const NDR64_CONF_STRUCTURE_HEADER_FORMAT *pStructFormat = 
                (const NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
            
            pMemory += pStructFormat->MemorySize;
            pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                             pMemory,
                                             pStructFormat->ArrayDescription,
                                             fUseBufferConformance );
            }

            break;
            
        case FC64_BOGUS_STRUCT :
        case FC64_FORCED_BOGUS_STRUCT:
            pMemory += ((const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*)pFormat)->MemorySize;
            break;

        case FC64_CONF_BOGUS_STRUCT:
        case FC64_FORCED_CONF_BOGUS_STRUCT:
            {
            const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT *pStructFormat = 
                (const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

            CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
            
            pMemory += pStructFormat->MemorySize;
            pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                             pMemory,
                                             pStructFormat->ConfArrayDescription,
                                             fUseBufferConformance );
            
            }
            break;

            
        //
        // Unions
        //
        case FC64_ENCAPSULATED_UNION :
            pMemory += ((const NDR64_ENCAPSULATED_UNION*)pFormat)->MemorySize;
            break;

        case FC64_NON_ENCAPSULATED_UNION :            
            pMemory += ((const NDR64_NON_ENCAPSULATED_UNION*)pFormat)->MemorySize;
            break;

        //
        // Arrays
        //
        case FC64_FIX_ARRAY :
            pMemory += ((const NDR64_FIX_ARRAY_HEADER_FORMAT*)pFormat)->TotalSize;
            break;

        case FC64_CONF_ARRAY:
            {
            const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
                (const NDR64_CONF_ARRAY_HEADER_FORMAT *)pFormat;
            SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );

            NDR64_WIRE_COUNT_TYPE Elements;

            if ( fUseBufferConformance )
                {
                Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
                pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
                }
            else 
                {
                Elements = 
                Ndr64EvaluateExpr( pStubMsg,
                                   pArrayFormat->ConfDescriptor,
                                   EXPR_MAXCOUNT );
                }


            pMemory += Ndr64pConvertTo2GB( (NDR64_UINT64)pArrayFormat->ElementSize *
                                           Elements );

            }
            break;

        case FC64_CONFVAR_ARRAY:
            {
            const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT *pArrayFormat =
                (const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT *)pFormat;
            SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
            NDR64_WIRE_COUNT_TYPE Elements;

            if ( fUseBufferConformance )
                {
                Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
                pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
                }
            else 
                {
                Elements =
                Ndr64EvaluateExpr( pStubMsg,
                                   pArrayFormat->ConfDescriptor,
                                   EXPR_MAXCOUNT );
                }


            pMemory += Ndr64pConvertTo2GB( (NDR64_UINT64)pArrayFormat->ElementSize *
                                           Elements );
            }
            break;

        case FC64_VAR_ARRAY:
            {
            const NDR64_VAR_ARRAY_HEADER_FORMAT *pArrayFormat =
                (NDR64_VAR_ARRAY_HEADER_FORMAT*)pFormat;
            pMemory += pArrayFormat->TotalSize;
            }
            break;

        case FC64_FIX_BOGUS_ARRAY :
        case FC64_FIX_FORCED_BOGUS_ARRAY:
        case FC64_BOGUS_ARRAY:
        case FC64_FORCED_BOGUS_ARRAY:
            
            {
            
            const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
                (NDR64_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;
            
            NDR64_WIRE_COUNT_TYPE Elements = pArrayFormat->NumberElements;

            BOOL IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                           ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

            SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark ); 

            if ( !IsFixed )
                {

                const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
                    (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

                if ( pConfVarFormat->ConfDescription )
                    {
                    if ( fUseBufferConformance )
                        {
                        Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
                        pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
                        }
                    else 
                        {
                        Elements = (NDR64_UINT32)
                                   Ndr64EvaluateExpr(pStubMsg,
                                                     pConfVarFormat->ConfDescription,
                                                     EXPR_MAXCOUNT);

                        }
                    }
                
                }

            NDR64_UINT32 ElementMemorySize = 
                (NDR64_UINT32)( Ndr64pMemoryIncrement( pStubMsg,
                                                       pMemory,
                                                       pArrayFormat->Element,
                                                       fUseBufferConformance ) - pMemory );

            pMemory += Ndr64pConvertTo2GB( (NDR64_UINT64)ElementMemorySize *
                                           Elements );                
            }
            break;

        //
        // String arrays (a.k.a. non-conformant strings).
        //
        case FC64_CHAR_STRING:
        case FC64_WCHAR_STRING:
        case FC64_STRUCT_STRING:
            {
            const NDR64_NON_CONFORMANT_STRING_FORMAT *pStringFormat =
                (const NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;
            pMemory += pStringFormat->TotalSize;
            break;
            }
        //
        // Sized conformant strings.
        //
        case FC64_CONF_CHAR_STRING:
        case FC64_CONF_WCHAR_STRING:
        case FC64_CONF_STRUCT_STRING:
            {

            const NDR64_SIZED_CONFORMANT_STRING_FORMAT *pStringFormat =
                (const NDR64_SIZED_CONFORMANT_STRING_FORMAT *) pFormat;            
            NDR64_WIRE_COUNT_TYPE Elements;

            SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );

            NDR_ASSERT( pStringFormat->Header.Flags.IsSized, 
                       "Ndr64pMemoryIncrement : called for non-sized string");

            if ( fUseBufferConformance )
                {
                Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
                pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);
                }
            else
                {
                Elements =  Ndr64EvaluateExpr( pStubMsg, 
                                               pStringFormat->SizeDescription, 
                                               EXPR_MAXCOUNT );                
                }

            pMemory += Ndr64pConvertTo2GB( Elements * 
                                           (NDR64_UINT64)pStringFormat->Header.ElementSize );
            }
            break;

        case FC64_RP :
        case FC64_UP :
        case FC64_OP :
        case FC64_IP :
        case FC64_FP :
            pMemory += PTR_MEM_SIZE;
            break;

        case FC64_RANGE:
            pMemory += NDR64_SIMPLE_TYPE_MEMSIZE( ((NDR64_RANGE_FORMAT *)pFormat)->RangeType );
            break;
        //
        // Transmit as, represent as, user marshal
        //
        case FC64_TRANSMIT_AS :
        case FC64_REPRESENT_AS :
            pMemory += ( ( NDR64_TRANSMIT_AS_FORMAT * )pFormat )->PresentedTypeMemorySize;
            break;
            
        case FC64_USER_MARSHAL :
            // Get the presented type size.
            pMemory += ( ( NDR64_USER_MARSHAL_FORMAT * )pFormat )->UserTypeMemorySize;
            break;
            

        default :
            NDR_ASSERT(0,"Ndr64pMemoryIncrement : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    return pMemory;
}

BOOL
Ndr64pIsStructStringTerminator(
    NDR64_UINT8*    pMemory,
    NDR64_UINT32    ElementSize
    )
/*--

RoutineDescription :

    Determines is pMemory is a struct string terminator.

Arguments :

    pMemory     - Pointer to struct string character.
    ElementSize - Number of bytes of each string character.

Return :

    Length of string.

--*/
{
    while( ElementSize-- ) 
        {
        if ( *pMemory++ != 0)
            return FALSE;
        }
    return TRUE;
}

NDR64_UINT32
Ndr64pStructStringLen( 
    NDR64_UINT8*    pMemory,
    NDR64_UINT32    ElementSize
    )
/*--

RoutineDescription :

    Determines a stringable struct's length.

Arguments :

    pMemory     - Pointer to stringable struct.
    ElementSize - Number of bytes of each string element.

Return :

    Length of string.

--*/
{
    NDR64_UINT32 StringSize = 0;
    
    while( !Ndr64pIsStructStringTerminator( pMemory, ElementSize ) )
        {
        StringSize++;
        pMemory += ElementSize;
        }
    return StringSize;
}
 
NDR64_UINT32 
Ndr64pCommonStringSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    uchar *                             pMemory,
    const NDR64_STRING_HEADER_FORMAT    *pStringFormat
    )
{
    NDR64_UINT64    CopySize64;

    // Compute the element count of the string and the total copy size.
    switch ( pStringFormat->FormatCode )
        {
        case FC64_CHAR_STRING:
        case FC64_CONF_CHAR_STRING:
            CopySize64 = pStubMsg->ActualCount = strlen((char *)pMemory) + 1;
            break;

        case FC64_WCHAR_STRING:
        case FC64_CONF_WCHAR_STRING:
            pStubMsg->ActualCount = wcslen((wchar_t *)pMemory) + 1;
            CopySize64  = (NDR64_UINT64)pStubMsg->ActualCount * (NDR64_UINT64)sizeof(wchar_t);
            break;

        case FC64_STRUCT_STRING:
        case FC64_CONF_STRUCT_STRING:
            pStubMsg->ActualCount = Ndr64pStructStringLen( (NDR64_UINT8*)pMemory, 
                                                           pStringFormat->ElementSize ) + 1;
            CopySize64  = (NDR64_UINT64)pStubMsg->ActualCount * 
                          (NDR64_UINT64)pStringFormat->ElementSize;
            break;

        default :
            NDR_ASSERT(0,"Ndr64pConformantStringMarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }

    pStubMsg->Offset = 0;
    return Ndr64pConvertTo2GB( CopySize64 );
}

PNDR64_FORMAT
Ndr64pFindUnionArm(
    PMIDL_STUB_MESSAGE pStubMsg,
    const NDR64_UNION_ARM_SELECTOR* pArmSelector,
    EXPR_VALUE Value
    )
{
    const NDR64_UNION_ARM *pUnionArm  = (NDR64_UNION_ARM*)(pArmSelector + 1);
    NDR64_UINT32 Arms                 = pArmSelector->Arms;

    while(1) 
        {

        if (0 == Arms--)
            {

            PNDR64_FORMAT DefaultType = *(PNDR64_FORMAT*)pUnionArm;

            // MIDL generates 0xffffffff instead of -1 here, and pointer is 64bit.
            if ( (NDR64_UINT32)((ULONG_PTR)DefaultType) != 0xffffffff)
                {
                return DefaultType ? *(PNDR64_FORMAT*)pUnionArm :
                                     NULL;
                }
            else
                {
                RpcRaiseException( RPC_S_INVALID_TAG );
                return 0;
                }
            }

        if ( (EXPR_VALUE)pUnionArm->CaseValue == Value )
            {
            return pUnionArm->Type ? pUnionArm->Type : NULL;
            }

        pUnionArm++;
        }
}


EXPR_VALUE
Ndr64pSimpleTypeToExprValue(
    NDR64_FORMAT_CHAR FormatChar,
    uchar *pSimple)
{
    switch( FormatChar )
        {
        case FC64_UINT8:
            return (EXPR_VALUE)*(unsigned char *)pSimple;
        
        case FC64_CHAR:
        case FC64_INT8:
            return (EXPR_VALUE)*(signed char *)pSimple;
        
        case FC64_WCHAR:
        case FC64_UINT16:
            return (EXPR_VALUE)*(unsigned short *)pSimple;
        
        case FC64_INT16:
            return (EXPR_VALUE)*(signed short *)pSimple;
        
        case FC64_UINT32:
            return (EXPR_VALUE)*(unsigned long *)pSimple;
        
        case FC64_INT32:
        case FC64_ERROR_STATUS_T:
            return (EXPR_VALUE)*(signed long *)pSimple;

        case FC64_INT64:
            return (EXPR_VALUE)*(NDR64_INT64 *)pSimple;

        case FC64_UINT64:
            return (EXPR_VALUE)*(NDR64_UINT64 *)pSimple;

        case FC64_POINTER:
            return (EXPR_VALUE)*(void **)pSimple;
     default :
         NDR_ASSERT(0,"Ndr64pSimpleTypeToExprValue : bad swith type");
         RpcRaiseException( RPC_S_INTERNAL_ERROR );
         return 0;
     }
}

EXPR_VALUE
Ndr64pCastExprValueToExprValue(
    NDR64_FORMAT_CHAR FormatChar,
    EXPR_VALUE Value)
{
    switch ( FormatChar )
        {
        
        case FC64_UINT8:
            return (EXPR_VALUE)(unsigned char)Value;
        
        case FC64_INT8:
        case FC64_CHAR:
            return (EXPR_VALUE)(signed char)Value;
        
        case FC64_UINT16:
        case FC64_WCHAR:
            return (EXPR_VALUE)(unsigned short)Value;
        
        case FC64_INT16:
            return (EXPR_VALUE)(signed short)Value;
        
        case FC64_UINT32:
            return (EXPR_VALUE)(unsigned long)Value;
        
        case FC64_INT32:
            return (EXPR_VALUE)(signed long)Value;

        case FC64_UINT64:
            return (EXPR_VALUE)(NDR64_UINT64)Value;

        case FC64_INT64:
            return (EXPR_VALUE)(NDR64_INT64)Value;
        
        case FC64_POINTER:
            return (EXPR_VALUE)(void *)Value;
        
        default:
            NDR_ASSERT(0,"Ndr64pCastExprValueToExprValue : Illegal type.");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return 0;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\pipes.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                                                   
Copyright (c) 1995 - 2000 Microsoft Corporation

Module Name :

    pipes.cxx

Abstract :

    This file contains the 64bit specified pipe code.

Author :

    Mike Zoran     (mzoran)    Feb 2000

Revision History :

---------------------------------------------------------------------*/

#include "precomp.hxx"
#include "..\ndr20\pipendr.h"


class NDR_PIPE_HELPER64 : public NDR_PIPE_HELPER
{

private:

    PMIDL_STUB_MESSAGE pStubMsg;
    char *pStackTop;

    unsigned long NumberParameters;
    NDR64_PARAM_FORMAT* pFirstParameter;

    NDR64_PARAM_FORMAT* pCurrentParameter;
    unsigned long CurrentParamNumber;

    NDR_PIPE_DESC PipeDesc;

public:

    void *operator new( size_t stAllocateBlock, PNDR_ALLOCA_CONTEXT pAllocContext )
    {
        return NdrpAlloca( pAllocContext, (UINT)stAllocateBlock );
    }
    // Do nothing since the memory will be deleted automatically
    void operator delete(void *pMemory) {}

    NDR_PIPE_HELPER64( PMIDL_STUB_MESSAGE  pStubMsg,
                       PFORMAT_STRING      Params,
                       char *              pStackTop,
                       unsigned long       NumberParams )
    {
        NDR_PIPE_HELPER64::pStubMsg  = pStubMsg;
        NDR_PIPE_HELPER64::pStackTop = pStackTop; 
        pFirstParameter  = (NDR64_PARAM_FORMAT*)Params;
        NumberParameters = NumberParams;

    }

    virtual PNDR_PIPE_DESC GetPipeDesc() 
        {
        return &PipeDesc;
        }

    virtual bool InitParamEnum() 
        {
        pCurrentParameter = pFirstParameter;
        CurrentParamNumber = 0;
        return NumberParameters > 0;
        }

    virtual bool GotoNextParam() 
        {
        if ( CurrentParamNumber + 1 >= NumberParameters )
            {
            return false;
            }
        
        CurrentParamNumber++;
        pCurrentParameter = pFirstParameter + CurrentParamNumber;
        return true;
        }

    virtual unsigned short GetParamPipeFlags()
        {
            NDR64_PARAM_FLAGS *pParamFlags = (NDR64_PARAM_FLAGS *)&pCurrentParameter->Attributes;
            if ( !pParamFlags->IsPipe )
                return 0;

            unsigned short Flags = 0;

            if ( pParamFlags->IsIn )
                Flags |= NDR_IN_PIPE;
            if ( pParamFlags->IsOut )
                Flags |= NDR_OUT_PIPE;

            if ( pParamFlags->IsSimpleRef )
                Flags |= NDR_REF_PIPE;

            return Flags;
        }

    virtual PFORMAT_STRING GetParamTypeFormat() 
        {
            return (PFORMAT_STRING)pCurrentParameter->Type;
        }

    virtual char *GetParamArgument() 
        {
            return pStackTop + pCurrentParameter->StackOffset;
        }

    virtual void InitPipeStateWithType( PNDR_PIPE_MESSAGE pPipeMsg )
        {

        NDR64_PIPE_FORMAT*   pPipeFc = (NDR64_PIPE_FORMAT *) pPipeMsg->pTypeFormat;
        NDR_PIPE_STATE *pState   = & PipeDesc.RuntimeState;
        NDR64_PIPE_FLAGS *pPipeFlags = (NDR64_PIPE_FLAGS*)&pPipeFc->Flags;
        NDR64_RANGE_PIPE_FORMAT *pRangePipeFc = (NDR64_RANGE_PIPE_FORMAT*)pPipeFc;

        pState->LowChunkLimit = 0;
        pState->HighChunkLimit = NDR_DEFAULT_PIPE_HIGH_CHUNK_LIMIT;
        pState->ElemAlign = pPipeFc->Alignment;
        pState->ElemMemSize  = pPipeFc->MemorySize;
        pState->ElemWireSize = pPipeFc->BufferSize;

        if ( pPipeFlags->HasRange )
            {
            pState->LowChunkLimit  = pRangePipeFc->MinValue;
            pState->HighChunkLimit = pRangePipeFc->MaxValue;
            }

        pState->ElemPad     = WIRE_PAD( pState->ElemWireSize, pState->ElemAlign );
        pState->fBlockCopy  = pPipeFlags->BlockCopy; 
        }
    
    virtual void MarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                               uchar *pMemory,
                               unsigned long Elements )
        {

            unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
            
            NDR64_PIPE_FORMAT*   pPipeFc = (NDR64_PIPE_FORMAT *) pPipeMsg->pTypeFormat;
            while( Elements-- )
                {
                Ndr64TopLevelTypeMarshall( pPipeMsg->pStubMsg,
                                           pMemory,
                                           pPipeFc->Type );

                pMemory += ElemMemSize;
                }
        }
    
    virtual void UnmarshallType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements )
        {

            unsigned long ElemMemSize =  PipeDesc.RuntimeState.ElemMemSize;
            
            NDR64_PIPE_FORMAT*   pPipeFc = (NDR64_PIPE_FORMAT *) pPipeMsg->pTypeFormat;

            while( Elements-- )
                {
                Ndr64TopLevelTypeUnmarshall( pPipeMsg->pStubMsg,
                                             &pMemory,
                                             pPipeFc->Type,
                                             false );
                pMemory += ElemMemSize;
                }

        }
    
    virtual void BufferSizeType( PNDR_PIPE_MESSAGE pPipeMsg,
                                 uchar *pMemory,
                                 unsigned long Elements )
        { 
        
        unsigned long ElemMemSize = PipeDesc.RuntimeState.ElemMemSize;
        
        NDR64_PIPE_FORMAT*   pPipeFc = (NDR64_PIPE_FORMAT *) pPipeMsg->pTypeFormat;

        while( Elements-- )
            {
            Ndr64TopLevelTypeSize( pPipeMsg->pStubMsg,
                                   pMemory,
                                   pPipeFc->Type );

            pMemory += ElemMemSize;
            }

        }
    
    virtual void ConvertType( PNDR_PIPE_MESSAGE /* pPipeMsg */,
                              unsigned long /* Elements */ ) 
        {
        }

    virtual void BufferSizeChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg ) 
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        LENGTH_ALIGN( pStubMsg->BufferLength, sizeof(NDR64_UINT64)-1 );
        pStubMsg->BufferLength += sizeof(NDR64_UINT64);
    }

    virtual bool UnmarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                          ulong *pOut )
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        ALIGN( pStubMsg->Buffer, sizeof(NDR64_UINT64)-1);
        
        if ( 0 == REMAINING_BYTES() )
            {
            return false;
            }

        // transition: end of src

        if (REMAINING_BYTES() < sizeof(NDR64_UINT64))
            {
            // with packet sizes being a multiple of 8,
            // this cannot happen.

            NDR_ASSERT( 0, "Chunk counter split is not possible.");

            NdrpRaisePipeException( &PipeDesc,  RPC_S_INTERNAL_ERROR );
            return false;
            }
        
        NDR64_UINT64 Counter = *(NDR64_UINT64*)pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(NDR64_UINT64);
        
        *pOut = Ndr64pConvertTo2GB( Counter );
        return true;
    }

    virtual void MarshallChunkCounter( PNDR_PIPE_MESSAGE pPipeMsg, 
                                       ulong Counter )
    {
        PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
        ALIGN( pStubMsg->Buffer, sizeof(NDR64_UINT64)-1);
        
        Ndr64pConvertTo2GB( Counter );
        *(NDR64_UINT64*)pStubMsg->Buffer = (NDR64_UINT64)Counter;
        pStubMsg->Buffer += sizeof(NDR64_UINT64);
    }

    virtual void BufferSizeChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg ) 
       { 
       BufferSizeChunkCounter( pPipeMsg ); 
       }

    virtual void MarshallChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                           ulong Counter ) 
       { 
       PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
       ALIGN( pStubMsg->Buffer, sizeof(NDR64_UINT64)-1);
       
       Ndr64pConvertTo2GB( Counter );
       NDR64_UINT64 TailCounter = (NDR64_UINT64)-(NDR64_INT64)(NDR64_UINT64)Counter;
       *(NDR64_UINT64*)pStubMsg->Buffer = TailCounter;
       pStubMsg->Buffer += sizeof(NDR64_UINT64);

       }

    virtual bool VerifyChunkTailCounter( PNDR_PIPE_MESSAGE pPipeMsg,
                                         ulong HeaderCounter ) 
       { 
       PMIDL_STUB_MESSAGE pStubMsg = pPipeMsg->pStubMsg;
       ALIGN( pStubMsg->Buffer, sizeof(NDR64_UINT64)-1);

       if ( 0 == REMAINING_BYTES() )
           {
           return false;
           }

       // transition: end of src

       if (REMAINING_BYTES() < sizeof(NDR64_UINT64))
           {
           // with packet sizes being a multiple of 8,
           // this cannot happen.

           NDR_ASSERT( 0, "Chunk counter split is not possible.");

           NdrpRaisePipeException( &PipeDesc,  RPC_S_INTERNAL_ERROR );
           return false;
           }

       NDR64_UINT64 TailCounter = *(NDR64_UINT64*)pStubMsg->Buffer;
       pStubMsg->Buffer += sizeof(NDR64_UINT64);
       
       Ndr64pConvertTo2GB( HeaderCounter );
       NDR64_UINT64 TailCounterChk = (NDR64_UINT64)-(NDR64_INT64)(NDR64_UINT64)HeaderCounter;
       
       if ( TailCounterChk != TailCounter )
           {
           RpcRaiseException( RPC_X_INVALID_BOUND );
           }

       return true;
       }

    virtual bool HasChunkTailCounter() { return TRUE; }


};





void
NdrpPipesInitialize64(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR_ALLOCA_CONTEXT pAllocContext,
    PFORMAT_STRING      Params,
    char *              pStackTop,
    unsigned long       NumberParams
    )
{

    /* C wrapper to initialize the 32 pipe helper and call NdrPipesInitialize*/
    NDR_PIPE_HELPER64 *pPipeHelper =
        new( pAllocContext ) NDR_PIPE_HELPER64( pStubMsg,
                                                Params,
                                                pStackTop,
                                                NumberParams );
    NdrPipesInitialize( pStubMsg,
                        pPipeHelper,
                        pAllocContext );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\pickle64.cxx ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pickle64.cxx

Abstract:

    This module contains ndr64 related pickling ndr library routines.

Notes:

Author:

    Yong Qu     Nov, 1993

Revision History:


------------------------------------------------------------------------*/
#include "precomp.hxx"

#include <midles.h>
#include "endianp.h"

#include "picklep.hxx"

extern "C"
{
void  RPC_ENTRY
NdrpPicklingClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis );

void  RPC_ENTRY
Ndr64pPicklingClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis );
}

const SYNTAX_DISPATCH_TABLE SyncDcePicklingClient =
{
    NdrpClientInit,
    NdrpSizing,
    NdrpClientMarshal,
    NdrpClientUnMarshal,
    NdrpClientExceptionHandling,
    NdrpPicklingClientFinally
};

const SYNTAX_DISPATCH_TABLE SyncNdr64PicklingClient =
{
    Ndr64pClientInit,
    Ndr64pSizing,
    Ndr64pClientMarshal,
    Ndr64pClientUnMarshal,
    Ndr64pClientExceptionHandling,
    Ndr64pPicklingClientFinally
};


extern const MIDL_FORMAT_STRING __MIDLFormatString;

__inline 
void Ndr64pMesTypeInit( PMIDL_STUB_MESSAGE   pStubMsg,
                        NDR_PROC_CONTEXT   * pContext,
                        PMIDL_STUB_DESC      pStubDesc )
{                        

    // we need this for correlation cache.
    NdrpInitializeProcContext( pContext );
    pStubMsg->pContext = pContext;

    pStubMsg->fHasExtensions  = 1;
    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    pStubMsg->pCorrInfo = NULL;
}

#define NdrpSetupMesTypeCommon( pfnName, pfnDCE, pfnNDR64 ) \
                                                            \
    if ( pMesMsg->Operation == MES_ENCODE || pMesMsg->Operation == MES_DECODE )   \
        {                                                   \
        SyntaxType = XFER_SYNTAX_DCE;                       \
        pfnName = &pfnDCE;                                  \
        }                                                   \
    else                                                    \
        {                                                   \
        SyntaxType = XFER_SYNTAX_NDR64;                     \
        pfnName = &pfnNDR64;                                \
        }                                                   \
                                                            \
    for ( long i = 0; i < (long) pProxyInfo->nCount; i ++ ) \
        if ( NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) == SyntaxType )  \
            {                                               \
            pSyntaxInfo = &pProxyInfo->pSyntaxInfo[i];      \
            break;                                          \
            }                                               \
                                                            \
    if (NULL == pSyntaxInfo )                               \
        RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );   \
                                                            \
    if ( XFER_SYNTAX_DCE == SyntaxType )                    \
        {                                                   \
        ulong nFormatOffset = ArrTypeOffset[i][nTypeIndex]; \
        pTypeFormat = &pSyntaxInfo->TypeString[nFormatOffset];  \
        }                                                   \
    else                                                    \
        {                                                   \
        if ( SyntaxType == XFER_SYNTAX_NDR64 )              \
            Ndr64pMesTypeInit( &pMesMsg->StubMsg, &ProcContext, pProxyInfo->pStubDesc );    \
                                                            \
        pTypeFormat = (PFORMAT_STRING)(((const FormatInfoRef **) ArrTypeOffset)[i][nTypeIndex]);   \
        }                                                   \
                                                            \
    ProcContext.pSyntaxInfo = pSyntaxInfo;              


void
Ndr64pValidateMesHandle(
    PMIDL_ES_MESSAGE_EX  pMesMsgEx )
{
    RpcTryExcept
        {
        if ( pMesMsgEx == 0  ||  
             pMesMsgEx->Signature != MIDL_ES_SIGNATURE  ||
             ( pMesMsgEx->MesMsg.MesVersion != MIDL_NDR64_ES_VERSION &&
               pMesMsgEx->MesMsg.MesVersion != MIDL_ES_VERSION ) )
            RpcRaiseException( RPC_S_INVALID_ARG );
        }
    RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
        {
        RpcRaiseException( RPC_S_INVALID_ARG );
        }
    RpcEndExcept
}

RPC_STATUS
Ndr64pValidateMesHandleReturnStatus(
    PMIDL_ES_MESSAGE_EX  pMesMsgEx )
{
    RPC_STATUS  Status = RPC_S_OK;

    RpcTryExcept
        {
        if ( pMesMsgEx == 0  ||  pMesMsgEx->Signature != MIDL_NDR64_ES_SIGNATURE  ||
             pMesMsgEx->MesMsg.MesVersion != MIDL_NDR64_ES_VERSION )
            Status = RPC_S_INVALID_ARG;
        }
    RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
        {
        Status = RPC_S_INVALID_ARG;
        }
    RpcEndExcept

    return Status;
}


void
Ndr64pCommonTypeHeaderSize(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    // This check is to prevent a decoding handle from being used
    // for both encoding and sizing of types.

    if ( pMesMsg->Operation != MES_ENCODE_NDR64 )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( ! GET_COMMON_TYPE_HEADER_SIZED( pMesMsg ) )
        {
        pMesMsg->StubMsg.BufferLength += MES_NDR64_CTYPE_HEADER_SIZE;

        SET_COMMON_TYPE_HEADER_SIZED( pMesMsg );
        }
}


size_t RPC_ENTRY
Ndr64MesTypeAlignSize( 
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    const void __RPC_FAR *          pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = ( PMIDL_ES_MESSAGE )Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    size_t                      OldLength = pStubMsg->BufferLength;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;
    
    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (long)pStubMsg->BufferLength & 0xf )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" );


    // See if we need to size the common type header.

    Ndr64pCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );

    // Now the individual type object.

    pStubMsg->BufferLength += MES_NDR64_HEADER_SIZE;

    if ( NDR64_IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void __RPC_FAR * __RPC_FAR *)pObject;
        }

    (Ndr64SizeRoutinesTable[ NDR64_ROUTINE_INDEX(*pFormat) ])
                                        ( pStubMsg,
                                        (uchar __RPC_FAR *)pObject,
                                        pFormat );

   LENGTH_ALIGN( pStubMsg->BufferLength, 0xf );

   Ndr64pPicklingClientFinally( pStubMsg, NULL );   // object
   return( pStubMsg->BufferLength - OldLength );

    
}


// ndr64 entries.

size_t  RPC_ENTRY
NdrMesTypeAlignSize3(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    const unsigned long **          ArrTypeOffset,
    unsigned long                   nTypeIndex,
    const void __RPC_FAR *          pObject )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PFORMAT_STRING              pTypeFormat;
    MIDL_SYNTAX_INFO    *       pSyntaxInfo = NULL;
    PFNMESTYPEALIGNSIZE         pfnSize;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    SYNTAX_TYPE                 SyntaxType;
    NDR_PROC_CONTEXT            ProcContext;
    if ( (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE &&
         (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );
    
    NdrpSetupMesTypeCommon( pfnSize, NdrMesTypeAlignSize2, Ndr64MesTypeAlignSize );

    return 
    ( *pfnSize )( Handle, pPicklingInfo, pProxyInfo->pStubDesc, pTypeFormat, pObject );
}


// common type header for type pickling is longer than before:
//  if version is 1, the header size is 8,
//  if version is higher than 1, the header size is 24+2*sizeof(RPC_SYNTAX_IDENTIFIER)
//  starting 8 bytes is still the same as old one: 
//  <version:1><endian:1><header_size:2><endian info: 4>
//  addtional header: 
//  <reserved: 16> <transfer_syntax><iid>
//
size_t
Ndr64pCommonTypeHeaderMarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
/*++
    Returns the space used by the common header.
--*/
{
    if ( ! GET_COMMON_TYPE_HEADER_IN( pMesMsg ) )
        {
        PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

        if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
            RpcRaiseException( RPC_X_INVALID_BUFFER );
            
        MIDL_memset( pStubMsg->Buffer, 0xcc, MES_NDR64_CTYPE_HEADER_SIZE );

        *pStubMsg->Buffer++ = MIDL_NDR64_ES_VERSION;
        *pStubMsg->Buffer++ = NDR_LOCAL_ENDIAN;
        * PSHORT_CAST pStubMsg->Buffer = MES_NDR64_CTYPE_HEADER_SIZE;

        pStubMsg->Buffer += MES_CTYPE_HEADER_SIZE + 16 -2 ; // skip over reserved, make header size 64bytes

        RpcpMemoryCopy( pStubMsg->Buffer,
                    & NDR64_TRANSFER_SYNTAX,
                    sizeof(RPC_SYNTAX_IDENTIFIER) );

        pStubMsg->Buffer += sizeof( RPC_SYNTAX_IDENTIFIER );
        RpcpMemoryCopy( pStubMsg->Buffer ,
                    & pMesMsg->InterfaceId,
                    sizeof(RPC_SYNTAX_IDENTIFIER) + sizeof(long) );
        pStubMsg->Buffer += sizeof( RPC_SYNTAX_IDENTIFIER );


        SET_COMMON_TYPE_HEADER_IN( pMesMsg );
        return( MES_NDR64_CTYPE_HEADER_SIZE );
        }

    return( 0 );
}


void RPC_ENTRY
Ndr64MesTypeEncode( 
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    const void __RPC_FAR *          pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;
    uchar __RPC_FAR *           pBufferSaved, *pTypeHeader;
    size_t                      RequiredLen, CommonHeaderSize, LengthSaved;
    

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;
    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (LONG_PTR)pStubMsg->Buffer & 0xf )
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        

    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    RequiredLen = Ndr64MesTypeAlignSize( Handle,
                                       pxPicklingInfo, 
                                       pStubDesc,
                                       pFormat,
                                       pObject );

    NdrpAllocPicklingBuffer( pMesMsg, RequiredLen );

    pBufferSaved = pStubMsg->Buffer;
    LengthSaved  = RequiredLen;

    // See if we need to marshall the common type header

    CommonHeaderSize = Ndr64pCommonTypeHeaderMarshall( pMesMsg );

    // Marshall the header and the object.

    memset( pStubMsg->Buffer, 0, MES_NDR64_HEADER_SIZE );
    pStubMsg->Buffer += MES_NDR64_HEADER_SIZE;

    if ( NDR64_IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void __RPC_FAR * __RPC_FAR *)pObject;
        }

    RpcTryFinally
        {
        ALIGN( pStubMsg->Buffer, 0xf );
        (Ndr64MarshallRoutinesTable[ NDR64_ROUTINE_INDEX(*pFormat) ])
                                      ( pStubMsg,
                                      (uchar __RPC_FAR *)pObject,
                                      pFormat );

        // We adjust the buffer to the next align by 16 and
        // so, we tell the user that we've written out till next mod 16.


        // cleanup possible leaks before raising exception.
        }
    RpcFinally
        {
        Ndr64pPicklingClientFinally( pStubMsg, NULL );  //  object
        }
    RpcEndFinally

    ALIGN( pStubMsg->Buffer, 0xf );
    size_t WriteLength = (size_t)(pStubMsg->Buffer - pBufferSaved);

    // We always save the rounded up object length in the type header.

    *(unsigned long __RPC_FAR *)(pBufferSaved + CommonHeaderSize) =
                     WriteLength - CommonHeaderSize - MES_NDR64_HEADER_SIZE;

    if ( LengthSaved < WriteLength )
        {
        NDR_ASSERT( 0, "NdrMesTypeEncode: encode buffer overflow" );
        RpcRaiseException( RPC_S_INTERNAL_ERROR );
        }

    NdrpWritePicklingBuffer( pMesMsg, pBufferSaved, WriteLength );
    
    
}

void  RPC_ENTRY
NdrMesTypeEncode3(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,    
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    const unsigned long **          ArrTypeOffset,    
    unsigned long                   nTypeIndex,
    const void __RPC_FAR *          pObject )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PFORMAT_STRING              pTypeFormat;
    MIDL_SYNTAX_INFO    *       pSyntaxInfo = NULL;
    PFNMESTYPEENCODE            pfnEncode;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    SYNTAX_TYPE                 SyntaxType;
    NDR_PROC_CONTEXT            ProcContext;
    if ( (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE &&
         (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    NdrpSetupMesTypeCommon( pfnEncode, NdrMesTypeEncode2, Ndr64MesTypeEncode );

    ( *pfnEncode )( Handle, pPicklingInfo, pProxyInfo->pStubDesc, pTypeFormat, pObject );
}

// read the type header, and determine if the buffer is marshalled 
// using ndr or ndr64
// for future extension, we can allow other transfer syntaxes. 
void RPC_ENTRY
Ndr64pCommonTypeHeaderUnmarshall(
    PMIDL_ES_MESSAGE    pMesMsg
    )
{
    BOOL IsNewPickling = FALSE;

    if ( pMesMsg->Operation != MES_DECODE && 
         pMesMsg->Operation != MES_DECODE_NDR64 )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    if ( ! GET_COMMON_TYPE_HEADER_IN( pMesMsg ) )
        {
        PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;

        // read the common header first.
        NdrpReadPicklingBuffer( pMesMsg, MES_CTYPE_HEADER_SIZE );

        // Check the version number, endianness.

        if ( *pStubMsg->Buffer == MIDL_ES_VERSION )
            {
            IsNewPickling = FALSE;           
            pMesMsg->Operation = MES_DECODE;
            }
        else
            {
            IsNewPickling = TRUE;
            }

        if ( pStubMsg->Buffer[1] == NDR_LOCAL_ENDIAN )
            {
            // Read the note about endianess at NdrMesTypeDecode.
            //
            pMesMsg->AlienDataRep = NDR_LOCAL_DATA_REPRESENTATION;
            }
        else
            {
            NDR_ASSERT( pMesMsg->Operation != MES_DECODE_NDR64, 
                    "endian convertion is not supported in ndr64" );
            unsigned char temp = pStubMsg->Buffer[2];
            pStubMsg->Buffer[2] = pStubMsg->Buffer[3];
            pStubMsg->Buffer[3] = temp;

            pMesMsg->AlienDataRep = ( NDR_ASCII_CHAR       |     // chars
                                      pStubMsg->Buffer[1]  |     // endianness
                                      NDR_IEEE_FLOAT );          // float
            }

        pStubMsg->Buffer += MES_CTYPE_HEADER_SIZE;
        if ( IsNewPickling )
            {
            SYNTAX_TYPE SyntaxType;
            // read the remaining header.
            NdrpReadPicklingBuffer( pMesMsg, MES_NDR64_CTYPE_HEADER_SIZE - MES_CTYPE_HEADER_SIZE );
            pStubMsg->Buffer += 16;  // skip over Reserved;
            SyntaxType = NdrpGetSyntaxType( (RPC_SYNTAX_IDENTIFIER *)pStubMsg->Buffer );
            if ( SyntaxType == XFER_SYNTAX_DCE )
                {
                pMesMsg->Operation = MES_DECODE;
                }
            else if ( SyntaxType == XFER_SYNTAX_NDR64 )
                {
                pMesMsg->Operation = ( MIDL_ES_CODE )MES_DECODE_NDR64;
                }
            else 
                {
                RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );
                } 

            // skip over iid: we don't need it for now. might be used for verification.
            pStubMsg->Buffer += 2*sizeof( RPC_SYNTAX_IDENTIFIER );            
            }

        SET_COMMON_TYPE_HEADER_IN( pMesMsg );
        }

}

void RPC_ENTRY
Ndr64MesTypeDecode( 
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void __RPC_FAR *                pObject
    )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;
    uchar __RPC_FAR *   pBufferSaved, pTypeHeader;
    size_t              RequiredLen, CommonHeaderSize, LengthSaved;
    

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;
    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    if( (LONG_PTR)pStubMsg->Buffer & 0xf )
        RpcRaiseException( RPC_X_INVALID_BUFFER );

   
    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    NdrpReadPicklingBuffer( pMesMsg, MES_NDR64_HEADER_SIZE );

    RequiredLen = (size_t) *(unsigned long __RPC_FAR *)pStubMsg->Buffer;
    pStubMsg->Buffer += MES_NDR64_HEADER_SIZE;

    NdrpReadPicklingBuffer( pMesMsg, RequiredLen );

    void * pArg = pObject;

    if ( NDR64_IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        //
        pArg = *(void **)pArg;
        }

   RpcTryFinally
        {
    
        (Ndr64UnmarshallRoutinesTable[ NDR64_ROUTINE_INDEX( *pFormat )])
                            ( pStubMsg,
                              (uchar __RPC_FAR * __RPC_FAR *)&pArg,
                              pFormat,
                              FALSE );

        if ( NDR64_IS_POINTER_TYPE(*pFormat) )
            {
            // Don't drop the pointee, if it was allocated.

            *(void **)pObject = pArg;
            }

        if ( pStubMsg->pCorrInfo )
            Ndr64CorrelationPass( pStubMsg );

    // Next decoding needs to start at aligned to 16.
        ALIGN( pStubMsg->Buffer, 15 );
        }
    RpcFinally
        {   
        Ndr64pPicklingClientFinally( pStubMsg, NULL );  // object
        }
   RpcEndFinally        
}

void  RPC_ENTRY
NdrMesTypeDecode3(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pPicklingInfo,    
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    const unsigned long **          ArrTypeOffset,    
    unsigned long                   nTypeIndex,
    void __RPC_FAR *                pObject )
{
    size_t              RequiredLen;

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;
    uchar *             BufferSaved;
    PFNMESDECODE        pfnDecode;
    MIDL_SYNTAX_INFO *  pSyntaxInfo;
    PFORMAT_STRING      pTypeFormat;
    SYNTAX_TYPE         SyntaxType;
    NDR_PROC_CONTEXT    ProcContext;

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    Ndr64pCommonTypeHeaderUnmarshall( pMesMsg );

    NdrpSetupMesTypeCommon( pfnDecode, NdrMesTypeDecode2, Ndr64MesTypeDecode );

    (* pfnDecode )( Handle, pPicklingInfo, pProxyInfo->pStubDesc, pTypeFormat, pObject );
}


void  RPC_ENTRY
Ndr64MesTypeFree(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,
    const MIDL_STUB_DESC          * pStubDesc,
    PFORMAT_STRING                  pFormat,
    void __RPC_FAR *                pObject
    )
/*++

Routine description:

    Free the object.

Arguments:

    Handle      - a pickling handle,
    pStubDesc   - a pointer to the stub descriptor,
    pFormat     - a pointer to the format code describing the object type
    pObject     - a pointer to the object being freed.

Returns:

Note:

    The pickling header is included in the sizing.

--*/
{
    NDR_PROC_CONTEXT            ProcContext;
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NDR_ASSERT( pPicklingInfo->Flags.Oicf, "Oicf should always be on" )

    if ( ! pObject )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );

    if( (LONG_PTR)pStubMsg->Buffer & 0xf )
        RpcRaiseException( RPC_X_INVALID_BUFFER );


    // Now the individual type object.

    if ( NDR64_IS_POINTER_TYPE(*pFormat) )
        {
        // We have to dereference the pointer once.
        pObject = *(void __RPC_FAR * __RPC_FAR *)pObject;
        }

    (Ndr64FreeRoutinesTable[ NDR64_ROUTINE_INDEX(*pFormat) ])
                                        ( pStubMsg,
                                        (uchar __RPC_FAR *)pObject,
                                        pFormat );

    Ndr64pPicklingClientFinally( pStubMsg, NULL );  // object
}

void  RPC_ENTRY
NdrMesTypeFree3(
    handle_t                        Handle,
    const MIDL_TYPE_PICKLING_INFO * pxPicklingInfo,    
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    const unsigned long **          ArrTypeOffset,    
    unsigned long                   nTypeIndex,
    void __RPC_FAR *                pObject )
{
    PMIDL_ES_MESSAGE            pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE          pStubMsg = &pMesMsg->StubMsg;
    PMIDL_TYPE_PICKLING_INFOp   pPicklingInfo;
    PFNMESFREE                  pfnFree;
    MIDL_SYNTAX_INFO        *   pSyntaxInfo;
    PFORMAT_STRING              pTypeFormat;
    SYNTAX_TYPE                 SyntaxType;
    NDR_PROC_CONTEXT            ProcContext;


    pPicklingInfo = (PMIDL_TYPE_PICKLING_INFOp) pxPicklingInfo;

    NdrpSetupMesTypeCommon( pfnFree, NdrMesTypeFree2, Ndr64MesTypeFree );

    (*pfnFree)(Handle, pxPicklingInfo, pProxyInfo->pStubDesc, pTypeFormat, pObject );
}

void 
Ndr64pMesProcEncodeInit( PMIDL_ES_MESSAGE                 pMesMsg,
                         const MIDL_STUBLESS_PROXY_INFO * pProxyInfo,
                         unsigned long                    nProcNum,
                         MIDL_ES_CODE                     Operation,
                         NDR_PROC_CONTEXT   *             pContext,
                         uchar *                          StartofStack)
{
    PMIDL_STUB_DESC         pStubDesc = pProxyInfo->pStubDesc;
    SYNTAX_TYPE             syntaxType;
    BOOL                    fUseEncode, fIsSupported = FALSE;
    PMIDL_STUB_MESSAGE      pStubMsg = &pMesMsg->StubMsg;
    RPC_STATUS              res;

    // TODO: verify stub version.
   
    if ( Operation == MES_ENCODE )
        {
        syntaxType = XFER_SYNTAX_DCE;
        memcpy( &( (PMIDL_ES_MESSAGE_EX)pMesMsg )->TransferSyntax,
                &NDR_TRANSFER_SYNTAX ,
                sizeof( RPC_SYNTAX_IDENTIFIER ) );
        }
    else
        {
        syntaxType = XFER_SYNTAX_NDR64;
        memcpy( &( (PMIDL_ES_MESSAGE_EX)pMesMsg )->TransferSyntax,
                &NDR64_TRANSFER_SYNTAX ,
                sizeof( RPC_SYNTAX_IDENTIFIER ) );
        }

    Ndr64ClientInitializeContext( syntaxType, pProxyInfo, nProcNum, pContext, StartofStack );
       
    pStubMsg->pContext = pContext;
    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    
    // varify proc header
    if ( syntaxType == XFER_SYNTAX_DCE )
        {
        uchar InterpreterFlag = * ((uchar *)&pContext->NdrInfo.InterpreterFlags );
        fUseEncode = InterpreterFlag & ENCODE_IS_USED;
        memcpy( & (pContext->pfnInit), &SyncDcePicklingClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
        }
    else 
        {
        fUseEncode = ( ( (NDR64_PROC_FLAGS *) & pContext->Ndr64Header->Flags)->IsEncode );
        memcpy( & (pContext->pfnInit), &SyncNdr64PicklingClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
        }

    if (!fUseEncode )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );
}

CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrMesProcEncode3(
    PMIDL_ES_MESSAGE                pMesMsg,
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    unsigned long                   nProcNum,
    uchar *                         StartofStack )
{
    PMIDL_STUB_MESSAGE  pStubMsg = & pMesMsg->StubMsg;
    NDR_PROC_CONTEXT    ProcContext;
    unsigned long       ulAlignment;
    unsigned char *             BufferSaved;
    size_t                      WriteLength;
    CLIENT_CALL_RETURN  Ret;

    Ret.Simple = NULL;

    pMesMsg->ProcNumber = nProcNum;
    

        Ndr64pMesProcEncodeInit( pMesMsg, 
                       pProxyInfo, 
                       nProcNum,
                       pMesMsg->Operation, 
                       &ProcContext,
                       StartofStack );

    RpcTryFinally
        {
        ProcContext.pfnInit( pStubMsg, 
                             NULL );    // return value
                         
        ProcContext.pfnSizing( pStubMsg,
                            TRUE );

        if ( pMesMsg->Operation == MES_ENCODE )
            ulAlignment = 0x7;
        else
            ulAlignment = 0xf;
        
        // we are not changing the proc header, but we need to overestimate because
        // proc header is marshalled first.
        LENGTH_ALIGN( pStubMsg->BufferLength, ulAlignment );
    
        pStubMsg->BufferLength += MES_PROC_HEADER_SIZE ;
    
        LENGTH_ALIGN( pStubMsg->BufferLength, ulAlignment );

        size_t  LengthSaved;

        NdrpAllocPicklingBuffer( pMesMsg, pStubMsg->BufferLength );
        BufferSaved = pStubMsg->Buffer;
        LengthSaved = pStubMsg->BufferLength;

        NDR_ASSERT( ( (ULONG_PTR)pStubMsg->Buffer & ulAlignment ) == 0, "pickling buffer is not aligned" );

        NdrpProcHeaderMarshallAll( pMesMsg );

        ALIGN( pStubMsg->Buffer, ulAlignment );

        ProcContext.pfnMarshal( pStubMsg,
                            FALSE );

        ALIGN( pStubMsg->Buffer, ulAlignment );

        WriteLength = (size_t)(pStubMsg->Buffer - BufferSaved);
        * (unsigned long __RPC_FAR *)
            ( BufferSaved + MES_PROC_HEADER_SIZE - 4) =
                                WriteLength - MES_PROC_HEADER_SIZE;

        if ( LengthSaved < WriteLength )
            {
            NDR_ASSERT( 0, "NdrMesProcEncodeDecode: encode buffer overflow" );
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            }

        NdrpWritePicklingBuffer( pMesMsg, BufferSaved, WriteLength );
        }
    RpcFinally
        {
        ( *ProcContext.pfnClientFinally)( pStubMsg, NULL ); // not object
        }
   RpcEndFinally

    return Ret;
}


// both encode and decode acts like the client side.
void
Ndr64pMesProcDecodeInit( PMIDL_ES_MESSAGE                   pMesMsg,
                         const MIDL_STUBLESS_PROXY_INFO *   pProxyInfo,
                         SYNTAX_TYPE                        SyntaxType,
                         unsigned long                      nProcNum,
                         NDR_PROC_CONTEXT *                 pContext,
                         uchar *                            StartofStack )
{
    RPC_STATUS            res;
    PMIDL_STUB_MESSAGE    pStubMsg = &pMesMsg->StubMsg;
    unsigned long         nFormatOffset;
    PMIDL_STUB_DESC       pStubDesc = pProxyInfo->pStubDesc;
    BOOL                  fUseDecode;

    // REVIEW: Calling the "Client" init for decode seems weird but it does
    //         the right thing and NdrServerSetupMultipleTransferSyntax assumes
    //         ndr64.

	Ndr64ClientInitializeContext(
	        SyntaxType,
            pProxyInfo,
            nProcNum,
            pContext,
            StartofStack );

    pStubMsg->pContext = pContext;
    pStubMsg->StubDesc = pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    
    NdrpDataBufferInit( pMesMsg, pContext->pProcFormat );
    
    if ( SyntaxType == XFER_SYNTAX_DCE )
        {
        uchar InterpreterFlag = * ((uchar *)&pContext->NdrInfo.InterpreterFlags );
        fUseDecode = InterpreterFlag & DECODE_IS_USED;
        memcpy( & (pContext->pfnInit), &SyncDcePicklingClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
        }
    else 
        {
        fUseDecode = ( ( (NDR64_PROC_FLAGS *) & pContext->Ndr64Header->Flags)->IsDecode );
        memcpy( & (pContext->pfnInit), &SyncNdr64PicklingClient, sizeof( SYNTAX_DISPATCH_TABLE ) );
        }

    if (!fUseDecode )
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );        
}


CLIENT_CALL_RETURN RPC_VAR_ENTRY
NdrMesProcDecode3(
    PMIDL_ES_MESSAGE                pMesMsg,
    const MIDL_STUBLESS_PROXY_INFO *pProxyInfo,
    unsigned long                   nProcNum,
    uchar *                         StartofStack,
    void *                          pReturnValue )
{
    CLIENT_CALL_RETURN      RetVal;
    NDR_PROC_CONTEXT        ProcContext;
    SYNTAX_TYPE             SyntaxType;
    PMIDL_STUB_MESSAGE      pStubMsg = & pMesMsg->StubMsg;
    NDR64_PROC_FLAGS           *ProcFlags;
    unsigned long           ulAlign;
    long                        HasComplexReturn;

    RetVal.Simple = NULL;
    if (NULL == pReturnValue )
        pReturnValue = &RetVal;
    
    if ( GET_MES_HEADER_PEEKED( pMesMsg ) )
        {
        // This makes it possible to encode/decode several procs one after
        // another with the same pickling handle (using the same buffer).

        CLEAR_MES_HEADER_PEEKED( pMesMsg );
        }
    else
        NdrpProcHeaderUnmarshallAll( pMesMsg );

    SyntaxType = NdrpGetSyntaxType( &((PMIDL_ES_MESSAGE_EX)pMesMsg)->TransferSyntax );

    if ( SyntaxType ==  XFER_SYNTAX_DCE )
        {
        pMesMsg->Operation = MES_DECODE;
        ulAlign = 0x7;
        }
    else if ( SyntaxType == XFER_SYNTAX_NDR64 )
        {
        pMesMsg->Operation = ( MIDL_ES_CODE )MES_DECODE_NDR64;
        ulAlign = 0xf;
        }
    else
        RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );

    if ( (LONG_PTR)pStubMsg->BufferStart & ulAlign )
        RpcRaiseException( RPC_X_INVALID_BUFFER );
        
    Ndr64pMesProcDecodeInit( pMesMsg,
                             pProxyInfo,
                             SyntaxType,
                             nProcNum,
                             &ProcContext,
                             StartofStack );

    RpcTryFinally
        {

        ProcContext.pfnInit( pStubMsg, 
                             NULL );    // return value
                         
        ALIGN( pStubMsg->Buffer, ulAlign );
    
        ProcContext.pfnUnMarshal( pStubMsg,
                                  ProcContext.HasComplexReturn
                                        ? &pReturnValue
                                        : pReturnValue );

    // prepare for new decoding.
        ALIGN( pStubMsg->Buffer, ulAlign );

        }
   RpcFinally
        {
    
        ( *ProcContext.pfnClientFinally)( pStubMsg, NULL );  // object
        }
   RpcEndFinally

   return *(CLIENT_CALL_RETURN *)pReturnValue;
            
}

CLIENT_CALL_RETURN  RPC_VAR_ENTRY
NdrMesProcEncodeDecode3(
    handle_t                        Handle,
    const MIDL_STUBLESS_PROXY_INFO* pProxyInfo,
    unsigned long                   nProcNum,
    void                            *pReturnValue,    
    ... )
{
    BOOL                fMoreParams;
    PFORMAT_STRING      pProcFormat;
    void __RPC_FAR *    pArg;
    va_list             ArgList;
    unsigned char *     BufferSaved;
    size_t              WriteLength;
    uchar *             StartofStack;

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );
    PMIDL_ES_MESSAGE    pMesMsg  = (PMIDL_ES_MESSAGE) Handle;

    INIT_ARG( ArgList, pReturnValue );
    GET_FIRST_IN_ARG(ArgList);
    StartofStack = (uchar *)GET_STACK_START(ArgList);

    if ( pMesMsg->Operation == MES_ENCODE ||
         pMesMsg->Operation == MES_ENCODE_NDR64 )
        return NdrMesProcEncode3( (PMIDL_ES_MESSAGE)Handle, pProxyInfo, nProcNum, StartofStack );
    else
        return NdrMesProcDecode3( (PMIDL_ES_MESSAGE)Handle, pProxyInfo, nProcNum, StartofStack, pReturnValue );
  

}


void  RPC_ENTRY
NdrpPicklingClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis )
{
    NDR_PROC_CONTEXT    *   pContext = (NDR_PROC_CONTEXT *) pStubMsg->pContext;
    PMIDL_STUB_DESC     pStubDesc = pStubMsg->StubDesc;

    NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

    NdrCorrelationFree( pStubMsg );

    NdrpAllocaDestroy( & pContext->AllocateContext );

}

void  RPC_ENTRY
Ndr64pPicklingClientFinally( PMIDL_STUB_MESSAGE pStubMsg,
                   void *  pThis )
{
    NdrFullPointerXlatFree(pStubMsg->FullPtrXlatTables);

    NdrpAllocaDestroy( & ( (NDR_PROC_CONTEXT *)pStubMsg->pContext )->AllocateContext );
}


// =======================================================================
//
//   Ready to use AlignSize routines for simple types
//
// =======================================================================
void ValidateMesSimpleTypeAll( const MIDL_STUBLESS_PROXY_INFO * pProxyInfo,
                               MIDL_ES_CODE Operation )
{
    ulong i;
    SYNTAX_TYPE SyntaxType;
    
    if ( Operation == MES_ENCODE ||
         Operation == MES_DECODE )
        SyntaxType = XFER_SYNTAX_DCE;
    else
        SyntaxType = XFER_SYNTAX_NDR64;

    for ( i = 0; i < ( ulong )pProxyInfo->nCount; i++ )
        {
        if ( NdrpGetSyntaxType( &pProxyInfo->pSyntaxInfo[i].TransferSyntax ) == SyntaxType )
            break;
        }

    // Raise exception if we didn't find the supported syntax in proxyinfo.
    if ( i >= pProxyInfo->nCount )  
        RpcRaiseException( RPC_S_UNSUPPORTED_TRANS_SYN );
}


size_t  RPC_ENTRY
NdrMesSimpleTypeAlignSizeAll(
    handle_t Handle,
    const MIDL_STUBLESS_PROXY_INFO *  pProxyInfo
    )
/*++
    Size is always 8 bytes for data and there is no header here per data.
    However, the common header gets included for the first object.
--*/
{
    if ( (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE &&
         (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );
         
    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE) Handle)->StubMsg;

    ValidateMesSimpleTypeAll( pProxyInfo, ((PMIDL_ES_MESSAGE)Handle)->Operation );
    
    unsigned long OldLength = pStubMsg->BufferLength;

    if ( ((PMIDL_ES_MESSAGE)Handle)->Operation == MES_ENCODE )
        {
        if( (long)( pStubMsg->BufferLength & 0x7 ) )
            RpcRaiseException( RPC_X_INVALID_BUFFER );
            
        NdrpCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );
        pStubMsg->BufferLength += 8;
        }
    else
        {
        if( (long)( pStubMsg->BufferLength & 0xf ) )
            RpcRaiseException( RPC_X_INVALID_BUFFER );
            
        Ndr64pCommonTypeHeaderSize( (PMIDL_ES_MESSAGE)Handle );
        LENGTH_ALIGN( pStubMsg->BufferLength, 0xf );
        pStubMsg->BufferLength += 16;
        }

    return( (size_t)(pStubMsg->BufferLength - OldLength) );
}


// =======================================================================
//
//   Ready to use Encode routines for simple types
//
// =======================================================================

void  RPC_ENTRY
NdrMesSimpleTypeEncodeAll(
    handle_t                Handle,
    const MIDL_STUBLESS_PROXY_INFO *  pProxyInfo,
    const void __RPC_FAR *  pData,
    short                   Size )
/*++
    Marshall a simple type entity. There is no header here per data.
    However, the common header gets included for the first object.
--*/
{
    if ( (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE &&
         (( PMIDL_ES_MESSAGE)Handle )->Operation != MES_ENCODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &pMesMsg->StubMsg;
    PMIDL_STUB_DESC     pStubDesc = pProxyInfo->pStubDesc;
    pStubMsg->pfnAllocate = pStubDesc->pfnAllocate;
    pStubMsg->pfnFree     = pStubDesc->pfnFree;
    unsigned long       ulAlignment;
    size_t RequiredLen;

    // Size and allocate the buffer.
    // The req len includes: (the common header) and the data

    // Take the pointer alignment to come up with the right size.

    pStubMsg->BufferLength = 0xf & PtrToUlong( pStubMsg->Buffer );

    RequiredLen = NdrMesSimpleTypeAlignSizeAll( Handle, pProxyInfo );
    NdrpAllocPicklingBuffer( pMesMsg, RequiredLen );

    // See if we need to marshall the common type header

    uchar __RPC_FAR *   pBufferSaved = pStubMsg->Buffer;

    if ( pMesMsg->Operation == MES_ENCODE )
        {
        NdrpCommonTypeHeaderMarshall( pMesMsg );
        ulAlignment = 0x7;
        }
    else if ( pMesMsg->Operation == MES_ENCODE_NDR64 )
        {
        Ndr64pCommonTypeHeaderMarshall( pMesMsg );
        ulAlignment = 0xf;
        }
    else
        RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    ALIGN( pStubMsg->Buffer, ulAlignment );
    
    switch ( Size )
        {
        case 1:
            * PCHAR_CAST pStubMsg->Buffer  = * PCHAR_CAST pData;
            break;

        case 2:
            * PSHORT_CAST pStubMsg->Buffer = * PSHORT_CAST pData;
            break;

        case 4:
            * PLONG_CAST pStubMsg->Buffer  = * PLONG_CAST pData;
            break;

        case 8:
            * PHYPER_CAST pStubMsg->Buffer = * PHYPER_CAST pData;
            break;

        default:
            NDR_ASSERT( 0, " Size generation problem" );
        }

    pStubMsg->Buffer += ulAlignment+1;

    NdrpWritePicklingBuffer( pMesMsg, pBufferSaved, RequiredLen );
}



// =======================================================================
//
//   Ready to use Decode routines for simple types
//
// =======================================================================

void  RPC_ENTRY
NdrMesSimpleTypeDecodeAll(
    handle_t Handle,
    const MIDL_STUBLESS_PROXY_INFO *  pProxyInfo,
    void  __RPC_FAR *  pData,
    short    FormatChar )
/*++
    Does not include the header for the data.
    However, the common header gets included for the first object.

    Note. Endianness and other conversions for decode.
    This has been deemed as not worthy doing in the Daytona time frame.
    However, to be able to add it in future without backward compatibility
    problems, we have the last argument to be the format character as
    opposed to the size.
    This makes it possible to call NdrSimpleTypeConvert, if needed.
    
    Note that the compiler uses the 32bit tokens for this since this routine 
    is common to both formats.
--*/
{
    if ( ( (PMIDL_ES_MESSAGE)Handle )->Operation != MES_DECODE &&
         ( (PMIDL_ES_MESSAGE)Handle )->Operation != MES_DECODE_NDR64 )
         RpcRaiseException( RPC_X_INVALID_ES_ACTION );

    Ndr64pValidateMesHandle( (PMIDL_ES_MESSAGE_EX)Handle );

    PMIDL_ES_MESSAGE    pMesMsg = (PMIDL_ES_MESSAGE) Handle;
    PMIDL_STUB_MESSAGE  pStubMsg = &((PMIDL_ES_MESSAGE)Handle)->StubMsg;
    uchar *             BufferSaved;
    unsigned long       ulAlignment;

    // See if we need to unmarshall the common type header.
    Ndr64pCommonTypeHeaderUnmarshall( pMesMsg );
    

    // Now the data.

    if ( pMesMsg->Operation == MES_DECODE )
        {
        NdrpReadPicklingBuffer( (PMIDL_ES_MESSAGE) Handle, 8);
        ulAlignment = 0x7;
        }
    else
        {
        NdrpReadPicklingBuffer( (PMIDL_ES_MESSAGE) Handle, 16);
        ulAlignment = 0xf;
        }

    NDR_ASSERT( ( (ULONG_PTR)pStubMsg->Buffer & ulAlignment ) == 0, "invalid buffer alignment in simple type pickling" );

    ValidateMesSimpleTypeAll( pProxyInfo, ((PMIDL_ES_MESSAGE)Handle)->Operation );
    if ( pMesMsg->AlienDataRep != NDR_LOCAL_DATA_REPRESENTATION )
        {
        pStubMsg->RpcMsg->DataRepresentation = pMesMsg->AlienDataRep;

        BufferSaved = pStubMsg->Buffer;
        NdrSimpleTypeConvert( pStubMsg, (unsigned char)FormatChar );
        pStubMsg->Buffer = BufferSaved;
        }

    switch ( FormatChar )
        {
        case FC_BYTE:
        case FC_CHAR:
        case FC_SMALL:
        case FC_USMALL:
            * PCHAR_CAST  pData = * PCHAR_CAST pStubMsg->Buffer;
            break;

        case FC_WCHAR:
        case FC_SHORT:
        case FC_USHORT:
            * PSHORT_CAST pData = * PSHORT_CAST pStubMsg->Buffer;
            break;

        case FC_LONG:
        case FC_ULONG:
        case FC_FLOAT:
        case FC_ENUM32:
        case FC_ERROR_STATUS_T:
            * PLONG_CAST  pData = * PLONG_CAST pStubMsg->Buffer;
            break;

        case FC_HYPER:
        case FC_DOUBLE:
            * PHYPER_CAST pData = * PHYPER_CAST pStubMsg->Buffer;
            break;

#if defined(__RPC_WIN64__)
        case FC_INT3264:
            if (pMesMsg->Operation == MES_DECODE )           
                *((INT64 *)pData)  = *((long *) pStubMsg->Buffer);
            else
                *((INT64 *)pData)  = *((INT64 *) pStubMsg->Buffer);            
            break;

        case FC_UINT3264:
            if (pMesMsg->Operation == MES_DECODE )           
                *((UINT64 *)pData) = *((ulong *)pStubMsg->Buffer);
            else
                *((UINT64 *)pData) = *((UINT64 *)pStubMsg->Buffer);
            break;
#endif

        default:
            NDR_ASSERT( 0, " Size generation problem for simple types" );
        }

    pStubMsg->Buffer += ulAlignment+1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\pointer.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    pointer.cxx

Abstract :

    This file contains the routines for handling pointers and pointer
    layouts.
    
Author :

    Mike Zoran  mzoran   January 2000.

Revision History :

  ---------------------------------------------------------------------*/
#include "precomp.hxx"

#if !defined(DBG)
// Optimize for time to force inlining.
#pragma optimize("gt", on)

#endif

typedef enum 
{
    NDR64_CORRELATION_NONE=0,
    NDR64_CORRELATION_MEMORY=1,
    NDR64_CORRELATION_BUFFER=2
} NDR64_CORRELATION_TYPE;

template<class Function>
static __forceinline void
Ndr64pProcessPointerLayout( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pLayoutFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer,
    const NDR64_CORRELATION_TYPE CorrType,
    Function            func )
/*++

Routine Description :

    Marshalls an array's or a structure's embedded pointers.

Arguments :

    pStubMsg        - Pointer to the stub message.
    pFormat         - The format string pointer layout.
    ArrayIterations - Numbers of iterations for variable sized arrays.
    pMemory         - Pointer to the structure or array whose embedded pointers 
                      are being marshalled.
    pBuffer         - Pointer to the buffer for the structure or arrays
    CorrType        - Determines how to set pCorrMemory.
    func            - Function to call to do the processing 
 

Return :

    Format string pointer after the pointer layout.

 --*/
{

    PFORMAT_STRING pFormat = (PFORMAT_STRING)pLayoutFormat;

    for (;;) 
        {

        const NDR64_REPEAT_FORMAT *pRepeatFormat;
        NDR64_UINT32 Iterations;

        switch( *pFormat )
            {

            case FC64_NO_REPEAT:
                {
                const NDR64_NO_REPEAT_FORMAT                *pNoRepeatHeader  = 
                    (NDR64_NO_REPEAT_FORMAT*)pFormat;
                
                const NDR64_POINTER_INSTANCE_HEADER_FORMAT  *pPointerInstance =
                    (NDR64_POINTER_INSTANCE_HEADER_FORMAT   *)(pNoRepeatHeader + 1);
                
                const NDR64_POINTER_FORMAT           *pPointerFormat = 
                    (NDR64_POINTER_FORMAT*)(pPointerInstance + 1);

                uchar *pMemPtr = pMemory + pPointerInstance->Offset;
                uchar *pBufPtr = pBuffer + pPointerInstance->Offset;
                
                func( pStubMsg,
                      pMemPtr,
                      pBufPtr ,
                      pPointerFormat );

                pFormat += sizeof(NDR64_NO_REPEAT_FORMAT) + 
                           sizeof(NDR64_POINTER_INSTANCE_HEADER_FORMAT) +
                           sizeof(NDR64_POINTER_FORMAT);

                break;
                }
            
            case FC64_FIXED_REPEAT:
                Iterations = ((NDR64_FIXED_REPEAT_FORMAT*)pFormat)->Iterations;
                pRepeatFormat = (NDR64_REPEAT_FORMAT*)pFormat;
                pFormat += sizeof(NDR64_FIXED_REPEAT_FORMAT);
                goto RepeatCommon;

            case FC64_VARIABLE_REPEAT:
                Iterations = ArrayIterations;
                pRepeatFormat = (NDR64_REPEAT_FORMAT*)pFormat;
                pFormat += sizeof(NDR64_REPEAT_FORMAT);
                // Fall through to Repeat Common
RepeatCommon:
                {

                uchar *pArrayMemory = pMemory + pRepeatFormat->OffsetToArray;
                uchar *pArrayBuffer = pBuffer + pRepeatFormat->OffsetToArray;
                PFORMAT_STRING pFormatSave = pFormat;

                uchar *pCorrMemorySave;
                if ( CorrType ) 
                    pCorrMemorySave = pStubMsg->pCorrMemory;

                    {
                    // Loop over the array elements
                    for( ; Iterations; 
                         Iterations--,
                         pArrayMemory += pRepeatFormat->Increment,
                         pArrayBuffer += pRepeatFormat->Increment)
                        {

                        pFormat = pFormatSave;

                        if ( CorrType ) 
                            {
                            if ( CorrType == NDR64_CORRELATION_MEMORY ) 
                                {
                                if (pRepeatFormat->Flags.SetCorrMark)
                                    pStubMsg->pCorrMemory = pArrayMemory;                      
                                }
                            else 
                                {
                                if (pRepeatFormat->Flags.SetCorrMark)
                                    pStubMsg->pCorrMemory = pArrayBuffer;                      
                                }
                            }

                        // Loop over the pointers per element
                        for ( NDR64_UINT32 Pointers = pRepeatFormat->NumberOfPointers;
                              Pointers; Pointers-- ) 
                            {

                            const NDR64_POINTER_INSTANCE_HEADER_FORMAT  *pPointerInstance =
                                  (NDR64_POINTER_INSTANCE_HEADER_FORMAT   *)pFormat;
                            const NDR64_POINTER_FORMAT           *pPointerFormat = 
                                  (NDR64_POINTER_FORMAT*)(pPointerInstance + 1);

                            uchar *pMemPtr = pArrayMemory + pPointerInstance->Offset;
                            uchar *pBufPtr = pArrayBuffer + pPointerInstance->Offset;

                            func( pStubMsg,
                                  pMemPtr,
                                  pBufPtr,
                                  pPointerFormat );

                            pFormat += sizeof(NDR64_POINTER_INSTANCE_HEADER_FORMAT) +
                                       sizeof(NDR64_POINTER_FORMAT);
                            }
                        }
                    
                    }

                if ( CorrType ) 
                    pStubMsg->pCorrMemory = pCorrMemorySave;
                
                }
            
            case FC64_END:

                return;

            default :
                NDR_ASSERT(0,"Ndr64pProcessPointerLayout : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
        
            } // switch
        }    
}

static __forceinline void 
Ndr64pPointerLayoutMarshallCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

    Ndr64pPointerMarshall
        ( pStubMsg,
          (NDR64_PTR_WIRE_TYPE*)pBufPtr,
          *(uchar**)pMemPtr,
          (PFORMAT_STRING)pFormat );        
}


void
Ndr64pPointerLayoutMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer )
{

    POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pMemory,
        pBuffer,
        NDR64_CORRELATION_MEMORY,
        Ndr64pPointerLayoutMarshallCallback);

}

static __forceinline void 
Ndr64pPointerLayoutUnmarshallCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

   Ndr64pPointerUnmarshall( 
       pStubMsg,
       *(NDR64_PTR_WIRE_TYPE*)pBufPtr,
       (uchar **)pMemPtr,
       *(uchar**)pMemPtr,
       pFormat );

    // Need to copy the value written to the memory pointer back to 
    // the buffer pointer since the buffer will be block copied to the memory. 
    *(uchar **)pBufPtr = *(uchar **)pMemPtr; 
}

void
Ndr64pPointerLayoutUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer ) 
{

    POINTER_BUFFER_SWAP_CONTEXT SwapContext( pStubMsg );

    uchar *pBufferSave = 0;

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, pMemory );

    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pMemory,
        pBuffer,
        NDR64_CORRELATION_BUFFER,
        Ndr64pPointerLayoutUnmarshallCallback);

}

static __forceinline void 
Ndr64pPointerLayoutMemorySizeCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

    // Discard the pMemPtr
    Ndr64pPointerMemorySize( 
        pStubMsg,
        (NDR64_PTR_WIRE_TYPE*)pBufPtr,
        pFormat );

}

void
Ndr64pPointerLayoutMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pBuffer )
{

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_MEMSIZE_SWAP_CONTEXT SwapContext( pStubMsg );

    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pBuffer,
        pBuffer,
        NDR64_CORRELATION_NONE,
        Ndr64pPointerLayoutMemorySizeCallback );

}

static __forceinline void 
Ndr64pPointerLayoutBufferSizeCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

    // Discard the BufferPointer
    Ndr64pPointerBufferSize( 
        pStubMsg,
        *(uchar**)pMemPtr,
        pFormat );

}


void 
Ndr64pPointerLayoutBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory )
{

    if ( pStubMsg->IgnoreEmbeddedPointers )
        return;

    POINTER_BUFFERLENGTH_SWAP_CONTEXT SwapContext( pStubMsg );

    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pMemory,
        pMemory,
        NDR64_CORRELATION_MEMORY,
        Ndr64pPointerLayoutBufferSizeCallback );

}

static __forceinline void 
Ndr64pPointerLayoutFreeCallback(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar*              pMemPtr,
    uchar*              pBufPtr,
    PNDR64_FORMAT       pFormat )
{

    Ndr64PointerFree( 
        pStubMsg,
        *(uchar**)pMemPtr,
        pFormat );

}


void 
Ndr64pPointerLayoutFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory )

{
    Ndr64pProcessPointerLayout(
        pStubMsg,
        pFormat,
        ArrayIterations,
        pMemory,
        pMemory,
        NDR64_CORRELATION_MEMORY,
        Ndr64pPointerLayoutFreeCallback );
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\srvcall.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    srvcall.c

Abstract :

    This file contains the single call Ndr64 routine for the server side.

Author :

    David Kays    dkays    October 1993.

Revision History :

    brucemc     11/15/93    Added struct by value support, corrected varargs
                            use.
    brucemc     12/20/93    Binding handle support.
    brucemc     12/22/93    Reworked argument accessing method.
    ryszardk    3/12/94     Handle optimization and fixes.

  ---------------------------------------------------------------------*/

#include "precomp.hxx"

#define CINTERFACE
#define USE_STUBLESS_PROXY

#include "ndrole.h"
#include "rpcproxy.h"

#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"

#include <stdarg.h>


#pragma code_seg(".ndr64")


long RPC_ENTRY
Ndr64StubWorker(
    IRpcStubBuffer *     pThis,
    IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE         pRpcMsg,
    MIDL_SERVER_INFO   * pServerInfo,
    const SERVER_ROUTINE *     DispatchTable,
    MIDL_SYNTAX_INFO *   pSyntaxInfo,  
    ulong *              pdwStubPhase
    )
/*++

Routine Description :

    Server Interpreter entry point for object RPC procs.  Also called by
    Ndr64ServerCall, the entry point for regular RPC procs.

Arguments :

    pThis           - Object proc's 'this' pointer, 0 for non-object procs.
    pChannel        - Object proc's Channel Buffer, 0 for non-object procs.
    pRpcMsg         - The RPC message.
    pdwStubPhase    - Used to track the current interpreter's activity.

Return :

    Status of S_OK.

--*/
{

    PMIDL_STUB_DESC         pStubDesc;
    ushort                  ProcNum;

    long                    FormatOffset;
    PFORMAT_STRING          pFormat;
    PFORMAT_STRING          pFormatParam;

    ulong                   StackSize;

    MIDL_STUB_MESSAGE       StubMsg;

    uchar *                 pArg;
    uchar **                ppArg;

    NDR64_PROC_FLAGS    *   pNdr64Flags;
    long                    NumberParams;

    BOOL                    HasExplicitHandle;
    BOOL                    fBadStubDataException = FALSE;
    long                    n;

    boolean                 NotifyAppInvoked = FALSE;
    long                    ret;
    NDR_PROC_CONTEXT        ProcContext;
    NDR64_PROC_FORMAT   *   pHeader = NULL;
    NDR64_PARAM_FLAGS   *       pParamFlags;
    NDR64_BIND_AND_NOTIFY_EXTENSION * pHeaderExts = NULL;
    MIDL_STUB_MESSAGE *     pStubMsg = &StubMsg;    

    //
    // In the case of a context handle, the server side manager function has
    // to be called with NDRSContextValue(ctxthandle). But then we may need to
    // marshall the handle, so NDRSContextValue(ctxthandle) is put in the
    // argument buffer and the handle itself is stored in the following array.
    // When marshalling a context handle, we marshall from this array.
    //
    NDR_SCONTEXT            CtxtHndl[MAX_CONTEXT_HNDL_NUMBER];

    ProcNum = (ushort) pRpcMsg->ProcNum;

    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );


    // setup SyntaxInfo of selected transfer syntax. 
    NdrServerSetupNDR64TransferSyntax( ProcNum, pSyntaxInfo, &ProcContext );
    StubMsg.pContext       = &ProcContext;
    
                                               
    pStubDesc = pServerInfo->pStubDesc;

    pFormat = ProcContext.pProcFormat;

    pHeader = (NDR64_PROC_FORMAT *) pFormat;
    pNdr64Flags = (NDR64_PROC_FLAGS *) & (pHeader->Flags );
    HasExplicitHandle = !NDR64MAPHANDLETYPE( NDR64GETHANDLETYPE ( pNdr64Flags ) );
    
    StackSize = pHeader->StackSize;

    //
    // Yes, do this here outside of our RpcTryFinally block.  If we
    // can't allocate the arg buffer there's nothing more to do, so
    // raise an exception and return control to the RPC runtime.
    //
    // Alloca throws an exception on an error.
    
    uchar *pArgBuffer = (uchar*)NdrpAlloca(&ProcContext.AllocateContext, StackSize);
    ProcContext.StartofStack = pArgBuffer;

    //
    // Zero out the arg buffer.  We must do this so that parameters
    // are properly zeroed before we start unmarshalling.  If we catch
    // an exception before finishing the unmarshalling we can not leave
    // parameters in an unitialized state since we have to do a freeing
    // pass.
    //
    MIDL_memset( pArgBuffer,
                 0,
                 StackSize );

    if ( pNdr64Flags->HasOtherExtensions )
        pHeaderExts = (NDR64_BIND_AND_NOTIFY_EXTENSION *) (pFormat + sizeof( NDR64_PROC_FORMAT ) );

    if ( HasExplicitHandle )
    {
        //
        // For a handle_t parameter we must pass the handle field of
        // the RPC message to the server manager.
        //
        NDR_ASSERT( pHeaderExts, "NULL extension header" );
        if ( pHeaderExts->Binding.HandleType == FC64_BIND_PRIMITIVE )
        {
            pArg = pArgBuffer + pHeaderExts->Binding.StackOffset;

            if ( NDR64_IS_HANDLE_PTR( pHeaderExts->Binding.Flags ) )
                pArg = *((uchar **)pArg);

            *((handle_t *)pArg) = pRpcMsg->Handle;
        }

    }

    //
    // Get new interpreter info.
    //
    NumberParams = pHeader->NumberOfParams;

    NDR64_PARAM_FORMAT* Params = 
        (NDR64_PARAM_FORMAT*)ProcContext.Params;


    //
    // Wrap the unmarshalling, mgr call and marshalling in the try block of
    // a try-finally. Put the free phase in the associated finally block.
    //
    RpcTryFinally
    {
        
        //
        // If OLE, put pThis in first dword of stack.
        //
        if ( pThis )
        {
            *((void **)pArgBuffer) =
                (void *)((CStdStubBuffer *)pThis)->pvServerObject;
        }

        //
        // Initialize the Stub message.
        //
        if ( ! pChannel )
            {
            if ( ! pNdr64Flags->UsesPipes )
               {
                Ndr64ServerInitialize( pRpcMsg,
                                       &StubMsg,
                                       pStubDesc );
               }
            else
                Ndr64ServerInitializePartial( pRpcMsg,
                                            &StubMsg,
                                            pStubDesc,
                                            pHeader->ConstantClientBufferSize );
            }
        else
            {
            NDR_ASSERT( ! pNdr64Flags->UsesPipes, "DCOM pipe is not supported" );
            NdrStubInitialize( pRpcMsg,
                               &StubMsg,
                               pStubDesc,
                               pChannel );
            }   

        //
        // Set up for context handle management.
        //
        StubMsg.SavedContextHandles = CtxtHndl;
        memset( CtxtHndl, 0, sizeof(CtxtHndl) );

 
        pStubMsg->pCorrMemory = pArgBuffer;

        if ( pNdr64Flags->UsesFullPtrPackage )
            StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );

        //
        // Set StackTop AFTER the initialize call, since it zeros the field
        // out.
        //
        StubMsg.StackTop = pArgBuffer;

        if ( pNdr64Flags->UsesPipes )
            NdrpPipesInitialize64( & StubMsg,
                                   &ProcContext.AllocateContext,
                                   (PFORMAT_STRING) Params,
                                   (char*)pArgBuffer,
                                   NumberParams );

        //
        // We must make this check AFTER the call to ServerInitialize,
        // since that routine puts the stub descriptor alloc/dealloc routines
        // into the stub message.
        //
        if ( pNdr64Flags->UsesRpcSmPackage )
            NdrRpcSsEnableAllocate( &StubMsg );

        RpcTryExcept
        {

            // --------------------------------
            // Unmarshall all of our parameters.
            // --------------------------------
            NDR_ASSERT( ProcContext.StartofStack == pArgBuffer, "startofstack is not set" );
            Ndr64pServerUnMarshal( &StubMsg );    
                                    
            if ( pRpcMsg->BufferLength  <
                 (uint)(StubMsg.Buffer - (uchar *)pRpcMsg->Buffer) )
                {
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
                }

            }

        RpcExcept( NdrServerUnmarshallExceptionFlag(GetExceptionInformation()) )
            {
            // Filter set in rpcndr.h to catch one of the following
            //     STATUS_ACCESS_VIOLATION
            //     STATUS_DATATYPE_MISALIGNMENT
            //     RPC_X_BAD_STUB_DATA


            fBadStubDataException = TRUE;
            NdrpFreeMemoryList( &StubMsg );
            if ( RPC_BAD_STUB_DATA_EXCEPTION_FILTER )
                RpcRaiseException( RPC_X_BAD_STUB_DATA );
            else
                RpcRaiseException( RpcExceptionCode() );
            }
        RpcEndExcept

        //
        // Do [out] initialization.
        //
        Ndr64pServerOutInit( pStubMsg );


        //
        // Unblock the first pipe; this needs to be after unmarshalling
        // because the buffer may need to be changed to the secondary one.
        // In the out only pipes case this happens immediately.
        //

        if ( pNdr64Flags->UsesPipes )
            NdrMarkNextActivePipe( ProcContext.pPipeDesc );

        //
        // OLE interfaces use pdwStubPhase in the exception filter.
        // See CStdStubBuffer_Invoke in rpcproxy.c.
        //
        *pdwStubPhase = STUB_CALL_SERVER;

        NotifyAppInvoked = TRUE;
        //
        // Check for a thunk.  Compiler does all the setup for us.
        //
        if ( pServerInfo->ThunkTable && pServerInfo->ThunkTable[ProcNum] )
            {
            pServerInfo->ThunkTable[ProcNum]( &StubMsg );
            }
        else
            {
            //
            // Note that this ArgNum is not the number of arguments declared
            // in the function we called, but really the number of
            // REGISTER_TYPEs occupied by the arguments to a function.
            //
            long                ArgNum;
            MANAGER_FUNCTION    pFunc;
            REGISTER_TYPE           returnValue;

            if ( pRpcMsg->ManagerEpv )
                pFunc = ((MANAGER_FUNCTION *)pRpcMsg->ManagerEpv)[ProcNum];
            else
                pFunc = (MANAGER_FUNCTION) DispatchTable[ProcNum];

            ArgNum = (long) StackSize / sizeof(REGISTER_TYPE);
           
            //
            // The StackSize includes the size of the return. If we want
            // just the number of REGISTER_TYPES, then ArgNum must be reduced
            // by 1 when there is a return value AND the current ArgNum count
            // is greater than 0.
            //
            if ( ArgNum && pNdr64Flags->HasReturn && !pNdr64Flags->HasComplexReturn )
                ArgNum--;

            returnValue = Invoke( pFunc, 
                                  (REGISTER_TYPE *)pArgBuffer,
#if defined(_WIN64)
                                  pHeader->FloatDoubleMask,
#endif
                                  ArgNum);

            if( pNdr64Flags->HasReturn && !pNdr64Flags->HasComplexReturn )
                {
                    ((REGISTER_TYPE *)pArgBuffer)[ArgNum] = returnValue;
                    // Pass the app's return value to OLE channel
                    if ( pThis )
                        (*pfnDcomChannelSetHResult)( pRpcMsg, 
                                                     NULL,   // reserved
                                                     (HRESULT) returnValue );
                }
            }

        *pdwStubPhase = STUB_MARSHAL;

        if ( pNdr64Flags->UsesPipes )
            {
            NdrIsAppDoneWithPipes( ProcContext.pPipeDesc );
            StubMsg.BufferLength += pHeader->ConstantServerBufferSize;
            }
        else
            StubMsg.BufferLength = pHeader->ConstantServerBufferSize;

        if ( pNdr64Flags->ServerMustSize )
            {
            //
            // Buffer size pass.
            //
            Ndr64pSizing( pStubMsg,
                          FALSE );  // IsClient
           }

        if ( pNdr64Flags->UsesPipes && ProcContext.pPipeDesc->OutPipes )
            {
            NdrGetPartialBuffer( & StubMsg );
            StubMsg.RpcMsg->RpcFlags &= ~RPC_BUFFER_PARTIAL;
            }
        else
            {
            if ( ! pChannel )
                {
                Ndr64GetBuffer( &StubMsg,
                              StubMsg.BufferLength );
                }
            else
                NdrStubGetBuffer( pThis,
                                  pChannel,
                                  &StubMsg );
            }

        //
        // Marshall pass.
        //
        Ndr64pServerMarshal ( &StubMsg );
                      

        if ( pRpcMsg->BufferLength <
                 (ulong)(StubMsg.Buffer - (uchar *)pRpcMsg->Buffer) )
            {
            NDR_ASSERT( 0, "Ndr64StubWrok marshal: buffer overflow!" );
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            }

        pRpcMsg->BufferLength = (ulong) ( StubMsg.Buffer - (uchar *) pRpcMsg->Buffer );

#if defined(DEBUG_WALKIP)
        if ( pChannel )
            {
            Ndr64pReleaseMarshalBuffer(
                StubMsg.RpcMsg,
                ProcContext.pSyntaxInfo,
                StubMsg.RpcMsg->ProcNum,
                StubMsg.StubDesc,
                1, //BUFFER_OUT
                true );
            }
#endif        

        }
    RpcFinally
        {
        // clean up context handles if exception is thrown in either marshalling or 
        // manager routine. 

        if ( RpcAbnormalTermination() && ! pChannel )
            {
            Ndr64pCleanupServerContextHandles( &StubMsg,
                                               NumberParams,
                                               Params,
                                               pArgBuffer,
                                               STUB_MARSHAL != *pdwStubPhase);
            }

        // If we died because of bad stub data, don't free the params here since they
        // were freed using a linked list of memory in the exception handler above.

        if ( ! fBadStubDataException  )
            {
            
            Ndr64pFreeParams( &StubMsg,
                            NumberParams,
                            Params,
                            pArgBuffer );
            }


        NdrpAllocaDestroy( &ProcContext.AllocateContext );

        //
        // Deferred frees.  Actually, this should only be necessary if you
        // had a pointer to enum16 in a *_is expression.
        //

        //
        // Free any full pointer resources.
        //
        NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );

        //
        // Disable rpcss allocate package if needed.
        //
        if ( pNdr64Flags->UsesRpcSmPackage )
            NdrRpcSsDisableAllocate( &StubMsg );

        if ( pNdr64Flags->HasNotify )
            {
            NDR_NOTIFY_ROUTINE     pfnNotify;

            // BUGBUG: tests need to be recompiled. 
            pfnNotify =  StubMsg.StubDesc->NotifyRoutineTable[ pHeaderExts->NotifyIndex ];

            ((NDR_NOTIFY2_ROUTINE)pfnNotify)(NotifyAppInvoked);
            }
        
        }
    RpcEndFinally

    return S_OK;
}


void
Ndr64pFreeParams(
    MIDL_STUB_MESSAGE       *       pStubMsg,
    long                            NumberParams,
    NDR64_PARAM_FORMAT      *       Params,
    uchar *                         pArgBuffer 
    )
/*++

Routine Description :

    Frees the memory associated with function parameters as required.

Arguments :

    pStubMsg     - Supplies a pointer to the stub message.
    NumberParams - Supplies the number of parameters for this procedure.
    Params       - Supplies a pointer to the parameter list for this function.
    pArgBuffer   - Supplies a pointer to the virtual stack.
    pParamFilter - Supplies a filter that is used to determine which functions
                   are to be considered.  This function should return TRUE if
                   the parameter should be considered.   If pParamFilter is NULL,
                   the default filter is used which is all parameters that have
                   MustFree set. 

Return :

    None.

--*/
{
    for ( long n = 0; n < NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = 
            ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
        
        if ( ! pParamFlags->MustFree )
            continue;

        uchar *pArg = pArgBuffer + Params[n].StackOffset;

        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar **)pArg);

        if ( pArg )
            {
            pStubMsg->fDontCallFreeInst =
                    pParamFlags->IsDontCallFreeInst;

            Ndr64ToplevelTypeFree( pStubMsg,
                                   pArg,
                                   Params[n].Type );

            }

        //
        // We have to check if we need to free any simple ref pointer,
        // since we skipped it's Ndr64PointerFree call.  We also have
        // to explicitly free arrays and strings.  But make sure it's
        // non-null and not sitting in the buffer.
        //
        if ( pParamFlags->IsSimpleRef ||
             NDR64_IS_ARRAY_OR_STRING(*(PFORMAT_STRING)Params[n].Type) )
            {
            //
            // Don't free [out] params that we're allocated on the
            // interpreter's stack.
            //

            if ( pParamFlags->UseCache )
                continue;

            //
            // We have to make sure the array/string is non-null in case we
            // get an exception before finishing our unmarshalling.
            //
            if ( pArg &&
                 ( (pArg < pStubMsg->BufferStart) ||
                   (pArg > pStubMsg->BufferEnd) ) )
                (*pStubMsg->pfnFree)( pArg );
            }
        } // for
}



void
Ndr64pCleanupServerContextHandles(
    MIDL_STUB_MESSAGE * pStubMsg,
    long                NumberParams,
    NDR64_PARAM_FORMAT* Params,
    uchar *             pArgBuffer,
    BOOL                fManagerRoutineException
    )
/*++

Routine Description :

    Cleans up context handles that might have been dropped by the NDR engine between
    the return from the manager routine and the end of marshaling.

Arguments :

    pStubMsg     - Supplies a pointer to the stub message.
    NumberParams - Supplies the number of parameters for this procedure.
    Params       - Supplies a pointer to the parameter list for this function.
    pArgBuffer   - Supplies a pointer to the virtual stack.

Return :

    None.

--*/
{
    for ( long n = 0; n < NumberParams; n++ )
        {
        NDR64_PARAM_FLAGS   *pParamFlags = 
                                (NDR64_PARAM_FLAGS *) &( Params[n].Attributes );
        
        if ( ! pParamFlags->IsOut  ||  pParamFlags->IsPipe )
            continue;
    
        uchar *pArg = pArgBuffer + Params[n].StackOffset;
    
        if ( ! pParamFlags->IsByValue )
            pArg = *((uchar * UNALIGNED *)pArg);

        NDR64_FORMAT_CHAR FcType = *(PFORMAT_STRING)Params[n].Type;
    
        if ( FcType == FC64_BIND_CONTEXT )
            {
            // NDR64_CONTEXT_HANDLE_FORMAT is the same as PNDR_CONTEXT_HANDLE_ARG_DESC.

            NdrpEmergencyContextCleanup( pStubMsg,
                                         (PNDR_CONTEXT_HANDLE_ARG_DESC ) Params[n].Type,
                                         pArg,
                                         fManagerRoutineException );
            }

        } // for
    }
    
    
    
    void RPC_ENTRY 
    Ndr64pServerUnMarshal ( MIDL_STUB_MESSAGE *     pStubMsg )
    {
        NDR_PROC_CONTEXT    *       pContext = ( NDR_PROC_CONTEXT * )pStubMsg->pContext;
    
    //    if ( (ULONG_PTR)pStubMsg->Buffer & 15 )
    //        RpcRaiseException( RPC_X_INVALID_BUFFER );
    
        NDR64_PARAM_FORMAT  *Params = (NDR64_PARAM_FORMAT *)pContext->Params;
    
        CORRELATION_CONTEXT CorrCtxt( pStubMsg, pContext->StartofStack );
    
       //
        // ----------------------------------------------------------
        // Unmarshall Pass.
        // ----------------------------------------------------------
        //
    
        for ( ulong n = 0; n < pContext->NumberParams; n++ )
            {
            NDR64_PARAM_FLAGS   *pParamFlags = 
                ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
            
    
            if ( ! pParamFlags->IsIn  ||
                 pParamFlags->IsPipe )
                continue;
    
            if ( pParamFlags->IsPartialIgnore )
                {
                uchar *pArg = pContext->StartofStack + Params[n].StackOffset;
            ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
            *(void**)pArg =  *(NDR64_PTR_WIRE_TYPE*)pStubMsg->Buffer ? (void*)1 : (void*)0;
            pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
            continue;
            }
            
        uchar *pArg = pContext->StartofStack + Params[n].StackOffset;

        //
        // This is for returned basetypes and for pointers to
        // basetypes.
        //
        if ( pParamFlags->IsBasetype )
            {
            NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

            //
            // Check for a pointer to a basetype.  Set the arg pointer
            // at the correct buffer location and you're done.
            // Except darn int3264.
            //
            if ( pParamFlags->IsSimpleRef )
                {
                ALIGN( pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( type ) );

                *((uchar **)pArg) = pStubMsg->Buffer;

                pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( type );
                }
            else
                {
                Ndr64SimpleTypeUnmarshall(
                    pStubMsg,
                    pArg,
                    type );
                }

            continue;
            } // IsBasetype

        //
        // This is an initialization of [in] and [in,out] ref pointers
        // to pointers.  These can not be initialized to point into the
        // rpc buffer and we want to avoid doing a malloc of 4 bytes!
        // 32b: a ref pointer to any pointer, we allocate the pointee pointer.
        //
        if ( pParamFlags->UseCache )
            {                      
            *((void **)pArg) = NdrpAlloca( &pContext->AllocateContext, 8);

            // Triple indirection - cool!
            **((void ***)pArg) = 0;
            }
        uchar **ppArg = pParamFlags->IsByValue ? &pArg : (uchar **)pArg;
        

        pStubMsg->ReuseBuffer = pParamFlags->IsForceAllocate;

        Ndr64TopLevelTypeUnmarshall(pStubMsg,
                                    ppArg,
                                    Params[n].Type,
                                    pParamFlags->IsForceAllocate && 
                                        !pParamFlags->IsByValue );

        // force allocate is param attr: reset the flag after each parameter.
        pStubMsg->ReuseBuffer  = FALSE;     
        
        }

    if ( pStubMsg->pCorrInfo )
        Ndr64CorrelationPass( pStubMsg );
   
    if (CheckVerificationTrailer(pStubMsg->Buffer, pStubMsg->BufferEnd, pStubMsg->RpcMsg) == FALSE)
        RpcRaiseException( RPC_S_ACCESS_DENIED );
        
}


#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\srvwrap.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    srvwrap.c

Abstract :

    This file contains the function to dispatch calls to stub worker. 

Author :

    Yong Qu     yongqu      Feb 2000        created
    
Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"

#define CINTERFACE
#define USE_STUBLESS_PROXY

#include "ndrole.h"
#include "rpcproxy.h"
#include "interp2.h"

#include <stdarg.h>

extern long RPC_ENTRY
Ndr64StubWorker(
    IRpcStubBuffer *     pThis,
    IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE         pRpcMsg,
    MIDL_SERVER_INFO   * pServerInfo,
    const SERVER_ROUTINE *     DispatchTable,
    MIDL_SYNTAX_INFO *   pSyntaxInfo,  
    ulong *              pdwStubPhase
    );

RPCRTAPI
void RPC_ENTRY
NdrServerCallNdr64(
    PRPC_MESSAGE    pRpcMsg
    )
/*++

Routine Description :

    Server Interpreter entry point for regular RPC procs.

Arguments :

    pRpcMsg     - The RPC message.

Return :

    None.

--*/
{
    ulong dwStubPhase = STUB_UNMARSHAL;
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    const SERVER_ROUTINE  * DispatchTable;
    NDR_PROC_CONTEXT        ProcContext;   
    MIDL_SYNTAX_INFO *      pSyntaxInfo;
    
    pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
    pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
    DispatchTable = pServerInfo->DispatchTable;
    pSyntaxInfo = &pServerInfo->pSyntaxInfo[0];

    NDR_ASSERT( XFER_SYNTAX_NDR64 == NdrpGetSyntaxType(&pSyntaxInfo->TransferSyntax),
                " invalid transfer syntax" );
                
    Ndr64StubWorker( 0,
                     0,
                     pRpcMsg,
                     pServerInfo,
                     DispatchTable,
                     pSyntaxInfo,
                     &dwStubPhase );
}

RPCRTAPI
void RPC_ENTRY
NdrServerCallAll(
    PRPC_MESSAGE    pRpcMsg
    )
{
    ulong dwStubPhase = STUB_UNMARSHAL;
    PRPC_SERVER_INTERFACE   pServerIfInfo;
    PMIDL_SERVER_INFO       pServerInfo;
    const SERVER_ROUTINE  * DispatchTable;
    NDR_PROC_CONTEXT        ProcContext;   
    MIDL_SYNTAX_INFO *      pSyntaxInfo;

    pServerIfInfo = (PRPC_SERVER_INTERFACE)pRpcMsg->RpcInterfaceInformation;
    pServerInfo = (PMIDL_SERVER_INFO)pServerIfInfo->InterpreterInfo;
    DispatchTable = pServerInfo->DispatchTable;
    // assuming the default transfer syntax is DCE, NDR64 is the second syntaxinfo.
    pSyntaxInfo = &pServerInfo->pSyntaxInfo[1];

    NDR_ASSERT( XFER_SYNTAX_NDR64 == NdrpGetSyntaxType(&pSyntaxInfo->TransferSyntax),
                " invalid transfer syntax" );
    
    Ndr64StubWorker( 0,
                     0,
                     pRpcMsg,
                     pServerInfo,
                     DispatchTable,
                     pSyntaxInfo,
                     &dwStubPhase );
    
}


long RPC_ENTRY
NdrStubCall3(
    struct IRpcStubBuffer *     pThis,
    struct IRpcChannelBuffer *  pChannel,
    PRPC_MESSAGE                pRpcMsg,
    ulong *                     pdwStubPhase
    )
{
    IUnknown *              pSrvObj;
    CInterfaceStubVtbl *    pStubVTable;
    PMIDL_SERVER_INFO       pServerInfo;
    const SERVER_ROUTINE  * DispatchTable;
    SYNTAX_TYPE             SyntaxType;
    long                    i;
    MIDL_SYNTAX_INFO *      pSyntaxInfo = NULL;

    if ( NULL == pRpcMsg->TransferSyntax ||
         NdrpGetSyntaxType( pRpcMsg->TransferSyntax ) == XFER_SYNTAX_DCE )
        return NdrStubCall2( pThis, pChannel, pRpcMsg, pdwStubPhase );
        
    pSrvObj = (IUnknown * )((CStdStubBuffer *)pThis)->pvServerObject;

    DispatchTable = (SERVER_ROUTINE *)pSrvObj->lpVtbl;

    pStubVTable = (CInterfaceStubVtbl *)
                  (*((uchar **)pThis) - sizeof(CInterfaceStubHeader));

    pServerInfo = (PMIDL_SERVER_INFO) pStubVTable->header.pServerInfo;

    for ( i = 0; i < (long)pServerInfo->nCount; i++ )
        {
        if ( NdrpGetSyntaxType( &pServerInfo->pSyntaxInfo[i].TransferSyntax ) == XFER_SYNTAX_NDR64 )
            {
            pSyntaxInfo = &pServerInfo->pSyntaxInfo[i];
            break;
            }
        }

    if ( NULL == pSyntaxInfo )
        return HRESULT_FROM_WIN32( RPC_S_UNSUPPORTED_TRANS_SYN );

    return 
    Ndr64StubWorker( pThis,
                     pChannel,
                     pRpcMsg,
                     pServerInfo,
                     DispatchTable,
                     pSyntaxInfo,
                     pdwStubPhase );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\proxy.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994 Microsoft Corporation.  All rights reserved.

Module Name:
    proxy.c

Abstract:
    Implements the IRpcProxyBuffer interface.

Author:
    ShannonC    12-Oct-1994

Environment:
    Windows NT and Windows 95 and PowerMac.
    We do not support DOS, Win16 and Mac.

Revision History:

--*/

#include "precomp.hxx"

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include <ndrole.h>
#include <rpcproxy.h>
#include <stddef.h>



CStdProxyBuffer * RPC_ENTRY
NdrGetProxyBuffer(
    void *pThis);
#pragma code_seg(".ndr64")


void RPC_ENTRY
Ndr64ProxyInitialize(
    IN  void * pThis,
    IN  PRPC_MESSAGE                    pRpcMsg,
    IN  PMIDL_STUB_MESSAGE              pStubMsg,
    IN  PMIDL_STUBLESS_PROXY_INFO       pProxyInfo,
    IN  unsigned int                    ProcNum )
/*++

Routine Description:
    Initialize the MIDL_STUB_MESSAGE.

Arguments:
    pThis - Supplies a pointer to the interface proxy.
    pRpcMsg
        pStubMsg
        pStubDescriptor
        ProcNum

Return Value:

--*/
{
    CStdProxyBuffer *   pProxyBuffer;
    HRESULT             hr;

    pProxyBuffer = NdrGetProxyBuffer(pThis);

    //
    // Initialize the stub message fields.
    //
    pStubMsg->dwStubPhase = PROXY_CALCSIZE;

    Ndr64ClientInitialize(
        pRpcMsg,
        pStubMsg,
        pProxyInfo,
        ProcNum );

    //Note that NdrClientInitializeNew sets RPC_FLAGS_VALID_BIT in the ProcNum.
    //We don't want to do this for object interfaces, so we clear the flag here.
    pRpcMsg->ProcNum &= ~RPC_FLAGS_VALID_BIT;

    pStubMsg->pRpcChannelBuffer = pProxyBuffer->pChannel;

    //Check if we are connected to a channel.
    if(pStubMsg->pRpcChannelBuffer != 0)
    {
        //AddRef the channel.
        //We will release it later in NdrProxyFreeBuffer.
        pStubMsg->pRpcChannelBuffer->lpVtbl->AddRef(pStubMsg->pRpcChannelBuffer);

        //Get the destination context from the channel
        hr = pStubMsg->pRpcChannelBuffer->lpVtbl->GetDestCtx(
            pStubMsg->pRpcChannelBuffer, &pStubMsg->dwDestContext, &pStubMsg->pvDestContext);
    }
    else
    {
        //We are not connected to a channel.
        RpcRaiseException(CO_E_OBJNOTCONNECTED);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\pointer.h ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    pointer.h

Abstract :

    This file contains the routines for handling pointers and pointer
    layouts.
    
Author :

    Mike Zoran  mzoran   January 2000.

Revision History :

  ---------------------------------------------------------------------*/

#include "ndrp.h"

#if !defined(__POINTER_H__)
#define  __POINTER_H__

void
Ndr64pPointerLayoutMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer );

void
Ndr64pPointerLayoutMarshallInternal( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer );

void
Ndr64pPointerLayoutUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory,
    uchar *             pBuffer );

void
Ndr64pPointerLayoutMemorySize (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pBuffer );

void 
Ndr64pPointerLayoutBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory );

void 
Ndr64pPointerLayoutFree( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat,
    NDR64_UINT32        ArrayIterations,
    uchar *             pMemory );

void 
Ndr64pPointerMarshall( 
    PMIDL_STUB_MESSAGE  pStubMsg, 
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    uchar *             pMemory, 
    PNDR64_FORMAT       pFormat
    );

void 
Ndr64pPointerMemorySize( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE *pBufferMark,
    PNDR64_FORMAT       pFormat
    );

void
Ndr64pPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE WirePtr,
    uchar **            ppMemory,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat 
    );


void
Ndr64pPointerBufferSize ( 
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat
    );

__forceinline ulong 
Ndr64pWirePtrToRefId(
        NDR64_PTR_WIRE_TYPE WireRef )
    {

    if ( WireRef > 0x7FFFFFFF )
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        return 0;
        }

    return (ulong)WireRef;
    }

__forceinline NDR64_PTR_WIRE_TYPE
Ndr64pRefIdToWirePtr(
        ulong RefId )
    {
    // Check if wire ref will fit in a 2GB number.
    
    if ( RefId > 0x7FFFFFFF )
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        return 0;
        }
    return (NDR64_PTR_WIRE_TYPE)RefId;
    }

__forceinline BOOL
Ndr64pFullPointerQueryPointer( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    void *                  pPointer,
    uchar                   QueryType,
    ulong *                 pRefId )
{

    return (BOOL)
    NdrFullPointerQueryPointer( pStubMsg->FullPtrXlatTables,
                                pPointer,
                                QueryType,
                                pRefId );
        
}


__forceinline BOOL
Ndr64pFullPointerQueryRefId( 
    PMIDL_STUB_MESSAGE      pStubMsg,
    ulong                   RefId,
    uchar                   QueryType,
    void **                 ppPointer )
    {

    return (BOOL)
    NdrFullPointerQueryRefId( pStubMsg->FullPtrXlatTables,
                              RefId,
                              QueryType,
                              ppPointer );

    }

__forceinline void
Ndr64pFullPointerInsertRefId(
    PMIDL_STUB_MESSAGE     pStubMsg,
    ulong                  RefId,
    void *                 pPointer )
    {
    
    NdrFullPointerInsertRefId( pStubMsg->FullPtrXlatTables,
                               RefId,
                               pPointer );

    }

#define FULL_POINTER_INSERT( pStubMsg, Pointer )    \
                { \
                Ndr64pFullPointerInsertRefId( pStubMsg, \
                                           pStubMsg->FullPtrRefId, \
                                           Pointer ); \
 \
                pStubMsg->FullPtrRefId = 0; \
                }

#endif // __POINTER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\relmrl.cxx ===
/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 1998 - 2000 Microsoft Corporation

Module Name :

    relmrl.c

Abstract :

    This file contains release of Marshaled Data (called before unmarshal).

Author :

    Yong Qu (yongqu@microsoft.com) Nov 1998

Revision History :

  ---------------------------------------------------------------------*/

#include "precomp.hxx"

#define USE_STUBLESS_PROXY
#define CINTERFACE

#include "ndrole.h"
#include "rpcproxy.h"
#include "hndl.h"
#include "interp2.h"
#include "pipendr.h"
#include "expr.h"

#include <stddef.h>
#include <stdarg.h>


/* client side: we only care about the [in] part. 
   it's basically like unmarshal on the server side, just that
   we immediately free the buffer (virtual stack) after unmarshalling.
   The call it not necessary always OLE call: one side raw RPC and 
   the other side OLE call is possible: do we support this?

   mostly code from NdrStubCall2, remove irrelavant code. 
*/

#define IN_BUFFER           0
#define OUT_BUFFER          1

#define IsSameDir(dwFlags,paramflag) ((dwFlags == IN_BUFFER)? paramflag->IsIn :paramflag->IsOut)

HRESULT Ndr64pReleaseMarshalBuffer(
        RPC_MESSAGE *               pRpcMsg,
        PMIDL_SYNTAX_INFO           pSyntaxInfo, 
        unsigned long               ProcNum, 
        PMIDL_STUB_DESC             pStubDesc,
        DWORD                       dwFlags,
        BOOLEAN fServer )
{
    ushort		            StackSize;
    MIDL_STUB_MESSAGE       StubMsg;

    NDR64_PARAM_FORMAT *    Params;
    long                    NumberParams;

    long                    n;
    HRESULT                 hr = S_OK;

    uchar *             pBuffer;
    PFORMAT_STRING      pFormatTypes;
    long		        FormatOffset;
    PFORMAT_STRING	    pFormat;
    NDR_PROC_CONTEXT    ProcContext;
    NDR64_PROC_FLAGS    *   pNdr64Flags;
    NDR64_PROC_FORMAT   *   pHeader = NULL;
    NDR64_PARAM_FLAGS   *       pParamFlags;

    
    NDR_ASSERT( ! ((ULONG_PTR)pRpcMsg->Buffer & 0x7),
                "marshaling buffer misaligned at server" );

    pFormat      = NdrpGetProcString( pSyntaxInfo,
                                      XFER_SYNTAX_NDR64,
                                      ProcNum );

    Ndr64ServerInitialize(pRpcMsg,&StubMsg,pStubDesc);
    StubMsg.fHasExtensions  = 1;
    StubMsg.fHasNewCorrDesc = 1;
    pFormatTypes = pSyntaxInfo->TypeString;

    pHeader = (NDR64_PROC_FORMAT *) pFormat;
    pNdr64Flags = (NDR64_PROC_FLAGS *) & (pHeader->Flags );

    NumberParams = pHeader->NumberOfParams;

    if ( pNdr64Flags->UsesFullPtrPackage )
        StubMsg.FullPtrXlatTables = NdrFullPointerXlatInit( 0, XLAT_SERVER );
    
    Params = (NDR64_PARAM_FORMAT *)( (char *) pFormat + sizeof( NDR64_PROC_FORMAT ) + pHeader->ExtensionSize );

    // Save the original buffer pointer to restore later.
    pBuffer = StubMsg.Buffer;

    // Get the type format string.
    RpcTryFinally
    {
    
        RpcTryExcept
        {
        //
        // Check if we need to do any walking .
        //

        NDR64_SET_WALKIP(StubMsg.uFlags);
                   
        for ( n = 0; n < NumberParams; n++ )
            {
            pParamFlags = ( NDR64_PARAM_FLAGS * ) & ( Params[n].Attributes );
            
            if ( ( dwFlags == IN_BUFFER ) &&
                 ( pParamFlags->IsPartialIgnore ) )
                {
                PMIDL_STUB_MESSAGE pStubMsg = &StubMsg;
                // Skip the boolean pointer in the buffer
                ALIGN( StubMsg.Buffer, NDR64_PTR_WIRE_ALIGN );
                StubMsg.Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
                CHECK_EOB_RAISE_BSD( StubMsg.Buffer );
                continue;
                } 

            if ( ! IsSameDir(dwFlags,pParamFlags) )
                continue;
                    
            if ( pParamFlags->IsBasetype )
                {
                NDR64_FORMAT_CHAR type = *(PFORMAT_STRING)Params[n].Type;

                ALIGN( StubMsg.Buffer, NDR64_SIMPLE_TYPE_BUFALIGN( type ) );
                StubMsg.Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( type );
                }
            else
                {
                //
                // Complex type or pointer to complex type.
                //   

                Ndr64TopLevelTypeMemorySize( &StubMsg,
                                             Params[n].Type );
                }
            
            }
        }
        RpcExcept( EXCEPTION_EXECUTE_HANDLER )
        {
             hr = HRESULT_FROM_WIN32(RpcExceptionCode());
        }
        RpcEndExcept

    }
    RpcFinally
    {
        NdrFullPointerXlatFree( StubMsg.FullPtrXlatTables );
        
        StubMsg.Buffer = pBuffer;
    }
    RpcEndFinally
    
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\ndr64\unmrshl.cxx ===
/**********************************************************************

Copyright (c) 1993-2000 Microsoft Corporation

Module Name :

    unmrshl.cxx

Abstract :

    This file contains the unmarshalling routines called by MIDL generated
    stubs and the interpreter.

Author :

    David Kays  dkays   September 1993.

Revision History :

  **********************************************************************/

#include "precomp.hxx"

#include "..\..\ndr20\ndrole.h"


void 
Ndr64UDTSimpleTypeUnmarshall1(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
{

    //
    // Align the buffer.
    //
    ALIGN( pStubMsg->Buffer, NDR64_SIMPLE_TYPE_BUFALIGN(*(PFORMAT_STRING)pFormat) );

    // Initialize the memory pointer if needed.
    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, 
                                           NDR64_SIMPLE_TYPE_MEMSIZE(*(PFORMAT_STRING)pFormat) );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        // Set pointer into buffer.
        *ppMemory = pStubMsg->Buffer;
        }

    Ndr64SimpleTypeUnmarshall( pStubMsg,
                               *ppMemory,
                               *(PFORMAT_STRING)pFormat );
}


void 
Ndr64SimpleTypeUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    uchar               FormatChar )
/*++

Routine Description :

    Unmarshalls a simple type.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Memory pointer to unmarshall into.
    FormatChar  - Simple type format character.

Return :

    None.

--*/
{
    switch ( FormatChar )
        {
        case FC64_CHAR :
        case FC64_UINT8 :
        case FC64_INT8 :
            *pMemory = *(pStubMsg->Buffer)++;
            break;

        case FC64_WCHAR :
        case FC64_UINT16 :
        case FC64_INT16 :
            ALIGN(pStubMsg->Buffer,1);

            *((NDR64_UINT16 *)pMemory) = *((NDR64_UINT16 *)pStubMsg->Buffer);
            pStubMsg->Buffer += sizeof(NDR64_UINT16);
            break;

        case FC64_INT32 :
        case FC64_UINT32 :
        case FC64_FLOAT32 :
        case FC64_ERROR_STATUS_T:
            ALIGN(pStubMsg->Buffer,3);

            *((NDR64_UINT32 *)pMemory) = *((NDR64_UINT32 *)pStubMsg->Buffer);
            pStubMsg->Buffer += sizeof(NDR64_UINT32);
            break;
        
        case FC64_UINT64 :
        case FC64_INT64 :
        case FC64_FLOAT64 :
            ALIGN(pStubMsg->Buffer,7);
            *((NDR64_UINT64 *)pMemory) = *((NDR64_UINT64 *)pStubMsg->Buffer);
            pStubMsg->Buffer += sizeof(NDR64_UINT64);
            break;

        case FC64_IGNORE :
            break;

        default :
            NDR_ASSERT(0,"Ndr64SimpleTypeUnmarshall : bad format char");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }
}


void 
Ndr64RangeUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++
    Unmarshals a range FC64_RANGE descriptor.
--*/
{
     const NDR64_RANGE_FORMAT * pRangeFormat =
        (const NDR64_RANGE_FORMAT*)pFormat;
     
     Ndr64UDTSimpleTypeUnmarshall1( pStubMsg,
                                    ppMemory,
                                    (PNDR64_FORMAT)&pRangeFormat->RangeType,
                                    fMustAlloc );

     EXPR_VALUE Value = Ndr64pSimpleTypeToExprValue( pRangeFormat->RangeType, *ppMemory ); 

     if ( Value < (EXPR_VALUE)pRangeFormat->MinValue || 
          Value > (EXPR_VALUE)pRangeFormat->MaxValue )
         RpcRaiseException( RPC_X_INVALID_BOUND );

}


IUnknown *
Ndr64pInterfacePointerUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    PNDR64_FORMAT       pFormat)
/*++

Routine Description :

    Unmarshalls an interface pointer.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pFormat     - Interface pointer's format string description.

Return :

    None.

Notes : Here is the data representation.

    // wire representation of a marshalled interface pointer
    typedef struct tagMInterfacePointer
    {
        ULONG           ulCntData;          // size of data
        [size_is(ulCntData)] BYTE abData[]; // data (OBJREF)
    } MInterfacePointer;
    
--*/
{
    const NDR64_CONSTANT_IID_FORMAT *pConstInterfaceFormat =
        (NDR64_CONSTANT_IID_FORMAT*)pFormat;
    const NDR64_IID_FORMAT *pInterfaceFormat =
        (NDR64_IID_FORMAT*)pFormat;
       
    // Unmarshal the conformant size and the count field.
    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, (sizeof(NDR64_WIRE_COUNT_TYPE)+sizeof(ulong)) );
    
    NDR64_UINT32 MaxCount = Ndr64pConvertTo2GB( *(NDR64_WIRE_COUNT_TYPE *) pStubMsg->Buffer );
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
    ulong ulCntData = *(ulong *) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(ulong);

    if ( MaxCount != ulCntData )
        {
        RpcRaiseException( RPC_X_BAD_STUB_DATA );
        return NULL;
        }


    if ( !MaxCount )
        {
        return NULL;
        }

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, MaxCount );
        
    // Get a pointer to the IID hidden in the interface pointer
    // representation in the buffer with Rick's IRpcHelper.
    //
    IID *piidValue;
    NdrpGetIIDFromBuffer( pStubMsg, & piidValue );

    //
    // Validate the IID.
    //
    if ( ((NDR64_IID_FLAGS*)&pConstInterfaceFormat->Flags)->ConstantIID )
        {
        if ( memcmp( &pConstInterfaceFormat->Guid,
                     piidValue,
                     sizeof(GUID)) != 0) 
            {
            RpcRaiseException( RPC_X_BAD_STUB_DATA );
            return NULL;
            }
        }
    else
        {

        Ndr64pCheckCorrelation(pStubMsg,
                               (EXPR_VALUE)piidValue,
                               pInterfaceFormat->IIDDescriptor,
                               EXPR_IID
                               );
        }

    IStream *pStream = (*NdrpCreateStreamOnMemory)(pStubMsg->Buffer, MaxCount);
    if(pStream == 0)
        {
        RpcRaiseException(RPC_S_OUT_OF_MEMORY);
        return NULL;
        }

    IUnknown *      punk = NULL;
    HRESULT hr = (*pfnCoUnmarshalInterface)(pStream, IID_NULL, (void**)&punk );
    pStream->Release();

    if(FAILED(hr))
        {
        RpcRaiseException(hr);
        return NULL;
        }

    pStubMsg->Buffer += MaxCount;

    return punk;
}



class FINDONTFREE_CONTEXT
{
    PMIDL_STUB_MESSAGE const pStubMsg;
    const int fInDontFreeSave;
public:
    __forceinline FINDONTFREE_CONTEXT( PMIDL_STUB_MESSAGE pStubMsg ) :
        pStubMsg( pStubMsg ),
        fInDontFreeSave(pStubMsg->fInDontFree)
    {}
    __forceinline FINDONTFREE_CONTEXT( PMIDL_STUB_MESSAGE pStubMsg,
                         int fInDontFree ) :
        pStubMsg( pStubMsg ),
        fInDontFreeSave(pStubMsg->fInDontFree)
    {
        pStubMsg->fInDontFree = fInDontFree;
    }
    __forceinline ~FINDONTFREE_CONTEXT()
    {
        pStubMsg->fInDontFree = fInDontFreeSave;
    }
};

void
Ndr64pFreeOlePointer(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar *            pMemory,
    PNDR64_FORMAT      pFormat )
{
    
    NDR_POINTER_QUEUE *pOldQueue = NULL;
    if ( pStubMsg->pPointerQueueState )
        {
        pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
        pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
        }

    RpcTryFinally
        {
        Ndr64PointerFree( pStubMsg,
                        pMemory,
                        pFormat );
        }
    RpcFinally
        {
        if ( pStubMsg->pPointerQueueState )
            {
            pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
            }
        }
    RpcEndFinally

}

NDR_ALLOC_ALL_NODES_CONTEXT *
Ndr64pGetAllocateAllNodesContext(
    PMIDL_STUB_MESSAGE pStubMsg,
    PNDR64_FORMAT      pFormat )
{
    uchar *pBuffer = pStubMsg->Buffer;

    // Clear memory size before calling mem size routine.
    pStubMsg->MemorySize = 0;

    //
    // Get the allocate all nodes memory size.
    //
    {
        NDR_POINTER_QUEUE *pOldQueue = NULL; 

        if (pStubMsg->pPointerQueueState)
            {
            pOldQueue = pStubMsg->pPointerQueueState->GetActiveQueue();
            pStubMsg->pPointerQueueState->SetActiveQueue(NULL);
            }

        RpcTryFinally
            {
            Ndr64TopLevelTypeMemorySize( pStubMsg,
                                         pFormat );
            }
        RpcFinally
            {
            if ( pStubMsg->pPointerQueueState )
                {
                pStubMsg->pPointerQueueState->SetActiveQueue( pOldQueue );
                }
            }
        RpcEndFinally


    }

    ulong AllocSize = pStubMsg->MemorySize;
    pStubMsg->MemorySize = 0;
    LENGTH_ALIGN( AllocSize, __alignof(NDR_ALLOC_ALL_NODES_CONTEXT) - 1);

    uchar *pAllocMemory = 
        (uchar*)NdrAllocate( pStubMsg, AllocSize + sizeof(NDR_ALLOC_ALL_NODES_CONTEXT) );

    NDR_ALLOC_ALL_NODES_CONTEXT *pAllocContext = 
        (NDR_ALLOC_ALL_NODES_CONTEXT*)(pAllocMemory + AllocSize);
    pAllocContext->AllocAllNodesMemory      = pAllocMemory;
    pAllocContext->AllocAllNodesMemoryBegin = pAllocMemory;
    pAllocContext->AllocAllNodesMemoryEnd   = (uchar*)pAllocContext;

    pStubMsg->Buffer = pBuffer;

    return pAllocContext;
}

__forceinline void
Ndr64pPointerUnmarshallInternal(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE WirePtr,
    uchar **            ppMemory,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
/*++

Routine Description :

    Private routine for unmarshalling a pointer to anything.  This is the
    entry point for pointers embedded in structures, arrays, and unions.

    Used for FC64_RP, FC64_UP, FC64_FP, FC64_OP.

Arguments :

    pStubMsg        - Pointer to the stub message.
    ppBufferPointer - Address of the location in the buffer which holds the
                      incomming pointer's value and will hold the final
                      unmarshalled pointer's value.
    pMemory         - Current memory pointer's value which we want to
                      unmarshall into.  If this value is valid the it will
                      be copied to *ppBufferPointer and this is where stuff
                      will get unmarshalled into.
    pFormat         - Pointer's format string description.

    pStubMsg->Buffer - set to the pointee.

Return :

    None.

--*/
{

    const NDR64_POINTER_FORMAT *pPointerFormat = (NDR64_POINTER_FORMAT*) pFormat;
    bool        fPointeeAlloc;
    bool        fNewAllocAllNodes = false;

    // make sure we are not out out of bound. We need this check for embedded pointers / pointer 
    // to pointer cases. 
    CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );
    
    SAVE_CONTEXT<ulong> FullPtrRefIdSave( pStubMsg->FullPtrRefId );
    FINDONTFREE_CONTEXT fInDontFreeSave( pStubMsg );

    if ( NDR64_IS_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags) )
        {
        pMemory = 0;
        }

    //
    // Check the pointer type.
    //
    switch ( *(PFORMAT_STRING)pFormat )
        {
        case FC64_RP :
            break;

        case FC64_OP :
            //
            // Burn some instructions for OLE unique pointer support.
            //
            if ( pStubMsg->IsClient )
                {
                //
                // It's ok if this is an [out] unique pointer.  It will get
                // zeroed before this routine is called and Ndr64PointerFree
                // will simply return.
                //
                Ndr64pFreeOlePointer( 
                    pStubMsg,
                    pMemory,
                    pFormat );

                // Set the current memory pointer to 0 so that we'll alloc.
                pMemory = 0;
                }

            // Fall through.

        case FC64_UP :
            //
            // Check for a null incomming pointer.  Routines which call this
            // routine insure that the memory pointer gets nulled.
            //
            if ( ! WirePtr )
                {
                *ppMemory = NULL;
                return;
                }

            break;

        case FC64_IP:

            if ( pStubMsg->IsClient )
                {
                Ndr64PointerFree( pStubMsg,
                                pMemory,
                                pFormat );

                pMemory = 0;
                }

            if ( ! WirePtr )
                {
                *ppMemory = NULL;
                return;
                }
           
            *(IUnknown **)ppMemory =  (IUnknown*)
              Ndr64pInterfacePointerUnmarshall( pStubMsg,
                                                pPointerFormat->Pointee
                                                );

            return;


        case FC64_FP :
            {
                //
                // We have to remember the incomming ref id because we overwrite
                // it during the QueryRefId call.
                //
                ulong FullPtrRefId = 
                    Ndr64pWirePtrToRefId( WirePtr );

    			if ( !FullPtrRefId )
    			    {
    				*ppMemory = NULL;
    				return;
    			    }

                //
                // Lookup the ref id.
                //
                if ( Ndr64pFullPointerQueryRefId( pStubMsg,
                                                  FullPtrRefId,
                                                  FULL_POINTER_UNMARSHALLED,
                                                  (void**)ppMemory ) )
                    {
                    return;
                    }

                //
                // If our query returned false then check if the returned pointer
                // is 0.  If so then we have to scribble away the ref id in the
                // stub message FullPtrRefId field so that we can insert the
                // pointer translation later, after we've allocated the pointer.
                // If the returned pointer was non-null then we leave the stub
                // message FullPtrRefId field alone so that we don't try to
                // re-insert the pointer to ref id translation later.
                //
                // We also copy the returned pointer value into pMemory.  This
                // will allow our allocation decision to be made correctly.
                //
                if ( ! ( pMemory = *ppMemory ) )
                    {
                    //
                    // Put the unmarshalled ref id into the stub message to
                    // be used later in a call to Ndr64FullPointerInsertRefId.
                    //
                    pStubMsg->FullPtrRefId = FullPtrRefId;
                    }
            }
            break;

        default :
            NDR_ASSERT(0,"Ndr64pPointerUnmarshall : bad pointer type");
            RpcRaiseException( RPC_S_INTERNAL_ERROR );
            return;
        }

    //
    // Make the initial "must allocate" decision.
    //
    // The fPointeeAlloc flag is set on the client side if the current memory
    // pointer is null, and on the server side it is set if the current memory
    // pointer has the allocate don't free attribute applied to it.
    //
    // On the client side we also set the pointer's value in the buffer equal
    // to the current memory pointer.
    //
    // On the server side we explicitly null out the pointer's value in the
    // buffer as long as it's not allocated on the stack, otherwise we set it
    // equal to the current memory pointer (stack allocated).
    //
    if ( pStubMsg->IsClient )
        {
        *ppMemory = pMemory;

        fPointeeAlloc = ! pMemory;
        }
    else
        {
        if ( ! NDR64_ALLOCED_ON_STACK( pPointerFormat->Flags ) )
            *ppMemory = 0;
        else
            *ppMemory = pMemory;

        //
        // If this is a don't free pointer or a parent pointer of this pointer
        // was a don't free pointer then we set the alloc flag.
        //
        if ( fPointeeAlloc = (NDR64_DONT_FREE( pPointerFormat->Flags ) || 
                             pStubMsg->fInDontFree || 
                             pStubMsg->ReuseBuffer ) )
            {
            pStubMsg->fInDontFree = TRUE;
            }

        //
        // We also set the alloc flag for object interface pointers.
        //
        if ( *(PFORMAT_STRING)pFormat == FC64_OP )
            fPointeeAlloc = true;

        }
    //
    // Check if this is an allocate all nodes pointer AND that we're
    // not already in an allocate all nodes context.
    //
    if ( NDR64_ALLOCATE_ALL_NODES( pPointerFormat->Flags ) && ! pStubMsg->pAllocAllNodesContext )
        {
        fNewAllocAllNodes = true;

        pStubMsg->pAllocAllNodesContext =
            Ndr64pGetAllocateAllNodesContext( 
                pStubMsg,
                pPointerFormat->Pointee );
        *ppMemory = 0;

        fPointeeAlloc = true;

        }

    if ( NDR64_POINTER_DEREF( pPointerFormat->Flags ) )
        {
        //
        // Re-align the buffer.  This is to cover embedded pointer to
        // pointers.
        //
        ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );

        //
        // We can't re-use the buffer for a pointer to a pointer
        // because we can't null out the pointee before we've unmarshalled
        // it.  We need the stubs to alloc pointers to pointers on the
        // stack.
        //
        if ( ! *ppMemory && ! pStubMsg->IsClient )
            fPointeeAlloc = true;

        if ( fPointeeAlloc )
            {
            *ppMemory = (uchar*)NdrAllocate( pStubMsg, PTR_MEM_SIZE );
            *((void **)*ppMemory) = 0;
            }

        if ( pStubMsg->FullPtrRefId )
            FULL_POINTER_INSERT( pStubMsg, *ppMemory );

        ppMemory = (uchar **) *ppMemory;
        }
    
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    NDR64_RESET_EMBEDDED_FLAGS_TO_STANDALONE(pStubMsg->uFlags);
    if ( fPointeeAlloc )
        NDR64_SET_SKIP_REF_CHECK( pStubMsg->uFlags );

    PNDR64_FORMAT pPointee = pPointerFormat->Pointee;
    if ( NDR64_IS_SIMPLE_TYPE( *(PFORMAT_STRING)pPointee) )
        {
        ALIGN(pStubMsg->Buffer,NDR64_SIMPLE_TYPE_BUFALIGN(*(PFORMAT_STRING)pPointee) );
    
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer + 
                NDR64_SIMPLE_TYPE_BUFSIZE( *(PFORMAT_STRING)pPointee ) );
        
        }
    // we don't need to check for buffer over run here. For non simple types,
    // unmarshal routines have checks available; for pointer to pointer, we have
    // the check at the beginning of this routine; and for pointer to simple types,
    // we'll unmarshal in place, but that's in current pStubMsg->Buffer, which is
    // covered by the above check too. 
    Ndr64TopLevelTypeUnmarshall(
         pStubMsg,
         ppMemory,
         pPointerFormat->Pointee,
         fPointeeAlloc );

    // Insert full pointer to ref id translation if needed.
    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    //
    // Reset the memory allocator and allocate all nodes flag if this was
    // an allocate all nodes case.
    //
    if ( fNewAllocAllNodes )
        {
        pStubMsg->pAllocAllNodesContext = 0;
        }

}

NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT::NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT( 
    MIDL_STUB_MESSAGE *pStubMsg,
    uchar **            ppMemoryNew,      
    uchar *             pMemoryNew,
    NDR64_PTR_WIRE_TYPE WirePtrNew,
    PFORMAT_STRING      pFormatNew )  :

    WirePtr(WirePtrNew),
    ppMemory(ppMemoryNew),
    pMemory(pMemoryNew),
    pFormat(pFormatNew),
    pCorrMemory(pStubMsg->pCorrMemory),
    pAllocAllNodesContext(pStubMsg->pAllocAllNodesContext),
    fInDontFree(pStubMsg->fInDontFree),
    uFlags(pStubMsg->uFlags)    
{

}

void NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT::Dispatch( PMIDL_STUB_MESSAGE pStubMsg )
{

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pCorrMemory );
    SAVE_CONTEXT<NDR_ALLOC_ALL_NODES_CONTEXT*> 
        AllocNodesSave(pStubMsg->pAllocAllNodesContext,pAllocAllNodesContext ); 
    FINDONTFREE_CONTEXT fInDoneFreeSave( pStubMsg, fInDontFree );
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags, uFlags );

    Ndr64pPointerUnmarshallInternal(
        pStubMsg,
        WirePtr,
        ppMemory,
        pMemory,
        pFormat );

}

#if defined(DBG)
void NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT::Print()
{
    DbgPrint("NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT:\n");
    DbgPrint("pNext:                   %p\n", pNext );
    DbgPrint("WirePtr:                 %I64u\n", WirePtr ); 
    DbgPrint("ppMemory:                %p\n", ppMemory );
    DbgPrint("pMemory:                 %p\n", pMemory );
    DbgPrint("pFormat:                 %p\n", pFormat );
    DbgPrint("pCorrMemory:             %p\n", pCorrMemory );
    DbgPrint("pAllocAllNodesContext:   %p\n", pAllocAllNodesContext );
    DbgPrint("fInDontFree:             %u\n", fInDontFree );
    DbgPrint("uFlags:                  %u\n", uFlags );
}
#endif

void
Ndr64pEnquePointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE WirePtr,
    uchar **            ppMemory,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    NDR64_POINTER_CONTEXT PointerContext( pStubMsg );

    RpcTryFinally
        {
        NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT*pElement = 
            new(pStubMsg->pPointerQueueState) 
                NDR64_UNMRSHL_POINTER_QUEUE_ELEMENT(pStubMsg,
                                                    ppMemory,
                                                    pMemory,
                                                    WirePtr,
                                                    (PFORMAT_STRING)pFormat );
        PointerContext.Enque( pElement );
        PointerContext.DispatchIfRequired();
        }
    RpcFinally
        {
        PointerContext.EndContext();
        }
    RpcEndFinally

}

void
Ndr64pPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    NDR64_PTR_WIRE_TYPE WirePtr,
    uchar **            ppMemory,
    uchar *             pMemory,
    PNDR64_FORMAT       pFormat )
{

    if ( !NdrIsLowStack( pStubMsg ) )
        {
        Ndr64pPointerUnmarshallInternal(
            pStubMsg,
            WirePtr,
            ppMemory,
            pMemory,
            pFormat );
        return;
        }

    Ndr64pEnquePointerUnmarshall(
        pStubMsg,
        WirePtr,
        ppMemory,
        pMemory,
        pFormat );

}

__forceinline void
Ndr64EmbeddedPointerUnmarshall(
    PMIDL_STUB_MESSAGE pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                /*fSkipRefCheck*/ )
{

    ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
    NDR64_PTR_WIRE_TYPE WirePtr = *(NDR64_PTR_WIRE_TYPE*) pStubMsg->Buffer;
    pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);

    POINTER_BUFFER_SWAP_CONTEXT SwapContext(pStubMsg);

    Ndr64pPointerUnmarshall( pStubMsg,
                             WirePtr,
                             *(uchar***)ppMemory,
                             **(uchar***)ppMemory,
                             pFormat );
}

__forceinline void
Ndr64TopLevelPointerUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                /* fSkipRefCheck */)
{
    if ( *(PFORMAT_STRING)pFormat != FC64_RP )
        {
        ALIGN( pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN );
        NDR64_PTR_WIRE_TYPE WirePtr = *(NDR64_PTR_WIRE_TYPE*) pStubMsg->Buffer;
        pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);

        Ndr64pPointerUnmarshall( pStubMsg,
                                 WirePtr,
                                 ppMemory,
                                 *ppMemory,
                                 pFormat );
        return;
        }
    
    //
    // If we're on the client unmarshalling a top level [out] ref pointer,
    // we have to make sure that it is non-null.

    if ( pStubMsg->IsClient && 
         !NDR64_IS_SKIP_REF_CHECK( pStubMsg->uFlags ) &&
         ! *ppMemory )
        RpcRaiseException( RPC_X_NULL_REF_POINTER );


    Ndr64pPointerUnmarshall( pStubMsg,
                             0,
                             ppMemory,
                             *ppMemory,
                             pFormat );
}


void 
Ndr64SimpleStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a simple structure.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to the structure being unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - TRUE if the structure must be allocate, FALSE otherwise.

--*/
{
    const NDR64_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    
    // Align the buffer.
    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment);

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, pStructFormat->MemorySize );

    uchar *pBufferSave = pStubMsg->Buffer;

    pStubMsg->Buffer += pStructFormat->MemorySize;

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, pStructFormat->MemorySize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        *ppMemory = pBufferSave;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    if ( pStructFormat->Flags.HasPointerInfo )
        {
        
        CORRELATION_CONTEXT CorrCtxt( pStubMsg, pBufferSave ); 
        
        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pStructFormat + 1,
                                       0,
                                       *ppMemory,
                                       pBufferSave );
        }

    // Copy the struct if we're not using the rpc buffer.
    if ( *ppMemory != pBufferSave )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferSave,
                        pStructFormat->MemorySize );
        }
}


void 
Ndr64ConformantStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a conformant structure.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - TRUE if the structure must be allocate, FALSE otherwise.

Return :

    None.

--*/
{
    const NDR64_CONF_STRUCTURE_HEADER_FORMAT * const pStructFormat =
        (NDR64_CONF_STRUCTURE_HEADER_FORMAT*) pFormat;
    
    const NDR64_CONF_ARRAY_HEADER_FORMAT * const pArrayFormat =  
        (NDR64_CONF_ARRAY_HEADER_FORMAT *) pStructFormat->ArrayDescription;

    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags );
    
    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align the buffer for unmarshalling the conformance count.
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);
        MaxCount = *((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else 
        MaxCount = *((NDR64_WIRE_COUNT_TYPE *)pStubMsg->ConformanceMark);

    // Re-align the buffer
    ALIGN(pStubMsg->Buffer, pStructFormat->Alignment );

    uchar *pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_RAISE_IB( pBufferStart + pStructFormat->MemorySize );

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pBufferStart );
    
    Ndr64pCheckCorrelation( pStubMsg,
                          MaxCount,
                          pArrayFormat->ConfDescriptor,
                          EXPR_MAXCOUNT );
    
    NDR64_UINT32 StructSize =  pStructFormat->MemorySize + Ndr64pMultiplyUpTo2GB(
                                                   MaxCount , pArrayFormat->ElementSize ) ;

    CHECK_EOB_WITH_WRAP_RAISE_IB( pBufferStart, StructSize );

    pStubMsg->Buffer += StructSize;

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, StructSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        *ppMemory = pBufferStart;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    if ( pStructFormat->Flags.HasPointerInfo )
        {
        
        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pStructFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       *ppMemory,
                                       pBufferStart );

        }
    
    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        StructSize );
        }

}


void 
Ndr64ComplexStructUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a complex structure.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the structure should be unmarshalled.
    pFormat     - Structure's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    const NDR64_BOGUS_STRUCTURE_HEADER_FORMAT *  pStructFormat =
        (NDR64_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;
    const NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT * pConfStructFormat =
        (NDR64_CONF_BOGUS_STRUCTURE_HEADER_FORMAT*) pFormat;

    bool fSetPointerBufferMark = !pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {
        uchar *pBufferSave = pStubMsg->Buffer;
        BOOL fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;
        pStubMsg->MemorySize = 0;

        Ndr64ComplexStructMemorySize( 
            pStubMsg,
            pFormat );

        // check buffer overrun for flat part of the struct.
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );    
        
        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        pStubMsg->Buffer = pBufferSave;

        }

    uchar *         pMemory;
    PFORMAT_STRING  pFormatPointers = (PFORMAT_STRING)pStructFormat->PointerLayout;
    PFORMAT_STRING  pFormatArray    = NULL;

    bool            fIsFullBogus    = ( *(PFORMAT_STRING)pFormat == FC64_BOGUS_STRUCT ||
                                        *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT );

    PFORMAT_STRING  pMemberLayout =  ( *(PFORMAT_STRING)pFormat == FC64_CONF_BOGUS_STRUCT ||
                                       *(PFORMAT_STRING)pFormat == FC64_FORCED_CONF_BOGUS_STRUCT ) ?
                                     (PFORMAT_STRING)( pConfStructFormat + 1) :
                                     (PFORMAT_STRING)( pStructFormat + 1);

    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
    SAVE_CONTEXT<uchar>  uFlagsSave( pStubMsg->uFlags );
    
    // Get conformant array description.
    if ( pStructFormat->Flags.HasConfArray )
        {
        pFormatArray = (PFORMAT_STRING)pConfStructFormat->ConfArrayDescription;
        }

    //
    // Now check if there is a conformant array and mark where the conformance
    // will be unmarshalled from.
    //

    if ( pFormatArray && !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

        pStubMsg->ConformanceMark = pStubMsg->Buffer;

        //
        // Increment the buffer pointer for every dimension in the
        // conformant array.
        //
        pStubMsg->Buffer += pConfStructFormat->Dimensions * sizeof(NDR64_WIRE_COUNT_TYPE);

        NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );


        }

    // Align the buffer on the struct's alignment.
    ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );

    bool fMustCopy;
    if ( fMustAlloc || ( fIsFullBogus && ! *ppMemory ) )
        {
        NDR64_UINT32    StructSize =
            Ndr64pMemorySize( pStubMsg,
                              pFormat,
                              TRUE );        

        *ppMemory = (uchar*)NdrAllocate( pStubMsg, StructSize );

        memset( *ppMemory, 0, StructSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION( pStubMsg->uFlags );

        fMustCopy = true;

        }
    else if ( ! *ppMemory )
        {
        *ppMemory = pStubMsg->Buffer;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION( pStubMsg->uFlags );
        fMustCopy = false;
        }
    else
		// reuse the clients memory
        fMustCopy = true;

    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    // Get the beginning memory pointer.
    pMemory = *ppMemory;

    CORRELATION_CONTEXT CorrCtxt( pStubMsg, pMemory );
    
    for ( ; ; )
        {
        switch ( *pMemberLayout )
            {

            case FC64_STRUCT:
                {
                const NDR64_SIMPLE_REGION_FORMAT *pRegion = 
                    (NDR64_SIMPLE_REGION_FORMAT*) pMemberLayout;
                
                ALIGN( pStubMsg->Buffer, pRegion->Alignment );
                
                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , pRegion->RegionSize );

                if ( fMustCopy )
                    RpcpMemoryCopy( pMemory,
                                    pStubMsg->Buffer,
                                    pRegion->RegionSize );

                pStubMsg->Buffer += pRegion->RegionSize;
                pMemory          += pRegion->RegionSize;

                pMemberLayout    += sizeof( *pRegion );
                break;
                }

            case FC64_STRUCTPADN :
                {
                const NDR64_MEMPAD_FORMAT *pMemPad = (NDR64_MEMPAD_FORMAT*)pMemberLayout;
                pMemory       += pMemPad->MemPad;
                pMemberLayout += sizeof(*pMemPad);
                break;
                }

            case FC64_POINTER :
                {

                Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                             &pMemory,
                                             pFormatPointers );
                
                pMemory += PTR_MEM_SIZE;

                pFormatPointers += sizeof(NDR64_POINTER_FORMAT);
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);                
                break;
                
                }

            case FC64_EMBEDDED_COMPLEX :
                {
                
                const NDR64_EMBEDDED_COMPLEX_FORMAT * pEmbeddedFormat =
                    (NDR64_EMBEDDED_COMPLEX_FORMAT*) pMemberLayout;

                Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                             &pMemory,
                                             pEmbeddedFormat->Type );

                pMemory = Ndr64pMemoryIncrement( pStubMsg,
                                               pMemory,
                                               pEmbeddedFormat->Type,
                                               TRUE );

                pMemberLayout += sizeof(*pEmbeddedFormat);
                break;
                }

            case FC64_BUFFER_ALIGN:
                {
                const NDR64_BUFFER_ALIGN_FORMAT *pBufAlign = 
                    (NDR64_BUFFER_ALIGN_FORMAT*) pMemberLayout;
                ALIGN( pStubMsg->Buffer, pBufAlign->Alignment );
                pMemberLayout += sizeof( *pBufAlign );
                break;
                }

            case FC64_CHAR :
            case FC64_WCHAR :
            case FC64_INT8:
            case FC64_UINT8:
            case FC64_INT16:
            case FC64_UINT16:
            case FC64_INT32:
            case FC64_UINT32:
            case FC64_INT64:
            case FC64_UINT64:
            case FC64_FLOAT32 :
            case FC64_FLOAT64 :
            case FC64_ERROR_STATUS_T:
                Ndr64SimpleTypeUnmarshall( pStubMsg,
                                           pMemory,
                                           *pMemberLayout );

                pMemory += NDR64_SIMPLE_TYPE_MEMSIZE(*pMemberLayout);
                pMemberLayout       += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);                                
                break;                    

            case FC64_IGNORE :
                ALIGN(pStubMsg->Buffer, NDR64_PTR_WIRE_ALIGN);
                pStubMsg->Buffer += sizeof(NDR64_PTR_WIRE_TYPE);
                if ( NDR64_IS_NEW_EMBEDDED_ALLOCATION( pStubMsg->uFlags ) ) 
                    {
                    *(char**)pMemory = (char*)0;
                    }
                pMemory          += PTR_MEM_SIZE;
                pMemberLayout    += sizeof(NDR64_SIMPLE_MEMBER_FORMAT);                                
                break;

            case FC64_END :                
                goto ComplexUnmarshallEnd;

            default :
                NDR_ASSERT(0,"Ndr64ComplexStructUnmarshall : bad format char");
                RpcRaiseException( RPC_S_INTERNAL_ERROR );
                return;
            }
        }

ComplexUnmarshallEnd:

    if ( pFormatArray )
        {

        Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                     &pMemory,
                                     pFormatArray );

        }
    else 
        {
        // If the structure doesn't have a conformant array, align it again
        ALIGN( pStubMsg->Buffer, pStructFormat->Alignment );
        }

    if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        }

} 

void
Ndr64pCommonStringUnmarshall(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    uchar **                            ppMemory,
    const NDR64_STRING_HEADER_FORMAT    *pStringFormat,
    bool                                fMustAlloc,
    NDR64_UINT32                        MemorySize )
{
    ALIGN(pStubMsg->Buffer,NDR64_WIRE_COUNT_ALIGN);
   
    NDR64_WIRE_COUNT_TYPE  Offset   = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE  Count    = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 TransmittedSize = 
        Ndr64pMultiplyUpTo2GB( Count, pStringFormat->ElementSize );
    
    if ( ( Offset != 0 ) ||  
         ( 0 == Count ) || 
         ( TransmittedSize > MemorySize ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, TransmittedSize );

    // In this code, we check that a terminator is 
    // where the marshaller tells us it is.   We could check
    // if another terminator exists in addition to the other 
    // terminator, but it doesn't make sense to do this
    // since it wouldn't close any attacks.

    switch( pStringFormat->FormatCode )
        {
        case FC64_CHAR_STRING:
        case FC64_CONF_CHAR_STRING: 
            {
            char *p = (char *) pStubMsg->Buffer;
            NDR64_WIRE_COUNT_TYPE ActualChars = Count - 1;

            if ( '\0' != p[ActualChars] )
                 {
                 RpcRaiseException( RPC_X_INVALID_BOUND );
                 return;
                 }
            break;            
            }
        case FC64_WCHAR_STRING:
        case FC64_CONF_WCHAR_STRING:            
            {
            wchar_t *p = ( wchar_t* ) pStubMsg->Buffer;
            NDR64_WIRE_COUNT_TYPE ActualChars = Count - 1;
            
            if ( L'\0' != p[ActualChars] )
                {
                RpcRaiseException( RPC_X_INVALID_BOUND );
                return;
                }
            break;            
            }
        case FC64_STRUCT_STRING:
        case FC64_CONF_STRUCT_STRING:
            {
            NDR64_UINT8 *p = (NDR64_UINT8 *) pStubMsg->Buffer;
            NDR64_WIRE_COUNT_TYPE ActualChars = Count - 1;
            NDR64_UINT32 ElementSize = pStringFormat->ElementSize;
            NDR64_UINT8 *t = p + Ndr64pMultiplyUpTo2GB( ActualChars , ElementSize );

            if ( !Ndr64pIsStructStringTerminator( t, ElementSize ) )
                {
                RpcRaiseException( RPC_X_INVALID_BOUND );
                return;
                }
            break;
            }
        }
    
    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, MemorySize );
        }
    else if ( ! *ppMemory ) 
        {

        *ppMemory = ( TransmittedSize == MemorySize ) ? pStubMsg->Buffer :
                                                        (uchar *) NdrAllocate( pStubMsg, MemorySize );
        }

    if ( *ppMemory != pStubMsg->Buffer )
        {
        RpcpMemoryCopy( *ppMemory,
            pStubMsg->Buffer,
            TransmittedSize );
        }
    
    pStubMsg->Buffer += TransmittedSize;

    return;
}


void 
Ndr64NonConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a non conformant string.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Double pointer to the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{

    const NDR64_NON_CONFORMANT_STRING_FORMAT * pStringFormat = 
        (NDR64_NON_CONFORMANT_STRING_FORMAT*) pFormat;

    Ndr64pCommonStringUnmarshall( pStubMsg,
                                  ppMemory,
                                  &pStringFormat->Header,
                                  fMustAlloc,
                                  pStringFormat->TotalSize );


}


void 
Ndr64ConformantStringUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine description :

    Unmarshalls a top level conformant string.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the string should be unmarshalled.
    pFormat     - String's format string description.
    fMustAlloc  - TRUE if the string must be allocated, FALSE otherwise.

Return :

    None.

--*/
{

    const NDR64_CONFORMANT_STRING_FORMAT * pStringFormat =
        (const NDR64_CONFORMANT_STRING_FORMAT*) pFormat;    
    const NDR64_SIZED_CONFORMANT_STRING_FORMAT *pSizedStringFormat =
        (const NDR64_SIZED_CONFORMANT_STRING_FORMAT*) pFormat;

    NDR64_WIRE_COUNT_TYPE    MaxCount;
    if ( !NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );        
        MaxCount =  *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else
        {
        MaxCount =  *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    NDR64_UINT32 AllocationSize = 
        Ndr64pMultiplyUpTo2GB( MaxCount ,
                            pStringFormat->Header.ElementSize );

    if ( pStringFormat->Header.Flags.IsSized )
        {
        Ndr64pCheckCorrelation( pStubMsg,
                                MaxCount,
                                pSizedStringFormat->SizeDescription,
                                EXPR_MAXCOUNT );
        }
    
    return
    Ndr64pCommonStringUnmarshall( pStubMsg,
                                  ppMemory,
                                  &pStringFormat->Header,
                                  fMustAlloc,
                                  AllocationSize );
    
} 


void 
Ndr64FixedArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls a fixed array of any number of dimensions.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array to unmarshall.
    pFormat     - Array's format string description.
    fMustAlloc  - TRUE if the array must be allocated, FALSE otherwise.

Return :

    None.

--*/
{
    const NDR64_FIX_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_FIX_ARRAY_HEADER_FORMAT*) pFormat;
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment );

    uchar *pBufferStart = pStubMsg->Buffer;

    CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer , pArrayFormat->TotalSize );

    pStubMsg->Buffer += pArrayFormat->TotalSize;

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, pArrayFormat->TotalSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        *ppMemory = pBufferStart;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    if ( pArrayFormat->Flags.HasPointerInfo )
        {
        
        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                               pArrayFormat + 1,
                               0,
                               *ppMemory,
                               pBufferStart );
        }

    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        pArrayFormat->TotalSize );
        }
}


void 
Ndr64ConformantArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level one dimensional conformant array.

    Used for FC64_CARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to array to be unmarshalled.
    pFormat     - Array's format string description.

Return :

    None.

--*/
{
    const NDR64_CONF_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_CONF_ARRAY_HEADER_FORMAT*) pFormat;
        
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );

    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {        
        // Align the buffer for conformance marshalling.
        ALIGN(pStubMsg->Buffer,NDR64_WIRE_COUNT_ALIGN);
        MaxCount = *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);
        }
    else 
        {
        MaxCount = *pStubMsg->ConformanceMark;
        }

    NDR64_UINT32 CopySize = 
        Ndr64pMultiplyUpTo2GB( MaxCount , pArrayFormat->ElementSize );

    Ndr64pCheckCorrelation( pStubMsg,
                            MaxCount,
                            pArrayFormat->ConfDescriptor,
                            EXPR_MAXCOUNT );

    ALIGN( pStubMsg->Buffer, pArrayFormat->Alignment );
    uchar *pBufferStart =  pStubMsg->Buffer;
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize);
    pStubMsg->Buffer    += CopySize;    // Unmarshall embedded pointers.

    if ( fMustAlloc )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, CopySize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }
    else if ( !*ppMemory )
        {
        *ppMemory = pBufferStart;
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)MaxCount,
                                       *ppMemory,
                                       pBufferStart );
        }

    if ( *ppMemory != pBufferStart )
        {
        RpcpMemoryCopy( *ppMemory,
                        pBufferStart,
                        CopySize );
        }
}


void 
Ndr64ConformantVaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )          
/*++

Routine Description :

    Unmarshalls a top level one dimensional conformant varying array.

    Used for FC64_CVARRAY.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    const NDR64_CONF_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_CONF_VAR_ARRAY_HEADER_FORMAT*) pFormat;
    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags);

    NDR64_WIRE_COUNT_TYPE MaxCount;
    if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
        {
        // Align the buffer for conformance unmarshalling.
        ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

        MaxCount = *((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer);
        pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE);

        }
    else 
        {
        MaxCount = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
        }

    ALIGN( pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );
    NDR64_WIRE_COUNT_TYPE Offset = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 AllocSize   = Ndr64pMultiplyUpTo2GB( MaxCount , pArrayFormat->ElementSize );
    NDR64_UINT32 CopySize    = Ndr64pMultiplyUpTo2GB( ActualCount , pArrayFormat->ElementSize );

    if ( ( Offset != 0 ) ||
         ActualCount > MaxCount )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    Ndr64pCheckCorrelation( pStubMsg,
                            MaxCount,
                            pArrayFormat->ConfDescriptor,
                            EXPR_MAXCOUNT );

    Ndr64pCheckCorrelation( pStubMsg,
                            ActualCount,
                            pArrayFormat->VarDescriptor,
                            EXPR_ACTUALCOUNT );

    //
    // For a conformant varying array, we can't reuse the buffer
    // because it doesn't hold the total size of the array.

    if ( fMustAlloc || !*ppMemory )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, AllocSize );
        memset( *ppMemory, 0, AllocSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    ALIGN( pStubMsg->Buffer, pArrayFormat->Alignment );
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize);
    
    uchar *pBufferStart =  pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;
    
    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       *ppMemory,
                                       pBufferStart );
        }
    
     RpcpMemoryCopy( *ppMemory,
                     pBufferStart,
                     CopySize );
}


void 
Ndr64VaryingArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls top level or embedded a one dimensional varying array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    pMemory     - Array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

--*/
{
    
    const NDR64_VAR_ARRAY_HEADER_FORMAT * pArrayFormat =
        (NDR64_VAR_ARRAY_HEADER_FORMAT*) pFormat;

    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );
    ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

    NDR64_WIRE_COUNT_TYPE Offset = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[0];
    NDR64_WIRE_COUNT_TYPE ActualCount = ((NDR64_WIRE_COUNT_TYPE *)pStubMsg->Buffer)[1];
    pStubMsg->Buffer += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

    NDR64_UINT32 CopySize    
        = Ndr64pMultiplyUpTo2GB( ActualCount , pArrayFormat->ElementSize );

    if ( ( Offset != 0 ) ||
         ( CopySize > pArrayFormat->TotalSize ) )
        RpcRaiseException( RPC_X_INVALID_BOUND );

    Ndr64pCheckCorrelation( pStubMsg,
                          ActualCount,
                          pArrayFormat->VarDescriptor,
                          EXPR_ACTUALCOUNT );

    if ( fMustAlloc || !*ppMemory )
        {
        *ppMemory = (uchar *) NdrAllocate( pStubMsg, pArrayFormat->TotalSize );
        memset( *ppMemory, 0, pArrayFormat->TotalSize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment );
    CHECK_EOB_WITH_WRAP_RAISE_IB( pStubMsg->Buffer, CopySize );
    uchar *pBufferStart = pStubMsg->Buffer;
    pStubMsg->Buffer += CopySize;

    if ( pArrayFormat->Flags.HasPointerInfo )
        {

        Ndr64pPointerLayoutUnmarshall( pStubMsg,
                                       pArrayFormat + 1,
                                       (NDR64_UINT32)ActualCount,
                                       *ppMemory,
                                       pBufferStart );
        }

    RpcpMemoryCopy( *ppMemory,
                    pBufferStart,
                    CopySize );
}


void 
Ndr64ComplexArrayUnmarshall(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls a top level complex array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Pointer to the array being unmarshalled.
    pFormat     - Array's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    const NDR64_BOGUS_ARRAY_HEADER_FORMAT *pArrayFormat =
        (NDR64_BOGUS_ARRAY_HEADER_FORMAT *) pFormat;
        
    bool fSetPointerBufferMark = ! pStubMsg->PointerBufferMark;
    if ( fSetPointerBufferMark )
        {
        uchar *pBuffer = pStubMsg->Buffer;
        BOOL fOldIgnore = pStubMsg->IgnoreEmbeddedPointers;
        pStubMsg->IgnoreEmbeddedPointers = TRUE;
        pStubMsg->MemorySize = 0;


        Ndr64ComplexArrayMemorySize( 
            pStubMsg,
            pFormat );

        // make sure we haven't overflow for the flat part.
        CHECK_EOB_RAISE_BSD( pStubMsg->Buffer );    

        pStubMsg->PointerBufferMark = pStubMsg->Buffer;
        pStubMsg->IgnoreEmbeddedPointers = fOldIgnore;
        pStubMsg->Buffer = pBuffer;
        }

    BOOL                IsFixed = ( pArrayFormat->FormatCode == FC64_FIX_BOGUS_ARRAY ) ||
                                  ( pArrayFormat->FormatCode == FC64_FIX_FORCED_BOGUS_ARRAY );

    SAVE_CONTEXT<uchar> uFlagsSave(pStubMsg->uFlags);
    SAVE_CONTEXT<uchar*> ConformanceMarkSave( pStubMsg->ConformanceMark );
    SAVE_CONTEXT<uchar*> VarianceMarkSave( pStubMsg->VarianceMark );

    PFORMAT_STRING      pElementFormat = (PFORMAT_STRING)pArrayFormat->Element;

    NDR64_WIRE_COUNT_TYPE   Elements = pArrayFormat->NumberElements;
    NDR64_WIRE_COUNT_TYPE   Count = Elements;
    NDR64_WIRE_COUNT_TYPE   Offset   = 0;

    if ( !IsFixed )
        {

        const NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT* pConfVarFormat=
             (NDR64_CONF_VAR_BOGUS_ARRAY_HEADER_FORMAT*)pFormat;

        //
        // Check for conformance description.
        //
        if ( pConfVarFormat->ConfDescription )
            {

            if ( ! NDR64_IS_CONF_MARK_VALID( pStubMsg->uFlags ) )
                {
                //
                // Outer most dimension sets the conformance marker.
                //

                // Align the buffer for conformance marshalling.
                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN);

                // Mark where the conformance count(s) will be marshalled.
                pStubMsg->ConformanceMark = pStubMsg->Buffer;

                // Increment past where the conformance will go.
                NDR64_UINT32 ConfSize =  pArrayFormat->NumberDims*sizeof(NDR64_WIRE_COUNT_TYPE) ;
                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, ConfSize);
                pStubMsg->Buffer += ConfSize;

                NDR64_SET_CONF_MARK_VALID( pStubMsg->uFlags );

                }

            Elements = *(NDR64_WIRE_COUNT_TYPE*)pStubMsg->ConformanceMark;
            pStubMsg->ConformanceMark += sizeof(NDR64_WIRE_COUNT_TYPE);

            Ndr64pCheckCorrelation( pStubMsg,
                                   Elements,
                                   pConfVarFormat->ConfDescription,
                                   EXPR_MAXCOUNT );

            Offset = 0;
            Count  = Elements;

            }

        //
        // Check for variance description.
        //
        if ( pConfVarFormat->VarDescription )
            {
            if ( ! NDR64_IS_VAR_MARK_VALID( pStubMsg->uFlags ) )
                {
                NDR64_UINT32 Dimensions;

                ALIGN(pStubMsg->Buffer, NDR64_WIRE_COUNT_ALIGN );

                Dimensions = ( pArrayFormat->Flags.IsArrayofStrings ) ? ( pArrayFormat->NumberDims - 1) :
                                                                        ( pArrayFormat->NumberDims );

                pStubMsg->VarianceMark = pStubMsg->Buffer;

                NDR64_UINT32 VaryingSize = Dimensions *  sizeof(NDR64_WIRE_COUNT_TYPE) * 2 ;
                CHECK_EOB_WITH_WRAP_RAISE_BSD( pStubMsg->Buffer, VaryingSize);
                pStubMsg->Buffer += VaryingSize;

                if ( NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                    NDR64_SET_VAR_MARK_VALID( pStubMsg->uFlags );
                
                }
            else if ( !NDR64_IS_ARRAY_OR_STRING( *pElementFormat ) )
                NDR64_RESET_VAR_MARK_VALID( pStubMsg->uFlags );

            Offset = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[0];
            Count  = ((NDR64_WIRE_COUNT_TYPE*)pStubMsg->VarianceMark)[1];
            pStubMsg->VarianceMark += sizeof(NDR64_WIRE_COUNT_TYPE) * 2;

            Ndr64pCheckCorrelation( pStubMsg,
                                    Count,
                                    pConfVarFormat->VarDescription,
                                    EXPR_ACTUALCOUNT );

            Ndr64pCheckCorrelation( pStubMsg,
                                    Offset,
                                    pConfVarFormat->OffsetDescription,
                                    EXPR_OFFSET );

            }
        
        }

    NDR64_UINT32 ElementMemorySize =
        Ndr64pMemorySize( pStubMsg,
                          pElementFormat,
                          TRUE );

    NDR64_UINT32 ArraySize = Ndr64pMultiplyUpTo2GB( Elements , ElementMemorySize );
    Ndr64pMultiplyUpTo2GB( Count , ElementMemorySize );


    if ( fMustAlloc || ! *ppMemory )
        {
        *ppMemory = (uchar*)NdrAllocate( pStubMsg, (uint) ArraySize );
        memset( *ppMemory, 0, ArraySize );
        NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);
        }

    if ( pStubMsg->FullPtrRefId )
        FULL_POINTER_INSERT( pStubMsg, *ppMemory );

    uchar *pMemory = *ppMemory;

    pMemory += Ndr64pMultiplyUpTo2GB(Offset , ElementMemorySize);
    
    ALIGN(pStubMsg->Buffer, pArrayFormat->Alignment);

    for( ; Count--; )
        {
        
        Ndr64EmbeddedTypeUnmarshall( pStubMsg,
                                     &pMemory,
                                     pElementFormat );
        
        pMemory += ElementMemorySize;

        }

     if ( fSetPointerBufferMark )
        {
        pStubMsg->Buffer = pStubMsg->PointerBufferMark;
        pStubMsg->PointerBufferMark = 0;
        }

}


void 
Ndr64UnionUnmarshall (
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar **            ppMemory,
    PNDR64_FORMAT       pFormat,
    bool                fMustAlloc )
/*++

Routine Description :

    Unmarshalls an encapsulated array.

Arguments :

    pStubMsg    - Pointer to the stub message.
    ppMemory    - Double pointer to where the union should be unmarshalled.
    pFormat     - Union's format string description.
    fMustAlloc  - Ignored.

Return :

    None.

--*/
{
    const NDR64_UNION_ARM_SELECTOR* pArmSelector;
    SAVE_CONTEXT<uchar> uFlagsSave( pStubMsg->uFlags );

    EXPR_VALUE          SwitchIs;
    uchar*              pArmMemory;

    switch(*(PFORMAT_STRING)pFormat)
    {
    case FC64_NON_ENCAPSULATED_UNION:
        {
        const NDR64_NON_ENCAPSULATED_UNION* pNonEncapUnionFormat =
            (const NDR64_NON_ENCAPSULATED_UNION*) pFormat;


        ALIGN(pStubMsg->Buffer, pNonEncapUnionFormat->Alignment);
        pArmSelector    = (NDR64_UNION_ARM_SELECTOR*)(pNonEncapUnionFormat + 1);

        if ( fMustAlloc || ! *ppMemory )
            {
            *ppMemory = (uchar*)NdrAllocate( pStubMsg, pNonEncapUnionFormat->MemorySize );

            //
            // We must zero out all of the new memory in case there are pointers
            // in any of the arms.
            //
            MIDL_memset( *ppMemory, 0, pNonEncapUnionFormat->MemorySize );
            NDR64_SET_NEW_EMBEDDED_ALLOCATION(pStubMsg->uFlags);

            }

        SwitchIs = Ndr64pSimpleTypeToExprValue( pNonEncapUnionFormat->SwitchType,
                                                pStubMsg->Buffer );

        pStubMsg->Buffer += NDR64_SIMPLE_TYPE_BUFSIZE( pNonEncapUnionFormat->SwitchType );
        
        Ndr64pCheckCorrelation( pStubMsg,
                                SwitchIs,
                                pNonEncapUnionFormat->Switch,
                                EXPR_SWITCHIS );

        pArmMemory = *ppMemory;

        break;
        }
    case FC64_ENCAPSULATED_UNION:
        {
        const NDR64_ENCAPSULATED_UNION* pEncapU